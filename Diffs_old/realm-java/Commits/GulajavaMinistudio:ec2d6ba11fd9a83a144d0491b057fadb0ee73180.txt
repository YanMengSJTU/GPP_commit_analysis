diff --git a/.gitignore b/.gitignore
index 483d1a7ced..2e810308be 100644
--- a/.gitignore
+++ b/.gitignore
@@ -13,6 +13,7 @@ local.properties
 core
 core-*
 realm-sync-android-*
+!realm/realm-library/src/main/java/io/realm/internal/core/
 
 # Android Studio
 .idea
diff --git a/CHANGELOG.md b/CHANGELOG.md
index ade6fbc4ff..44d2937f5d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,13 +1,35 @@
-## 5.6.0 (YYYY-MM-DD)
-
-### Enhancements
+## 5.7.0 (2017-09-24)
+
+## Enhancements
+* [ObjectServer] Devices will now report download progress for read-only Realms which 
+  will allow the server to compact files sooner, saving server space. This does not affect 
+  the client. You will need to upgrade your Realm Object Server to at least version 3.11.0 
+  or use [Realm Cloud](https://cloud.realm.io). If you try to connect to a ROS v3.10.x or 
+  previous, you will see an error like `Wrong protocol version in Sync HTTP request, 
+  client protocol version = 25, server protocol version = 24`.
+  
+### Compatibility
+* File format: ver. 7 (upgrades automatically from previous formats)
+* Realm Object Server: 3.11.0 or later.
+* APIs are backwards compatible with all previous release of realm-java in the 5.x.y series.
 
-* `@RealmClass("name")` and `@RealmField("name")` can now be used as a shorthand for defining custom name mappings (#6145).
+### Internal
+* Sync Protocol version increased to 25.
+* Updated Realm Sync to 3.10.1
+* Updated Realm Core to 5.10.2
 
 
-## 5.5.1 (YYYY-MM-DD)
+## 5.6.0 (2018-09-24)
 
 ### Enhancements
+* [ObjectServer] Added `RealmPermissions.findOrCreate(String roleName)` and
+  `ClassPermissions.findOrCreate(String roleName)` ([#6168](https://github.com/realm/realm-java/issues/6168)).
+* `@RealmClass("name")` and `@RealmField("name")` can now be used as a shorthand for defining custom
+  name mappings ([#6145](https://github.com/realm/realm-java/issues/6145)).
+* Added support for `RealmQuery.limit(long limit)` ([#544](https://github.com/realm/realm-java/issues/544)).
+  When building a `RealmQuery`, `sort()`, `distinct()` and `limit()` will now be applied in the order
+  they are called. Before this release, `sort()`  and `distinct()` could be called any order, but
+  `sort()` would always be applied before `distinct()`.
 * Building with Android App Bundle is now supported ([#5977](https://github.com/realm/realm-java/issues/5977)).
 
 ### Fixes
@@ -20,6 +42,7 @@
 
 ### Internal
 * Updated ReLinker to 1.3.0.
+* Updated to Object Store commit: 7e19c51af72c3343b453b8a13c82dfda148e4bbc
 
 
 ## 5.5.0 (2018-08-31)
diff --git a/build.gradle b/build.gradle
index 87999ef4df..2ff457c052 100644
--- a/build.gradle
+++ b/build.gradle
@@ -392,7 +392,7 @@ task bintrayRealm(type: GradleBuild) {
     description = 'Publish the Realm AAR and AP to Bintray'
     group = 'Publishing'
     buildFile = file('realm/build.gradle')
-    tasks = ['bintrayUpload']
+    tasks = ['bintrayUploadAll']
     startParameter.projectProperties = gradle.startParameter.projectProperties
     if (project.hasProperty('buildTargetABIs')) {
         startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
diff --git a/dependencies.list b/dependencies.list
index 9a517e46ef..d3e23b5bd8 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,11 +1,11 @@
 # Realm Sync Core release used by Realm Java
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=3.9.4
-REALM_SYNC_SHA256=f5f52093270c8d26a4b6ba3790c05425d89786033aa6d061fd74e9a24ecb22d7
+REALM_SYNC_VERSION=3.10.1
+REALM_SYNC_SHA256=df8fb8506a318faf83e027a442e5ad0a38f458ec44567146e64d5a1c60b424ae
 
 # Object Server Release used by Integration tests. Installed using NPM.
 # Use `npm view realm-object-server versions` to get a list of available versions.
-REALM_OBJECT_SERVER_VERSION=3.9.9
+REALM_OBJECT_SERVER_VERSION=3.11.1
 
 # Common Android settings across projects
 GRADLE_BUILD_TOOLS=3.1.4
diff --git a/examples/gradle/wrapper/gradle-wrapper.jar b/examples/gradle/wrapper/gradle-wrapper.jar
index 0d4a951687..1948b9074f 100644
Binary files a/examples/gradle/wrapper/gradle-wrapper.jar and b/examples/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.jar b/gradle-plugin/gradle/wrapper/gradle-wrapper.jar
index 99340b4ad1..1948b9074f 100644
Binary files a/gradle-plugin/gradle/wrapper/gradle-wrapper.jar and b/gradle-plugin/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
index bd24854fe8..7dc503f149 100644
--- a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 99340b4ad1..1948b9074f 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index bd24854fe8..7dc503f149 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
diff --git a/library-benchmarks/build.gradle b/library-benchmarks/build.gradle
index 243bdbfef7..c3ebfa3675 100644
--- a/library-benchmarks/build.gradle
+++ b/library-benchmarks/build.gradle
@@ -1,14 +1,14 @@
-def projectDependencies = new Properties()
-projectDependencies.load(new FileInputStream("${rootDir}/../dependencies.list"))
-
 buildscript {
+    def properties = new Properties()
+    properties.load(new FileInputStream("${rootDir}/../dependencies.list"))
+
     repositories {
         mavenLocal()
         google()
         jcenter()
     }
     dependencies {
-        classpath "com.android.tools.build:gradle:${projectDependencies.get("GRADLE_BUILD_TOOLS")}"
+        classpath "com.android.tools.build:gradle:${properties.get("GRADLE_BUILD_TOOLS")}"
         classpath "io.realm:realm-gradle-plugin:${file("${rootDir}/../version.txt").text.trim()}"
     }
 }
@@ -16,6 +16,7 @@ buildscript {
 allprojects {
     def props = new Properties()
     props.load(new FileInputStream("${rootDir}/../realm.properties"))
+    props.load(new FileInputStream("${rootDir}/../dependencies.list"))
     props.each { key, val ->
         project.ext.set(key, val)
     }
@@ -31,7 +32,7 @@ apply plugin: 'realm-android'
 
 android {
     compileSdkVersion 27
-    buildToolsVersion ${projectDependencies.get("ANDROID_BUILD_TOOLS")}
+    buildToolsVersion "${project.ext.get("ANDROID_BUILD_TOOLS")}"
 
     defaultConfig {
         minSdkVersion 15
diff --git a/library-benchmarks/gradle/wrapper/gradle-wrapper.jar b/library-benchmarks/gradle/wrapper/gradle-wrapper.jar
index 99340b4ad1..1948b9074f 100644
Binary files a/library-benchmarks/gradle/wrapper/gradle-wrapper.jar and b/library-benchmarks/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/library-benchmarks/gradle/wrapper/gradle-wrapper.properties b/library-benchmarks/gradle/wrapper/gradle-wrapper.properties
index bd24854fe8..7dc503f149 100644
--- a/library-benchmarks/gradle/wrapper/gradle-wrapper.properties
+++ b/library-benchmarks/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
diff --git a/library-build-transformer/build.gradle b/library-build-transformer/build.gradle
index c744d5219c..eb4f5ed791 100644
--- a/library-build-transformer/build.gradle
+++ b/library-build-transformer/build.gradle
@@ -104,3 +104,8 @@ publishing {
         }
     }
 }
+
+task wrapper(type: Wrapper) {
+    gradleVersion = project.gradleVersion
+    distributionType = 'all'
+}
diff --git a/library-build-transformer/gradle/wrapper/gradle-wrapper.jar b/library-build-transformer/gradle/wrapper/gradle-wrapper.jar
index 99340b4ad1..1948b9074f 100644
Binary files a/library-build-transformer/gradle/wrapper/gradle-wrapper.jar and b/library-build-transformer/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/library-build-transformer/gradle/wrapper/gradle-wrapper.properties b/library-build-transformer/gradle/wrapper/gradle-wrapper.properties
index bd24854fe8..7dc503f149 100644
--- a/library-build-transformer/gradle/wrapper/gradle-wrapper.properties
+++ b/library-build-transformer/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.jar b/realm-annotations/gradle/wrapper/gradle-wrapper.jar
index 99340b4ad1..1948b9074f 100644
Binary files a/realm-annotations/gradle/wrapper/gradle-wrapper.jar and b/realm-annotations/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.properties b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
index bd24854fe8..7dc503f149 100644
--- a/realm-annotations/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
diff --git a/realm-transformer/gradle/wrapper/gradle-wrapper.jar b/realm-transformer/gradle/wrapper/gradle-wrapper.jar
index 99340b4ad1..1948b9074f 100644
Binary files a/realm-transformer/gradle/wrapper/gradle-wrapper.jar and b/realm-transformer/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm-transformer/gradle/wrapper/gradle-wrapper.properties b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
index bd24854fe8..7dc503f149 100644
--- a/realm-transformer/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
diff --git a/realm/gradle.properties b/realm/gradle.properties
index b9c41987bf..4bc510ffff 100644
--- a/realm/gradle.properties
+++ b/realm/gradle.properties
@@ -1,3 +1,7 @@
 org.gradle.jvmargs=-Xms512m -Xmx2048m
 org.gradle.caching=true
 kotlin.incremental=false;
+
+# See https://issuetracker.google.com/issues/80464216
+# Can be removed when we upgrade to Android Build Tools 3.3.0
+org.gradle.workers.max=1
diff --git a/realm/gradle/wrapper/gradle-wrapper.jar b/realm/gradle/wrapper/gradle-wrapper.jar
index 99340b4ad1..1948b9074f 100644
Binary files a/realm/gradle/wrapper/gradle-wrapper.jar and b/realm/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm/gradle/wrapper/gradle-wrapper.properties b/realm/gradle/wrapper/gradle-wrapper.properties
index bd24854fe8..7dc503f149 100644
--- a/realm/gradle/wrapper/gradle-wrapper.properties
+++ b/realm/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip
diff --git a/realm/kotlin-extensions/build.gradle b/realm/kotlin-extensions/build.gradle
index 4f7841a9ae..ec0e31fdf4 100644
--- a/realm/kotlin-extensions/build.gradle
+++ b/realm/kotlin-extensions/build.gradle
@@ -2,8 +2,8 @@ apply plugin: 'com.android.library'
 apply plugin: 'kotlin-android'
 apply plugin: 'kotlin-kapt'
 apply plugin: 'com.github.dcendents.android-maven'
-apply plugin: 'maven-publish'
 apply plugin: 'com.jfrog.artifactory'
+apply plugin: 'maven-publish'
 apply plugin: 'de.undercouch.download'
 apply plugin: 'org.jetbrains.dokka'
 
@@ -368,11 +368,17 @@ android.productFlavors.all { flavor ->
     }
 }
 
-task bintrayUpload() {
+// Cannot override bintrayUpload in Gradle 4.9. Most likely due to a bug in
+// the gradle-bintray-plugin. So we use `bintrayUploadAll` instead that can
+// then depend on the original bintrayUpload task.
+task bintrayUploadAll() {
+    group = 'Publishing'
+}
+
+project.afterEvaluate {
     android.productFlavors.all { flavor ->
-        dependsOn "bintray${flavor.name.capitalize()}"
+        bintrayUploadAll.dependsOn "bintray${flavor.name.capitalize()}"
     }
-    group = 'Publishing'
 }
 
 task ojoUpload() {
diff --git a/realm/realm-annotations-processor/build.gradle b/realm/realm-annotations-processor/build.gradle
index a272ee6680..50de49ce65 100644
--- a/realm/realm-annotations-processor/build.gradle
+++ b/realm/realm-annotations-processor/build.gradle
@@ -115,6 +115,14 @@ bintray {
     }
 }
 
+// Cannot override bintrayUpload in Gradle 4.9. Most likely due to a bug in
+// the gradle-bintray-plugin. So we use `bintrayUploadAll` instead that can
+// then depend on the original bintrayUpload task.
+task bintrayUploadAll() {
+    dependsOn bintrayUpload
+    group = 'Publishing'
+}
+
 artifactory {
     contextUrl = 'https://oss.jfrog.org/artifactory'
     publish {
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index 791b2bc3d7..b0e7425827 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -4,8 +4,8 @@ apply plugin: 'com.android.library'
 apply plugin: 'kotlin-android'
 apply plugin: 'kotlin-kapt'
 apply plugin: 'com.github.dcendents.android-maven'
-apply plugin: 'maven-publish'
 apply plugin: 'com.jfrog.artifactory'
+apply plugin: 'maven-publish'
 apply plugin: 'findbugs'
 apply plugin: 'pmd'
 apply plugin: 'checkstyle'
@@ -756,11 +756,17 @@ android.productFlavors.all { flavor ->
     }
 }
 
-task bintrayUpload() {
+// Cannot override bintrayUpload in Gradle 4.9. Most likely due to a bug in
+// the gradle-bintray-plugin. So we use `bintrayUploadAll` instead that can
+// then depend on the original bintrayUpload task.
+task bintrayUploadAll() {
+    group = 'Publishing'
+}
+
+project.afterEvaluate {
     android.productFlavors.all { flavor ->
-        dependsOn "bintray${flavor.name.capitalize()}"
+        bintrayUploadAll.dependsOn "bintray${flavor.name.capitalize()}"
     }
-    group = 'Publishing'
 }
 
 task ojoUpload() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
index 9c0ed01755..fe5e347d47 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
@@ -28,6 +28,7 @@
 
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -45,6 +46,7 @@
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.Dog;
+import io.realm.log.LogLevel;
 import io.realm.log.RealmLog;
 import io.realm.log.RealmLogger;
 import io.realm.rule.RunInLooperThread;
@@ -988,4 +990,112 @@ public void onChange(RealmModel element) {
         } catch (IllegalStateException ignored) {
         }
     }
+
+    // Checks that we can attach change listeners to queries involving `limit()` and that
+    // they do the right thing
+    @Test
+    @RunTestInLooperThread
+    public void limitedQueryResult_fromTable_finegrainedListener() {
+        realm = looperThread.getRealm();
+        realm.executeTransaction(r -> {
+            for (int i = 0; i < 5; i++) {
+                r.createObject(AllTypes.class).setColumnLong(i % 5);
+            }
+        });
+        RealmResults<AllTypes> results = realm.where(AllTypes.class)
+                .sort(AllTypes.FIELD_LONG, Sort.DESCENDING) // [4, 4, 3, 3, 2, 2, 1, 1, 0, 0]
+                .distinct(AllTypes.FIELD_LONG) // [4, 3, 2, 1, 0]
+                .limit(2) // [4, 3]
+                .findAll();
+        looperThread.keepStrongReference(results);
+        results.addChangeListener((objects, changeSet) -> {
+            assertEquals(2, objects.size());
+            assertEquals(5, objects.first().getColumnLong());
+            assertEquals(4, objects.last().getColumnLong());
+            assertEquals(1, changeSet.getInsertions().length);
+            assertEquals(0, changeSet.getInsertions()[0]);
+            assertEquals(1, changeSet.getDeletions().length);
+            assertEquals(1, changeSet.getDeletions()[0]);
+            assertEquals(0, changeSet.getChanges().length);
+            looperThread.testComplete();
+        });
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(AllTypes.class).setColumnLong(5);
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void limitedQueryResult_fromTable_finegrainedListener_withModifications() {
+        realm = looperThread.getRealm();
+        realm.executeTransaction(r -> {
+            for (int i = 0; i < 5; i++) {
+                r.createObject(AllTypes.class).setColumnLong(i % 5);
+            }
+        });
+        RealmResults<AllTypes> results = realm.where(AllTypes.class)
+                .sort(AllTypes.FIELD_LONG, Sort.DESCENDING) // [4, 4, 3, 3, 2, 2, 1, 1, 0, 0]
+                .distinct(AllTypes.FIELD_LONG) // [4, 3, 2, 1, 0]
+                .limit(2) // [4, 3]
+                .findAll();
+        looperThread.keepStrongReference(results);
+        results.addChangeListener((objects, changeSet) -> {
+            assertEquals(2, objects.size());
+            assertEquals(6, objects.first().getColumnLong());
+            assertEquals(5, objects.last().getColumnLong());
+            assertEquals(1, changeSet.getInsertions().length);
+            assertEquals(0, changeSet.getInsertions()[0]);
+            assertEquals(1, changeSet.getDeletions().length);
+            assertEquals(1, changeSet.getDeletions()[0]);
+            assertEquals(1, changeSet.getChanges().length);
+            assertEquals(1, changeSet.getChanges()[0]);
+            looperThread.testComplete();
+        });
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(AllTypes.class).setColumnLong(6);
+                for (AllTypes obj : realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, 4).findAll()) {
+                    obj.setColumnLong(5);
+                }
+            }
+        });
+    }
+
+    // Checks that we can attach change listeners to queries involving `limit()` and that
+    // they do the right thing
+    @Test
+    @RunTestInLooperThread
+    public void limitedQueryResult_fromTable_simpleChangeListener() {
+        realm = looperThread.getRealm();
+        realm.executeTransaction(r -> {
+            for (int i = 0; i < 5; i++) {
+                r.createObject(AllTypes.class).setColumnLong(i % 5);
+            }
+        });
+        RealmResults<AllTypes> results = realm.where(AllTypes.class)
+                .sort(AllTypes.FIELD_LONG, Sort.DESCENDING) // [4, 4, 3, 3, 2, 2, 1, 1, 0, 0]
+                .distinct(AllTypes.FIELD_LONG) // [4, 3, 2, 1, 0]
+                .limit(2) // [4, 3]
+                .findAll();
+        looperThread.keepStrongReference(results);
+        results.addChangeListener((objects) -> {
+            assertEquals(2, objects.size());
+            assertEquals(5, objects.first().getColumnLong());
+            assertEquals(4, objects.last().getColumnLong());
+            looperThread.testComplete();
+        });
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(AllTypes.class).setColumnLong(5);
+            }
+        });
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index 1601b59ea7..e0bf51bfbc 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -24,7 +24,6 @@
 import java.lang.reflect.Field;
 import java.util.Date;
 import java.util.Locale;
-import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -3518,4 +3517,99 @@ public void getRealm_throwsIfRealmClosed() {
         } catch (IllegalStateException ignore) {
         }
     }
+
+    @Test
+    public void limit() {
+        populateTestRealm(realm, TEST_DATA_SIZE);
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).sort(AllTypes.FIELD_LONG).limit(5).findAll();
+        assertEquals(5, results.size());
+        for (int i = 0; i < 5; i++) {
+            assertEquals(i, results.get(i).getColumnLong());
+        }
+    }
+
+    @Test
+    public void limit_withSortAndDistinct() {
+        // The order of operators matter when using limit()
+        // If applying sort/distinct without limit, any order will result in the same query result.
+
+        realm.beginTransaction();
+        RealmList<AllJavaTypes> list = realm.createObject(AllJavaTypes.class, -1).getFieldList(); // Root object;
+        for (int i = 0; i < 5; i++) {
+            AllJavaTypes obj = realm.createObject(AllJavaTypes.class, i);
+            obj.setFieldLong(i);
+            list.add(obj);
+        }
+        realm.commitTransaction();
+
+        RealmResults<AllJavaTypes> results = list.where()
+                .sort(AllJavaTypes.FIELD_LONG, Sort.DESCENDING) // [4, 4, 3, 3, 2, 2, 1, 1, 0, 0]
+                .distinct(AllJavaTypes.FIELD_LONG) // [4, 3, 2, 1, 0]
+                .limit(2) // [4, 3]
+                .findAll();
+        assertEquals(2, results.size());
+        assertEquals(4, results.first().getFieldLong());
+        assertEquals(3, results.last().getFieldLong());
+
+        results = list.where()
+                .limit(2) // [0, 1]
+                .distinct(AllJavaTypes.FIELD_LONG) // [ 0, 1]
+                .sort(AllJavaTypes.FIELD_LONG, Sort.DESCENDING) // [1, 0]
+                .findAll();
+        assertEquals(2, results.size());
+        assertEquals(1, results.first().getFieldLong());
+        assertEquals(0, results.last().getFieldLong());
+
+        results = list.where()
+                .distinct(AllJavaTypes.FIELD_LONG) // [ 0, 1, 2, 3, 4]
+                .limit(2) // [0, 1]
+                .sort(AllJavaTypes.FIELD_LONG, Sort.DESCENDING) // [1, 0]
+                .findAll();
+        assertEquals(2, results.size());
+        assertEquals(1, results.first().getFieldLong());
+        assertEquals(0, results.last().getFieldLong());
+    }
+
+    // Checks that https://github.com/realm/realm-object-store/pull/679/files#diff-c0354faf99b53cc5d3c9e6a58ed9ae85R610
+    // Do not apply to Realm Java as we do not lazy-execute queries.
+    @Test
+    public void limit_asSubQuery() {
+        realm.executeTransaction(r -> {
+            for (int i = 0; i < 10; i++) {
+                r.createObject(AllTypes.class).setColumnLong(i % 5);
+            }
+        });
+
+        RealmResults<AllTypes> results = realm.where(AllTypes.class)
+                .sort(AllTypes.FIELD_LONG, Sort.DESCENDING)
+                .findAll() // [4, 4, 3, 3, 2, 2, 1, 1, 0, 0]
+                .where()
+                .distinct(AllTypes.FIELD_LONG)
+                .findAll() // [4, 3, 2, 1, 0]
+                .where()
+                .limit(2) // [4, 3]
+                .findAll();
+        assertEquals(2, results.size());
+        assertEquals(4, results.first().getColumnLong());
+        assertEquals(3, results.last().getColumnLong());
+    }
+
+    @Test
+    public void limit_invalidValuesThrows() {
+        RealmQuery<AllTypes> query = realm.where(AllTypes.class);
+
+        try {
+            query.limit(0);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        try {
+            query.limit(-1);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
index 6f41a48b9b..45b23de504 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
@@ -585,7 +585,7 @@ public void sortAndDistinctMixed() {
         // (2, 1, "B")
         // (3, 1, "C")
         // Depending on the sorting, distinct should pick the first element encountered.
-        // The order of sort/distinct in the query should not matter
+        // The order of sort/distinct in the query matters
 
         // Case 1: Selecting highest numbers
         RealmResults<AnnotationIndexTypes> results1a = realm.where(AnnotationIndexTypes.class)
@@ -600,7 +600,7 @@ public void sortAndDistinctMixed() {
                 .sort(AnnotationIndexTypes.FIELD_INDEX_LONG, Sort.DESCENDING)
                 .findAll();
         assertEquals(1, results1b.size());
-        assertEquals(3, results1b.get(0).getIndexLong());
+        assertEquals(1, results1b.get(0).getIndexLong());
 
         // Case 1: Selecting lowest number numbers
         RealmResults<AnnotationIndexTypes> results2a = realm.where(AnnotationIndexTypes.class)
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/OsResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/OsResultsTests.java
index de67a7e5df..31eb7ec756 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/OsResultsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/OsResultsTests.java
@@ -36,6 +36,8 @@
 import io.realm.RealmConfiguration;
 import io.realm.RealmFieldType;
 import io.realm.TestHelper;
+import io.realm.internal.core.DescriptorOrdering;
+import io.realm.internal.core.QueryDescriptor;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -151,8 +153,9 @@ private void addRow(OsSharedRealm sharedRealm) {
 
     @Test
     public void constructor_withDistinct() {
-        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(null, table, "firstName");
-        OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where(), null, distinctDescriptor);
+        DescriptorOrdering queryDescriptors = new DescriptorOrdering();
+        queryDescriptors.appendDistinct(QueryDescriptor.getInstanceForDistinct(null, table, "firstName"));
+        OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where(), queryDescriptors);
 
         assertEquals(3, osResults.size());
         assertEquals("John", osResults.getUncheckedRow(0).getString(0));
@@ -202,7 +205,7 @@ public void where() {
     @Test
     public void sort() {
         OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where().greaterThan(new long[] {2}, oneNullTable, 1));
-        SortDescriptor sortDescriptor = SortDescriptor.getTestInstance(table, new long[] {2});
+        QueryDescriptor sortDescriptor = QueryDescriptor.getTestInstance(table, new long[] {2});
 
         OsResults osResults2 = osResults.sort(sortDescriptor);
 
@@ -234,9 +237,10 @@ public void contains() {
 
     @Test
     public void indexOf() {
-        SortDescriptor sortDescriptor = SortDescriptor.getTestInstance(table, new long[] {2});
+        DescriptorOrdering queryDescriptors = new DescriptorOrdering();
+        queryDescriptors.appendSort(QueryDescriptor.getTestInstance(table, new long[] {2}));
 
-        OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where(), sortDescriptor, null);
+        OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where(), queryDescriptors);
         UncheckedRow row = table.getUncheckedRow(0);
         assertEquals(3, osResults.indexOf(row));
     }
@@ -245,7 +249,7 @@ public void indexOf() {
     public void distinct() {
         OsResults osResults = OsResults.createFromQuery(sharedRealm, table.where().lessThan(new long[] {2}, oneNullTable, 4));
 
-        SortDescriptor distinctDescriptor = SortDescriptor.getTestInstance(table, new long[] {2});
+        QueryDescriptor distinctDescriptor = QueryDescriptor.getTestInstance(table, new long[] {2});
         OsResults osResults2 = osResults.distinct(distinctDescriptor);
 
         // A new native Results should be created.
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/QueryDescriptorTests.java
similarity index 82%
rename from realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/QueryDescriptorTests.java
index 6a762423c7..2a15fee6b8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/QueryDescriptorTests.java
@@ -31,6 +31,7 @@
 import io.realm.RealmConfiguration;
 import io.realm.RealmFieldType;
 import io.realm.Sort;
+import io.realm.internal.core.QueryDescriptor;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static junit.framework.Assert.assertEquals;
@@ -41,7 +42,7 @@
 
 
 @RunWith(AndroidJUnit4.class)
-public class SortDescriptorTests {
+public class QueryDescriptorTests {
     @Rule
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
     @Rule
@@ -65,14 +66,14 @@ public void tearDown() {
 
     @Test
     public void getInstanceForDistinct() {
-        for (RealmFieldType type : SortDescriptor.DISTINCT_VALID_FIELD_TYPES) {
+        for (RealmFieldType type : QueryDescriptor.DISTINCT_VALID_FIELD_TYPES) {
             long column = table.addColumn(type, type.name());
             table.addSearchIndex(column);
         }
 
         long i = 0;
-        for (RealmFieldType type : SortDescriptor.DISTINCT_VALID_FIELD_TYPES) {
-            SortDescriptor sortDescriptor = SortDescriptor.getInstanceForDistinct(null, table, type.name());
+        for (RealmFieldType type : QueryDescriptor.DISTINCT_VALID_FIELD_TYPES) {
+            QueryDescriptor sortDescriptor = QueryDescriptor.getInstanceForDistinct(null, table, type.name());
             assertEquals(1, sortDescriptor.getColumnIndices()[0].length);
             assertEquals(i, sortDescriptor.getColumnIndices()[0][0]);
             assertNull(sortDescriptor.getAscendings());
@@ -90,13 +91,13 @@ public void getInstanceForDistinct_shouldThrowOnLinkAndListListField() {
         table.addColumnLink(listType, listType.name(), table);
 
         try {
-            SortDescriptor.getInstanceForDistinct(null, table, String.format("%s.%s", listType.name(), type.name()));
+            QueryDescriptor.getInstanceForDistinct(null, table, String.format("%s.%s", listType.name(), type.name()));
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
         try {
-            SortDescriptor.getInstanceForDistinct(null, table, String.format("%s.%s", objectType.name(), type.name()));
+            QueryDescriptor.getInstanceForDistinct(null, table, String.format("%s.%s", objectType.name(), type.name()));
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -111,7 +112,7 @@ public void getInstanceForDistinct_multipleFields() {
         long intColumn = table.addColumn(intType, intType.name());
         table.addSearchIndex(intColumn);
 
-        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForDistinct(null, table, new String[] {
+        QueryDescriptor sortDescriptor = QueryDescriptor.getInstanceForDistinct(null, table, new String[] {
                 stringType.name(), intType.name()});
         assertEquals(2, sortDescriptor.getColumnIndices().length);
         assertNull(sortDescriptor.getAscendings());
@@ -123,11 +124,11 @@ public void getInstanceForDistinct_multipleFields() {
 
     @Test
     public void getInstanceForDistinct_shouldThrowOnInvalidField() {
-        Set<RealmFieldType> types = getValidFieldTypes(SortDescriptor.DISTINCT_VALID_FIELD_TYPES);
+        Set<RealmFieldType> types = getValidFieldTypes(QueryDescriptor.DISTINCT_VALID_FIELD_TYPES);
 
         for (RealmFieldType type : types) {
             try {
-                SortDescriptor.getInstanceForDistinct(null, table, type.name());
+                QueryDescriptor.getInstanceForDistinct(null, table, type.name());
                 fail();
             } catch (IllegalArgumentException ignored) {
                 assertTrue(ignored.getMessage().contains("Distinct is not supported"));
@@ -137,13 +138,13 @@ public void getInstanceForDistinct_shouldThrowOnInvalidField() {
 
     @Test
     public void getInstanceForSort() {
-        for (RealmFieldType type : SortDescriptor.SORT_VALID_FIELD_TYPES) {
+        for (RealmFieldType type : QueryDescriptor.SORT_VALID_FIELD_TYPES) {
             table.addColumn(type, type.name());
         }
 
         long i = 0;
-        for (RealmFieldType type : SortDescriptor.SORT_VALID_FIELD_TYPES) {
-            SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(null, table, type.name(), Sort.DESCENDING);
+        for (RealmFieldType type : QueryDescriptor.SORT_VALID_FIELD_TYPES) {
+            QueryDescriptor sortDescriptor = QueryDescriptor.getInstanceForSort(null, table, type.name(), Sort.DESCENDING);
             assertEquals(1, sortDescriptor.getColumnIndices()[0].length);
             assertEquals(i, sortDescriptor.getColumnIndices()[0][0]);
             assertFalse(sortDescriptor.getAscendings()[0]);
@@ -153,7 +154,7 @@ public void getInstanceForSort() {
 
     @Test
     public void getInstanceForSort_linkField() {
-        for (RealmFieldType type : SortDescriptor.DISTINCT_VALID_FIELD_TYPES) {
+        for (RealmFieldType type : QueryDescriptor.DISTINCT_VALID_FIELD_TYPES) {
             long column = table.addColumn(type, type.name());
             table.addSearchIndex(column);
         }
@@ -161,8 +162,8 @@ public void getInstanceForSort_linkField() {
         long columnLink = table.addColumnLink(objectType, objectType.name(), table);
 
         long i = 0;
-        for (RealmFieldType type : SortDescriptor.DISTINCT_VALID_FIELD_TYPES) {
-            SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(null, table,
+        for (RealmFieldType type : QueryDescriptor.DISTINCT_VALID_FIELD_TYPES) {
+            QueryDescriptor sortDescriptor = QueryDescriptor.getInstanceForSort(null, table,
                     String.format("%s.%s", objectType.name(), type.name()), Sort.ASCENDING);
             assertEquals(2, sortDescriptor.getColumnIndices()[0].length);
             assertEquals(columnLink, sortDescriptor.getColumnIndices()[0][0]);
@@ -179,7 +180,7 @@ public void getInstanceForSort_multipleFields() {
         RealmFieldType intType = RealmFieldType.INTEGER;
         long intColumn = table.addColumn(intType, intType.name());
 
-        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(null, table, new String[] {
+        QueryDescriptor sortDescriptor = QueryDescriptor.getInstanceForSort(null, table, new String[] {
                 stringType.name(), intType.name()}, new Sort[] {Sort.ASCENDING, Sort.DESCENDING});
 
         assertEquals(2, sortDescriptor.getAscendings().length);
@@ -204,18 +205,18 @@ public void getInstanceForSort_numOfFeildsAndSortOrdersNotMatch() {
 
         thrown.expect(IllegalArgumentException.class);
         thrown.expectMessage("Number of fields and sort orders do not match.");
-        SortDescriptor.getInstanceForSort(null, table,
+        QueryDescriptor.getInstanceForSort(null, table,
                 new String[] {stringType.name(), intType.name()}, new Sort[] {Sort.ASCENDING});
 
     }
 
     @Test
     public void getInstanceForSort_shouldThrowOnInvalidField() {
-        Set<RealmFieldType> types = getValidFieldTypes(SortDescriptor.SORT_VALID_FIELD_TYPES);
+        Set<RealmFieldType> types = getValidFieldTypes(QueryDescriptor.SORT_VALID_FIELD_TYPES);
 
         for (RealmFieldType type : types) {
             try {
-                SortDescriptor.getInstanceForSort(null, table, type.name(), Sort.ASCENDING);
+                QueryDescriptor.getInstanceForSort(null, table, type.name(), Sort.ASCENDING);
                 fail();
             } catch (IllegalArgumentException ignored) {
                 assertTrue(ignored.getMessage().contains("Sort is not supported"));
@@ -232,7 +233,7 @@ public void getInstanceForSort_shouldThrowOnLinkListField() {
 
         thrown.expect(IllegalArgumentException.class);
         thrown.expectMessage("Invalid query: field 'LIST' in class 'test_table' is of invalid type 'LIST'.");
-        SortDescriptor.getInstanceForSort(null, table, String.format("%s.%s", listType.name(), type.name()), Sort.ASCENDING);
+        QueryDescriptor.getInstanceForSort(null, table, String.format("%s.%s", listType.name(), type.name()), Sort.ASCENDING);
     }
 
     private Set<RealmFieldType> getValidFieldTypes(Set<RealmFieldType> filter) {
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/ObjectLevelPermissionsTest.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/ObjectLevelPermissionsTest.java
index 79eb7fd407..13183c24a0 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/ObjectLevelPermissionsTest.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/ObjectLevelPermissionsTest.java
@@ -520,6 +520,118 @@ public void allPrivileges() {
         assertNoAccess(nobody);
     }
 
+    @Test
+    public void findOrCreate_unmanagedObjectThrows() {
+        RealmPermissions realmPermissions = new RealmPermissions();
+        try {
+            realmPermissions.findOrCreate("foo");
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        ClassPermissions classPermissions = new ClassPermissions();
+        try {
+            classPermissions.findOrCreate("foo");
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+    }
+
+    @Test
+    public void findOrCreate_notInTransactionThrows() {
+        RealmPermissions realmPermissions = realm.getPermissions();
+        try {
+            realmPermissions.findOrCreate("foo");
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        ClassPermissions classPermissions = realm.getPermissions(ClassPermissions.class);
+        try {
+            classPermissions.findOrCreate("foo");
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+    }
+
+    @Test
+    public void findOrCreate_nullThrows() {
+        realm.beginTransaction();
+        RealmPermissions realmPermissions = realm.getPermissions();
+        try {
+            //noinspection ConstantConditions
+            realmPermissions.findOrCreate(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        ClassPermissions classPermissions = realm.getPermissions(ClassPermissions.class);
+        try {
+            //noinspection ConstantConditions
+            classPermissions.findOrCreate(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void findOrCreate_createRole() {
+        realm.beginTransaction();
+        assertNull(realm.where(Role.class).equalTo("name", "role1").findFirst());
+        assertNull(realm.where(Role.class).equalTo("name", "role2").findFirst());
+
+        // Realm permissions
+        RealmPermissions realmPermissions = realm.getPermissions();
+        Permission p = realmPermissions.findOrCreate("role1");
+        assertEquals("role1", p.getRole().getName());
+        assertTrue(p.getRole().getMembers().isEmpty());
+
+        // Class permissions
+        ClassPermissions classPermissions = realm.getPermissions(ClassPermissions.class);
+        p = classPermissions.findOrCreate("role2");
+        assertEquals("role2", p.getRole().getName());
+        assertTrue(p.getRole().getMembers().isEmpty());
+    }
+
+    @Test
+    public void findOrCreate_createPermission() {
+        realm.beginTransaction();
+        realm.createObject(Role.class, "role1");
+
+        RealmPermissions realmPermissions = realm.getPermissions();
+        assertEquals(1, realmPermissions.getPermissions().size());
+        Permission p = realmPermissions.findOrCreate("role1");
+        assertNoAccess(p);
+        assertEquals("role1", p.getRole().getName());
+        assertEquals(2, realmPermissions.getPermissions().size());
+        assertTrue(p.equals(realmPermissions.getPermissions().last()));
+
+        // Class permissions
+        ClassPermissions classPermissions = realm.getPermissions(ClassPermissions.class);
+        assertEquals(1, classPermissions.getPermissions().size());
+        p = classPermissions.findOrCreate("role2");
+        assertNoAccess(p);
+        assertEquals("role2", p.getRole().getName());
+        assertEquals(2, classPermissions.getPermissions().size());
+        assertTrue(p.equals(classPermissions.getPermissions().last()));
+    }
+
+    @Test
+    public void findOrCreate_findExistingPermission() {
+        realm.beginTransaction();
+
+        RealmPermissions realmPermissions = realm.getPermissions();
+        Permission p = realmPermissions.findOrCreate("everyone");
+        assertFullAccess(p);
+        assertEquals("everyone", p.getRole().getName());
+
+        ClassPermissions classPermissions = realm.getPermissions(ClassPermissions.class);
+        p = classPermissions.findOrCreate("everyone");
+        assertFullAccess(p);
+        assertEquals("everyone", p.getRole().getName());
+    }
+
+
     private void assertFullAccess(RealmPrivileges privileges) {
         assertTrue(privileges.canRead());
         assertTrue(privileges.canUpdate());
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index aa67d94199..5430185427 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -64,6 +64,7 @@ set(classes_LIST
     io.realm.internal.NativeObjectReference io.realm.internal.OsCollectionChangeSet
     io.realm.internal.OsObject io.realm.internal.OsRealmConfig io.realm.internal.OsList
     io.realm.internal.OsObjectStore io.realm.internal.sync.OsSubscription
+    io.realm.internal.core.DescriptorOrdering
 )
 # /./ is the workaround for the problem that AS cannot find the jni headers.
 # See https://github.com/googlesamples/android-ndk/issues/319
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsResults.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsResults.cpp
index 9c3670b388..47254d1d60 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsResults.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsResults.cpp
@@ -22,7 +22,7 @@
 #include <realm/util/optional.hpp>
 
 #include "java_class_global_def.hpp"
-#include "java_sort_descriptor.hpp"
+#include "java_query_descriptor.hpp"
 #include "observable_collection_wrapper.hpp"
 #include "util.hpp"
 
@@ -41,9 +41,9 @@ static void finalize_results(jlong ptr)
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeCreateResults(JNIEnv* env, jclass,
-                                                                              jlong shared_realm_ptr, jlong query_ptr,
-                                                                              jobject j_sort_desc,
-                                                                              jobject j_distinct_desc)
+                                                                             jlong shared_realm_ptr,
+                                                                             jlong query_ptr,
+                                                                             jlong descriptor_ordering_ptr)
 {
     TR_ENTER()
     try {
@@ -53,13 +53,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeCreateResults(JNI
         }
 
         auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-        DescriptorOrdering descriptor_ordering;
-        if (j_sort_desc) {
-            descriptor_ordering.append_sort(JavaSortDescriptor(env, j_sort_desc).sort_descriptor());
-        }
-        if (j_distinct_desc) {
-            descriptor_ordering.append_distinct(JavaSortDescriptor(env, j_distinct_desc).distinct_descriptor());
-        }
+        auto descriptor_ordering = *(reinterpret_cast<DescriptorOrdering*>(descriptor_ordering_ptr));
         Results results(shared_realm, *query, descriptor_ordering);
         auto wrapper = new ResultsWrapper(results);
 
@@ -219,7 +213,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeSort(JNIEnv* env,
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        auto sorted_result = wrapper->collection().sort(JavaSortDescriptor(env, j_sort_desc).sort_descriptor());
+        auto sorted_result = wrapper->collection().sort(JavaQueryDescriptor(env, j_sort_desc).sort_descriptor());
         return reinterpret_cast<jlong>(new ResultsWrapper(sorted_result));
     }
     CATCH_STD()
@@ -233,7 +227,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeDistinct(JNIEnv*
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
         auto distinct_result =
-            wrapper->collection().distinct(JavaSortDescriptor(env, j_distinct_desc).distinct_descriptor());
+            wrapper->collection().distinct(JavaQueryDescriptor(env, j_distinct_desc).distinct_descriptor());
         return reinterpret_cast<jlong>(new ResultsWrapper(distinct_result));
     }
     CATCH_STD()
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_core_DescriptorOrdering.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_core_DescriptorOrdering.cpp
new file mode 100644
index 0000000000..062074fd93
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_core_DescriptorOrdering.cpp
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "io_realm_internal_core_DescriptorOrdering.h"
+
+#include <realm/views.hpp>
+
+#include "java_query_descriptor.hpp"
+#include "util.hpp"
+
+using namespace realm;
+using namespace realm::util;
+using namespace realm::_impl;
+
+static void finalize_descriptor(jlong ptr);
+static void finalize_descriptor(jlong ptr)
+{
+    TR_ENTER_PTR(ptr)
+    delete reinterpret_cast<DescriptorOrdering*>(ptr);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_core_DescriptorOrdering_nativeGetFinalizerMethodPtr(JNIEnv*, jclass)
+{
+    TR_ENTER()
+    return reinterpret_cast<jlong>(&finalize_descriptor);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_core_DescriptorOrdering_nativeCreate(JNIEnv* env, jclass)
+{
+   TR_ENTER()
+   try {
+        return reinterpret_cast<jlong>(new DescriptorOrdering());
+    }
+    CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_core_DescriptorOrdering_nativeAppendSort(JNIEnv* env, jclass,
+                                                                             jlong descriptor_ptr,
+                                                                             jobject j_sort_descriptor)
+{
+    TR_ENTER()
+    try {
+        auto descriptor = reinterpret_cast<DescriptorOrdering*>(descriptor_ptr);
+        if (j_sort_descriptor) {
+                descriptor->append_sort(JavaQueryDescriptor(env, j_sort_descriptor).sort_descriptor());
+        }
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_core_DescriptorOrdering_nativeAppendDistinct(JNIEnv* env, jclass,
+                                                                             jlong descriptor_ptr,
+                                                                             jobject j_distinct_descriptor)
+{
+    TR_ENTER()
+    try {
+        auto descriptor = reinterpret_cast<DescriptorOrdering*>(descriptor_ptr);
+        if (j_distinct_descriptor) {
+            descriptor->append_distinct(JavaQueryDescriptor(env, j_distinct_descriptor).distinct_descriptor());
+        }
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_core_DescriptorOrdering_nativeAppendLimit(JNIEnv* env, jclass,
+                                                                             jlong descriptor_ptr,
+                                                                             jlong limit)
+{
+    TR_ENTER()
+    try {
+         auto descriptor = reinterpret_cast<DescriptorOrdering*>(descriptor_ptr);
+         descriptor->append_limit(limit);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_core_DescriptorOrdering_nativeIsEmpty(JNIEnv* env, jclass,
+                                                                             jlong descriptor_ptr)
+{
+    TR_ENTER()
+    try {
+        auto descriptor = reinterpret_cast<DescriptorOrdering*>(descriptor_ptr);
+        return descriptor->is_empty() ? JNI_TRUE : JNI_FALSE;
+    }
+    CATCH_STD()
+    return JNI_TRUE;
+}
diff --git a/realm/realm-library/src/main/cpp/java_sort_descriptor.cpp b/realm/realm-library/src/main/cpp/java_query_descriptor.cpp
similarity index 82%
rename from realm/realm-library/src/main/cpp/java_sort_descriptor.cpp
rename to realm/realm-library/src/main/cpp/java_query_descriptor.cpp
index 90adec02ef..0c85d29728 100644
--- a/realm/realm-library/src/main/cpp/java_sort_descriptor.cpp
+++ b/realm/realm-library/src/main/cpp/java_query_descriptor.cpp
@@ -16,7 +16,7 @@
 
 
 #include "java_accessor.hpp"
-#include "java_sort_descriptor.hpp"
+#include "java_query_descriptor.hpp"
 #include "util.hpp"
 #include "jni_util/java_class.hpp"
 #include "jni_util/java_method.hpp"
@@ -25,7 +25,7 @@ using namespace realm;
 using namespace realm::_impl;
 using namespace realm::jni_util;
 
-SortDescriptor JavaSortDescriptor::sort_descriptor() const noexcept
+SortDescriptor JavaQueryDescriptor::sort_descriptor() const noexcept
 {
     if (m_sort_desc_obj == nullptr) {
         return SortDescriptor();
@@ -34,7 +34,7 @@ SortDescriptor JavaSortDescriptor::sort_descriptor() const noexcept
     return SortDescriptor(*get_table_ptr(), get_column_indices(), get_ascendings());
 }
 
-DistinctDescriptor JavaSortDescriptor::distinct_descriptor() const noexcept
+DistinctDescriptor JavaQueryDescriptor::distinct_descriptor() const noexcept
 {
     if (m_sort_desc_obj == nullptr) {
         return DistinctDescriptor();
@@ -42,14 +42,14 @@ DistinctDescriptor JavaSortDescriptor::distinct_descriptor() const noexcept
     return DistinctDescriptor(*get_table_ptr(), get_column_indices());
 }
 
-Table* JavaSortDescriptor::get_table_ptr() const noexcept
+Table* JavaQueryDescriptor::get_table_ptr() const noexcept
 {
     static JavaMethod get_table_ptr_method(m_env, get_sort_desc_class(), "getTablePtr", "()J");
     jlong table_ptr = m_env->CallLongMethod(m_sort_desc_obj, get_table_ptr_method);
     return reinterpret_cast<Table*>(table_ptr);
 }
 
-std::vector<std::vector<size_t>> JavaSortDescriptor::get_column_indices() const noexcept
+std::vector<std::vector<size_t>> JavaQueryDescriptor::get_column_indices() const noexcept
 {
     static JavaMethod get_column_indices_method(m_env, get_sort_desc_class(), "getColumnIndices", "()[[J");
     jobjectArray column_indices =
@@ -69,7 +69,7 @@ std::vector<std::vector<size_t>> JavaSortDescriptor::get_column_indices() const
     return indices;
 }
 
-std::vector<bool> JavaSortDescriptor::get_ascendings() const noexcept
+std::vector<bool> JavaQueryDescriptor::get_ascendings() const noexcept
 {
     static JavaMethod get_ascendings_method(m_env, get_sort_desc_class(), "getAscendings", "()[Z");
 
@@ -90,9 +90,9 @@ std::vector<bool> JavaSortDescriptor::get_ascendings() const noexcept
     return ascending_list;
 }
 
-JavaClass const& JavaSortDescriptor::get_sort_desc_class() const noexcept
+JavaClass const& JavaQueryDescriptor::get_sort_desc_class() const noexcept
 {
-    static JavaClass sort_desc_class(m_env, "io/realm/internal/SortDescriptor");
+    static JavaClass sort_desc_class(m_env, "io/realm/internal/core/QueryDescriptor");
     return sort_desc_class;
 }
 
diff --git a/realm/realm-library/src/main/cpp/java_sort_descriptor.hpp b/realm/realm-library/src/main/cpp/java_query_descriptor.hpp
similarity index 64%
rename from realm/realm-library/src/main/cpp/java_sort_descriptor.hpp
rename to realm/realm-library/src/main/cpp/java_query_descriptor.hpp
index 92893bdca0..077b5f92c8 100644
--- a/realm/realm-library/src/main/cpp/java_sort_descriptor.hpp
+++ b/realm/realm-library/src/main/cpp/java_query_descriptor.hpp
@@ -14,8 +14,8 @@
  * limitations under the License.
  */
 
-#ifndef JAVA_SORT_DESCRIPTOR_HPP
-#define JAVA_SORT_DESCRIPTOR_HPP
+#ifndef JAVA_QUERY_DESCRIPTOR_HPP
+#define JAVA_QUERY_DESCRIPTOR_HPP
 
 #include <jni.h>
 
@@ -27,23 +27,24 @@ class JavaClass;
 
 namespace _impl {
 
-// For converting a Java SortDescriptor object to realm::SortDescriptor.
+// For converting a Java QueryDescriptor object to realm::SortDescriptor or realm::DistinctDescriptor.
+//
 // This class is not designed to be used across JNI calls. So it doesn't acquire a reference to the given Java object.
-// We don't hold a pointer to the SortDescriptor in the Java object like normally we do, because the ObjectStore
-// always consumes the SortDescriptor by calling the move constructor. Holding an empty SortDescriptor in Java level
-// doesn't make too much sense and causes troubles with memory management.
-class JavaSortDescriptor {
+// We don't hold a pointer to the native Sort/DistinctDescriptor in the Java object like normally we do, because the
+// ObjectStore always consumes the descriptor by calling the move constructor. Holding an empty descriptor at Java level
+// thus doesn't make much sense and causes problems with memory management.
+class JavaQueryDescriptor {
 public:
-    JavaSortDescriptor(JNIEnv* env, jobject sort_desc_obj)
+    JavaQueryDescriptor(JNIEnv* env, jobject sort_desc_obj)
         : m_env(env)
         , m_sort_desc_obj(sort_desc_obj)
     {
     }
 
-    JavaSortDescriptor(const JavaSortDescriptor&) = delete;
-    JavaSortDescriptor& operator=(const JavaSortDescriptor&) = delete;
-    JavaSortDescriptor(JavaSortDescriptor&&) = delete;
-    JavaSortDescriptor& operator=(JavaSortDescriptor&&) = delete;
+    JavaQueryDescriptor(const JavaQueryDescriptor&) = delete;
+    JavaQueryDescriptor& operator=(const JavaQueryDescriptor&) = delete;
+    JavaQueryDescriptor(JavaQueryDescriptor&&) = delete;
+    JavaQueryDescriptor& operator=(JavaQueryDescriptor&&) = delete;
 
     // Prevent heap allocation
     static void *operator new     (size_t) = delete;
@@ -67,4 +68,4 @@ class JavaSortDescriptor {
 
 } // namespace _impl
 } // namespace realm
-#endif // JAVA_SORT_DESCRIPTOR_HPP
+#endif // JAVA_QUERY_DESCRIPTOR_HPP
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index b0fc2814d9..7e19c51af7 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit b0fc2814d9e6061ce5ba1da887aab6cfba4755ca
+Subproject commit 7e19c51af72c3343b453b8a13c82dfda148e4bbc
diff --git a/realm/realm-library/src/main/cpp/util.cpp b/realm/realm-library/src/main/cpp/util.cpp
index 296cac34ff..bc44a9303c 100644
--- a/realm/realm-library/src/main/cpp/util.cpp
+++ b/realm/realm-library/src/main/cpp/util.cpp
@@ -50,7 +50,7 @@ void ConvertException(JNIEnv* env, const char* file, int line)
     catch (JavaExceptionThrower& e) {
         e.throw_java_exception(env);
     }
-    catch (bad_alloc& e) {
+    catch (std::bad_alloc& e) {
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, OutOfMemory, ss.str());
     }
@@ -62,7 +62,7 @@ void ConvertException(JNIEnv* env, const char* file, int line)
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, BadVersion, ss.str());
     }
-    catch (invalid_argument& e) {
+    catch (std::invalid_argument& e) {
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, IllegalArgument, ss.str());
     }
@@ -314,7 +314,7 @@ struct JStringCharsAccessor {
     {
         size_t size;
         if (int_cast_with_overflow_detect(e->GetStringLength(s), size))
-            throw runtime_error("String size overflow");
+            throw std::runtime_error("String size overflow");
         return size;
     }
 };
@@ -390,7 +390,7 @@ jstring to_jstring(JNIEnv* env, StringData str)
     if (str.size() <= stack_buf_size) {
         size_t retcode = Xcode::to_utf16(in_begin, in_end, out_curr, out_end);
         if (retcode != 0) {
-            throw runtime_error(string_to_hex("Failure when converting short string to UTF-16", str, in_begin, in_end,
+            throw std::runtime_error(string_to_hex("Failure when converting short string to UTF-16", str, in_begin, in_end,
                                               out_curr, out_end, size_t(0), retcode));
         }
         if (in_begin == in_end) {
@@ -403,11 +403,11 @@ jstring to_jstring(JNIEnv* env, StringData str)
         size_t error_code;
         size_t size = Xcode::find_utf16_buf_size(in_begin2, in_end, error_code);
         if (in_begin2 != in_end) {
-            throw runtime_error(string_to_hex("Failure when computing UTF-16 size", str, in_begin, in_end, out_curr,
+            throw std::runtime_error(string_to_hex("Failure when computing UTF-16 size", str, in_begin, in_end, out_curr,
                                               out_end, size, error_code));
         }
         if (int_add_with_overflow_detect(size, stack_buf_size)) {
-            throw runtime_error("String size overflow");
+            throw std::runtime_error("String size overflow");
         }
         dyn_buf.reset(new jchar[size]);
         out_curr = copy(out_begin, out_curr, dyn_buf.get());
@@ -415,7 +415,7 @@ jstring to_jstring(JNIEnv* env, StringData str)
         out_end = dyn_buf.get() + size;
         size_t retcode = Xcode::to_utf16(in_begin, in_end, out_curr, out_end);
         if (retcode != 0) {
-            throw runtime_error(string_to_hex("Failure when converting long string to UTF-16", str, in_begin, in_end,
+            throw std::runtime_error(string_to_hex("Failure when converting long string to UTF-16", str, in_begin, in_end,
                                               out_curr, out_end, size_t(0), retcode));
         }
         REALM_ASSERT(in_begin == in_end);
@@ -424,7 +424,7 @@ jstring to_jstring(JNIEnv* env, StringData str)
 transcode_complete : {
     jsize out_size;
     if (int_cast_with_overflow_detect(out_curr - out_begin, out_size)) {
-        throw runtime_error("String size overflow");
+        throw std::runtime_error("String size overflow");
     }
 
     return env->NewString(out_begin, out_size);
@@ -472,11 +472,11 @@ JStringAccessor::JStringAccessor(JNIEnv* env, jstring str)
         char* out_end = m_data.get() + buf_size;
         size_t error_code;
         if (!Xcode::to_utf8(in_begin, in_end, out_begin, out_end, error_code)) {
-            throw invalid_argument(
+            throw std::invalid_argument(
                 string_to_hex("Failure when converting to UTF-8", chars.data(), chars.size(), error_code));
         }
         if (in_begin != in_end) {
-            throw invalid_argument(
+            throw std::invalid_argument(
                 string_to_hex("in_begin != in_end when converting to UTF-8", chars.data(), chars.size(), error_code));
         }
         m_size = out_begin - m_data.get();
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java
index 2ce0fc42b3..715c7541c0 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java
@@ -13,7 +13,7 @@
 import io.realm.internal.OsResults;
 import io.realm.internal.InvalidRow;
 import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.SortDescriptor;
+import io.realm.internal.core.QueryDescriptor;
 import io.realm.internal.Table;
 import io.realm.internal.UncheckedRow;
 
@@ -289,8 +289,8 @@ private long getColumnIndexForSort(String fieldName) {
      */
     @Override
     public RealmResults<E> sort(String fieldName) {
-        SortDescriptor sortDescriptor =
-                SortDescriptor.getInstanceForSort(getSchemaConnector(), osResults.getTable(), fieldName, Sort.ASCENDING);
+        QueryDescriptor sortDescriptor =
+                QueryDescriptor.getInstanceForSort(getSchemaConnector(), osResults.getTable(), fieldName, Sort.ASCENDING);
 
         OsResults sortedOsResults = osResults.sort(sortDescriptor);
         return createLoadedResults(sortedOsResults);
@@ -301,8 +301,8 @@ private long getColumnIndexForSort(String fieldName) {
      */
     @Override
     public RealmResults<E> sort(String fieldName, Sort sortOrder) {
-        SortDescriptor sortDescriptor =
-                SortDescriptor.getInstanceForSort(getSchemaConnector(), osResults.getTable(), fieldName, sortOrder);
+        QueryDescriptor sortDescriptor =
+                QueryDescriptor.getInstanceForSort(getSchemaConnector(), osResults.getTable(), fieldName, sortOrder);
 
         OsResults sortedOsResults = osResults.sort(sortDescriptor);
         return createLoadedResults(sortedOsResults);
@@ -313,8 +313,8 @@ private long getColumnIndexForSort(String fieldName) {
      */
     @Override
     public RealmResults<E> sort(String fieldNames[], Sort sortOrders[]) {
-        SortDescriptor sortDescriptor =
-                SortDescriptor.getInstanceForSort(getSchemaConnector(), osResults.getTable(), fieldNames, sortOrders);
+        QueryDescriptor sortDescriptor =
+                QueryDescriptor.getInstanceForSort(getSchemaConnector(), osResults.getTable(), fieldNames, sortOrders);
 
         OsResults sortedOsResults = osResults.sort(sortDescriptor);
         return createLoadedResults(sortedOsResults);
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index 10327254d4..d1e51d662d 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -23,18 +23,18 @@
 
 import javax.annotation.Nullable;
 
-import io.realm.annotations.Beta;
 import io.realm.annotations.Required;
 import io.realm.internal.OsList;
 import io.realm.internal.OsResults;
 import io.realm.internal.PendingRow;
+import io.realm.internal.core.QueryDescriptor;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
-import io.realm.internal.SortDescriptor;
 import io.realm.internal.SubscriptionAwareOsResults;
 import io.realm.internal.Table;
 import io.realm.internal.TableQuery;
 import io.realm.internal.Util;
+import io.realm.internal.core.DescriptorOrdering;
 import io.realm.internal.fields.FieldDescriptor;
 import io.realm.internal.sync.SubscriptionAction;
 
@@ -67,8 +67,7 @@
     private String className;
     private final boolean forValues;
     private final OsList osList;
-    private SortDescriptor sortDescriptor;
-    private SortDescriptor distinctDescriptor;
+    private DescriptorOrdering queryDescriptors = new DescriptorOrdering();
 
     private static final String TYPE_MISMATCH = "Field '%s': type mismatch - %s expected.";
     private static final String EMPTY_VALUES = "Non-empty 'values' must be provided.";
@@ -1767,7 +1766,7 @@ public long count() {
     @SuppressWarnings("unchecked")
     public RealmResults<E> findAll() {
         realm.checkIfValid();
-        return createRealmResults(query, sortDescriptor, distinctDescriptor, true, SubscriptionAction.NO_SUBSCRIPTION);
+        return createRealmResults(query, queryDescriptors, true, SubscriptionAction.NO_SUBSCRIPTION);
     }
 
     /**
@@ -1782,8 +1781,7 @@ private OsResults lazyFindAll() {
         realm.checkIfValid();
         return createRealmResults(
                 query,
-                sortDescriptor,
-                distinctDescriptor,
+                queryDescriptors,
                 false,
                 SubscriptionAction.NO_SUBSCRIPTION).osResults;
     }
@@ -1810,7 +1808,7 @@ private OsResults lazyFindAll() {
         }  else {
             subscriptionAction = SubscriptionAction.NO_SUBSCRIPTION;
         }
-        return createRealmResults(query, sortDescriptor, distinctDescriptor, false, subscriptionAction);
+        return createRealmResults(query, queryDescriptors, false, subscriptionAction);
     }
 
     /**
@@ -1836,7 +1834,7 @@ private OsResults lazyFindAll() {
         }
 
         realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
-        return createRealmResults(query, sortDescriptor, distinctDescriptor, false, SubscriptionAction.create(subscriptionName));
+        return createRealmResults(query, queryDescriptors, false, SubscriptionAction.create(subscriptionName));
     }
 
     /**
@@ -1903,10 +1901,8 @@ private OsResults lazyFindAll() {
      */
     public RealmQuery<E> sort(String[] fieldNames, Sort[] sortOrders) {
         realm.checkIfValid();
-        if (sortDescriptor != null) {
-            throw new IllegalStateException("A sorting order was already defined.");
-        }
-        sortDescriptor = SortDescriptor.getInstanceForSort(getSchemaConnector(), query.getTable(), fieldNames, sortOrders);
+        QueryDescriptor sortDescriptor = QueryDescriptor.getInstanceForSort(getSchemaConnector(), query.getTable(), fieldNames, sortOrders);
+        queryDescriptors.appendSort(sortDescriptor);
         return this;
     }
 
@@ -1921,7 +1917,6 @@ private OsResults lazyFindAll() {
      * to linked fields.
      * @throws IllegalStateException if distinct field names were already defined.
      */
-    @Beta
     public RealmQuery<E> distinct(String fieldName) {
         return distinct(fieldName, new String[]{});
     }
@@ -1938,20 +1933,37 @@ private OsResults lazyFindAll() {
      * is an unsupported type, or points to a linked field.
      * @throws IllegalStateException if distinct field names were already defined.
      */
-    @Beta
     public RealmQuery<E> distinct(String firstFieldName, String... remainingFieldNames) {
         realm.checkIfValid();
-        if (distinctDescriptor != null) {
-            throw new IllegalStateException("Distinct fields have already been defined.");
-        }
+        QueryDescriptor distinctDescriptor;
         if (remainingFieldNames.length == 0) {
-            distinctDescriptor = SortDescriptor.getInstanceForDistinct(getSchemaConnector(), table, firstFieldName);
+            distinctDescriptor = QueryDescriptor.getInstanceForDistinct(getSchemaConnector(), table, firstFieldName);
         } else {
             String[] fieldNames = new String[1 + remainingFieldNames.length];
             fieldNames[0] = firstFieldName;
             System.arraycopy(remainingFieldNames, 0, fieldNames, 1, remainingFieldNames.length);
-            distinctDescriptor = SortDescriptor.getInstanceForDistinct(getSchemaConnector(), table, fieldNames);
+            distinctDescriptor = QueryDescriptor.getInstanceForDistinct(getSchemaConnector(), table, fieldNames);
+        }
+        queryDescriptors.appendDistinct(distinctDescriptor);
+        return this;
+    }
+
+    /**
+     * Limits the number of objects returned in case the query matched more objects.
+     * <p>
+     * Note that when using this method in combination with {@link #sort(String)} and
+     * {@link #distinct(String)} they will be executed in the order they where added which can
+     * affect the end result.
+     *
+     * @param limit a limit that is {@code &ge; 1}.
+     * @throws IllegalArgumentException if the provided {@code limit} is less than 1.
+     */
+    public RealmQuery<E> limit(long limit) {
+        realm.checkIfValid();
+        if (limit < 1) {
+            throw new IllegalArgumentException("Only positive numbers above 0 is allowed. Yours was: " + limit);
         }
+        queryDescriptors.setLimit(limit);
         return this;
     }
 
@@ -2049,7 +2061,7 @@ public E findFirstAsync() {
             // TODO: The performance by the pending query will be a little bit worse than directly calling core's
             // Query.find(). The overhead comes with core needs to add all the row indices to the vector. However this
             // can be optimized by adding support of limit in OS's Results which is supported by core already.
-            row = new PendingRow(realm.sharedRealm, query, sortDescriptor, isDynamicQuery());
+            row = new PendingRow(realm.sharedRealm, query, queryDescriptors, isDynamicQuery());
         }
         final E result;
         if (isDynamicQuery()) {
@@ -2074,16 +2086,15 @@ public E findFirstAsync() {
 
 
     private RealmResults<E> createRealmResults(TableQuery query,
-                                               @Nullable SortDescriptor sortDescriptor,
-                                               @Nullable SortDescriptor distinctDescriptor,
+                                               DescriptorOrdering queryDescriptors,
                                                boolean loadResults,
                                                SubscriptionAction subscriptionAction) {
         RealmResults<E> results;
         OsResults osResults;
         if (subscriptionAction.shouldCreateSubscriptions()) {
-            osResults = SubscriptionAwareOsResults.createFromQuery(realm.sharedRealm, query, sortDescriptor, distinctDescriptor, subscriptionAction.getName());
+            osResults = SubscriptionAwareOsResults.createFromQuery(realm.sharedRealm, query, queryDescriptors, subscriptionAction.getName());
         } else {
-            osResults = OsResults.createFromQuery(realm.sharedRealm, query, sortDescriptor, distinctDescriptor);
+            osResults = OsResults.createFromQuery(realm.sharedRealm, query, queryDescriptors);
         }
 
         if (isDynamicQuery()) {
@@ -2099,7 +2110,7 @@ public E findFirstAsync() {
     }
 
     private long getSourceRowIndexForFirstObject() {
-        if (sortDescriptor != null || distinctDescriptor != null) {
+        if (!queryDescriptors.isEmpty()) {
             RealmObjectProxy obj = (RealmObjectProxy) findAll().first(null);
             if (obj != null) {
                 return obj.realmGet$proxyState().getRow$realm().getIndex();
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
index c4982b0d82..4b6aaf46eb 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
@@ -123,8 +123,4 @@ public void addSupportForObjectLevelPermissions(RealmConfiguration.Builder build
         // Do nothing
     }
 
-    public OsResults createSubscriptionAwareResults(OsSharedRealm sharedRealm, TableQuery query, SortDescriptor sortDescriptor, SortDescriptor distinctDescriptor, String name) {
-        throw new IllegalStateException("Should only be called by builds supporting Sync");
-    }
-
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsResults.java b/realm/realm-library/src/main/java/io/realm/internal/OsResults.java
index 55690afbd1..56701527d6 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsResults.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsResults.java
@@ -16,17 +16,16 @@
 
 package io.realm.internal;
 
-import java.util.ArrayList;
 import java.util.ConcurrentModificationException;
 import java.util.Date;
-import java.util.List;
 import java.util.NoSuchElementException;
 
 import javax.annotation.Nullable;
 
 import io.realm.OrderedRealmCollectionChangeListener;
 import io.realm.RealmChangeListener;
-import io.realm.internal.sync.OsSubscription;
+import io.realm.internal.core.DescriptorOrdering;
+import io.realm.internal.core.QueryDescriptor;
 
 
 /**
@@ -284,18 +283,14 @@ public static OsResults createForBacklinks(OsSharedRealm realm, UncheckedRow row
         return new OsResults(realm, srcTable, backlinksPtr);
     }
 
-    public static OsResults createFromQuery(OsSharedRealm sharedRealm, TableQuery query,
-                                            @Nullable SortDescriptor sortDescriptor,
-                                            @Nullable SortDescriptor distinctDescriptor) {
+    public static OsResults createFromQuery(OsSharedRealm sharedRealm, TableQuery query, DescriptorOrdering queryDescriptors) {
         query.validateQuery();
-        long ptr = nativeCreateResults(sharedRealm.getNativePtr(), query.getNativePtr(),
-                sortDescriptor,
-                distinctDescriptor);
+        long ptr = nativeCreateResults(sharedRealm.getNativePtr(), query.getNativePtr(), queryDescriptors.getNativePtr());
         return new OsResults(sharedRealm, query.getTable(), ptr);
     }
 
     public static OsResults createFromQuery(OsSharedRealm sharedRealm, TableQuery query) {
-        return createFromQuery(sharedRealm, query, null, null);
+        return createFromQuery(sharedRealm, query, new DescriptorOrdering());
     }
 
     OsResults(OsSharedRealm sharedRealm, Table table, long nativePtr) {
@@ -371,11 +366,11 @@ public void clear() {
         nativeClear(nativePtr);
     }
 
-    public OsResults sort(SortDescriptor sortDescriptor) {
+    public OsResults sort(QueryDescriptor sortDescriptor) {
         return new OsResults(sharedRealm, table, nativeSort(nativePtr, sortDescriptor));
     }
 
-    public OsResults distinct(SortDescriptor distinctDescriptor) {
+    public OsResults distinct(QueryDescriptor distinctDescriptor) {
         return new OsResults(sharedRealm, table, nativeDistinct(nativePtr, distinctDescriptor));
     }
 
@@ -480,8 +475,7 @@ public void load() {
 
     private static native long nativeGetFinalizerPtr();
 
-    protected static native long nativeCreateResults(long sharedRealmNativePtr, long queryNativePtr,
-                                                     @Nullable SortDescriptor sortDesc, @Nullable SortDescriptor distinctDesc);
+    protected static native long nativeCreateResults(long sharedRealmNativePtr, long queryNativePtr, long descriptorOrderingPtr);
 
     private static native long nativeCreateSnapshot(long nativePtr);
 
@@ -499,9 +493,9 @@ protected static native long nativeCreateResults(long sharedRealmNativePtr, long
 
     private static native Object nativeAggregate(long nativePtr, long columnIndex, byte aggregateFunc);
 
-    private static native long nativeSort(long nativePtr, SortDescriptor sortDesc);
+    private static native long nativeSort(long nativePtr, QueryDescriptor sortDesc);
 
-    private static native long nativeDistinct(long nativePtr, SortDescriptor distinctDesc);
+    private static native long nativeDistinct(long nativePtr, QueryDescriptor distinctDesc);
 
     private static native boolean nativeDeleteFirst(long nativePtr);
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java b/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
index bfa733cd33..5fb25b5b5e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
@@ -7,6 +7,7 @@
 
 import io.realm.RealmChangeListener;
 import io.realm.RealmFieldType;
+import io.realm.internal.core.DescriptorOrdering;
 
 
 /**
@@ -37,10 +38,10 @@
     private WeakReference<FrontEnd> frontEndRef;
     private boolean returnCheckedRow;
 
-    public PendingRow(OsSharedRealm sharedRealm, TableQuery query, @Nullable SortDescriptor sortDescriptor,
+    public PendingRow(OsSharedRealm sharedRealm, TableQuery query, DescriptorOrdering queryDescriptors,
                       final boolean returnCheckedRow) {
         this.sharedRealm = sharedRealm;
-        pendingOsResults = OsResults.createFromQuery(sharedRealm, query, sortDescriptor, null);
+        pendingOsResults = OsResults.createFromQuery(sharedRealm, query, queryDescriptors);
 
         listener = new RealmChangeListener<PendingRow>() {
             @Override
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SubscriptionAwareOsResults.java b/realm/realm-library/src/main/java/io/realm/internal/SubscriptionAwareOsResults.java
index 18d91b4626..c9ab8d4e0e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SubscriptionAwareOsResults.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SubscriptionAwareOsResults.java
@@ -19,6 +19,7 @@
 import javax.annotation.Nullable;
 
 import io.realm.RealmChangeListener;
+import io.realm.internal.core.DescriptorOrdering;
 import io.realm.internal.sync.OsSubscription;
 
 /**
@@ -38,11 +39,10 @@
     private boolean firstCallback;
 
     public static SubscriptionAwareOsResults createFromQuery(OsSharedRealm sharedRealm, TableQuery query,
-                                                             @Nullable SortDescriptor sortDescriptor,
-                                                             @Nullable SortDescriptor distinctDescriptor,
+                                                             DescriptorOrdering queryDescriptors,
                                                              String subscriptionName) {
         query.validateQuery();
-        long ptr = nativeCreateResults(sharedRealm.getNativePtr(), query.getNativePtr(), sortDescriptor, distinctDescriptor);
+        long ptr = nativeCreateResults(sharedRealm.getNativePtr(), query.getNativePtr(), queryDescriptors.getNativePtr());
         return new SubscriptionAwareOsResults(sharedRealm, query.getTable(), ptr, subscriptionName);
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/core/DescriptorOrdering.java b/realm/realm-library/src/main/java/io/realm/internal/core/DescriptorOrdering.java
new file mode 100644
index 0000000000..2777a63a08
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/core/DescriptorOrdering.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.core;
+
+import io.realm.internal.NativeObject;
+import io.realm.internal.OsSharedRealm;
+import io.realm.internal.TableQuery;
+
+/**
+ * Java class wrapping the native {@code realm::DescriptorOrdering} class. This class
+ * is used to track sort/distinct/limit criterias on a query.
+ */
+public class DescriptorOrdering implements NativeObject {
+
+    private static final long nativeFinalizerMethodPtr = nativeGetFinalizerMethodPtr();
+    private final long nativePtr;
+
+    // Used to track if constraints are already set, and throw if they are.
+    // This is just to mirror old behaviour. We should consider lifting this restriction,
+    // although it seems hard to find a use case that is not a logical bug in nested query
+    // construction.
+    private boolean sortDefined = false;
+    private boolean distinctDefined = false;
+    private boolean limitDefined = false;
+
+    /**
+     * Creates a standalone DescriptorOrdering. This only achieves meaning when combined with
+     * a RealmQuery object.
+     *
+     * @see io.realm.internal.OsResults#createFromQuery(OsSharedRealm, TableQuery, DescriptorOrdering)
+     */
+    public DescriptorOrdering() {
+        nativePtr = nativeCreate();
+    }
+
+    @Override
+    public long getNativePtr() {
+        return nativePtr;
+    }
+
+    @Override
+    public long getNativeFinalizerPtr() {
+        return nativeFinalizerMethodPtr;
+    }
+
+    /**
+     * Append a sort criteria.
+     *
+     * @param descriptor description of the sort.
+     */
+    public void appendSort(QueryDescriptor descriptor) {
+        if (sortDefined) {
+            throw new IllegalStateException("A sorting order was already defined. It cannot be redefined");
+        }
+        nativeAppendSort(nativePtr, descriptor);
+        sortDefined = true;
+    }
+
+    /**
+     * Append a distinct criteria.
+     *
+     * @param descriptor description of the distinct criteria.
+     */
+    public void appendDistinct(QueryDescriptor descriptor) {
+        if (distinctDefined) {
+            throw new IllegalStateException("A distinct field was already defined. It cannot be redefined");
+        }
+        nativeAppendDistinct(nativePtr, descriptor);
+        distinctDefined = true;
+    }
+
+    /**
+     * Sets a limit criteria.
+     *
+     * @param limit the maximum amount of objects returned.
+     */
+    public void setLimit(long limit) {
+        if (limitDefined) {
+            throw new IllegalStateException("A limit was already set. It cannot be redefined.");
+        }
+        nativeAppendLimit(nativePtr, limit);
+        limitDefined = true;
+    }
+
+    /**
+     * Returns true if no descriptors or limits have been added.
+     */
+    public boolean isEmpty() {
+        return nativeIsEmpty(nativePtr);
+    }
+
+
+    private static native long nativeGetFinalizerMethodPtr();
+    private static native long nativeCreate();
+    private static native void nativeAppendSort(long descriptorPtr, QueryDescriptor sortDesc);
+    private static native void nativeAppendDistinct(long descriptorPtr, QueryDescriptor sortDesc);
+    private static native void nativeAppendLimit(long descriptorPtr, long limit);
+    private static native boolean nativeIsEmpty(long descriptorPtr);
+
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/core/QueryDescriptor.java
similarity index 70%
rename from realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java
rename to realm/realm-library/src/main/java/io/realm/internal/core/QueryDescriptor.java
index ff80eb74d9..e3e8b597d0 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/core/QueryDescriptor.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package io.realm.internal;
+package io.realm.internal.core;
 
 import java.util.Arrays;
 import java.util.Collections;
@@ -24,37 +24,40 @@
 
 import javax.annotation.Nullable;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import io.realm.RealmFieldType;
 import io.realm.Sort;
+import io.realm.internal.Keep;
+import io.realm.internal.Table;
 import io.realm.internal.fields.FieldDescriptor;
 
 
 /**
- * Java class to present the same name core class in Java. This can be converted to a cpp realm::SortDescriptor object
- * through realm::_impl::JavaSortDescriptor.
+ * Java wrapper class around `realm::SortDescriptor` and `realm::DistinctDescriptor` classes in C++.
+ * They can be converted between each other using realm::_impl::JavaQueryDescriptor.
  * <p>
  * NOTE: Since the column indices are determined when constructing the object with the given table's status, the indices
- * could be wrong when schema changes. Always create and consume the instance when needed, DON'T store a SortDescriptor
- * and use it whenever the ShareGroup can be in different versions.
+ * could be wrong when schema changes. Always create and consume the instance when needed, DON'T store a QueryDescriptor
+ * since it can be wrong if the SharedGroup has a different version.
  * <p>
- * Sort descriptors do not support Linking Objects, either internally or as terminal types.
+ * Query descriptors do not support Linking Objects, either internally or as terminal types.
  */
 @Keep
-public class SortDescriptor {
+public class QueryDescriptor {
     //@VisibleForTesting
-    final static Set<RealmFieldType> SORT_VALID_FIELD_TYPES = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
+    public final static Set<RealmFieldType> SORT_VALID_FIELD_TYPES = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
             RealmFieldType.BOOLEAN, RealmFieldType.INTEGER, RealmFieldType.FLOAT, RealmFieldType.DOUBLE,
             RealmFieldType.STRING, RealmFieldType.DATE)));
 
     //@VisibleForTesting
-    final static Set<RealmFieldType> DISTINCT_VALID_FIELD_TYPES = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
+    public final static Set<RealmFieldType> DISTINCT_VALID_FIELD_TYPES = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
             RealmFieldType.BOOLEAN, RealmFieldType.INTEGER, RealmFieldType.STRING, RealmFieldType.DATE)));
 
-    public static SortDescriptor getInstanceForSort(FieldDescriptor.SchemaProxy proxy, Table table, String fieldDescription, Sort sortOrder) {
+    public static QueryDescriptor getInstanceForSort(FieldDescriptor.SchemaProxy proxy, Table table, String fieldDescription, Sort sortOrder) {
         return getInstanceForSort(proxy, table, new String[] {fieldDescription}, new Sort[] {sortOrder});
     }
 
-    public static SortDescriptor getInstanceForSort(FieldDescriptor.SchemaProxy proxy, Table table, String[] fieldDescriptions, Sort[] sortOrders) {
+    public static QueryDescriptor getInstanceForSort(FieldDescriptor.SchemaProxy proxy, Table table, String[] fieldDescriptions, Sort[] sortOrders) {
         //noinspection ConstantConditions
         if (sortOrders == null || sortOrders.length == 0) {
             throw new IllegalArgumentException("You must provide at least one sort order.");
@@ -65,15 +68,15 @@ public static SortDescriptor getInstanceForSort(FieldDescriptor.SchemaProxy prox
         return getInstance(proxy, table, fieldDescriptions, sortOrders, FieldDescriptor.OBJECT_LINK_FIELD_TYPE, SORT_VALID_FIELD_TYPES, "Sort is not supported");
     }
 
-    public static SortDescriptor getInstanceForDistinct(FieldDescriptor.SchemaProxy proxy, Table table, String fieldDescription) {
+    public static QueryDescriptor getInstanceForDistinct(FieldDescriptor.SchemaProxy proxy, Table table, String fieldDescription) {
         return getInstanceForDistinct(proxy, table, new String[] {fieldDescription});
     }
 
-    public static SortDescriptor getInstanceForDistinct(FieldDescriptor.SchemaProxy proxy, Table table, String[] fieldDescriptions) {
+    public static QueryDescriptor getInstanceForDistinct(FieldDescriptor.SchemaProxy proxy, Table table, String[] fieldDescriptions) {
         return getInstance(proxy, table, fieldDescriptions, null, FieldDescriptor.NO_LINK_FIELD_TYPE, DISTINCT_VALID_FIELD_TYPES, "Distinct is not supported");
     }
 
-    private static SortDescriptor getInstance(
+    private static QueryDescriptor getInstance(
             FieldDescriptor.SchemaProxy proxy,
             Table table,
             String[] fieldDescriptions,
@@ -89,20 +92,20 @@ private static SortDescriptor getInstance(
 
         long[][] columnIndices = new long[fieldDescriptions.length][];
 
-        // Force aggressive parsing of the FieldDescriptors, so that only valid SortDescriptor objects are created.
+        // Force aggressive parsing of the FieldDescriptors, so that only valid QueryDescriptor objects are created.
         for (int i = 0; i < fieldDescriptions.length; i++) {
             FieldDescriptor descriptor = FieldDescriptor.createFieldDescriptor(proxy, table, fieldDescriptions[i], legalInternalTypes, null);
             checkFieldType(descriptor, legalTerminalTypes, message, fieldDescriptions[i]);
             columnIndices[i] = descriptor.getColumnIndices();
         }
 
-        return new SortDescriptor(table, columnIndices, sortOrders);
+        return new QueryDescriptor(table, columnIndices, sortOrders);
     }
 
     // Internal use only. For JNI testing.
     //@VisibleForTesting
-    static SortDescriptor getTestInstance(Table table, long[] columnIndices) {
-        return new SortDescriptor(table, new long[][] {columnIndices}, null);
+    public static QueryDescriptor getTestInstance(Table table, long[] columnIndices) {
+        return new QueryDescriptor(table, new long[][] {columnIndices}, null);
     }
 
     // could do this in the field descriptor, but this provides a better error message
@@ -118,7 +121,7 @@ private static void checkFieldType(FieldDescriptor descriptor, Set<RealmFieldTyp
     private final long[][] columnIndices;
     private final boolean[] ascendings;
 
-    private SortDescriptor(Table table, long[][] columnIndices, @Nullable Sort[] sortOrders) {
+    private QueryDescriptor(Table table, long[][] columnIndices, @Nullable Sort[] sortOrders) {
         this.table = table;
         this.columnIndices = columnIndices;
         if (sortOrders != null) {
@@ -133,13 +136,15 @@ private SortDescriptor(Table table, long[][] columnIndices, @Nullable Sort[] sor
 
     // Called by JNI.
     @SuppressWarnings("unused")
-    long[][] getColumnIndices() {
+    @SuppressFBWarnings("EI_EXPOSE_REP")
+    public long[][] getColumnIndices() {
         return columnIndices;
     }
 
     // Called by JNI.
     @SuppressWarnings("unused")
-    boolean[] getAscendings() {
+    @SuppressFBWarnings("EI_EXPOSE_REP")
+    public boolean[] getAscendings() {
         return ascendings;
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/core/package-info.java b/realm/realm-library/src/main/java/io/realm/internal/core/package-info.java
new file mode 100644
index 0000000000..29793f1acb
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/core/package-info.java
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+@javax.annotation.ParametersAreNonnullByDefault
+package io.realm.internal.core;
diff --git a/realm/realm-library/src/main/java/io/realm/internal/sync/PermissionHelper.java b/realm/realm-library/src/main/java/io/realm/internal/sync/PermissionHelper.java
new file mode 100644
index 0000000000..880d28439e
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/sync/PermissionHelper.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal.sync;
+
+import io.realm.Realm;
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.internal.annotations.ObjectServer;
+import io.realm.sync.permissions.Permission;
+import io.realm.sync.permissions.Role;
+
+/**
+ * Helper class for working with fine-grained permissions
+ */
+@ObjectServer
+public class PermissionHelper {
+
+    /**
+     * Finds or creates the permission object for a given role. Creating objects if they cannot
+     * be found.
+     *
+     * @param container RealmObject containg the permission objects
+     * @param permissions the list of permissions
+     * @param roleName the role to search for
+     * @return
+     */
+    public static Permission findOrCreatePermissionForRole(RealmObject container, RealmList<Permission> permissions, String roleName) {
+        if (!container.isManaged()) {
+            throw new IllegalStateException("'findOrCreate()' can only be called on managed objects.");
+        }
+        Realm realm = container.getRealm();
+        if (!realm.isInTransaction()) {
+            throw new IllegalStateException("'findOrCreate()' can only be called inside a write transaction.");
+        }
+
+        // Find existing permission object or create new one
+        Permission permission = permissions.where().equalTo("role.name", roleName).findFirst();
+        if (permission == null) {
+
+            // Find existing role or create new one
+            Role role = realm.where(Role.class).equalTo("name", roleName).findFirst();
+            if (role == null) {
+                role = realm.createObject(Role.class, roleName);
+            }
+
+            permission = realm.copyToRealm(new Permission.Builder(role).noPrivileges().build());
+            permissions.add(permission);
+        }
+
+        return permission;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/sync/permissions/ClassPermissions.java b/realm/realm-library/src/main/java/io/realm/sync/permissions/ClassPermissions.java
index aadd98706f..d2a4d94854 100644
--- a/realm/realm-library/src/main/java/io/realm/sync/permissions/ClassPermissions.java
+++ b/realm/realm-library/src/main/java/io/realm/sync/permissions/ClassPermissions.java
@@ -23,6 +23,7 @@
 import io.realm.annotations.RealmClass;
 import io.realm.annotations.Required;
 import io.realm.internal.annotations.ObjectServer;
+import io.realm.internal.sync.PermissionHelper;
 
 /**
  * Class describing all permissions related to a given Realm model class. These permissions will
@@ -61,6 +62,7 @@ public ClassPermissions() {
      * @param clazz class to create permissions.
      */
     public ClassPermissions(Class<? extends RealmModel> clazz) {
+        //noinspection ConstantConditions
         if (clazz == null) {
             throw new IllegalArgumentException("Non-null 'clazz' required.");
         }
@@ -89,4 +91,26 @@ public String getName() {
     public RealmList<Permission> getPermissions() {
         return permissions;
     }
+
+    /**
+     * Finds the permissions associated with a given {@link Role}. If either the role or the permission
+     * object doesn't exists, it will be created.
+     * <p>
+     * If the {@link Permission} object is created because one didn't exist already, it will be
+     * created with all privileges disabled.
+     * <p>
+     * If the the {@link Role} object is created because one didn't exists, it will be created
+     * with no members.
+     *
+     * @param roleName name of the role to find.
+     * @return permission object for the given role.
+     * @throws IllegalStateException if this object is not managed by Realm.
+     * @throws IllegalStateException if this method is not called inside a write transaction.
+     * @throws IllegalArgumentException if a {@code null} or empty
+     */
+    public Permission findOrCreate(String roleName) {
+        // Error handling done in the helper class
+        return PermissionHelper.findOrCreatePermissionForRole(this, permissions, roleName);
+    }
+
 }
diff --git a/realm/realm-library/src/main/java/io/realm/sync/permissions/RealmPermissions.java b/realm/realm-library/src/main/java/io/realm/sync/permissions/RealmPermissions.java
index 41b0f05009..1b8915e245 100644
--- a/realm/realm-library/src/main/java/io/realm/sync/permissions/RealmPermissions.java
+++ b/realm/realm-library/src/main/java/io/realm/sync/permissions/RealmPermissions.java
@@ -15,11 +15,13 @@
  */
 package io.realm.sync.permissions;
 
+import io.realm.Realm;
 import io.realm.RealmList;
 import io.realm.RealmObject;
 import io.realm.annotations.PrimaryKey;
 import io.realm.annotations.RealmClass;
 import io.realm.internal.annotations.ObjectServer;
+import io.realm.internal.sync.PermissionHelper;
 
 /**
  * Class describing all permissions related to a given Realm. Permissions attached to this class
@@ -48,4 +50,25 @@ public RealmPermissions() {
     public RealmList<Permission> getPermissions() {
         return permissions;
     }
+
+    /**
+     * Finds the permissions associated with a given {@link Role}. If either the role or the permission
+     * object doesn't exists, it will be created.
+     * <p>
+     * If the {@link Permission} object is created because one didn't exist already, it will be
+     * created with all privileges disabled.
+     * <p>
+     * If the role {@link Role} object is created because one didn't exists, it will be created
+     * with no members.
+     *
+     * @param roleName name of the role to find.
+     * @return permission object for the given role.
+     * @throws IllegalStateException if this object is not managed by Realm.
+     * @throws IllegalStateException if this method is not called inside a write transaction.
+     * @throws IllegalArgumentException if a {@code null} or empty
+     */
+    public Permission findOrCreate(String roleName) {
+        // Error handling done in the helper class
+        return PermissionHelper.findOrCreatePermissionForRole(this, permissions, roleName);
+    }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java
index b47a848564..ff2eeb70b0 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java
@@ -284,7 +284,7 @@ public void execute(Realm realm) {
         realm.close();
         user.logOut();
     }
-    
+
     @Test
     public void waitForInitialRemoteData_readOnlyTrue_throwsIfWrongServerSchema() {
         SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/QueryBasedSyncTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/QueryBasedSyncTests.java
index 3585330c64..a8ad9278e7 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/QueryBasedSyncTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/QueryBasedSyncTests.java
@@ -2,6 +2,7 @@
 
 import android.support.test.runner.AndroidJUnit4;
 
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -11,6 +12,7 @@
 import io.realm.RealmChangeListener;
 import io.realm.RealmList;
 import io.realm.RealmResults;
+import io.realm.Sort;
 import io.realm.StandardIntegrationTest;
 import io.realm.SyncConfiguration;
 import io.realm.SyncManager;
@@ -19,6 +21,8 @@
 import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
 import io.realm.entities.Dog;
+import io.realm.log.LogLevel;
+import io.realm.log.RealmLog;
 import io.realm.objectserver.model.PartialSyncModule;
 import io.realm.objectserver.model.PartialSyncObjectA;
 import io.realm.objectserver.model.PartialSyncObjectB;
@@ -296,6 +300,42 @@ public void clearTable() {
         looperThread.testComplete();
     }
 
+    @Test
+    @RunTestInLooperThread
+    @Ignore("FIXME: We need to use ROS 3.10+ to support limit, but cannot upgrade before https://github.com/realm/realm-js/issues/1971 is fixed")
+    public void downloadLimitedData() throws InterruptedException {
+        RealmLog.setLevel(LogLevel.TRACE);
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        createServerData(user, Constants.SYNC_SERVER_URL);
+        Realm realm = getPartialRealm(user);
+        looperThread.closeAfterTest(realm);
+
+        RealmResults<PartialSyncObjectA> results = realm.where(PartialSyncObjectA.class)
+                .notEqualTo("string", "")
+                .distinct("string")
+                .sort("string", Sort.ASCENDING)
+                .limit(2)
+                .findAllAsync();
+        looperThread.keepStrongReference(results);
+
+        results.addChangeListener((objects, changeSet) -> {
+            RealmLog.error(changeSet.getState().toString());
+            if (changeSet.getState() == OrderedCollectionChangeSet.State.ERROR) {
+                RealmLog.error(changeSet.getError().toString());
+            }
+            if (changeSet.isCompleteResult()) {
+                assertEquals(2, results.size());
+                PartialSyncObjectA obj = objects.first();
+                assertEquals(6, obj.getNumber());
+                assertEquals("partial", obj.getString());
+                obj = objects.last();
+                assertEquals(0, obj.getNumber());
+                assertEquals("realm", obj.getString());
+                looperThread.testComplete();
+            }
+        });
+    }
+
     private Realm getPartialRealm(SyncUser user) {
         final SyncConfiguration partialSyncConfig = configurationFactory.createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
                 .name("partialSync")
diff --git a/tools/sync_test_server/ros/package.json b/tools/sync_test_server/ros/package.json
index c1baabf349..777423ed70 100644
--- a/tools/sync_test_server/ros/package.json
+++ b/tools/sync_test_server/ros/package.json
@@ -6,7 +6,7 @@
     "scripts": {
         "build": "rm -rf dist; ./node_modules/.bin/tsc",
         "clean": "rm -rf dist",
-        "start": "npm run build && node dist/index.js"
+        "start": "npm run build && NODE_TLS_REJECT_UNAUTHORIZED=0 node dist/index.js"
     },
     "devDependencies": {
         "typescript": "2.5.3"
diff --git a/version.txt b/version.txt
index df4bca0bb7..4f39750113 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-5.6.0-SNAPSHOT
\ No newline at end of file
+5.8.0-SNAPSHOT
\ No newline at end of file
