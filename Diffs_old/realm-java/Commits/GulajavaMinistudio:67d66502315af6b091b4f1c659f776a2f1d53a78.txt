diff --git a/CHANGELOG.md b/CHANGELOG.md
index 3e6f763a34..e0442210d4 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,4 +1,4 @@
-## 3.5.0 (YYYY-MM-DD)
+## 3.5.0 (2017-07-11)
 
 ### Breaking Changes
 
@@ -10,24 +10,6 @@
 ### Enhancements
 
 * Added `RealmConfiguration.Builder.compactOnLaunch()` to compact the file on launch (#3739).
-
-### Bug Fixes
-
-### Internal
-
-* Use Object Store to do table initialization.
-
-### Credits
-
-
-## 3.4.1 (YYYY-MM-DD)
-
-### Breaking Changes
-
-### Deprecated
-
-### Enhancements
-
 * [ObjectServer] Adding user lookup API for administrators (#4828).
 
 ### Bug Fixes
@@ -35,13 +17,16 @@
 * Bug in `isNull()`, `isNotNull()`, `isEmpty()`, and `isNotEmpty()` when queries involve nullable fields in link queries (#4856).
 * Bug in how to resolve field names when querying `@LinkingObjects` as the last field (#4864).
 * Rare crash in `RealmLog` when log level was set to `LogLevel.DEBUG`.
+* Broken case insensitive query with indexed field (#4788).
 * [ObjectServer] Bug related to the behaviour of `SyncUser#logout` and the use of invalid `SyncUser` with `SyncConfiguration` (#4822).
 * [ObjectServer] Not all error codes from the server were recognized correctly, resulting in UNKNOWN being reported instead.
 
 ### Internal
 
+* Use Object Store to do table initialization.
 * Removed `Table#Table()`, `Table#addEmptyRow()`, `Table#addEmptyRows()`, `Table#add(Object...)`, `Table#pivot(long,long,PivotType)` and `Table#createnative()`.
-
+* Upgraded Realm Core to 2.8.6
+* Upgraded Realm Sync to 1.10.5
 
 
 ## 3.4.0 (2017-06-22)
diff --git a/dependencies.list b/dependencies.list
index 597493e8ca..a732c8eea7 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,7 +1,7 @@
 # Realm Sync Core release used by Realm Java
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=1.10.1
-REALM_SYNC_SHA256=b48fd48461b563e2a6b1605ec346aca48b64b64a12d42a0f5a61135906d49074
+REALM_SYNC_VERSION=1.10.5
+REALM_SYNC_SHA256=c93caa9b0ff1391550ce6b68ab3822fea7e6ae921498a3ebf3a5e6b17c56fa9b
 
 # Object Server Release used by Integration tests
 # `realm` is stable releases, `realm-testing` is developer builds.
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 81fd9a5c11..3b22eb85be 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -54,6 +54,7 @@
             "io.realm.internal.OsObject",
             "io.realm.internal.OsObjectSchemaInfo",
             "io.realm.internal.Property",
+            "io.realm.internal.ProxyUtils",
             "io.realm.internal.RealmObjectProxy",
             "io.realm.internal.Row",
             "io.realm.internal.SharedRealm",
@@ -130,6 +131,8 @@ public void generate() throws IOException, UnsupportedOperationException {
         emitColumnInfoClass(writer);
 
         emitClassFields(writer);
+
+        emitInstanceFields(writer);
         emitConstructor(writer);
 
         emitInjectContextMethod(writer);
@@ -225,44 +228,46 @@ private void emitColumnInfoClass(JavaWriter writer) throws IOException {
         }
         writer.endMethod();
 
-        writer.endType()
-                .emitEmptyLine();
+        writer.endType();
     }
 
+    //@formatter:off
     private void emitClassFields(JavaWriter writer) throws IOException {
-        writer.emitField(columnInfoClassName(), "columnInfo", EnumSet.of(Modifier.PRIVATE))
-                .emitField("ProxyState<" + qualifiedClassName + ">", "proxyState", EnumSet.of(Modifier.PRIVATE))
+        writer.emitEmptyLine()
                 .emitField("OsObjectSchemaInfo", "expectedObjectSchemaInfo",
-                        EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL),
-                        "createExpectedObjectSchemaInfo()");
+                EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL), "createExpectedObjectSchemaInfo()");
 
+        writer.emitField("List<String>", "FIELD_NAMES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL));
+        writer.beginInitializer(true)
+            .emitStatement("List<String> fieldNames = new ArrayList<String>()");
+            for (VariableElement field : metadata.getFields()) {
+                writer.emitStatement("fieldNames.add(\"%s\")", field.getSimpleName().toString());
+            }
+        writer.emitStatement("FIELD_NAMES = Collections.unmodifiableList(fieldNames)")
+            .endInitializer();
+    }
+    //@formatter:on
+
+    //@formatter:off
+    private void emitInstanceFields(JavaWriter writer) throws IOException {
+        writer.emitEmptyLine()
+                .emitField(columnInfoClassName(), "columnInfo", EnumSet.of(Modifier.PRIVATE))
+                .emitField("ProxyState<" + qualifiedClassName + ">", "proxyState", EnumSet.of(Modifier.PRIVATE));
 
         for (VariableElement variableElement : metadata.getFields()) {
             if (Utils.isRealmList(variableElement)) {
                 String genericType = Utils.getGenericTypeQualifiedName(variableElement);
-                writer.emitField("RealmList<" + genericType + ">", variableElement.getSimpleName().toString() + "RealmList", EnumSet.of(Modifier.PRIVATE));
+                writer.emitField("RealmList<" + genericType + ">", variableElement.getSimpleName().toString() +
+                        "RealmList", EnumSet.of(Modifier.PRIVATE));
             }
         }
 
         for (Backlink backlink : metadata.getBacklinkFields()) {
-            writer.emitField(
-                    backlink.getTargetFieldType(),
-                    backlink.getTargetField() + BACKLINKS_FIELD_EXTENSION,
+            writer.emitField(backlink.getTargetFieldType(), backlink.getTargetField() + BACKLINKS_FIELD_EXTENSION,
                     EnumSet.of(Modifier.PRIVATE));
         }
-
-        //@formatter:off
-        writer.emitField("List<String>", "FIELD_NAMES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL))
-                .beginInitializer(true)
-                .emitStatement("List<String> fieldNames = new ArrayList<String>()");
-        for (VariableElement field : metadata.getFields()) {
-            writer.emitStatement("fieldNames.add(\"%s\")", field.getSimpleName().toString());
-        }
-        writer.emitStatement("FIELD_NAMES = Collections.unmodifiableList(fieldNames)")
-                .endInitializer()
-                .emitEmptyLine();
-        //@formatter:on
     }
+    //@formatter:on
 
     //@formatter:off
     private void emitConstructor(JavaWriter writer) throws IOException {
@@ -780,19 +785,27 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
     private void emitValidateRealmType(JavaWriter writer, VariableElement field, String fieldName, String fieldTypeQualifiedName)
             throws IOException {
 
-        // make sure types align
-        writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
-        emitMigrationNeededException(writer, "\"Missing field '%s' in existing Realm file. " +
-                "Either remove field or migrate using io.realm.internal.Table.addColumn()." +
-                "\")", fieldName);
-        writer.endControlFlow();
-        writer.beginControlFlow("if (columnTypes.get(\"%s\") != %s)", fieldName, getRealmTypeChecked(field).getRealmType());
-        emitMigrationNeededException(writer, "\"Invalid type '%s' for field '%s' in existing Realm file.\")",
-                Utils.getFieldTypeSimpleName(field), fieldName);
-        writer.endControlFlow();
+        // make field sure types align
+        writer.emitStatement(
+                "ProxyUtils.verifyField(sharedRealm, columnTypes, \"%s\", %s, \"%s\")",
+                fieldName, getRealmTypeChecked(field).getRealmType(), Utils.getFieldTypeSimpleName(field));
 
         // make sure that nullability matches
-        if (metadata.isNullable(field)) {
+        if (!metadata.isNullable(field)) {
+            writer.beginControlFlow("if (table.isColumnNullable(%s))", fieldIndexVariableReference(field));
+            if (Utils.isPrimitiveType(fieldTypeQualifiedName)) {
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
+                                " \"Field '%s' does support null values in the existing Realm file. " +
+                                "Use corresponding boxed type for field '%s' or migrate using RealmObjectSchema.setNullable().\")",
+                        fieldName, fieldName);
+            } else {
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
+                                " \"Field '%s' does support null values in the existing Realm file. " +
+                                "Remove @Required or @PrimaryKey from field '%s' or migrate using RealmObjectSchema.setNullable().\")",
+                        fieldName, fieldName);
+            }
+            writer.endControlFlow();
+        } else {
             writer.beginControlFlow("if (!table.isColumnNullable(%s))", fieldIndexVariableReference(field));
             // Check if the existing PrimaryKey does support null value for String, Byte, Short, Integer, & Long
             if (metadata.isPrimaryKey(field)) {
@@ -814,20 +827,6 @@ private void emitValidateRealmType(JavaWriter writer, VariableElement field, Str
                         fieldName, fieldName);
             }
             writer.endControlFlow();
-        } else {
-            writer.beginControlFlow("if (table.isColumnNullable(%s))", fieldIndexVariableReference(field));
-            if (Utils.isPrimitiveType(fieldTypeQualifiedName)) {
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
-                                " \"Field '%s' does support null values in the existing Realm file. " +
-                                "Use corresponding boxed type for field '%s' or migrate using RealmObjectSchema.setNullable().\")",
-                        fieldName, fieldName);
-            } else {
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
-                                " \"Field '%s' does support null values in the existing Realm file. " +
-                                "Remove @Required or @PrimaryKey from field '%s' or migrate using RealmObjectSchema.setNullable().\")",
-                        fieldName, fieldName);
-            }
-            writer.endControlFlow();
         }
 
         // Validate @Index
@@ -843,14 +842,10 @@ private void emitValidateRealmModelType(JavaWriter writer, VariableElement field
             throws IOException {
         String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
 
-        writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
-        emitMigrationNeededException(writer, "\"Missing field '%s' in existing Realm file. " +
-                "Either remove field or migrate using io.realm.internal.Table.addColumn().\")", fieldName);
-        writer.endControlFlow();
-        writer.beginControlFlow("if (columnTypes.get(\"%s\") != RealmFieldType.OBJECT)", fieldName);
-        emitMigrationNeededException(writer, "\"Invalid type '%s' for field '%s'\")",
-                fieldTypeSimpleName, fieldName);
-        writer.endControlFlow();
+        // make field sure types align
+        writer.emitStatement(
+                "ProxyUtils.verifyField(sharedRealm, columnTypes, \"%s\", RealmFieldType.OBJECT, \"%s\")",
+                fieldName, Utils.getFieldTypeSimpleName(field));
         writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
         emitMigrationNeededException(writer, "\"Missing class '%s%s' for field '%s'\")",
                 Constants.TABLE_PREFIX, fieldTypeSimpleName, fieldName);
@@ -866,14 +861,13 @@ private void emitValidateRealmModelType(JavaWriter writer, VariableElement field
 
     private void emitValidateRealmListType(JavaWriter writer, VariableElement field, long fieldIndex, String fieldName)
             throws IOException {
+
         String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
-        writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
-        emitMigrationNeededException(writer, "\"Missing field '%s'\")", fieldName);
-        writer.endControlFlow();
-        writer.beginControlFlow("if (columnTypes.get(\"%s\") != RealmFieldType.LIST)", fieldName);
-        emitMigrationNeededException(writer, "\"Invalid type '%s' for field '%s'\")",
-                genericTypeSimpleName, fieldName);
-        writer.endControlFlow();
+
+        writer.emitStatement(
+                "ProxyUtils.verifyField(sharedRealm, columnTypes, \"%s\", RealmFieldType.LIST, \"%s\")",
+                fieldName, genericTypeSimpleName);
+
         writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericTypeSimpleName);
         emitMigrationNeededException(writer, "\"Missing class '%s%s' for field '%s'\")",
                 Constants.TABLE_PREFIX, genericTypeSimpleName, fieldName);
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index 22dc82ea71..b6a89c7c56 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -11,6 +11,7 @@
 import io.realm.internal.OsObject;
 import io.realm.internal.OsObjectSchemaInfo;
 import io.realm.internal.Property;
+import io.realm.internal.ProxyUtils;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
@@ -85,11 +86,7 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
         }
     }
 
-    private AllTypesColumnInfo columnInfo;
-    private ProxyState<some.test.AllTypes> proxyState;
     private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
-    private RealmList<some.test.AllTypes> columnRealmListRealmList;
-    private RealmResults<some.test.AllTypes> parentObjectsBacklinks;
     private static final List<String> FIELD_NAMES;
     static {
         List<String> fieldNames = new ArrayList<String>();
@@ -105,6 +102,11 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
         FIELD_NAMES = Collections.unmodifiableList(fieldNames);
     }
 
+    private AllTypesColumnInfo columnInfo;
+    private ProxyState<some.test.AllTypes> proxyState;
+    private RealmList<some.test.AllTypes> columnRealmListRealmList;
+    private RealmResults<some.test.AllTypes> parentObjectsBacklinks;
+
     AllTypesRealmProxy() {
         proxyState.setConstructionFinished();
     }
@@ -449,78 +451,38 @@ public static AllTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean
             }
         }
 
-        if (!columnTypes.containsKey("columnString")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnString' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("columnString") != RealmFieldType.STRING) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'columnString' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnString", RealmFieldType.STRING, "String");
         if (!table.isColumnNullable(columnInfo.columnStringIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(),"@PrimaryKey field 'columnString' does not support null values in the existing Realm file. Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.");
         }
         if (!table.hasSearchIndex(table.getColumnIndex("columnString"))) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Index not defined for field 'columnString' in existing Realm file. Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().");
         }
-        if (!columnTypes.containsKey("columnLong")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnLong' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("columnLong") != RealmFieldType.INTEGER) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'long' for field 'columnLong' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnLong", RealmFieldType.INTEGER, "long");
         if (table.isColumnNullable(columnInfo.columnLongIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnLong' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnLong' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("columnFloat")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnFloat' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("columnFloat") != RealmFieldType.FLOAT) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'float' for field 'columnFloat' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnFloat", RealmFieldType.FLOAT, "float");
         if (table.isColumnNullable(columnInfo.columnFloatIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnFloat' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnFloat' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("columnDouble")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnDouble' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("columnDouble") != RealmFieldType.DOUBLE) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'double' for field 'columnDouble' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnDouble", RealmFieldType.DOUBLE, "double");
         if (table.isColumnNullable(columnInfo.columnDoubleIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDouble' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnDouble' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("columnBoolean")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnBoolean' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("columnBoolean") != RealmFieldType.BOOLEAN) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'columnBoolean' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnBoolean", RealmFieldType.BOOLEAN, "boolean");
         if (table.isColumnNullable(columnInfo.columnBooleanIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnBoolean' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("columnDate")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnDate' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("columnDate") != RealmFieldType.DATE) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Date' for field 'columnDate' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnDate", RealmFieldType.DATE, "Date");
         if (table.isColumnNullable(columnInfo.columnDateIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDate' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnDate' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("columnBinary")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnBinary' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("columnBinary") != RealmFieldType.BINARY) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'byte[]' for field 'columnBinary' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnBinary", RealmFieldType.BINARY, "byte[]");
         if (table.isColumnNullable(columnInfo.columnBinaryIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBinary' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnBinary' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("columnObject")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnObject' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("columnObject") != RealmFieldType.OBJECT) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'AllTypes' for field 'columnObject'");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnObject", RealmFieldType.OBJECT, "AllTypes");
         if (!sharedRealm.hasTable("class_AllTypes")) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnObject'");
         }
@@ -528,12 +490,7 @@ public static AllTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean
         if (!table.getLinkTarget(columnInfo.columnObjectIndex).hasSameSchema(table_7)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmObject for field 'columnObject': '" + table.getLinkTarget(columnInfo.columnObjectIndex).getName() + "' expected - was '" + table_7.getName() + "'");
         }
-        if (!columnTypes.containsKey("columnRealmList")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnRealmList'");
-        }
-        if (columnTypes.get("columnRealmList") != RealmFieldType.LIST) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'AllTypes' for field 'columnRealmList'");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "columnRealmList", RealmFieldType.LIST, "AllTypes");
         if (!sharedRealm.hasTable("class_AllTypes")) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnRealmList'");
         }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index 4248632d3d..003b520bf3 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -11,6 +11,7 @@
 import io.realm.internal.OsObject;
 import io.realm.internal.OsObjectSchemaInfo;
 import io.realm.internal.Property;
+import io.realm.internal.ProxyUtils;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
@@ -68,8 +69,6 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
         }
     }
 
-    private BooleansColumnInfo columnInfo;
-    private ProxyState<some.test.Booleans> proxyState;
     private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
     private static final List<String> FIELD_NAMES;
     static {
@@ -81,6 +80,9 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
         FIELD_NAMES = Collections.unmodifiableList(fieldNames);
     }
 
+    private BooleansColumnInfo columnInfo;
+    private ProxyState<some.test.Booleans> proxyState;
+
     BooleansRealmProxy() {
         proxyState.setConstructionFinished();
     }
@@ -227,39 +229,19 @@ public static BooleansColumnInfo validateTable(SharedRealm sharedRealm, boolean
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key defined for field " + table.getColumnName(table.getPrimaryKey()) + " was removed.");
         }
 
-        if (!columnTypes.containsKey("done")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'done' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("done") != RealmFieldType.BOOLEAN) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'done' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "done", RealmFieldType.BOOLEAN, "boolean");
         if (table.isColumnNullable(columnInfo.doneIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'done' does support null values in the existing Realm file. Use corresponding boxed type for field 'done' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("isReady")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'isReady' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("isReady") != RealmFieldType.BOOLEAN) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'isReady' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "isReady", RealmFieldType.BOOLEAN, "boolean");
         if (table.isColumnNullable(columnInfo.isReadyIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'isReady' does support null values in the existing Realm file. Use corresponding boxed type for field 'isReady' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("mCompleted")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'mCompleted' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("mCompleted") != RealmFieldType.BOOLEAN) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'mCompleted' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "mCompleted", RealmFieldType.BOOLEAN, "boolean");
         if (table.isColumnNullable(columnInfo.mCompletedIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'mCompleted' does support null values in the existing Realm file. Use corresponding boxed type for field 'mCompleted' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("anotherBoolean")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'anotherBoolean' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("anotherBoolean") != RealmFieldType.BOOLEAN) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'anotherBoolean' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "anotherBoolean", RealmFieldType.BOOLEAN, "boolean");
         if (table.isColumnNullable(columnInfo.anotherBooleanIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'anotherBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'anotherBoolean' or migrate using RealmObjectSchema.setNullable().");
         }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index f7395470d9..cab706c70d 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -11,6 +11,7 @@
 import io.realm.internal.OsObject;
 import io.realm.internal.OsObjectSchemaInfo;
 import io.realm.internal.Property;
+import io.realm.internal.ProxyUtils;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
@@ -119,8 +120,6 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
         }
     }
 
-    private NullTypesColumnInfo columnInfo;
-    private ProxyState<some.test.NullTypes> proxyState;
     private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
     private static final List<String> FIELD_NAMES;
     static {
@@ -149,6 +148,9 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
         FIELD_NAMES = Collections.unmodifiableList(fieldNames);
     }
 
+    private NullTypesColumnInfo columnInfo;
+    private ProxyState<some.test.NullTypes> proxyState;
+
     NullTypesRealmProxy() {
         proxyState.setConstructionFinished();
     }
@@ -879,192 +881,87 @@ public static NullTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key defined for field " + table.getColumnName(table.getPrimaryKey()) + " was removed.");
         }
 
-        if (!columnTypes.containsKey("fieldStringNotNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldStringNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldStringNotNull") != RealmFieldType.STRING) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'fieldStringNotNull' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldStringNotNull", RealmFieldType.STRING, "String");
         if (table.isColumnNullable(columnInfo.fieldStringNotNullIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldStringNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldStringNotNull' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("fieldStringNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldStringNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldStringNull") != RealmFieldType.STRING) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'fieldStringNull' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldStringNull", RealmFieldType.STRING, "String");
         if (!table.isColumnNullable(columnInfo.fieldStringNullIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldStringNull' is required. Either set @Required to field 'fieldStringNull' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("fieldBooleanNotNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBooleanNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldBooleanNotNull") != RealmFieldType.BOOLEAN) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Boolean' for field 'fieldBooleanNotNull' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldBooleanNotNull", RealmFieldType.BOOLEAN, "Boolean");
         if (table.isColumnNullable(columnInfo.fieldBooleanNotNullIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldBooleanNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBooleanNotNull' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("fieldBooleanNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBooleanNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldBooleanNull") != RealmFieldType.BOOLEAN) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Boolean' for field 'fieldBooleanNull' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldBooleanNull", RealmFieldType.BOOLEAN, "Boolean");
         if (!table.isColumnNullable(columnInfo.fieldBooleanNullIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldBooleanNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldBooleanNull' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("fieldBytesNotNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBytesNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldBytesNotNull") != RealmFieldType.BINARY) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'byte[]' for field 'fieldBytesNotNull' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldBytesNotNull", RealmFieldType.BINARY, "byte[]");
         if (table.isColumnNullable(columnInfo.fieldBytesNotNullIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldBytesNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBytesNotNull' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("fieldBytesNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBytesNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldBytesNull") != RealmFieldType.BINARY) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'byte[]' for field 'fieldBytesNull' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldBytesNull", RealmFieldType.BINARY, "byte[]");
         if (!table.isColumnNullable(columnInfo.fieldBytesNullIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldBytesNull' is required. Either set @Required to field 'fieldBytesNull' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("fieldByteNotNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldByteNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldByteNotNull") != RealmFieldType.INTEGER) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Byte' for field 'fieldByteNotNull' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldByteNotNull", RealmFieldType.INTEGER, "Byte");
         if (table.isColumnNullable(columnInfo.fieldByteNotNullIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldByteNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldByteNotNull' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("fieldByteNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldByteNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldByteNull") != RealmFieldType.INTEGER) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Byte' for field 'fieldByteNull' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldByteNull", RealmFieldType.INTEGER, "Byte");
         if (!table.isColumnNullable(columnInfo.fieldByteNullIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldByteNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldByteNull' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("fieldShortNotNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldShortNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldShortNotNull") != RealmFieldType.INTEGER) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Short' for field 'fieldShortNotNull' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldShortNotNull", RealmFieldType.INTEGER, "Short");
         if (table.isColumnNullable(columnInfo.fieldShortNotNullIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldShortNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldShortNotNull' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("fieldShortNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldShortNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldShortNull") != RealmFieldType.INTEGER) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Short' for field 'fieldShortNull' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldShortNull", RealmFieldType.INTEGER, "Short");
         if (!table.isColumnNullable(columnInfo.fieldShortNullIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldShortNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldShortNull' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("fieldIntegerNotNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldIntegerNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldIntegerNotNull") != RealmFieldType.INTEGER) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Integer' for field 'fieldIntegerNotNull' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldIntegerNotNull", RealmFieldType.INTEGER, "Integer");
         if (table.isColumnNullable(columnInfo.fieldIntegerNotNullIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldIntegerNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldIntegerNotNull' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("fieldIntegerNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldIntegerNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldIntegerNull") != RealmFieldType.INTEGER) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Integer' for field 'fieldIntegerNull' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldIntegerNull", RealmFieldType.INTEGER, "Integer");
         if (!table.isColumnNullable(columnInfo.fieldIntegerNullIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldIntegerNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldIntegerNull' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("fieldLongNotNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldLongNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldLongNotNull") != RealmFieldType.INTEGER) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Long' for field 'fieldLongNotNull' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldLongNotNull", RealmFieldType.INTEGER, "Long");
         if (table.isColumnNullable(columnInfo.fieldLongNotNullIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldLongNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldLongNotNull' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("fieldLongNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldLongNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldLongNull") != RealmFieldType.INTEGER) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Long' for field 'fieldLongNull' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldLongNull", RealmFieldType.INTEGER, "Long");
         if (!table.isColumnNullable(columnInfo.fieldLongNullIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldLongNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldLongNull' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("fieldFloatNotNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldFloatNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldFloatNotNull") != RealmFieldType.FLOAT) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Float' for field 'fieldFloatNotNull' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldFloatNotNull", RealmFieldType.FLOAT, "Float");
         if (table.isColumnNullable(columnInfo.fieldFloatNotNullIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldFloatNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldFloatNotNull' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("fieldFloatNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldFloatNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldFloatNull") != RealmFieldType.FLOAT) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Float' for field 'fieldFloatNull' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldFloatNull", RealmFieldType.FLOAT, "Float");
         if (!table.isColumnNullable(columnInfo.fieldFloatNullIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldFloatNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldFloatNull' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("fieldDoubleNotNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDoubleNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldDoubleNotNull") != RealmFieldType.DOUBLE) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Double' for field 'fieldDoubleNotNull' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldDoubleNotNull", RealmFieldType.DOUBLE, "Double");
         if (table.isColumnNullable(columnInfo.fieldDoubleNotNullIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldDoubleNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDoubleNotNull' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("fieldDoubleNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDoubleNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldDoubleNull") != RealmFieldType.DOUBLE) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Double' for field 'fieldDoubleNull' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldDoubleNull", RealmFieldType.DOUBLE, "Double");
         if (!table.isColumnNullable(columnInfo.fieldDoubleNullIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldDoubleNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldDoubleNull' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("fieldDateNotNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDateNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldDateNotNull") != RealmFieldType.DATE) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Date' for field 'fieldDateNotNull' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldDateNotNull", RealmFieldType.DATE, "Date");
         if (table.isColumnNullable(columnInfo.fieldDateNotNullIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldDateNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDateNotNull' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("fieldDateNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDateNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldDateNull") != RealmFieldType.DATE) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Date' for field 'fieldDateNull' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldDateNull", RealmFieldType.DATE, "Date");
         if (!table.isColumnNullable(columnInfo.fieldDateNullIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldDateNull' is required. Either set @Required to field 'fieldDateNull' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("fieldObjectNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldObjectNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldObjectNull") != RealmFieldType.OBJECT) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'NullTypes' for field 'fieldObjectNull'");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "fieldObjectNull", RealmFieldType.OBJECT, "NullTypes");
         if (!sharedRealm.hasTable("class_NullTypes")) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_NullTypes' for field 'fieldObjectNull'");
         }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index f7c85cb206..52fb1beff6 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -11,6 +11,7 @@
 import io.realm.internal.OsObject;
 import io.realm.internal.OsObjectSchemaInfo;
 import io.realm.internal.Property;
+import io.realm.internal.ProxyUtils;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
@@ -62,8 +63,6 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
         }
     }
 
-    private SimpleColumnInfo columnInfo;
-    private ProxyState<some.test.Simple> proxyState;
     private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
     private static final List<String> FIELD_NAMES;
     static {
@@ -73,6 +72,9 @@ protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
         FIELD_NAMES = Collections.unmodifiableList(fieldNames);
     }
 
+    private SimpleColumnInfo columnInfo;
+    private ProxyState<some.test.Simple> proxyState;
+
     SimpleRealmProxy() {
         proxyState.setConstructionFinished();
     }
@@ -181,21 +183,11 @@ public static SimpleColumnInfo validateTable(SharedRealm sharedRealm, boolean al
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key defined for field " + table.getColumnName(table.getPrimaryKey()) + " was removed.");
         }
 
-        if (!columnTypes.containsKey("name")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'name' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("name") != RealmFieldType.STRING) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'name' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "name", RealmFieldType.STRING, "String");
         if (!table.isColumnNullable(columnInfo.nameIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'name' is required. Either set @Required to field 'name' or migrate using RealmObjectSchema.setNullable().");
         }
-        if (!columnTypes.containsKey("age")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'age' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("age") != RealmFieldType.INTEGER) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'int' for field 'age' in existing Realm file.");
-        }
+        ProxyUtils.verifyField(sharedRealm, columnTypes, "age", RealmFieldType.INTEGER, "int");
         if (table.isColumnNullable(columnInfo.ageIndex)) {
             throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'age' does support null values in the existing Realm file. Use corresponding boxed type for field 'age' or migrate using RealmObjectSchema.setNullable().");
         }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index e12978c71a..2998dae327 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -34,6 +34,7 @@
 import io.realm.entities.Cat;
 import io.realm.entities.CatOwner;
 import io.realm.entities.Dog;
+import io.realm.entities.IndexedFields;
 import io.realm.entities.NoPrimaryKeyNullTypes;
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.NullTypes;
@@ -2923,6 +2924,20 @@ public void onChange(RealmResults<AllTypes> results) {
         });
     }
 
+    @Test
+    public void findAll_indexedCaseInsensitiveFields() {
+        // Catches https://github.com/realm/realm-java/issues/4788
+        realm.beginTransaction();
+        realm.createObject(IndexedFields.class).indexedString = "ROVER";
+        realm.createObject(IndexedFields.class).indexedString = "Rover";
+        realm.commitTransaction();
+
+        RealmResults<IndexedFields> results = realm.where(IndexedFields.class)
+                .equalTo(IndexedFields.FIELD_INDEXED_STRING, "rover", Case.INSENSITIVE)
+                .findAll();
+        assertEquals(2, results.size());
+    }
+
     @Test
     public void findAllSorted_listOnSubObjectField() {
         String[] fieldNames = new String[2];
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/IndexedFields.java b/realm/realm-library/src/androidTest/java/io/realm/entities/IndexedFields.java
index 420062c098..85109c3c4c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/IndexedFields.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/IndexedFields.java
@@ -26,6 +26,6 @@
     public static final String FIELD_NON_INDEXED_STRING = "nonIndexedString";
 
     @Index
-    private String indexedString;
-    private String nonIndexedString;
+    public String indexedString;
+    public String nonIndexedString;
 }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp
index 057f7a79ba..f77eb20ccf 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp
@@ -65,8 +65,8 @@ static void finalize_results(jlong ptr)
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateResults(JNIEnv* env, jclass,
                                                                               jlong shared_realm_ptr, jlong query_ptr,
-                                                                              jobject sort_desc,
-                                                                              jobject distinct_desc)
+                                                                              jobject j_sort_desc,
+                                                                              jobject j_distinct_desc)
 {
     TR_ENTER()
     try {
@@ -76,8 +76,16 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateResults(JN
         }
 
         auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-        Results results(shared_realm, *query, SortDescriptor(JavaSortDescriptor(env, sort_desc)),
-                        SortDescriptor(JavaSortDescriptor(env, distinct_desc)));
+
+        DescriptorOrdering descriptor_ordering;
+        REALM_ASSERT_RELEASE(!(j_sort_desc && j_distinct_desc));
+        if (j_sort_desc) {
+            descriptor_ordering.append_sort(JavaSortDescriptor(env, j_sort_desc).sort_descriptor());
+        }
+        if (j_distinct_desc) {
+            descriptor_ordering.append_distinct(JavaSortDescriptor(env, j_distinct_desc).distinct_descriptor());
+        }
+        Results results(shared_realm, *query, descriptor_ordering);
         auto wrapper = new ResultsWrapper(results);
 
         return reinterpret_cast<jlong>(wrapper);
@@ -89,13 +97,14 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateResults(JN
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateResultsFromLinkView(JNIEnv* env, jclass,
                                                                                           jlong shared_realm_ptr,
                                                                                           jlong link_view_ptr,
-                                                                                          jobject sort_desc)
+                                                                                          jobject j_sort_desc)
 {
     TR_ENTER()
     try {
         auto link_view_ref = reinterpret_cast<LinkViewRef*>(link_view_ptr);
         auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-        Results results(shared_realm, *link_view_ref, util::none, SortDescriptor(JavaSortDescriptor(env, sort_desc)));
+        Results results(shared_realm, *link_view_ref, util::none,
+                        JavaSortDescriptor(env, j_sort_desc).sort_descriptor());
         auto wrapper = new ResultsWrapper(results);
 
         return reinterpret_cast<jlong>(wrapper);
@@ -245,12 +254,12 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_Collection_nativeAggregate(JNIE
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeSort(JNIEnv* env, jclass, jlong native_ptr,
-                                                                     jobject sort_desc)
+                                                                     jobject j_sort_desc)
 {
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        auto sorted_result = wrapper->m_results.sort(JavaSortDescriptor(env, sort_desc));
+        auto sorted_result = wrapper->m_results.sort(JavaSortDescriptor(env, j_sort_desc).sort_descriptor());
         return reinterpret_cast<jlong>(new ResultsWrapper(sorted_result));
     }
     CATCH_STD()
@@ -258,12 +267,13 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeSort(JNIEnv* env
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeDistinct(JNIEnv* env, jclass, jlong native_ptr,
-                                                                         jobject distinct_desc)
+                                                                         jobject j_distinct_desc)
 {
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        auto distinct_result = wrapper->m_results.distinct(JavaSortDescriptor(env, distinct_desc));
+        auto distinct_result =
+            wrapper->m_results.distinct(JavaSortDescriptor(env, j_distinct_desc).distinct_descriptor());
         return reinterpret_cast<jlong>(new ResultsWrapper(distinct_result));
     }
     CATCH_STD()
diff --git a/realm/realm-library/src/main/cpp/java_sort_descriptor.cpp b/realm/realm-library/src/main/cpp/java_sort_descriptor.cpp
index b26c76309b..acee8a21a2 100644
--- a/realm/realm-library/src/main/cpp/java_sort_descriptor.cpp
+++ b/realm/realm-library/src/main/cpp/java_sort_descriptor.cpp
@@ -23,28 +23,38 @@ using namespace realm;
 using namespace realm::_impl;
 using namespace realm::jni_util;
 
-JavaSortDescriptor::operator realm::SortDescriptor() const noexcept
+SortDescriptor JavaSortDescriptor::sort_descriptor() const noexcept
 {
     if (m_sort_desc_obj == nullptr) {
         return SortDescriptor();
     }
 
-    // Cache the method IDs.
-    static JavaMethod getColumnIndices(m_env, m_sort_desc_obj, "getColumnIndices", "()[[J");
-    static JavaMethod getAscendings(m_env, m_sort_desc_obj, "getAscendings", "()[Z");
-    static JavaMethod getTablePtr(m_env, m_sort_desc_obj, "getTablePtr", "()J");
+    return SortDescriptor(*get_table_ptr(), get_column_indices(), get_ascendings());
+}
 
-    jobjectArray column_indices =
-        static_cast<jobjectArray>(m_env->CallObjectMethod(m_sort_desc_obj, getColumnIndices));
-    jbooleanArray ascendings = static_cast<jbooleanArray>(m_env->CallObjectMethod(m_sort_desc_obj, getAscendings));
-    jlong table_ptr = m_env->CallLongMethod(m_sort_desc_obj, getTablePtr);
+DistinctDescriptor JavaSortDescriptor::distinct_descriptor() const noexcept
+{
+    if (m_sort_desc_obj == nullptr) {
+        return DistinctDescriptor();
+    }
+    return DistinctDescriptor(*get_table_ptr(), get_column_indices());
+}
 
+Table* JavaSortDescriptor::get_table_ptr() const noexcept
+{
+    static JavaMethod get_table_ptr_method(m_env, m_sort_desc_obj, "getTablePtr", "()J");
+    jlong table_ptr = m_env->CallLongMethod(m_sort_desc_obj, get_table_ptr_method);
+    return reinterpret_cast<Table*>(table_ptr);
+}
+
+std::vector<std::vector<size_t>> JavaSortDescriptor::get_column_indices() const noexcept
+{
+    static JavaMethod get_column_indices_method(m_env, m_sort_desc_obj, "getColumnIndices", "()[[J");
+    jobjectArray column_indices =
+        static_cast<jobjectArray>(m_env->CallObjectMethod(m_sort_desc_obj, get_column_indices_method));
     JniArrayOfArrays<JniLongArray, jlongArray> arrays(m_env, column_indices);
-    JniBooleanArray ascending_array(m_env, ascendings);
     jsize arr_len = arrays.len();
-
     std::vector<std::vector<size_t>> indices;
-    std::vector<bool> ascending_list;
 
     for (int i = 0; i < arr_len; ++i) {
         JniLongArray& jni_long_array = arrays[i];
@@ -53,12 +63,27 @@ JavaSortDescriptor::operator realm::SortDescriptor() const noexcept
             col_indices.push_back(static_cast<size_t>(jni_long_array[j]));
         }
         indices.push_back(std::move(col_indices));
-        if (ascendings) {
-            ascending_list.push_back(static_cast<bool>(ascending_array[i]));
-        }
     }
+    return indices;
+}
+
+std::vector<bool> JavaSortDescriptor::get_ascendings() const noexcept
+{
+    static JavaMethod get_ascendings_method(m_env, m_sort_desc_obj, "getAscendings", "()[Z");
+
+    jbooleanArray ascendings =
+        static_cast<jbooleanArray>(m_env->CallObjectMethod(m_sort_desc_obj, get_ascendings_method));
+
+    if (!ascendings) {
+        return {};
+    }
+
+    JniBooleanArray ascending_array(m_env, ascendings);
+    std::vector<bool> ascending_list;
+    jsize arr_len = ascending_array.len();
 
-    return ascendings
-               ? SortDescriptor(*reinterpret_cast<Table*>(table_ptr), std::move(indices), std::move(ascending_list))
-               : SortDescriptor(*reinterpret_cast<Table*>(table_ptr), std::move(indices));
+    for (int i = 0; i < arr_len; i++) {
+        ascending_list.push_back(static_cast<bool>(ascending_array[i]));
+    }
+    return ascending_list;
 }
diff --git a/realm/realm-library/src/main/cpp/java_sort_descriptor.hpp b/realm/realm-library/src/main/cpp/java_sort_descriptor.hpp
index 39c175254c..16d7bfa11b 100644
--- a/realm/realm-library/src/main/cpp/java_sort_descriptor.hpp
+++ b/realm/realm-library/src/main/cpp/java_sort_descriptor.hpp
@@ -18,7 +18,8 @@
 #define JAVA_SORT_DESCRIPTOR_HPP
 
 #include <jni.h>
-#include <realm/views.hpp>
+
+#include "descriptor_ordering.hpp"
 
 namespace realm {
 namespace _impl {
@@ -41,11 +42,22 @@ class JavaSortDescriptor {
     JavaSortDescriptor(JavaSortDescriptor&&) = delete;
     JavaSortDescriptor& operator=(JavaSortDescriptor&&) = delete;
 
-    operator realm::SortDescriptor() const noexcept;
+    // Prevent heap allocation
+    static void *operator new     (size_t) = delete;
+    static void *operator new[]   (size_t) = delete;
+    static void  operator delete  (void*)  = delete;
+    static void  operator delete[](void*)  = delete;
+
+    realm::SortDescriptor sort_descriptor() const noexcept;
+    realm::DistinctDescriptor distinct_descriptor() const noexcept;
 
 private:
     JNIEnv* m_env;
     jobject m_sort_desc_obj;
+
+    realm::Table* get_table_ptr() const noexcept;
+    std::vector<std::vector<size_t>> get_column_indices() const noexcept;
+    std::vector<bool> get_ascendings() const noexcept;
 };
 
 } // namespace _impl
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 1e3cbb1789..7c12b340e0 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 1e3cbb178952e26112a474f596aad6bf4f938adf
+Subproject commit 7c12b340e078aa4ce371347e235eba51f37f84c4
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ProxyUtils.java b/realm/realm-library/src/main/java/io/realm/internal/ProxyUtils.java
new file mode 100644
index 0000000000..7b9da29d3d
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/ProxyUtils.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal;
+
+import java.util.Map;
+
+import io.realm.RealmFieldType;
+import io.realm.exceptions.RealmMigrationNeededException;
+
+public class ProxyUtils {
+
+    public static void verifyField(SharedRealm sharedRealm, Map<String, RealmFieldType> columnTypes, String fieldName, RealmFieldType fieldType, String fieldSimpleType) {
+        if (!columnTypes.containsKey(fieldName)) {
+            throw new RealmMigrationNeededException(
+                    sharedRealm.getPath(),
+                    String.format("Missing field '%s' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().", fieldName));
+        }
+        if (columnTypes.get(fieldName) != fieldType) {
+            throw new RealmMigrationNeededException(
+                    sharedRealm.getPath(),
+                    String.format("Invalid type '%s' for field '%s' in existing Realm file.", fieldSimpleType, fieldName));
+        }
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java
index 3936d36a50..1f47c94e4d 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java
@@ -70,7 +70,7 @@ public static SortDescriptor getInstanceForDistinct(FieldDescriptor.SchemaProxy
         return getInstance(proxy, table, fieldDescriptions, null, FieldDescriptor.NO_LINK_FIELD_TYPE, DISTINCT_VALID_FIELD_TYPES, "Distinct is not supported");
     }
 
-    static SortDescriptor getInstance(
+    private static SortDescriptor getInstance(
             FieldDescriptor.SchemaProxy proxy,
             Table table,
             String[] fieldDescriptions,
diff --git a/version.txt b/version.txt
index b9821b826b..a6541492d0 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-3.5.0-SNAPSHOT
\ No newline at end of file
+3.5.1-SNAPSHOT
\ No newline at end of file
