diff --git a/CHANGELOG.md b/CHANGELOG.md
index ff2e6fc339..dd33ec97a5 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,27 @@
+## 5.5.0 (YYYY-MM-DD)
+
+### Enhancements
+
+* [ObjectServer] Added `ConnectionState` enum describing the states a connection can be in.
+* [ObjectServer] Added `SyncSession.isConnected()`.
+* [ObjectServer] Added support for observing connection changes for a session using `SyncSession.addConnectionChangeListener()` and `SyncSession.removeConnectionChangeListener()`.
+
+### Internal
+
+* Updated to Object Store commit: 97fd03819f398b3c81c8b007feaca8636629050b
+
+
+## 5.4.2 (2018-08-09)
+
+### Bug Fixes
+
+* [ObjectServer] Fixed bugs in the Sync Client that could lead to memory corruption and crashes.
+
+### Internal
+
+* Upgraded to Realm Sync 3.8.8
+
+
 ## 5.4.1 (2018-08-03)
 
 ### Bug Fixes
diff --git a/dependencies.list b/dependencies.list
index 34ad7bb009..9becc34d10 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,8 +1,8 @@
 # Realm Sync Core release used by Realm Java
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=3.8.1
-REALM_SYNC_SHA256=346bc1cfe8e77d20d268ca002a4990dceb29e9d5aa08f9201be80143ebde85a3
+REALM_SYNC_VERSION=3.8.8
+REALM_SYNC_SHA256=a0cbc5b46dbc3a9351bd002ccbcb07bf2a5fd13f9f1b7ef6ed51df931b46587b
 
 # Object Server Release used by Integration tests. Installed using NPM.
 # Use `npm view realm-object-server versions` to get a list of available versions.
-REALM_OBJECT_SERVER_VERSION=3.9.2
+REALM_OBJECT_SERVER_VERSION=3.9.9
diff --git a/examples/settings.gradle b/examples/settings.gradle
index 4a5ac90600..15f6d6c37d 100644
--- a/examples/settings.gradle
+++ b/examples/settings.gradle
@@ -15,4 +15,3 @@ include 'threadExample'
 include 'unitTestExample'
 include 'objectServerExample'
 include 'multiprocessExample'
-
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index 458807bab3..6ea9d4956b 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -457,4 +457,16 @@ public void getSessionThrowsOnNonExistingSession() {
                     "No SyncSession found using the path : "));
         }
     }
+
+    @Test
+    public void isConnected_falseForInvalidUser() {
+        Realm realm = Realm.getInstance(configuration);
+        SyncSession session = SyncManager.getSession(configuration);
+        try {
+            assertFalse(session.isConnected());
+        } finally {
+            realm.close();
+        }
+    }
+
 }
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
index 20c8f764cd..140e8e5f1d 100644
--- a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
@@ -47,8 +47,15 @@ static_assert(SyncSession::PublicState::Dying ==
 static_assert(SyncSession::PublicState::Inactive ==
                   static_cast<SyncSession::PublicState>(io_realm_SyncSession_STATE_VALUE_INACTIVE),
               "");
-static_assert(SyncSession::PublicState::Error ==
-                  static_cast<SyncSession::PublicState>(io_realm_SyncSession_STATE_VALUE_ERROR),
+
+static_assert(SyncSession::ConnectionState::Disconnected ==
+              static_cast<SyncSession::ConnectionState >(io_realm_SyncSession_CONNECTION_VALUE_DISCONNECTED),
+              "");
+static_assert(SyncSession::ConnectionState::Connecting ==
+              static_cast<SyncSession::ConnectionState>(io_realm_SyncSession_CONNECTION_VALUE_CONNECTING),
+              "");
+static_assert(SyncSession::ConnectionState::Connected ==
+              static_cast<SyncSession::ConnectionState>(io_realm_SyncSession_CONNECTION_VALUE_CONNECTED),
               "");
 
 JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeRefreshAccessToken(JNIEnv* env, jclass,
@@ -229,11 +236,97 @@ JNIEXPORT jbyte JNICALL Java_io_realm_SyncSession_nativeGetState(JNIEnv* env, jc
                     return io_realm_SyncSession_STATE_VALUE_DYING;
                 case SyncSession::PublicState::Inactive:
                     return io_realm_SyncSession_STATE_VALUE_INACTIVE;
-                case SyncSession::PublicState::Error:
-                    return io_realm_SyncSession_STATE_VALUE_ERROR;
             }
         }
     }
     CATCH_STD()
     return -1;
 }
+
+JNIEXPORT jbyte JNICALL Java_io_realm_SyncSession_nativeGetConnectionState(JNIEnv* env, jclass, jstring j_local_realm_path)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor local_realm_path(env, j_local_realm_path);
+        auto session = SyncManager::shared().get_existing_session(local_realm_path);
+
+        if (session) {
+            switch (session->connection_state()) {
+                case SyncSession::ConnectionState::Disconnected:
+                    return io_realm_SyncSession_CONNECTION_VALUE_DISCONNECTED;
+                case SyncSession::ConnectionState::Connecting:
+                    return io_realm_SyncSession_CONNECTION_VALUE_CONNECTING;
+                case SyncSession::ConnectionState::Connected:
+                    return io_realm_SyncSession_CONNECTION_VALUE_CONNECTED;
+            }
+        }
+    }
+    CATCH_STD()
+    return -1;
+}
+
+static jlong get_connection_value(SyncSession::ConnectionState state) {
+    switch (state) {
+        case SyncSession::ConnectionState::Disconnected: return static_cast<jlong>(io_realm_SyncSession_CONNECTION_VALUE_DISCONNECTED);
+        case SyncSession::ConnectionState::Connecting: return static_cast<jlong>(io_realm_SyncSession_CONNECTION_VALUE_CONNECTING);
+        case SyncSession::ConnectionState::Connected: return static_cast<jlong>(io_realm_SyncSession_CONNECTION_VALUE_CONNECTED);
+    }
+    return static_cast<jlong>(-1);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_SyncSession_nativeAddConnectionListener(JNIEnv* env, jclass, jstring j_local_realm_path)
+{
+    try {
+        // JNIEnv is thread confined, so we need a deep copy in order to capture the string in the lambda
+        std::string local_realm_path(JStringAccessor(env, j_local_realm_path));
+        std::shared_ptr<SyncSession> session = SyncManager::shared().get_existing_session(local_realm_path);
+        if (!session) {
+            // FIXME: We should lift this restriction
+            ThrowException(env, IllegalState,
+            "Cannot register a connection listener before a session is "
+            "created. A session will be created after the first call to Realm.getInstance().");
+            return 0;
+        }
+
+        static JavaClass java_syncmanager_class(env, "io/realm/SyncManager");
+        static JavaMethod java_notify_connection_listener(env, java_syncmanager_class, "notifyConnectionListeners", "(Ljava/lang/String;JJ)V", true);
+
+        std::function<SyncSession::ConnectionStateCallback > callback = [local_realm_path](SyncSession::ConnectionState old_state, SyncSession::ConnectionState new_state) {
+            JNIEnv* local_env = jni_util::JniUtils::get_env(true);
+
+            jlong old_connection_value = get_connection_value(old_state);
+            jlong new_connection_value = get_connection_value(new_state);
+
+            JavaLocalRef<jstring> path(local_env, to_jstring(local_env, local_realm_path));
+            local_env->CallStaticVoidMethod(java_syncmanager_class, java_notify_connection_listener, path.get(),
+                                        old_connection_value, new_connection_value);
+
+            // All exceptions will be caught on the Java side of handlers, but Errors will still end
+            // up here, so we need to do something sensible with them.
+            // Throwing a C++ exception will terminate the sync thread and cause the pending Java
+            // exception to become visible. For some (unknown) reason Logcat will not see the C++
+            // exception, only the Java one.
+            if (local_env->ExceptionCheck()) {
+                local_env->ExceptionDescribe();
+                throw std::runtime_error("An unexpected Error was thrown from Java. See LogCat");
+            }
+        };
+        uint64_t token = session->register_connection_change_callback(callback);
+        return static_cast<jlong>(token);
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT void JNICALL Java_io_realm_SyncSession_nativeRemoveConnectionListener(JNIEnv* env, jclass, jlong listener_id, jstring j_local_realm_path)
+{
+    try {
+        // JNIEnv is thread confined, so we need a deep copy in order to capture the string in the lambda
+        std::string local_realm_path(JStringAccessor(env, j_local_realm_path));
+        std::shared_ptr<SyncSession> session = SyncManager::shared().get_existing_session(local_realm_path);
+        if (session) {
+            session->unregister_connection_change_callback(static_cast<uint64_t>(listener_id));
+        }
+    }
+    CATCH_STD()
+}
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 58f106676f..97fd03819f 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 58f106676f96d0a5dcb52b6d705cf20db797d5c6
+Subproject commit 97fd03819f398b3c81c8b007feaca8636629050b
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ConnectionListener.java b/realm/realm-library/src/objectServer/java/io/realm/ConnectionListener.java
new file mode 100644
index 0000000000..43bed189a7
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/ConnectionListener.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+/**
+ * Interface used when reporting changes that happened to the connection used by the session.
+ * <p>
+ * Multiple sessions might re-use the same connection. In that case, any connection
+ * change will be reported to all sessions.
+ * <p>
+ * If a disconnect happened due to an error, that error will be reported to the sessions
+ * {@link io.realm.SyncSession.ErrorHandler}.
+ *
+ * @see SyncSession#isConnected()
+ * @see SyncConfiguration.Builder#errorHandler(SyncSession.ErrorHandler)
+ */
+public interface ConnectionListener {
+
+    /**
+     * A change in the connection to the server was detected.
+     *
+     * @param oldState the state the connection transitioned from.
+     * @param newState the state the connection transitioned to.
+     */
+    void onChange(ConnectionState oldState, ConnectionState newState);
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ConnectionState.java b/realm/realm-library/src/objectServer/java/io/realm/ConnectionState.java
new file mode 100644
index 0000000000..e603160f93
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/ConnectionState.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2018 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+/**
+ * Enum describing the states of the underlying connection used by a {@link SyncSession}.
+ */
+public enum ConnectionState {
+
+    /**
+     * No connection to the server exists. No data is being transferred even if the session
+     * is {@link SyncSession.State#ACTIVE}. If the connection entered this state due to an error, this
+     * error will be reported to the {@link SyncSession.ErrorHandler}.
+     */
+    DISCONNECTED(SyncSession.CONNECTION_VALUE_DISCONNECTED),
+
+    /**
+     * A connection is currently in progress of being established. If successful the next
+     * state is {@link #CONNECTED}. If the connection fails it will be {@link #DISCONNECTED}.
+     */
+    CONNECTING(SyncSession.CONNECTION_VALUE_CONNECTING),
+
+    /**
+     * A connection was successfully established to the server. If the SyncSession is {@link SyncSession.State#ACTIVE}
+     * data will now be transferred between the device and the server.
+     */
+    CONNECTED(SyncSession.CONNECTION_VALUE_CONNECTED);
+
+    final int value;
+
+    ConnectionState(int value) {
+        this.value = value;
+    }
+
+    static ConnectionState fromNativeValue(long value) {
+        ConnectionState[] stateCodes = values();
+        for (ConnectionState state : stateCodes) {
+            if (state.value == value) {
+                return state;
+            }
+        }
+
+        throw new IllegalArgumentException("Unknown connection state code: " + value);
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
index 390e44782e..ce556daad1 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -400,6 +400,22 @@ private static synchronized void notifyProgressListener(String localRealmPath, l
         }
     }
 
+    /**
+     * Called from native code. This method is not allowed to throw as it would be swallowed
+     * by the native Sync Client thread. Instead log all exceptions to logcat.
+     */
+    @SuppressWarnings("unused")
+    private static synchronized void notifyConnectionListeners(String localRealmPath, long oldState, long newState) {
+        SyncSession session = sessions.get(localRealmPath);
+        if (session != null) {
+            try {
+                session.notifyConnectionListeners(ConnectionState.fromNativeValue(oldState), ConnectionState.fromNativeValue(newState));
+            } catch (Exception exception) {
+                RealmLog.error(exception);
+            }
+        }
+    }
+
     /**
      * This is called from the Object Store (through JNI) to request an {@code access_token} for
      * the session specified by sessionPath.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index f05656a86f..f099649332 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -26,6 +26,7 @@
 import java.util.Iterator;
 import java.util.Locale;
 import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Future;
 import java.util.concurrent.ScheduledFuture;
@@ -36,6 +37,8 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
+import javax.annotation.Nullable;
+
 import io.realm.internal.Keep;
 import io.realm.internal.SyncObjectServerFacade;
 import io.realm.internal.Util;
@@ -50,15 +53,23 @@
 import io.realm.log.RealmLog;
 
 /**
- * This class represents the connection to the Realm Object Server for one {@link SyncConfiguration}.
+ * A session controls how data is synchronized between a single Realm on the device and the server
+ * Realm on the Realm Object Server.
  * <p>
- * A Session is created by opening a Realm instance using that configuration. Once a session has been created,
+ * A Session is created by opening a Realm instance using a {@link SyncConfiguration}. Once a session has been created,
  * it will continue to exist until the app is closed or all threads using this {@link SyncConfiguration} closes their respective {@link Realm}s.
  * <p>
- * A session is fully controlled by Realm, but can provide additional information in case of errors.
- * It is passed along in all {@link SyncSession.ErrorHandler}s.
+ * A session is controlled by Realm, but can provide additional information in case of errors.
+ * These errors are passed along in the {@link SyncSession.ErrorHandler}.
+ * <p>
+ * When creating a session, Realm will establish a connection to the server. This connection is
+ * controlled by Realm and might be shared between multiple sessions. It is possible to get insight
+ * into the connection using {@link #addConnectionChangeListener(ConnectionListener)} and {@link #isConnected()}.
+ * <p>
+ * The session itself has a different lifecycle than the underlying connection. The state of the session
+ * can be found using {@link #getState()}.
  * <p>
- * This object is thread safe.
+ * The {@link SyncSession} object is thread safe.
  */
 @Keep
 public class SyncSession {
@@ -101,13 +112,67 @@
     private static final byte STATE_VALUE_INACTIVE = 3;
     private static final byte STATE_VALUE_ERROR = 4;
 
+    // List of Java connection change listeners
+    private final CopyOnWriteArrayList<ConnectionListener> connectionListeners = new CopyOnWriteArrayList<>();
+
+    // Reference to the token representing the native listener for connection changes
+    // Only one native listener is used for all Java listeners
+    private long nativeConnectionListenerToken;
+
+    // represent different states as defined in SyncSession::PublicConnectionState 'sync_session.hpp'
+    // saved here instead of as constants in ConnectionState.java to enable static checking by JNI
+    static final byte CONNECTION_VALUE_DISCONNECTED = 0;
+    static final byte CONNECTION_VALUE_CONNECTING = 1;
+    static final byte CONNECTION_VALUE_CONNECTED = 2;
+
     private URI resolvedRealmURI;
 
+    /**
+     * Enum describing the states a SyncSession can be in. The initial state is
+     * {@link State#INACTIVE}.
+     * <p>
+     * A Realm will automatically synchronize data with the server if the session is either {@link State#ACTIVE}
+     * or {@link State#DYING} and {@link #isConnected()} returns {@code true}.
+     */
     public enum State {
+
+        /**
+         * This is the initial state. The session is closed. No data is being synchronized. The session
+         * will automatically transition to {@link #WAITING_FOR_ACCESS_TOKEN} when a Realm is opened.
+         */
+        INACTIVE(STATE_VALUE_INACTIVE),
+
+        /**
+         * The user is attempting to synchronize data but needs a valid access token to do so. Realm
+         * will either use a cached token or automatically try to acquire one based on the current
+         * users login. This requires a network connection.
+         * <p>
+         * Data cannot be synchronized in this state.
+         * <p>
+         * Once a valid token is acquired, the session will transition to {@link #ACTIVE}.
+         */
         WAITING_FOR_ACCESS_TOKEN(STATE_VALUE_WAITING_FOR_ACCESS_TOKEN),
+
+        /**
+         * The Realm is open and data will be synchronized between the device and the server
+         * if the underlying connection is {@link ConnectionState#CONNECTED}.
+         * <p>
+         * The session will remain in this state until either the current login expires or the Realm
+         * is closed. In the first case, the session will transition to {@link #WAITING_FOR_ACCESS_TOKEN},
+         * in the second case, it will become {@link #DYING}.
+         */
         ACTIVE(STATE_VALUE_ACTIVE),
+
+        /**
+         * The Realm was closed, but still contains data that needs to be synchronized to the server.
+         * The session will attempt to upload all local data before going {@link #INACTIVE}.
+         */
         DYING(STATE_VALUE_DYING),
-        INACTIVE(STATE_VALUE_INACTIVE),
+
+        /**
+         * DEPRECATED: This is never used. Errors are reported to {@link ErrorHandler} instead.
+         */
+        @Deprecated
         ERROR(STATE_VALUE_ERROR);
 
         final byte value;
@@ -116,7 +181,7 @@
             this.value = value;
         }
 
-        static State fromByte(byte value) {
+        static State fromNativeValue(long value) {
             State[] stateCodes = values();
             for (State state : stateCodes) {
                 if (state.value == value) {
@@ -124,7 +189,7 @@ static State fromByte(byte value) {
                 }
             }
 
-            throw new IllegalArgumentException("Unknown state code: " + value);
+            throw new IllegalArgumentException("Unknown session state code: " + value);
         }
     }
 
@@ -188,14 +253,45 @@ void notifySessionError(int errorCode, String errorMessage) {
      * @return the state of the session.
      * @see SyncSession.State
      */
-    @SuppressWarnings("unused")
     public State getState() {
         byte state = nativeGetState(configuration.getPath());
         if (state == -1) {
             // session was not found, probably the Realm was closed
             throw new IllegalStateException("Could not find session, Realm was probably closed");
         }
-        return State.fromByte(state);
+        return State.fromNativeValue(state);
+    }
+
+    /**
+     * Get the current state of the connection used by the session as defined in {@link ConnectionState}.
+     *
+     * @return the state of connection used by the session.
+     * @see ConnectionState
+     */
+    public ConnectionState getConnectionState() {
+        byte state = nativeGetConnectionState(configuration.getPath());
+        if (state == -1) {
+            // session was not found, probably the Realm was closed
+            throw new IllegalStateException("Could not find session, Realm was probably closed");
+        }
+        return ConnectionState.fromNativeValue(state);
+    }
+
+    /**
+     * Checks if the session is connected to the server and can synchronize data.
+     *
+     * This is a best guess effort. To conserve battery the underlying implementation uses heartbeats
+     * to  detect if the connection is still available. So if no data is actively being synced
+     * and some time has elapsed since the last heartbeat, the connection could have been dropped but
+     * this method will still return {@code true}.
+     *
+     * @return {@code true} if the session is connected and ready to synchronize data, {@code false}
+     * if not or if it is in the process of connecting.
+     */
+    public boolean isConnected() {
+        ConnectionState connectionState = ConnectionState.fromNativeValue(nativeGetConnectionState(configuration.getPath()));
+        State sessionState = getState();
+        return (sessionState == State.ACTIVE || sessionState == State.DYING) && connectionState == ConnectionState.CONNECTED;
     }
 
     synchronized void notifyProgressListener(long listenerId, long transferredBytes, long transferableBytes) {
@@ -210,7 +306,13 @@ synchronized void notifyProgressListener(long listenerId, long transferredBytes,
             RealmLog.debug("Trying unknown listener failed: " + listenerId);
         }
     }
-    
+
+    void notifyConnectionListeners(ConnectionState oldState, ConnectionState newState) {
+        for (ConnectionListener listener : connectionListeners) {
+            listener.onChange(oldState, newState);
+        }
+    }
+
     /**
      * Adds a progress listener tracking changes that need to be downloaded from the Realm Object
      * Server.
@@ -297,6 +399,36 @@ private void checkProgressListenerArguments(ProgressMode mode, ProgressListener
         }
     }
 
+    /**
+     * Adds a listener tracking changes to the connection backing this session. See {@link ConnectionState}
+     * for further details.
+     *
+     * @param listener the listener to register.
+     * @throws IllegalArgumentException if the listener is {@code null}.
+     * @see ConnectionState
+     */
+    public synchronized void addConnectionChangeListener(ConnectionListener listener) {
+        checkNonNullListener(listener);
+        if (connectionListeners.isEmpty()) {
+            nativeConnectionListenerToken = nativeAddConnectionListener(configuration.getPath());
+        }
+        connectionListeners.add(listener);
+    }
+
+    /**
+     * Removes a previously registered {@link ConnectionListener}.
+     *
+     * @param listener listener to remove
+     * @throws IllegalArgumentException if the listener is {@code null}.
+     */
+    public synchronized void removeConnectionChangeListener(ConnectionListener listener) {
+        checkNonNullListener(listener);
+        connectionListeners.remove(listener);
+        if (connectionListeners.isEmpty()) {
+            nativeRemoveConnectionListener(nativeConnectionListenerToken, configuration.getPath());
+        }
+    }
+
     void close() {
         isClosed = true;
         if (networkRequest != null) {
@@ -438,6 +570,12 @@ private void checkIfNotOnMainThread(String errorMessage) {
         }
     }
 
+    private void checkNonNullListener(@Nullable Object listener) {
+        if (listener == null) {
+            throw new IllegalArgumentException("Non-null 'listener' required.");
+        }
+    }
+
     /**
      * Interface used to report any session errors.
      *
@@ -712,10 +850,13 @@ public void throwExceptionIfNeeded() {
         }
     }
 
+    private static native long nativeAddConnectionListener(String localRealmPath);
+    private static native void nativeRemoveConnectionListener(long listenerId, String localRealmPath);
     private static native long nativeAddProgressListener(String localRealmPath, long listenerId, int direction, boolean isStreaming);
     private static native void nativeRemoveProgressListener(String localRealmPath, long listenerToken);
     private static native boolean nativeRefreshAccessToken(String localRealmPath, String accessToken, String realmUrl);
     private native boolean nativeWaitForDownloadCompletion(int callbackId, String localRealmPath);
     private native boolean nativeWaitForUploadCompletion(int callbackId, String localRealmPath);
     private static native byte nativeGetState(String localRealmPath);
+    private static native byte nativeGetConnectionState(String localRealmPath);
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
index 7ccccc9e46..c14df626b9 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
@@ -510,4 +510,68 @@ public void run() {
         SyncManager.simulateClientReset(SyncManager.getSession(config));
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void registerConnectionListener() {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        SyncConfiguration syncConfiguration = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .build();
+        Realm realm = Realm.getInstance(syncConfiguration);
+        SyncSession session = SyncManager.getSession(syncConfiguration);
+        session.addConnectionChangeListener((oldState, newState) -> {
+            if (newState == ConnectionState.DISCONNECTED) {
+                looperThread.testComplete();
+            }
+        });
+        realm.close();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void removeConnectionListener() {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        SyncConfiguration syncConfiguration = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .build();
+        Realm realm = Realm.getInstance(syncConfiguration);
+        SyncSession session = SyncManager.getSession(syncConfiguration);
+        ConnectionListener listener1 = (oldState, newState) -> {
+            if (newState == ConnectionState.DISCONNECTED) {
+                fail("Listener should have been removed");
+            }
+        };
+        ConnectionListener listener2 = (oldState, newState) -> {
+            if (newState == ConnectionState.DISCONNECTED) {
+                looperThread.testComplete();
+            }
+        };
+
+        session.addConnectionChangeListener(listener1);
+        session.addConnectionChangeListener(listener2);
+        session.removeConnectionChangeListener(listener1);
+        realm.close();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void isConnected() {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        SyncConfiguration syncConfiguration = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .build();
+        looperThread.closeAfterTest(Realm.getInstance(syncConfiguration));
+        SyncSession session = SyncManager.getSession(syncConfiguration);
+        if (session.isConnected()) {
+            looperThread.testComplete();
+        } else {
+            session.addConnectionChangeListener(((oldState, newState) -> {
+                if (newState == ConnectionState.CONNECTED) {
+                    assertEquals(session.getConnectionState(), ConnectionState.CONNECTED);
+                    assertTrue(session.isConnected());
+                    looperThread.testComplete();
+                }
+            }));
+        }
+    }
 }
