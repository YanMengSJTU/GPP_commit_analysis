diff --git a/.gitignore b/.gitignore
index a72b66b484..22df2e0956 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,7 +1,6 @@
 # Gradle build artifacts
 build
 realm/build
-realm-jni/build
 
 # Gradle cache
 .gradle
@@ -46,3 +45,9 @@ distribution/RealmGridViewExample/app/src
 distribution/RealmIntroExample/app/src
 distribution/RealmMigrationExample/app/src
 
+# Generated JNI headers
+realm/realm-library/src/main/cpp/jni_include
+# Downloaded core
+realm/realm-library/distribution
+# Cmake output
+realm/realm-library/.externalNativeBuild
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000000..35b419c520
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "realm/realm-library/src/main/cpp/object-store"]
+	path = realm/realm-library/src/main/cpp/object-store
+	url = https://github.com/realm/realm-object-store.git
diff --git a/CHANGELOG.md b/CHANGELOG.md
index f6678dde9d..3f62ff6c1f 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,134 @@
+## 2.0.0
+
+### Breaking Changes
+
+* `isValid()` now always returns `true` instead of `false` for unmanaged `RealmObject` and `RealmList`. This puts it in line with the behaviour of the Cocoa and .NET API's (#3101).
+* armeabi is not supported anymore.
+* Added new `RealmFileException`.
+  - `IncompatibleLockFileException` has been removed and replaced by `RealmFileException` with kind `INCOMPATIBLE_LOCK_FILE`.
+  - `RealmIOExcpetion` has been removed and replaced by `RealmFileException`.
+* Removed `RealmConfiguration.Builder(Context, File)` and `RealmConfiguration.Builder(File)` constructors.
+* `RealmConfiguration.Builder.assetFile(Context, String)` has been renamed to `RealmConfiguration.Builder.assetFile(String)`.
+* Object with primary key is now required to define it when the object is created. This means that `Realm.createObject(Class<E>)` and `DynamicRealm.createObject(String)` now throws `RealmException` if they are used to create an object with a primary key field. Use `Realm.createObject(Class<E>, Object)` or `DynamicRealm.createObject(String, Object)` instead.
+* Importing from JSON without the primary key field defined in the JSON object now throws `IllegalArgumentException`.
+* Now `Realm.beginTransaction()`, `Realm.executeTransaction()` and `Realm.waitForChange()` throw `RealmMigrationNeededException` if a remote process introduces incompatible schema changes (#3409).
+* The primary key value of an object can no longer be changed after the object was created. Instead a new object must be created and all fields copied over.
+* Now `Realm.createObject(Class)` and `Realm.createObject(Class,Object)` take the values from the model's fields and default constructor. Creating objects through the `DynamicRealm` does not use these values (#777).
+* When `Realm.create*FromJson()`s create a new `RealmObject`, now they take the default values defined by the field itself and its default constructor for those fields that are not defined in the JSON object.
+
+### Enhancements
+
+* Added `realmObject.isManaged()`, `RealmObject.isManaged(obj)` and `RealmCollection.isManaged()` (#3101).
+* Added `RealmConfiguration.Builder.directory(File)`.
+* `RealmLog` has been moved to the public API. It is now possible to control which events Realm emit to Logcat. See the `RealmLog` class for more details.
+* Typed `RealmObject`s can now continue to access their fields properly even though the schema was changed while the Realm was open (#3409).
+
+### Bug fixes
+
+* Fixed a lint error in proxy classes when the 'minSdkVersion' of user's project is smaller than 11 (#3356).
+* Fixed a potential crash when there were lots of async queries waiting in the queue.
+* Fixed a bug causing the Realm Transformer to not transform field access in the model's constructors (#3361).
+* Fixed a bug causing the `NullPointerException` when calling getters/setters in the model's constructors (#2536).
+
+### Internal
+
+* Moved JNI build to CMake.
+* Updated Realm Core to 2.0.0-rc4.
+
+## 1.2.0
+
+### Bug fixes
+
+* Throw a proper exception when operating on a non-existing field with the dynamic API (#3292).
+* `DynamicRealmObject.setList` should only accept `RealmList<DynamicRealmObject>` (#3280).
+* `DynamicRealmObject.getX(fieldName)` now throws a proper exception instead of a native crash when called with a field name of the wrong type (#3294).
+* Fixed a concurrency crash which might happen when `Realm.executeTransactionAsync()` tried to call `onSucess` after the Realm was closed.
+
+### Enhancements
+
+* Added `RealmQuery.in()` for a comparison against multiple values.
+* Added byte array (`byte[]`) support to `RealmQuery`'s `equalTo` and `notEqualTo` methods.
+* Optimized internal caching of schema classes (#3315).
+
+### Internal
+
+* Updated Realm Core to 1.5.1.
+* Improved sorting speed.
+* Completely removed the `OptionalAPITransformer`.
+
+### Credits
+
+* Thanks to Brenden Kromhout (@bkromhout) for adding binary array support to `equalTo` and `notEqualTo`.
+
+## 1.1.1
+
+### Bug fixes
+
+* Fixed a wrong JNI method declaration which might cause "method not found" crash on some devices.
+* Fixed a bug that `Error` in the background async thread is not forwarded to the caller thread.
+* Fixed a crash when an empty `Collection` is passed to `insert()`/`insertOrUpdate()` (#3103).
+* Fixed a bug that does not transfer the primary key when `RealmSchemaObject.setClassName()` is called to rename a class (#3118).
+* Fixed bug in `Realm.insert` and `Realm.insertOrUpdate` methods causing a `RealmList` to be cleared when inserting a managed `RealmModel` (#3105).
+* Fixed a concurrency allocation bug in storage engine which might lead to some random crashes.
+* Bulk insertion now throws if it is not called in a transaction (#3173).
+* The IllegalStateException thrown when accessing an empty RealmObject is now more meaningful (#3200).
+* `insert()` now correctly throws an exception if two different objects have the same primary key (#3212).
+* Blackberry Z10 throwing "Function not implemented" (#3178).
+* Reduced the number of file descriptors used by Realm Core (#3197).
+* Throw a proper `IllegalStateException` if a `RealmChangeListener` is used inside an IntentService (#2875).
+
+### Enhancements
+
+* The Realm Annotation processor no longer consumes the Realm annotations. Allowing other annotation processors to run.
+
+### Internal
+
+* Updated Realm Core to 1.4.2.
+
+## 1.1.0
+
+### Bug fixes
+
+* A number of bug fixes in the storage engine related to memory management in rare cases when a Realm has been compacted.
+* Disabled the optional API transformer since it has problems with DexGuard (#3022).
+* `OnSuccess.OnSuccess()` might not be called with the correct Realm version for async transaction (#1893).
+* Fixed a bug in `copyToRealm()` causing a cyclic dependency objects being duplicated.
+* Fixed a build failure when model class has a conflicting name such as `Map`, `List`, `String`, ... (#3077).
+
+### Enhancements
+
+* Added `insert(RealmModel obj)`, `insertOrUpdate(RealmModel obj)`, `insert(Collection<RealmModel> collection)` and `insertOrUpdate(Collection<RealmModel> collection)` to perform batch inserts (#1684).
+* Enhanced `Table.toString()` to show a PrimaryKey field details (#2903).
+* Enabled ReLinker when loading a Realm from a custom path by adding a `RealmConfiguration.Builder(Context, File)` constructor (#2900).
+* Changed `targetSdkVersion` of `realm-library` to 24.
+* Logs warning if `DynamicRealm` is not closed when GC happens as it does for `Realm`.
+
+### Deprecated
+
+* `RealmConfiguration.Builder(File)`. Use `RealmConfiguration.Builder(Context, File)` instead.
+
+### Internal
+
+* Updated Realm Core to 1.2.0.
+
+## 1.0.1
+
+### Bug fixes
+
+* Fixed a crash when calling `Table.toString()` in debugger (#2429).
+* Fixed a race condition which would cause some `RealmResults` to not be properly updated inside a `RealmChangeListener`. This could result in crashes when accessing items from those results (#2926/#2951).
+* Revised `RealmResults.isLoaded()` description (#2895).
+* Fixed a bug that could cause Realm to lose track of primary key when using `RealmObjectSchema.removeField()` and `RealmObjectSchema.renameField()` (#2829/#2926).
+* Fixed a bug that prevented some devices from finding async related JNI methods correctly.
+* Updated ProGuard configuration in order not to depend on Android's default configuration (#2972).
+* Fixed a race condition between Realms notifications and other UI events. This could e.g. cause ListView to crash (#2990).
+* Fixed a bug that allowed both `RealmConfiguration.Builder.assetFile()`/`deleteRealmIfMigrationNeeded()` to be configured at the same time, which leads to the asset file accidentally being deleted in migrations (#2933).
+* Realm crashed outright when the same Realm file was opened in two processes. Realm will now optimistically retry opening for 1 second before throwing an Error (#2459).
+
+### Enhancements
+
+* Removes RxJava related APIs during bytecode transforming to make RealmObject plays well with reflection when rx.Observable doesn't exist.
+
 ## 1.0.0
 
 No changes since 0.91.1.
@@ -8,7 +139,7 @@ No changes since 0.91.1.
 
 ### Bug fixes
 
-* Fixed a bug when opening a Realm cause a staled memory mapping. Symptoms are error messages like "Bad or incompatible history type", "File format version doesn't match", and "Encrypted interprocess sharing is currently unsupported". 
+* Fixed a bug when opening a Realm causes a staled memory mapping. Symptoms are error messages like "Bad or incompatible history type", "File format version doesn't match", and "Encrypted interprocess sharing is currently unsupported".
 
 ## 0.91.0
 
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 117abc2ef9..e25a9af5f1 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -182,3 +182,19 @@ public RealmQuery<E> equalTo(String fieldName, String fieldValue, boolean caseSe
 
 Above is based on the official guidelines from Oracle regarding Javadoc: http://www.oracle.com/technetwork/articles/java/index-137868.html
 
+### Branch Strategy
+
+We have two branches for shared development: `master` and `releases`. We make releases from each.
+
+`master`:
+
+* The `master` branch is where major/minor versions are released from.
+* It is for new features and/or breaking changes.
+
+`releases`:
+
+* The releases branch is where patch versions are released from.
+* It is mainly for bug fixes.
+* Every commit is automatically merged to `master`.
+* Minor changes (e.g. to documentation, tests, and the build system) may not affect end users but should still be merged to `releases` to avoid diverging too far from `master` and to reduce the likelihood of merge conflicts.
+
diff --git a/Dockerfile b/Dockerfile
new file mode 100644
index 0000000000..f3c06ffa5e
--- /dev/null
+++ b/Dockerfile
@@ -0,0 +1,61 @@
+FROM ubuntu:16.04
+
+# Locales
+RUN locale-gen en_US.UTF-8
+ENV LANG "en_US.UTF-8"
+ENV LANGUAGE "en_US.UTF-8"
+ENV LC_ALL "en_US.UTF-8"
+
+# Set the environment variables
+ENV JAVA_HOME /usr/lib/jvm/java-8-openjdk-amd64
+ENV ANDROID_HOME /opt/android-sdk-linux
+# Need by cmake
+ENV ANDROID_NDK_HOME /opt/android-ndk
+ENV PATH ${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
+ENV PATH ${PATH}:${NDK_HOME}
+
+# Install the JDK
+# We are going to need some 32 bit binaries because aapt requires it
+# file is need by the script that creates NDK toolchains
+RUN DEBIAN_FRONTEND=noninteractive dpkg --add-architecture i386 \
+    && apt-get update -qq \
+    && apt-get install -y file git curl wget zip unzip \
+                       bsdmainutils \
+                       build-essential \
+                       openjdk-8-jdk-headless \
+                       libc6:i386 libstdc++6:i386 libgcc1:i386 libncurses5:i386 libz1:i386 \
+    && apt-get clean
+
+# Install the Android SDK
+RUN cd /opt && \
+    wget -q https://dl.google.com/android/repository/tools_r25.1.7-linux.zip -O android-tools-linux.zip && \
+    unzip android-tools-linux.zip -d ${ANDROID_HOME} && \
+    rm -f android-tools-linux.zip
+
+# Grab what's needed in the SDK
+# ↓ updates tools to at least 25.1.7, but that prints 'Nothing was installed' (so I don't check the outputs).
+RUN echo y | android update sdk --no-ui --all --filter tools > /dev/null
+RUN echo y | android update sdk --no-ui --all --filter platform-tools | grep 'package installed'
+RUN echo y | android update sdk --no-ui --all --filter build-tools-24.0.0 | grep 'package installed'
+RUN echo y | android update sdk --no-ui --all --filter extra-android-m2repository | grep 'package installed'
+RUN echo y | android update sdk --no-ui --all --filter android-24 | grep 'package installed'
+
+# Install the NDK
+RUN mkdir /opt/android-ndk-tmp && \
+    cd /opt/android-ndk-tmp && \
+    wget -q http://dl.google.com/android/ndk/android-ndk-r10e-linux-x86_64.bin -O android-ndk.bin && \
+    chmod a+x ./android-ndk.bin && \
+    ./android-ndk.bin && \
+    mv android-ndk-r10e /opt/android-ndk && \
+    rm -rf /opt/android-ndk-tmp && \
+    chmod -R a+rX /opt/android-ndk
+
+# Install cmake
+RUN mkdir /opt/cmake-tmp && \
+    cd /opt/cmake-tmp && \
+    wget -q https://dl.google.com/android/repository/cmake-3.6.3133135-linux-x86_64.zip -O cmake-linux.zip && \
+    unzip cmake-linux.zip -d ${ANDROID_HOME}/cmake && \
+    rm -rf /opt/cmake-tmp
+
+# Make the SDK universally readable
+RUN chmod -R a+rX ${ANDROID_HOME}
diff --git a/Jenkinsfile b/Jenkinsfile
new file mode 100644
index 0000000000..de5d3ebddd
--- /dev/null
+++ b/Jenkinsfile
@@ -0,0 +1,164 @@
+#!groovy
+
+import groovy.json.JsonOutput
+
+def buildSuccess = false
+try {
+  node('android') {
+    // Allocate a custom workspace to avoid having % in the path (it breaks ld)
+    ws('/tmp/realm-java') {
+      stage 'SCM'
+      checkout scm
+      // Make sure not to delete the folder that Jenkins allocates to store scripts
+      sh 'git clean -ffdx -e .????????'
+      // Update submodule for object-store
+      sh 'git submodule sync'
+      sh 'git submodule update --init --force'
+
+      stage 'Docker build'
+      def buildEnv = docker.build 'realm-java:snapshot'
+      buildEnv.inside("-e HOME=/tmp -e _JAVA_OPTIONS=-Duser.home=/tmp --privileged -v /dev/bus/usb:/dev/bus/usb -v ${env.HOME}/gradle-cache:/tmp/.gradle -v ${env.HOME}/.android:/tmp/.android") {
+        stage 'JVM tests'
+        try {
+          gradle 'assemble check javadoc'
+        } finally {
+          storeJunitResults 'realm/realm-annotations-processor/build/test-results/TEST-*.xml'
+          storeJunitResults 'examples/unitTestExample/build/test-results/**/TEST-*.xml'
+          step([$class: 'LintPublisher'])
+        }
+
+        stage 'Static code analysis'
+        try {
+          gradle('realm', 'findbugs pmd checkstyle')
+        } finally {
+          publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/findbugs', reportFiles: 'findbugs-output.html', reportName: 'Findbugs issues'])
+          publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/reports/pmd', reportFiles: 'pmd.html', reportName: 'PMD Issues'])
+          step([$class: 'CheckStylePublisher',
+          canComputeNew: false,
+          defaultEncoding: '',
+          healthy: '',
+          pattern: 'realm/realm-library/build/reports/checkstyle/checkstyle.xml',
+          unHealthy: ''
+          ])
+        }
+
+        stage 'Run instrumented tests'
+        boolean archiveLog = true
+        String backgroundPid
+        try {
+          backgroundPid = startLogCatCollector()
+          gradle('realm', 'connectedUnitTests')
+          archiveLog = false;
+        } finally {
+          stopLogCatCollector(backgroundPid, archiveLog)
+          storeJunitResults 'realm/realm-library/build/outputs/androidTest-results/connected/TEST-*.xml'
+        }
+
+        // TODO: add support for running monkey on the example apps
+
+        if (env.BRANCH_NAME == 'master') {
+          stage 'Collect metrics'
+          collectAarMetrics()
+
+          stage 'Publish to OJO'
+          withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: 'bintray', passwordVariable: 'BINTRAY_KEY', usernameVariable: 'BINTRAY_USER']]) {
+            sh "chmod +x gradlew && ./gradlew -PbintrayUser=${env.BINTRAY_USER} -PbintrayKey=${env.BINTRAY_KEY} assemble ojoUpload --stacktrace"
+          }
+        }
+      }
+    }
+  }
+  currentBuild.rawBuild.setResult(Result.SUCCESS)
+  buildSuccess = true
+} catch(Exception e) {
+  currentBuild.rawBuild.setResult(Result.FAILURE)
+  buildSuccess = false
+  throw e
+} finally {
+  if (['master', 'releases'].contains(env.BRANCH_NAME) && !buildSuccess) {
+    node {
+      withCredentials([[$class: 'StringBinding', credentialsId: 'slack-java-url', variable: 'SLACK_URL']]) {
+        def payload = JsonOutput.toJson([
+          username: 'Mr. Jenkins',
+          icon_emoji: ':jenkins:',
+          attachments: [[
+            'title': "The ${env.BRANCH_NAME} branch is broken!",
+            'text': "<${env.BUILD_URL}|Click here> to check the build.",
+            'color': "danger"
+          ]]
+        ])
+        sh "curl -X POST --data-urlencode \'payload=${payload}\' ${env.SLACK_URL}"
+      }
+    }
+  }
+}
+
+
+def String startLogCatCollector() {
+  sh '''adb logcat -c
+  adb logcat -v time > "logcat.txt" &
+  echo $! > pid
+  '''
+  return readFile("pid").trim()
+}
+
+def stopLogCatCollector(String backgroundPid, boolean archiveLog) {
+  sh "kill ${backgroundPid}"
+  if (archiveLog) {
+    zip([
+      'zipFile': 'logcat.zip',
+      'archive': true,
+      'glob' : 'logcat.txt'
+    ])
+  }
+  sh 'rm logcat.txt '
+}
+
+def sendMetrics(String metric, String value) {
+  withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: '5b8ad2d9-61a4-43b5-b4df-b8ff6b1f16fa', passwordVariable: 'influx_pass', usernameVariable: 'influx_user']]) {
+    sh "curl -i -XPOST 'https://greatscott-pinheads-70.c.influxdb.com:8086/write?db=realm' --data-binary '${metric} value=${value}i' --user '${env.influx_user}:${env.influx_pass}'"
+  }
+}
+
+def sendTaggedMetric(String metric, String value, String tagName, String tagValue) {
+  withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: '5b8ad2d9-61a4-43b5-b4df-b8ff6b1f16fa', passwordVariable: 'influx_pass', usernameVariable: 'influx_user']]) {
+    sh "curl -i -XPOST 'https://greatscott-pinheads-70.c.influxdb.com:8086/write?db=realm' --data-binary '${metric},${tagName}=${tagValue} value=${value}i' --user '${env.influx_user}:${env.influx_pass}'"
+  }
+}
+
+def storeJunitResults(String path) {
+  step([
+    $class: 'JUnitResultArchiver',
+    testResults: path
+  ])
+}
+
+def collectAarMetrics() {
+  sh '''set -xe
+  cd realm/realm-library/build/outputs/aar
+  unzip realm-android-library-release.aar -d unzipped
+  find $ANDROID_HOME -name dx | sort -r | head -n 1 > dx
+  $(cat dx) --dex --output=temp.dex unzipped/classes.jar
+  cat temp.dex | head -c 92 | tail -c 4 | hexdump -e '1/4 "%d"' > methods
+  '''
+
+  sendMetrics('methods', readFile('realm/realm-library/build/outputs/aar/methods'))
+
+  def aarFile = findFiles(glob: 'realm/realm-library/build/outputs/aar/realm-android-library-release.aar')[0]
+  sendMetrics('aar_size', aarFile.length as String)
+
+  def soFiles = findFiles(glob: 'realm/realm-library/build/outputs/aar/unzipped/jni/*/librealm-jni.so')
+  for (int i = 0; i < soFiles.length; i++) {
+      def abiName = soFiles[i].path.tokenize('/')[-2]
+      def libSize = soFiles[i].length as String
+      sendTaggedMetric('abi_size', libSize, 'type', abiName)
+  }
+}
+
+def gradle(String commands) {
+  sh "chmod +x gradlew && ./gradlew ${commands} --stacktrace"
+}
+
+def gradle(String relativePath, String commands) {
+  sh "cd ${relativePath} && chmod +x gradlew && ./gradlew ${commands} --stacktrace"
+}
diff --git a/README.md b/README.md
index 285431ba15..9f0eeec413 100644
--- a/README.md
+++ b/README.md
@@ -55,12 +55,13 @@ See [version.txt](version.txt) for the latest version number.
 
 In case you don't want to use the precompiled version, you can build Realm yourself from source.
 
-Prerequisites:
+### Prerequisites
 
- * Make sure `make` is available in your `$PATH`
+ * Make sure `make` is available in your `$PATH`.
  * Download the [**JDK 7**](http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html) or [**JDK 8**](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) from Oracle and install it.
- * Download & install the Android SDK, **Android 4.4.2 (API 19)**, **Android 4.4W (API 20)** and **Android 5.0 (API 21)** (for example through Android Studio’s **Android SDK Manager**)
+ * Download & install the Android SDK **Build-Tools 24.0.0**, **Android N (API 24)** (for example through Android Studio’s **Android SDK Manager**).
  * Download the **Android NDK (= r10e)** for [OS X](http://dl.google.com/android/ndk/android-ndk-r10e-darwin-x86_64.bin) or [Linux](http://dl.google.com/android/ndk/android-ndk-r10e-linux-x86_64.bin).
+ * Install CMake from SDK manager in Android Studio ("SDK Tools" -> "CMake").
  * Or you can use [Hombrew-versions](https://github.com/Homebrew/homebrew-versions) to install Android NDK for Mac:
 
     ```
@@ -72,14 +73,20 @@ Prerequisites:
 
     ```
     export ANDROID_HOME=~/Library/Android/sdk
-    export NDK_HOME=/usr/local/Cellar/android-ndk-r10e/r10e
+    export ANDROID_NDK_HOME=/usr/local/Cellar/android-ndk-r10e/r10e
+    ```
+
+ * If you want to build with Android Studio, `ndk.dir` has to be defined in the `realm/local.properties` as well.
+
+    ```
+    ndk.dir=/usr/local/Cellar/android-ndk-r10e/r10e
     ```
 
  * If you are using OS X, you'd be better to add following lines to `~/.profile` (or `~/.zprofile` if the login shell is `zsh`) in order for Android Studio to see those environment variables.
 
     ```
     launchctl setenv ANDROID_HOME "$ANDROID_HOME"
-    launchctl setenv NDK_HOME "$NDK_HOME"
+    launchctl setenv ANDROID_NDK_HOME "$ANDROID_NDK_HOME"
     ```
 
  * And if you'd like to specify the location to store the archives of Realm's core, set `REALM_CORE_DOWNLOAD_DIR` environment variable. It enables you to keep core's archive when executing `git clean -xfd`.
@@ -94,6 +101,22 @@ Prerequisites:
    launchctl setenv REALM_CORE_DOWNLOAD_DIR "$REALM_CORE_DOWNLOAD_DIR"
    ```
 
+### Download sources
+
+You can download the source code of Realm Java by using git. Since realm-java has git submodules, use `--recursive` when cloning the repository.
+
+```
+git clone git@github.com:realm/realm-java.git --recursive
+```
+
+or
+
+```
+git clone https://github.com/realm/realm-java.git --recursive
+```
+
+### Build
+
 Once you have completed all the pre-requisites building Realm is done with a simple command
 
 ```
@@ -133,6 +156,12 @@ This means that `./gradlew clean` and `./gradlew cleanExamples` will fail if `as
 Note that IntelliJ [does not support multiple projects in the same window](https://youtrack.jetbrains.com/issue/IDEABKL-6118#)
 so each sub-project must be opened in its own window.
 
+## Examples
+
+The `./examples` folder contain a number of example projects showing how Realm can be used. If this is the first time you checkout or pull a new version of this repository to try the examples, you must call `./gradlew installRealmJava` from the top-level directory first. Otherwise the examples will not compile as they depend on all Realm artifacts being installed in `mavenLocal()`.
+
+Standalone examples can be [downloaded from website](https://realm.io/docs/java/latest/#getting-started).
+
 ## Contributing
 
 See [CONTRIBUTING.md](CONTRIBUTING.md) for more details!
diff --git a/build.gradle b/build.gradle
index cef0f4b666..228c2813a0 100644
--- a/build.gradle
+++ b/build.gradle
@@ -59,7 +59,17 @@ task assembleRealm(type:GradleBuild) {
     }
 }
 
-task check(type:GradleBuild) {
+task checkExamples(type:GradleBuild) {
+    group = 'Test'
+    description = 'Run the JVM tests and checks the examples'
+    buildFile = file('examples/build.gradle')
+    tasks = ['check']
+    if (project.hasProperty('buildTargetABIs')) {
+        startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
+    }
+}
+
+task checkRealm(type:GradleBuild) {
     group = 'Test'
     description = 'Run the JVM tests and checks Realm project'
     buildFile = file('realm/build.gradle')
@@ -69,6 +79,13 @@ task check(type:GradleBuild) {
     }
 }
 
+task check {
+    group = 'Test'
+    description = 'Run the JVM tests and checks in the realm and examples projects'
+    dependsOn checkRealm
+    dependsOn checkExamples
+}
+
 task connectedUnitTests(type:GradleBuild) {
     group = 'Test'
     description = 'Run the Android unit tests of the Realm project'
@@ -196,7 +213,7 @@ task distributionJniUnstrippedPackage(type:Zip) {
     archiveName = "realm-java-jni-libs-unstripped-${currentVersion}.zip"
     destinationDir = file("${buildDir}/outputs/distribution")
 
-    from("realm/realm-jni/build/outputs/jniLibs-unstripped") {
+    from("realm/realm-library/build/outputs/jniLibs-unstripped") {
         include '**/*.so'
     }
 }
@@ -288,6 +305,7 @@ task bintrayRealm(type: GradleBuild) {
     group = 'Publishing'
     buildFile = file('realm/build.gradle')
     tasks = ['bintrayUpload']
+    startParameter.projectProperties = gradle.startParameter.projectProperties
     if (project.hasProperty('buildTargetABIs')) {
         startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
     }
@@ -297,6 +315,7 @@ task bintrayAnnotations(type: GradleBuild) {
     description = 'Publish the Realm Annotations to Bintray'
     group = 'Publishing'
     buildFile = file('realm-annotations/build.gradle')
+    startParameter.projectProperties = gradle.startParameter.projectProperties
     tasks = ['bintrayUpload']
 }
 
@@ -304,6 +323,7 @@ task bintrayGradlePlugin(type: GradleBuild) {
     description = 'Publish the Realm Gradle Plugin to Bintray'
     group = 'Publishing'
     buildFile = file('gradle-plugin/build.gradle')
+    startParameter.projectProperties = gradle.startParameter.projectProperties
     tasks = ['bintrayUpload']
 }
 
@@ -311,6 +331,7 @@ task bintrayTransformer(type: GradleBuild) {
     description = 'Publish the Realm Transformer to Bintray'
     group = 'Publishing'
     buildFile = file('realm-transformer/build.gradle')
+    startParameter.projectProperties = gradle.startParameter.projectProperties
     tasks = ['bintrayUpload']
 }
 
@@ -328,6 +349,7 @@ task ojoRealm(type: GradleBuild) {
     group = 'Publishing'
     buildFile = file('realm/build.gradle')
     tasks = ['artifactoryPublish']
+    startParameter.projectProperties = gradle.startParameter.projectProperties
     if (project.hasProperty('buildTargetABIs')) {
         startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
     }
@@ -337,6 +359,7 @@ task ojoAnnotations(type: GradleBuild) {
     description = 'Publish the Realm Annotations SNAPSHOT to Bintray'
     group = 'Publishing'
     buildFile = file('realm-annotations/build.gradle')
+    startParameter.projectProperties = gradle.startParameter.projectProperties
     tasks = ['artifactoryPublish']
 }
 
@@ -344,6 +367,7 @@ task ojoGradlePlugin(type: GradleBuild) {
     description = 'Publish the Realm Gradle Plugin SNAPSHOT to Bintray'
     group = 'Publishing'
     buildFile = file('gradle-plugin/build.gradle')
+    startParameter.projectProperties = gradle.startParameter.projectProperties
     tasks = ['artifactoryPublish']
 }
 
@@ -351,6 +375,7 @@ task ojoTransformer(type: GradleBuild) {
     description = 'Publish the Realm Transformer SNAPSHOT to Bintray'
     group = 'Publishing'
     buildFile = file('realm-transformer/build.gradle')
+    startParameter.projectProperties = gradle.startParameter.projectProperties
     tasks = ['artifactoryPublish']
 }
 
diff --git a/examples/build.gradle b/examples/build.gradle
index f8e6fe2e64..47be4e4ca1 100644
--- a/examples/build.gradle
+++ b/examples/build.gradle
@@ -1,5 +1,5 @@
-project.ext.sdkVersion = 23
-project.ext.buildTools = '23.0.0'
+project.ext.sdkVersion = 24
+project.ext.buildTools = '24.0.0'
 
 // Don't cache SNAPSHOT (changing) dependencies.
 configurations.all {
diff --git a/examples/encryptionExample/build.gradle b/examples/encryptionExample/build.gradle
index 60181889d3..c58427e952 100644
--- a/examples/encryptionExample/build.gradle
+++ b/examples/encryptionExample/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
 apply plugin: 'realm-android'
diff --git a/examples/encryptionExample/lint.xml b/examples/encryptionExample/lint.xml
index 3e72f2f79a..0666c5455c 100644
--- a/examples/encryptionExample/lint.xml
+++ b/examples/encryptionExample/lint.xml
@@ -5,4 +5,5 @@
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="TrulyRandom" severity="ignore" />
     <issue id="PrngFix" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/encryptionExample/src/main/AndroidManifest.xml b/examples/encryptionExample/src/main/AndroidManifest.xml
index 28d1c607d0..b3bb0e1028 100644
--- a/examples/encryptionExample/src/main/AndroidManifest.xml
+++ b/examples/encryptionExample/src/main/AndroidManifest.xml
@@ -4,7 +4,7 @@
 
     <application
         android:allowBackup="true"
-        android:icon="@drawable/ic_launcher"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme">
         <activity
diff --git a/examples/encryptionExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/encryptionExample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 433021180b..0000000000
Binary files a/examples/encryptionExample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/examples/encryptionExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/encryptionExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/encryptionExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/encryptionExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/encryptionExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/encryptionExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/encryptionExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/encryptionExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/encryptionExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/encryptionExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/encryptionExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/encryptionExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/encryptionExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/encryptionExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/encryptionExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/gridViewExample/build.gradle b/examples/gridViewExample/build.gradle
index 049cf16cbf..474e8611e1 100644
--- a/examples/gridViewExample/build.gradle
+++ b/examples/gridViewExample/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
 apply plugin: 'realm-android'
diff --git a/examples/gridViewExample/lint.xml b/examples/gridViewExample/lint.xml
index 58a8015fe4..3af2534ba6 100644
--- a/examples/gridViewExample/lint.xml
+++ b/examples/gridViewExample/lint.xml
@@ -5,4 +5,5 @@
     <issue id="IconLauncherShape" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/gridViewExample/src/main/AndroidManifest.xml b/examples/gridViewExample/src/main/AndroidManifest.xml
index d7f791e888..1bf1d8752c 100644
--- a/examples/gridViewExample/src/main/AndroidManifest.xml
+++ b/examples/gridViewExample/src/main/AndroidManifest.xml
@@ -4,7 +4,7 @@
 
     <application
         android:allowBackup="true"
-        android:icon="@drawable/ic_launcher"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme">
         <activity
diff --git a/examples/gridViewExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/gridViewExample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 433021180b..0000000000
Binary files a/examples/gridViewExample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/examples/gridViewExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/gridViewExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/gridViewExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/gridViewExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/gridViewExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/gridViewExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/gridViewExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/gridViewExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/gridViewExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/gridViewExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/gridViewExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/gridViewExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/gridViewExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/gridViewExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/gridViewExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/introExample/build.gradle b/examples/introExample/build.gradle
index b253559d33..d61e93b5a3 100644
--- a/examples/introExample/build.gradle
+++ b/examples/introExample/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
 apply plugin: 'com.neenbedankt.android-apt'
diff --git a/examples/introExample/lint.xml b/examples/introExample/lint.xml
index 3b74cb97d0..3af2534ba6 100644
--- a/examples/introExample/lint.xml
+++ b/examples/introExample/lint.xml
@@ -5,5 +5,5 @@
     <issue id="IconLauncherShape" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
-    
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/introExample/src/main/AndroidManifest.xml b/examples/introExample/src/main/AndroidManifest.xml
index 9263488282..f23c433da2 100644
--- a/examples/introExample/src/main/AndroidManifest.xml
+++ b/examples/introExample/src/main/AndroidManifest.xml
@@ -3,7 +3,7 @@
     package="io.realm.examples.intro" >
 
     <application
-        android:icon="@drawable/ic_launcher"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme" >
         <activity
diff --git a/examples/introExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/introExample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 433021180b..0000000000
Binary files a/examples/introExample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/examples/introExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/introExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/introExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/introExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/introExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/introExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/introExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/introExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/introExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/introExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/introExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/introExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/introExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/introExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/introExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/jsonExample/build.gradle b/examples/jsonExample/build.gradle
index 4dcc5d1350..1b9bd2a6a7 100644
--- a/examples/jsonExample/build.gradle
+++ b/examples/jsonExample/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'com.neenbedankt.android-apt'
 apply plugin: 'android-command'
diff --git a/examples/jsonExample/lint.xml b/examples/jsonExample/lint.xml
index 9a4f122c70..6a7edc9890 100644
--- a/examples/jsonExample/lint.xml
+++ b/examples/jsonExample/lint.xml
@@ -4,4 +4,5 @@
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="PrngFix" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/jsonExample/src/main/AndroidManifest.xml b/examples/jsonExample/src/main/AndroidManifest.xml
index 22004a8ef0..7c50dd72f8 100644
--- a/examples/jsonExample/src/main/AndroidManifest.xml
+++ b/examples/jsonExample/src/main/AndroidManifest.xml
@@ -4,7 +4,7 @@
 
     <application
         android:allowBackup="true"
-        android:icon="@drawable/ic_launcher"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme">
         <activity
diff --git a/examples/jsonExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/jsonExample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 433021180b..0000000000
Binary files a/examples/jsonExample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/examples/jsonExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/jsonExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/jsonExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/jsonExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/jsonExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/jsonExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/jsonExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/jsonExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/jsonExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/jsonExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/jsonExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/jsonExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/jsonExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/jsonExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/jsonExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/kotlinExample/build.gradle b/examples/kotlinExample/build.gradle
index 6a94f78e9f..a7baf526da 100644
--- a/examples/kotlinExample/build.gradle
+++ b/examples/kotlinExample/build.gradle
@@ -1,5 +1,5 @@
 buildscript {
-    ext.kotlin_version = '1.0.2'
+    ext.kotlin_version = '1.0.3'
     repositories {
         jcenter()
         mavenCentral()
@@ -9,7 +9,6 @@ buildscript {
     }
 }
 
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'kotlin-android'
 apply plugin: 'android-command'
diff --git a/examples/kotlinExample/lint.xml b/examples/kotlinExample/lint.xml
index 829e13eda8..cc4d461aee 100644
--- a/examples/kotlinExample/lint.xml
+++ b/examples/kotlinExample/lint.xml
@@ -4,4 +4,5 @@
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="IconLauncherShape" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/kotlinExample/src/main/AndroidManifest.xml b/examples/kotlinExample/src/main/AndroidManifest.xml
index 877e97864f..3373613527 100644
--- a/examples/kotlinExample/src/main/AndroidManifest.xml
+++ b/examples/kotlinExample/src/main/AndroidManifest.xml
@@ -3,7 +3,7 @@
 
     <application
         android:allowBackup="true"
-        android:icon="@drawable/ic_launcher"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme">
         <activity
diff --git a/examples/kotlinExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/kotlinExample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 433021180b..0000000000
Binary files a/examples/kotlinExample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/examples/kotlinExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/kotlinExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/kotlinExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/kotlinExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/kotlinExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/kotlinExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/kotlinExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/kotlinExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/kotlinExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/kotlinExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/kotlinExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/kotlinExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/kotlinExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/kotlinExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/kotlinExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/migrationExample/build.gradle b/examples/migrationExample/build.gradle
index b15849923f..800fa0ee4f 100644
--- a/examples/migrationExample/build.gradle
+++ b/examples/migrationExample/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
 apply plugin: 'realm-android'
diff --git a/examples/migrationExample/lint.xml b/examples/migrationExample/lint.xml
index a1b63af0fd..1d3dbb0011 100644
--- a/examples/migrationExample/lint.xml
+++ b/examples/migrationExample/lint.xml
@@ -3,4 +3,5 @@
     <issue id="IconLauncherShape" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/migrationExample/src/main/AndroidManifest.xml b/examples/migrationExample/src/main/AndroidManifest.xml
index e92dc433ae..b21664e66a 100644
--- a/examples/migrationExample/src/main/AndroidManifest.xml
+++ b/examples/migrationExample/src/main/AndroidManifest.xml
@@ -4,7 +4,7 @@
 
     <application
         android:allowBackup="true"
-        android:icon="@drawable/ic_launcher"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme" >
         <activity
diff --git a/examples/migrationExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/migrationExample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 433021180b..0000000000
Binary files a/examples/migrationExample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/examples/migrationExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/migrationExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/migrationExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/migrationExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/migrationExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/migrationExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/migrationExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/migrationExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/migrationExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/migrationExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/migrationExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/migrationExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/migrationExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/migrationExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/migrationExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/moduleExample/app/build.gradle b/examples/moduleExample/app/build.gradle
index 33a5ed5655..957f094945 100644
--- a/examples/moduleExample/app/build.gradle
+++ b/examples/moduleExample/app/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
 apply plugin: 'realm-android'
diff --git a/examples/moduleExample/app/lint.xml b/examples/moduleExample/app/lint.xml
new file mode 100644
index 0000000000..1d3dbb0011
--- /dev/null
+++ b/examples/moduleExample/app/lint.xml
@@ -0,0 +1,7 @@
+<lint>
+    <issue id="AllowBackup" severity="ignore" />
+    <issue id="IconLauncherShape" severity="ignore" />
+    <issue id="IconMissingDensityFolder" severity="ignore" />
+    <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
+</lint>
diff --git a/examples/moduleExample/app/src/main/AndroidManifest.xml b/examples/moduleExample/app/src/main/AndroidManifest.xml
index 97549cad37..c5aaf2017b 100644
--- a/examples/moduleExample/app/src/main/AndroidManifest.xml
+++ b/examples/moduleExample/app/src/main/AndroidManifest.xml
@@ -3,7 +3,7 @@
     package="io.realm.examples.appmodules" >
 
     <application
-        android:icon="@drawable/ic_launcher"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme" >
         <activity
diff --git a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
index 12d4c014bb..246bafadfc 100644
--- a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
+++ b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
@@ -60,7 +60,7 @@ protected void onCreate(Bundle savedInstanceState) {
         // configuration would know about the following classes: { Cow, Pig, Snake, Spider }
         RealmConfiguration defaultConfig = new RealmConfiguration.Builder(this).build();
 
-        // It is possible to extend the default schema by adding additional Realm modules using setModule(). This can
+        // It is possible to extend the default schema by adding additional Realm modules using modules(). This can
         // also be Realm modules from libraries. The below Realm contains the following classes: { Cow, Pig, Snake,
         // Spider, Cat, Dog }
         RealmConfiguration farmAnimalsConfig = new RealmConfiguration.Builder(this)
diff --git a/examples/moduleExample/app/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/moduleExample/app/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 433021180b..0000000000
Binary files a/examples/moduleExample/app/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/examples/moduleExample/app/src/main/res/layout/activity_modules_example.xml b/examples/moduleExample/app/src/main/res/layout/activity_modules_example.xml
index f7891e6991..38d19031c7 100644
--- a/examples/moduleExample/app/src/main/res/layout/activity_modules_example.xml
+++ b/examples/moduleExample/app/src/main/res/layout/activity_modules_example.xml
@@ -13,7 +13,7 @@
         android:layout_height="wrap_content">
         <TextView
             android:gravity="center_horizontal"
-            android:text="Status Output..."
+            android:text="@string/status_output"
             android:textStyle="bold"
             android:textSize="18sp"
             android:layout_width="match_parent"
diff --git a/examples/moduleExample/app/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/moduleExample/app/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/moduleExample/app/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/moduleExample/app/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/moduleExample/app/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/moduleExample/app/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/moduleExample/app/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/moduleExample/app/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/moduleExample/app/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/moduleExample/app/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/moduleExample/app/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/moduleExample/app/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/moduleExample/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/moduleExample/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/moduleExample/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/moduleExample/app/src/main/res/values/strings.xml b/examples/moduleExample/app/src/main/res/values/strings.xml
index d6848f4045..3a9a495414 100644
--- a/examples/moduleExample/app/src/main/res/values/strings.xml
+++ b/examples/moduleExample/app/src/main/res/values/strings.xml
@@ -2,5 +2,6 @@
 <resources>
 
     <string name="app_name">RealmModule example</string>
+    <string name="status_output">Status Output…</string>
 
 </resources>
diff --git a/examples/moduleExample/library/build.gradle b/examples/moduleExample/library/build.gradle
index c4e79639f9..3697638a79 100644
--- a/examples/moduleExample/library/build.gradle
+++ b/examples/moduleExample/library/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.library'
 apply plugin: 'realm-android'
 
diff --git a/examples/moduleExample/library/lint.xml b/examples/moduleExample/library/lint.xml
index 58a8015fe4..3af2534ba6 100644
--- a/examples/moduleExample/library/lint.xml
+++ b/examples/moduleExample/library/lint.xml
@@ -5,4 +5,5 @@
     <issue id="IconLauncherShape" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/newsreaderExample/build.gradle b/examples/newsreaderExample/build.gradle
index f90596c1ed..3809773b25 100644
--- a/examples/newsreaderExample/build.gradle
+++ b/examples/newsreaderExample/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
 apply plugin: 'realm-android'
@@ -35,9 +34,9 @@ android {
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
     //noinspection GradleDependency
-    compile 'com.android.support:appcompat-v7:23.1.1'
+    compile 'com.android.support:appcompat-v7:24.0.0'
     //noinspection GradleDependency
-    compile 'com.android.support:design:23.1.1'
+    compile 'com.android.support:design:24.0.0'
     compile 'io.reactivex:rxjava:1.1.0'
     compile 'io.reactivex:rxandroid:1.1.0'
     compile 'com.squareup.retrofit:retrofit:2.0.0-beta2'
diff --git a/examples/newsreaderExample/lint.xml b/examples/newsreaderExample/lint.xml
index a1b63af0fd..1d3dbb0011 100644
--- a/examples/newsreaderExample/lint.xml
+++ b/examples/newsreaderExample/lint.xml
@@ -3,4 +3,5 @@
     <issue id="IconLauncherShape" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/newsreaderExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/newsreaderExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/newsreaderExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/newsreaderExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/newsreaderExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/newsreaderExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/newsreaderExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/newsreaderExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/newsreaderExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/newsreaderExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/newsreaderExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
old mode 100644
new mode 100755
index 433021180b..eb9ece04b2
Binary files a/examples/newsreaderExample/src/main/res/mipmap-xxhdpi/ic_launcher.png and b/examples/newsreaderExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/newsreaderExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/newsreaderExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/newsreaderExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/rxJavaExample/build.gradle b/examples/rxJavaExample/build.gradle
index e91c2e7875..9a916ede8a 100644
--- a/examples/rxJavaExample/build.gradle
+++ b/examples/rxJavaExample/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
 apply plugin: 'realm-android'
diff --git a/examples/rxJavaExample/lint.xml b/examples/rxJavaExample/lint.xml
index 829e13eda8..cc4d461aee 100644
--- a/examples/rxJavaExample/lint.xml
+++ b/examples/rxJavaExample/lint.xml
@@ -4,4 +4,5 @@
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="IconLauncherShape" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/rxJavaExample/src/main/AndroidManifest.xml b/examples/rxJavaExample/src/main/AndroidManifest.xml
index 8283fb31e6..b214dcd863 100644
--- a/examples/rxJavaExample/src/main/AndroidManifest.xml
+++ b/examples/rxJavaExample/src/main/AndroidManifest.xml
@@ -5,7 +5,7 @@
     <uses-permission android:name="android.permission.INTERNET" />
 
     <application
-        android:icon="@drawable/ic_launcher"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:name=".MyApplication"
         android:theme="@style/AppTheme" >
diff --git a/examples/rxJavaExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/rxJavaExample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 433021180b..0000000000
Binary files a/examples/rxJavaExample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/examples/rxJavaExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/rxJavaExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/rxJavaExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/rxJavaExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/rxJavaExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/rxJavaExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/rxJavaExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/rxJavaExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/rxJavaExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/rxJavaExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/rxJavaExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/rxJavaExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/rxJavaExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/rxJavaExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/rxJavaExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/threadExample/build.gradle b/examples/threadExample/build.gradle
index cc74e3a549..98ec9f1827 100644
--- a/examples/threadExample/build.gradle
+++ b/examples/threadExample/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
 apply plugin: 'realm-android'
@@ -26,5 +25,5 @@ android {
 
 dependencies {
     //noinspection GradleDependency
-    compile 'com.android.support:appcompat-v7:23.2.1'
+    compile 'com.android.support:appcompat-v7:24.0.0'
 }
diff --git a/examples/threadExample/lint.xml b/examples/threadExample/lint.xml
index 58a8015fe4..3af2534ba6 100644
--- a/examples/threadExample/lint.xml
+++ b/examples/threadExample/lint.xml
@@ -5,4 +5,5 @@
     <issue id="IconLauncherShape" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/threadExample/src/main/AndroidManifest.xml b/examples/threadExample/src/main/AndroidManifest.xml
index 3f54c69592..a59f33e36c 100644
--- a/examples/threadExample/src/main/AndroidManifest.xml
+++ b/examples/threadExample/src/main/AndroidManifest.xml
@@ -7,7 +7,7 @@
     <application
         android:name=".MyApplication"
         android:allowBackup="true"
-        android:icon="@drawable/ic_launcher"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme">
         <activity
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java
index 8d50ca9919..c64cf21644 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java
@@ -112,8 +112,13 @@ public void execute(Realm realm) {
     @Override
     public void onDestroy() {
         super.onDestroy();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.delete(Person.class);
+            }
+        });
         // Clear out all Person instances.
-        realm.delete(Person.class);
         realm.close();
     }
 }
diff --git a/examples/threadExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/threadExample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 433021180b..0000000000
Binary files a/examples/threadExample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/examples/threadExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/threadExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/threadExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/threadExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/threadExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/threadExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/threadExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/threadExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/threadExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/threadExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/threadExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/threadExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/threadExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/threadExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/threadExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/unitTestExample/build.gradle b/examples/unitTestExample/build.gradle
index b2a09b1677..f4a1b95430 100644
--- a/examples/unitTestExample/build.gradle
+++ b/examples/unitTestExample/build.gradle
@@ -1,4 +1,3 @@
-apply plugin: 'android-sdk-manager'
 apply plugin: 'com.android.application'
 apply plugin: 'android-command'
 apply plugin: 'com.neenbedankt.android-apt'
@@ -46,9 +45,9 @@ dependencies {
     testCompile "org.powermock:powermock-classloading-xstream:1.6.4"
 
 
-    androidTestCompile 'com.android.support.test:runner:0.4.1'
+    androidTestCompile 'com.android.support.test:runner:0.5'
     // Set this dependency to use JUnit 4 rules
-    androidTestCompile 'com.android.support.test:rules:0.4.1'
+    androidTestCompile 'com.android.support.test:rules:0.5'
     // Set this dependency to build and run Espresso tests
-    androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.1'
+    androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'
 }
diff --git a/examples/unitTestExample/lint.xml b/examples/unitTestExample/lint.xml
index a1b63af0fd..1d3dbb0011 100644
--- a/examples/unitTestExample/lint.xml
+++ b/examples/unitTestExample/lint.xml
@@ -3,4 +3,5 @@
     <issue id="IconLauncherShape" severity="ignore" />
     <issue id="IconMissingDensityFolder" severity="ignore" />
     <issue id="GoogleAppIndexingWarning" severity="ignore" />
+    <issue id="LogNotTimber" severity="ignore" />
 </lint>
diff --git a/examples/unitTestExample/src/main/AndroidManifest.xml b/examples/unitTestExample/src/main/AndroidManifest.xml
index bdb9f97441..5dfb87f40a 100644
--- a/examples/unitTestExample/src/main/AndroidManifest.xml
+++ b/examples/unitTestExample/src/main/AndroidManifest.xml
@@ -4,7 +4,7 @@
 
     <application
         android:allowBackup="true"
-        android:icon="@drawable/ic_launcher"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name"
         android:theme="@style/AppTheme" >
         <activity
diff --git a/examples/unitTestExample/src/main/res/drawable-xxhdpi/ic_launcher.png b/examples/unitTestExample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index 433021180b..0000000000
Binary files a/examples/unitTestExample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/examples/unitTestExample/src/main/res/mipmap-hdpi/ic_launcher.png b/examples/unitTestExample/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..58303aff5b
Binary files /dev/null and b/examples/unitTestExample/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/examples/unitTestExample/src/main/res/mipmap-mdpi/ic_launcher.png b/examples/unitTestExample/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b29caed3d
Binary files /dev/null and b/examples/unitTestExample/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/examples/unitTestExample/src/main/res/mipmap-xhdpi/ic_launcher.png b/examples/unitTestExample/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..15527b160e
Binary files /dev/null and b/examples/unitTestExample/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/examples/unitTestExample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/examples/unitTestExample/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..eb9ece04b2
Binary files /dev/null and b/examples/unitTestExample/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/examples/unitTestExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/examples/unitTestExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..91826a7567
Binary files /dev/null and b/examples/unitTestExample/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
index 4e23a70df5..c4b4d8403c 100644
--- a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
+++ b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
@@ -23,8 +23,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mockito;
+import org.powermock.api.mockito.PowerMockito;
 import org.powermock.core.classloader.annotations.PowerMockIgnore;
 import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.powermock.core.classloader.annotations.SuppressStaticInitializationFor;
+import org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl;
 import org.powermock.modules.junit4.rule.PowerMockRule;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricGradleTestRunner;
@@ -41,6 +44,9 @@
 import io.realm.RealmResults;
 import io.realm.examples.unittesting.model.Person;
 import io.realm.internal.RealmCore;
+import io.realm.internal.Util;
+import io.realm.log.Logger;
+import io.realm.log.RealmLog;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;
@@ -60,7 +66,8 @@
 @RunWith(RobolectricGradleTestRunner.class)
 @Config(constants = BuildConfig.class, sdk = 21)
 @PowerMockIgnore({"org.mockito.*", "org.robolectric.*", "android.*"})
-@PrepareForTest({Realm.class, RealmConfiguration.class, RealmQuery.class, RealmResults.class, RealmCore.class})
+@SuppressStaticInitializationFor("io.realm.internal.Util")
+@PrepareForTest({Realm.class, RealmConfiguration.class, RealmQuery.class, RealmResults.class, RealmCore.class, RealmLog.class})
 public class ExampleActivityTest {
 
     // Robolectric, Using Power Mock https://github.com/robolectric/robolectric/wiki/Using-PowerMock
@@ -74,10 +81,11 @@
     @Before
     public void setup() throws Exception {
 
-        // Setup Realm to be mocked
+        // Setup Realm to be mocked. The order of these matters
+        mockStatic(RealmCore.class);
+        mockStatic(RealmLog.class);
         mockStatic(Realm.class);
         mockStatic(RealmConfiguration.class);
-        mockStatic(RealmCore.class);
 
         // Create the mock
         final Realm mockRealm = mock(Realm.class);
@@ -89,6 +97,7 @@ public void setup() throws Exception {
         doNothing().when(RealmCore.class);
         RealmCore.loadLibrary(any(Context.class));
 
+
         // TODO: Mock the RealmConfiguration's constructor. If the RealmConfiguration.Builder.build can be mocked, this
         // is not necessary anymore.
         whenNew(RealmConfiguration.class).withAnyArguments().thenReturn(mockRealmConfig);
diff --git a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java
index e7be410e33..1c12d4114d 100644
--- a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java
+++ b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java
@@ -24,6 +24,7 @@
 import org.powermock.api.mockito.PowerMockito;
 import org.powermock.core.classloader.annotations.PowerMockIgnore;
 import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.powermock.core.classloader.annotations.SuppressStaticInitializationFor;
 import org.powermock.modules.junit4.rule.PowerMockRule;
 import org.robolectric.RobolectricGradleTestRunner;
 import org.robolectric.annotation.Config;
@@ -32,6 +33,7 @@
 import io.realm.examples.unittesting.model.Dog;
 import io.realm.examples.unittesting.repository.DogRepository;
 import io.realm.examples.unittesting.repository.DogRepositoryImpl;
+import io.realm.log.RealmLog;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;
@@ -45,7 +47,8 @@
 @RunWith(RobolectricGradleTestRunner.class)
 @Config(constants = BuildConfig.class, sdk = 19)
 @PowerMockIgnore({"org.mockito.*", "org.robolectric.*", "android.*"})
-@PrepareForTest({Realm.class})
+@SuppressStaticInitializationFor("io.realm.internal.Util")
+@PrepareForTest({Realm.class, RealmLog.class})
 public class ExampleRealmTest {
     // Robolectric, Using Power Mock https://github.com/robolectric/robolectric/wiki/Using-PowerMock
 
@@ -55,6 +58,7 @@
 
     @Before
     public void setup() {
+        mockStatic(RealmLog.class);
         mockStatic(Realm.class);
 
         Realm mockRealm = PowerMockito.mock(Realm.class);
diff --git a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
index 06600161bd..c533258ce2 100644
--- a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
+++ b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
@@ -39,11 +39,12 @@ class Realm implements Plugin<Project> {
             throw new GradleException('Realm gradle plugin only supports android gradle plugin 1.5.0 or later.')
         }
 
-        def isKotlinProject = project.plugins.find {
-            it.getClass().name == 'org.jetbrains.kotlin.gradle.plugin.KotlinAndroidPluginWrapper'
-        }
+        def usesKotlinPlugin = project.plugins.findPlugin('kotlin-android') != null
+        def usesAptPlugin = project.plugins.findPlugin('com.neenbedankt.android-apt') != null
+
+        def isKaptProject = usesKotlinPlugin && !usesAptPlugin
 
-        if (!isKotlinProject) {
+        if (!isKaptProject) {
             project.plugins.apply(AndroidAptPlugin)
         }
 
@@ -51,7 +52,7 @@ class Realm implements Plugin<Project> {
         project.repositories.add(project.getRepositories().jcenter())
         project.dependencies.add("compile", "io.realm:realm-android-library:${Version.VERSION}")
         project.dependencies.add("compile", "io.realm:realm-annotations:${Version.VERSION}")
-        if (isKotlinProject) {
+        if (isKaptProject) {
             project.dependencies.add("kapt", "io.realm:realm-annotations:${Version.VERSION}")
             project.dependencies.add("kapt", "io.realm:realm-annotations-processor:${Version.VERSION}")
         } else {
diff --git a/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy b/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
index 432348538b..d73ef15836 100644
--- a/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
+++ b/gradle-plugin/src/test/groovy/io/realm/gradle/PluginTest.groovy
@@ -30,6 +30,7 @@ import org.junit.Before
 import org.junit.Test
 
 import static org.junit.Assert.assertEquals
+import static org.junit.Assert.assertFalse
 import static org.junit.Assert.assertTrue
 import static org.junit.Assert.fail
 
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 587246a1a4..f71002edb7 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
diff --git a/logo.png b/logo.png
index cbe7817724..c64d652d2d 100644
Binary files a/logo.png and b/logo.png differ
diff --git a/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java b/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java
index ddef303a14..b9e263cf4e 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java
@@ -25,10 +25,11 @@
  * The @PrimaryKey annotation will mark a field as a primary key inside Realm. Only one field in a
  * RealmObject class can have this annotation, and the field should uniquely identify the object.
  * Trying to insert an object with an existing primary key will result in an
- * {@link io.realm.exceptions.RealmPrimaryKeyConstraintException}.
- *
+ * {@link io.realm.exceptions.RealmPrimaryKeyConstraintException}. Primary key cannot be changed
+ * after the object created.
+ * <p>
  * Primary keys also count as having the {@link Index} annotation.
- *
+ * <p>
  * It is allowed to apply this annotation on the following primitive types: byte, short, int, and long.
  * String, Byte, Short, Integer, and Long are also allowed, and further permitted to have {@code null}
  * as a primary key value.
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
index b927ef5b38..ce1fc39801 100644
--- a/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
@@ -57,7 +57,7 @@ class BytecodeModifier {
      * @param clazz The CtClass to modify
      * @param managedFields List of fields whose access should be replaced
      */
-    public static void useRealmAccessors(CtClass clazz, List<CtField> managedFields, List<CtClass> modelClasses) {
+    public static void useRealmAccessors(CtClass clazz, List<CtField> managedFields) {
         clazz.getDeclaredBehaviors().each { behavior ->
             logger.info "    Behavior: ${behavior.name}"
             if (
@@ -66,8 +66,7 @@ class BytecodeModifier {
                     !behavior.name.startsWith('realmGet$') &&
                     !behavior.name.startsWith('realmSet$')
                 ) || (
-                    behavior instanceof CtConstructor &&
-                    !modelClasses.contains(clazz)
+                    behavior instanceof CtConstructor
                 )
             ) {
                 behavior.instrument(new FieldAccessToAccessorConverter(managedFields, clazz, behavior))
@@ -95,7 +94,9 @@ class BytecodeModifier {
         final CtClass ctClass
         final CtBehavior behavior
 
-        FieldAccessToAccessorConverter(List<CtField> managedFields, CtClass ctClass, CtBehavior behavior) {
+        FieldAccessToAccessorConverter(List<CtField> managedFields,
+                                       CtClass ctClass,
+                                       CtBehavior behavior) {
             this.managedFields = managedFields
             this.ctClass = ctClass
             this.behavior = behavior
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
index d58fb39b7c..ba85db84ab 100644
--- a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
@@ -137,7 +137,7 @@ class RealmTransformer extends Transform {
         inputClassNames.each {
             logger.info "  Modifying class ${it}"
             def ctClass = classPool.getCtClass(it)
-            BytecodeModifier.useRealmAccessors(ctClass, allManagedFields, allModelClasses)
+            BytecodeModifier.useRealmAccessors(ctClass, allManagedFields)
             ctClass.writeFile(getOutputFile(outputProvider).canonicalPath)
         }
 
diff --git a/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy b/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy
index 65609cd5df..6a8b6ee34d 100644
--- a/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy
+++ b/realm-transformer/src/test/groovy/io/realm/transformer/BytecodeModifierTest.groovy
@@ -79,7 +79,7 @@ class BytecodeModifierTest extends Specification {
     def "UseRealmAccessors"() {
         setup: 'generate an empty class'
         def classPool = ClassPool.getDefault()
-        def ctClass = classPool.makeClass('testClass')
+        def ctClass = classPool.makeClass('TestClass')
 
         and: 'add a field'
         def ctField = new CtField(CtClass.intType, 'age', ctClass)
@@ -93,23 +93,13 @@ class BytecodeModifierTest extends Specification {
         BytecodeModifier.addRealmAccessors(ctClass)
 
         when: 'the field use is replaced by the accessor'
-        BytecodeModifier.useRealmAccessors(ctClass, [ctField], [])
+        BytecodeModifier.useRealmAccessors(ctClass, [ctField])
 
-        then: 'the field is not used in the method anymore'
-        def methodInfo = ctMethod.getMethodInfo()
-        def codeAttribute = methodInfo.getCodeAttribute()
-        def fieldIsUsed = false
-        for (CodeIterator ci = codeAttribute.iterator(); ci.hasNext();) {
-            int index = ci.next();
-            int op = ci.byteAt(index);
-            if (op == Opcode.GETFIELD) {
-                fieldIsUsed = true
-            }
-        }
-        !fieldIsUsed
+        then: 'the field is not used and getter is called in the method '
+        !isFieldRead(ctMethod) && hasMethodCall(ctMethod)
     }
 
-    def "UseRealmAccessorsInNonDefaultConstructor"() {
+    def "UseRealmAccessors_fieldAccessConstructorIsTransformed"() {
         setup: 'generate an empty class'
         def classPool = ClassPool.getDefault()
         def ctClass = classPool.makeClass('TestClass')
@@ -122,27 +112,50 @@ class BytecodeModifierTest extends Specification {
         def ctMethod = CtNewMethod.make('private void setupAge(int age) { this.age = age; }', ctClass)
         ctClass.addMethod(ctMethod)
 
-        and: 'add a constructor that uses the method'
-        def ctConstructor = CtNewConstructor.make('public TestClass(int age) { setupAge(age); }', ctClass)
-        ctClass.addConstructor(ctConstructor)
+        and: 'add a default constructor that uses the method'
+        def ctDefaultConstructor = CtNewConstructor.make('public TestClass() { int myAge = this.age; }', ctClass)
+        ctClass.addConstructor(ctDefaultConstructor)
+
+        and: 'add a non-default constructor that uses the method'
+        def ctNonDefaultConstructor = CtNewConstructor.make('public TestClass(TestClass other) { int otherAge = other.age; }', ctClass)
+        ctClass.addConstructor(ctNonDefaultConstructor)
 
         and: 'realm accessors are added'
         BytecodeModifier.addRealmAccessors(ctClass)
 
         when: 'the field use is replaced by the accessor'
-        BytecodeModifier.useRealmAccessors(ctClass, [ctField], [])
+        BytecodeModifier.useRealmAccessors(ctClass, [ctField])
 
         then: 'the field is not used in the method anymore'
-        def methodInfo = ctMethod.getMethodInfo()
+        !isFieldRead(ctDefaultConstructor) && hasMethodCall(ctDefaultConstructor) &&
+                !isFieldRead(ctNonDefaultConstructor) && hasMethodCall(ctNonDefaultConstructor)
+    }
+
+    private static def isFieldRead(CtBehavior behavior) {
+        def methodInfo = behavior.getMethodInfo()
+        def codeAttribute = methodInfo.getCodeAttribute()
+
+        for (CodeIterator ci = codeAttribute.iterator(); ci.hasNext();) {
+            int index = ci.next();
+            int op = ci.byteAt(index);
+            if (op == Opcode.GETFIELD) {
+                return true
+            }
+        }
+        return false
+    }
+
+    private static def hasMethodCall(CtBehavior behavior) {
+        def methodInfo = behavior.getMethodInfo()
         def codeAttribute = methodInfo.getCodeAttribute()
-        def fieldIsUsed = false
+
         for (CodeIterator ci = codeAttribute.iterator(); ci.hasNext();) {
             int index = ci.next();
             int op = ci.byteAt(index);
-            if (op == Opcode.PUTFIELD) {
-                fieldIsUsed = true
+            if (op == Opcode.INVOKEVIRTUAL) {
+                return true
             }
         }
-        !fieldIsUsed
+        return false
     }
 }
diff --git a/realm.properties b/realm.properties
index 60d64cf12c..1be5af0639 100644
--- a/realm.properties
+++ b/realm.properties
@@ -1,2 +1,2 @@
-gradleVersion=2.7
+gradleVersion=2.14.1
 ndkVersion=r10e
diff --git a/realm/build.gradle b/realm/build.gradle
index 44d2ab9c3f..3be5c2794e 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -6,11 +6,10 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.1.0'
-        classpath 'de.undercouch:gradle-download-task:2.0.0'
+        classpath 'com.android.tools.build:gradle:2.2.0-beta2'
+        classpath 'de.undercouch:gradle-download-task:3.1.1'
         classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
-        classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'
-        classpath 'com.github.JakeWharton:sdk-manager-plugin:0ce4cdf08009d79223850a59959d9d6e774d0f77'
+        classpath 'com.github.dcendents:android-maven-gradle-plugin:1.4.1'
         classpath 'com.novoda:gradle-android-command-plugin:1.3.0'
         classpath 'com.github.skhatri:gradle-s3-plugin:1.0.2'
         classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.4.0'
diff --git a/realm/config/findbugs/findbugs-filter.xml b/realm/config/findbugs/findbugs-filter.xml
index 93e9d7ac1a..b6503d5337 100644
--- a/realm/config/findbugs/findbugs-filter.xml
+++ b/realm/config/findbugs/findbugs-filter.xml
@@ -7,21 +7,6 @@
     <Match>
         <Class name="~.*\.Manifest\$.*"/>
     </Match>
-    <Match>
-        <Class name="io.realm.internal.ImplicitTransaction" />
-        <Method name="finalize" />
-        <Bug pattern="FI_NULLIFY_SUPER" />
-    </Match>
-    <Match>
-        <Class name="io.realm.internal.ReadTransaction" />
-        <Method name="finalize" />
-        <Bug pattern="FI_NULLIFY_SUPER" />
-    </Match>
-    <Match>
-        <Class name="io.realm.internal.WriteTransaction" />
-        <Method name="finalize" />
-        <Bug pattern="FI_NULLIFY_SUPER" />
-    </Match>
     <Match>
         <Class name="io.realm.Realm" />
         <Method name="checkHasPrimaryKey" />
diff --git a/realm/gradle.properties b/realm/gradle.properties
index 7d70fda02c..033fd72f9a 100644
--- a/realm/gradle.properties
+++ b/realm/gradle.properties
@@ -1 +1 @@
-org.gradle.jvmargs=-Xms256m -Xmx1024m
\ No newline at end of file
+org.gradle.jvmargs=-Xms256m -Xmx2048m
diff --git a/realm/gradle/wrapper/gradle-wrapper.properties b/realm/gradle/wrapper/gradle-wrapper.properties
index 587246a1a4..f71002edb7 100644
--- a/realm/gradle/wrapper/gradle-wrapper.properties
+++ b/realm/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
diff --git a/realm/realm-annotations-processor/build.gradle b/realm/realm-annotations-processor/build.gradle
index fe4dab1d3c..b6ca11d063 100644
--- a/realm/realm-annotations-processor/build.gradle
+++ b/realm/realm-annotations-processor/build.gradle
@@ -15,7 +15,7 @@ dependencies {
     testCompile files("${System.properties['java.home']}/../lib/tools.jar") // This is needed otherwise compile-testing won't be able to find it
     testCompile group:'junit', name:'junit', version:'4.12'
     testCompile group:'com.google.testing.compile', name:'compile-testing', version:'0.6'
-    testCompile files(file("${System.env.ANDROID_HOME}/platforms/android-21/android.jar"))
+    testCompile files(file("${System.env.ANDROID_HOME}/platforms/android-24/android.jar"))
 }
 
 // for Ant filter
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index 630e56eefe..646a12790d 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -162,7 +162,7 @@ private boolean checkListTypes() {
         for (VariableElement field : fields) {
             if (Utils.isRealmList(field)) {
                 // Check for missing generic (default back to Object)
-                if (Utils.getGenericType(field) == null) {
+                if (Utils.getGenericTypeQualifiedName(field) == null) {
                     Utils.error("No generic type supplied for field", field);
                     return false;
                 }
@@ -373,6 +373,19 @@ public boolean isNullable(VariableElement variableElement) {
         return nullableFields.contains(variableElement);
     }
 
+    /**
+     * Checks if a VariableElement is a primary key.
+     *
+     * @param variableElement the element/field
+     * @return {@code true} if a VariableElement is primary key, {@code false} otherwise.
+     */
+    public boolean isPrimaryKey(VariableElement variableElement) {
+        if (primaryKey == null) {
+            return false;
+        }
+        return primaryKey.equals(variableElement);
+    }
+
     private boolean isValidPrimaryKeyType(TypeMirror type) {
         for (TypeMirror validType : validPrimaryKeyTypes) {
             if (typeUtils.isAssignable(type, validType)) {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
index 8cb7ec6ea8..791f81df9c 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
@@ -27,7 +27,12 @@
     public static final String TABLE_PREFIX = "class_";
     public static final String DEFAULT_MODULE_CLASS_NAME = "DefaultRealmModule";
     static final String STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE =
-            "throw new IllegalArgumentException(\"Trying to set non-nullable field %s to null.\")";
+            "throw new IllegalArgumentException(\"Trying to set non-nullable field '%s' to null.\")";
+    static final String STATEMENT_EXCEPTION_NO_PRIMARY_KEY_IN_JSON =
+            "throw new IllegalArgumentException(\"JSON object doesn't have the primary key field '%s'.\")";
+    static final String STATEMENT_EXCEPTION_PRIMARY_KEY_CANNOT_BE_CHANGED =
+            "throw new io.realm.exceptions.RealmException(\"Primary key field '%s' cannot be changed after object" +
+                    " was created.\")";
 
     static final Map<String, String> JAVA_TO_REALM_TYPES;
     static {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
index 6fc488c70c..af9402ab21 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
@@ -68,7 +68,7 @@ public void emitTypeConversion(String interfaceName, String setter, String field
 
             @Override
             public void emitStreamTypeConversion(String interfaceName, String setter, String fieldName, String
-                    fieldType, JavaWriter writer)
+                    fieldType, JavaWriter writer, boolean isPrimaryKey)
                     throws IOException {
                 writer
                     .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
@@ -86,8 +86,10 @@ public void emitStreamTypeConversion(String interfaceName, String setter, String
             }
 
             @Override
-            public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String fieldName, JavaWriter writer) throws IOException {
-                throw new IllegalArgumentException("Date is not allowed as a primary key value.");
+            public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
+                                                         String qualifiedRealmObjectProxyClass,
+                                                         String fieldName, JavaWriter writer) throws IOException {
+                throw new IllegalArgumentException("'Date' is not allowed as a primary key value.");
             }
         });
         JAVA_TO_JSON_TYPES.put("byte[]", new JsonToRealmFieldTypeConverter() {
@@ -108,7 +110,7 @@ public void emitTypeConversion(String interfaceName, String setter, String field
 
             @Override
             public void emitStreamTypeConversion(String interfaceName, String setter, String fieldName, String
-                    fieldType, JavaWriter writer)
+                    fieldType, JavaWriter writer, boolean isPrimaryKey)
                     throws IOException {
                 writer
                     .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
@@ -121,17 +123,21 @@ public void emitStreamTypeConversion(String interfaceName, String setter, String
             }
 
             @Override
-            public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String fieldName, JavaWriter writer) throws IOException {
-                throw new IllegalArgumentException("byte[] is not allowed as a primary key value.");
+            public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
+                                                         String qualifiedRealmObjectProxyClass,
+                                                         String fieldName, JavaWriter writer) throws IOException {
+                throw new IllegalArgumentException("'byte[]' is not allowed as a primary key value.");
             }
         });
     }
 
-    public static void emitCreateObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String qualifiedFieldType,
+    public static void emitCreateObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
+                                                           String qualifiedRealmObjectProxyClass,
+                                                           String qualifiedFieldType,
                                                            String fieldName, JavaWriter writer) throws IOException {
         JsonToRealmFieldTypeConverter typeEmitter = JAVA_TO_JSON_TYPES.get(qualifiedFieldType);
         if (typeEmitter != null) {
-            typeEmitter.emitGetObjectWithPrimaryKeyValue(qualifiedRealmObjectClass, fieldName, writer);
+            typeEmitter.emitGetObjectWithPrimaryKeyValue(qualifiedRealmObjectClass, qualifiedRealmObjectProxyClass, fieldName, writer);
         }
     }
 
@@ -177,11 +183,16 @@ public static void emitFillRealmListWithJsonValue(String interfaceName, String g
     }
 
 
-    public static void emitFillJavaTypeFromStream(String interfaceName, String setter, String fieldName, String
+    public static void emitFillJavaTypeFromStream(String interfaceName, ClassMetaData metaData, String fieldName, String
             fieldType, JavaWriter writer) throws IOException {
+        String setter = metaData.getSetter(fieldName);
+        boolean isPrimaryKey = false;
+        if (metaData.hasPrimaryKey() && metaData.getPrimaryKey().getSimpleName().toString().equals(fieldName)) {
+            isPrimaryKey = true;
+        }
         if (JAVA_TO_JSON_TYPES.containsKey(fieldType)) {
             JAVA_TO_JSON_TYPES.get(fieldType).emitStreamTypeConversion(interfaceName, setter, fieldName, fieldType,
-                    writer);
+                    writer, isPrimaryKey);
         }
     }
 
@@ -205,6 +216,7 @@ public static void emitFillRealmListFromStream(String interfaceName, String gett
                 .emitStatement("reader.skipValue()")
                 .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
             .nextControlFlow("else")
+                .emitStatement("((%s) obj).%s(new RealmList<%s>())", interfaceName, setter, fieldTypeCanonicalName)
                 .emitStatement("reader.beginArray()")
                 .beginControlFlow("while (reader.hasNext())")
                     .emitStatement("%s item = %s.createUsingJsonStream(realm, reader)", fieldTypeCanonicalName, proxyClass)
@@ -258,7 +270,7 @@ public void emitTypeConversion(String interfaceName, String setter, String field
 
         @Override
         public void emitStreamTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
-                                             JavaWriter writer)
+                                             JavaWriter writer, boolean isPrimaryKey)
                 throws IOException {
             String statementSetNullOrThrow;
             if (Utils.isPrimitiveType(fieldType)) {
@@ -275,23 +287,29 @@ public void emitStreamTypeConversion(String interfaceName, String setter, String
                 .nextControlFlow("else")
                     .emitStatement("((%s) obj).%s((%s) reader.next%s())", interfaceName, setter, castType, jsonType)
                 .endControlFlow();
+            if (isPrimaryKey) {
+                writer.emitStatement("jsonHasPrimaryKey = true");
+            }
         }
 
         @Override
-        public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String fieldName, JavaWriter writer) throws IOException {
+        public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
+                                                     String qualifiedRealmObjectProxyClass,
+                                                     String fieldName, JavaWriter writer) throws IOException {
             // No error checking is done here for valid primary key types. This should be done by the annotation
             // processor
             writer
                 .beginControlFlow("if (json.has(\"%s\"))", fieldName)
                     .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
-                        .emitStatement("obj = (%1$sRealmProxy) realm.createObject(%1$s.class, null)", qualifiedRealmObjectClass)
+                        .emitStatement("obj = (%1$s) realm.createObjectInternal(%2$s.class, null, true, excludeFields)",
+                                qualifiedRealmObjectProxyClass, qualifiedRealmObjectClass)
                     .nextControlFlow("else")
-                        .emitStatement("obj = (%1$sRealmProxy) realm.createObject(%1$s.class, json.get%2$s(\"%3$s\"))",
-                                qualifiedRealmObjectClass, jsonType, fieldName)
+                        .emitStatement("obj = (%1$s) realm.createObjectInternal(%2$s.class, json.get%3$s(\"%4$s\"), true, excludeFields)",
+                                qualifiedRealmObjectProxyClass, qualifiedRealmObjectClass, jsonType, fieldName)
                     .endControlFlow()
                 .nextControlFlow("else")
-                    .emitStatement("obj = (%1$sRealmProxy) realm.createObject(%1$s.class)", qualifiedRealmObjectClass)
-                .endControlFlow();
+                    .emitStatement(Constants.STATEMENT_EXCEPTION_NO_PRIMARY_KEY_IN_JSON, fieldName)
+                    .endControlFlow();
         }
     }
 
@@ -299,7 +317,9 @@ public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, S
         void emitTypeConversion(String interfaceName, String setter, String fieldName, String fieldType, JavaWriter
                 writer) throws IOException;
         void emitStreamTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
-                                      JavaWriter writer) throws IOException;
-        void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String fieldName, JavaWriter writer) throws IOException;
+                                      JavaWriter writer, boolean isPrimaryKey) throws IOException;
+        void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
+                                              String qualifiedRealmObjectProxyClass,
+                                              String fieldName, JavaWriter writer) throws IOException;
     }
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
index c7bdee7c34..59f14327d7 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
@@ -23,7 +23,6 @@
 import java.util.TreeSet;
 
 import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
 import javax.lang.model.SourceVersion;
@@ -91,6 +90,28 @@
  *  <li>Each time a static helper method is needed, Realm can now delegate these method calls to the appropriate
  *    Mediator which in turn will delegate the method call to the appropriate RealmObjectProxy class.</li>
  * </ol>
+ *
+ * <h1>CREATING A MANAGED RealmObject</h1>
+ *
+ * To allow to specify default values by model's constructor or direct field assignment,
+ * the flow of creating the proxy object is a bit complicated. This section illustrates
+ * how proxy object should be created.
+ *
+ * <ol>
+ *  <li>Get the thread local {@code io.realm.BaseRealm.RealmObjectContext} instance by {@code BaseRealm.objectContext.get()} </li>
+ *  <li>Set the object context information to the {@code RealmObjectContext} those should be set to the creating proxy object.</li>
+ *  <li>Create proxy object ({@code new io.realm.FooRealmProxy()}).</li>
+ *  <li>Set the object context information to the created proxy when the first access of its accessors (or in its constructor if accessors are not used in the model's constructor).</li>
+ *  <li>Clear the object context information in the thread local {@code io.realm.BaseRealm.RealmObjectContext} instance by calling {@code
+ *  #clear()} method.</li>
+ * </ol>
+ *
+ * The reason of this complicated step is that we can't pass these context information
+ * via the constructor of the proxy. It's because the constructor of the proxy is executed
+ * <b>after</b> the constructor of the model class. The access to the fields in the model's
+ * constructor happens before the assignment of the context information to the 'proxyState'.
+ * This will cause the {@link NullPointerException} if getters/setter is accessed in the model's
+ * constructor (see https://github.com/realm/realm-java/issues/2536 ).
  */
 @SupportedAnnotationTypes({
         "io.realm.annotations.RealmClass",
@@ -102,6 +123,9 @@
 })
 public class RealmProcessor extends AbstractProcessor {
 
+    // Don't consume annotations. This allows 3rd party annotation processors to run.
+    private static final boolean CONSUME_ANNOTATIONS = false;
+
     Set<ClassMetaData> classesToValidate = new HashSet<ClassMetaData>();
     private boolean hasProcessedModules = false;
 
@@ -111,8 +135,9 @@
 
     @Override
     public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+        // Don't run this processor in subsequent runs. We created everything in the first one.
         if (hasProcessedModules) {
-            return true;
+            return CONSUME_ANNOTATIONS;
         }
         RealmVersionChecker updateChecker = RealmVersionChecker.getInstance(processingEnv);
         updateChecker.executeRealmVersionUpdate();
@@ -165,7 +190,9 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
         }
 
         hasProcessedModules = true;
-        return processModules(roundEnv);
+        processModules(roundEnv);
+
+        return CONSUME_ANNOTATIONS;
     }
 
     // Returns true if modules was processed successfully, false otherwise
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 4e5ecf260a..a9cbc092cd 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -36,18 +36,22 @@
 public class RealmProxyClassGenerator {
     private ProcessingEnvironment processingEnvironment;
     private ClassMetaData metadata;
-    private final String className;
+    private final String simpleClassName;
+    private final String qualifiedClassName;
     private final String interfaceName;
+    private final String qualifiedGeneratedClassName;
 
     public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment, ClassMetaData metadata) {
         this.processingEnvironment = processingEnvironment;
         this.metadata = metadata;
-        this.className = metadata.getSimpleClassName();
-        this.interfaceName = Utils.getProxyInterfaceName(className);
+        this.simpleClassName = metadata.getSimpleClassName();
+        this.qualifiedClassName = metadata.getFullyQualifiedClassName();
+        this.interfaceName = Utils.getProxyInterfaceName(simpleClassName);
+        this.qualifiedGeneratedClassName = String.format("%s.%s",
+                Constants.REALM_PACKAGE_NAME, Utils.getProxyClassName(simpleClassName));
     }
 
     public void generate() throws IOException, UnsupportedOperationException {
-        String qualifiedGeneratedClassName = String.format("%s.%s", Constants.REALM_PACKAGE_NAME, Utils.getProxyClassName(className));
         JavaFileObject sourceFile = processingEnvironment.getFiler().createSourceFile(qualifiedGeneratedClassName);
         JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));
 
@@ -58,43 +62,31 @@ public void generate() throws IOException, UnsupportedOperationException {
                 .emitEmptyLine();
 
         ArrayList<String> imports = new ArrayList<String>();
+        imports.add("android.annotation.TargetApi");
+        imports.add("android.os.Build");
         imports.add("android.util.JsonReader");
         imports.add("android.util.JsonToken");
-        imports.add("io.realm.RealmFieldType");
         imports.add("io.realm.exceptions.RealmMigrationNeededException");
         imports.add("io.realm.internal.ColumnInfo");
         imports.add("io.realm.internal.RealmObjectProxy");
         imports.add("io.realm.internal.Table");
         imports.add("io.realm.internal.TableOrView");
-        imports.add("io.realm.internal.ImplicitTransaction");
+        imports.add("io.realm.internal.SharedRealm");
         imports.add("io.realm.internal.LinkView");
         imports.add("io.realm.internal.android.JsonUtils");
-        imports.add("io.realm.internal.Row");
+        imports.add("io.realm.log.RealmLog");
         imports.add("java.io.IOException");
         imports.add("java.util.ArrayList");
         imports.add("java.util.Collections");
         imports.add("java.util.List");
+        imports.add("java.util.Iterator");
         imports.add("java.util.Date");
         imports.add("java.util.Map");
         imports.add("java.util.HashMap");
         imports.add("org.json.JSONObject");
         imports.add("org.json.JSONException");
         imports.add("org.json.JSONArray");
-        imports.add("java.util.concurrent.Future");
 
-        imports.add(metadata.getFullyQualifiedClassName());
-
-        for (VariableElement field : metadata.getFields()) {
-            String fieldTypeName = "";
-            if (Utils.isRealmModel(field)) { // Links
-                fieldTypeName = field.asType().toString();
-            } else if (Utils.isRealmList(field)) { // LinkLists
-                fieldTypeName = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
-            }
-            if (!fieldTypeName.isEmpty() && !imports.contains(fieldTypeName)) {
-                imports.add(fieldTypeName);
-            }
-        }
         Collections.sort(imports);
         writer.emitImports(imports);
         writer.emitEmptyLine();
@@ -104,7 +96,7 @@ public void generate() throws IOException, UnsupportedOperationException {
                 qualifiedGeneratedClassName, // full qualified name of the item to generate
                 "class",                     // the type of the item
                 EnumSet.of(Modifier.PUBLIC), // modifiers to apply
-                className,                   // class to extend
+                qualifiedClassName,          // class to extend
                 "RealmObjectProxy",          // interfaces to implement
                 interfaceName)
                 .emitEmptyLine();
@@ -113,6 +105,7 @@ public void generate() throws IOException, UnsupportedOperationException {
 
         emitClassFields(writer);
         emitConstructor(writer);
+        emitInjectContextMethod(writer);
         emitAccessors(writer);
         emitInitTableMethod(writer);
         emitValidateTableMethod(writer);
@@ -122,6 +115,10 @@ public void generate() throws IOException, UnsupportedOperationException {
         emitCreateUsingJsonStream(writer);
         emitCopyOrUpdateMethod(writer);
         emitCopyMethod(writer);
+        emitInsertMethod(writer);
+        emitInsertListMethod(writer);
+        emitInsertOrUpdateMethod(writer);
+        emitInsertOrUpdateListMethod(writer);
         emitCreateDetachedCopyMethod(writer);
         emitUpdateMethod(writer);
         emitToStringMethod(writer);
@@ -139,13 +136,14 @@ private void emitColumnIndicesClass(JavaWriter writer) throws IOException {
                 columnInfoClassName(),                       // full qualified name of the item to generate
                 "class",                                     // the type of the item
                 EnumSet.of(Modifier.STATIC, Modifier.FINAL), // modifiers to apply
-                "ColumnInfo")                                // base class
+                "ColumnInfo",                                // base class
+                "Cloneable")                                 // interfaces
                 .emitEmptyLine();
 
         // fields
         for (VariableElement variableElement : metadata.getFields()) {
             writer.emitField("long", columnIndexVarName(variableElement),
-                    EnumSet.of(Modifier.PUBLIC, Modifier.FINAL));
+                    EnumSet.of(Modifier.PUBLIC));
         }
         writer.emitEmptyLine();
 
@@ -159,24 +157,55 @@ private void emitColumnIndicesClass(JavaWriter writer) throws IOException {
             final String columnName = variableElement.getSimpleName().toString();
             final String columnIndexVarName = columnIndexVarName(variableElement);
             writer.emitStatement("this.%s = getValidColumnIndex(path, table, \"%s\", \"%s\")",
-                    columnIndexVarName, className, columnName);
+                    columnIndexVarName, simpleClassName, columnName);
             writer.emitStatement("indicesMap.put(\"%s\", this.%s)", columnName, columnIndexVarName);
-            writer.emitEmptyLine();
         }
+        writer.emitEmptyLine();
         writer.emitStatement("setIndicesMap(indicesMap)");
         writer.endConstructor();
+        writer.emitEmptyLine();
 
-        writer.endType();
+        // copyColumnInfoFrom method
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "void",                      // return type
+                "copyColumnInfoFrom",        // method name
+                EnumSet.of(Modifier.PUBLIC, Modifier.FINAL), // modifiers
+                "ColumnInfo", "other");      // parameters
+        {
+            writer.emitStatement("final %1$s otherInfo = (%1$s) other", columnInfoClassName());
+
+            // copy field values
+            for (VariableElement variableElement : metadata.getFields()) {
+                writer.emitStatement("this.%1$s = otherInfo.%1$s", columnIndexVarName(variableElement));
+            }
+            writer.emitEmptyLine();
+            writer.emitStatement("setIndicesMap(otherInfo.getIndicesMap())");
+        }
+        writer.endMethod();
         writer.emitEmptyLine();
+
+        // clone method
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                columnInfoClassName(),       // return type
+                "clone",                     // method name
+                EnumSet.of(Modifier.PUBLIC, Modifier.FINAL)) // modifiers
+                // method body
+                .emitStatement("return (%1$s) super.clone()", columnInfoClassName())
+                .endMethod()
+                .emitEmptyLine();
+
+        writer.endType();
     }
 
     private void emitClassFields(JavaWriter writer) throws IOException {
-        writer.emitField(columnInfoClassName(), "columnInfo", EnumSet.of(Modifier.PRIVATE, Modifier.FINAL));
-        writer.emitField("ProxyState", "proxyState", EnumSet.of(Modifier.PRIVATE, Modifier.FINAL));
+        writer.emitField(columnInfoClassName(), "columnInfo", EnumSet.of(Modifier.PRIVATE));
+        writer.emitField("ProxyState", "proxyState", EnumSet.of(Modifier.PRIVATE));
 
         for (VariableElement variableElement : metadata.getFields()) {
             if (Utils.isRealmList(variableElement)) {
-                String genericType = Utils.getGenericType(variableElement);
+                String genericType = Utils.getGenericTypeQualifiedName(variableElement);
                 writer.emitField("RealmList<" + genericType + ">", variableElement.getSimpleName().toString() + "RealmList", EnumSet.of(Modifier.PRIVATE));
             }
         }
@@ -194,17 +223,19 @@ private void emitClassFields(JavaWriter writer) throws IOException {
 
     private void emitConstructor(JavaWriter writer) throws IOException {
         // FooRealmProxy(ColumnInfo)
-        writer.beginConstructor(EnumSet.noneOf(Modifier.class), "ColumnInfo", "columnInfo");
-        writer.emitStatement("this.columnInfo = (%s) columnInfo", columnInfoClassName());
-        writer.emitStatement("this.proxyState = new ProxyState(%s.class, this)", className);
+        writer.beginConstructor(EnumSet.noneOf(Modifier.class));
+        writer.beginControlFlow("if (proxyState == null)")
+                .emitStatement("injectObjectContext()")
+                .endControlFlow();
+        writer.emitStatement("proxyState.setConstructionFinished()");
         writer.endConstructor();
         writer.emitEmptyLine();
     }
 
     private void emitAccessors(JavaWriter writer) throws IOException {
         for (VariableElement field : metadata.getFields()) {
-            String fieldName = field.getSimpleName().toString();
-            String fieldTypeCanonicalName = field.asType().toString();
+            final String fieldName = field.getSimpleName().toString();
+            final String fieldTypeCanonicalName = field.asType().toString();
 
             if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                 /**
@@ -215,6 +246,7 @@ private void emitAccessors(JavaWriter writer) throws IOException {
                 // Getter
                 writer.emitAnnotation("SuppressWarnings", "\"cast\"");
                 writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
+                emitCodeForInjectingObjectContext(writer, field, false, metadata.isPrimaryKey(field));
                 writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
 
                 // For String and bytes[], null value will be returned by JNI code. Try to save one JNI call here.
@@ -226,7 +258,7 @@ private void emitAccessors(JavaWriter writer) throws IOException {
 
                 // For Boxed types, this should be the corresponding primitive types. Others remain the same.
                 String castingBackType;
-                if (Utils.isBoxedType(field.asType().toString())) {
+                if (Utils.isBoxedType(fieldTypeCanonicalName)) {
                     Types typeUtils = processingEnvironment.getTypeUtils();
                     castingBackType = typeUtils.unboxedType(field.asType()).toString();
                 } else {
@@ -240,24 +272,30 @@ private void emitAccessors(JavaWriter writer) throws IOException {
 
                 // Setter
                 writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
+                emitCodeForInjectingObjectContext(writer, field, true, metadata.isPrimaryKey(field));
                 writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
                 // Although setting null value for String and bytes[] can be handled by the JNI code, we still generate the same code here.
                 // Compared with getter, null value won't trigger more native calls in setter which is relatively cheaper.
-                if (metadata.isNullable(field)) {
-                    writer.beginControlFlow("if (value == null)")
-                        .emitStatement("proxyState.getRow$realm().setNull(%s)", fieldIndexVariableReference(field))
-                        .emitStatement("return")
-                    .endControlFlow();
-                } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
-                    // Same reason, throw IAE earlier.
-                    writer
-                        .beginControlFlow("if (value == null)")
-                            .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
-                        .endControlFlow();
+                if (metadata.isPrimaryKey(field)) {
+                    // Primary key is not allowed to be changed after object created.
+                    writer.emitStatement(Constants.STATEMENT_EXCEPTION_PRIMARY_KEY_CANNOT_BE_CHANGED, fieldName);
+                } else {
+                    if (metadata.isNullable(field)) {
+                        writer.beginControlFlow("if (value == null)")
+                                .emitStatement("proxyState.getRow$realm().setNull(%s)", fieldIndexVariableReference(field))
+                                .emitStatement("return")
+                                .endControlFlow();
+                    } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
+                        // Same reason, throw IAE earlier.
+                        writer
+                                .beginControlFlow("if (value == null)")
+                                .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
+                                .endControlFlow();
+                    }
+                    writer.emitStatement(
+                            "proxyState.getRow$realm().set%s(%s, value)",
+                            realmType, fieldIndexVariableReference(field));
                 }
-                writer.emitStatement(
-                        "proxyState.getRow$realm().set%s(%s, value)",
-                        realmType, fieldIndexVariableReference(field));
                 writer.endMethod();
             } else if (Utils.isRealmModel(field)) {
                 /**
@@ -266,23 +304,25 @@ private void emitAccessors(JavaWriter writer) throws IOException {
 
                 // Getter
                 writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
+                emitCodeForInjectingObjectContext(writer, field, false, metadata.isPrimaryKey(field));
                 writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
                 writer.beginControlFlow("if (proxyState.getRow$realm().isNullLink(%s))", fieldIndexVariableReference(field));
                         writer.emitStatement("return null");
                         writer.endControlFlow();
-                writer.emitStatement("return proxyState.getRealm$realm().get(%s.class, proxyState.getRow$realm().getLink(%s))",
+                writer.emitStatement("return proxyState.getRealm$realm().get(%s.class, proxyState.getRow$realm().getLink(%s), false, Collections.<String>emptyList())",
                         fieldTypeCanonicalName, fieldIndexVariableReference(field));
                 writer.endMethod();
                 writer.emitEmptyLine();
 
                 // Setter
                 writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
+                emitCodeForInjectingObjectContext(writer, field, true, metadata.isPrimaryKey(field));
                 writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
                 writer.beginControlFlow("if (value == null)");
                     writer.emitStatement("proxyState.getRow$realm().nullifyLink(%s)", fieldIndexVariableReference(field));
                     writer.emitStatement("return");
                 writer.endControlFlow();
-                writer.beginControlFlow("if (!RealmObject.isValid(value))");
+                writer.beginControlFlow("if (!(RealmObject.isManaged(value) && RealmObject.isValid(value)))");
                     writer.emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")");
                 writer.endControlFlow();
                 writer.beginControlFlow("if (((RealmObjectProxy)value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())");
@@ -294,10 +334,11 @@ private void emitAccessors(JavaWriter writer) throws IOException {
                 /**
                  * LinkLists
                  */
-                String genericType = Utils.getGenericType(field);
+                String genericType = Utils.getGenericTypeQualifiedName(field);
 
                 // Getter
                 writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
+                emitCodeForInjectingObjectContext(writer, field, false, metadata.isPrimaryKey(field));
                 writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
                 writer.emitSingleLineComment("use the cached value if available");
                 writer.beginControlFlow("if (" + fieldName + "RealmList != null)");
@@ -315,13 +356,14 @@ private void emitAccessors(JavaWriter writer) throws IOException {
                 // Setter
                 writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                 writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
+                emitCodeForInjectingObjectContext(writer, field, true, metadata.isPrimaryKey(field));
                 writer.emitStatement("LinkView links = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field));
                 writer.emitStatement("links.clear()");
                 writer.beginControlFlow("if (value == null)");
                     writer.emitStatement("return");
                 writer.endControlFlow();
                 writer.beginControlFlow("for (RealmModel linkedObject : (RealmList<? extends RealmModel>) value)");
-                    writer.beginControlFlow("if (!RealmObject.isValid(linkedObject))");
+                    writer.beginControlFlow("if (!(RealmObject.isManaged(linkedObject) && RealmObject.isValid(linkedObject)))");
                         writer.emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must be a valid managed object.\")");
                     writer.endControlFlow();
                     writer.beginControlFlow("if (((RealmObjectProxy)linkedObject).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())");
@@ -332,12 +374,88 @@ private void emitAccessors(JavaWriter writer) throws IOException {
                 writer.endMethod();
             } else {
                 throw new UnsupportedOperationException(
-                        String.format("Type %s of field %s is not supported", fieldTypeCanonicalName, fieldName));
+                        String.format("Type '%s' of field '%s' is not supported", fieldTypeCanonicalName, fieldName));
             }
             writer.emitEmptyLine();
         }
     }
 
+    private void emitCodeForInjectingObjectContext(JavaWriter writer, VariableElement field, boolean isSetter, boolean isPrimaryKey) throws IOException {
+        // if invoked from model's constructor, inject BaseRealm and Row
+        writer.beginControlFlow("if (proxyState == null)");
+        {
+            writer.emitSingleLineComment("Called from model's constructor. Inject context.");
+            writer.emitStatement("injectObjectContext()");
+        }
+        writer.endControlFlow();
+        writer.emitEmptyLine();
+
+        if (isSetter) {
+            writer.beginControlFlow("if (proxyState.isUnderConstruction())");
+            {
+                if (isPrimaryKey) {
+                    writer.emitSingleLineComment("default value of the primary key is always ignored.");
+                    writer.emitStatement("return");
+                } else {
+                    writer.beginControlFlow("if (!proxyState.getAcceptDefaultValue$realm())")
+                            .emitStatement("return")
+                            .endControlFlow();
+                    if (Utils.isRealmModel(field)) {
+                        // check excludeFields
+                        writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
+                                field.getSimpleName().toString())
+                                .emitStatement("return")
+                                .endControlFlow();
+                        writer.beginControlFlow("if (value != null && !RealmObject.isManaged(value))")
+                                .emitStatement("value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value)")
+                                .endControlFlow();
+                    } else if (Utils.isRealmList(field)) {
+                        // check excludeFields
+                        writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
+                                field.getSimpleName().toString())
+                                .emitStatement("return")
+                                .endControlFlow();
+                        final String modelFqcn = Utils.getGenericTypeQualifiedName(field);
+                        writer.beginControlFlow("if (value != null && !value.isManaged())")
+                                .emitStatement("final Realm realm = (Realm) proxyState.getRealm$realm()")
+                                .emitStatement("final RealmList<%1$s> original = value", modelFqcn)
+                                .emitStatement("value = new RealmList<%1$s>()", modelFqcn)
+                                .beginControlFlow("for (%1$s item : original)", modelFqcn)
+                                    .beginControlFlow("if (item == null || RealmObject.isManaged(item))")
+                                        .emitStatement("value.add(item)")
+                                    .nextControlFlow("else")
+                                        .emitStatement("value.add(realm.copyToRealm(item))")
+                                    .endControlFlow()
+                                .endControlFlow()
+                            .endControlFlow();
+                    }
+                }
+            }
+            writer.endControlFlow()
+                    .emitEmptyLine();
+        }
+    }
+
+    private void emitInjectContextMethod(JavaWriter writer) throws IOException {
+        writer.beginMethod(
+                "void", // Return type
+                "injectObjectContext", // Method name
+                EnumSet.of(Modifier.PRIVATE) // Modifiers
+                ); // Argument type & argument name
+
+        writer.emitStatement("final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get()");
+        writer.emitStatement("this.columnInfo = (%1$s) context.getColumnInfo()", columnInfoClassName());
+        writer.emitStatement("this.proxyState = new ProxyState(%1$s.class, this)", qualifiedClassName);
+        writer.emitStatement("proxyState.setRealm$realm(context.getRealm())");
+        writer.emitStatement("proxyState.setRow$realm(context.getRow())");
+        writer.emitStatement("proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue())");
+        writer.emitStatement("proxyState.setExcludeFields$realm(context.getExcludeFields())");
+
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+
     private void emitRealmObjectProxyImplementation(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod("ProxyState", "realmGet$proxyState", EnumSet.of(Modifier.PUBLIC));
@@ -351,10 +469,10 @@ private void emitInitTableMethod(JavaWriter writer) throws IOException {
                 "Table", // Return type
                 "initTable", // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "ImplicitTransaction", "transaction"); // Argument type & argument name
+                "SharedRealm", "sharedRealm"); // Argument type & argument name
 
-        writer.beginControlFlow("if (!transaction.hasTable(\"" + Constants.TABLE_PREFIX + this.className + "\"))");
-        writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.className);
+        writer.beginControlFlow("if (!sharedRealm.hasTable(\"" + Constants.TABLE_PREFIX + this.simpleClassName + "\"))");
+        writer.emitStatement("Table table = sharedRealm.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.simpleClassName);
 
         // For each field generate corresponding table index constant
         for (VariableElement field : metadata.getFields()) {
@@ -373,18 +491,18 @@ private void emitInitTableMethod(JavaWriter writer) throws IOException {
                         Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
                         fieldName, nullableFlag);
             } else if (Utils.isRealmModel(field)) {
-                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
-                writer.emitStatement("%s%s.initTable(transaction)", fieldTypeSimpleName, Constants.PROXY_SUFFIX);
+                writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
+                writer.emitStatement("%s%s.initTable(sharedRealm)", fieldTypeSimpleName, Constants.PROXY_SUFFIX);
                 writer.endControlFlow();
-                writer.emitStatement("table.addColumnLink(RealmFieldType.OBJECT, \"%s\", transaction.getTable(\"%s%s\"))",
+                writer.emitStatement("table.addColumnLink(RealmFieldType.OBJECT, \"%s\", sharedRealm.getTable(\"%s%s\"))",
                         fieldName, Constants.TABLE_PREFIX, fieldTypeSimpleName);
             } else if (Utils.isRealmList(field)) {
-                String genericType = Utils.getGenericType(field);
-                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericType);
-                writer.emitStatement("%s%s.initTable(transaction)", genericType, Constants.PROXY_SUFFIX);
+                String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
+                writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericTypeSimpleName);
+                writer.emitStatement("%s.initTable(sharedRealm)", Utils.getProxyClassName(genericTypeSimpleName));
                 writer.endControlFlow();
-                writer.emitStatement("table.addColumnLink(RealmFieldType.LIST, \"%s\", transaction.getTable(\"%s%s\"))",
-                        fieldName, Constants.TABLE_PREFIX, genericType);
+                writer.emitStatement("table.addColumnLink(RealmFieldType.LIST, \"%s\", sharedRealm.getTable(\"%s%s\"))",
+                        fieldName, Constants.TABLE_PREFIX, genericTypeSimpleName);
             }
         }
 
@@ -402,25 +520,36 @@ private void emitInitTableMethod(JavaWriter writer) throws IOException {
 
         writer.emitStatement("return table");
         writer.endControlFlow();
-        writer.emitStatement("return transaction.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.className);
+        writer.emitStatement("return sharedRealm.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.simpleClassName);
         writer.endMethod();
         writer.emitEmptyLine();
     }
 
     private void emitValidateTableMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
-                columnInfoClassName(), // Return type
-                "validateTable", // Method name
+                columnInfoClassName(),        // Return type
+                "validateTable",              // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "ImplicitTransaction", "transaction"); // Argument type & argument name
+                "SharedRealm", "sharedRealm", // Argument type & argument name
+                "boolean", "allowExtraColumns");
 
-        writer.beginControlFlow("if (transaction.hasTable(\"" + Constants.TABLE_PREFIX + this.className + "\"))");
-        writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.className);
+        writer.beginControlFlow("if (sharedRealm.hasTable(\"" + Constants.TABLE_PREFIX + this.simpleClassName + "\"))");
+        writer.emitStatement("Table table = sharedRealm.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.simpleClassName);
 
         // verify number of columns
-        writer.beginControlFlow("if (table.getColumnCount() != " + metadata.getFields().size() + ")");
-        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Field count does not match - expected %d but was \" + table.getColumnCount())",
-                metadata.getFields().size());
+        writer.emitStatement("final long columnCount = table.getColumnCount()");
+        writer.beginControlFlow("if (columnCount != %d)", metadata.getFields().size());
+            writer.beginControlFlow("if (columnCount < %d)", metadata.getFields().size());
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Field count is less than expected - expected %d but was \" + columnCount)",
+                        metadata.getFields().size());
+            writer.endControlFlow();
+            writer.beginControlFlow("if (allowExtraColumns)");
+                writer.emitStatement("RealmLog.debug(\"Field count is more than expected - expected %d but was %%1$d\", columnCount)",
+                        metadata.getFields().size());
+            writer.nextControlFlow("else");
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Field count is more than expected - expected %d but was \" + columnCount)",
+                        metadata.getFields().size());
+            writer.endControlFlow();
         writer.endControlFlow();
 
         // create type dictionary for lookup
@@ -431,26 +560,26 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
 
         // create an instance of ColumnInfo
-        writer.emitStatement("final %1$s columnInfo = new %1$s(transaction.getPath(), table)", columnInfoClassName());
+        writer.emitStatement("final %1$s columnInfo = new %1$s(sharedRealm.getPath(), table)", columnInfoClassName());
         writer.emitEmptyLine();
 
         // For each field verify there is a corresponding
         long fieldIndex = 0;
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
-            String fieldTypeCanonicalName = field.asType().toString();
+            String fieldTypeQualifiedName = Utils.getFieldTypeQualifiedName(field);
             String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
 
-            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
+            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeQualifiedName)) {
                 // make sure types align
                 writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing field '%s' in existing Realm file. " +
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Missing field '%s' in existing Realm file. " +
                         "Either remove field or migrate using io.realm.internal.Table.addColumn()." +
                         "\")", fieldName);
                 writer.endControlFlow();
                 writer.beginControlFlow("if (columnTypes.get(\"%s\") != %s)",
-                        fieldName, Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName));
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid type '%s' for field '%s' in existing Realm file.\")",
+                        fieldName, Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeQualifiedName));
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Invalid type '%s' for field '%s' in existing Realm file.\")",
                         fieldTypeSimpleName, fieldName);
                 writer.endControlFlow();
 
@@ -458,20 +587,20 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                 if (metadata.isNullable(field)) {
                     writer.beginControlFlow("if (!table.isColumnNullable(%s))", fieldIndexVariableReference(field));
                     // Check if the existing PrimaryKey does support null value for String, Byte, Short, Integer, & Long
-                    if (field.equals(metadata.getPrimaryKey())) {
-                        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
+                    if (metadata.isPrimaryKey(field)) {
+                        writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                 "\"@PrimaryKey field '%s' does not support null values in the existing Realm file. " +
                                 "Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.\")",
                                 fieldName);
                     // nullability check for boxed types
-                    } else if (Utils.isBoxedType(fieldTypeCanonicalName)) {
-                        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
+                    } else if (Utils.isBoxedType(fieldTypeQualifiedName)) {
+                        writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                 "\"Field '%s' does not support null values in the existing Realm file. " +
                                 "Either set @Required, use the primitive type for field '%s' " +
                                 "or migrate using RealmObjectSchema.setNullable().\")",
                                 fieldName, fieldName);
                     } else {
-                        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
+                        writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                 " \"Field '%s' is required. Either set @Required to field '%s' " +
                                 "or migrate using RealmObjectSchema.setNullable().\")",
                                 fieldName, fieldName);
@@ -479,7 +608,7 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                     writer.endControlFlow();
                 } else {
                     // check before migrating a nullable field containing null value to not-nullable PrimaryKey field for Realm version 0.89+
-                    if (field.equals(metadata.getPrimaryKey())) {
+                    if (metadata.isPrimaryKey(field)) {
                         writer
                             .beginControlFlow("if (table.isColumnNullable(%s) && table.findFirstNull(%s) != TableOrView.NO_MATCH)",
                                     fieldIndexVariableReference(field), fieldIndexVariableReference(field))
@@ -489,13 +618,13 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                             .endControlFlow();
                     } else {
                         writer.beginControlFlow("if (table.isColumnNullable(%s))", fieldIndexVariableReference(field));
-                        if (Utils.isPrimitiveType(fieldTypeCanonicalName)) {
-                            writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
+                        if (Utils.isPrimitiveType(fieldTypeQualifiedName)) {
+                            writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                     " \"Field '%s' does support null values in the existing Realm file. " +
                                     "Use corresponding boxed type for field '%s' or migrate using RealmObjectSchema.setNullable().\")",
                                     fieldName, fieldName);
                         } else {
-                            writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath()," +
+                            writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
                                     " \"Field '%s' does support null values in the existing Realm file. " +
                                     "Remove @Required or @PrimaryKey from field '%s' or migrate using RealmObjectSchema.setNullable().\")",
                                     fieldName, fieldName);
@@ -505,58 +634,58 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                 }
 
                 // Validate @PrimaryKey
-                if (field.equals(metadata.getPrimaryKey())) {
+                if (metadata.isPrimaryKey(field)) {
                     writer.beginControlFlow("if (table.getPrimaryKey() != table.getColumnIndex(\"%s\"))", fieldName);
-                    writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Primary key not defined for field '%s' in existing Realm file. Add @PrimaryKey.\")", fieldName);
+                    writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Primary key not defined for field '%s' in existing Realm file. Add @PrimaryKey.\")", fieldName);
                     writer.endControlFlow();
                 }
 
                 // Validate @Index
                 if (metadata.getIndexedFields().contains(field)) {
                     writer.beginControlFlow("if (!table.hasSearchIndex(table.getColumnIndex(\"%s\")))", fieldName);
-                    writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Index not defined for field '%s' in existing Realm file. " +
+                    writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Index not defined for field '%s' in existing Realm file. " +
                             "Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().\")", fieldName);
                     writer.endControlFlow();
                 }
 
             } else if (Utils.isRealmModel(field)) { // Links
                 writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing field '%s' in existing Realm file. " +
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Missing field '%s' in existing Realm file. " +
                         "Either remove field or migrate using io.realm.internal.Table.addColumn().\")", fieldName);
                 writer.endControlFlow();
                 writer.beginControlFlow("if (columnTypes.get(\"%s\") != RealmFieldType.OBJECT)", fieldName);
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid type '%s' for field '%s'\")",
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Invalid type '%s' for field '%s'\")",
                         fieldTypeSimpleName, fieldName);
                 writer.endControlFlow();
-                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing class '%s%s' for field '%s'\")",
+                writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Missing class '%s%s' for field '%s'\")",
                         Constants.TABLE_PREFIX, fieldTypeSimpleName, fieldName);
                 writer.endControlFlow();
 
-                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, fieldTypeSimpleName);
+                writer.emitStatement("Table table_%d = sharedRealm.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, fieldTypeSimpleName);
                 writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
                         fieldIndexVariableReference(field), fieldIndex);
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid RealmObject for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Invalid RealmObject for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
                         fieldName, fieldIndexVariableReference(field), fieldIndex);
                 writer.endControlFlow();
             } else if (Utils.isRealmList(field)) { // Link Lists
-                String genericType = Utils.getGenericType(field);
+                String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
                 writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing field '%s'\")", fieldName);
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Missing field '%s'\")", fieldName);
                 writer.endControlFlow();
                 writer.beginControlFlow("if (columnTypes.get(\"%s\") != RealmFieldType.LIST)", fieldName);
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid type '%s' for field '%s'\")",
-                        genericType, fieldName);
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Invalid type '%s' for field '%s'\")",
+                        genericTypeSimpleName, fieldName);
                 writer.endControlFlow();
-                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericType);
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Missing class '%s%s' for field '%s'\")",
-                        Constants.TABLE_PREFIX, genericType, fieldName);
+                writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericTypeSimpleName);
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Missing class '%s%s' for field '%s'\")",
+                        Constants.TABLE_PREFIX, genericTypeSimpleName, fieldName);
                 writer.endControlFlow();
 
-                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, genericType);
+                writer.emitStatement("Table table_%d = sharedRealm.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, genericTypeSimpleName);
                 writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
                         fieldIndexVariableReference(field), fieldIndex);
-                writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"Invalid RealmList type for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
+                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"Invalid RealmList type for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
                         fieldName, fieldIndexVariableReference(field), fieldIndex);
                 writer.endControlFlow();
             }
@@ -566,7 +695,7 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
         writer.emitStatement("return %s", "columnInfo");
 
         writer.nextControlFlow("else");
-        writer.emitStatement("throw new RealmMigrationNeededException(transaction.getPath(), \"The %s class is missing from the schema for this Realm.\")", metadata.getSimpleClassName());
+        writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), \"The '%s' class is missing from the schema for this Realm.\")", metadata.getSimpleClassName());
         writer.endControlFlow();
         writer.endMethod();
         writer.emitEmptyLine();
@@ -574,7 +703,7 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
 
     private void emitGetTableNameMethod(JavaWriter writer) throws IOException {
         writer.beginMethod("String", "getTableName", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC));
-        writer.emitStatement("return \"%s%s\"", Constants.TABLE_PREFIX, className);
+        writer.emitStatement("return \"%s%s\"", Constants.TABLE_PREFIX, simpleClassName);
         writer.endMethod();
         writer.emitEmptyLine();
     }
@@ -588,10 +717,10 @@ private void emitGetFieldNamesMethod(JavaWriter writer) throws IOException {
 
     private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
-                className, // Return type
+                qualifiedClassName, // Return type
                 "copyOrUpdate", // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "Realm", "realm", className, "object", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache" // Argument type & argument name
+                "Realm", "realm", qualifiedClassName, "object", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache" // Argument type & argument name
         );
 
         writer
@@ -606,163 +735,660 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                 .emitStatement("return object")
             .endControlFlow();
 
-        if (!metadata.hasPrimaryKey()) {
-            writer.emitStatement("return copy(realm, object, update, cache)");
-        } else {
-            writer
-                .emitStatement("%s realmObject = null", className)
-                .emitStatement("boolean canUpdate = update")
-                .beginControlFlow("if (canUpdate)")
-                    .emitStatement("Table table = realm.getTable(%s.class)", className)
-                    .emitStatement("long pkColumnIndex = table.getPrimaryKey()");
+        writer.emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()");
 
-            String primaryKeyGetter = metadata.getPrimaryKeyGetter();
-            VariableElement primaryKeyElement = metadata.getPrimaryKey();
-            if (metadata.isNullable(primaryKeyElement)) {
-                if (Utils.isString(primaryKeyElement)) {
-                    writer
-                        .emitStatement("String value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
-                        .emitStatement("long rowIndex = TableOrView.NO_MATCH")
-                        .beginControlFlow("if (value == null)")
-                            .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
-                        .nextControlFlow("else")
-                            .emitStatement("rowIndex = table.findFirstString(pkColumnIndex, value)")
-                        .endControlFlow();
+        writer.emitStatement("RealmObjectProxy cachedRealmObject = cache.get(object)");
+        writer.beginControlFlow("if (cachedRealmObject != null)")
+                .emitStatement("return (%s) cachedRealmObject", qualifiedClassName)
+                .nextControlFlow("else");
+
+            if (!metadata.hasPrimaryKey()) {
+                writer.emitStatement("return copy(realm, object, update, cache)");
+            } else {
+                writer
+                    .emitStatement("%s realmObject = null", qualifiedClassName)
+                    .emitStatement("boolean canUpdate = update")
+                    .beginControlFlow("if (canUpdate)")
+                        .emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName)
+                        .emitStatement("long pkColumnIndex = table.getPrimaryKey()");
+
+                String primaryKeyGetter = metadata.getPrimaryKeyGetter();
+                VariableElement primaryKeyElement = metadata.getPrimaryKey();
+                if (metadata.isNullable(primaryKeyElement)) {
+                    if (Utils.isString(primaryKeyElement)) {
+                        writer
+                            .emitStatement("String value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
+                            .emitStatement("long rowIndex = TableOrView.NO_MATCH")
+                            .beginControlFlow("if (value == null)")
+                                .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
+                            .nextControlFlow("else")
+                                .emitStatement("rowIndex = table.findFirstString(pkColumnIndex, value)")
+                            .endControlFlow();
+                    } else {
+                        writer
+                            .emitStatement("Number value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
+                            .emitStatement("long rowIndex = TableOrView.NO_MATCH")
+                            .beginControlFlow("if (value == null)")
+                                .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
+                            .nextControlFlow("else")
+                                .emitStatement("rowIndex = table.findFirstLong(pkColumnIndex, value.longValue())")
+                            .endControlFlow();
+                    }
                 } else {
-                    writer
-                        .emitStatement("Number value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
-                        .emitStatement("long rowIndex = TableOrView.NO_MATCH")
-                        .beginControlFlow("if (value == null)")
-                            .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
-                        .nextControlFlow("else")
-                            .emitStatement("rowIndex = table.findFirstLong(pkColumnIndex, value.longValue())")
-                        .endControlFlow();
+                    String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
+                    writer.emitStatement("long rowIndex = table.findFirst%s(pkColumnIndex, ((%s) object).%s())",
+                            pkType, interfaceName, primaryKeyGetter);
                 }
-            } else {
-                String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
-                writer.emitStatement("long rowIndex = table.findFirst%s(pkColumnIndex, ((%s) object).%s())",
-                        pkType, interfaceName, primaryKeyGetter);
+
+                writer
+                    .beginControlFlow("if (rowIndex != TableOrView.NO_MATCH)")
+                        .beginControlFlow("try")
+                            .emitStatement("objectContext.set(realm, table.getUncheckedRow(rowIndex)," +
+                                    " realm.schema.getColumnInfo(%s.class)," +
+                                    " false, Collections.<String> emptyList())", qualifiedClassName)
+                            .emitStatement("realmObject = new %s()", qualifiedGeneratedClassName)
+                            .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
+                        .nextControlFlow("finally")
+                            .emitStatement("objectContext.clear()")
+                        .endControlFlow()
+
+                    .nextControlFlow("else")
+                        .emitStatement("canUpdate = false")
+                    .endControlFlow();
+
+                writer.endControlFlow();
+
+                writer
+                    .emitEmptyLine()
+                    .beginControlFlow("if (canUpdate)")
+                        .emitStatement("return update(realm, realmObject, object, cache)")
+                    .nextControlFlow("else")
+                        .emitStatement("return copy(realm, object, update, cache)")
+                    .endControlFlow();
             }
 
+        writer.endControlFlow();
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void setTableValues(JavaWriter writer, String fieldType, String fieldName, String interfaceName, String getter, boolean isUpdate) throws IOException {
+        if ("long".equals(fieldType)
+                || "int".equals(fieldType)
+                || "short".equals(fieldType)
+                || "byte".equals(fieldType)) {
+            writer.emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s())", fieldName, interfaceName, getter);
+
+        } else if ("java.lang.Long".equals(fieldType)
+                || "java.lang.Integer".equals(fieldType)
+                || "java.lang.Short".equals(fieldType)
+                || "java.lang.Byte".equals(fieldType)) {
             writer
-                .beginControlFlow("if (rowIndex != TableOrView.NO_MATCH)")
-                    .emitStatement("realmObject = new %s(realm.schema.getColumnInfo(%s.class))",
-                            Utils.getProxyClassName(className),
-                            className)
-                    .emitStatement("((RealmObjectProxy)realmObject).realmGet$proxyState().setRealm$realm(realm)")
-                    .emitStatement("((RealmObjectProxy)realmObject).realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex))")
-                    .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
-                .nextControlFlow("else")
-                    .emitStatement("canUpdate = false")
-                .endControlFlow();
+                    .emitStatement("Number %s = ((%s)object).%s()", getter, interfaceName, getter)
+                    .beginControlFlow("if (%s != null)", getter)
+                        .emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue())", fieldName, getter);
+                    if (isUpdate) {
+                        writer.nextControlFlow("else")
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                    }
+                    writer.endControlFlow();
 
-            writer.endControlFlow();
+        } else if ("double".equals(fieldType)) {
+            writer.emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s())", fieldName, interfaceName, getter);
 
+        } else if("java.lang.Double".equals(fieldType)) {
             writer
-                .emitEmptyLine()
-                .beginControlFlow("if (canUpdate)")
-                    .emitStatement("return update(realm, realmObject, object, cache)")
-                .nextControlFlow("else")
-                    .emitStatement("return copy(realm, object, update, cache)")
+                    .emitStatement("Double %s = ((%s)object).%s()", getter, interfaceName, getter)
+                    .beginControlFlow("if (%s != null)", getter)
+                        .emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, %s)", fieldName, getter);
+                    if (isUpdate) {
+                        writer.nextControlFlow("else")
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                    }
+                    writer.endControlFlow();
+
+        } else if ("float".equals(fieldType)) {
+            writer.emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s())", fieldName, interfaceName, getter);
+
+        } else if ("java.lang.Float".equals(fieldType)) {
+            writer
+                    .emitStatement("Float %s = ((%s)object).%s()", getter, interfaceName, getter)
+                    .beginControlFlow("if (%s != null)", getter)
+                        .emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, %s)", fieldName, getter);
+                    if (isUpdate) {
+                        writer.nextControlFlow("else")
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                    }
+                    writer.endControlFlow();
+
+        } else if ("boolean".equals(fieldType)) {
+            writer.emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s())", fieldName, interfaceName, getter);
+
+        } else if ("java.lang.Boolean".equals(fieldType)) {
+            writer
+                    .emitStatement("Boolean %s = ((%s)object).%s()", getter, interfaceName, getter)
+                    .beginControlFlow("if (%s != null)", getter)
+                        .emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, %s)", fieldName, getter);
+                    if (isUpdate) {
+                        writer.nextControlFlow("else")
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                    }
+                    writer.endControlFlow();
+
+        } else if ("byte[]".equals(fieldType)) {
+            writer
+                    .emitStatement("byte[] %s = ((%s)object).%s()", getter, interfaceName, getter)
+                    .beginControlFlow("if (%s != null)", getter)
+                        .emitStatement("Table.nativeSetByteArray(tableNativePtr, columnInfo.%sIndex, rowIndex, %s)", fieldName, getter);
+                    if (isUpdate) {
+                        writer.nextControlFlow("else")
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                    }
+                    writer.endControlFlow();
+
+
+        } else if ("java.util.Date".equals(fieldType)) {
+            writer
+                    .emitStatement("java.util.Date %s = ((%s)object).%s()", getter, interfaceName, getter)
+                    .beginControlFlow("if (%s != null)", getter)
+                        .emitStatement("Table.nativeSetTimestamp(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.getTime())", fieldName, getter);
+                    if (isUpdate) {
+                        writer.nextControlFlow("else")
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                    }
+                    writer.endControlFlow();
+
+        } else if ("java.lang.String".equals(fieldType)) {
+            writer
+                    .emitStatement("String %s = ((%s)object).%s()", getter, interfaceName, getter)
+                    .beginControlFlow("if (%s != null)", getter)
+                        .emitStatement("Table.nativeSetString(tableNativePtr, columnInfo.%sIndex, rowIndex, %s)", fieldName, getter);
+                    if (isUpdate) {
+                        writer.nextControlFlow("else")
+                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName);
+                    }
+                    writer.endControlFlow();
+        } else {
+            throw new IllegalStateException("Unsupported type " + fieldType);
+        }
+    }
+
+    private void emitInsertMethod(JavaWriter writer) throws IOException {
+        writer.beginMethod(
+                "long", // Return type
+                "insert", // Method name
+                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
+                "Realm", "realm", qualifiedClassName, "object", "Map<RealmModel,Long>", "cache" // Argument type & argument name
+        );
+
+        // If object is already in the Realm there is nothing to update
+        writer
+                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))")
+                .emitStatement("return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex()")
                 .endControlFlow();
+
+        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
+        writer.emitStatement("long tableNativePtr = table.getNativeTablePointer()");
+        writer.emitStatement("%s columnInfo = (%s) realm.schema.getColumnInfo(%s.class)",
+                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
+
+        if (metadata.hasPrimaryKey()) {
+            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
         }
+        addPrimaryKeyCheckIfNeeded(metadata, true, writer);
 
+        for (VariableElement field : metadata.getFields()) {
+            String fieldName = field.getSimpleName().toString();
+            String fieldType = field.asType().toString();
+            String getter = metadata.getGetter(fieldName);
+
+            if (Utils.isRealmModel(field)) {
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sObj != null)", fieldName)
+                            .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
+                            .beginControlFlow("if (cache%s == null)", fieldName)
+                                .emitStatement("cache%s = %s.insert(realm, %sObj, cache)",
+                                        fieldName,
+                                        Utils.getProxyClassSimpleName(field),
+                                        fieldName)
+                            .endControlFlow()
+                           .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s)", fieldName)
+                        .endControlFlow();
+            } else if (Utils.isRealmList(field)) {
+                final String genericType = Utils.getGenericTypeQualifiedName(field);
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
+                                genericType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sList != null)", fieldName)
+                            .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
+                            .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                                .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
+                             .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                                .emitStatement("cacheItemIndex%1$s = %2$s.insert(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                             .endControlFlow()
+                             .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
+                            .endControlFlow()
+                            .emitStatement("LinkView.nativeClose(%sNativeLinkViewPtr)", fieldName)
+                        .endControlFlow()
+                        .emitEmptyLine();
+
+            } else {
+                if (metadata.getPrimaryKey() != field) {
+                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, false);
+                }
+            }
+        }
+
+        writer.emitStatement("return rowIndex");
         writer.endMethod();
         writer.emitEmptyLine();
     }
 
-    private void emitCopyMethod(JavaWriter writer) throws IOException {
+    private void emitInsertListMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
-                className, // Return type
-                "copy", // Method name
+                "void", // Return type
+                "insert", // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "Realm", "realm", className, "newObject", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache"); // Argument type & argument name
+                "Realm", "realm", "Iterator<? extends RealmModel>", "objects", "Map<RealmModel,Long>", "cache" // Argument type & argument name
+        );
 
+        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
+        writer.emitStatement("long tableNativePtr = table.getNativeTablePointer()");
+        writer.emitStatement("%s columnInfo = (%s) realm.schema.getColumnInfo(%s.class)",
+                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
         if (metadata.hasPrimaryKey()) {
-            writer.emitStatement("%s realmObject = realm.createObject(%s.class, ((%s) newObject).%s())",
-                    className, className, interfaceName, metadata.getPrimaryKeyGetter());
-        } else {
-            writer.emitStatement("%s realmObject = realm.createObject(%s.class)", className, className);
+            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
         }
-        writer.emitStatement("cache.put(newObject, (RealmObjectProxy) realmObject)");
+        writer.emitStatement("%s object = null", qualifiedClassName);
+
+        writer.beginControlFlow("while (objects.hasNext())");
+        writer.emitStatement("object = (%s) objects.next()", qualifiedClassName);
+        writer.beginControlFlow("if(!cache.containsKey(object))");
+
+        writer.beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))");
+                writer.emitStatement("cache.put(object, ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex())")
+                .emitStatement("continue");
+        writer.endControlFlow();
+
+        addPrimaryKeyCheckIfNeeded(metadata, true, writer);
+
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String fieldType = field.asType().toString();
-            String setter = metadata.getSetter(fieldName);
             String getter = metadata.getGetter(fieldName);
 
             if (Utils.isRealmModel(field)) {
                 writer
-                    .emitEmptyLine()
-                    .emitStatement("%s %sObj = ((%s) newObject).%s()", fieldType, fieldName, interfaceName, getter)
-                    .beginControlFlow("if (%sObj != null)", fieldName)
-                        .emitStatement("%s cache%s = (%s) cache.get(%sObj)", fieldType, fieldName, fieldType, fieldName)
-                        .beginControlFlow("if (cache%s != null)", fieldName)
-                            .emitStatement("((%s) realmObject).%s(cache%s)", interfaceName, setter, fieldName)
+                        .emitEmptyLine()
+                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sObj != null)", fieldName)
+                            .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
+                         .beginControlFlow("if (cache%s == null)", fieldName)
+                                .emitStatement("cache%s = %s.insert(realm, %sObj, cache)",
+                                        fieldName,
+                                        Utils.getProxyClassSimpleName(field),
+                                        fieldName)
+                                .endControlFlow()
+                        .emitStatement("table.setLink(columnInfo.%1$sIndex, rowIndex, cache%1$s)", fieldName)
+                        .endControlFlow();
+            } else if (Utils.isRealmList(field)) {
+                final String genericType = Utils.getGenericTypeQualifiedName(field);
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
+                                genericType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sList != null)", fieldName)
+                            .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
+                          .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                                .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
+                             .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                                    .emitStatement("cacheItemIndex%1$s = %2$s.insert(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                             .endControlFlow()
+                        .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
+                        .endControlFlow()
+                        .emitStatement("LinkView.nativeClose(%sNativeLinkViewPtr)", fieldName)
+                        .endControlFlow()
+                        .emitEmptyLine();
+
+            } else {
+                if (metadata.getPrimaryKey() != field) {
+                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, false);
+                }
+            }
+        }
+
+        writer.endControlFlow();
+        writer.endControlFlow();
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitInsertOrUpdateMethod(JavaWriter writer) throws IOException {
+        writer.beginMethod(
+                "long", // Return type
+                "insertOrUpdate", // Method name
+                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
+                "Realm", "realm", qualifiedClassName, "object", "Map<RealmModel,Long>", "cache" // Argument type & argument name
+        );
+
+        // If object is already in the Realm there is nothing to update
+        writer
+                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))")
+                .emitStatement("return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex()")
+                .endControlFlow();
+
+        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
+        writer.emitStatement("long tableNativePtr = table.getNativeTablePointer()");
+        writer.emitStatement("%s columnInfo = (%s) realm.schema.getColumnInfo(%s.class)",
+                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
+
+        if (metadata.hasPrimaryKey()) {
+            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
+        }
+        addPrimaryKeyCheckIfNeeded(metadata, false, writer);
+
+        for (VariableElement field : metadata.getFields()) {
+            String fieldName = field.getSimpleName().toString();
+            String fieldType = field.asType().toString();
+            String getter = metadata.getGetter(fieldName);
+
+            if (Utils.isRealmModel(field)) {
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sObj != null)", fieldName)
+                            .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
+                            .beginControlFlow("if (cache%s == null)", fieldName)
+                                .emitStatement("cache%1$s = %2$s.insertOrUpdate(realm, %1$sObj, cache)",
+                                        fieldName,
+                                        Utils.getProxyClassSimpleName(field))
+                            .endControlFlow()
+                            .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s)", fieldName)
                         .nextControlFlow("else")
-                            .emitStatement("((%s) realmObject).%s(%s.copyOrUpdate(realm, %sObj, update, cache))",
-                                    interfaceName,
-                                    setter,
-                                    Utils.getProxyClassSimpleName(field),
-                                    fieldName)
+                                // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
+                            .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
+                        .endControlFlow();
+            } else if (Utils.isRealmList(field)) {
+                final String genericType = Utils.getGenericTypeQualifiedName(field);
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
+                        .emitStatement("LinkView.nativeClear(%sNativeLinkViewPtr)", fieldName)
+                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
+                                genericType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sList != null)", fieldName)
+                            .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                                .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
+                                .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                                    .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                                .endControlFlow()
+                                .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
+                            .endControlFlow()
                         .endControlFlow()
-                    .nextControlFlow("else")
-                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
-                        .emitStatement("((%s) realmObject).%s(null)", interfaceName, setter)
-                    .endControlFlow();
+                        .emitStatement("LinkView.nativeClose(%sNativeLinkViewPtr)", fieldName)
+                        .emitEmptyLine();
+
+            } else {
+                if (metadata.getPrimaryKey() != field) {
+                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, true);
+                }
+            }
+        }
+
+        writer.emitStatement("return rowIndex");
+
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitInsertOrUpdateListMethod(JavaWriter writer) throws IOException {
+        writer.beginMethod(
+                "void", // Return type
+                "insertOrUpdate", // Method name
+                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
+                "Realm", "realm", "Iterator<? extends RealmModel>", "objects", "Map<RealmModel,Long>", "cache" // Argument type & argument name
+        );
+
+        writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
+        writer.emitStatement("long tableNativePtr = table.getNativeTablePointer()");
+        writer.emitStatement("%s columnInfo = (%s) realm.schema.getColumnInfo(%s.class)",
+                columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
+        if (metadata.hasPrimaryKey()) {
+            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
+        }
+        writer.emitStatement("%s object = null", qualifiedClassName);
+
+        writer.beginControlFlow("while (objects.hasNext())");
+        writer.emitStatement("object = (%s) objects.next()", qualifiedClassName);
+        writer.beginControlFlow("if(!cache.containsKey(object))");
+
+        writer.beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))");
+            writer.emitStatement("cache.put(object, ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex())")
+                  .emitStatement("continue");
+        writer.endControlFlow();
+        addPrimaryKeyCheckIfNeeded(metadata, false, writer);
+
+        for (VariableElement field : metadata.getFields()) {
+            String fieldName = field.getSimpleName().toString();
+            String fieldType = field.asType().toString();
+            String getter = metadata.getGetter(fieldName);
+
+            if (Utils.isRealmModel(field)) {
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sObj != null)", fieldName)
+                            .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
+                            .beginControlFlow("if (cache%s == null)", fieldName)
+                                .emitStatement("cache%1$s = %2$s.insertOrUpdate(realm, %1$sObj, cache)",
+                                        fieldName,
+                                        Utils.getProxyClassSimpleName(field))
+                                    .endControlFlow()
+                            .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s)", fieldName)
+                        .nextControlFlow("else")
+                                // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
+                            .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
+                        .endControlFlow();
             } else if (Utils.isRealmList(field)) {
+                final String genericType = Utils.getGenericTypeQualifiedName(field);
                 writer
-                    .emitEmptyLine()
-                    .emitStatement("RealmList<%s> %sList = ((%s) newObject).%s()",
-                            Utils.getGenericType(field), fieldName, interfaceName, getter)
-                    .beginControlFlow("if (%sList != null)", fieldName)
-                        .emitStatement("RealmList<%s> %sRealmList = ((%s) realmObject).%s()",
-                                Utils.getGenericType(field), fieldName, interfaceName, getter)
-                        .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
-                                .emitStatement("%s %sItem = %sList.get(i)", Utils.getGenericType(field), fieldName, fieldName)
-                                .emitStatement("%s cache%s = (%s) cache.get(%sItem)", Utils.getGenericType(field), fieldName, Utils.getGenericType(field), fieldName)
-                                .beginControlFlow("if (cache%s != null)", fieldName)
-                                        .emitStatement("%sRealmList.add(cache%s)", fieldName, fieldName)
-                                .nextControlFlow("else")
-                                        .emitStatement("%sRealmList.add(%s.copyOrUpdate(realm, %sList.get(i), update, cache))", fieldName, Utils.getProxyClassSimpleName(field), fieldName)
+                        .emitEmptyLine()
+                        .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
+                        .emitStatement("LinkView.nativeClear(%sNativeLinkViewPtr)", fieldName)
+                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
+                                genericType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sList != null)", fieldName)
+                            .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                                .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
+                            .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                                    .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
                                 .endControlFlow()
+                            .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
+                            .endControlFlow()
                         .endControlFlow()
-                    .endControlFlow()
-                    .emitEmptyLine();
+                        .emitStatement("LinkView.nativeClose(%sNativeLinkViewPtr)", fieldName)
+                        .emitEmptyLine();
 
             } else {
-                writer.emitStatement("((%s) realmObject).%s(((%s) newObject).%s())",
-                        interfaceName, setter, interfaceName, getter);
+                if (metadata.getPrimaryKey() != field) {
+                    setTableValues(writer, fieldType, fieldName, interfaceName, getter, true);
+                }
             }
         }
+            writer.endControlFlow();
+        writer.endControlFlow();
 
-        writer.emitStatement("return realmObject");
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void addPrimaryKeyCheckIfNeeded(ClassMetaData metadata, boolean throwIfPrimaryKeyDuplicate, JavaWriter writer) throws IOException {
+        if (metadata.hasPrimaryKey()) {
+            String primaryKeyGetter = metadata.getPrimaryKeyGetter();
+            VariableElement primaryKeyElement = metadata.getPrimaryKey();
+            if (metadata.isNullable(primaryKeyElement)) {
+                if (Utils.isString(primaryKeyElement)) {
+                    writer
+                        .emitStatement("String primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
+                        .emitStatement("long rowIndex = TableOrView.NO_MATCH")
+                        .beginControlFlow("if (primaryKeyValue == null)")
+                        .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
+                        .nextControlFlow("else")
+                        .emitStatement("rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue)")
+                        .endControlFlow();
+                } else {
+                    writer
+                        .emitStatement("Object primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
+                        .emitStatement("long rowIndex = TableOrView.NO_MATCH")
+                        .beginControlFlow("if (primaryKeyValue == null)")
+                        .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
+                        .nextControlFlow("else")
+                        .emitStatement("rowIndex = Table.nativeFindFirstInt(tableNativePtr, pkColumnIndex, ((%s) object).%s())", interfaceName, primaryKeyGetter)
+                        .endControlFlow();
+                }
+            } else {
+                writer.emitStatement("long rowIndex = TableOrView.NO_MATCH");
+                writer.emitStatement("Object primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter);
+                writer.beginControlFlow("if (primaryKeyValue != null)");
+
+                if (Utils.isString(metadata.getPrimaryKey())) {
+                    writer.emitStatement("rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, (String)primaryKeyValue)");
+                } else {
+                    writer.emitStatement("rowIndex = Table.nativeFindFirstInt(tableNativePtr, pkColumnIndex, ((%s) object).%s())", interfaceName, primaryKeyGetter);
+                }
+                writer.endControlFlow();
+            }
+
+            writer.beginControlFlow("if (rowIndex == TableOrView.NO_MATCH)");
+            if (Utils.isString(metadata.getPrimaryKey())) {
+                writer.emitStatement("rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false)");
+            } else {
+                writer.emitStatement("rowIndex = table.addEmptyRowWithPrimaryKey(((%s) object).%s(), false)",
+                        interfaceName, primaryKeyGetter);
+            }
+
+            if (throwIfPrimaryKeyDuplicate) {
+                writer.nextControlFlow("else");
+                writer.emitStatement("Table.throwDuplicatePrimaryKeyException(primaryKeyValue)");
+            }
+
+            writer.endControlFlow();
+            writer.emitStatement("cache.put(object, rowIndex)");
+        } else {
+            writer.emitStatement("long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1)");
+            writer.emitStatement("cache.put(object, rowIndex)");
+        }
+    }
+
+    private void emitCopyMethod(JavaWriter writer) throws IOException {
+        writer.beginMethod(
+                qualifiedClassName, // Return type
+                "copy", // Method name
+                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
+                "Realm", "realm", qualifiedClassName, "newObject", "boolean", "update", "Map<RealmModel,RealmObjectProxy>", "cache"); // Argument type & argument name
+
+        writer.emitStatement("RealmObjectProxy cachedRealmObject = cache.get(newObject)");
+        writer.beginControlFlow("if (cachedRealmObject != null)")
+              .emitStatement("return (%s) cachedRealmObject", qualifiedClassName)
+              .nextControlFlow("else");
+
+            writer.emitSingleLineComment("rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.");
+            if (metadata.hasPrimaryKey()) {
+                writer.emitStatement("%s realmObject = realm.createObjectInternal(%s.class, ((%s) newObject).%s(), false, Collections.<String>emptyList())",
+                        qualifiedClassName, qualifiedClassName, interfaceName, metadata.getPrimaryKeyGetter());
+            } else {
+                writer.emitStatement("%s realmObject = realm.createObjectInternal(%s.class, false, Collections.<String>emptyList())",
+                        qualifiedClassName, qualifiedClassName);
+            }
+            writer.emitStatement("cache.put(newObject, (RealmObjectProxy) realmObject)");
+            for (VariableElement field : metadata.getFields()) {
+                String fieldName = field.getSimpleName().toString();
+                String fieldType = field.asType().toString();
+                String setter = metadata.getSetter(fieldName);
+                String getter = metadata.getGetter(fieldName);
+
+                if (metadata.isPrimaryKey(field)) {
+                    // PK has been set when creating object.
+                    continue;
+                }
+
+                if (Utils.isRealmModel(field)) {
+                    writer
+                        .emitEmptyLine()
+                        .emitStatement("%s %sObj = ((%s) newObject).%s()", fieldType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sObj != null)", fieldName)
+                            .emitStatement("%s cache%s = (%s) cache.get(%sObj)", fieldType, fieldName, fieldType, fieldName)
+                            .beginControlFlow("if (cache%s != null)", fieldName)
+                                .emitStatement("((%s) realmObject).%s(cache%s)", interfaceName, setter, fieldName)
+                            .nextControlFlow("else")
+                                .emitStatement("((%s) realmObject).%s(%s.copyOrUpdate(realm, %sObj, update, cache))",
+                                        interfaceName,
+                                        setter,
+                                        Utils.getProxyClassSimpleName(field),
+                                        fieldName)
+                            .endControlFlow()
+                        .nextControlFlow("else")
+                            // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
+                            .emitStatement("((%s) realmObject).%s(null)", interfaceName, setter)
+                        .endControlFlow();
+                } else if (Utils.isRealmList(field)) {
+                    final String genericType = Utils.getGenericTypeQualifiedName(field);
+                    writer
+                        .emitEmptyLine()
+                        .emitStatement("RealmList<%s> %sList = ((%s) newObject).%s()",
+                                genericType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sList != null)", fieldName)
+                            .emitStatement("RealmList<%s> %sRealmList = ((%s) realmObject).%s()",
+                                    genericType, fieldName, interfaceName, getter)
+                            .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
+                                    .emitStatement("%s %sItem = %sList.get(i)", genericType, fieldName, fieldName)
+                                    .emitStatement("%s cache%s = (%s) cache.get(%sItem)", genericType, fieldName, genericType, fieldName)
+                                    .beginControlFlow("if (cache%s != null)", fieldName)
+                                            .emitStatement("%sRealmList.add(cache%s)", fieldName, fieldName)
+                                    .nextControlFlow("else")
+                                            .emitStatement("%sRealmList.add(%s.copyOrUpdate(realm, %sList.get(i), update, cache))", fieldName, Utils.getProxyClassSimpleName(field), fieldName)
+                                    .endControlFlow()
+                            .endControlFlow()
+                        .endControlFlow()
+                        .emitEmptyLine();
+
+                } else {
+                    writer.emitStatement("((%s) realmObject).%s(((%s) newObject).%s())",
+                            interfaceName, setter, interfaceName, getter);
+                }
+            }
+
+            writer.emitStatement("return realmObject");
+          writer.endControlFlow();
         writer.endMethod();
         writer.emitEmptyLine();
     }
 
     private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException {
         writer.beginMethod(
-                className, // Return type
+                qualifiedClassName, // Return type
                 "createDetachedCopy", // Method name
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                className, "realmObject", "int", "currentDepth", "int", "maxDepth", "Map<RealmModel, CacheData<RealmModel>>", "cache");
+                qualifiedClassName, "realmObject", "int", "currentDepth", "int", "maxDepth", "Map<RealmModel, CacheData<RealmModel>>", "cache");
         writer
             .beginControlFlow("if (currentDepth > maxDepth || realmObject == null)")
                 .emitStatement("return null")
             .endControlFlow()
             .emitStatement("CacheData<RealmModel> cachedObject = cache.get(realmObject)")
-            .emitStatement("%s unmanagedObject", className)
+            .emitStatement("%s unmanagedObject", qualifiedClassName)
             .beginControlFlow("if (cachedObject != null)")
                 .emitSingleLineComment("Reuse cached object or recreate it because it was encountered at a lower depth.")
                 .beginControlFlow("if (currentDepth >= cachedObject.minDepth)")
-                    .emitStatement("return (%s)cachedObject.object", className)
+                    .emitStatement("return (%s)cachedObject.object", qualifiedClassName)
                 .nextControlFlow("else")
-                    .emitStatement("unmanagedObject = (%s)cachedObject.object", className)
+                    .emitStatement("unmanagedObject = (%s)cachedObject.object", qualifiedClassName)
                     .emitStatement("cachedObject.minDepth = currentDepth")
                 .endControlFlow()
             .nextControlFlow("else")
-                .emitStatement("unmanagedObject = new %s()", className)
+                .emitStatement("unmanagedObject = new %s()", qualifiedClassName)
                 .emitStatement("cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject))")
             .endControlFlow();
 
@@ -785,14 +1411,14 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
                         .emitStatement("((%s) unmanagedObject).%s(null)", interfaceName, setter)
                     .nextControlFlow("else")
                         .emitStatement("RealmList<%s> managed%sList = ((%s) realmObject).%s()",
-                                Utils.getGenericType(field), fieldName, interfaceName, getter)
-                        .emitStatement("RealmList<%1$s> unmanaged%2$sList = new RealmList<%1$s>()", Utils.getGenericType(field), fieldName)
+                                 Utils.getGenericTypeQualifiedName(field), fieldName, interfaceName, getter)
+                        .emitStatement("RealmList<%1$s> unmanaged%2$sList = new RealmList<%1$s>()", Utils.getGenericTypeQualifiedName(field), fieldName)
                         .emitStatement("((%s) unmanagedObject).%s(unmanaged%sList)", interfaceName, setter, fieldName)
                         .emitStatement("int nextDepth = currentDepth + 1")
                         .emitStatement("int size = managed%sList.size()", fieldName)
                         .beginControlFlow("for (int i = 0; i < size; i++)")
                             .emitStatement("%s item = %s.createDetachedCopy(managed%sList.get(i), nextDepth, maxDepth, cache)",
-                                    Utils.getGenericType(field), Utils.getProxyClassSimpleName(field), fieldName)
+                                    Utils.getGenericTypeQualifiedName(field), Utils.getProxyClassSimpleName(field), fieldName)
                             .emitStatement("unmanaged%sList.add(item)", fieldName)
                         .endControlFlow()
                     .endControlFlow();
@@ -813,10 +1439,10 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
         }
 
         writer.beginMethod(
-                className, // Return type
+                qualifiedClassName, // Return type
                 "update", // Method name
                 EnumSet.of(Modifier.STATIC), // Modifiers
-                "Realm", "realm", className, "realmObject", className, "newObject", "Map<RealmModel, RealmObjectProxy>", "cache"); // Argument type & argument name
+                "Realm", "realm", qualifiedClassName, "realmObject", qualifiedClassName, "newObject", "Map<RealmModel, RealmObjectProxy>", "cache"); // Argument type & argument name
 
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
@@ -825,9 +1451,9 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
             if (Utils.isRealmModel(field)) {
                 writer
                     .emitStatement("%s %sObj = ((%s) newObject).%s()",
-                            Utils.getFieldTypeSimpleName(field), fieldName, interfaceName, getter)
+                            Utils.getFieldTypeQualifiedName(field), fieldName, interfaceName, getter)
                     .beginControlFlow("if (%sObj != null)", fieldName)
-                        .emitStatement("%s cache%s = (%s) cache.get(%sObj)", Utils.getFieldTypeSimpleName(field), fieldName, Utils.getFieldTypeSimpleName(field), fieldName)
+                        .emitStatement("%s cache%s = (%s) cache.get(%sObj)", Utils.getFieldTypeQualifiedName(field), fieldName, Utils.getFieldTypeQualifiedName(field), fieldName)
                         .beginControlFlow("if (cache%s != null)", fieldName)
                             .emitStatement("((%s) realmObject).%s(cache%s)", interfaceName, setter, fieldName)
                         .nextControlFlow("else")
@@ -835,8 +1461,7 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
                                     interfaceName,
                                     setter,
                                     Utils.getProxyClassSimpleName(field),
-                                    fieldName,
-                                    Utils.getFieldTypeSimpleName(field)
+                                    fieldName
                             )
                         .endControlFlow()
                     .nextControlFlow("else")
@@ -844,16 +1469,17 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
                         .emitStatement("((%s) realmObject).%s(null)", interfaceName, setter)
                     .endControlFlow();
             } else if (Utils.isRealmList(field)) {
+                final String genericType = Utils.getGenericTypeQualifiedName(field);
                 writer
                     .emitStatement("RealmList<%s> %sList = ((%s) newObject).%s()",
-                            Utils.getGenericType(field), fieldName, interfaceName, getter)
+                            genericType, fieldName, interfaceName, getter)
                     .emitStatement("RealmList<%s> %sRealmList = ((%s) realmObject).%s()",
-                            Utils.getGenericType(field), fieldName, interfaceName, getter)
+                            genericType, fieldName, interfaceName, getter)
                     .emitStatement("%sRealmList.clear()", fieldName)
                     .beginControlFlow("if (%sList != null)", fieldName)
                         .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
-                            .emitStatement("%s %sItem = %sList.get(i)", Utils.getGenericType(field), fieldName, fieldName)
-                            .emitStatement("%s cache%s = (%s) cache.get(%sItem)", Utils.getGenericType(field), fieldName, Utils.getGenericType(field), fieldName)
+                            .emitStatement("%s %sItem = %sList.get(i)", genericType, fieldName, fieldName)
+                            .emitStatement("%s cache%s = (%s) cache.get(%sItem)", genericType, fieldName, genericType, fieldName)
                             .beginControlFlow("if (cache%s != null)", fieldName)
                                 .emitStatement("%sRealmList.add(cache%s)", fieldName, fieldName)
                             .nextControlFlow("else")
@@ -885,7 +1511,7 @@ private void emitToStringMethod(JavaWriter writer) throws IOException {
         writer.beginControlFlow("if (!RealmObject.isValid(this))");
         writer.emitStatement("return \"Invalid object\"");
         writer.endControlFlow();
-        writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = [\")", className);
+        writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = [\")", simpleClassName);
         List<VariableElement> fields = metadata.getFields();
         for (int i = 0; i < fields.size(); i++) {
             VariableElement field = fields.get(i);
@@ -900,9 +1526,9 @@ private void emitToStringMethod(JavaWriter writer) throws IOException {
                         fieldTypeSimpleName
                 );
             } else if (Utils.isRealmList(field)) {
-                String genericType = Utils.getGenericType(field);
+                String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
                 writer.emitStatement("stringBuilder.append(\"RealmList<%s>[\").append(%s().size()).append(\"]\")",
-                        genericType,
+                        genericTypeSimpleName,
                         metadata.getGetter(fieldName));
             } else {
                 if (metadata.isNullable(field)) {
@@ -955,46 +1581,55 @@ private void emitEqualsMethod(JavaWriter writer) throws IOException {
         if (metadata.containsEquals()) {
             return;
         }
-        String proxyClassName = className + Constants.PROXY_SUFFIX;
+        String proxyClassName = Utils.getProxyClassName(simpleClassName);
+        String otherObjectVarName = "a" + simpleClassName;
         writer.emitAnnotation("Override");
         writer.beginMethod("boolean", "equals", EnumSet.of(Modifier.PUBLIC), "Object", "o");
         writer.emitStatement("if (this == o) return true");
         writer.emitStatement("if (o == null || getClass() != o.getClass()) return false");
-        writer.emitStatement("%s a%s = (%s)o", proxyClassName, className, proxyClassName);  // FooRealmProxy aFoo = (FooRealmProxy)o
+        writer.emitStatement("%s %s = (%s)o", proxyClassName, otherObjectVarName, proxyClassName);  // FooRealmProxy aFoo = (FooRealmProxy)o
         writer.emitEmptyLine();
         writer.emitStatement("String path = proxyState.getRealm$realm().getPath()");
-        writer.emitStatement("String otherPath = a%s.proxyState.getRealm$realm().getPath()", className);
-        writer.emitStatement("if (path != null ? !path.equals(otherPath) : otherPath != null) return false;");
+        writer.emitStatement("String otherPath = %s.proxyState.getRealm$realm().getPath()", otherObjectVarName);
+        writer.emitStatement("if (path != null ? !path.equals(otherPath) : otherPath != null) return false");
         writer.emitEmptyLine();
         writer.emitStatement("String tableName = proxyState.getRow$realm().getTable().getName()");
-        writer.emitStatement("String otherTableName = a%s.proxyState.getRow$realm().getTable().getName()", className);
+        writer.emitStatement("String otherTableName = %s.proxyState.getRow$realm().getTable().getName()", otherObjectVarName);
         writer.emitStatement("if (tableName != null ? !tableName.equals(otherTableName) : otherTableName != null) return false");
         writer.emitEmptyLine();
-        writer.emitStatement("if (proxyState.getRow$realm().getIndex() != a%s.proxyState.getRow$realm().getIndex()) return false", className);
+        writer.emitStatement("if (proxyState.getRow$realm().getIndex() != %s.proxyState.getRow$realm().getIndex()) return false", otherObjectVarName);
         writer.emitEmptyLine();
         writer.emitStatement("return true");
         writer.endMethod();
         writer.emitEmptyLine();
     }
 
-
     private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOException {
         writer.emitAnnotation("SuppressWarnings", "\"cast\"");
         writer.beginMethod(
-                className,
+                qualifiedClassName,
                 "createOrUpdateUsingJsonObject",
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
                 Arrays.asList("Realm", "realm", "JSONObject", "json", "boolean", "update"),
                 Collections.singletonList("JSONException"));
 
+        final int modelOrListCount = countModelOrListFields(metadata.getFields());
+        if (modelOrListCount == 0) {
+            writer.emitStatement("final List<String> excludeFields = Collections.<String> emptyList()");
+        } else {
+            writer.emitStatement("final List<String> excludeFields = new ArrayList<String>(%1$d)",
+                    modelOrListCount);
+        }
         if (!metadata.hasPrimaryKey()) {
-            writer.emitStatement("%s obj = realm.createObject(%s.class)", className, className);
+            buildExcludeFieldsList(writer, metadata.getFields());
+            writer.emitStatement("%s obj = realm.createObjectInternal(%s.class, true, excludeFields)",
+                    qualifiedClassName, qualifiedClassName);
         } else {
             String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
             writer
-                .emitStatement("%s obj = null", className)
+                .emitStatement("%s obj = null", qualifiedClassName)
                 .beginControlFlow("if (update)")
-                    .emitStatement("Table table = realm.getTable(%s.class)", className)
+                    .emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName)
                     .emitStatement("long pkColumnIndex = table.getPrimaryKey()")
                     .emitStatement("long rowIndex = TableOrView.NO_MATCH");
             if (metadata.isNullable(metadata.getPrimaryKey())) {
@@ -1014,23 +1649,34 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
             }
             writer
                     .beginControlFlow("if (rowIndex != TableOrView.NO_MATCH)")
-                        .emitStatement("obj = new %s(realm.schema.getColumnInfo(%s.class))",
-                                Utils.getProxyClassName(className), className)
-                        .emitStatement("((RealmObjectProxy)obj).realmGet$proxyState().setRealm$realm(realm)")
-                        .emitStatement("((RealmObjectProxy)obj).realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex))")
+                        .emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()")
+                        .beginControlFlow("try")
+                            .emitStatement("objectContext.set(realm, table.getUncheckedRow(rowIndex)," +
+                                    " realm.schema.getColumnInfo(%s.class)," +
+                                    " false, Collections.<String> emptyList())", qualifiedClassName)
+                            .emitStatement("obj = new %s()", qualifiedGeneratedClassName)
+                        .nextControlFlow("finally")
+                            .emitStatement("objectContext.clear()")
+                        .endControlFlow()
                     .endControlFlow()
                 .endControlFlow();
 
             writer.beginControlFlow("if (obj == null)");
+            buildExcludeFieldsList(writer, metadata.getFields());
             String primaryKeyFieldType = metadata.getPrimaryKey().asType().toString();
             String primaryKeyFieldName = metadata.getPrimaryKey().getSimpleName().toString();
-            RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(className, primaryKeyFieldType, primaryKeyFieldName, writer);
+            RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(qualifiedClassName, qualifiedGeneratedClassName,
+                    primaryKeyFieldType, primaryKeyFieldName, writer);
             writer.endControlFlow();
         }
 
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String qualifiedFieldType = field.asType().toString();
+            if (metadata.isPrimaryKey(field)) {
+                // Primary key has already been set when adding new row or finding the existing row.
+                continue;
+            }
             if (Utils.isRealmModel(field)) {
                 RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(
                         interfaceName,
@@ -1067,16 +1713,33 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
         writer.emitEmptyLine();
     }
 
+    private void buildExcludeFieldsList(JavaWriter writer, List<VariableElement> fields) throws IOException {
+        for (VariableElement field : fields) {
+            if (Utils.isRealmModel(field) || Utils.isRealmList(field)) {
+                final String fieldName = field.getSimpleName().toString();
+                writer.beginControlFlow("if (json.has(\"%1$s\"))", fieldName)
+                        .emitStatement("excludeFields.add(\"%1$s\")", fieldName)
+                        .endControlFlow();
+            }
+        }
+    }
+
+    // Since we need to check the PK in stream before creating the object, this is now using copyToRealm
+    // instead of createObject() to avoid parsing the stream twice.
     private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
         writer.emitAnnotation("SuppressWarnings", "\"cast\"");
+        writer.emitAnnotation("TargetApi", "Build.VERSION_CODES.HONEYCOMB");
         writer.beginMethod(
-                className,
+                qualifiedClassName,
                 "createUsingJsonStream",
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),
                 Arrays.asList("Realm", "realm", "JsonReader", "reader"),
                 Collections.singletonList("IOException"));
 
-        writer.emitStatement("%s obj = realm.createObject(%s.class)",className, className);
+        if (metadata.hasPrimaryKey()) {
+            writer.emitStatement("boolean jsonHasPrimaryKey = false");
+        }
+        writer.emitStatement("%s obj = new %s()", qualifiedClassName, qualifiedClassName);
         writer.emitStatement("reader.beginObject()");
         writer.beginControlFlow("while (reader.hasNext())");
         writer.emitStatement("String name = reader.nextName()");
@@ -1114,7 +1777,7 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
             } else {
                 RealmJsonTypeHelper.emitFillJavaTypeFromStream(
                         interfaceName,
-                        metadata.getSetter(fieldName),
+                        metadata,
                         fieldName,
                         qualifiedFieldType,
                         writer
@@ -1129,13 +1792,20 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
         }
         writer.endControlFlow();
         writer.emitStatement("reader.endObject()");
+        if (metadata.hasPrimaryKey()) {
+            writer.beginControlFlow("if (!jsonHasPrimaryKey)");
+            writer.emitStatement(Constants.STATEMENT_EXCEPTION_NO_PRIMARY_KEY_IN_JSON, metadata.getPrimaryKey());
+            writer.endControlFlow();
+        }
+        writer.emitStatement("obj = realm.copyToRealm(obj)");
         writer.emitStatement("return obj");
         writer.endMethod();
         writer.emitEmptyLine();
+
     }
 
     private String columnInfoClassName() {
-        return className + "ColumnInfo";
+        return simpleClassName + "ColumnInfo";
     }
 
     private String columnIndexVarName(VariableElement variableElement) {
@@ -1145,4 +1815,14 @@ private String columnIndexVarName(VariableElement variableElement) {
     private String fieldIndexVariableReference(VariableElement variableElement) {
         return "columnInfo." + columnIndexVarName(variableElement);
     }
+
+    private static int countModelOrListFields(List<VariableElement> fields) {
+        int count = 0;
+        for (VariableElement f : fields) {
+            if (Utils.isRealmModel(f) || Utils.isRealmList(f)) {
+                count++;
+            }
+        }
+        return count;
+    }
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
index 7a963457c5..69f14ae529 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
@@ -33,14 +33,13 @@
 
 import io.realm.annotations.RealmModule;
 
+import static io.realm.processor.Constants.REALM_PACKAGE_NAME;
+
 public class RealmProxyMediatorGenerator {
     private final String className;
     private ProcessingEnvironment processingEnvironment;
     private List<String> qualifiedModelClasses = new ArrayList<String>();
-    private List<String> simpleModelClasses = new ArrayList<String>();
-    private List<String> proxyClasses = new ArrayList<String>();
-
-    private static final String REALM_PACKAGE_NAME = "io.realm";
+    private List<String> qualifiedProxyClasses = new ArrayList<String>();
 
     public RealmProxyMediatorGenerator(ProcessingEnvironment processingEnvironment,
                                        String className, Set<ClassMetaData> classesToValidate) {
@@ -50,8 +49,7 @@ public RealmProxyMediatorGenerator(ProcessingEnvironment processingEnvironment,
         for (ClassMetaData metadata : classesToValidate) {
             String simpleName = metadata.getSimpleClassName();
             qualifiedModelClasses.add(metadata.getFullyQualifiedClassName());
-            simpleModelClasses.add(simpleName);
-            proxyClasses.add(getProxyClassName(simpleName));
+            qualifiedProxyClasses.add(REALM_PACKAGE_NAME + "." + getProxyClassName(simpleName));
         }
     }
 
@@ -68,20 +66,22 @@ public void generate() throws IOException {
                 "android.util.JsonReader",
                 "java.io.IOException",
                 "java.util.Collections",
-                "java.util.HashMap",
                 "java.util.HashSet",
                 "java.util.List",
                 "java.util.Map",
+                "java.util.IdentityHashMap",
                 "java.util.Set",
+                "java.util.Iterator",
+                "java.util.Collection",
                 "io.realm.internal.ColumnInfo",
-                "io.realm.internal.ImplicitTransaction",
+                "io.realm.internal.SharedRealm",
                 "io.realm.internal.RealmObjectProxy",
                 "io.realm.internal.RealmProxyMediator",
+                "io.realm.internal.Row",
                 "io.realm.internal.Table",
                 "org.json.JSONException",
                 "org.json.JSONObject"
         );
-        writer.emitImports(qualifiedModelClasses);
 
         writer.emitEmptyLine();
 
@@ -101,6 +101,10 @@ public void generate() throws IOException {
         emitNewInstanceMethod(writer);
         emitGetClassModelList(writer);
         emitCopyToRealmMethod(writer);
+        emitInsertObjectToRealmMethod(writer);
+        emitInsertListToRealmMethod(writer);
+        emitInsertOrUpdateObjectToRealmMethod(writer);
+        emitInsertOrUpdateListToRealmMethod(writer);
         emitCreteOrUpdateUsingJsonObject(writer);
         emitCreateUsingJsonStream(writer);
         emitCreateDetachedCopyMethod(writer);
@@ -112,7 +116,7 @@ private void emitFields(JavaWriter writer) throws IOException {
         writer.emitField("Set<Class<? extends RealmModel>>", "MODEL_CLASSES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL));
         writer.beginInitializer(true);
         writer.emitStatement("Set<Class<? extends RealmModel>> modelClasses = new HashSet<Class<? extends RealmModel>>()");
-        for (String clazz : simpleModelClasses) {
+        for (String clazz : qualifiedModelClasses) {
             writer.emitStatement("modelClasses.add(%s.class)", clazz);
         }
         writer.emitStatement("MODEL_CLASSES = Collections.unmodifiableSet(modelClasses)");
@@ -126,12 +130,12 @@ private void emitCreateTableMethod(JavaWriter writer) throws IOException {
                 "Table",
                 "createTable",
                 EnumSet.of(Modifier.PUBLIC),
-                "Class<? extends RealmModel>", "clazz", "ImplicitTransaction", "transaction"
+                "Class<? extends RealmModel>", "clazz", "SharedRealm", "sharedRealm"
         );
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return %s.initTable(transaction)", proxyClasses.get(i));
+                writer.emitStatement("return %s.initTable(sharedRealm)", qualifiedProxyClasses.get(i));
             }
         }, writer);
         writer.endMethod();
@@ -144,12 +148,15 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                 "ColumnInfo",
                 "validateTable",
                 EnumSet.of(Modifier.PUBLIC),
-                "Class<? extends RealmModel>", "clazz", "ImplicitTransaction", "transaction"
+                "Class<? extends RealmModel>", "clazz", // Argument type & argument name
+                "SharedRealm", "sharedRealm",
+                "boolean", "allowExtraColumns"
         );
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return %s.validateTable(transaction)", proxyClasses.get(i));
+                writer.emitStatement("return %s.validateTable(sharedRealm, allowExtraColumns)",
+                        qualifiedProxyClasses.get(i));
             }
         }, writer);
         writer.endMethod();
@@ -167,7 +174,7 @@ private void emitGetFieldNamesMethod(JavaWriter writer) throws IOException {
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return %s.getFieldNames()", proxyClasses.get(i));
+                writer.emitStatement("return %s.getFieldNames()", qualifiedProxyClasses.get(i));
             }
         }, writer);
         writer.endMethod();
@@ -185,7 +192,7 @@ private void emitGetTableNameMethod(JavaWriter writer) throws IOException {
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return %s.getTableName()", proxyClasses.get(i));
+                writer.emitStatement("return %s.getTableName()", qualifiedProxyClasses.get(i));
             }
         }, writer);
         writer.endMethod();
@@ -198,14 +205,25 @@ private void emitNewInstanceMethod(JavaWriter writer) throws IOException {
                 "<E extends RealmModel> E",
                 "newInstance",
                 EnumSet.of(Modifier.PUBLIC),
-                "Class<E>", "clazz", "ColumnInfo", "columnInfo"
+                "Class<E>", "clazz",
+                "Object", "baseRealm",
+                "Row", "row",
+                "ColumnInfo", "columnInfo",
+                "boolean", "acceptDefaultValue",
+                "List<String>", "excludeFields"
         );
+        writer.emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()");
+        writer.beginControlFlow("try")
+                .emitStatement("objectContext.set((BaseRealm) baseRealm, row, columnInfo, acceptDefaultValue, excludeFields)");
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return clazz.cast(new %s(columnInfo))", proxyClasses.get(i));
+                writer.emitStatement("return clazz.cast(new %s())", qualifiedProxyClasses.get(i));
             }
         }, writer);
+        writer.nextControlFlow("finally")
+                .emitStatement("objectContext.clear()")
+                .endControlFlow();
         writer.endMethod();
         writer.emitEmptyLine();
     }
@@ -233,9 +251,133 @@ private void emitCopyToRealmMethod(JavaWriter writer) throws IOException {
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return clazz.cast(%s.copyOrUpdate(realm, (%s) obj, update, cache))", proxyClasses.get(i), simpleModelClasses.get(i));
+                writer.emitStatement("return clazz.cast(%s.copyOrUpdate(realm, (%s) obj, update, cache))", qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
+            }
+        }, writer, false);
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitInsertObjectToRealmMethod(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "void",
+                "insert",
+                EnumSet.of(Modifier.PUBLIC),
+                "Realm", "realm", "RealmModel", "object", "Map<RealmModel, Long>", "cache");
+        writer.emitSingleLineComment("This cast is correct because obj is either");
+        writer.emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject");
+        writer.emitStatement("@SuppressWarnings(\"unchecked\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())");
+        writer.emitEmptyLine();
+        emitMediatorSwitch(new ProxySwitchStatement() {
+            @Override
+            public void emitStatement(int i, JavaWriter writer) throws IOException {
+                writer.emitStatement("%s.insert(realm, (%s) object, cache)", qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
+            }
+        }, writer, false);
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitInsertOrUpdateObjectToRealmMethod(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "void",
+                "insertOrUpdate",
+                EnumSet.of(Modifier.PUBLIC),
+                "Realm", "realm", "RealmModel", "obj", "Map<RealmModel, Long>", "cache");
+        writer.emitSingleLineComment("This cast is correct because obj is either");
+        writer.emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject");
+        writer.emitStatement("@SuppressWarnings(\"unchecked\") Class<RealmModel> clazz = (Class<RealmModel>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass())");
+        writer.emitEmptyLine();
+        emitMediatorSwitch(new ProxySwitchStatement() {
+            @Override
+            public void emitStatement(int i, JavaWriter writer) throws IOException {
+                writer.emitStatement("%s.insertOrUpdate(realm, (%s) obj, cache)", qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
+            }
+        }, writer, false);
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitInsertOrUpdateListToRealmMethod(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "void",
+                "insertOrUpdate",
+                EnumSet.of(Modifier.PUBLIC),
+                "Realm", "realm", "Collection<? extends RealmModel>", "objects");
+
+        writer.emitStatement("Iterator<? extends RealmModel> iterator = objects.iterator()");
+        writer.emitStatement("RealmModel object = null");
+        writer.emitStatement("Map<RealmModel, Long> cache = new IdentityHashMap<RealmModel, Long>(objects.size())");
+
+        writer.beginControlFlow("if (iterator.hasNext())")
+                .emitSingleLineComment(" access the first element to figure out the clazz for the routing below")
+                .emitStatement("object = iterator.next()")
+                .emitSingleLineComment("This cast is correct because obj is either")
+                .emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject")
+                .emitStatement("@SuppressWarnings(\"unchecked\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())")
+                .emitEmptyLine();
+
+        emitMediatorSwitch(new ProxySwitchStatement() {
+            @Override
+            public void emitStatement(int i, JavaWriter writer) throws IOException {
+                writer.emitStatement("%s.insertOrUpdate(realm, (%s) object, cache)", qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
+            }
+        }, writer, false);
+
+        writer.beginControlFlow("if (iterator.hasNext())");
+        emitMediatorSwitch(new ProxySwitchStatement() {
+            @Override
+            public void emitStatement(int i, JavaWriter writer) throws IOException {
+                writer.emitStatement("%s.insertOrUpdate(realm, iterator, cache)", qualifiedProxyClasses.get(i));
+            }
+        }, writer, false);
+        writer.endControlFlow();
+        writer.endControlFlow();
+
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitInsertListToRealmMethod(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
+        writer.beginMethod(
+                "void",
+                "insert",
+                EnumSet.of(Modifier.PUBLIC),
+                "Realm", "realm", "Collection<? extends RealmModel>", "objects");
+
+        writer.emitStatement("Iterator<? extends RealmModel> iterator = objects.iterator()");
+        writer.emitStatement("RealmModel object = null");
+        writer.emitStatement("Map<RealmModel, Long> cache = new IdentityHashMap<RealmModel, Long>(objects.size())");
+
+        writer.beginControlFlow("if (iterator.hasNext())")
+                .emitSingleLineComment(" access the first element to figure out the clazz for the routing below")
+                .emitStatement("object = iterator.next()")
+                .emitSingleLineComment("This cast is correct because obj is either")
+                .emitSingleLineComment("generated by RealmProxy or the original type extending directly from RealmObject")
+                .emitStatement("@SuppressWarnings(\"unchecked\") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass())")
+                .emitEmptyLine();
+
+        emitMediatorSwitch(new ProxySwitchStatement() {
+            @Override
+            public void emitStatement(int i, JavaWriter writer) throws IOException {
+                writer.emitStatement("%s.insert(realm, (%s) object, cache)", qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
             }
         }, writer, false);
+
+        writer.beginControlFlow("if (iterator.hasNext())");
+        emitMediatorSwitch(new ProxySwitchStatement() {
+            @Override
+            public void emitStatement(int i, JavaWriter writer) throws IOException {
+                writer.emitStatement("%s.insert(realm, iterator, cache)", qualifiedProxyClasses.get(i));
+            }
+        }, writer, false);
+        writer.endControlFlow();
+        writer.endControlFlow();
+
         writer.endMethod();
         writer.emitEmptyLine();
     }
@@ -252,7 +394,7 @@ private void emitCreteOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcept
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return clazz.cast(%s.createOrUpdateUsingJsonObject(realm, json, update))", proxyClasses.get(i));
+                writer.emitStatement("return clazz.cast(%s.createOrUpdateUsingJsonObject(realm, json, update))", qualifiedProxyClasses.get(i));
             }
         }, writer);
         writer.endMethod();
@@ -271,7 +413,7 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
         emitMediatorSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return clazz.cast(%s.createUsingJsonStream(realm, reader))", proxyClasses.get(i));
+                writer.emitStatement("return clazz.cast(%s.createUsingJsonStream(realm, reader))", qualifiedProxyClasses.get(i));
             }
         }, writer);
         writer.endMethod();
@@ -294,7 +436,7 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
                 writer.emitStatement("return clazz.cast(%s.createDetachedCopy((%s) realmObject, 0, maxDepth, cache))",
-                        proxyClasses.get(i), simpleModelClasses.get(i));
+                        qualifiedProxyClasses.get(i), qualifiedModelClasses.get(i));
             }
         }, writer, false);
         writer.endMethod();
@@ -314,13 +456,13 @@ private void emitMediatorSwitch(ProxySwitchStatement statement, JavaWriter write
             writer.emitStatement("checkClass(clazz)");
             writer.emitEmptyLine();
         }
-        if (simpleModelClasses.size() == 0) {
+        if (qualifiedModelClasses.size() == 0) {
             writer.emitStatement("throw getMissingProxyClassException(clazz)");
         } else {
-            writer.beginControlFlow("if (clazz.equals(%s.class))", simpleModelClasses.get(0));
+            writer.beginControlFlow("if (clazz.equals(%s.class))", qualifiedModelClasses.get(0));
             statement.emitStatement(0, writer);
-            for (int i = 1; i < simpleModelClasses.size(); i++) {
-                writer.nextControlFlow("else if (clazz.equals(%s.class))", simpleModelClasses.get(i));
+            for (int i = 1; i < qualifiedModelClasses.size(); i++) {
+                writer.nextControlFlow("else if (clazz.equals(%s.class))", qualifiedModelClasses.get(i));
                 statement.emitStatement(i, writer);
             }
             writer.nextControlFlow("else");
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
index 8f0dd71b41..9ed30c70eb 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
@@ -50,7 +50,7 @@ public static String lowerFirstChar(String input) {
 
     public static String getProxyClassSimpleName(VariableElement field) {
         if (typeUtils.isAssignable(field.asType(), realmList)) {
-            return getProxyClassName(getGenericType(field));
+            return getProxyClassName(getGenericTypeSimpleName(field));
         } else {
             return getProxyClassName(getFieldTypeSimpleName(field));
         }
@@ -156,37 +156,48 @@ public static boolean isRealmModel(VariableElement field) {
     }
 
 
+    /**
+     * @return the qualified type name for a field.
+     */
+    public static String getFieldTypeQualifiedName(VariableElement field) {
+        return field.asType().toString();
+    }
+
     /**
      * @return the simple type name for a field.
      */
     public static String getFieldTypeSimpleName(VariableElement field) {
-        String fieldTypeCanonicalName = field.asType().toString();
-        String fieldTypeName;
-        if (fieldTypeCanonicalName.contains(".")) {
-            fieldTypeName = fieldTypeCanonicalName.substring(fieldTypeCanonicalName.lastIndexOf('.') + 1);
-        } else {
-            fieldTypeName = fieldTypeCanonicalName;
+        String fieldTypeQualifiedName = getFieldTypeQualifiedName(field);
+        if (!fieldTypeQualifiedName.contains(".")) {
+            return fieldTypeQualifiedName;
         }
-        return fieldTypeName;
+        return fieldTypeQualifiedName.substring(fieldTypeQualifiedName.lastIndexOf('.') + 1);
     }
 
     /**
      * @return the generic type for Lists of the form {@code List<type>}
      */
-    public static String getGenericType(VariableElement field) {
+    public static String getGenericTypeQualifiedName(VariableElement field) {
         TypeMirror fieldType = field.asType();
         List<? extends TypeMirror> typeArguments = ((DeclaredType) fieldType).getTypeArguments();
         if (typeArguments.size() == 0) {
             return null;
         }
-        String genericCanonicalType = (String) typeArguments.get(0).toString();
-        String genericType;
-        if (genericCanonicalType.contains(".")) {
-            genericType = genericCanonicalType.substring(genericCanonicalType.lastIndexOf('.') + 1);
-        } else {
-            genericType = genericCanonicalType;
+        return typeArguments.get(0).toString();
+    }
+
+    /**
+     * @return the generic type for Lists of the form {@code List<type>}
+     */
+    public static String getGenericTypeSimpleName(VariableElement field) {
+        final String genericTypeName = getGenericTypeQualifiedName(field);
+        if (genericTypeName == null) {
+            return null;
+        }
+        if (!genericTypeName.contains(".")) {
+            return genericTypeName;
         }
-        return genericType;
+        return genericTypeName.substring(genericTypeName.lastIndexOf('.') + 1);
     }
 
     /**
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index a9645b0ef2..17697142ad 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -1,82 +1,96 @@
 package io.realm;
 
 
+import android.annotation.TargetApi;
+import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
-import io.realm.RealmFieldType;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.Row;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
+import io.realm.log.RealmLog;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.Future;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
-import some.test.AllTypes;
 
-public class AllTypesRealmProxy extends AllTypes
+public class AllTypesRealmProxy extends some.test.AllTypes
         implements RealmObjectProxy, AllTypesRealmProxyInterface {
 
-    static final class AllTypesColumnInfo extends ColumnInfo {
+    static final class AllTypesColumnInfo extends ColumnInfo
+            implements Cloneable {
 
-        public final long columnStringIndex;
-        public final long columnLongIndex;
-        public final long columnFloatIndex;
-        public final long columnDoubleIndex;
-        public final long columnBooleanIndex;
-        public final long columnDateIndex;
-        public final long columnBinaryIndex;
-        public final long columnObjectIndex;
-        public final long columnRealmListIndex;
+        public long columnStringIndex;
+        public long columnLongIndex;
+        public long columnFloatIndex;
+        public long columnDoubleIndex;
+        public long columnBooleanIndex;
+        public long columnDateIndex;
+        public long columnBinaryIndex;
+        public long columnObjectIndex;
+        public long columnRealmListIndex;
 
         AllTypesColumnInfo(String path, Table table) {
             final Map<String, Long> indicesMap = new HashMap<String, Long>(9);
             this.columnStringIndex = getValidColumnIndex(path, table, "AllTypes", "columnString");
             indicesMap.put("columnString", this.columnStringIndex);
-
             this.columnLongIndex = getValidColumnIndex(path, table, "AllTypes", "columnLong");
             indicesMap.put("columnLong", this.columnLongIndex);
-
             this.columnFloatIndex = getValidColumnIndex(path, table, "AllTypes", "columnFloat");
             indicesMap.put("columnFloat", this.columnFloatIndex);
-
             this.columnDoubleIndex = getValidColumnIndex(path, table, "AllTypes", "columnDouble");
             indicesMap.put("columnDouble", this.columnDoubleIndex);
-
             this.columnBooleanIndex = getValidColumnIndex(path, table, "AllTypes", "columnBoolean");
             indicesMap.put("columnBoolean", this.columnBooleanIndex);
-
             this.columnDateIndex = getValidColumnIndex(path, table, "AllTypes", "columnDate");
             indicesMap.put("columnDate", this.columnDateIndex);
-
             this.columnBinaryIndex = getValidColumnIndex(path, table, "AllTypes", "columnBinary");
             indicesMap.put("columnBinary", this.columnBinaryIndex);
-
             this.columnObjectIndex = getValidColumnIndex(path, table, "AllTypes", "columnObject");
             indicesMap.put("columnObject", this.columnObjectIndex);
-
             this.columnRealmListIndex = getValidColumnIndex(path, table, "AllTypes", "columnRealmList");
             indicesMap.put("columnRealmList", this.columnRealmListIndex);
 
             setIndicesMap(indicesMap);
         }
-    }
 
-    private final AllTypesColumnInfo columnInfo;
-    private final ProxyState proxyState;
-    private RealmList<AllTypes> columnRealmListRealmList;
+        @Override
+        public final void copyColumnInfoFrom(ColumnInfo other) {
+            final AllTypesColumnInfo otherInfo = (AllTypesColumnInfo) other;
+            this.columnStringIndex = otherInfo.columnStringIndex;
+            this.columnLongIndex = otherInfo.columnLongIndex;
+            this.columnFloatIndex = otherInfo.columnFloatIndex;
+            this.columnDoubleIndex = otherInfo.columnDoubleIndex;
+            this.columnBooleanIndex = otherInfo.columnBooleanIndex;
+            this.columnDateIndex = otherInfo.columnDateIndex;
+            this.columnBinaryIndex = otherInfo.columnBinaryIndex;
+            this.columnObjectIndex = otherInfo.columnObjectIndex;
+            this.columnRealmListIndex = otherInfo.columnRealmListIndex;
+
+            setIndicesMap(otherInfo.getIndicesMap());
+        }
+
+        @Override
+        public final AllTypesColumnInfo clone() {
+            return (AllTypesColumnInfo) super.clone();
+        }
+
+    }
+    private AllTypesColumnInfo columnInfo;
+    private ProxyState proxyState;
+    private RealmList<some.test.AllTypes> columnRealmListRealmList;
     private static final List<String> FIELD_NAMES;
     static {
         List<String> fieldNames = new ArrayList<String>();
@@ -92,113 +106,254 @@
         FIELD_NAMES = Collections.unmodifiableList(fieldNames);
     }
 
-    AllTypesRealmProxy(ColumnInfo columnInfo) {
-        this.columnInfo = (AllTypesColumnInfo) columnInfo;
-        this.proxyState = new ProxyState(AllTypes.class, this);
+    AllTypesRealmProxy() {
+        if (proxyState == null) {
+            injectObjectContext();
+        }
+        proxyState.setConstructionFinished();
+    }
+
+    private void injectObjectContext() {
+        final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
+        this.columnInfo = (AllTypesColumnInfo) context.getColumnInfo();
+        this.proxyState = new ProxyState(some.test.AllTypes.class, this);
+        proxyState.setRealm$realm(context.getRealm());
+        proxyState.setRow$realm(context.getRow());
+        proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
+        proxyState.setExcludeFields$realm(context.getExcludeFields());
     }
 
     @SuppressWarnings("cast")
     public String realmGet$columnString() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.columnStringIndex);
     }
 
     public void realmSet$columnString(String value) {
-        proxyState.getRealm$realm().checkIfValid();
-        if (value == null) {
-            proxyState.getRow$realm().setNull(columnInfo.columnStringIndex);
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            // default value of the primary key is always ignored.
             return;
         }
-        proxyState.getRow$realm().setString(columnInfo.columnStringIndex, value);
+
+        proxyState.getRealm$realm().checkIfValid();
+        throw new io.realm.exceptions.RealmException("Primary key field 'columnString' cannot be changed after object was created.");
     }
 
     @SuppressWarnings("cast")
     public long realmGet$columnLong() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (long) proxyState.getRow$realm().getLong(columnInfo.columnLongIndex);
     }
 
     public void realmSet$columnLong(long value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         proxyState.getRow$realm().setLong(columnInfo.columnLongIndex, value);
     }
 
     @SuppressWarnings("cast")
     public float realmGet$columnFloat() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (float) proxyState.getRow$realm().getFloat(columnInfo.columnFloatIndex);
     }
 
     public void realmSet$columnFloat(float value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         proxyState.getRow$realm().setFloat(columnInfo.columnFloatIndex, value);
     }
 
     @SuppressWarnings("cast")
     public double realmGet$columnDouble() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (double) proxyState.getRow$realm().getDouble(columnInfo.columnDoubleIndex);
     }
 
     public void realmSet$columnDouble(double value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         proxyState.getRow$realm().setDouble(columnInfo.columnDoubleIndex, value);
     }
 
     @SuppressWarnings("cast")
     public boolean realmGet$columnBoolean() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.columnBooleanIndex);
     }
 
     public void realmSet$columnBoolean(boolean value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         proxyState.getRow$realm().setBoolean(columnInfo.columnBooleanIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Date realmGet$columnDate() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (java.util.Date) proxyState.getRow$realm().getDate(columnInfo.columnDateIndex);
     }
 
     public void realmSet$columnDate(Date value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field columnDate to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'columnDate' to null.");
         }
         proxyState.getRow$realm().setDate(columnInfo.columnDateIndex, value);
     }
 
     @SuppressWarnings("cast")
     public byte[] realmGet$columnBinary() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (byte[]) proxyState.getRow$realm().getBinaryByteArray(columnInfo.columnBinaryIndex);
     }
 
     public void realmSet$columnBinary(byte[] value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field columnBinary to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'columnBinary' to null.");
         }
         proxyState.getRow$realm().setBinaryByteArray(columnInfo.columnBinaryIndex, value);
     }
 
-    public AllTypes realmGet$columnObject() {
+    public some.test.AllTypes realmGet$columnObject() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNullLink(columnInfo.columnObjectIndex)) {
             return null;
         }
-        return proxyState.getRealm$realm().get(some.test.AllTypes.class, proxyState.getRow$realm().getLink(columnInfo.columnObjectIndex));
+        return proxyState.getRealm$realm().get(some.test.AllTypes.class, proxyState.getRow$realm().getLink(columnInfo.columnObjectIndex), false, Collections.<String>emptyList());
     }
 
-    public void realmSet$columnObject(AllTypes value) {
+    public void realmSet$columnObject(some.test.AllTypes value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnObject")) {
+                return;
+            }
+            if (value != null && !RealmObject.isManaged(value)) {
+                value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value);
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().nullifyLink(columnInfo.columnObjectIndex);
             return;
         }
-        if (!RealmObject.isValid(value)) {
+        if (!(RealmObject.isManaged(value) && RealmObject.isValid(value))) {
             throw new IllegalArgumentException("'value' is not a valid managed object.");
         }
         if (((RealmObjectProxy)value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
@@ -207,27 +362,58 @@
         proxyState.getRow$realm().setLink(columnInfo.columnObjectIndex, ((RealmObjectProxy)value).realmGet$proxyState().getRow$realm().getIndex());
     }
 
-    public RealmList<AllTypes> realmGet$columnRealmList() {
+    public RealmList<some.test.AllTypes> realmGet$columnRealmList() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         // use the cached value if available
         if (columnRealmListRealmList != null) {
             return columnRealmListRealmList;
         } else {
             LinkView linkView = proxyState.getRow$realm().getLinkList(columnInfo.columnRealmListIndex);
-            columnRealmListRealmList = new RealmList<AllTypes>(AllTypes.class, linkView, proxyState.getRealm$realm());
+            columnRealmListRealmList = new RealmList<some.test.AllTypes>(some.test.AllTypes.class, linkView, proxyState.getRealm$realm());
             return columnRealmListRealmList;
         }
     }
 
-    public void realmSet$columnRealmList(RealmList<AllTypes> value) {
+    public void realmSet$columnRealmList(RealmList<some.test.AllTypes> value) {
         proxyState.getRealm$realm().checkIfValid();
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnRealmList")) {
+                return;
+            }
+            if (value != null && !value.isManaged()) {
+                final Realm realm = (Realm) proxyState.getRealm$realm();
+                final RealmList<some.test.AllTypes> original = value;
+                value = new RealmList<some.test.AllTypes>();
+                for (some.test.AllTypes item : original) {
+                    if (item == null || RealmObject.isManaged(item)) {
+                        value.add(item);
+                    } else {
+                        value.add(realm.copyToRealm(item));
+                    }
+                }
+            }
+        }
+
         LinkView links = proxyState.getRow$realm().getLinkList(columnInfo.columnRealmListIndex);
         links.clear();
         if (value == null) {
             return;
         }
         for (RealmModel linkedObject : (RealmList<? extends RealmModel>) value) {
-            if (!RealmObject.isValid(linkedObject)) {
+            if (!(RealmObject.isManaged(linkedObject) && RealmObject.isValid(linkedObject))) {
                 throw new IllegalArgumentException("Each element of 'value' must be a valid managed object.");
             }
             if (((RealmObjectProxy)linkedObject).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
@@ -237,9 +423,9 @@
         }
     }
 
-    public static Table initTable(ImplicitTransaction transaction) {
-        if (!transaction.hasTable("class_AllTypes")) {
-            Table table = transaction.getTable("class_AllTypes");
+    public static Table initTable(SharedRealm sharedRealm) {
+        if (!sharedRealm.hasTable("class_AllTypes")) {
+            Table table = sharedRealm.getTable("class_AllTypes");
             table.addColumn(RealmFieldType.STRING, "columnString", Table.NULLABLE);
             table.addColumn(RealmFieldType.INTEGER, "columnLong", Table.NOT_NULLABLE);
             table.addColumn(RealmFieldType.FLOAT, "columnFloat", Table.NOT_NULLABLE);
@@ -247,132 +433,140 @@ public static Table initTable(ImplicitTransaction transaction) {
             table.addColumn(RealmFieldType.BOOLEAN, "columnBoolean", Table.NOT_NULLABLE);
             table.addColumn(RealmFieldType.DATE, "columnDate", Table.NOT_NULLABLE);
             table.addColumn(RealmFieldType.BINARY, "columnBinary", Table.NOT_NULLABLE);
-            if (!transaction.hasTable("class_AllTypes")) {
-                AllTypesRealmProxy.initTable(transaction);
+            if (!sharedRealm.hasTable("class_AllTypes")) {
+                AllTypesRealmProxy.initTable(sharedRealm);
             }
-            table.addColumnLink(RealmFieldType.OBJECT, "columnObject", transaction.getTable("class_AllTypes"));
-            if (!transaction.hasTable("class_AllTypes")) {
-                AllTypesRealmProxy.initTable(transaction);
+            table.addColumnLink(RealmFieldType.OBJECT, "columnObject", sharedRealm.getTable("class_AllTypes"));
+            if (!sharedRealm.hasTable("class_AllTypes")) {
+                AllTypesRealmProxy.initTable(sharedRealm);
             }
-            table.addColumnLink(RealmFieldType.LIST, "columnRealmList", transaction.getTable("class_AllTypes"));
+            table.addColumnLink(RealmFieldType.LIST, "columnRealmList", sharedRealm.getTable("class_AllTypes"));
             table.addSearchIndex(table.getColumnIndex("columnString"));
             table.setPrimaryKey("columnString");
             return table;
         }
-        return transaction.getTable("class_AllTypes");
+        return sharedRealm.getTable("class_AllTypes");
     }
 
-    public static AllTypesColumnInfo validateTable(ImplicitTransaction transaction) {
-        if (transaction.hasTable("class_AllTypes")) {
-            Table table = transaction.getTable("class_AllTypes");
-            if (table.getColumnCount() != 9) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field count does not match - expected 9 but was " + table.getColumnCount());
+    public static AllTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
+        if (sharedRealm.hasTable("class_AllTypes")) {
+            Table table = sharedRealm.getTable("class_AllTypes");
+            final long columnCount = table.getColumnCount();
+            if (columnCount != 9) {
+                if (columnCount < 9) {
+                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 9 but was " + columnCount);
+                }
+                if (allowExtraColumns) {
+                    RealmLog.debug("Field count is more than expected - expected 9 but was %1$d", columnCount);
+                } else {
+                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 9 but was " + columnCount);
+                }
             }
             Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
             for (long i = 0; i < 9; i++) {
                 columnTypes.put(table.getColumnName(i), table.getColumnType(i));
             }
 
-            final AllTypesColumnInfo columnInfo = new AllTypesColumnInfo(transaction.getPath(), table);
+            final AllTypesColumnInfo columnInfo = new AllTypesColumnInfo(sharedRealm.getPath(), table);
 
             if (!columnTypes.containsKey("columnString")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnString' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnString' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("columnString") != RealmFieldType.STRING) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'String' for field 'columnString' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'columnString' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.columnStringIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"@PrimaryKey field 'columnString' does not support null values in the existing Realm file. Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(),"@PrimaryKey field 'columnString' does not support null values in the existing Realm file. Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.");
             }
             if (table.getPrimaryKey() != table.getColumnIndex("columnString")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Primary key not defined for field 'columnString' in existing Realm file. Add @PrimaryKey.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary key not defined for field 'columnString' in existing Realm file. Add @PrimaryKey.");
             }
             if (!table.hasSearchIndex(table.getColumnIndex("columnString"))) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Index not defined for field 'columnString' in existing Realm file. Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Index not defined for field 'columnString' in existing Realm file. Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().");
             }
             if (!columnTypes.containsKey("columnLong")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnLong' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnLong' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("columnLong") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'long' for field 'columnLong' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'long' for field 'columnLong' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.columnLongIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnLong' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnLong' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnLong' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnLong' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("columnFloat")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnFloat' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnFloat' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("columnFloat") != RealmFieldType.FLOAT) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'float' for field 'columnFloat' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'float' for field 'columnFloat' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.columnFloatIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnFloat' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnFloat' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnFloat' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnFloat' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("columnDouble")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnDouble' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnDouble' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("columnDouble") != RealmFieldType.DOUBLE) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'double' for field 'columnDouble' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'double' for field 'columnDouble' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.columnDoubleIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnDouble' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnDouble' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDouble' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnDouble' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("columnBoolean")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnBoolean' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnBoolean' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("columnBoolean") != RealmFieldType.BOOLEAN) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'columnBoolean' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'columnBoolean' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.columnBooleanIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnBoolean' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnBoolean' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("columnDate")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnDate' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnDate' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("columnDate") != RealmFieldType.DATE) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Date' for field 'columnDate' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Date' for field 'columnDate' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.columnDateIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnDate' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnDate' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDate' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnDate' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("columnBinary")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnBinary' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnBinary' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("columnBinary") != RealmFieldType.BINARY) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'byte[]' for field 'columnBinary' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'byte[]' for field 'columnBinary' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.columnBinaryIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'columnBinary' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnBinary' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBinary' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnBinary' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("columnObject")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnObject' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnObject' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("columnObject") != RealmFieldType.OBJECT) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'AllTypes' for field 'columnObject'");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'AllTypes' for field 'columnObject'");
             }
-            if (!transaction.hasTable("class_AllTypes")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing class 'class_AllTypes' for field 'columnObject'");
+            if (!sharedRealm.hasTable("class_AllTypes")) {
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnObject'");
             }
-            Table table_7 = transaction.getTable("class_AllTypes");
+            Table table_7 = sharedRealm.getTable("class_AllTypes");
             if (!table.getLinkTarget(columnInfo.columnObjectIndex).hasSameSchema(table_7)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid RealmObject for field 'columnObject': '" + table.getLinkTarget(columnInfo.columnObjectIndex).getName() + "' expected - was '" + table_7.getName() + "'");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmObject for field 'columnObject': '" + table.getLinkTarget(columnInfo.columnObjectIndex).getName() + "' expected - was '" + table_7.getName() + "'");
             }
             if (!columnTypes.containsKey("columnRealmList")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'columnRealmList'");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnRealmList'");
             }
             if (columnTypes.get("columnRealmList") != RealmFieldType.LIST) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'AllTypes' for field 'columnRealmList'");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'AllTypes' for field 'columnRealmList'");
             }
-            if (!transaction.hasTable("class_AllTypes")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing class 'class_AllTypes' for field 'columnRealmList'");
+            if (!sharedRealm.hasTable("class_AllTypes")) {
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnRealmList'");
             }
-            Table table_8 = transaction.getTable("class_AllTypes");
+            Table table_8 = sharedRealm.getTable("class_AllTypes");
             if (!table.getLinkTarget(columnInfo.columnRealmListIndex).hasSameSchema(table_8)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid RealmList type for field 'columnRealmList': '" + table.getLinkTarget(columnInfo.columnRealmListIndex).getName() + "' expected - was '" + table_8.getName() + "'");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmList type for field 'columnRealmList': '" + table.getLinkTarget(columnInfo.columnRealmListIndex).getName() + "' expected - was '" + table_8.getName() + "'");
             }
             return columnInfo;
         } else {
-            throw new RealmMigrationNeededException(transaction.getPath(), "The AllTypes class is missing from the schema for this Realm.");
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'AllTypes' class is missing from the schema for this Realm.");
         }
     }
 
@@ -385,11 +579,12 @@ public static String getTableName() {
     }
 
     @SuppressWarnings("cast")
-    public static AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
+    public static some.test.AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
-        AllTypes obj = null;
+        final List<String> excludeFields = new ArrayList<String>(2);
+        some.test.AllTypes obj = null;
         if (update) {
-            Table table = realm.getTable(AllTypes.class);
+            Table table = realm.getTable(some.test.AllTypes.class);
             long pkColumnIndex = table.getPrimaryKey();
             long rowIndex = TableOrView.NO_MATCH;
             if (json.isNull("columnString")) {
@@ -398,53 +593,56 @@ public static AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject jso
                 rowIndex = table.findFirstString(pkColumnIndex, json.getString("columnString"));
             }
             if (rowIndex != TableOrView.NO_MATCH) {
-                obj = new AllTypesRealmProxy(realm.schema.getColumnInfo(AllTypes.class));
-                ((RealmObjectProxy)obj).realmGet$proxyState().setRealm$realm(realm);
-                ((RealmObjectProxy)obj).realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex));
+                final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
+                try {
+                    objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.schema.getColumnInfo(some.test.AllTypes.class), false, Collections.<String> emptyList());
+                    obj = new io.realm.AllTypesRealmProxy();
+                } finally {
+                    objectContext.clear();
+                }
             }
         }
         if (obj == null) {
+            if (json.has("columnObject")) {
+                excludeFields.add("columnObject");
+            }
+            if (json.has("columnRealmList")) {
+                excludeFields.add("columnRealmList");
+            }
             if (json.has("columnString")) {
                 if (json.isNull("columnString")) {
-                    obj = (AllTypesRealmProxy) realm.createObject(AllTypes.class, null);
+                    obj = (io.realm.AllTypesRealmProxy) realm.createObjectInternal(some.test.AllTypes.class, null, true, excludeFields);
                 } else {
-                    obj = (AllTypesRealmProxy) realm.createObject(AllTypes.class, json.getString("columnString"));
+                    obj = (io.realm.AllTypesRealmProxy) realm.createObjectInternal(some.test.AllTypes.class, json.getString("columnString"), true, excludeFields);
                 }
             } else {
-                obj = (AllTypesRealmProxy) realm.createObject(AllTypes.class);
-            }
-        }
-        if (json.has("columnString")) {
-            if (json.isNull("columnString")) {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnString(null);
-            } else {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnString((String) json.getString("columnString"));
+                throw new IllegalArgumentException("JSON object doesn't have the primary key field 'columnString'.");
             }
         }
         if (json.has("columnLong")) {
             if (json.isNull("columnLong")) {
-                throw new IllegalArgumentException("Trying to set non-nullable field columnLong to null.");
+                throw new IllegalArgumentException("Trying to set non-nullable field 'columnLong' to null.");
             } else {
                 ((AllTypesRealmProxyInterface) obj).realmSet$columnLong((long) json.getLong("columnLong"));
             }
         }
         if (json.has("columnFloat")) {
             if (json.isNull("columnFloat")) {
-                throw new IllegalArgumentException("Trying to set non-nullable field columnFloat to null.");
+                throw new IllegalArgumentException("Trying to set non-nullable field 'columnFloat' to null.");
             } else {
                 ((AllTypesRealmProxyInterface) obj).realmSet$columnFloat((float) json.getDouble("columnFloat"));
             }
         }
         if (json.has("columnDouble")) {
             if (json.isNull("columnDouble")) {
-                throw new IllegalArgumentException("Trying to set non-nullable field columnDouble to null.");
+                throw new IllegalArgumentException("Trying to set non-nullable field 'columnDouble' to null.");
             } else {
                 ((AllTypesRealmProxyInterface) obj).realmSet$columnDouble((double) json.getDouble("columnDouble"));
             }
         }
         if (json.has("columnBoolean")) {
             if (json.isNull("columnBoolean")) {
-                throw new IllegalArgumentException("Trying to set non-nullable field columnBoolean to null.");
+                throw new IllegalArgumentException("Trying to set non-nullable field 'columnBoolean' to null.");
             } else {
                 ((AllTypesRealmProxyInterface) obj).realmSet$columnBoolean((boolean) json.getBoolean("columnBoolean"));
             }
@@ -492,9 +690,11 @@ public static AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject jso
     }
 
     @SuppressWarnings("cast")
-    public static AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public static some.test.AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        AllTypes obj = realm.createObject(AllTypes.class);
+        boolean jsonHasPrimaryKey = false;
+        some.test.AllTypes obj = new some.test.AllTypes();
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
@@ -505,31 +705,32 @@ public static AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
                 } else {
                     ((AllTypesRealmProxyInterface) obj).realmSet$columnString((String) reader.nextString());
                 }
+                jsonHasPrimaryKey = true;
             } else if (name.equals("columnLong")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    throw new IllegalArgumentException("Trying to set non-nullable field columnLong to null.");
+                    throw new IllegalArgumentException("Trying to set non-nullable field 'columnLong' to null.");
                 } else {
                     ((AllTypesRealmProxyInterface) obj).realmSet$columnLong((long) reader.nextLong());
                 }
             } else if (name.equals("columnFloat")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    throw new IllegalArgumentException("Trying to set non-nullable field columnFloat to null.");
+                    throw new IllegalArgumentException("Trying to set non-nullable field 'columnFloat' to null.");
                 } else {
                     ((AllTypesRealmProxyInterface) obj).realmSet$columnFloat((float) reader.nextDouble());
                 }
             } else if (name.equals("columnDouble")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    throw new IllegalArgumentException("Trying to set non-nullable field columnDouble to null.");
+                    throw new IllegalArgumentException("Trying to set non-nullable field 'columnDouble' to null.");
                 } else {
                     ((AllTypesRealmProxyInterface) obj).realmSet$columnDouble((double) reader.nextDouble());
                 }
             } else if (name.equals("columnBoolean")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    throw new IllegalArgumentException("Trying to set non-nullable field columnBoolean to null.");
+                    throw new IllegalArgumentException("Trying to set non-nullable field 'columnBoolean' to null.");
                 } else {
                     ((AllTypesRealmProxyInterface) obj).realmSet$columnBoolean((boolean) reader.nextBoolean());
                 }
@@ -565,6 +766,7 @@ public static AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
                     reader.skipValue();
                     ((AllTypesRealmProxyInterface) obj).realmSet$columnRealmList(null);
                 } else {
+                    ((AllTypesRealmProxyInterface) obj).realmSet$columnRealmList(new RealmList<some.test.AllTypes>());
                     reader.beginArray();
                     while (reader.hasNext()) {
                         some.test.AllTypes item = AllTypesRealmProxy.createUsingJsonStream(realm, reader);
@@ -577,101 +779,377 @@ public static AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
             }
         }
         reader.endObject();
+        if (!jsonHasPrimaryKey) {
+            throw new IllegalArgumentException("JSON object doesn't have the primary key field 'columnString'.");
+        }
+        obj = realm.copyToRealm(obj);
         return obj;
     }
 
-    public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+    public static some.test.AllTypes copyOrUpdate(Realm realm, some.test.AllTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
             throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
         }
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
             return object;
         }
-        AllTypes realmObject = null;
-        boolean canUpdate = update;
-        if (canUpdate) {
-            Table table = realm.getTable(AllTypes.class);
-            long pkColumnIndex = table.getPrimaryKey();
-            String value = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
-            long rowIndex = TableOrView.NO_MATCH;
-            if (value == null) {
-                rowIndex = table.findFirstNull(pkColumnIndex);
+        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
+        RealmObjectProxy cachedRealmObject = cache.get(object);
+        if (cachedRealmObject != null) {
+            return (some.test.AllTypes) cachedRealmObject;
+        } else {
+            some.test.AllTypes realmObject = null;
+            boolean canUpdate = update;
+            if (canUpdate) {
+                Table table = realm.getTable(some.test.AllTypes.class);
+                long pkColumnIndex = table.getPrimaryKey();
+                String value = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
+                long rowIndex = TableOrView.NO_MATCH;
+                if (value == null) {
+                    rowIndex = table.findFirstNull(pkColumnIndex);
+                } else {
+                    rowIndex = table.findFirstString(pkColumnIndex, value);
+                }
+                if (rowIndex != TableOrView.NO_MATCH) {
+                    try {
+                        objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.schema.getColumnInfo(some.test.AllTypes.class), false, Collections.<String> emptyList());
+                        realmObject = new io.realm.AllTypesRealmProxy();
+                        cache.put(object, (RealmObjectProxy) realmObject);
+                    } finally {
+                        objectContext.clear();
+                    }
+                } else {
+                    canUpdate = false;
+                }
+            }
+
+            if (canUpdate) {
+                return update(realm, realmObject, object, cache);
             } else {
-                rowIndex = table.findFirstString(pkColumnIndex, value);
+                return copy(realm, object, update, cache);
             }
-            if (rowIndex != TableOrView.NO_MATCH) {
-                realmObject = new AllTypesRealmProxy(realm.schema.getColumnInfo(AllTypes.class));
-                ((RealmObjectProxy)realmObject).realmGet$proxyState().setRealm$realm(realm);
-                ((RealmObjectProxy)realmObject).realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex));
-                cache.put(object, (RealmObjectProxy) realmObject);
+        }
+    }
+
+    public static some.test.AllTypes copy(Realm realm, some.test.AllTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+        RealmObjectProxy cachedRealmObject = cache.get(newObject);
+        if (cachedRealmObject != null) {
+            return (some.test.AllTypes) cachedRealmObject;
+        } else {
+            // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
+            some.test.AllTypes realmObject = realm.createObjectInternal(some.test.AllTypes.class, ((AllTypesRealmProxyInterface) newObject).realmGet$columnString(), false, Collections.<String>emptyList());
+            cache.put(newObject, (RealmObjectProxy) realmObject);
+            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnLong(((AllTypesRealmProxyInterface) newObject).realmGet$columnLong());
+            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) newObject).realmGet$columnFloat());
+            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) newObject).realmGet$columnDouble());
+            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBoolean(((AllTypesRealmProxyInterface) newObject).realmGet$columnBoolean());
+            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDate(((AllTypesRealmProxyInterface) newObject).realmGet$columnDate());
+            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBinary(((AllTypesRealmProxyInterface) newObject).realmGet$columnBinary());
+
+            some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) newObject).realmGet$columnObject();
+            if (columnObjectObj != null) {
+                some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
+                if (cachecolumnObject != null) {
+                    ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(cachecolumnObject);
+                } else {
+                    ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, update, cache));
+                }
             } else {
-                canUpdate = false;
+                ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(null);
             }
+
+            RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) newObject).realmGet$columnRealmList();
+            if (columnRealmListList != null) {
+                RealmList<some.test.AllTypes> columnRealmListRealmList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
+                for (int i = 0; i < columnRealmListList.size(); i++) {
+                    some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
+                    some.test.AllTypes cachecolumnRealmList = (some.test.AllTypes) cache.get(columnRealmListItem);
+                    if (cachecolumnRealmList != null) {
+                        columnRealmListRealmList.add(cachecolumnRealmList);
+                    } else {
+                        columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListList.get(i), update, cache));
+                    }
+                }
+            }
+
+            return realmObject;
         }
+    }
 
-        if (canUpdate) {
-            return update(realm, realmObject, object, cache);
+    public static long insert(Realm realm, some.test.AllTypes object, Map<RealmModel,Long> cache) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+            return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
+        }
+        Table table = realm.getTable(some.test.AllTypes.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.schema.getColumnInfo(some.test.AllTypes.class);
+        long pkColumnIndex = table.getPrimaryKey();
+        String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
+        long rowIndex = TableOrView.NO_MATCH;
+        if (primaryKeyValue == null) {
+            rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
         } else {
-            return copy(realm, object, update, cache);
+            rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
+        }
+        if (rowIndex == TableOrView.NO_MATCH) {
+            rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false);
+        } else {
+            Table.throwDuplicatePrimaryKeyException(primaryKeyValue);
+        }
+        cache.put(object, rowIndex);
+        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong());
+        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat());
+        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble());
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean());
+        java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface)object).realmGet$columnDate();
+        if (realmGet$columnDate != null) {
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime());
         }
+        byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface)object).realmGet$columnBinary();
+        if (realmGet$columnBinary != null) {
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary);
+        }
+
+        some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
+        if (columnObjectObj != null) {
+            Long cachecolumnObject = cache.get(columnObjectObj);
+            if (cachecolumnObject == null) {
+                cachecolumnObject = AllTypesRealmProxy.insert(realm, columnObjectObj, cache);
+            }
+            Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject);
+        }
+
+        RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
+        if (columnRealmListList != null) {
+            long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
+            for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
+                Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
+                if (cacheItemIndexcolumnRealmList == null) {
+                    cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insert(realm, columnRealmListItem, cache);
+                }
+                LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
+            }
+            LinkView.nativeClose(columnRealmListNativeLinkViewPtr);
+        }
+
+        return rowIndex;
     }
 
-    public static AllTypes copy(Realm realm, AllTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
-        AllTypes realmObject = realm.createObject(AllTypes.class, ((AllTypesRealmProxyInterface) newObject).realmGet$columnString());
-        cache.put(newObject, (RealmObjectProxy) realmObject);
-        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnString(((AllTypesRealmProxyInterface) newObject).realmGet$columnString());
-        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnLong(((AllTypesRealmProxyInterface) newObject).realmGet$columnLong());
-        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) newObject).realmGet$columnFloat());
-        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) newObject).realmGet$columnDouble());
-        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBoolean(((AllTypesRealmProxyInterface) newObject).realmGet$columnBoolean());
-        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDate(((AllTypesRealmProxyInterface) newObject).realmGet$columnDate());
-        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBinary(((AllTypesRealmProxyInterface) newObject).realmGet$columnBinary());
+    public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.AllTypes.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.schema.getColumnInfo(some.test.AllTypes.class);
+        long pkColumnIndex = table.getPrimaryKey();
+        some.test.AllTypes object = null;
+        while (objects.hasNext()) {
+            object = (some.test.AllTypes) objects.next();
+            if(!cache.containsKey(object)) {
+                if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                    cache.put(object, ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex());
+                    continue;
+                }
+                String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
+                long rowIndex = TableOrView.NO_MATCH;
+                if (primaryKeyValue == null) {
+                    rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
+                } else {
+                    rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
+                }
+                if (rowIndex == TableOrView.NO_MATCH) {
+                    rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false);
+                } else {
+                    Table.throwDuplicatePrimaryKeyException(primaryKeyValue);
+                }
+                cache.put(object, rowIndex);
+                Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong());
+                Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat());
+                Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble());
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean());
+                java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface)object).realmGet$columnDate();
+                if (realmGet$columnDate != null) {
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime());
+                }
+                byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface)object).realmGet$columnBinary();
+                if (realmGet$columnBinary != null) {
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary);
+                }
 
-        some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) newObject).realmGet$columnObject();
+                some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
+                if (columnObjectObj != null) {
+                    Long cachecolumnObject = cache.get(columnObjectObj);
+                    if (cachecolumnObject == null) {
+                        cachecolumnObject = AllTypesRealmProxy.insert(realm, columnObjectObj, cache);
+                    }
+                    table.setLink(columnInfo.columnObjectIndex, rowIndex, cachecolumnObject);
+                }
+
+                RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
+                if (columnRealmListList != null) {
+                    long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
+                    for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
+                        Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
+                        if (cacheItemIndexcolumnRealmList == null) {
+                            cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insert(realm, columnRealmListItem, cache);
+                        }
+                        LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
+                    }
+                    LinkView.nativeClose(columnRealmListNativeLinkViewPtr);
+                }
+
+            }
+        }
+    }
+
+    public static long insertOrUpdate(Realm realm, some.test.AllTypes object, Map<RealmModel,Long> cache) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+            return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
+        }
+        Table table = realm.getTable(some.test.AllTypes.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.schema.getColumnInfo(some.test.AllTypes.class);
+        long pkColumnIndex = table.getPrimaryKey();
+        String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
+        long rowIndex = TableOrView.NO_MATCH;
+        if (primaryKeyValue == null) {
+            rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
+        } else {
+            rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
+        }
+        if (rowIndex == TableOrView.NO_MATCH) {
+            rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false);
+        }
+        cache.put(object, rowIndex);
+        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong());
+        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat());
+        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble());
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean());
+        java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface)object).realmGet$columnDate();
+        if (realmGet$columnDate != null) {
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.columnDateIndex, rowIndex);
+        }
+        byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface)object).realmGet$columnBinary();
+        if (realmGet$columnBinary != null) {
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex);
+        }
+
+        some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
         if (columnObjectObj != null) {
-            some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
-            if (cachecolumnObject != null) {
-                ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(cachecolumnObject);
-            } else {
-                ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, update, cache));
+            Long cachecolumnObject = cache.get(columnObjectObj);
+            if (cachecolumnObject == null) {
+                cachecolumnObject = AllTypesRealmProxy.insertOrUpdate(realm, columnObjectObj, cache);
             }
+            Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject);
         } else {
-            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(null);
+            Table.nativeNullifyLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex);
         }
 
-        RealmList<AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) newObject).realmGet$columnRealmList();
+        long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
+        LinkView.nativeClear(columnRealmListNativeLinkViewPtr);
+        RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
         if (columnRealmListList != null) {
-            RealmList<AllTypes> columnRealmListRealmList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
-            for (int i = 0; i < columnRealmListList.size(); i++) {
-                AllTypes columnRealmListItem = columnRealmListList.get(i);
-                AllTypes cachecolumnRealmList = (AllTypes) cache.get(columnRealmListItem);
-                if (cachecolumnRealmList != null) {
-                    columnRealmListRealmList.add(cachecolumnRealmList);
-                } else {
-                    columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListList.get(i), update, cache));
+            for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
+                Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
+                if (cacheItemIndexcolumnRealmList == null) {
+                    cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insertOrUpdate(realm, columnRealmListItem, cache);
                 }
+                LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
             }
         }
+        LinkView.nativeClose(columnRealmListNativeLinkViewPtr);
 
-        return realmObject;
+        return rowIndex;
     }
 
-    public static AllTypes createDetachedCopy(AllTypes realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
+    public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.AllTypes.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.schema.getColumnInfo(some.test.AllTypes.class);
+        long pkColumnIndex = table.getPrimaryKey();
+        some.test.AllTypes object = null;
+        while (objects.hasNext()) {
+            object = (some.test.AllTypes) objects.next();
+            if(!cache.containsKey(object)) {
+                if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                    cache.put(object, ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex());
+                    continue;
+                }
+                String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
+                long rowIndex = TableOrView.NO_MATCH;
+                if (primaryKeyValue == null) {
+                    rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
+                } else {
+                    rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
+                }
+                if (rowIndex == TableOrView.NO_MATCH) {
+                    rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false);
+                }
+                cache.put(object, rowIndex);
+                Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong());
+                Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat());
+                Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble());
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean());
+                java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface)object).realmGet$columnDate();
+                if (realmGet$columnDate != null) {
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.columnDateIndex, rowIndex);
+                }
+                byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface)object).realmGet$columnBinary();
+                if (realmGet$columnBinary != null) {
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex);
+                }
+
+                some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
+                if (columnObjectObj != null) {
+                    Long cachecolumnObject = cache.get(columnObjectObj);
+                    if (cachecolumnObject == null) {
+                        cachecolumnObject = AllTypesRealmProxy.insertOrUpdate(realm, columnObjectObj, cache);
+                    }
+                    Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject);
+                } else {
+                    Table.nativeNullifyLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex);
+                }
+
+                long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
+                LinkView.nativeClear(columnRealmListNativeLinkViewPtr);
+                RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
+                if (columnRealmListList != null) {
+                    for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
+                        Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
+                        if (cacheItemIndexcolumnRealmList == null) {
+                            cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insertOrUpdate(realm, columnRealmListItem, cache);
+                        }
+                        LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
+                    }
+                }
+                LinkView.nativeClose(columnRealmListNativeLinkViewPtr);
+
+            }
+        }
+    }
+
+    public static some.test.AllTypes createDetachedCopy(some.test.AllTypes realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
         if (currentDepth > maxDepth || realmObject == null) {
             return null;
         }
         CacheData<RealmModel> cachedObject = cache.get(realmObject);
-        AllTypes unmanagedObject;
+        some.test.AllTypes unmanagedObject;
         if (cachedObject != null) {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
             if (currentDepth >= cachedObject.minDepth) {
-                return (AllTypes)cachedObject.object;
+                return (some.test.AllTypes)cachedObject.object;
             } else {
-                unmanagedObject = (AllTypes)cachedObject.object;
+                unmanagedObject = (some.test.AllTypes)cachedObject.object;
                 cachedObject.minDepth = currentDepth;
             }
         } else {
-            unmanagedObject = new AllTypes();
+            unmanagedObject = new some.test.AllTypes();
             cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject));
         }
         ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnString(((AllTypesRealmProxyInterface) realmObject).realmGet$columnString());
@@ -689,29 +1167,29 @@ public static AllTypes createDetachedCopy(AllTypes realmObject, int currentDepth
         if (currentDepth == maxDepth) {
             ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnRealmList(null);
         } else {
-            RealmList<AllTypes> managedcolumnRealmListList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
-            RealmList<AllTypes> unmanagedcolumnRealmListList = new RealmList<AllTypes>();
+            RealmList<some.test.AllTypes> managedcolumnRealmListList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
+            RealmList<some.test.AllTypes> unmanagedcolumnRealmListList = new RealmList<some.test.AllTypes>();
             ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnRealmList(unmanagedcolumnRealmListList);
             int nextDepth = currentDepth + 1;
             int size = managedcolumnRealmListList.size();
             for (int i = 0; i < size; i++) {
-                AllTypes item = AllTypesRealmProxy.createDetachedCopy(managedcolumnRealmListList.get(i), nextDepth, maxDepth, cache);
+                some.test.AllTypes item = AllTypesRealmProxy.createDetachedCopy(managedcolumnRealmListList.get(i), nextDepth, maxDepth, cache);
                 unmanagedcolumnRealmListList.add(item);
             }
         }
         return unmanagedObject;
     }
 
-    static AllTypes update(Realm realm, AllTypes realmObject, AllTypes newObject, Map<RealmModel, RealmObjectProxy> cache) {
+    static some.test.AllTypes update(Realm realm, some.test.AllTypes realmObject, some.test.AllTypes newObject, Map<RealmModel, RealmObjectProxy> cache) {
         ((AllTypesRealmProxyInterface) realmObject).realmSet$columnLong(((AllTypesRealmProxyInterface) newObject).realmGet$columnLong());
         ((AllTypesRealmProxyInterface) realmObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) newObject).realmGet$columnFloat());
         ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) newObject).realmGet$columnDouble());
         ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBoolean(((AllTypesRealmProxyInterface) newObject).realmGet$columnBoolean());
         ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDate(((AllTypesRealmProxyInterface) newObject).realmGet$columnDate());
         ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBinary(((AllTypesRealmProxyInterface) newObject).realmGet$columnBinary());
-        AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) newObject).realmGet$columnObject();
+        some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) newObject).realmGet$columnObject();
         if (columnObjectObj != null) {
-            AllTypes cachecolumnObject = (AllTypes) cache.get(columnObjectObj);
+            some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
             if (cachecolumnObject != null) {
                 ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(cachecolumnObject);
             } else {
@@ -720,13 +1198,13 @@ static AllTypes update(Realm realm, AllTypes realmObject, AllTypes newObject, Ma
         } else {
             ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(null);
         }
-        RealmList<AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) newObject).realmGet$columnRealmList();
-        RealmList<AllTypes> columnRealmListRealmList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
+        RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) newObject).realmGet$columnRealmList();
+        RealmList<some.test.AllTypes> columnRealmListRealmList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
         columnRealmListRealmList.clear();
         if (columnRealmListList != null) {
             for (int i = 0; i < columnRealmListList.size(); i++) {
-                AllTypes columnRealmListItem = columnRealmListList.get(i);
-                AllTypes cachecolumnRealmList = (AllTypes) cache.get(columnRealmListItem);
+                some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
+                some.test.AllTypes cachecolumnRealmList = (some.test.AllTypes) cache.get(columnRealmListItem);
                 if (cachecolumnRealmList != null) {
                     columnRealmListRealmList.add(cachecolumnRealmList);
                 } else {
@@ -808,7 +1286,7 @@ public boolean equals(Object o) {
 
         String path = proxyState.getRealm$realm().getPath();
         String otherPath = aAllTypes.proxyState.getRealm$realm().getPath();
-        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;;
+        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;
 
         String tableName = proxyState.getRow$realm().getTable().getName();
         String otherTableName = aAllTypes.proxyState.getRow$realm().getTable().getName();
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index 0fe76e0cbe..7621195151 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -1,61 +1,75 @@
 package io.realm;
 
 
+import android.annotation.TargetApi;
+import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
-import io.realm.RealmFieldType;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.Row;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
+import io.realm.log.RealmLog;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.Future;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
-import some.test.Booleans;
 
-public class BooleansRealmProxy extends Booleans
+public class BooleansRealmProxy extends some.test.Booleans
         implements RealmObjectProxy, BooleansRealmProxyInterface {
 
-    static final class BooleansColumnInfo extends ColumnInfo {
+    static final class BooleansColumnInfo extends ColumnInfo
+            implements Cloneable {
 
-        public final long doneIndex;
-        public final long isReadyIndex;
-        public final long mCompletedIndex;
-        public final long anotherBooleanIndex;
+        public long doneIndex;
+        public long isReadyIndex;
+        public long mCompletedIndex;
+        public long anotherBooleanIndex;
 
         BooleansColumnInfo(String path, Table table) {
             final Map<String, Long> indicesMap = new HashMap<String, Long>(4);
             this.doneIndex = getValidColumnIndex(path, table, "Booleans", "done");
             indicesMap.put("done", this.doneIndex);
-
             this.isReadyIndex = getValidColumnIndex(path, table, "Booleans", "isReady");
             indicesMap.put("isReady", this.isReadyIndex);
-
             this.mCompletedIndex = getValidColumnIndex(path, table, "Booleans", "mCompleted");
             indicesMap.put("mCompleted", this.mCompletedIndex);
-
             this.anotherBooleanIndex = getValidColumnIndex(path, table, "Booleans", "anotherBoolean");
             indicesMap.put("anotherBoolean", this.anotherBooleanIndex);
 
             setIndicesMap(indicesMap);
         }
-    }
 
-    private final BooleansColumnInfo columnInfo;
-    private final ProxyState proxyState;
+        @Override
+        public final void copyColumnInfoFrom(ColumnInfo other) {
+            final BooleansColumnInfo otherInfo = (BooleansColumnInfo) other;
+            this.doneIndex = otherInfo.doneIndex;
+            this.isReadyIndex = otherInfo.isReadyIndex;
+            this.mCompletedIndex = otherInfo.mCompletedIndex;
+            this.anotherBooleanIndex = otherInfo.anotherBooleanIndex;
+
+            setIndicesMap(otherInfo.getIndicesMap());
+        }
+
+        @Override
+        public final BooleansColumnInfo clone() {
+            return (BooleansColumnInfo) super.clone();
+        }
+
+    }
+    private BooleansColumnInfo columnInfo;
+    private ProxyState proxyState;
     private static final List<String> FIELD_NAMES;
     static {
         List<String> fieldNames = new ArrayList<String>();
@@ -66,58 +80,134 @@
         FIELD_NAMES = Collections.unmodifiableList(fieldNames);
     }
 
-    BooleansRealmProxy(ColumnInfo columnInfo) {
-        this.columnInfo = (BooleansColumnInfo) columnInfo;
-        this.proxyState = new ProxyState(Booleans.class, this);
+    BooleansRealmProxy() {
+        if (proxyState == null) {
+            injectObjectContext();
+        }
+        proxyState.setConstructionFinished();
+    }
+
+    private void injectObjectContext() {
+        final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
+        this.columnInfo = (BooleansColumnInfo) context.getColumnInfo();
+        this.proxyState = new ProxyState(some.test.Booleans.class, this);
+        proxyState.setRealm$realm(context.getRealm());
+        proxyState.setRow$realm(context.getRow());
+        proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
+        proxyState.setExcludeFields$realm(context.getExcludeFields());
     }
 
     @SuppressWarnings("cast")
     public boolean realmGet$done() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.doneIndex);
     }
 
     public void realmSet$done(boolean value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         proxyState.getRow$realm().setBoolean(columnInfo.doneIndex, value);
     }
 
     @SuppressWarnings("cast")
     public boolean realmGet$isReady() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.isReadyIndex);
     }
 
     public void realmSet$isReady(boolean value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         proxyState.getRow$realm().setBoolean(columnInfo.isReadyIndex, value);
     }
 
     @SuppressWarnings("cast")
     public boolean realmGet$mCompleted() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.mCompletedIndex);
     }
 
     public void realmSet$mCompleted(boolean value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         proxyState.getRow$realm().setBoolean(columnInfo.mCompletedIndex, value);
     }
 
     @SuppressWarnings("cast")
     public boolean realmGet$anotherBoolean() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.anotherBooleanIndex);
     }
 
     public void realmSet$anotherBoolean(boolean value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         proxyState.getRow$realm().setBoolean(columnInfo.anotherBooleanIndex, value);
     }
 
-    public static Table initTable(ImplicitTransaction transaction) {
-        if (!transaction.hasTable("class_Booleans")) {
-            Table table = transaction.getTable("class_Booleans");
+    public static Table initTable(SharedRealm sharedRealm) {
+        if (!sharedRealm.hasTable("class_Booleans")) {
+            Table table = sharedRealm.getTable("class_Booleans");
             table.addColumn(RealmFieldType.BOOLEAN, "done", Table.NOT_NULLABLE);
             table.addColumn(RealmFieldType.BOOLEAN, "isReady", Table.NOT_NULLABLE);
             table.addColumn(RealmFieldType.BOOLEAN, "mCompleted", Table.NOT_NULLABLE);
@@ -125,61 +215,69 @@ public static Table initTable(ImplicitTransaction transaction) {
             table.setPrimaryKey("");
             return table;
         }
-        return transaction.getTable("class_Booleans");
+        return sharedRealm.getTable("class_Booleans");
     }
 
-    public static BooleansColumnInfo validateTable(ImplicitTransaction transaction) {
-        if (transaction.hasTable("class_Booleans")) {
-            Table table = transaction.getTable("class_Booleans");
-            if (table.getColumnCount() != 4) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field count does not match - expected 4 but was " + table.getColumnCount());
+    public static BooleansColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
+        if (sharedRealm.hasTable("class_Booleans")) {
+            Table table = sharedRealm.getTable("class_Booleans");
+            final long columnCount = table.getColumnCount();
+            if (columnCount != 4) {
+                if (columnCount < 4) {
+                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 4 but was " + columnCount);
+                }
+                if (allowExtraColumns) {
+                    RealmLog.debug("Field count is more than expected - expected 4 but was %1$d", columnCount);
+                } else {
+                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 4 but was " + columnCount);
+                }
             }
             Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
             for (long i = 0; i < 4; i++) {
                 columnTypes.put(table.getColumnName(i), table.getColumnType(i));
             }
 
-            final BooleansColumnInfo columnInfo = new BooleansColumnInfo(transaction.getPath(), table);
+            final BooleansColumnInfo columnInfo = new BooleansColumnInfo(sharedRealm.getPath(), table);
 
             if (!columnTypes.containsKey("done")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'done' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'done' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("done") != RealmFieldType.BOOLEAN) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'done' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'done' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.doneIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'done' does support null values in the existing Realm file. Use corresponding boxed type for field 'done' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'done' does support null values in the existing Realm file. Use corresponding boxed type for field 'done' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("isReady")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'isReady' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'isReady' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("isReady") != RealmFieldType.BOOLEAN) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'isReady' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'isReady' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.isReadyIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'isReady' does support null values in the existing Realm file. Use corresponding boxed type for field 'isReady' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'isReady' does support null values in the existing Realm file. Use corresponding boxed type for field 'isReady' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("mCompleted")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'mCompleted' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'mCompleted' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("mCompleted") != RealmFieldType.BOOLEAN) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'mCompleted' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'mCompleted' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.mCompletedIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'mCompleted' does support null values in the existing Realm file. Use corresponding boxed type for field 'mCompleted' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'mCompleted' does support null values in the existing Realm file. Use corresponding boxed type for field 'mCompleted' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("anotherBoolean")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'anotherBoolean' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'anotherBoolean' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("anotherBoolean") != RealmFieldType.BOOLEAN) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'boolean' for field 'anotherBoolean' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'anotherBoolean' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.anotherBooleanIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'anotherBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'anotherBoolean' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'anotherBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'anotherBoolean' or migrate using RealmObjectSchema.setNullable().");
             }
             return columnInfo;
         } else {
-            throw new RealmMigrationNeededException(transaction.getPath(), "The Booleans class is missing from the schema for this Realm.");
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'Booleans' class is missing from the schema for this Realm.");
         }
     }
 
@@ -192,33 +290,34 @@ public static String getTableName() {
     }
 
     @SuppressWarnings("cast")
-    public static Booleans createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
+    public static some.test.Booleans createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
-        Booleans obj = realm.createObject(Booleans.class);
+        final List<String> excludeFields = Collections.<String> emptyList();
+        some.test.Booleans obj = realm.createObjectInternal(some.test.Booleans.class, true, excludeFields);
         if (json.has("done")) {
             if (json.isNull("done")) {
-                throw new IllegalArgumentException("Trying to set non-nullable field done to null.");
+                throw new IllegalArgumentException("Trying to set non-nullable field 'done' to null.");
             } else {
                 ((BooleansRealmProxyInterface) obj).realmSet$done((boolean) json.getBoolean("done"));
             }
         }
         if (json.has("isReady")) {
             if (json.isNull("isReady")) {
-                throw new IllegalArgumentException("Trying to set non-nullable field isReady to null.");
+                throw new IllegalArgumentException("Trying to set non-nullable field 'isReady' to null.");
             } else {
                 ((BooleansRealmProxyInterface) obj).realmSet$isReady((boolean) json.getBoolean("isReady"));
             }
         }
         if (json.has("mCompleted")) {
             if (json.isNull("mCompleted")) {
-                throw new IllegalArgumentException("Trying to set non-nullable field mCompleted to null.");
+                throw new IllegalArgumentException("Trying to set non-nullable field 'mCompleted' to null.");
             } else {
                 ((BooleansRealmProxyInterface) obj).realmSet$mCompleted((boolean) json.getBoolean("mCompleted"));
             }
         }
         if (json.has("anotherBoolean")) {
             if (json.isNull("anotherBoolean")) {
-                throw new IllegalArgumentException("Trying to set non-nullable field anotherBoolean to null.");
+                throw new IllegalArgumentException("Trying to set non-nullable field 'anotherBoolean' to null.");
             } else {
                 ((BooleansRealmProxyInterface) obj).realmSet$anotherBoolean((boolean) json.getBoolean("anotherBoolean"));
             }
@@ -227,37 +326,38 @@ public static Booleans createOrUpdateUsingJsonObject(Realm realm, JSONObject jso
     }
 
     @SuppressWarnings("cast")
-    public static Booleans createUsingJsonStream(Realm realm, JsonReader reader)
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public static some.test.Booleans createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        Booleans obj = realm.createObject(Booleans.class);
+        some.test.Booleans obj = new some.test.Booleans();
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
             if (name.equals("done")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    throw new IllegalArgumentException("Trying to set non-nullable field done to null.");
+                    throw new IllegalArgumentException("Trying to set non-nullable field 'done' to null.");
                 } else {
                     ((BooleansRealmProxyInterface) obj).realmSet$done((boolean) reader.nextBoolean());
                 }
             } else if (name.equals("isReady")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    throw new IllegalArgumentException("Trying to set non-nullable field isReady to null.");
+                    throw new IllegalArgumentException("Trying to set non-nullable field 'isReady' to null.");
                 } else {
                     ((BooleansRealmProxyInterface) obj).realmSet$isReady((boolean) reader.nextBoolean());
                 }
             } else if (name.equals("mCompleted")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    throw new IllegalArgumentException("Trying to set non-nullable field mCompleted to null.");
+                    throw new IllegalArgumentException("Trying to set non-nullable field 'mCompleted' to null.");
                 } else {
                     ((BooleansRealmProxyInterface) obj).realmSet$mCompleted((boolean) reader.nextBoolean());
                 }
             } else if (name.equals("anotherBoolean")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    throw new IllegalArgumentException("Trying to set non-nullable field anotherBoolean to null.");
+                    throw new IllegalArgumentException("Trying to set non-nullable field 'anotherBoolean' to null.");
                 } else {
                     ((BooleansRealmProxyInterface) obj).realmSet$anotherBoolean((boolean) reader.nextBoolean());
                 }
@@ -266,45 +366,134 @@ public static Booleans createUsingJsonStream(Realm realm, JsonReader reader)
             }
         }
         reader.endObject();
+        obj = realm.copyToRealm(obj);
         return obj;
     }
 
-    public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+    public static some.test.Booleans copyOrUpdate(Realm realm, some.test.Booleans object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
             throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
         }
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
             return object;
         }
-        return copy(realm, object, update, cache);
+        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
+        RealmObjectProxy cachedRealmObject = cache.get(object);
+        if (cachedRealmObject != null) {
+            return (some.test.Booleans) cachedRealmObject;
+        } else {
+            return copy(realm, object, update, cache);
+        }
+    }
+
+    public static some.test.Booleans copy(Realm realm, some.test.Booleans newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+        RealmObjectProxy cachedRealmObject = cache.get(newObject);
+        if (cachedRealmObject != null) {
+            return (some.test.Booleans) cachedRealmObject;
+        } else {
+            // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
+            some.test.Booleans realmObject = realm.createObjectInternal(some.test.Booleans.class, false, Collections.<String>emptyList());
+            cache.put(newObject, (RealmObjectProxy) realmObject);
+            ((BooleansRealmProxyInterface) realmObject).realmSet$done(((BooleansRealmProxyInterface) newObject).realmGet$done());
+            ((BooleansRealmProxyInterface) realmObject).realmSet$isReady(((BooleansRealmProxyInterface) newObject).realmGet$isReady());
+            ((BooleansRealmProxyInterface) realmObject).realmSet$mCompleted(((BooleansRealmProxyInterface) newObject).realmGet$mCompleted());
+            ((BooleansRealmProxyInterface) realmObject).realmSet$anotherBoolean(((BooleansRealmProxyInterface) newObject).realmGet$anotherBoolean());
+            return realmObject;
+        }
     }
 
-    public static Booleans copy(Realm realm, Booleans newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
-        Booleans realmObject = realm.createObject(Booleans.class);
-        cache.put(newObject, (RealmObjectProxy) realmObject);
-        ((BooleansRealmProxyInterface) realmObject).realmSet$done(((BooleansRealmProxyInterface) newObject).realmGet$done());
-        ((BooleansRealmProxyInterface) realmObject).realmSet$isReady(((BooleansRealmProxyInterface) newObject).realmGet$isReady());
-        ((BooleansRealmProxyInterface) realmObject).realmSet$mCompleted(((BooleansRealmProxyInterface) newObject).realmGet$mCompleted());
-        ((BooleansRealmProxyInterface) realmObject).realmSet$anotherBoolean(((BooleansRealmProxyInterface) newObject).realmGet$anotherBoolean());
-        return realmObject;
+    public static long insert(Realm realm, some.test.Booleans object, Map<RealmModel,Long> cache) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+            return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
+        }
+        Table table = realm.getTable(some.test.Booleans.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(some.test.Booleans.class);
+        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+        cache.put(object, rowIndex);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done());
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady());
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted());
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean());
+        return rowIndex;
+    }
+
+    public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.Booleans.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(some.test.Booleans.class);
+        some.test.Booleans object = null;
+        while (objects.hasNext()) {
+            object = (some.test.Booleans) objects.next();
+            if(!cache.containsKey(object)) {
+                if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                    cache.put(object, ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex());
+                    continue;
+                }
+                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+                cache.put(object, rowIndex);
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done());
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady());
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted());
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean());
+            }
+        }
+    }
+
+    public static long insertOrUpdate(Realm realm, some.test.Booleans object, Map<RealmModel,Long> cache) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+            return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
+        }
+        Table table = realm.getTable(some.test.Booleans.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(some.test.Booleans.class);
+        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+        cache.put(object, rowIndex);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done());
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady());
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted());
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean());
+        return rowIndex;
+    }
+
+    public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.Booleans.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(some.test.Booleans.class);
+        some.test.Booleans object = null;
+        while (objects.hasNext()) {
+            object = (some.test.Booleans) objects.next();
+            if(!cache.containsKey(object)) {
+                if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                    cache.put(object, ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex());
+                    continue;
+                }
+                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+                cache.put(object, rowIndex);
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done());
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady());
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted());
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean());
+            }
+        }
     }
 
-    public static Booleans createDetachedCopy(Booleans realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
+    public static some.test.Booleans createDetachedCopy(some.test.Booleans realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
         if (currentDepth > maxDepth || realmObject == null) {
             return null;
         }
         CacheData<RealmModel> cachedObject = cache.get(realmObject);
-        Booleans unmanagedObject;
+        some.test.Booleans unmanagedObject;
         if (cachedObject != null) {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
             if (currentDepth >= cachedObject.minDepth) {
-                return (Booleans)cachedObject.object;
+                return (some.test.Booleans)cachedObject.object;
             } else {
-                unmanagedObject = (Booleans)cachedObject.object;
+                unmanagedObject = (some.test.Booleans)cachedObject.object;
                 cachedObject.minDepth = currentDepth;
             }
         } else {
-            unmanagedObject = new Booleans();
+            unmanagedObject = new some.test.Booleans();
             cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject));
         }
         ((BooleansRealmProxyInterface) unmanagedObject).realmSet$done(((BooleansRealmProxyInterface) realmObject).realmGet$done());
@@ -365,7 +554,7 @@ public boolean equals(Object o) {
 
         String path = proxyState.getRealm$realm().getPath();
         String otherPath = aBooleans.proxyState.getRealm$realm().getPath();
-        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;;
+        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;
 
         String tableName = proxyState.getRow$realm().getTable().getName();
         String otherTableName = aBooleans.proxyState.getRow$realm().getTable().getName();
@@ -376,4 +565,4 @@ public boolean equals(Object o) {
         return true;
     }
 
-}
\ No newline at end of file
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index 266dd5b234..b8b1322464 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -1,129 +1,143 @@
 package io.realm;
 
 
+import android.annotation.TargetApi;
+import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
-import io.realm.RealmFieldType;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.Row;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
+import io.realm.log.RealmLog;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.Future;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
-import some.test.NullTypes;
 
-public class NullTypesRealmProxy extends NullTypes
+public class NullTypesRealmProxy extends some.test.NullTypes
         implements RealmObjectProxy, NullTypesRealmProxyInterface {
 
-    static final class NullTypesColumnInfo extends ColumnInfo {
-
-        public final long fieldStringNotNullIndex;
-        public final long fieldStringNullIndex;
-        public final long fieldBooleanNotNullIndex;
-        public final long fieldBooleanNullIndex;
-        public final long fieldBytesNotNullIndex;
-        public final long fieldBytesNullIndex;
-        public final long fieldByteNotNullIndex;
-        public final long fieldByteNullIndex;
-        public final long fieldShortNotNullIndex;
-        public final long fieldShortNullIndex;
-        public final long fieldIntegerNotNullIndex;
-        public final long fieldIntegerNullIndex;
-        public final long fieldLongNotNullIndex;
-        public final long fieldLongNullIndex;
-        public final long fieldFloatNotNullIndex;
-        public final long fieldFloatNullIndex;
-        public final long fieldDoubleNotNullIndex;
-        public final long fieldDoubleNullIndex;
-        public final long fieldDateNotNullIndex;
-        public final long fieldDateNullIndex;
-        public final long fieldObjectNullIndex;
+    static final class NullTypesColumnInfo extends ColumnInfo
+            implements Cloneable {
+
+        public long fieldStringNotNullIndex;
+        public long fieldStringNullIndex;
+        public long fieldBooleanNotNullIndex;
+        public long fieldBooleanNullIndex;
+        public long fieldBytesNotNullIndex;
+        public long fieldBytesNullIndex;
+        public long fieldByteNotNullIndex;
+        public long fieldByteNullIndex;
+        public long fieldShortNotNullIndex;
+        public long fieldShortNullIndex;
+        public long fieldIntegerNotNullIndex;
+        public long fieldIntegerNullIndex;
+        public long fieldLongNotNullIndex;
+        public long fieldLongNullIndex;
+        public long fieldFloatNotNullIndex;
+        public long fieldFloatNullIndex;
+        public long fieldDoubleNotNullIndex;
+        public long fieldDoubleNullIndex;
+        public long fieldDateNotNullIndex;
+        public long fieldDateNullIndex;
+        public long fieldObjectNullIndex;
 
         NullTypesColumnInfo(String path, Table table) {
             final Map<String, Long> indicesMap = new HashMap<String, Long>(21);
             this.fieldStringNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldStringNotNull");
             indicesMap.put("fieldStringNotNull", this.fieldStringNotNullIndex);
-
             this.fieldStringNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldStringNull");
             indicesMap.put("fieldStringNull", this.fieldStringNullIndex);
-
             this.fieldBooleanNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldBooleanNotNull");
             indicesMap.put("fieldBooleanNotNull", this.fieldBooleanNotNullIndex);
-
             this.fieldBooleanNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldBooleanNull");
             indicesMap.put("fieldBooleanNull", this.fieldBooleanNullIndex);
-
             this.fieldBytesNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldBytesNotNull");
             indicesMap.put("fieldBytesNotNull", this.fieldBytesNotNullIndex);
-
             this.fieldBytesNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldBytesNull");
             indicesMap.put("fieldBytesNull", this.fieldBytesNullIndex);
-
             this.fieldByteNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldByteNotNull");
             indicesMap.put("fieldByteNotNull", this.fieldByteNotNullIndex);
-
             this.fieldByteNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldByteNull");
             indicesMap.put("fieldByteNull", this.fieldByteNullIndex);
-
             this.fieldShortNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldShortNotNull");
             indicesMap.put("fieldShortNotNull", this.fieldShortNotNullIndex);
-
             this.fieldShortNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldShortNull");
             indicesMap.put("fieldShortNull", this.fieldShortNullIndex);
-
             this.fieldIntegerNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldIntegerNotNull");
             indicesMap.put("fieldIntegerNotNull", this.fieldIntegerNotNullIndex);
-
             this.fieldIntegerNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldIntegerNull");
             indicesMap.put("fieldIntegerNull", this.fieldIntegerNullIndex);
-
             this.fieldLongNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldLongNotNull");
             indicesMap.put("fieldLongNotNull", this.fieldLongNotNullIndex);
-
             this.fieldLongNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldLongNull");
             indicesMap.put("fieldLongNull", this.fieldLongNullIndex);
-
             this.fieldFloatNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldFloatNotNull");
             indicesMap.put("fieldFloatNotNull", this.fieldFloatNotNullIndex);
-
             this.fieldFloatNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldFloatNull");
             indicesMap.put("fieldFloatNull", this.fieldFloatNullIndex);
-
             this.fieldDoubleNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldDoubleNotNull");
             indicesMap.put("fieldDoubleNotNull", this.fieldDoubleNotNullIndex);
-
             this.fieldDoubleNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldDoubleNull");
             indicesMap.put("fieldDoubleNull", this.fieldDoubleNullIndex);
-
             this.fieldDateNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldDateNotNull");
             indicesMap.put("fieldDateNotNull", this.fieldDateNotNullIndex);
-
             this.fieldDateNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldDateNull");
             indicesMap.put("fieldDateNull", this.fieldDateNullIndex);
-
             this.fieldObjectNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldObjectNull");
             indicesMap.put("fieldObjectNull", this.fieldObjectNullIndex);
 
             setIndicesMap(indicesMap);
         }
-    }
 
-    private final NullTypesColumnInfo columnInfo;
-    private final ProxyState proxyState;
+        @Override
+        public final void copyColumnInfoFrom(ColumnInfo other) {
+            final NullTypesColumnInfo otherInfo = (NullTypesColumnInfo) other;
+            this.fieldStringNotNullIndex = otherInfo.fieldStringNotNullIndex;
+            this.fieldStringNullIndex = otherInfo.fieldStringNullIndex;
+            this.fieldBooleanNotNullIndex = otherInfo.fieldBooleanNotNullIndex;
+            this.fieldBooleanNullIndex = otherInfo.fieldBooleanNullIndex;
+            this.fieldBytesNotNullIndex = otherInfo.fieldBytesNotNullIndex;
+            this.fieldBytesNullIndex = otherInfo.fieldBytesNullIndex;
+            this.fieldByteNotNullIndex = otherInfo.fieldByteNotNullIndex;
+            this.fieldByteNullIndex = otherInfo.fieldByteNullIndex;
+            this.fieldShortNotNullIndex = otherInfo.fieldShortNotNullIndex;
+            this.fieldShortNullIndex = otherInfo.fieldShortNullIndex;
+            this.fieldIntegerNotNullIndex = otherInfo.fieldIntegerNotNullIndex;
+            this.fieldIntegerNullIndex = otherInfo.fieldIntegerNullIndex;
+            this.fieldLongNotNullIndex = otherInfo.fieldLongNotNullIndex;
+            this.fieldLongNullIndex = otherInfo.fieldLongNullIndex;
+            this.fieldFloatNotNullIndex = otherInfo.fieldFloatNotNullIndex;
+            this.fieldFloatNullIndex = otherInfo.fieldFloatNullIndex;
+            this.fieldDoubleNotNullIndex = otherInfo.fieldDoubleNotNullIndex;
+            this.fieldDoubleNullIndex = otherInfo.fieldDoubleNullIndex;
+            this.fieldDateNotNullIndex = otherInfo.fieldDateNotNullIndex;
+            this.fieldDateNullIndex = otherInfo.fieldDateNullIndex;
+            this.fieldObjectNullIndex = otherInfo.fieldObjectNullIndex;
+
+            setIndicesMap(otherInfo.getIndicesMap());
+        }
+
+        @Override
+        public final NullTypesColumnInfo clone() {
+            return (NullTypesColumnInfo) super.clone();
+        }
+
+    }
+    private NullTypesColumnInfo columnInfo;
+    private ProxyState proxyState;
     private static final List<String> FIELD_NAMES;
     static {
         List<String> fieldNames = new ArrayList<String>();
@@ -151,32 +165,76 @@
         FIELD_NAMES = Collections.unmodifiableList(fieldNames);
     }
 
-    NullTypesRealmProxy(ColumnInfo columnInfo) {
-        this.columnInfo = (NullTypesColumnInfo) columnInfo;
-        this.proxyState = new ProxyState(NullTypes.class, this);
+    NullTypesRealmProxy() {
+        if (proxyState == null) {
+            injectObjectContext();
+        }
+        proxyState.setConstructionFinished();
+    }
+
+    private void injectObjectContext() {
+        final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
+        this.columnInfo = (NullTypesColumnInfo) context.getColumnInfo();
+        this.proxyState = new ProxyState(some.test.NullTypes.class, this);
+        proxyState.setRealm$realm(context.getRealm());
+        proxyState.setRow$realm(context.getRow());
+        proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
+        proxyState.setExcludeFields$realm(context.getExcludeFields());
     }
 
     @SuppressWarnings("cast")
     public String realmGet$fieldStringNotNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.fieldStringNotNullIndex);
     }
 
     public void realmSet$fieldStringNotNull(String value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field fieldStringNotNull to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'fieldStringNotNull' to null.");
         }
         proxyState.getRow$realm().setString(columnInfo.fieldStringNotNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public String realmGet$fieldStringNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.fieldStringNullIndex);
     }
 
     public void realmSet$fieldStringNull(String value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.fieldStringNullIndex);
@@ -187,20 +245,41 @@
 
     @SuppressWarnings("cast")
     public Boolean realmGet$fieldBooleanNotNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.fieldBooleanNotNullIndex);
     }
 
     public void realmSet$fieldBooleanNotNull(Boolean value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field fieldBooleanNotNull to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'fieldBooleanNotNull' to null.");
         }
         proxyState.getRow$realm().setBoolean(columnInfo.fieldBooleanNotNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Boolean realmGet$fieldBooleanNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldBooleanNullIndex)) {
             return null;
@@ -209,6 +288,17 @@
     }
 
     public void realmSet$fieldBooleanNull(Boolean value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.fieldBooleanNullIndex);
@@ -219,25 +309,57 @@
 
     @SuppressWarnings("cast")
     public byte[] realmGet$fieldBytesNotNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (byte[]) proxyState.getRow$realm().getBinaryByteArray(columnInfo.fieldBytesNotNullIndex);
     }
 
     public void realmSet$fieldBytesNotNull(byte[] value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field fieldBytesNotNull to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'fieldBytesNotNull' to null.");
         }
         proxyState.getRow$realm().setBinaryByteArray(columnInfo.fieldBytesNotNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public byte[] realmGet$fieldBytesNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (byte[]) proxyState.getRow$realm().getBinaryByteArray(columnInfo.fieldBytesNullIndex);
     }
 
     public void realmSet$fieldBytesNull(byte[] value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.fieldBytesNullIndex);
@@ -248,20 +370,41 @@
 
     @SuppressWarnings("cast")
     public Byte realmGet$fieldByteNotNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (byte) proxyState.getRow$realm().getLong(columnInfo.fieldByteNotNullIndex);
     }
 
     public void realmSet$fieldByteNotNull(Byte value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field fieldByteNotNull to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'fieldByteNotNull' to null.");
         }
         proxyState.getRow$realm().setLong(columnInfo.fieldByteNotNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Byte realmGet$fieldByteNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldByteNullIndex)) {
             return null;
@@ -270,6 +413,17 @@
     }
 
     public void realmSet$fieldByteNull(Byte value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.fieldByteNullIndex);
@@ -280,20 +434,41 @@
 
     @SuppressWarnings("cast")
     public Short realmGet$fieldShortNotNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (short) proxyState.getRow$realm().getLong(columnInfo.fieldShortNotNullIndex);
     }
 
     public void realmSet$fieldShortNotNull(Short value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field fieldShortNotNull to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'fieldShortNotNull' to null.");
         }
         proxyState.getRow$realm().setLong(columnInfo.fieldShortNotNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Short realmGet$fieldShortNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldShortNullIndex)) {
             return null;
@@ -302,6 +477,17 @@
     }
 
     public void realmSet$fieldShortNull(Short value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.fieldShortNullIndex);
@@ -312,20 +498,41 @@
 
     @SuppressWarnings("cast")
     public Integer realmGet$fieldIntegerNotNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (int) proxyState.getRow$realm().getLong(columnInfo.fieldIntegerNotNullIndex);
     }
 
     public void realmSet$fieldIntegerNotNull(Integer value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field fieldIntegerNotNull to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'fieldIntegerNotNull' to null.");
         }
         proxyState.getRow$realm().setLong(columnInfo.fieldIntegerNotNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Integer realmGet$fieldIntegerNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldIntegerNullIndex)) {
             return null;
@@ -334,6 +541,17 @@
     }
 
     public void realmSet$fieldIntegerNull(Integer value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.fieldIntegerNullIndex);
@@ -344,20 +562,41 @@
 
     @SuppressWarnings("cast")
     public Long realmGet$fieldLongNotNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (long) proxyState.getRow$realm().getLong(columnInfo.fieldLongNotNullIndex);
     }
 
     public void realmSet$fieldLongNotNull(Long value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field fieldLongNotNull to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'fieldLongNotNull' to null.");
         }
         proxyState.getRow$realm().setLong(columnInfo.fieldLongNotNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Long realmGet$fieldLongNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldLongNullIndex)) {
             return null;
@@ -366,6 +605,17 @@
     }
 
     public void realmSet$fieldLongNull(Long value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.fieldLongNullIndex);
@@ -376,20 +626,41 @@
 
     @SuppressWarnings("cast")
     public Float realmGet$fieldFloatNotNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (float) proxyState.getRow$realm().getFloat(columnInfo.fieldFloatNotNullIndex);
     }
 
     public void realmSet$fieldFloatNotNull(Float value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field fieldFloatNotNull to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'fieldFloatNotNull' to null.");
         }
         proxyState.getRow$realm().setFloat(columnInfo.fieldFloatNotNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Float realmGet$fieldFloatNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldFloatNullIndex)) {
             return null;
@@ -398,6 +669,17 @@
     }
 
     public void realmSet$fieldFloatNull(Float value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.fieldFloatNullIndex);
@@ -408,20 +690,41 @@
 
     @SuppressWarnings("cast")
     public Double realmGet$fieldDoubleNotNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (double) proxyState.getRow$realm().getDouble(columnInfo.fieldDoubleNotNullIndex);
     }
 
     public void realmSet$fieldDoubleNotNull(Double value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field fieldDoubleNotNull to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'fieldDoubleNotNull' to null.");
         }
         proxyState.getRow$realm().setDouble(columnInfo.fieldDoubleNotNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Double realmGet$fieldDoubleNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldDoubleNullIndex)) {
             return null;
@@ -430,6 +733,17 @@
     }
 
     public void realmSet$fieldDoubleNull(Double value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.fieldDoubleNullIndex);
@@ -440,20 +754,41 @@
 
     @SuppressWarnings("cast")
     public Date realmGet$fieldDateNotNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (java.util.Date) proxyState.getRow$realm().getDate(columnInfo.fieldDateNotNullIndex);
     }
 
     public void realmSet$fieldDateNotNull(Date value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
-            throw new IllegalArgumentException("Trying to set non-nullable field fieldDateNotNull to null.");
+            throw new IllegalArgumentException("Trying to set non-nullable field 'fieldDateNotNull' to null.");
         }
         proxyState.getRow$realm().setDate(columnInfo.fieldDateNotNullIndex, value);
     }
 
     @SuppressWarnings("cast")
     public Date realmGet$fieldDateNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldDateNullIndex)) {
             return null;
@@ -462,6 +797,17 @@
     }
 
     public void realmSet$fieldDateNull(Date value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.fieldDateNullIndex);
@@ -470,21 +816,43 @@
         proxyState.getRow$realm().setDate(columnInfo.fieldDateNullIndex, value);
     }
 
-    public NullTypes realmGet$fieldObjectNull() {
+    public some.test.NullTypes realmGet$fieldObjectNull() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNullLink(columnInfo.fieldObjectNullIndex)) {
             return null;
         }
-        return proxyState.getRealm$realm().get(some.test.NullTypes.class, proxyState.getRow$realm().getLink(columnInfo.fieldObjectNullIndex));
+        return proxyState.getRealm$realm().get(some.test.NullTypes.class, proxyState.getRow$realm().getLink(columnInfo.fieldObjectNullIndex), false, Collections.<String>emptyList());
     }
 
-    public void realmSet$fieldObjectNull(NullTypes value) {
+    public void realmSet$fieldObjectNull(some.test.NullTypes value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldObjectNull")) {
+                return;
+            }
+            if (value != null && !RealmObject.isManaged(value)) {
+                value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value);
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().nullifyLink(columnInfo.fieldObjectNullIndex);
             return;
         }
-        if (!RealmObject.isValid(value)) {
+        if (!(RealmObject.isManaged(value) && RealmObject.isValid(value))) {
             throw new IllegalArgumentException("'value' is not a valid managed object.");
         }
         if (((RealmObjectProxy)value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
@@ -493,9 +861,9 @@
         proxyState.getRow$realm().setLink(columnInfo.fieldObjectNullIndex, ((RealmObjectProxy)value).realmGet$proxyState().getRow$realm().getIndex());
     }
 
-    public static Table initTable(ImplicitTransaction transaction) {
-        if (!transaction.hasTable("class_NullTypes")) {
-            Table table = transaction.getTable("class_NullTypes");
+    public static Table initTable(SharedRealm sharedRealm) {
+        if (!sharedRealm.hasTable("class_NullTypes")) {
+            Table table = sharedRealm.getTable("class_NullTypes");
             table.addColumn(RealmFieldType.STRING, "fieldStringNotNull", Table.NOT_NULLABLE);
             table.addColumn(RealmFieldType.STRING, "fieldStringNull", Table.NULLABLE);
             table.addColumn(RealmFieldType.BOOLEAN, "fieldBooleanNotNull", Table.NOT_NULLABLE);
@@ -516,225 +884,233 @@ public static Table initTable(ImplicitTransaction transaction) {
             table.addColumn(RealmFieldType.DOUBLE, "fieldDoubleNull", Table.NULLABLE);
             table.addColumn(RealmFieldType.DATE, "fieldDateNotNull", Table.NOT_NULLABLE);
             table.addColumn(RealmFieldType.DATE, "fieldDateNull", Table.NULLABLE);
-            if (!transaction.hasTable("class_NullTypes")) {
-                NullTypesRealmProxy.initTable(transaction);
+            if (!sharedRealm.hasTable("class_NullTypes")) {
+                NullTypesRealmProxy.initTable(sharedRealm);
             }
-            table.addColumnLink(RealmFieldType.OBJECT, "fieldObjectNull", transaction.getTable("class_NullTypes"));
+            table.addColumnLink(RealmFieldType.OBJECT, "fieldObjectNull", sharedRealm.getTable("class_NullTypes"));
             table.setPrimaryKey("");
             return table;
         }
-        return transaction.getTable("class_NullTypes");
+        return sharedRealm.getTable("class_NullTypes");
     }
 
-    public static NullTypesColumnInfo validateTable(ImplicitTransaction transaction) {
-        if (transaction.hasTable("class_NullTypes")) {
-            Table table = transaction.getTable("class_NullTypes");
-            if (table.getColumnCount() != 21) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field count does not match - expected 21 but was " + table.getColumnCount());
+    public static NullTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
+        if (sharedRealm.hasTable("class_NullTypes")) {
+            Table table = sharedRealm.getTable("class_NullTypes");
+            final long columnCount = table.getColumnCount();
+            if (columnCount != 21) {
+                if (columnCount < 21) {
+                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 21 but was " + columnCount);
+                }
+                if (allowExtraColumns) {
+                    RealmLog.debug("Field count is more than expected - expected 21 but was %1$d", columnCount);
+                } else {
+                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 21 but was " + columnCount);
+                }
             }
             Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
             for (long i = 0; i < 21; i++) {
                 columnTypes.put(table.getColumnName(i), table.getColumnType(i));
             }
 
-            final NullTypesColumnInfo columnInfo = new NullTypesColumnInfo(transaction.getPath(), table);
+            final NullTypesColumnInfo columnInfo = new NullTypesColumnInfo(sharedRealm.getPath(), table);
 
             if (!columnTypes.containsKey("fieldStringNotNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldStringNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldStringNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldStringNotNull") != RealmFieldType.STRING) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'String' for field 'fieldStringNotNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'fieldStringNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldStringNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldStringNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldStringNotNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldStringNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldStringNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldStringNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldStringNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldStringNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldStringNull") != RealmFieldType.STRING) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'String' for field 'fieldStringNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'fieldStringNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldStringNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldStringNull' is required. Either set @Required to field 'fieldStringNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldStringNull' is required. Either set @Required to field 'fieldStringNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldBooleanNotNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldBooleanNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBooleanNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldBooleanNotNull") != RealmFieldType.BOOLEAN) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Boolean' for field 'fieldBooleanNotNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Boolean' for field 'fieldBooleanNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldBooleanNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldBooleanNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBooleanNotNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldBooleanNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBooleanNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldBooleanNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldBooleanNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBooleanNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldBooleanNull") != RealmFieldType.BOOLEAN) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Boolean' for field 'fieldBooleanNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Boolean' for field 'fieldBooleanNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldBooleanNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldBooleanNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldBooleanNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldBooleanNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldBooleanNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldBytesNotNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldBytesNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBytesNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldBytesNotNull") != RealmFieldType.BINARY) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'byte[]' for field 'fieldBytesNotNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'byte[]' for field 'fieldBytesNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldBytesNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldBytesNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBytesNotNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldBytesNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBytesNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldBytesNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldBytesNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBytesNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldBytesNull") != RealmFieldType.BINARY) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'byte[]' for field 'fieldBytesNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'byte[]' for field 'fieldBytesNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldBytesNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldBytesNull' is required. Either set @Required to field 'fieldBytesNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldBytesNull' is required. Either set @Required to field 'fieldBytesNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldByteNotNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldByteNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldByteNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldByteNotNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Byte' for field 'fieldByteNotNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Byte' for field 'fieldByteNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldByteNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldByteNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldByteNotNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldByteNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldByteNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldByteNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldByteNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldByteNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldByteNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Byte' for field 'fieldByteNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Byte' for field 'fieldByteNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldByteNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldByteNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldByteNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldByteNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldByteNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldShortNotNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldShortNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldShortNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldShortNotNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Short' for field 'fieldShortNotNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Short' for field 'fieldShortNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldShortNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldShortNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldShortNotNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldShortNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldShortNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldShortNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldShortNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldShortNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldShortNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Short' for field 'fieldShortNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Short' for field 'fieldShortNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldShortNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldShortNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldShortNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldShortNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldShortNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldIntegerNotNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldIntegerNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldIntegerNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldIntegerNotNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Integer' for field 'fieldIntegerNotNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Integer' for field 'fieldIntegerNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldIntegerNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldIntegerNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldIntegerNotNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldIntegerNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldIntegerNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldIntegerNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldIntegerNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldIntegerNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldIntegerNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Integer' for field 'fieldIntegerNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Integer' for field 'fieldIntegerNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldIntegerNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldIntegerNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldIntegerNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldIntegerNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldIntegerNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldLongNotNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldLongNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldLongNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldLongNotNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Long' for field 'fieldLongNotNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Long' for field 'fieldLongNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldLongNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldLongNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldLongNotNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldLongNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldLongNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldLongNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldLongNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldLongNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldLongNull") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Long' for field 'fieldLongNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Long' for field 'fieldLongNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldLongNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldLongNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldLongNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldLongNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldLongNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldFloatNotNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldFloatNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldFloatNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldFloatNotNull") != RealmFieldType.FLOAT) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Float' for field 'fieldFloatNotNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Float' for field 'fieldFloatNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldFloatNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldFloatNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldFloatNotNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldFloatNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldFloatNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldFloatNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldFloatNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldFloatNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldFloatNull") != RealmFieldType.FLOAT) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Float' for field 'fieldFloatNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Float' for field 'fieldFloatNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldFloatNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldFloatNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldFloatNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldFloatNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldFloatNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldDoubleNotNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldDoubleNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDoubleNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldDoubleNotNull") != RealmFieldType.DOUBLE) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Double' for field 'fieldDoubleNotNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Double' for field 'fieldDoubleNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldDoubleNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldDoubleNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDoubleNotNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldDoubleNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDoubleNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldDoubleNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldDoubleNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDoubleNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldDoubleNull") != RealmFieldType.DOUBLE) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Double' for field 'fieldDoubleNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Double' for field 'fieldDoubleNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldDoubleNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(),"Field 'fieldDoubleNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldDoubleNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldDoubleNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldDoubleNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldDateNotNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldDateNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDateNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldDateNotNull") != RealmFieldType.DATE) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Date' for field 'fieldDateNotNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Date' for field 'fieldDateNotNull' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.fieldDateNotNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldDateNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDateNotNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldDateNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDateNotNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldDateNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldDateNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDateNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldDateNull") != RealmFieldType.DATE) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'Date' for field 'fieldDateNull' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Date' for field 'fieldDateNull' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.fieldDateNullIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'fieldDateNull' is required. Either set @Required to field 'fieldDateNull' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldDateNull' is required. Either set @Required to field 'fieldDateNull' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("fieldObjectNull")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'fieldObjectNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldObjectNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("fieldObjectNull") != RealmFieldType.OBJECT) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'NullTypes' for field 'fieldObjectNull'");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'NullTypes' for field 'fieldObjectNull'");
             }
-            if (!transaction.hasTable("class_NullTypes")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing class 'class_NullTypes' for field 'fieldObjectNull'");
+            if (!sharedRealm.hasTable("class_NullTypes")) {
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_NullTypes' for field 'fieldObjectNull'");
             }
-            Table table_20 = transaction.getTable("class_NullTypes");
+            Table table_20 = sharedRealm.getTable("class_NullTypes");
             if (!table.getLinkTarget(columnInfo.fieldObjectNullIndex).hasSameSchema(table_20)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid RealmObject for field 'fieldObjectNull': '" + table.getLinkTarget(columnInfo.fieldObjectNullIndex).getName() + "' expected - was '" + table_20.getName() + "'");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmObject for field 'fieldObjectNull': '" + table.getLinkTarget(columnInfo.fieldObjectNullIndex).getName() + "' expected - was '" + table_20.getName() + "'");
             }
             return columnInfo;
         } else {
-            throw new RealmMigrationNeededException(transaction.getPath(), "The NullTypes class is missing from the schema for this Realm.");
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'NullTypes' class is missing from the schema for this Realm.");
         }
     }
 
@@ -747,9 +1123,13 @@ public static String getTableName() {
     }
 
     @SuppressWarnings("cast")
-    public static NullTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
+    public static some.test.NullTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
-        NullTypes obj = realm.createObject(NullTypes.class);
+        final List<String> excludeFields = new ArrayList<String>(1);
+        if (json.has("fieldObjectNull")) {
+            excludeFields.add("fieldObjectNull");
+        }
+        some.test.NullTypes obj = realm.createObjectInternal(some.test.NullTypes.class, true, excludeFields);
         if (json.has("fieldStringNotNull")) {
             if (json.isNull("fieldStringNotNull")) {
                 ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNotNull(null);
@@ -912,9 +1292,10 @@ public static NullTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject js
     }
 
     @SuppressWarnings("cast")
-    public static NullTypes createUsingJsonStream(Realm realm, JsonReader reader)
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public static some.test.NullTypes createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        NullTypes obj = realm.createObject(NullTypes.class);
+        some.test.NullTypes obj = new some.test.NullTypes();
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
@@ -1081,73 +1462,586 @@ public static NullTypes createUsingJsonStream(Realm realm, JsonReader reader)
             }
         }
         reader.endObject();
+        obj = realm.copyToRealm(obj);
         return obj;
     }
 
-    public static NullTypes copyOrUpdate(Realm realm, NullTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+    public static some.test.NullTypes copyOrUpdate(Realm realm, some.test.NullTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
             throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
         }
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
             return object;
         }
-        return copy(realm, object, update, cache);
+        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
+        RealmObjectProxy cachedRealmObject = cache.get(object);
+        if (cachedRealmObject != null) {
+            return (some.test.NullTypes) cachedRealmObject;
+        } else {
+            return copy(realm, object, update, cache);
+        }
     }
 
-    public static NullTypes copy(Realm realm, NullTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
-        NullTypes realmObject = realm.createObject(NullTypes.class);
-        cache.put(newObject, (RealmObjectProxy) realmObject);
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldStringNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldStringNotNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldStringNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldStringNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBooleanNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBooleanNotNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBooleanNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBooleanNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBytesNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBytesNotNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBytesNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBytesNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldByteNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldByteNotNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldByteNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldByteNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldShortNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldShortNotNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldShortNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldShortNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldIntegerNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldIntegerNotNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldIntegerNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldIntegerNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldLongNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldLongNotNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldLongNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldLongNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldFloatNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldFloatNotNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldFloatNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldFloatNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDoubleNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDoubleNotNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDoubleNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDoubleNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDateNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDateNotNull());
-        ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDateNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDateNull());
-
-        some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) newObject).realmGet$fieldObjectNull();
-        if (fieldObjectNullObj != null) {
-            some.test.NullTypes cachefieldObjectNull = (some.test.NullTypes) cache.get(fieldObjectNullObj);
-            if (cachefieldObjectNull != null) {
-                ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(cachefieldObjectNull);
+    public static some.test.NullTypes copy(Realm realm, some.test.NullTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+        RealmObjectProxy cachedRealmObject = cache.get(newObject);
+        if (cachedRealmObject != null) {
+            return (some.test.NullTypes) cachedRealmObject;
+        } else {
+            // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
+            some.test.NullTypes realmObject = realm.createObjectInternal(some.test.NullTypes.class, false, Collections.<String>emptyList());
+            cache.put(newObject, (RealmObjectProxy) realmObject);
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldStringNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldStringNotNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldStringNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldStringNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBooleanNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBooleanNotNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBooleanNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBooleanNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBytesNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBytesNotNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBytesNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBytesNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldByteNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldByteNotNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldByteNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldByteNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldShortNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldShortNotNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldShortNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldShortNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldIntegerNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldIntegerNotNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldIntegerNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldIntegerNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldLongNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldLongNotNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldLongNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldLongNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldFloatNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldFloatNotNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldFloatNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldFloatNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDoubleNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDoubleNotNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDoubleNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDoubleNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDateNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDateNotNull());
+            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDateNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDateNull());
+
+            some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) newObject).realmGet$fieldObjectNull();
+            if (fieldObjectNullObj != null) {
+                some.test.NullTypes cachefieldObjectNull = (some.test.NullTypes) cache.get(fieldObjectNullObj);
+                if (cachefieldObjectNull != null) {
+                    ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(cachefieldObjectNull);
+                } else {
+                    ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(NullTypesRealmProxy.copyOrUpdate(realm, fieldObjectNullObj, update, cache));
+                }
             } else {
-                ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(NullTypesRealmProxy.copyOrUpdate(realm, fieldObjectNullObj, update, cache));
+                ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(null);
+            }
+            return realmObject;
+        }
+    }
+
+    public static long insert(Realm realm, some.test.NullTypes object, Map<RealmModel,Long> cache) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+            return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
+        }
+        Table table = realm.getTable(some.test.NullTypes.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        NullTypesColumnInfo columnInfo = (NullTypesColumnInfo) realm.schema.getColumnInfo(some.test.NullTypes.class);
+        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+        cache.put(object, rowIndex);
+        String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNotNull();
+        if (realmGet$fieldStringNotNull != null) {
+            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull);
+        }
+        String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNull();
+        if (realmGet$fieldStringNull != null) {
+            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull);
+        }
+        Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNotNull();
+        if (realmGet$fieldBooleanNotNull != null) {
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull);
+        }
+        Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNull();
+        if (realmGet$fieldBooleanNull != null) {
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull);
+        }
+        byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNotNull();
+        if (realmGet$fieldBytesNotNull != null) {
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull);
+        }
+        byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNull();
+        if (realmGet$fieldBytesNull != null) {
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull);
+        }
+        Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNotNull();
+        if (realmGet$fieldByteNotNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue());
+        }
+        Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNull();
+        if (realmGet$fieldByteNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue());
+        }
+        Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNotNull();
+        if (realmGet$fieldShortNotNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue());
+        }
+        Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNull();
+        if (realmGet$fieldShortNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue());
+        }
+        Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNotNull();
+        if (realmGet$fieldIntegerNotNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue());
+        }
+        Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNull();
+        if (realmGet$fieldIntegerNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue());
+        }
+        Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNotNull();
+        if (realmGet$fieldLongNotNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue());
+        }
+        Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNull();
+        if (realmGet$fieldLongNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue());
+        }
+        Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNotNull();
+        if (realmGet$fieldFloatNotNull != null) {
+            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull);
+        }
+        Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNull();
+        if (realmGet$fieldFloatNull != null) {
+            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull);
+        }
+        Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNotNull();
+        if (realmGet$fieldDoubleNotNull != null) {
+            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull);
+        }
+        Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNull();
+        if (realmGet$fieldDoubleNull != null) {
+            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull);
+        }
+        java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNotNull();
+        if (realmGet$fieldDateNotNull != null) {
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime());
+        }
+        java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNull();
+        if (realmGet$fieldDateNull != null) {
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime());
+        }
+
+        some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
+        if (fieldObjectNullObj != null) {
+            Long cachefieldObjectNull = cache.get(fieldObjectNullObj);
+            if (cachefieldObjectNull == null) {
+                cachefieldObjectNull = NullTypesRealmProxy.insert(realm, fieldObjectNullObj, cache);
             }
+            Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull);
+        }
+        return rowIndex;
+    }
+
+    public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.NullTypes.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        NullTypesColumnInfo columnInfo = (NullTypesColumnInfo) realm.schema.getColumnInfo(some.test.NullTypes.class);
+        some.test.NullTypes object = null;
+        while (objects.hasNext()) {
+            object = (some.test.NullTypes) objects.next();
+            if(!cache.containsKey(object)) {
+                if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                    cache.put(object, ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex());
+                    continue;
+                }
+                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+                cache.put(object, rowIndex);
+                String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNotNull();
+                if (realmGet$fieldStringNotNull != null) {
+                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull);
+                }
+                String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNull();
+                if (realmGet$fieldStringNull != null) {
+                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull);
+                }
+                Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNotNull();
+                if (realmGet$fieldBooleanNotNull != null) {
+                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull);
+                }
+                Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNull();
+                if (realmGet$fieldBooleanNull != null) {
+                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull);
+                }
+                byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNotNull();
+                if (realmGet$fieldBytesNotNull != null) {
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull);
+                }
+                byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNull();
+                if (realmGet$fieldBytesNull != null) {
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull);
+                }
+                Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNotNull();
+                if (realmGet$fieldByteNotNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue());
+                }
+                Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNull();
+                if (realmGet$fieldByteNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue());
+                }
+                Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNotNull();
+                if (realmGet$fieldShortNotNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue());
+                }
+                Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNull();
+                if (realmGet$fieldShortNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue());
+                }
+                Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNotNull();
+                if (realmGet$fieldIntegerNotNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue());
+                }
+                Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNull();
+                if (realmGet$fieldIntegerNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue());
+                }
+                Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNotNull();
+                if (realmGet$fieldLongNotNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue());
+                }
+                Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNull();
+                if (realmGet$fieldLongNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue());
+                }
+                Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNotNull();
+                if (realmGet$fieldFloatNotNull != null) {
+                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull);
+                }
+                Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNull();
+                if (realmGet$fieldFloatNull != null) {
+                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull);
+                }
+                Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNotNull();
+                if (realmGet$fieldDoubleNotNull != null) {
+                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull);
+                }
+                Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNull();
+                if (realmGet$fieldDoubleNull != null) {
+                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull);
+                }
+                java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNotNull();
+                if (realmGet$fieldDateNotNull != null) {
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime());
+                }
+                java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNull();
+                if (realmGet$fieldDateNull != null) {
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime());
+                }
+
+                some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
+                if (fieldObjectNullObj != null) {
+                    Long cachefieldObjectNull = cache.get(fieldObjectNullObj);
+                    if (cachefieldObjectNull == null) {
+                        cachefieldObjectNull = NullTypesRealmProxy.insert(realm, fieldObjectNullObj, cache);
+                    }
+                    table.setLink(columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull);
+                }
+            }
+        }
+    }
+
+    public static long insertOrUpdate(Realm realm, some.test.NullTypes object, Map<RealmModel,Long> cache) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+            return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
+        }
+        Table table = realm.getTable(some.test.NullTypes.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        NullTypesColumnInfo columnInfo = (NullTypesColumnInfo) realm.schema.getColumnInfo(some.test.NullTypes.class);
+        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+        cache.put(object, rowIndex);
+        String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNotNull();
+        if (realmGet$fieldStringNotNull != null) {
+            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex);
+        }
+        String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNull();
+        if (realmGet$fieldStringNull != null) {
+            Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull);
         } else {
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(null);
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex);
+        }
+        Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNotNull();
+        if (realmGet$fieldBooleanNotNull != null) {
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex);
+        }
+        Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNull();
+        if (realmGet$fieldBooleanNull != null) {
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex);
+        }
+        byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNotNull();
+        if (realmGet$fieldBytesNotNull != null) {
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex);
+        }
+        byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNull();
+        if (realmGet$fieldBytesNull != null) {
+            Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex);
+        }
+        Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNotNull();
+        if (realmGet$fieldByteNotNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex);
+        }
+        Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNull();
+        if (realmGet$fieldByteNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex);
+        }
+        Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNotNull();
+        if (realmGet$fieldShortNotNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex);
+        }
+        Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNull();
+        if (realmGet$fieldShortNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex);
+        }
+        Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNotNull();
+        if (realmGet$fieldIntegerNotNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex);
+        }
+        Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNull();
+        if (realmGet$fieldIntegerNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex);
+        }
+        Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNotNull();
+        if (realmGet$fieldLongNotNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex);
+        }
+        Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNull();
+        if (realmGet$fieldLongNull != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex);
+        }
+        Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNotNull();
+        if (realmGet$fieldFloatNotNull != null) {
+            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex);
+        }
+        Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNull();
+        if (realmGet$fieldFloatNull != null) {
+            Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex);
+        }
+        Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNotNull();
+        if (realmGet$fieldDoubleNotNull != null) {
+            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex);
+        }
+        Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNull();
+        if (realmGet$fieldDoubleNull != null) {
+            Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex);
+        }
+        java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNotNull();
+        if (realmGet$fieldDateNotNull != null) {
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex);
+        }
+        java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNull();
+        if (realmGet$fieldDateNull != null) {
+            Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime());
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex);
+        }
+
+        some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
+        if (fieldObjectNullObj != null) {
+            Long cachefieldObjectNull = cache.get(fieldObjectNullObj);
+            if (cachefieldObjectNull == null) {
+                cachefieldObjectNull = NullTypesRealmProxy.insertOrUpdate(realm, fieldObjectNullObj, cache);
+            }
+            Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull);
+        } else {
+            Table.nativeNullifyLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex);
+        }
+        return rowIndex;
+    }
+
+    public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.NullTypes.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        NullTypesColumnInfo columnInfo = (NullTypesColumnInfo) realm.schema.getColumnInfo(some.test.NullTypes.class);
+        some.test.NullTypes object = null;
+        while (objects.hasNext()) {
+            object = (some.test.NullTypes) objects.next();
+            if(!cache.containsKey(object)) {
+                if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                    cache.put(object, ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex());
+                    continue;
+                }
+                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+                cache.put(object, rowIndex);
+                String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNotNull();
+                if (realmGet$fieldStringNotNull != null) {
+                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex);
+                }
+                String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNull();
+                if (realmGet$fieldStringNull != null) {
+                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex);
+                }
+                Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNotNull();
+                if (realmGet$fieldBooleanNotNull != null) {
+                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex);
+                }
+                Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNull();
+                if (realmGet$fieldBooleanNull != null) {
+                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex);
+                }
+                byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNotNull();
+                if (realmGet$fieldBytesNotNull != null) {
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex);
+                }
+                byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNull();
+                if (realmGet$fieldBytesNull != null) {
+                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex);
+                }
+                Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNotNull();
+                if (realmGet$fieldByteNotNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex);
+                }
+                Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNull();
+                if (realmGet$fieldByteNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex);
+                }
+                Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNotNull();
+                if (realmGet$fieldShortNotNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex);
+                }
+                Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNull();
+                if (realmGet$fieldShortNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex);
+                }
+                Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNotNull();
+                if (realmGet$fieldIntegerNotNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex);
+                }
+                Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNull();
+                if (realmGet$fieldIntegerNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex);
+                }
+                Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNotNull();
+                if (realmGet$fieldLongNotNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex);
+                }
+                Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNull();
+                if (realmGet$fieldLongNull != null) {
+                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex);
+                }
+                Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNotNull();
+                if (realmGet$fieldFloatNotNull != null) {
+                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex);
+                }
+                Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNull();
+                if (realmGet$fieldFloatNull != null) {
+                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex);
+                }
+                Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNotNull();
+                if (realmGet$fieldDoubleNotNull != null) {
+                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex);
+                }
+                Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNull();
+                if (realmGet$fieldDoubleNull != null) {
+                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex);
+                }
+                java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNotNull();
+                if (realmGet$fieldDateNotNull != null) {
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex);
+                }
+                java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNull();
+                if (realmGet$fieldDateNull != null) {
+                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime());
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex);
+                }
+
+                some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
+                if (fieldObjectNullObj != null) {
+                    Long cachefieldObjectNull = cache.get(fieldObjectNullObj);
+                    if (cachefieldObjectNull == null) {
+                        cachefieldObjectNull = NullTypesRealmProxy.insertOrUpdate(realm, fieldObjectNullObj, cache);
+                    }
+                    Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull);
+                } else {
+                    Table.nativeNullifyLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex);
+                }
+            }
         }
-        return realmObject;
     }
 
-    public static NullTypes createDetachedCopy(NullTypes realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
+    public static some.test.NullTypes createDetachedCopy(some.test.NullTypes realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
         if (currentDepth > maxDepth || realmObject == null) {
             return null;
         }
         CacheData<RealmModel> cachedObject = cache.get(realmObject);
-        NullTypes unmanagedObject;
+        some.test.NullTypes unmanagedObject;
         if (cachedObject != null) {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
             if (currentDepth >= cachedObject.minDepth) {
-                return (NullTypes)cachedObject.object;
+                return (some.test.NullTypes)cachedObject.object;
             } else {
-                unmanagedObject = (NullTypes)cachedObject.object;
+                unmanagedObject = (some.test.NullTypes)cachedObject.object;
                 cachedObject.minDepth = currentDepth;
             }
         } else {
-            unmanagedObject = new NullTypes();
+            unmanagedObject = new some.test.NullTypes();
             cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject));
         }
         ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldStringNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldStringNotNull());
@@ -1295,7 +2189,7 @@ public boolean equals(Object o) {
 
         String path = proxyState.getRealm$realm().getPath();
         String otherPath = aNullTypes.proxyState.getRealm$realm().getPath();
-        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;;
+        if (path != null ? !path.equals(otherPath) : otherPath != null) return false;
 
         String tableName = proxyState.getRow$realm().getTable().getName();
         String otherTableName = aNullTypes.proxyState.getRow$realm().getTable().getName();
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
index 861016434b..0edbe6cb1f 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
@@ -3,20 +3,22 @@
 
 import android.util.JsonReader;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.Row;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import java.io.IOException;
+import java.util.Collection;
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.HashSet;
+import java.util.IdentityHashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import org.json.JSONException;
 import org.json.JSONObject;
-import some.test.AllTypes;
 
 @io.realm.annotations.RealmModule
 class DefaultRealmModuleMediator extends RealmProxyMediator {
@@ -24,27 +26,27 @@
     private static final Set<Class<? extends RealmModel>> MODEL_CLASSES;
     static {
         Set<Class<? extends RealmModel>> modelClasses = new HashSet<Class<? extends RealmModel>>();
-        modelClasses.add(AllTypes.class);
+        modelClasses.add(some.test.AllTypes.class);
         MODEL_CLASSES = Collections.unmodifiableSet(modelClasses);
     }
 
     @Override
-    public Table createTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction) {
+    public Table createTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm) {
         checkClass(clazz);
 
-        if (clazz.equals(AllTypes.class)) {
-            return AllTypesRealmProxy.initTable(transaction);
+        if (clazz.equals(some.test.AllTypes.class)) {
+            return io.realm.AllTypesRealmProxy.initTable(sharedRealm);
         } else {
             throw getMissingProxyClassException(clazz);
         }
     }
 
     @Override
-    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction) {
+    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm, boolean allowExtraColumns) {
         checkClass(clazz);
 
-        if (clazz.equals(AllTypes.class)) {
-            return AllTypesRealmProxy.validateTable(transaction);
+        if (clazz.equals(some.test.AllTypes.class)) {
+            return io.realm.AllTypesRealmProxy.validateTable(sharedRealm, allowExtraColumns);
         } else {
             throw getMissingProxyClassException(clazz);
         }
@@ -54,8 +56,8 @@ public ColumnInfo validateTable(Class<? extends RealmModel> clazz, ImplicitTrans
     public List<String> getFieldNames(Class<? extends RealmModel> clazz) {
         checkClass(clazz);
 
-        if (clazz.equals(AllTypes.class)) {
-            return AllTypesRealmProxy.getFieldNames();
+        if (clazz.equals(some.test.AllTypes.class)) {
+            return io.realm.AllTypesRealmProxy.getFieldNames();
         } else {
             throw getMissingProxyClassException(clazz);
         }
@@ -65,21 +67,27 @@ public ColumnInfo validateTable(Class<? extends RealmModel> clazz, ImplicitTrans
     public String getTableName(Class<? extends RealmModel> clazz) {
         checkClass(clazz);
 
-        if (clazz.equals(AllTypes.class)) {
-            return AllTypesRealmProxy.getTableName();
+        if (clazz.equals(some.test.AllTypes.class)) {
+            return io.realm.AllTypesRealmProxy.getTableName();
         } else {
             throw getMissingProxyClassException(clazz);
         }
     }
 
     @Override
-    public <E extends RealmModel> E newInstance(Class<E> clazz, ColumnInfo columnInfo) {
-        checkClass(clazz);
-
-        if (clazz.equals(AllTypes.class)) {
-            return clazz.cast(new AllTypesRealmProxy(columnInfo));
-        } else {
-            throw getMissingProxyClassException(clazz);
+    public <E extends RealmModel> E newInstance(Class<E> clazz, Object baseRealm, Row row, ColumnInfo columnInfo, boolean acceptDefaultValue, List<String> excludeFields) {
+        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
+        try {
+            objectContext.set((BaseRealm) baseRealm, row, columnInfo, acceptDefaultValue, excludeFields);
+            checkClass(clazz);
+
+            if (clazz.equals(some.test.AllTypes.class)) {
+                return clazz.cast(new io.realm.AllTypesRealmProxy());
+            } else {
+                throw getMissingProxyClassException(clazz);
+            }
+        } finally {
+            objectContext.clear();
         }
     }
 
@@ -94,20 +102,100 @@ public String getTableName(Class<? extends RealmModel> clazz) {
         // generated by RealmProxy or the original type extending directly from RealmObject
         @SuppressWarnings("unchecked") Class<E> clazz = (Class<E>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass());
 
-        if (clazz.equals(AllTypes.class)) {
-            return clazz.cast(AllTypesRealmProxy.copyOrUpdate(realm, (AllTypes) obj, update, cache));
+        if (clazz.equals(some.test.AllTypes.class)) {
+            return clazz.cast(io.realm.AllTypesRealmProxy.copyOrUpdate(realm, (some.test.AllTypes) obj, update, cache));
+        } else {
+            throw getMissingProxyClassException(clazz);
+        }
+    }
+
+    @Override
+    public void insert(Realm realm, RealmModel object, Map<RealmModel, Long> cache) {
+        // This cast is correct because obj is either
+        // generated by RealmProxy or the original type extending directly from RealmObject
+        @SuppressWarnings("unchecked") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass());
+
+        if (clazz.equals(some.test.AllTypes.class)) {
+            io.realm.AllTypesRealmProxy.insert(realm, (some.test.AllTypes) object, cache);
+        } else {
+            throw getMissingProxyClassException(clazz);
+        }
+    }
+
+    @Override
+    public void insert(Realm realm, Collection<? extends RealmModel> objects) {
+        Iterator<? extends RealmModel> iterator = objects.iterator();
+        RealmModel object = null;
+        Map<RealmModel, Long> cache = new IdentityHashMap<RealmModel, Long>(objects.size());
+        if (iterator.hasNext()) {
+            //  access the first element to figure out the clazz for the routing below
+            object = iterator.next();
+            // This cast is correct because obj is either
+            // generated by RealmProxy or the original type extending directly from RealmObject
+            @SuppressWarnings("unchecked") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass());
+
+            if (clazz.equals(some.test.AllTypes.class)) {
+                io.realm.AllTypesRealmProxy.insert(realm, (some.test.AllTypes) object, cache);
+            } else {
+                throw getMissingProxyClassException(clazz);
+            }
+            if (iterator.hasNext()) {
+                if (clazz.equals(some.test.AllTypes.class)) {
+                    io.realm.AllTypesRealmProxy.insert(realm, iterator, cache);
+                } else {
+                    throw getMissingProxyClassException(clazz);
+                }
+            }
+        }
+    }
+
+    @Override
+    public void insertOrUpdate(Realm realm, RealmModel obj, Map<RealmModel, Long> cache) {
+        // This cast is correct because obj is either
+        // generated by RealmProxy or the original type extending directly from RealmObject
+        @SuppressWarnings("unchecked") Class<RealmModel> clazz = (Class<RealmModel>) ((obj instanceof RealmObjectProxy) ? obj.getClass().getSuperclass() : obj.getClass());
+
+        if (clazz.equals(some.test.AllTypes.class)) {
+            io.realm.AllTypesRealmProxy.insertOrUpdate(realm, (some.test.AllTypes) obj, cache);
         } else {
             throw getMissingProxyClassException(clazz);
         }
     }
 
+    @Override
+    public void insertOrUpdate(Realm realm, Collection<? extends RealmModel> objects) {
+        Iterator<? extends RealmModel> iterator = objects.iterator();
+        RealmModel object = null;
+        Map<RealmModel, Long> cache = new IdentityHashMap<RealmModel, Long>(objects.size());
+        if (iterator.hasNext()) {
+            //  access the first element to figure out the clazz for the routing below
+            object = iterator.next();
+            // This cast is correct because obj is either
+            // generated by RealmProxy or the original type extending directly from RealmObject
+            @SuppressWarnings("unchecked") Class<RealmModel> clazz = (Class<RealmModel>) ((object instanceof RealmObjectProxy) ? object.getClass().getSuperclass() : object.getClass());
+
+            if (clazz.equals(some.test.AllTypes.class)) {
+                io.realm.AllTypesRealmProxy.insertOrUpdate(realm, (some.test.AllTypes) object, cache);
+            } else {
+                throw getMissingProxyClassException(clazz);
+            }
+            if (iterator.hasNext()) {
+                if (clazz.equals(some.test.AllTypes.class)) {
+                    io.realm.AllTypesRealmProxy.insertOrUpdate(realm, iterator, cache);
+                } else {
+                    throw getMissingProxyClassException(clazz);
+                }
+            }
+        }
+    }
+
     @Override
     public <E extends RealmModel> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update)
             throws JSONException {
         checkClass(clazz);
 
-        if (clazz.equals(AllTypes.class)) {
-            return clazz.cast(AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, json, update));
+        if (clazz.equals(some.test.AllTypes.class)) {
+            return clazz.cast(io.realm.AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, json, update));
         } else {
             throw getMissingProxyClassException(clazz);
         }
@@ -118,8 +206,8 @@ public String getTableName(Class<? extends RealmModel> clazz) {
             throws IOException {
         checkClass(clazz);
 
-        if (clazz.equals(AllTypes.class)) {
-            return clazz.cast(AllTypesRealmProxy.createUsingJsonStream(realm, reader));
+        if (clazz.equals(some.test.AllTypes.class)) {
+            return clazz.cast(io.realm.AllTypesRealmProxy.createUsingJsonStream(realm, reader));
         } else {
             throw getMissingProxyClassException(clazz);
         }
@@ -131,11 +219,11 @@ public String getTableName(Class<? extends RealmModel> clazz) {
         // generated by RealmProxy or the original type extending directly from RealmObject
         @SuppressWarnings("unchecked") Class<E> clazz = (Class<E>) realmObject.getClass().getSuperclass();
 
-        if (clazz.equals(AllTypes.class)) {
-            return clazz.cast(AllTypesRealmProxy.createDetachedCopy((AllTypes) realmObject, 0, maxDepth, cache));
+        if (clazz.equals(some.test.AllTypes.class)) {
+            return clazz.cast(io.realm.AllTypesRealmProxy.createDetachedCopy((some.test.AllTypes) realmObject, 0, maxDepth, cache));
         } else {
             throw getMissingProxyClassException(clazz);
         }
     }
 
-}
\ No newline at end of file
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index 22dba1e930..c25a606f1f 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -1,53 +1,67 @@
 package io.realm;
 
 
+import android.annotation.TargetApi;
+import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
-import io.realm.RealmFieldType;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.Row;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
+import io.realm.log.RealmLog;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.Future;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
-import some.test.Simple;
 
-public class SimpleRealmProxy extends Simple
+public class SimpleRealmProxy extends some.test.Simple
         implements RealmObjectProxy, SimpleRealmProxyInterface {
 
-    static final class SimpleColumnInfo extends ColumnInfo {
+    static final class SimpleColumnInfo extends ColumnInfo
+            implements Cloneable {
 
-        public final long nameIndex;
-        public final long ageIndex;
+        public long nameIndex;
+        public long ageIndex;
 
         SimpleColumnInfo(String path, Table table) {
             final Map<String, Long> indicesMap = new HashMap<String, Long>(2);
             this.nameIndex = getValidColumnIndex(path, table, "Simple", "name");
             indicesMap.put("name", this.nameIndex);
-
             this.ageIndex = getValidColumnIndex(path, table, "Simple", "age");
             indicesMap.put("age", this.ageIndex);
 
             setIndicesMap(indicesMap);
         }
-    }
 
-    private final SimpleColumnInfo columnInfo;
-    private final ProxyState proxyState;
+        @Override
+        public final void copyColumnInfoFrom(ColumnInfo other) {
+            final SimpleColumnInfo otherInfo = (SimpleColumnInfo) other;
+            this.nameIndex = otherInfo.nameIndex;
+            this.ageIndex = otherInfo.ageIndex;
+
+            setIndicesMap(otherInfo.getIndicesMap());
+        }
+
+        @Override
+        public final SimpleColumnInfo clone() {
+            return (SimpleColumnInfo) super.clone();
+        }
+
+    }
+    private SimpleColumnInfo columnInfo;
+    private ProxyState proxyState;
     private static final List<String> FIELD_NAMES;
     static {
         List<String> fieldNames = new ArrayList<String>();
@@ -56,18 +70,46 @@
         FIELD_NAMES = Collections.unmodifiableList(fieldNames);
     }
 
-    SimpleRealmProxy(ColumnInfo columnInfo) {
-        this.columnInfo = (SimpleColumnInfo) columnInfo;
-        this.proxyState = new ProxyState(Simple.class, this);
+    SimpleRealmProxy() {
+        if (proxyState == null) {
+            injectObjectContext();
+        }
+        proxyState.setConstructionFinished();
+    }
+
+    private void injectObjectContext() {
+        final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
+        this.columnInfo = (SimpleColumnInfo) context.getColumnInfo();
+        this.proxyState = new ProxyState(some.test.Simple.class, this);
+        proxyState.setRealm$realm(context.getRealm());
+        proxyState.setRow$realm(context.getRow());
+        proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
+        proxyState.setExcludeFields$realm(context.getExcludeFields());
     }
 
     @SuppressWarnings("cast")
     public String realmGet$name() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.nameIndex);
     }
 
     public void realmSet$name(String value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         if (value == null) {
             proxyState.getRow$realm().setNull(columnInfo.nameIndex);
@@ -78,60 +120,84 @@
 
     @SuppressWarnings("cast")
     public int realmGet$age() {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         return (int) proxyState.getRow$realm().getLong(columnInfo.ageIndex);
     }
 
     public void realmSet$age(int value) {
+        if (proxyState == null) {
+            // Called from model's constructor. Inject context.
+            injectObjectContext();
+        }
+
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+        }
+
         proxyState.getRealm$realm().checkIfValid();
         proxyState.getRow$realm().setLong(columnInfo.ageIndex, value);
     }
 
-    public static Table initTable(ImplicitTransaction transaction) {
-        if (!transaction.hasTable("class_Simple")) {
-            Table table = transaction.getTable("class_Simple");
+    public static Table initTable(SharedRealm sharedRealm) {
+        if (!sharedRealm.hasTable("class_Simple")) {
+            Table table = sharedRealm.getTable("class_Simple");
             table.addColumn(RealmFieldType.STRING, "name", Table.NULLABLE);
             table.addColumn(RealmFieldType.INTEGER, "age", Table.NOT_NULLABLE);
             table.setPrimaryKey("");
             return table;
         }
-        return transaction.getTable("class_Simple");
+        return sharedRealm.getTable("class_Simple");
     }
 
-    public static SimpleColumnInfo validateTable(ImplicitTransaction transaction) {
-        if (transaction.hasTable("class_Simple")) {
-            Table table = transaction.getTable("class_Simple");
-            if (table.getColumnCount() != 2) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field count does not match - expected 2 but was " + table.getColumnCount());
+    public static SimpleColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
+        if (sharedRealm.hasTable("class_Simple")) {
+            Table table = sharedRealm.getTable("class_Simple");
+            final long columnCount = table.getColumnCount();
+            if (columnCount != 2) {
+                if (columnCount < 2) {
+                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 2 but was " + columnCount);
+                }
+                if (allowExtraColumns) {
+                    RealmLog.debug("Field count is more than expected - expected 2 but was %1$d", columnCount);
+                } else {
+                    throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 2 but was " + columnCount);
+                }
             }
             Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
             for (long i = 0; i < 2; i++) {
                 columnTypes.put(table.getColumnName(i), table.getColumnType(i));
             }
 
-            final SimpleColumnInfo columnInfo = new SimpleColumnInfo(transaction.getPath(), table);
+            final SimpleColumnInfo columnInfo = new SimpleColumnInfo(sharedRealm.getPath(), table);
 
             if (!columnTypes.containsKey("name")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'name' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'name' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("name") != RealmFieldType.STRING) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'String' for field 'name' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'name' in existing Realm file.");
             }
             if (!table.isColumnNullable(columnInfo.nameIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'name' is required. Either set @Required to field 'name' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'name' is required. Either set @Required to field 'name' or migrate using RealmObjectSchema.setNullable().");
             }
             if (!columnTypes.containsKey("age")) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Missing field 'age' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'age' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
             }
             if (columnTypes.get("age") != RealmFieldType.INTEGER) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Invalid type 'int' for field 'age' in existing Realm file.");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'int' for field 'age' in existing Realm file.");
             }
             if (table.isColumnNullable(columnInfo.ageIndex)) {
-                throw new RealmMigrationNeededException(transaction.getPath(), "Field 'age' does support null values in the existing Realm file. Use corresponding boxed type for field 'age' or migrate using RealmObjectSchema.setNullable().");
+                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'age' does support null values in the existing Realm file. Use corresponding boxed type for field 'age' or migrate using RealmObjectSchema.setNullable().");
             }
             return columnInfo;
         } else {
-            throw new RealmMigrationNeededException(transaction.getPath(), "The Simple class is missing from the schema for this Realm.");
+            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'Simple' class is missing from the schema for this Realm.");
         }
     }
 
@@ -144,9 +210,10 @@ public static String getTableName() {
     }
 
     @SuppressWarnings("cast")
-    public static Simple createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
+    public static some.test.Simple createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
-        Simple obj = realm.createObject(Simple.class);
+        final List<String> excludeFields = Collections.<String> emptyList();
+        some.test.Simple obj = realm.createObjectInternal(some.test.Simple.class, true, excludeFields);
         if (json.has("name")) {
             if (json.isNull("name")) {
                 ((SimpleRealmProxyInterface) obj).realmSet$name(null);
@@ -156,7 +223,7 @@ public static Simple createOrUpdateUsingJsonObject(Realm realm, JSONObject json,
         }
         if (json.has("age")) {
             if (json.isNull("age")) {
-                throw new IllegalArgumentException("Trying to set non-nullable field age to null.");
+                throw new IllegalArgumentException("Trying to set non-nullable field 'age' to null.");
             } else {
                 ((SimpleRealmProxyInterface) obj).realmSet$age((int) json.getInt("age"));
             }
@@ -165,9 +232,10 @@ public static Simple createOrUpdateUsingJsonObject(Realm realm, JSONObject json,
     }
 
     @SuppressWarnings("cast")
-    public static Simple createUsingJsonStream(Realm realm, JsonReader reader)
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    public static some.test.Simple createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        Simple obj = realm.createObject(Simple.class);
+        some.test.Simple obj = new some.test.Simple();
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
@@ -181,7 +249,7 @@ public static Simple createUsingJsonStream(Realm realm, JsonReader reader)
             } else if (name.equals("age")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    throw new IllegalArgumentException("Trying to set non-nullable field age to null.");
+                    throw new IllegalArgumentException("Trying to set non-nullable field 'age' to null.");
                 } else {
                     ((SimpleRealmProxyInterface) obj).realmSet$age((int) reader.nextInt());
                 }
@@ -190,43 +258,140 @@ public static Simple createUsingJsonStream(Realm realm, JsonReader reader)
             }
         }
         reader.endObject();
+        obj = realm.copyToRealm(obj);
         return obj;
     }
 
-    public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+    public static some.test.Simple copyOrUpdate(Realm realm, some.test.Simple object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
             throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
         }
         if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
             return object;
         }
-        return copy(realm, object, update, cache);
+        final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
+        RealmObjectProxy cachedRealmObject = cache.get(object);
+        if (cachedRealmObject != null) {
+            return (some.test.Simple) cachedRealmObject;
+        } else {
+            return copy(realm, object, update, cache);
+        }
+    }
+
+    public static some.test.Simple copy(Realm realm, some.test.Simple newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
+        RealmObjectProxy cachedRealmObject = cache.get(newObject);
+        if (cachedRealmObject != null) {
+            return (some.test.Simple) cachedRealmObject;
+        } else {
+            // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
+            some.test.Simple realmObject = realm.createObjectInternal(some.test.Simple.class, false, Collections.<String>emptyList());
+            cache.put(newObject, (RealmObjectProxy) realmObject);
+            ((SimpleRealmProxyInterface) realmObject).realmSet$name(((SimpleRealmProxyInterface) newObject).realmGet$name());
+            ((SimpleRealmProxyInterface) realmObject).realmSet$age(((SimpleRealmProxyInterface) newObject).realmGet$age());
+            return realmObject;
+        }
+    }
+
+    public static long insert(Realm realm, some.test.Simple object, Map<RealmModel,Long> cache) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+            return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
+        }
+        Table table = realm.getTable(some.test.Simple.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.schema.getColumnInfo(some.test.Simple.class);
+        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+        cache.put(object, rowIndex);
+        String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
+        if (realmGet$name != null) {
+            Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name);
+        }
+        Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age());
+        return rowIndex;
+    }
+
+    public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.Simple.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.schema.getColumnInfo(some.test.Simple.class);
+        some.test.Simple object = null;
+        while (objects.hasNext()) {
+            object = (some.test.Simple) objects.next();
+            if(!cache.containsKey(object)) {
+                if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                    cache.put(object, ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex());
+                    continue;
+                }
+                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+                cache.put(object, rowIndex);
+                String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
+                if (realmGet$name != null) {
+                    Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name);
+                }
+                Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age());
+            }
+        }
+    }
+
+    public static long insertOrUpdate(Realm realm, some.test.Simple object, Map<RealmModel,Long> cache) {
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+            return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
+        }
+        Table table = realm.getTable(some.test.Simple.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.schema.getColumnInfo(some.test.Simple.class);
+        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+        cache.put(object, rowIndex);
+        String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
+        if (realmGet$name != null) {
+            Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.nameIndex, rowIndex);
+        }
+        Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age());
+        return rowIndex;
     }
 
-    public static Simple copy(Realm realm, Simple newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
-        Simple realmObject = realm.createObject(Simple.class);
-        cache.put(newObject, (RealmObjectProxy) realmObject);
-        ((SimpleRealmProxyInterface) realmObject).realmSet$name(((SimpleRealmProxyInterface) newObject).realmGet$name());
-        ((SimpleRealmProxyInterface) realmObject).realmSet$age(((SimpleRealmProxyInterface) newObject).realmGet$age());
-        return realmObject;
+    public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.Simple.class);
+        long tableNativePtr = table.getNativeTablePointer();
+        SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.schema.getColumnInfo(some.test.Simple.class);
+        some.test.Simple object = null;
+        while (objects.hasNext()) {
+            object = (some.test.Simple) objects.next();
+            if(!cache.containsKey(object)) {
+                if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                    cache.put(object, ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex());
+                    continue;
+                }
+                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+                cache.put(object, rowIndex);
+                String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
+                if (realmGet$name != null) {
+                    Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name);
+                } else {
+                    Table.nativeSetNull(tableNativePtr, columnInfo.nameIndex, rowIndex);
+                }
+                Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age());
+            }
+        }
     }
 
-    public static Simple createDetachedCopy(Simple realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
+    public static some.test.Simple createDetachedCopy(some.test.Simple realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
         if (currentDepth > maxDepth || realmObject == null) {
             return null;
         }
         CacheData<RealmModel> cachedObject = cache.get(realmObject);
-        Simple unmanagedObject;
+        some.test.Simple unmanagedObject;
         if (cachedObject != null) {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
             if (currentDepth >= cachedObject.minDepth) {
-                return (Simple)cachedObject.object;
+                return (some.test.Simple)cachedObject.object;
             } else {
-                unmanagedObject = (Simple)cachedObject.object;
+                unmanagedObject = (some.test.Simple)cachedObject.object;
                 cachedObject.minDepth = currentDepth;
             }
         } else {
-            unmanagedObject = new Simple();
+            unmanagedObject = new some.test.Simple();
             cache.put(realmObject, new RealmObjectProxy.CacheData(currentDepth, unmanagedObject));
         }
         ((SimpleRealmProxyInterface) unmanagedObject).realmSet$name(((SimpleRealmProxyInterface) realmObject).realmGet$name());
@@ -239,4 +404,4 @@ public static Simple createDetachedCopy(Simple realmObject, int currentDepth, in
         return proxyState;
     }
 
-}
\ No newline at end of file
+}
diff --git a/realm/realm-jni/build.gradle b/realm/realm-jni/build.gradle
deleted file mode 100644
index 95650090c0..0000000000
--- a/realm/realm-jni/build.gradle
+++ /dev/null
@@ -1,365 +0,0 @@
-import java.security.MessageDigest
-
-ext.coreVersion = '1.0.1'
-// empty or comment out this to disable hash checking
-ext.coreSha256Hash = 'e132f5824dc31e683353fb0be91eb45cac702f88f8cee819499a1dfa7936aeac'
-ext.forceDownloadCore =
-        project.hasProperty('forceDownloadCore') ? project.getProperty('forceDownloadCore').toBoolean() : false
-// gcc is default for the NDK. It also produces smaller binaries
-ext.clang = project.hasProperty('clang') ? project.getProperty('clang').toBoolean() : false
-// Build with debug symbols
-ext.debugBuild = project.hasProperty('debugBuild') ? project.getProperty('debugBuild').toBoolean() : false
-// Strip the symbols from the so file or not. If debugBuild is true, this one will be always false.
-ext.stripSymbols = project.hasProperty('stripSymbols') ? project.getProperty('stripSymbols').toBoolean() : true
-// Set the core source code path. By setting this, the core will be built from source. And coreVersion will be read from
-// core source code.
-ext.coreSourcePath = project.hasProperty('coreSourcePath') ? project.getProperty('coreSourcePath') : null
-// The location of core archive.
-ext.coreArchiveDir = System.getenv("REALM_CORE_DOWNLOAD_DIR")
-// target ABIs to build(null means all).
-// To obtain the ABI of the connected device, execute "adb shell getprop ro.product.cpu.abi"
-ext.buildTargetAbis = project.hasProperty('buildTargetABIs') ? project.getProperty('buildTargetABIs').split(',').collect {it.trim()} : null
-
-def commonCflags = [ '-Os', '-std=c++11' ]
-// LTO and debugging don't play well together
-if (!ext.debugBuild) {
-    commonCflags += [ '-fvisibility=hidden', '-ffunction-sections', '-fdata-sections', '-flto' ]
-}
-
-enum Compiler {
-    GCC, CLANG
-}
-
-// Unfortunately the NDK has no consistency when it comes to naming.
-// This Class holds all the different names used and some more information
-class Toolchain {
-    // The standard name: arm, arm64, mips, x86
-    String name
-
-    // The name used when generating the standalone toolchain
-    String fullName
-
-    // The prefix commands use. i.e. arm-linux-androideabi-gcc
-    String commandPrefix
-
-    // Which version of each compiler to use
-    Map<Compiler, String> version
-
-    // The first Android platform to support this toolchain
-    int platform
-}
-
-// This class describes the specific target
-class Target {
-    // The name of the target. This is used for the task names
-    String name
-
-    // The name of the abi. It is also the name of the folder where the Android Gradle plugin
-    // expects to find the shared library
-    String abi
-
-    // The toolchain associated to this target
-    Toolchain toolchain
-
-    // The CFLAGS specific to this target
-    List<String> cflags
-}
-
-// We are using gcc 4.9 for all architectures
-def toolchains = [
-    new Toolchain( name:'arm', fullName:'arm-linux-androideabi', commandPrefix:'arm-linux-androideabi', version:[ (Compiler.GCC):'4.9', (Compiler.CLANG):'3.5' ], platform:8 ),
-    new Toolchain( name:'arm64', fullName:'aarch64-linux-android', commandPrefix:'aarch64-linux-android', version:[ (Compiler.GCC):'4.9', (Compiler.CLANG):'3.5' ], platform:21 ),
-    new Toolchain( name:'mips', fullName:'mipsel-linux-android', commandPrefix:'mipsel-linux-android', version:[ (Compiler.GCC):'4.9', (Compiler.CLANG):'3.5' ], platform:9 ),
-    new Toolchain( name:'x86', fullName:'x86', commandPrefix:'i686-linux-android', version:[ (Compiler.GCC):'4.9', (Compiler.CLANG):'3.5' ], platform:9 ),
-    new Toolchain( name:'x86_64', fullName:'x86_64', commandPrefix:'x86_64-linux-android', version:[ (Compiler.GCC):'4.9', (Compiler.CLANG):'3.5' ], platform:21 )
-]
-
-def allTargets = [
-    new Target( name:'arm',     abi:'armeabi',     toolchain:toolchains.find {it.name == 'arm'},    cflags:[ '-mthumb' ] ),
-    new Target( name:'arm-v7a', abi:'armeabi-v7a', toolchain:toolchains.find {it.name == 'arm'},    cflags:[ '-mthumb', '-march=armv7-a', '-mfloat-abi=softfp', '-mfpu=vfpv3-d16' ] ),
-    new Target( name:'arm64',   abi:'arm64-v8a',   toolchain:toolchains.find {it.name == 'arm64'},  cflags:[] ),
-    new Target( name:'mips',    abi:'mips',        toolchain:toolchains.find {it.name == 'mips'},   cflags:[] ),
-    new Target( name:'x86',     abi:'x86',         toolchain:toolchains.find {it.name == 'x86'},    cflags:[] ),
-    new Target( name:'x86_64',  abi:'x86_64',      toolchain:toolchains.find {it.name == 'x86_64'}, cflags:[] )
-]
-
-def targets
-if (ext.buildTargetAbis == null) {
-    targets = allTargets;
-} else {
-    targets = ext.buildTargetAbis.collect { targetAbi ->
-        def target = allTargets.find {it.abi == targetAbi}
-        if (!target) {
-            throw new GradleException("Warning: no target ABIs found for '${targetAbi}'." +
-                    " Please check 'buildTargetABIs' property." +
-                    " Supprted ABIs are ${allTargets.collect {it.abi}. join(', ')}.")
-        }
-        return target
-    }
-}
-
-buildscript {
-    repositories {
-        jcenter()
-    }
-    dependencies {
-        classpath 'de.undercouch:gradle-download-task:2.0.0'
-    }
-}
-
-apply plugin: 'de.undercouch.download'
-
-if (ext.debugBuild) {
-    // Debug build should never strip symbols
-    ext.stripSymbols = false
-}
-if (ext.coreSourcePath) {
-    // Run the "sh build.sh get-version" to get the core version.
-    ext.coreVersion = "sh build.sh get-version".execute([], file(coreSourcePath)).text.trim()
-}
-
-def getNdk() {
-    if (!System.env.NDK_HOME) {
-        throw new GradleException('The NDK_HOME environment variable is not set.')
-    }
-    def ndkDir = file(System.env.NDK_HOME)
-    if (!ndkDir.directory) {
-        throw new GradleException('The path provided in the NDK_HOME environment variable is not a folder.')
-    }
-    if (!file("${ndkDir}/RELEASE.TXT").file) {
-        throw new GradleException('The path provided in the NDK_HOME environment variable does not seem to be an Android NDK.')
-    }
-    def detectedNdkVersion = file("${ndkDir}/RELEASE.TXT").text.trim().split()[0].split('-')[0]
-    if (detectedNdkVersion != ndkVersion) {
-        throw new GradleException("Your NDK version: ${detectedNdkVersion}. Realm JNI should be compiled with the version ${ndkVersion} of NDK.")
-    }
-    return ndkDir
-}
-
-def getStrippedExt() {
-    return stripSymbols ? "-stripped" : ""
-}
-
-def getDebugExt() {
-    return debugBuild ? "-dbg" : ""
-}
-
-if (!ext.coreArchiveDir) {
-    ext.coreArchiveDir = ".."
-}
-ext.coreArchiveFile = rootProject.file("${ext.coreArchiveDir}/core-android-${project.coreVersion}.tar.gz")
-ext.coreDir = file("${buildDir}/core-${project.coreVersion}")
-
-def coreDownloaded = false
-
-task downloadCore(group: 'build setup', description: 'Download the latest version of realm core') {
-    def isHashCheckingEnabled = {
-        return project.hasProperty('coreSha256Hash') && !project.coreSha256Hash.empty
-    }
-
-    def calcSha256Hash = {File targetFile ->
-        MessageDigest sha = MessageDigest.getInstance("SHA-256");
-        Formatter hexHash = new Formatter()
-        sha.digest(targetFile.bytes).each { b -> hexHash.format('%02x', b) }
-        return hexHash.toString()
-    }
-
-    def shouldDownloadCore = {
-        if (!project.coreArchiveFile.exists()) {
-            return true
-        }
-        if (project.forceDownloadCore) {
-            return true;
-        }
-        if (!isHashCheckingEnabled()) {
-            println "Skipping hash check(empty \'coreSha256Hash\')."
-            return false
-        }
-
-        def calculatedHash = calcSha256Hash(project.coreArchiveFile)
-        if (project.coreSha256Hash.equalsIgnoreCase(calculatedHash)) {
-            return false
-        }
-
-        println "Existing archive hash mismatch(Expected: ${project.coreSha256Hash.toLowerCase()}" +
-                " but got ${calculatedHash.toLowerCase()}). Download new version."
-        return true
-    }
-
-    doLast {
-        if (shouldDownloadCore()) {
-            download {
-                src "http://static.realm.io/downloads/core/realm-core-android-${project.coreVersion}.tar.gz"
-                dest project.coreArchiveFile
-                onlyIfNewer false
-            }
-            coreDownloaded = true
-
-            if (isHashCheckingEnabled()) {
-                def calculatedHash = calcSha256Hash(project.coreArchiveFile)
-                if (!project.coreSha256Hash.equalsIgnoreCase(calculatedHash)) {
-                    throw new GradleException("Invalid checksum for file '" +
-                            "${project.coreArchiveFile.getName()}'. Expected " +
-                            "${project.coreSha256Hash.toLowerCase()} but got " +
-                            "${calculatedHash.toLowerCase()}.");
-                }
-            } else {
-                println 'Skipping hash check(empty \'coreSha256Hash\').'
-            }
-        }
-    }
-}
-
-task compileCore(group: 'build setup', description: 'Compile the core library from source code') {
-    // Build the library from core source code
-    doFirst {
-        if (!coreSourcePath) {
-            throw new GradleException('The coreSourcePath is not set.')
-        }
-        exec {
-            workingDir = coreSourcePath
-            commandLine = [
-                    "bash",
-                    "build.sh",
-                    "build-android"
-            ]
-        }
-    }
-
-    // Copy the core tar ball
-    doLast {
-        copy {
-            from "${coreSourcePath}/realm-core-android-${coreVersion}.tar.gz"
-            into project.coreArchiveFile.parent
-            rename "realm-core-android-${coreVersion}.tar.gz", "core-android-${coreVersion}.tar.gz"
-        }
-    }
-}
-
-task deployCore(group: 'build setup', description: 'Deploy the latest version of realm core') {
-    dependsOn {
-        coreSourcePath ? compileCore : downloadCore
-    }
-
-    outputs.upToDateWhen {
-        // Clean up the coreDir if it is newly downloaded or compiled from source
-        if (coreDownloaded || coreSourcePath) {
-            return false
-        }
-
-        return project.coreDir.exists()
-    }
-
-    doLast {
-        exec {
-            commandLine = [
-                    'rm',
-                    '-rf',
-                    project.coreDir.getAbsolutePath()
-            ]
-        }
-        copy {
-            from tarTree(project.coreArchiveFile)
-            into project.coreDir
-        }
-        for (target in targets) {
-            exec {
-                commandLine = [
-                        'make',
-                        '-C', "${projectDir}/src",
-                        "BASE_DENOM=${target.name}",
-                        'LIB_SUFFIX_SHARED=.so',
-                        'clean'
-                ]
-            }
-        }
-    }
-}
-
-toolchains.each { toolchain ->
-    def ndkDir = getNdk()
-    task "generateNdkToolchain${toolchain.name.capitalize()}"(type: Exec) {
-        group 'build setup'
-        description "Generate the NDK standalone toolchain for the ${toolchain.name.capitalize()} platform"
-        outputs.dir file("${buildDir}/standalone-toolchains/${toolchain.name}")
-        commandLine = [
-            "bash",
-            "${ndkDir}/build/tools/make-standalone-toolchain.sh",
-            "--platform=android-${toolchain.platform}",
-            "--install-dir=${buildDir}/standalone-toolchains/${toolchain.name}",
-            "--toolchain=${toolchain.fullName}-${clang?'clang'+toolchain.version[Compiler.CLANG]:toolchain.version[Compiler.GCC]}"
-        ]
-    }
-}
-
-targets.each { target ->
-    task "buildAndroidJni${target.name.capitalize()}"(type: Exec) {
-        group 'build'
-        description "Build the Android JNI shared library for the ${target.name.capitalize()} platform"
-        dependsOn deployCore
-        dependsOn "generateNdkToolchain${target.toolchain.name.capitalize()}"
-        environment PATH: "${buildDir}/standalone-toolchains/${target.toolchain.name}/bin:${System.env.PATH}"
-        environment CC: "${target.toolchain.commandPrefix}-${clang?'clang':'gcc'}"
-        environment STRIP: "${target.toolchain.commandPrefix}-strip -o librealm-jni-${target.name}-stripped.so"
-        environment REALM_ANDROID: '1'
-        commandLine = [
-            'make',
-            "-j${Runtime.getRuntime().availableProcessors() * 2}",
-            "-l${Runtime.getRuntime().availableProcessors()}",
-            '-C', "${projectDir}/src",
-            "CC_IS=${clang?'clang':'gcc'}",
-            "REALM_CFLAGS_COMMON=-Wno-variadic-macros -DREALM_HAVE_CONFIG -DPIC -I${project.coreDir}/include",
-            "CFLAGS_ARCH=${(commonCflags + target.cflags).join(' ')}",
-            "BASE_DENOM=${target.name}",
-            "REALM_LDFLAGS_COMMON=-lrealm-android-${target.name} -lstdc++ -lsupc++ -llog -L${project.coreDir} -Wl,--gc-sections -Wl,-soname,librealm-jni.so",
-            'LIB_SUFFIX_SHARED=.so',
-            "librealm-jni-${target.name}${getDebugExt()}.so"
-        ]
-    }
-
-    task "copyAndroidJni${target.name.capitalize()}"(dependsOn: "buildAndroidJni${target.name.capitalize()}") << {
-        copy {
-            from "${projectDir}/src/librealm-jni-${target.name}${getDebugExt()}${getStrippedExt()}.so"
-            into "${projectDir}/../realm-library/src/main/jniLibs/${target.abi}"
-            rename "librealm-jni-${target.name}${getDebugExt()}${getStrippedExt()}.so", 'librealm-jni.so'
-        }
-
-        // Store the unstripped version
-        copy {
-            from "${projectDir}/src/librealm-jni-${target.name}${getDebugExt()}.so"
-            into "${buildDir}/outputs/jniLibs-unstripped/${target.abi}"
-            rename "librealm-jni-${target.name}${getDebugExt()}.so", 'librealm-jni.so'
-        }
-    }
-}
-
-task buildAndroidJni(group: 'build', description: 'Build the Android JNI shared library for all the supported platforms') {
-    targets.each { target ->
-        dependsOn "copyAndroidJni${target.name.capitalize()}"
-    }
-}
-
-task clean(type: Delete) {
-    outputs.upToDateWhen {
-        project.hasProperty('dontCleanJniFiles')
-    }
-
-    delete project.buildDir
-
-    delete fileTree(dir: "${projectDir}/../realm-library/src/main/jniLibs/", include: '**/librealm-jni*.so')
-    delete fileTree(dir: "${projectDir}/src/", include: '**/librealm-jni*-stripped.so')
-
-    doLast {
-        targets.each { target ->
-            exec {
-                commandLine = [
-                        'make',
-                        '-C', "${projectDir}/src",
-                        "BASE_DENOM=${target.name}",
-                        'LIB_SUFFIX_SHARED=.so',
-                        'clean'
-                ]
-            }
-        }
-    }
-}
diff --git a/realm/realm-jni/generate-jni-headers.sh b/realm/realm-jni/generate-jni-headers.sh
deleted file mode 100755
index 62e34ef83f..0000000000
--- a/realm/realm-jni/generate-jni-headers.sh
+++ /dev/null
@@ -1,18 +0,0 @@
-#!/bin/bash
-#
-# Generate header file for JNI calls
-#
-# Assumption: the .java files have been compiled
-# 1. build project using Android Studio (or gradle); unit tests will probably fail due to missing native methods
-# 2. run this script
-# 3. rebuild project using Android Studio (or gradle)
-
-# Setting up
-CLASSDIR="$(pwd)/../realm/build/intermediates/classes/release/"
-JNIDIR="$(pwd)/src"
-
-# Generate the headers
-(cd "$CLASSDIR" && javah -jni -classpath "$CLASSDIR" -d "$JNIDIR" io.realm.internal.Group io.realm.internal.LinkView io.realm.internal.Row io.realm.internal.SharedGroup io.realm.internal.SubtableSchema io.realm.internal.Table io.realm.internal.TableQuery io.realm.internal.TableView io.realm.internal.Util io.realm.internal.Version)
-
-# Remove "empty" header files (they have 13 lines)
-wc -l "$JNIDIR"/*.h | grep " 13 " | awk '{print $2}' | xargs rm -f
diff --git a/realm/realm-jni/generic.mk b/realm/realm-jni/generic.mk
deleted file mode 100644
index 9b0d6fdf55..0000000000
--- a/realm/realm-jni/generic.mk
+++ /dev/null
@@ -1,1971 +0,0 @@
-# Generic makefile that captures some of the ideas of GNU Automake,
-# especially with respect to naming targets.
-#
-# Author: Kristian Spangsege
-#
-# Version: 1.0.2
-#
-# This makefile requires GNU Make. It has been tested with version
-# 3.81, and it is known to work well on both Linux and OS X.
-#
-#
-# Major goals
-# -----------
-#
-# clean ........ Delete targets and other files that are produced
-#                while building.
-#
-# build (default) Build convenience libraries (`noinst_LIBRARIES`)
-#                plus everything that `install-only` wants to install
-#                (when disregarding `INSTALL_FILTER`). If necessary,
-#                the convenience libraries will also be built in
-#                'debug' mode.
-#
-# install ...... Same as `build` followed by `install-only`.
-#
-# uninstall .... Uninstall everything that `install` would install.
-#
-# install-only . Installs `HEADERS`, `LIBRARIES`, `PROGRAMS`, and
-#                `DEV_PROGRAMS`. Whether static libraries and/or
-#                'debug' mode versions are also installed depends on
-#                various configuration parameters. Note that
-#                `INSTALL_FILTER` can be used to select a subset of
-#                the above.
-#
-# ### Selective building
-#
-# release ...... Builds `LIBRARIES`, `noinst_LIBRARIES`, `PROGRAMS`,
-#                `DEV_PROGRAMS`, and `noinst_PROGRAMS` in 'release'
-#                mode.
-#
-# nodebug ...... Builds everything that `release` does, plus static
-#                versions installable libraries (`LIBRARIES`) in
-#                'release' mode.
-#
-# debug ........ Builds everything that `release` does, but in 'debug'
-#                mode.
-#
-# cover ........ Builds everything that `release` does, but in 'code
-#                coverage' mode.
-#
-# everything ... Builds `LIBRARIES`, `noinst_LIBRARIES`,
-#                `check_LIBRARIES`, `PROGRAMS`, `DEV_PROGRAMS`, and
-#                `noinst_PROGRAMS` in both 'release' and 'debug' mode.
-#
-# ### Testing
-#
-# check ......... Build `LIBRARIES`, `noinst_LIBRARIES`,
-#                 `check_LIBRARIES`, `PROGRAMS`, and `check_PROGRAMS`
-#                 in 'release' mode, then run all `check_PROGRAMS`.
-#
-# check-debug ... Same as `check`, but in 'debug' mode.
-#
-# check-cover ... Same as `check`, but in 'code coverage' mode.
-#
-# memcheck, memcheck-debug Same as `check` and `check-debug`
-#                 respectively, but runs each program under Valgrind.
-#
-# check-norun, check-debug-norun, check-cover-norun Same as `check`,
-#                 `check-debug`, and `check-cover` respectively, but
-#                 stop after building.
-#
-#
-# Building installable programs and libraries
-# -------------------------------------------
-#
-# Here is an example of a complete `Makefile` that uses `generic.mk`
-# to build a program called `myprog` out of two source files called
-# `foo.cpp` and `bar.cpp`:
-#
-#   bin_PROGRAMS = myprog
-#   myprog_SOURCES = foo.cpp bar.cpp
-#   include generic.mk
-#
-# The `bin` in `bin_PROGRAMS` means that your program will be
-# installed in the directory specified by the `bindir` variable which
-# is set to `/usr/local/bin` by default. This can be overridden by
-# setting `prefix`, `exec_prefix`, or `bindir`.
-#
-# Note: You can place `generic.mk` anywhere you like inside your
-# project, but you must always refer to it by a relative path, and if
-# you have multiple `Makefile`s in multiple directories, they must all
-# refer to the same `generic.mk`.
-#
-# Here is how to build a library:
-#
-#   include_HEADERS = foo.hpp
-#   lib_LIBRARIES = libfoo.a
-#   libfoo_a_SOURCES = libfoo.cpp
-#
-# Again, the `lib` prefix in `lib_LIBRARIES` means that your library
-# will be installed in the directory specified by the `libdir`
-# variable which is typically set to `/usr/local/lib` by default. The
-# exact default path depends on the chosen installation prefix as well
-# as platform policies, for example, on a 64 bit Fedora, it will be
-# `/usr/local/lib64`. This can be overridden by setting `prefix`,
-# `exec_prefix`, or `libdir`.
-#
-# The `lib` prefix in `libfoo.a` is mandatory for all installed
-# libraries. The `.a` suffix is mandatory for both installed an
-# non-installed libraries. The actual extension of the installed
-# library is not necessarily going to be `.a`. For a shared library on
-# Linux, it will be `.so` by default. The important point is that the
-# specified library name is a logical name that is mapped to one or
-# more physical names by `generic.mk`.
-#
-# Note that `.` is replaced by `_` when referring to `libfoo.a` in
-# `libfoo_a_SOURCES`. In general, when a target (program or library)
-# name is used as part of a variable name, any character that is
-# neither alphanumeric nor an underscore, is converted to an
-# underscore.
-#
-# Installed libraries are generally accompanied by one or more headers
-# to be included by applications that use the library. Such headers
-# must be listed in the `include_HEADERS` variable. Headers are
-# installed in `/usr/local/include` by default, but this can be
-# changed by setting the `prefix` or `includedir` variable. Note also
-# that headers can be installed in a subdirectory of
-# `/usr/local/include` or even into a multi-level hierarchy of
-# subdirectories (see the 'Subdirectories' section for more on this).
-#
-# To build more than one program, or more than one library, simply
-# list all of them in `bin_PROGRAMS` or `lib_LIBRARIES`. For
-# example:
-#
-#   bin_PROGRAMS = hilbert banach
-#   hilbert_SOURCES = ...
-#   banach_SOURCES = ...
-#
-# Here is how to build a library as well as a program that uses the
-# library:
-#
-#   lib_LIBRARIES = libmyparser.a
-#   bin_PROGRAMS = parser
-#   libmyparser_a_SOURCES = myparser.c
-#   parser_SOURCES = parser.c
-#   parser_LIBS = libmyparser.a
-#
-# I you have two libraries, and one depends on the other:
-#
-#   lib_LIBRARIES = libfoo.a libbar.a
-#   libbar_a_LIBS = libfoo.a
-#
-# The installation directory for programs, libraries, and headers is
-# determined by the primary prefix being used. Note that `PROGRAMS`,
-# `LIBRARIES`, and `HEADERS` are primaries, and that `bin` is a
-# primary prefix in `bin_PROGRAMS`, for example. The following primary
-# prefixes are supported directly by `generic.mk`:
-#
-#   Prefix     Variable    Installation directory  Default value
-#   ----------------------------------------------------------------------------
-#   bin        bindir      $(exec_prefix)/bin      (/usr/local/bin)
-#   sbin       sbindir     $(exec_prefix)/sbin     (/usr/local/sbin)
-#   lib        libdir      $(exec_prefix)/lib      (/usr/local/lib)         (*1)
-#   libexec    libexecdir  $(exec_prefix)/libexec  (/usr/local/libexec)
-#   include    includedir  $(prefix)/include       (/usr/local/include)
-#   subinclude includedir  $(prefix)/include/...   (/usr/local/include/...) (*2)
-#
-#   (*1) The actual default value depends on the platform.
-#   (*2) Only available when `INCLUDE_ROOT` is specified.
-#
-# You can also install a program, a library, or a header into a
-# non-default directory by defining a custom primary prefix. This is
-# usefull when you want (for other purposes) to maintain the default
-# values of the standard prefixes. Here is an example:
-#
-#   EXTRA_PRIMARY_PREFIXES = libhome
-#   libhomedir = /usr/lib/mydeamon/bin
-#   libhome_PROGRAMS = mydaemon
-#
-# When doing 'filtered installs' (using `make install
-# INSTALL_FILTER=...`) there is a distinction between two categories
-# of programs, ordinary programs and 'developer programs'. When a
-# project that provides a library gets distributed in compiled form,
-# it is customary to offer two packages, the main one, that provides
-# the shared library, and a secondary one that provides the header
-# files. Some such projects offer programs that are packaged together
-# with the shared library, and other programs that are packaged
-# together with the headers. The latter category is what we refer to
-# as 'developer programs' when working with filtered installs.
-#
-# To mark a program as a 'developer program' use the special primary
-# prefix 'DEV' as in the following example:
-#
-#   DEV_PROGRAMS = mylib-config
-#   mylib_config_SOURCES = ...
-#
-# These programs are installed into the same directory as
-# `bin_PROGRAMS`.
-#
-#
-# Convenience libraries
-# ---------------------
-#
-# A convenience library is one that is not installed, but gets linked
-# statically into programs that are built as part of the same
-# project. Convenience libraries are created by using the special
-# primary prefix `noinst`, for example:
-#
-#   noinst_LIBRARIES = util.a
-#   bin_PROGRAMS = foo
-#   foo_SOURCES = foo.cpp
-#   foo_LIBS = util.a
-#
-# Note that in contrast to installed libraries, names of convenience
-# libraries are not required to have `lib` as a prefix, but the `.a`
-# suffix is still mandatory. Additionally, convenience library names
-# do not have to be unique. Indeed, it is valid for a program to be
-# linked against two convenience libraries of the same name, as long
-# as they reside in different subdirectories within the
-# project. Installed libraries, on the other hand, need to have
-# system-wide unique names.
-#
-# It is an error to list a convenience library as a dependency of
-# another convenience library or as a dependency of an installed
-# library. Only programs can be declared to depend on convenience
-# libraries.
-#
-# A convenience library such as `util.a` can be made to depend on
-# project-local installed libraries by listing them in the
-# `util_a_LIBS` variable. This can be done because code in `util.a`
-# depends on those other libraries, or it can be done simply to avoid
-# specifying them repeatedly for multiple programs. On top of that, it
-# is possible to attach a set of extra linker flags to a convenience
-# library, to be used when linking programs against it. Such flags are
-# listed in `util_a_LDFLAGS`. This can be used, for example, to
-# specify linking against system libraries or other separately
-# installed libraries.
-#
-#
-# Installed programs
-# ------------------
-#
-# If a program, that is supposed to be installed, is linked against a
-# locally built shared library, then `generic.mk` will pass the
-# appropriate `-rpath` option to the program linker, such that the
-# dynamic linker can find the library in its installed
-# location. Unfortunately this does not enable the program to find the
-# locally built library, and therefore it will generally not be
-# possible to execute the program until after the library is
-# installed.
-#
-# To work around this problem, `generic.mk` will create an extra
-# version of the program, where it sets the `RPATH` in such a way that
-# the (yet to be installed) library can be found. The name of the
-# extra version is constructed by appending `-noinst` to the name of
-# the regular version. The extra 'noinst' version is created only for
-# testing purposes, and it will not be included during
-# installation. It should be noted that the extra 'noinst' version is
-# created only for programs that are linked against locally built,
-# shared libraries.
-#
-# The extra 'noinst' versions of installed programs, as well as test
-# programs and programs declared using the special primary prefix
-# `noinst`, are all configured with relative `RPATH`s. This means that
-# they will continue to work even when the project is relocated to a
-# different directory, as long as the internal directory structure
-# remains the same.
-#
-# Note that the standard installation procedure, that places targets
-# in system directories according to category (`/usr/local/bin`,
-# `/usr/local/lib`, ...), does not in general preserve the relative
-# paths between targets with respect to how they occur in your project
-# directory. Further more, the standard installation procedure is
-# based upon the idea that the final installed location of targets is
-# specified and fixed at build time.
-#
-# As a special option, `generic.mk` can be asked to completely disable
-# its support for installation, and instead link all programs as if
-# they had been declared as 'noinst' programs in the first place. This
-# mode also disables the creation of the extra 'noinst' versions (as
-# they would be redundant), and it will disable shared library
-# versioning, that is, it will build each library as if no version was
-# specified for it (see 'Library versioning' below). This mode is
-# enabled by setting the environment variable `ENABLE_NOINST_BUILD` to
-# a non-empty value. Be sure to do a `make clean` when you switch
-# between 'noinst' and regular mode.
-#
-#
-# Programs that are not installed
-# -------------------------------
-#
-# Sometimes it is desirable to build a program that is not supposed to
-# be installed when running `make install`. One reason could be that
-# the program is used only for testing. Such programs are created by
-# using the special primary prefix `noinst`, for example:
-#
-#   noinst_PROGRAMS = performance
-#
-# There is another related category of programs called 'test programs'
-# that are both built and executed when running `make test`. These
-# programs are created by using the `check` primary prefix, and are
-# also not installed:
-#
-#   check_PROGRAMS = test_foo test_bar
-#
-# It is also possible to create a convenience library that is built
-# only when 'test programs' are built. List libraries of this kind in
-# `check_LIBRARIES`.
-#
-#
-# Subdirectories
-# --------------
-#
-# In larger projects it is desirable to organize the source files into
-# multiple subdirectories. This can be done in two ways, using a
-# single `Makefile` or using multiple `Makefile`s. When using a single
-# `Makefile`, refer to the source files using relative paths as
-# follows:
-#
-#   myprog_SOURCES = foo/alpha.cpp bar/beta.cpp
-#
-# The alternative is to use multiple `Makefile`s. This requires one or
-# more subdirectories each one with an extra subordinate
-# `Makefile`. The top-level `Makefile` must then use the `SUBDIRS`
-# variable to list each of the involved subdirectories. When there is
-# a dependency between two subdirectories, the top-level `Makefile`
-# must declare this. Here is an example:
-#
-#   Makefile:
-#     SUBDIRS = foo bar
-#     bar_DEPS = foo
-#     include generic.mk
-#
-#   foo/Makefile:
-#     lib_LIBRARIES = util.a
-#     util_a_SOURCES = ...
-#     include ../generic.mk
-#
-#   bar/Makefile:
-#     bin_PROGRAMS = myprog
-#     myprog_SOURCES = ...
-#     myprog_LIBS = ../foo/util.a
-#
-# To declare that a subdirectory `foo` depends on stuff in the current
-# directory (presumably libraries), include `.` in `foo_DEPS`. To
-# declare that the current directory depends on stuff in a
-# subdirectory, list that subdirectory in the `DIR_DEPS` variable as
-# in the following example:
-#
-#   Makefile:
-#     SUBDIRS = util
-#     DIR_DEPS = util
-#     bin_PROGRAMS = myprog
-#     myprog_SOURCES = ...
-#     myprog_LIBS = util/util.a
-#     include generic.mk
-#
-#   util/Makefile:
-#     noinst_LIBRARIES = util.a
-#     util_a_SOURCES = ...
-#     include ../generic.mk
-#
-# FIXME: Mention `PASSIVE_SUBDIRS` (such directories are cleaned but
-# not otherwise included during recursive `make` invocations).
-#
-#
-# Compiler and linker flags
-# -------------------------
-#
-# Extra compiler and linker flags can be specified for each target
-# (program or library):
-#
-#   bin_PROGRAMS = myprog
-#   myprog_SOURCES = foo.cpp bar.cpp
-#   myprog_CFLAGS = -Wno-long-long
-#   myprog_LDFLAGS = -lparser
-#
-# Compiler flags can also be specified for individual object files,
-# for example, to add flags just to the compilation of `foo.o`:
-#
-#   foo_o_CFLAGS = -I/opt/parser-1.5/include
-#
-# Compiler and linker flags can be specified for all targets in a
-# directory (the directory containing the `Makefile`) as follows:
-#
-#   DIR_CFLAGS = ...
-#   DIR_LDFLAGS = ...
-#
-# In a project that consists of multiple subprojects (each one in its
-# own subdirectory and with its own `Makefile`,) compiler and linker
-# flags can be specified for all targets in the project by setting
-# `PROJECT_CFLAGS` and `PROJECT_LDFLAGS` in `project.mk`:
-#
-#   PROJECT_CFLAGS = ...
-#   PROJECT_LDFLAGS = ...
-#
-# All these compiler and linker flag specifications are additive.
-#
-#
-# Debug and coverage analysis modes
-# ---------------------------------
-#
-#   foo_o_CFLAGS_OPTIM
-#   foo_o_CFLAGS_DEBUG
-#   foo_o_CFLAGS_COVER
-#
-#
-# Library versioning
-# ------------------
-#
-#   lib_LIBRARIES = libmyparser.a
-#   libmyparser_a_VERSION = 4:0:0
-#
-# Format: CURRENT[:REVISION[:AGE]]
-#
-# At each new public release:
-#   If the interface has changed at all:
-#     Increment CURRENT and reset REVISION to zero
-#     Let COMPAT be the least number such that the new library (in
-#       its binary form) can be used as a drop-in replacement for
-#       all previous releases whose CURRENT is greater than or equal
-#       to COMPAT
-#     If COMPAT + AGE < CURRENT:
-#       Increment AGE
-#     Else:
-#       Reset AGE to zero
-#   Else:
-#     Increment REVISION
-#
-# The meaning of this version string is identical to the one defined
-# by GNU Libtool. See also
-# http://www.gnu.org/software/libtool/manual/libtool.html#Libtool-versioning
-#
-#
-# Generated sources
-# -----------------
-#
-# FIXME: Describe `GENERATED_SOURCES`.
-#
-#
-# Configuration variables
-# -----------------------
-#
-# All variables listed in the section CONFIG VARIABLES are available
-# for modification in `project.mk`, and they may also be overridden on
-# the command line. For example, to enable POSIX Threads and disable
-# automatic dependency tracking, you could do this:
-#
-#   make CFLAGS_PTHREADS="-pthreads" CFLAGS_AUTODEP=""
-#
-# If CFLAGS is specified in the environment or on the command line, it
-# will replace the value of CFLAGS_GENERAL. Similarly with LDFLAGS and
-# ARFLAGS.
-#
-# If EXTRA_CFLAGS is specified on the command line, its contents will
-# be added to CFLAGS_GENERAL. Similarly with LDFLAGS.
-#
-# If CC, CXX, OCC, OCXX, LD, and AR are specified in the environment
-# or on the command line, their values will be respected.
-#
-# NOTE: When you change the configuration specified via the
-# environment or the command line from one invocation of make to the
-# next, you should always start with a 'make clean'. MAKE does this
-# automatically when you change `project.mk`.
-#
-# If `CC` is neither specified in the environment nor on the command
-# line, `generic.mk` will look for a number of well-known compilers
-# (GCC, Clang), and set `CC` accordingly. If CXX or OCC is neither
-# specified in the environment nor on the command line, it will be set
-# to whatever `CC` is set to. Likewise, if `OCXX` is neither specified
-# in the environment nor on the command line, it will be set to
-# whatever `OCC` is set to. If `LD` or `AR` is neither specified in
-# the environment nor on the command line, `generic.mk` will attempt
-# to derive their values from `CC`.
-#
-# A number of variables are provided to query about the
-# detected/specified tool chain:
-#
-# If `generic.mk` can identify the contents of `CC` as GCC or Clang,
-# it sets `CC_IS` to `gcc` or `clang` respectively, and
-# `CC_IS_GCC_LIKE` to `yes`. Otherwise it sets both `CC_IS` and
-# `CC_IS_GCC_LIKE` to empty strings. Equivalent variables exist for
-# `CXX`, `OCC`, `OCXX`, and `LD`.
-#
-# Additionally, if `IS_CC`, `IS_CXX`, `IS_OCC`, and `IS_OCXX` are all
-# equal, then `COMPILER_IS` is set to that value (`gcc` or
-# `clang`). Likewise, if all four are GCC-like, then
-# `COMPILER_IS_GCC_LIKE` is set to `yes`.
-#
-# In general, `generic.mk` can identify a compiler or linker as GCC if
-# its name (when arguments are stripped away and path is removed) is
-# `gcc` or `g++`, or begins with `gcc-` or `g++-`. Likewise with Clang
-# if the name is `clang` or `clang++`.
-#
-# When `COMPILER_IS_GCC_LIKE` is true (not empty), `generic.mk` will
-# add a number of sensible GCC-like compiler flags for optimization,
-# debugging, profiling, header dependency tracking, and
-# more. Likewise, if `LD_IS_GCC_LIKE` is not empty, extra linker flags
-# will be added.
-#
-# If you set `CC` to something that is GCC-like, but is not
-# automatically identified as such (e.g. `arm-linux-androideabi-gcc`),
-# you can manually override `CC_IS` (or any of the other classifying
-# variables) on the `make` command line. When done right, this will
-# fix "chained" classification variables, and reenable the automatic
-# addition of extra GCC-like compiler/linker flags.
-#
-#
-# Technicalities
-# --------------
-#
-# Project local files and directories mentioned in variables passed to
-# `generic.mk` as part of specifying target, source, or subdirectory
-# paths, must consist entirely of letters, digits, `_`, `-`, and `.`
-# (all from the ASCII character set). In particular, spaces are not
-# allowed. When variable names are constructed from paths, `/`, `-`,
-# and `.` are folded to `_`.
-#
-# The same restriction applies to all installation directories
-# (`bindir`, `libdir` `includedir`, etc.).
-#
-# On the other hand, the value of `DESTDIR` may contain any graphical
-# characters from the ASCII character set as well as SPACE and TAB.
-#
-# Except when you are building in 'code coverage' mode, the absolute
-# path to the root of your project may contain any graphical
-# characters from ASCII as well as SPACE and TAB. However, when you
-# are building in 'code coverage' mode, your project root path must
-# adhere to the same restrictions that apply to project local target
-# paths passed to `generic.mk`.
-
-
-
-# CONFIG VARIABLES
-
-# The relative path to the root of the include tree. If specified, a
-# corresponding include option (`-I`) is added to the compiler command
-# line for all object file targets in the project, and the primary
-# prefix `subinclude` becomes available in Makefiles contained inside
-# the specified directory.
-INCLUDE_ROOT =
-
-CFLAGS_OPTIM          = -DNDEBUG
-CFLAGS_DEBUG          =
-CFLAGS_COVER          =
-CFLAGS_SHARED         =
-CFLAGS_PTHREADS       =
-CFLAGS_GENERAL        =
-CFLAGS_C              =
-CFLAGS_CXX            =
-CFLAGS_OBJC           =
-CFLAGS_ARCH           =
-CFLAGS_INCLUDE        =
-CFLAGS_AUTODEP        =
-LDFLAGS_OPTIM         = $(filter-out -D%,$(CFLAGS_OPTIM))
-LDFLAGS_DEBUG         = $(filter-out -D%,$(CFLAGS_DEBUG))
-LDFLAGS_COVER         = $(filter-out -D%,$(CFLAGS_COVER))
-LDFLAGS_SHARED        =
-LDFLAGS_PTHREADS      = $(CFLAGS_PTHREADS)
-LDFLAGS_GENERAL       =
-LDFLAGS_ARCH          = $(CFLAGS_ARCH)
-ARFLAGS_GENERAL       = csr
-
-PROJECT_CFLAGS        =
-PROJECT_CFLAGS_OPTIM  =
-PROJECT_CFLAGS_DEBUG  =
-PROJECT_CFLAGS_COVER  =
-PROJECT_LDFLAGS       =
-PROJECT_LDFLAGS_OPTIM =
-PROJECT_LDFLAGS_DEBUG =
-PROJECT_LDFLAGS_COVER =
-
-LIB_SUFFIX_STATIC     = .a
-LIB_SUFFIX_SHARED     = .so
-LIB_SUFFIX_LIBDEPS    = .libdeps
-
-ifneq ($(filter undefined environment,$(origin PROG_SUFFIX)),)
-PROG_SUFFIX           =
-endif
-
-BASE_DENOM            =
-OBJ_DENOM_SHARED      = .pic
-OBJ_DENOM_OPTIM       =
-OBJ_DENOM_DEBUG       = .dbg
-OBJ_DENOM_COVER       = .cov
-LIB_DENOM_OPTIM       =
-LIB_DENOM_DEBUG       = -dbg
-LIB_DENOM_COVER       = -cov
-PROG_DENOM_OPTIM      =
-PROG_DENOM_DEBUG      = -dbg
-PROG_DENOM_COVER      = -cov
-
-# When set to an empty value, 'make install' will not install the
-# static versions of the libraries mentioned in lib_LIBRARIES, and a
-# plain 'make' will not even build them. When set to a nonempty value,
-# the opposite is true.
-ENABLE_INSTALL_STATIC_LIBS =
-
-# When set to an empty value, 'make install' will not install the
-# debug versions of the libraries mentioned in lib_LIBRARIES, and a
-# plain 'make' will not even build them. When set to a nonempty value,
-# the opposite is true.
-ENABLE_INSTALL_DEBUG_LIBS =
-
-# When set to an empty value, 'make install' will not install the
-# debug versions of the programs mentioned in bin_PROGRAMS, and a
-# plain 'make' will not even build them. When set to a nonempty value,
-# the opposite is true.
-ENABLE_INSTALL_DEBUG_PROGS =
-
-# Use this if you want to install only a subset of what is usually
-# installed. For example, to produce a separate binary and development
-# package for a library product, you can run 'make install
-# INSTALL_FILTER=shared-libs,progs' for the binary package and 'make
-# install INSTALL_FILTER=static-libs,dev-progs,headers' for the
-# development package. This filter affects uninstallation the same way
-# it affects installation.
-INSTALL_FILTER = shared-libs,static-libs,progs,dev-progs,headers
-
-# Installation (GNU style)
-prefix          = /usr/local
-exec_prefix     = $(prefix)
-bindir          = $(exec_prefix)/bin
-sbindir         = $(exec_prefix)/sbin
-libdir          = $(if $(USE_LIB64),$(exec_prefix)/lib64,$(exec_prefix)/lib)
-libexecdir      = $(exec_prefix)/libexec
-includedir      = $(prefix)/include
-INSTALL         = install
-INSTALL_DIR     = $(INSTALL) -d
-INSTALL_DATA    = $(INSTALL) -m 644
-INSTALL_LIBRARY = $(INSTALL) -m 644
-INSTALL_PROGRAM = $(INSTALL)
-
-VALGRIND       ?= valgrind
-VALGRIND_FLAGS ?= --quiet --track-origins=yes --leak-check=yes --leak-resolution=low
-
-# Alternative filesystem root for installation
-DESTDIR =
-
-
-
-# UTILITY CONSTANTS AND FUNCTIONS
-
-EMPTY :=
-SPACE := $(EMPTY) $(EMPTY)
-COMMA := ,
-APOSTROPHE := $(patsubst "%",%,"'")
-
-define NEWLINE
-$(EMPTY)
-$(EMPTY)
-endef
-
-define TAB
-	$(EMPTY)
-endef
-
-NL_TAB := $(NEWLINE)$(TAB)
-
-IDENTITY = $(1)
-
-IS_EQUAL_TO = $(and $(findstring $(1),$(2)),$(findstring $(2),$(1)))
-
-# ARGS: prefix, string
-IS_PREFIX_OF = $(findstring .$(call IS_PREFIX_OF_1,$(1)),.$(call IS_PREFIX_OF_1,$(2)))
-IS_PREFIX_OF_1 = $(subst .,:d:,$(subst :,:c:,$(1)))
-
-COND_PREPEND = $(if $(2),$(1)$(2))
-COND_APPEND  = $(if $(1),$(1)$(2))
-
-LIST_CONCAT  = $(if $(and $(1),$(2)),$(1) $(2),$(1)$(2))
-LIST_REVERSE = $(if $(1),$(call LIST_CONCAT,$(call LIST_REVERSE,$(wordlist 2,$(words $(1)),$(1))),$(firstword $(1))))
-
-# ARGS: predicate, list, optional_predicate_arg
-STABLE_PARTITION = $(call STABLE_PARTITION_1,$(1),$(strip $(2)),$(3))
-STABLE_PARTITION_1 = $(if $(2),$(call STABLE_PARTITION_2,$(1),$(wordlist 2,$(words $(2)),$(2)),$(3),$(4),$(5),$(word 1,$(2))),$(strip $(4) $(5)))
-STABLE_PARTITION_2 = $(if $(call $(1),$(6),$(3)),$(call STABLE_PARTITION_1,$(1),$(2),$(3),$(4) $(6),$(5)),$(call STABLE_PARTITION_1,$(1),$(2),$(3),$(4),$(5) $(6)))
-
-# ARGS: predicate, list, optional_predicate_arg
-# Expands to first entry that satisfies the predicate, or the empty string if no entry satsifies it.
-FIND = $(call FIND_1,$(1),$(strip $(2)),$(3))
-FIND_1 = $(if $(2),$(call FIND_2,$(1),$(2),$(3),$(word 1,$(2))))
-FIND_2 = $(if $(call $(1),$(4),$(3)),$(4),$(call FIND_1,$(1),$(wordlist 2,$(words $(2)),$(2)),$(3)))
-
-# ARGS: func, init_accum, list
-FOLD_LEFT = $(call FOLD_LEFT_1,$(1),$(2),$(strip $(3)))
-FOLD_LEFT_1 = $(if $(3),$(call FOLD_LEFT_1,$(1),$(call $(1),$(2),$(word 1,$(3))),$(wordlist 2,$(words $(3)),$(3))),$(2))
-
-# ARGS: list_1, list_2
-UNION = $(call FOLD_LEFT,UNION_1,$(1),$(2))
-UNION_1 = $(if $(call FIND,IS_EQUAL_TO,$(1),$(2)),$(1),$(if $(1),$(1) $(2),$(2)))
-
-# ARGS: list
-REMOVE_DUPES = $(call UNION,,$(1))
-
-# ARGS: predicate, list, optional_predicate_arg
-FILTER = $(call FILTER_1,$(1),$(strip $(2)),$(3))
-FILTER_1 = $(if $(2),$(call FILTER_1,$(1),$(wordlist 2,$(words $(2)),$(2)),$(3),$(call LIST_CONCAT,$(4),$(if $(call $(1),$(word 1,$(2)),$(3)),$(word 1,$(2))))),$(4))
-
-# ARGS: list
-REMOVE_PREFIXES = $(call FILTER,REMOVE_PREFIXES_1,$(1),$(1))
-REMOVE_PREFIXES_1 = $(if $(call FIND,REMOVE_PREFIXES_2,$(2),$(1)),,x)
-REMOVE_PREFIXES_2 = $(if $(call IS_EQUAL_TO,$(2),$(1)),,$(call IS_PREFIX_OF,$(2),$(1)))
-
-HIDE_SPACE   = $(subst $(TAB),:t:,$(subst $(SPACE),:s:,$(subst :,:c:,$(1))))
-UNHIDE_SPACE = $(subst :c:,:,$(subst :s:,$(SPACE),$(subst :t:,$(TAB),$(1))))
-
-# If `a` and `b` are relative or absolute paths (without a final
-# slash), and `b` points to a directory, then PATH_DIFF(a,b) expands
-# to the relative path from `b` to `a`. If abspath(a) and abspath(b)
-# are the same path, then PATH_DIFF(a,b) expands to the empty string.
-PATH_DIFF = $(call PATH_DIFF_2,$(call PATH_DIFF_1,$(1)),$(call PATH_DIFF_1,$(2)))
-PATH_DIFF_1 = $(subst /,$(SPACE),$(abspath $(call HIDE_SPACE,$(if $(filter /%,$(1)),$(1),$(abspath .)/$(1)))))
-PATH_DIFF_2 = $(if $(and $(1),$(2),$(call IS_EQUAL_TO,$(word 1,$(1)),$(word 1,$(2)))),$(call PATH_DIFF_2,$(wordlist 2,$(words $(1)),$(1)),$(wordlist 2,$(words $(2)),$(2))),$(call UNHIDE_SPACE,$(subst $(SPACE),/,$(strip $(patsubst %,..,$(2)) $(1)))))
-
-# If `p` is already an absolute path, or if `optional_abs_base` is not
-# specified, then `MAKE_ABS_PATH(p, optional_abs_base)` expands to
-# `abspath(p)`. Otherwise, `optional_abs_base` must be an absolute
-# path, and this function expands to
-# `abspath(optional_abs_base+'/'+p)`. As opposed to the built-in
-# function `abspath()`, this function properly handles paths that
-# contain spaces.
-MAKE_ABS_PATH = $(call UNHIDE_SPACE,$(abspath $(call HIDE_SPACE,$(if $(filter /%,$(1)),$(1),$(or $(2),$(abspath .))/$(1)))))
-
-# If `p` and `base` are paths, then MAKE_REL_PATH(p,base) expands to
-# the relative path from abspath(base) to abspath(p). If the two paths
-# are equal, it expands to `.`. If `base` is unspecified, it defaults
-# to `.`.
-MAKE_REL_PATH = $(or $(call PATH_DIFF,$(1),$(or $(2),.)),.)
-
-IS_SAME_PATH_AS = $(call IS_EQUAL_TO,$(call CANON_PATH_HIDE_SPACE,$(1)),$(call CANON_PATH_HIDE_SPACE,$(2)))
-IS_PATH_CONTAINED_IN = $(call IS_PREFIX_OF,$(call CANON_PATH_HIDE_SPACE,$(2))/,$(call CANON_PATH_HIDE_SPACE,$(1)))
-CANON_PATH_HIDE_SPACE = $(abspath $(call HIDE_SPACE,$(patsubst %/,%,$(if $(filter /%,$(1)),$(1),$(abspath .)/$(1)))))
-
-# Only a `*` is recognized, and at most one is allowed per component
-# of the wildcard path. Matching is guaranteed to fail if any
-# component of the wildcard path has more than one star and the
-# non-wildcard path has no stars in it.
-#
-# ARGS: wildcard_path, path
-WILDCARD_PATH_MATCH = $(and $(call WILDCARD_PATH_MATCH_1,$(dir $(1)),$(dir $(2))),$(filter $(subst *,%,$(subst %,\%,$(notdir $(1)))),$(notdir $(2))))
-WILDCARD_PATH_MATCH_1 = $(if $(filter-out / ./,$(1) $(2)),$(if $(filter / ./,$(1) $(2)),,$(call WILDCARD_PATH_MATCH,$(patsubst %/,%,$(1)),$(patsubst %/,%,$(2)))),$(filter // ././,$(1)$(2)))
-
-# ARGS: wildcard_paths, paths
-WILDCARD_PATHS_FILTER_OUT = $(foreach x,$(2),$(if $(strip $(foreach y,$(1),$(call WILDCARD_PATH_MATCH,$(y),$(x)))),,$(x)))
-
-# Escape space, tab, and the following 21 characters using backslashes: !"#$&'()*;<>?[\]`{|}~
-SHELL_ESCAPE = $(shell printf '%s\n' '$(call SHELL_ESCAPE_1,$(1))' | sed $(SHELL_ESCAPE_2))
-SHELL_ESCAPE_1 = $(subst $(APOSTROPHE),$(APOSTROPHE)\$(APOSTROPHE)$(APOSTROPHE),$(1))
-SHELL_ESCAPE_2 = 's/\([]$(TAB)$(SPACE)!"\#$$&'\''()*;<>?[\`{|}~]\)/\\\1/g'
-
-HAVE_CMD = $(shell which $(word 1,$(1)))
-
-# ARGS: command, prefix_to_class_map
-# Returns empty if identification fails
-IDENT_CMD = $(call IDENT_CMD_1,$(notdir $(word 1,$(1))),$(2))
-IDENT_CMD_1 = $(word 1,$(foreach x,$(2),$(call IDENT_CMD_2,$(1),$(subst :,$(SPACE),$(x)))))
-IDENT_CMD_2 = $(call IDENT_CMD_3,$(1),$(word 1,$(2)),$(word 2,$(2)))
-IDENT_CMD_3 = $(if $(call IS_PREFIX_OF,$(2)-,$(1)-),$(3))
-
-# ARGS: command, subsitutions
-# Returns empty if mapping fails
-MAP_CMD = $(call MAP_CMD_1,$(word 1,$(1)),$(wordlist 2,$(words $(1)),$(1)),$(2))
-MAP_CMD_1 = $(call MAP_CMD_2,$(if $(findstring /,$(1)),$(dir $(1))),$(notdir $(1)),$(2),$(3))
-MAP_CMD_2 = $(call MAP_CMD_3,$(1),$(word 1,$(foreach x,$(4),$(call MAP_CMD_4,$(x),$(2)))),$(3))
-MAP_CMD_3 = $(if $(2),$(call LIST_CONCAT,$(1)$(2),$(3)))
-MAP_CMD_4 = $(call MAP_CMD_5,$(subst :,$(SPACE),$(1)),$(2))
-MAP_CMD_5 = $(call MAP_CMD_6,-$(word 1,$(1))-,-$(word 2,$(1))-,-$(2)-)
-MAP_CMD_6 = $(if $(findstring $(1),$(3)),$(call MAP_CMD_7,$(patsubst -%-,%,$(subst $(1),$(2),$(3)))))
-MAP_CMD_7 = $(if $(call HAVE_CMD,$(1)),$(1))
-
-CAT_OPT_FILE = $(shell cat $(1) 2>/dev/null)
-
-# Library for non-negative integer arithmetic.
-#
-# Note: It is an error if a numeric (unencoded) argument is greater
-# than 65536.
-#
-# This implementation is an adaptation of John Graham-Cumming's work at
-# http://www.cmcrossroads.com/article/learning-gnu-make-functions-arithmetic
-INT_ADD = $(call INT_DEC,$(call INT_ADD_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2))))
-INT_SUB = $(call INT_DEC,$(call INT_SUB_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2))))
-INT_MUL = $(call INT_DEC,$(call INT_MUL_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2))))
-INT_DIV = $(call INT_DEC,$(call INT_DIV_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2))))
-INT_MAX = $(call INT_DEC,$(call INT_MAX_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2))))
-INT_MIN = $(call INT_DEC,$(call INT_MIN_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2))))
-INT_EQ  = $(call INT_EQ_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2)))
-INT_NE  = $(call INT_NE_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2)))
-INT_GT  = $(call INT_GT_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2)))
-INT_LT  = $(call INT_LT_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2)))
-INT_GTE = $(call INT_GTE_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2)))
-INT_LTE = $(call INT_LTE_E,$(call INT_ENC,$(1)),$(call INT_ENC,$(2)))
-INT_ADD_E = $(1) $(2)
-INT_SUB_E = $(if $(call INT_GTE_E,$(1),$(2)),$(filter-out xx,$(join $(1),$(2))),$(error Subtraction underflow))
-INT_MUL_E = $(foreach a,$(1),$(2))
-INT_DIV_E = $(if $(filter-out $(words $(2)),0),$(call INT_DIV_2,$(1),$(2)),$(error Division by zero))
-INT_DIV_2 = $(if $(call INT_GTE_E,$(1),$(2)),x $(call INT_DIV_2,$(call INT_SUB_E,$(1),$(2)),$(2)))
-INT_MAX_E = $(subst xx,x,$(join $(1),$(2)))
-INT_MIN_E = $(subst xx,x,$(filter xx,$(join $(1),$(2))))
-INT_EQ_E  = $(filter $(words $(1)),$(words $(2)))
-INT_NE_E  = $(filter-out $(words $(1)),$(words $(2)))
-INT_GT_E  = $(filter-out $(words $(2)),$(words $(call INT_MAX_E,$(1),$(2))))
-INT_LT_E  = $(filter-out $(words $(1)),$(words $(call INT_MAX_E,$(1),$(2))))
-INT_GTE_E = $(call INT_GT_E,$(1),$(2))$(call INT_EQ_E,$(1),$(2))
-INT_LTE_E = $(call INT_LT_E,$(1),$(2))$(call INT_EQ_E,$(1),$(2))
-# More efficient increment / decrement
-INT_INC_E = $(1) x
-INT_DEC_E = $(wordlist 2,$(words $(1)),$(1))
-# More efficient double / halve
-INT_DBL_E = $(1) $(1)
-INT_HLV_E = $(subst xx,x,$(filter-out xy x y,$(join $(1),$(foreach a,$(1),y x))))
-# Encode / decode
-INT_DEC = $(words $(1))
-INT_ENC = $(wordlist 1,$(1),$(INT_65536))
-INT_16    := x x x x x x x x x x x x x x x
-INT_65536 := $(foreach a,$(INT_16),$(foreach b,$(INT_16),$(foreach c,$(INT_16),$(INT_16))))
-
-
-
-# PLATFORM SPECIFICS
-
-OS := $(shell uname)
-ARCH := $(shell uname -m)
-
-ifeq ($(OS),Darwin)
-  LIB_SUFFIX_SHARED = .dylib
-endif
-
-USE_LIB64 =
-ifeq ($(OS),Linux)
-  IS_64BIT = $(filter x86_64 ia64,$(ARCH))
-  ifneq ($(IS_64BIT),)
-    ifeq ($(shell [ -e /etc/redhat-release -o -e /etc/SuSE-release ] && echo yes),yes)
-      USE_LIB64 = 1
-    else ifneq ($(shell [ -e /etc/system-release ] && grep Amazon /etc/system-release),)
-      USE_LIB64 = 1
-    endif
-  endif
-endif
-
-
-
-# SETUP A GCC-LIKE TOOL CHAIN IF POSSIBLE
-
-# If CC is not specified, search PATH for these compilers in the
-# specified order.
-ifeq ($(OS),Darwin)
-  COMPILER_DETECT_LIST = clang llvm-gcc gcc
-else
-  COMPILER_DETECT_LIST = gcc clang
-endif
-
-# Compiler identification. Maps command prefix to compiler class.
-COMPILER_IDENT_MAP = gcc:gcc g++:gcc llvm-gcc:gcc llvm-g++:gcc clang:clang clang++:clang
-
-# Compiler classes that are mostly like GCC.
-GCC_LIKE_COMPILERS = gcc clang
-
-# How to map C compiler to corresponding C++ linker.
-CC_TO_CXXL_MAP = gcc:g++ g++:g++ clang:clang++ clang++:clang++
-
-# How to map C compiler to corresponding archiver (static libraries).
-CC_TO_AR_MAP  = gcc:gcc-ar g++:gcc-ar gcc:ar g++:ar clang:clang-ar clang++:clang-ar clang:ar clang++:ar
-
-DETECT_COMPILER = $(call FIND,HAVE_CMD,$(COMPILER_DETECT_LIST))
-IDENT_COMPILER = $(call IDENT_CMD,$(1),$(COMPILER_IDENT_MAP))
-CLASS_IS_GCC_LIKE = $(if $(filter $(GCC_LIKE_COMPILERS),$(1)),yes)
-
-# C compiler
-CC_SPECIFIED := $(filter-out undefined default,$(origin CC))
-ifeq ($(CC_SPECIFIED),)
-  # CC was not specified
-  X := $(call DETECT_COMPILER)
-  ifneq ($(X),)
-    CC := $(X)
-  endif
-endif
-CC_IS := $(call IDENT_COMPILER,$(CC))
-CC_IS_GCC_LIKE := $(call CLASS_IS_GCC_LIKE,$(CC_IS))
-
-# C++ compiler
-CXX_SPECIFIED := $(filter-out undefined default,$(origin CXX))
-ifeq ($(CXX_SPECIFIED),)
-  # CXX was not specified
-  CXX := $(CC)
-  CXX_IS := $(CC_IS)
-  CXX_IS_GCC_LIKE := $(CC_IS_GCC_LIKE)
-else
-  CXX_IS := $(call IDENT_COMPILER,$(CXX))
-  CXX_IS_GCC_LIKE := $(call CLASS_IS_GCC_LIKE,$(CXX_IS))
-endif
-
-# Objective-C compiler
-OCC_SPECIFIED := $(filter-out undefined default,$(origin OCC))
-ifeq ($(OCC_SPECIFIED),)
-  # OCC was not specified
-  OCC := $(CC)
-  OCC_IS := $(CC_IS)
-  OCC_IS_GCC_LIKE := $(CC_IS_GCC_LIKE)
-else
-  OCC_IS := $(call IDENT_COMPILER,$(OCC))
-  OCC_IS_GCC_LIKE := $(call CLASS_IS_GCC_LIKE,$(OCC_IS))
-endif
-
-# Objective-C++ compiler
-OCXX_SPECIFIED := $(filter-out undefined default,$(origin OCXX))
-ifeq ($(OCXX_SPECIFIED),)
-  # OCXX was not specified
-  OCXX := $(OCC)
-  OCXX_IS := $(OCC_IS)
-  OCXX_IS_GCC_LIKE := $(OCC_IS_GCC_LIKE)
-else
-  OCXX_IS := $(call IDENT_COMPILER,$(OCXX))
-  OCXX_IS_GCC_LIKE := $(call CLASS_IS_GCC_LIKE,$(OCXX_IS))
-endif
-
-COMPILER_IS = $(if $(word 2,$(call REMOVE_DUPES,x$(CC_IS) x$(CXX_IS) x$(OCC_IS) x$(OCXX_IS))),,$(CC_IS))
-COMPILER_IS_GCC_LIKE := $(and $(CC_IS_GCC_LIKE),$(CXX_IS_GCC_LIKE),$(OCC_IS_GCC_LIKE),$(OCXX_IS_GCC_LIKE))
-
-ifneq ($(COMPILER_IS_GCC_LIKE),)
-  CFLAGS_OPTIM   = -O3 -DNDEBUG
-  CFLAGS_DEBUG   = -ggdb
-  CFLAGS_COVER   = --coverage
-  CFLAGS_SHARED  = -fPIC -DPIC
-  CFLAGS_GENERAL = -Wall
-  CFLAGS_AUTODEP = -MMD -MP
-endif
-
-# Linker
-X := $(EMPTY)
-LD_SPECIFIED = $(filter-out undefined default,$(origin LD))
-ifeq ($(LD_SPECIFIED),)
-  # LD was not specified
-  ifneq ($(CC_IS_GCC_LIKE),)
-    X := $(call MAP_CMD,$(CC),$(CC_TO_CXXL_MAP))
-    ifneq ($(X),)
-      LD := $(X)
-      LD_IS := $(CC_IS)
-      LD_IS_GCC_LIKE := yes
-    endif
-  endif
-endif
-ifeq ($(X),)
-  LD_IS := $(call IDENT_COMPILER,$(LD))
-  LD_IS_GCC_LIKE := $(call CLASS_IS_GCC_LIKE,$(LD_IS))
-endif
-ifneq ($(LD_IS_GCC_LIKE),)
-  LDFLAGS_SHARED = -shared
-endif
-
-# Archiver (static libraries)
-AR_SPECIFIED = $(filter-out undefined default,$(origin AR))
-ifeq ($(AR_SPECIFIED),)
-  # AR was not specified
-  ifneq ($(CC_IS_GCC_LIKE),)
-    X := $(call MAP_CMD,$(CC),$(CC_TO_AR_MAP))
-    ifneq ($(X),)
-      AR := $(X)
-    endif
-  endif
-endif
-
-
-
-# LOAD PROJECT SPECIFIC CONFIGURATION
-
-EXTRA_CFLAGS  =
-EXTRA_LDFLAGS =
-
-GENERIC_MK := $(lastword $(MAKEFILE_LIST))
-GENERIC_MK_DIR := $(patsubst %/,%,$(dir $(GENERIC_MK)))
-PROJECT_MK := $(GENERIC_MK_DIR)/project.mk
-DEP_MAKEFILES := Makefile $(GENERIC_MK)
-ifneq ($(wildcard $(PROJECT_MK)),)
-  DEP_MAKEFILES += $(PROJECT_MK)
-  include $(PROJECT_MK)
-endif
-
-ifneq ($(INCLUDE_ROOT),)
-  REL_INCLUDE_ROOT := $(call MAKE_REL_PATH,$(dir $(GENERIC_MK))/$(INCLUDE_ROOT))
-endif
-
-ROOT_INC_FLAG := $(EMPTY)
-ROOT_INC_FLAG_COVER := $(EMPTY)
-ifneq ($(REL_INCLUDE_ROOT),)
-  ROOT_INC_FLAG += -I$(REL_INCLUDE_ROOT)
-  ROOT_INC_FLAG_COVER += -I$(call MAKE_ABS_PATH,$(REL_INCLUDE_ROOT))
-endif
-
-
-
-# SETUP BUILD COMMANDS
-
-CFLAGS_SPECIFIED  := $(filter-out undefined default,$(origin CFLAGS))
-LDFLAGS_SPECIFIED := $(filter-out undefined default,$(origin LDFLAGS))
-ARFLAGS_SPECIFIED := $(filter-out undefined default,$(origin ARFLAGS))
-ifneq ($(CFLAGS_SPECIFIED),)
-CFLAGS_GENERAL = $(CFLAGS)
-endif
-ifneq ($(LDFLAGS_SPECIFIED),)
-LDFLAGS_GENERAL = $(LDFLAGS)
-endif
-ifneq ($(ARFLAGS_SPECIFIED),)
-ARFLAGS_GENERAL = $(ARFLAGS)
-endif
-CFLAGS_GENERAL  += $(EXTRA_CFLAGS)
-LDFLAGS_GENERAL += $(EXTRA_LDFLAGS)
-
-CC_STATIC_OPTIM   = $(CC) $(CFLAGS_OPTIM) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-CC_SHARED_OPTIM   = $(CC) $(CFLAGS_OPTIM) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-CC_STATIC_DEBUG   = $(CC) $(CFLAGS_DEBUG) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-CC_SHARED_DEBUG   = $(CC) $(CFLAGS_DEBUG) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-CC_STATIC_COVER   = $(CC) $(CFLAGS_COVER) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(ROOT_INC_FLAG_COVER) $(CFLAGS_GENERAL)
-CC_SHARED_COVER   = $(CC) $(CFLAGS_COVER) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(ROOT_INC_FLAG_COVER) $(CFLAGS_GENERAL)
-
-CXX_STATIC_OPTIM  = $(CXX) $(CFLAGS_OPTIM) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-CXX_SHARED_OPTIM  = $(CXX) $(CFLAGS_OPTIM) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-CXX_STATIC_DEBUG  = $(CXX) $(CFLAGS_DEBUG) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-CXX_SHARED_DEBUG  = $(CXX) $(CFLAGS_DEBUG) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-CXX_STATIC_COVER  = $(CXX) $(CFLAGS_COVER) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(ROOT_INC_FLAG_COVER) $(CFLAGS_GENERAL)
-CXX_SHARED_COVER  = $(CXX) $(CFLAGS_COVER) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(ROOT_INC_FLAG_COVER) $(CFLAGS_GENERAL)
-
-OCC_STATIC_OPTIM  = $(OCC) $(CFLAGS_OPTIM) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(CFLAGS_OBJC) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-OCC_SHARED_OPTIM  = $(OCC) $(CFLAGS_OPTIM) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(CFLAGS_OBJC) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-OCC_STATIC_DEBUG  = $(OCC) $(CFLAGS_DEBUG) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(CFLAGS_OBJC) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-OCC_SHARED_DEBUG  = $(OCC) $(CFLAGS_DEBUG) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(CFLAGS_OBJC) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-OCC_STATIC_COVER  = $(OCC) $(CFLAGS_COVER) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(CFLAGS_OBJC) $(ROOT_INC_FLAG_COVER) $(CFLAGS_GENERAL)
-OCC_SHARED_COVER  = $(OCC) $(CFLAGS_COVER) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_C) $(CFLAGS_OBJC) $(ROOT_INC_FLAG_COVER) $(CFLAGS_GENERAL)
-
-OCXX_STATIC_OPTIM = $(OCXX) $(CFLAGS_OPTIM) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(CFLAGS_OBJC) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-OCXX_SHARED_OPTIM = $(OCXX) $(CFLAGS_OPTIM) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(CFLAGS_OBJC) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-OCXX_STATIC_DEBUG = $(OCXX) $(CFLAGS_DEBUG) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(CFLAGS_OBJC) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-OCXX_SHARED_DEBUG = $(OCXX) $(CFLAGS_DEBUG) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(CFLAGS_OBJC) $(ROOT_INC_FLAG) $(CFLAGS_GENERAL)
-OCXX_STATIC_COVER = $(OCXX) $(CFLAGS_COVER) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(CFLAGS_OBJC) $(ROOT_INC_FLAG_COVER) $(CFLAGS_GENERAL)
-OCXX_SHARED_COVER = $(OCXX) $(CFLAGS_COVER) $(CFLAGS_SHARED) $(CFLAGS_PTHREADS) $(CFLAGS_CXX) $(CFLAGS_OBJC) $(ROOT_INC_FLAG_COVER) $(CFLAGS_GENERAL)
-
-CFLAGS_OTHER = $(CFLAGS_ARCH) $(CFLAGS_INCLUDE) $(CFLAGS_AUTODEP)
-
-LD_LIB_OPTIM      = $(LD) $(LDFLAGS_SHARED) $(LDFLAGS_OPTIM) $(LDFLAGS_PTHREADS) $(LDFLAGS_GENERAL)
-LD_LIB_DEBUG      = $(LD) $(LDFLAGS_SHARED) $(LDFLAGS_DEBUG) $(LDFLAGS_PTHREADS) $(LDFLAGS_GENERAL)
-LD_LIB_COVER      = $(LD) $(LDFLAGS_SHARED) $(LDFLAGS_COVER) $(LDFLAGS_PTHREADS) $(LDFLAGS_GENERAL)
-LD_PROG_OPTIM     = $(LD) $(LDFLAGS_OPTIM) $(LDFLAGS_PTHREADS) $(LDFLAGS_GENERAL)
-LD_PROG_DEBUG     = $(LD) $(LDFLAGS_DEBUG) $(LDFLAGS_PTHREADS) $(LDFLAGS_GENERAL)
-LD_PROG_COVER     = $(LD) $(LDFLAGS_COVER) $(LDFLAGS_PTHREADS) $(LDFLAGS_GENERAL)
-
-
-
-BASE_DENOM_2            := $(if $(BASE_DENOM),-$(BASE_DENOM))
-SUFFIX_OBJ_STATIC_OPTIM := $(BASE_DENOM_2)$(OBJ_DENOM_OPTIM).o
-SUFFIX_OBJ_SHARED_OPTIM := $(BASE_DENOM_2)$(OBJ_DENOM_OPTIM)$(OBJ_DENOM_SHARED).o
-SUFFIX_OBJ_STATIC_DEBUG := $(BASE_DENOM_2)$(OBJ_DENOM_DEBUG).o
-SUFFIX_OBJ_SHARED_DEBUG := $(BASE_DENOM_2)$(OBJ_DENOM_DEBUG)$(OBJ_DENOM_SHARED).o
-SUFFIX_OBJ_STATIC_COVER := $(BASE_DENOM_2)$(OBJ_DENOM_COVER).o
-SUFFIX_OBJ_SHARED_COVER := $(BASE_DENOM_2)$(OBJ_DENOM_COVER)$(OBJ_DENOM_SHARED).o
-SUFFIX_LIB_STATIC_OPTIM := $(BASE_DENOM_2)$(LIB_DENOM_OPTIM)$(LIB_SUFFIX_STATIC)
-SUFFIX_LIB_SHARED_OPTIM := $(BASE_DENOM_2)$(LIB_DENOM_OPTIM)$(LIB_SUFFIX_SHARED)
-SUFFIX_LIB_STATIC_DEBUG := $(BASE_DENOM_2)$(LIB_DENOM_DEBUG)$(LIB_SUFFIX_STATIC)
-SUFFIX_LIB_SHARED_DEBUG := $(BASE_DENOM_2)$(LIB_DENOM_DEBUG)$(LIB_SUFFIX_SHARED)
-SUFFIX_LIB_STATIC_COVER := $(BASE_DENOM_2)$(LIB_DENOM_COVER)$(LIB_SUFFIX_STATIC)
-SUFFIX_LIB_SHARED_COVER := $(BASE_DENOM_2)$(LIB_DENOM_COVER)$(LIB_SUFFIX_SHARED)
-SUFFIX_PROG_OPTIM       := $(BASE_DENOM_2)$(PROG_DENOM_OPTIM)$(PROG_SUFFIX)
-SUFFIX_PROG_DEBUG       := $(BASE_DENOM_2)$(PROG_DENOM_DEBUG)$(PROG_SUFFIX)
-SUFFIX_PROG_COVER       := $(BASE_DENOM_2)$(PROG_DENOM_COVER)$(PROG_SUFFIX)
-
-GET_FLAGS = $($(1)) $($(1)_$(2))
-FOLD_TARGET = $(subst /,_,$(subst .,_,$(subst -,_,$(1))))
-GET_LIBRARY_STEM         = $(patsubst %.a,%,$(1))
-GET_OBJECTS_FOR_TARGET   = $(addsuffix $(2),$(basename $($(call FOLD_TARGET,$(1))_SOURCES)))
-GET_LDFLAGS_FOR_TARGET   = $(foreach x,PROJECT DIR $(call FOLD_TARGET,$(1)),$(call GET_FLAGS,$(x)_LDFLAGS,$(2)))
-GET_DEPS_FOR_TARGET      = $($(call FOLD_TARGET,$(1))_DEPS)
-GET_LIBRARY_VERSION      = $(call GET_LIBRARY_VERSION_2,$(strip $($(call FOLD_TARGET,$(1))_VERSION)))
-GET_LIBRARY_VERSION_2    = $(if $(1),$(wordlist 1,3,$(subst :, ,$(1):0:0)))
-
-PRIMARIES := HEADERS LIBRARIES PROGRAMS
-PRIMARY_PREFIXES := bin sbin lib libexec include
-INCLUDE_SUBDIR :=
-
-USING_SUBINCLUDE := $(strip $(foreach x,$(PRIMARIES) $(PRIMARIES)_EXTRA_UNINSTALL,$(subinclude_$(x))$(nobase_subinclude_$(x))))
-ifneq ($(USING_SUBINCLUDE),)
-ifeq ($(REL_INCLUDE_ROOT),)
-$(error Cannot determine installation directory for `subinclude` when `INCLUDE_ROOT` is unspecified)
-endif
-INSIDE_INCLUDE_ROOT := $(or $(call IS_SAME_PATH_AS,.,$(REL_INCLUDE_ROOT)),$(call IS_PATH_CONTAINED_IN,.,$(REL_INCLUDE_ROOT)))
-ifeq ($(INSIDE_INCLUDE_ROOT),)
-$(error Cannot determine installation directory for `subinclude` from outside `INCLUDE_ROOT`)
-endif
-PRIMARY_PREFIXES += subinclude
-INCLUDE_SUBDIR := $(call PATH_DIFF,.,$(REL_INCLUDE_ROOT))
-endif
-
-PRIMARY_PREFIXES += $(EXTRA_PRIMARY_PREFIXES)
-
-# ARGS: primary_prefix
-GET_INSTALL_DIR = $(if $(filter subinclude,$(1)),$(call GET_ROOT_INSTALL_DIR,include)$(call COND_PREPEND,/,$(INCLUDE_SUBDIR)),$(call GET_ROOT_INSTALL_DIR,$(1)))
-GET_ROOT_INSTALL_DIR = $(if $($(1)dir),$(patsubst %/,%,$($(1)dir)),$(error Variable `$(1)dir` was not specified))
-
-# ARGS: folded_lib_target, install_dir
-define RECORD_LIB_INSTALL_DIR
-GMK_INSTALL_DIR_$(1) = $(2)
-endef
-
-# ARGS: primary_prefix, install_dir
-RECORD_LIB_INSTALL_DIRS = \
-$(foreach x,$($(1)_LIBRARIES),$(eval $(call RECORD_LIB_INSTALL_DIR,$(call FOLD_TARGET,$(x)),$(2))))\
-$(foreach x,$(nobase_$(1)_LIBRARIES),$(eval $(call RECORD_LIB_INSTALL_DIR,$(call FOLD_TARGET,$(x)),$(patsubst %/,%,$(dir $(2)/$(x))))))
-
-$(foreach x,$(PRIMARY_PREFIXES),$(call RECORD_LIB_INSTALL_DIRS,$(x),$(call GET_INSTALL_DIR,$(x))))
-
-# ARGS: installable_lib_target
-GET_INSTALL_DIR_FOR_LIB_TARGET = $(value GMK_INSTALL_DIR_$(call FOLD_TARGET,$(1)))
-
-INST_PROGRAMS  := $(strip $(foreach x,$(PRIMARY_PREFIXES),$($(x)_PROGRAMS)  $(nobase_$(x)_PROGRAMS)))
-INST_LIBRARIES := $(strip $(foreach x,$(PRIMARY_PREFIXES),$($(x)_LIBRARIES) $(nobase_$(x)_LIBRARIES)))
-
-LIBRARIES := $(INST_LIBRARIES) $(noinst_LIBRARIES) $(check_LIBRARIES)
-PROGRAMS  := $(INST_PROGRAMS) $(DEV_PROGRAMS) $(noinst_PROGRAMS) $(check_PROGRAMS)
-
-SOURCE_DIRS := $(patsubst ././,./,$(patsubst %,./%,$(call REMOVE_DUPES,$(dir $(foreach x,$(LIBRARIES) $(PROGRAMS),$($(call FOLD_TARGET,$(x))_SOURCES))))))
-
-OBJECTS_STATIC_OPTIM := $(foreach x,$(LIBRARIES) $(PROGRAMS),$(call GET_OBJECTS_FOR_TARGET,$(x),$(SUFFIX_OBJ_STATIC_OPTIM)))
-OBJECTS_SHARED_OPTIM := $(foreach x,$(LIBRARIES),$(call GET_OBJECTS_FOR_TARGET,$(x),$(SUFFIX_OBJ_SHARED_OPTIM)))
-OBJECTS_STATIC_DEBUG := $(foreach x,$(LIBRARIES) $(PROGRAMS),$(call GET_OBJECTS_FOR_TARGET,$(x),$(SUFFIX_OBJ_STATIC_DEBUG)))
-OBJECTS_SHARED_DEBUG := $(foreach x,$(LIBRARIES),$(call GET_OBJECTS_FOR_TARGET,$(x),$(SUFFIX_OBJ_SHARED_DEBUG)))
-OBJECTS_STATIC_COVER := $(foreach x,$(LIBRARIES) $(PROGRAMS),$(call GET_OBJECTS_FOR_TARGET,$(x),$(SUFFIX_OBJ_STATIC_COVER)))
-OBJECTS_SHARED_COVER := $(foreach x,$(LIBRARIES),$(call GET_OBJECTS_FOR_TARGET,$(x),$(SUFFIX_OBJ_SHARED_COVER)))
-OBJECTS := $(sort $(OBJECTS_STATIC_OPTIM) $(OBJECTS_SHARED_OPTIM) $(OBJECTS_STATIC_DEBUG) $(OBJECTS_SHARED_DEBUG) $(OBJECTS_STATIC_COVER) $(OBJECTS_SHARED_COVER))
-
-TARGETS_LIB_STATIC_OPTIM   := $(foreach x,$(INST_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_STATIC_OPTIM))
-TARGETS_LIB_SHARED_OPTIM   := $(foreach x,$(INST_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_SHARED_OPTIM))
-TARGETS_LIB_STATIC_DEBUG   := $(foreach x,$(INST_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_STATIC_DEBUG))
-TARGETS_LIB_SHARED_DEBUG   := $(foreach x,$(INST_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_SHARED_DEBUG))
-TARGETS_LIB_STATIC_COVER   := $(foreach x,$(INST_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_STATIC_COVER))
-TARGETS_LIB_SHARED_COVER   := $(foreach x,$(INST_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_SHARED_COVER))
-TARGETS_INST_LIB_LIBDEPS   := $(foreach x,$(INST_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(LIB_SUFFIX_LIBDEPS))
-TARGETS_NOINST_LIB_OPTIM   := $(foreach x,$(noinst_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_STATIC_OPTIM))
-TARGETS_NOINST_LIB_DEBUG   := $(foreach x,$(noinst_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_STATIC_DEBUG))
-TARGETS_NOINST_LIB_COVER   := $(foreach x,$(noinst_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_STATIC_COVER))
-TARGETS_NOINST_LIB_LIBDEPS := $(foreach x,$(noinst_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(LIB_SUFFIX_LIBDEPS))
-TARGETS_CHECK_LIB_OPTIM     := $(foreach x,$(check_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_STATIC_OPTIM))
-TARGETS_CHECK_LIB_DEBUG     := $(foreach x,$(check_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_STATIC_DEBUG))
-TARGETS_CHECK_LIB_COVER     := $(foreach x,$(check_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(SUFFIX_LIB_STATIC_COVER))
-TARGETS_CHECK_LIB_LIBDEPS   := $(foreach x,$(check_LIBRARIES),$(call GET_LIBRARY_STEM,$(x))$(LIB_SUFFIX_LIBDEPS))
-TARGETS_PROG_OPTIM         := $(foreach x,$(INST_PROGRAMS),$(x)$(SUFFIX_PROG_OPTIM))
-TARGETS_PROG_DEBUG         := $(foreach x,$(INST_PROGRAMS),$(x)$(SUFFIX_PROG_DEBUG))
-TARGETS_PROG_COVER         := $(foreach x,$(INST_PROGRAMS),$(x)$(SUFFIX_PROG_COVER))
-TARGETS_DEV_PROG_OPTIM     := $(foreach x,$(DEV_PROGRAMS),$(x)$(SUFFIX_PROG_OPTIM))
-TARGETS_DEV_PROG_DEBUG     := $(foreach x,$(DEV_PROGRAMS),$(x)$(SUFFIX_PROG_DEBUG))
-TARGETS_NOINST_PROG_OPTIM  := $(foreach x,$(noinst_PROGRAMS),$(x)$(SUFFIX_PROG_OPTIM))
-TARGETS_NOINST_PROG_DEBUG  := $(foreach x,$(noinst_PROGRAMS),$(x)$(SUFFIX_PROG_DEBUG))
-TARGETS_NOINST_PROG_COVER  := $(foreach x,$(noinst_PROGRAMS),$(x)$(SUFFIX_PROG_COVER))
-TARGETS_CHECK_PROG_OPTIM    := $(foreach x,$(check_PROGRAMS),$(x)$(SUFFIX_PROG_OPTIM))
-TARGETS_CHECK_PROG_DEBUG    := $(foreach x,$(check_PROGRAMS),$(x)$(SUFFIX_PROG_DEBUG))
-TARGETS_CHECK_PROG_COVER    := $(foreach x,$(check_PROGRAMS),$(x)$(SUFFIX_PROG_COVER))
-
-TARGETS_BUILD :=
-ifneq ($(ENABLE_INSTALL_STATIC_LIBS),)
-TARGETS_BUILD += $(TARGETS_LIB_STATIC_OPTIM)
-endif
-TARGETS_BUILD += $(TARGETS_LIB_SHARED_OPTIM)
-ifneq ($(or $(ENABLE_INSTALL_DEBUG_LIBS),$(ENABLE_INSTALL_DEBUG_PROGS)),)
-TARGETS_BUILD += $(TARGETS_LIB_SHARED_DEBUG)
-endif
-TARGETS_BUILD += $(TARGETS_INST_LIB_LIBDEPS)
-TARGETS_BUILD += $(TARGETS_NOINST_LIB_OPTIM)
-ifneq ($(ENABLE_INSTALL_DEBUG_PROGS),)
-TARGETS_BUILD += $(TARGETS_NOINST_LIB_DEBUG)
-endif
-TARGETS_BUILD += $(TARGETS_NOINST_LIB_LIBDEPS)
-TARGETS_BUILD += $(TARGETS_PROG_OPTIM)
-ifneq ($(ENABLE_INSTALL_DEBUG_PROGS),)
-TARGETS_BUILD += $(TARGETS_PROG_DEBUG)
-endif
-TARGETS_BUILD += $(TARGETS_DEV_PROG_OPTIM) $(TARGETS_DEV_PROG_DEBUG) $(TARGETS_NOINST_PROG_OPTIM)
-
-TARGETS_RELEASE     := $(TARGETS_LIB_SHARED_OPTIM) $(TARGETS_INST_LIB_LIBDEPS)
-TARGETS_RELEASE     += $(TARGETS_NOINST_LIB_OPTIM) $(TARGETS_NOINST_LIB_LIBDEPS)
-TARGETS_RELEASE     += $(TARGETS_PROG_OPTIM) $(TARGETS_DEV_PROG_OPTIM) $(TARGETS_NOINST_PROG_OPTIM)
-TARGETS_NODEBUG     := $(TARGETS_LIB_STATIC_OPTIM) $(TARGETS_LIB_SHARED_OPTIM) $(TARGETS_INST_LIB_LIBDEPS)
-TARGETS_NODEBUG     += $(TARGETS_NOINST_LIB_OPTIM) $(TARGETS_NOINST_LIB_LIBDEPS)
-TARGETS_NODEBUG     += $(TARGETS_PROG_OPTIM) $(TARGETS_DEV_PROG_OPTIM) $(TARGETS_NOINST_PROG_OPTIM)
-TARGETS_DEBUG       := $(TARGETS_LIB_SHARED_DEBUG) $(TARGETS_INST_LIB_LIBDEPS)
-TARGETS_DEBUG       += $(TARGETS_NOINST_LIB_DEBUG) $(TARGETS_NOINST_LIB_LIBDEPS)
-TARGETS_DEBUG       += $(TARGETS_PROG_DEBUG) $(TARGETS_DEV_PROG_DEBUG) $(TARGETS_NOINST_PROG_DEBUG)
-TARGETS_COVER       := $(TARGETS_LIB_SHARED_COVER) $(TARGETS_INST_LIB_LIBDEPS)
-TARGETS_COVER       += $(TARGETS_NOINST_LIB_COVER) $(TARGETS_NOINST_LIB_LIBDEPS)
-TARGETS_COVER       += $(TARGETS_PROG_COVER) $(TARGETS_NOINST_PROG_COVER)
-TARGETS_CHECK       := $(TARGETS_LIB_SHARED_OPTIM) $(TARGETS_INST_LIB_LIBDEPS)
-TARGETS_CHECK       += $(TARGETS_NOINST_LIB_OPTIM) $(TARGETS_NOINST_LIB_LIBDEPS)
-TARGETS_CHECK       += $(TARGETS_CHECK_LIB_OPTIM) $(TARGETS_CHECK_LIB_LIBDEPS)
-TARGETS_CHECK       += $(TARGETS_PROG_OPTIM) $(TARGETS_CHECK_PROG_OPTIM)
-TARGETS_CHECK_DEBUG := $(TARGETS_LIB_SHARED_DEBUG) $(TARGETS_INST_LIB_LIBDEPS)
-TARGETS_CHECK_DEBUG += $(TARGETS_NOINST_LIB_DEBUG) $(TARGETS_NOINST_LIB_LIBDEPS)
-TARGETS_CHECK_DEBUG += $(TARGETS_CHECK_LIB_DEBUG) $(TARGETS_CHECK_LIB_LIBDEPS)
-TARGETS_CHECK_DEBUG += $(TARGETS_PROG_DEBUG) $(TARGETS_CHECK_PROG_DEBUG)
-TARGETS_CHECK_COVER := $(TARGETS_LIB_SHARED_COVER) $(TARGETS_INST_LIB_LIBDEPS)
-TARGETS_CHECK_COVER += $(TARGETS_NOINST_LIB_COVER) $(TARGETS_NOINST_LIB_LIBDEPS)
-TARGETS_CHECK_COVER += $(TARGETS_CHECK_LIB_COVER) $(TARGETS_CHECK_LIB_LIBDEPS)
-TARGETS_CHECK_COVER += $(TARGETS_PROG_COVER) $(TARGETS_CHECK_PROG_COVER)
-
-TARGETS_EVERYTHING := $(TARGETS_LIB_STATIC_OPTIM) $(TARGETS_LIB_SHARED_OPTIM)
-TARGETS_EVERYTHING += $(TARGETS_LIB_SHARED_DEBUG) $(TARGETS_INST_LIB_LIBDEPS)
-TARGETS_EVERYTHING += $(TARGETS_NOINST_LIB_OPTIM) $(TARGETS_NOINST_LIB_DEBUG) $(TARGETS_NOINST_LIB_LIBDEPS)
-TARGETS_EVERYTHING += $(TARGETS_CHECK_LIB_OPTIM) $(TARGETS_CHECK_LIB_DEBUG) $(TARGETS_CHECK_LIB_LIBDEPS)
-TARGETS_EVERYTHING += $(TARGETS_PROG_OPTIM) $(TARGETS_PROG_DEBUG)
-TARGETS_EVERYTHING += $(TARGETS_DEV_PROG_OPTIM) $(TARGETS_DEV_PROG_DEBUG)
-TARGETS_EVERYTHING += $(TARGETS_NOINST_PROG_OPTIM) $(TARGETS_NOINST_PROG_DEBUG)
-TARGETS_EVERYTHING += $(TARGETS_CHECK_PROG_OPTIM) $(TARGETS_CHECK_PROG_DEBUG)
-
-TARGETS_LIB_STATIC  := $(TARGETS_LIB_STATIC_OPTIM) $(TARGETS_LIB_STATIC_DEBUG) $(TARGETS_LIB_STATIC_COVER)
-TARGETS_LIB_SHARED  := $(TARGETS_LIB_SHARED_OPTIM) $(TARGETS_LIB_SHARED_DEBUG) $(TARGETS_LIB_SHARED_COVER)
-TARGETS_NOINST_LIB  := $(TARGETS_NOINST_LIB_OPTIM) $(TARGETS_NOINST_LIB_DEBUG) $(TARGETS_NOINST_LIB_COVER)
-TARGETS_CHECK_LIB   := $(TARGETS_CHECK_LIB_OPTIM) $(TARGETS_CHECK_LIB_DEBUG) $(TARGETS_CHECK_LIB_COVER)
-TARGETS_PROG        := $(TARGETS_PROG_OPTIM) $(TARGETS_PROG_DEBUG) $(TARGETS_PROG_COVER)
-TARGETS_DEV_PROG    := $(TARGETS_DEV_PROG_OPTIM) $(TARGETS_DEV_PROG_DEBUG)
-TARGETS_NOINST_PROG := $(TARGETS_NOINST_PROG_OPTIM) $(TARGETS_NOINST_PROG_DEBUG) $(TARGETS_NOINST_PROG_COVER)
-TARGETS_CHECK_PROG  := $(TARGETS_CHECK_PROG_OPTIM) $(TARGETS_CHECK_PROG_DEBUG) $(TARGETS_CHECK_PROG_COVER)
-TARGETS_PROG_ALL    := $(foreach x,$(TARGETS_PROG) $(TARGETS_DEV_PROG),$(x) $(x)-noinst) $(TARGETS_NOINST_PROG) $(TARGETS_CHECK_PROG)
-
-# ARGS: real_local_path, version
-GET_SHARED_LIB_ALIASES = $(1)
-
-ifeq ($(OS),Linux)
-
-GET_SHARED_LIB_ALIASES   = $(if $(2),$(call GET_SHARED_LIB_ALIASES_2,$(1),$(call MAP_SHARED_LIB_VERSION,$(2))),$(1))
-GET_SHARED_LIB_ALIASES_2 = $(1) $(1).$(word 1,$(2)) $(1).$(word 2,$(2))
-
-MAP_SHARED_LIB_VERSION   = $(call MAP_SHARED_LIB_VERSION_2,$(word 1,$(1)),$(word 2,$(1)),$(word 3,$(1)))
-MAP_SHARED_LIB_VERSION_2 = $(call MAP_SHARED_LIB_VERSION_3,$(call INT_SUB,$(1),$(3)),$(3),$(2))
-MAP_SHARED_LIB_VERSION_3 = $(1) $(1).$(2).$(3)
-
-endif
-
-ifeq ($(OS),Darwin)
-
-GET_SHARED_LIB_ALIASES = $(if $(2),$(1) $(word 1,$(call MAP_SHARED_LIB_VERSION,$(1),$(2))),$(1))
-
-MAP_SHARED_LIB_VERSION   = $(call MAP_SHARED_LIB_VERSION_2,$(1),$(word 1,$(2)),$(word 2,$(2)),$(word 3,$(2)))
-MAP_SHARED_LIB_VERSION_2 = $(call MAP_SHARED_LIB_VERSION_3,$(1),$(call INT_SUB,$(2),$(4)),$(call INT_ADD,$(2),1),$(3))
-MAP_SHARED_LIB_VERSION_3 = $(patsubst %.dylib,%,$(1)).$(2).dylib $(3) $(3).$(4)
-
-endif
-
-TARGETS_LIB_SHARED_ALIASES = $(foreach x,$(INST_LIBRARIES),$(foreach y,OPTIM DEBUG COVER,$(call TARGETS_LIB_SHARED_ALIASES_1,$(x),$(SUFFIX_LIB_SHARED_$(y)))))
-TARGETS_LIB_SHARED_ALIASES_1 = $(call GET_SHARED_LIB_ALIASES,$(call GET_LIBRARY_STEM,$(1))$(2),$(call GET_LIBRARY_VERSION,$(1)))
-
-TARGETS := $(TARGETS_LIB_STATIC) $(TARGETS_LIB_SHARED_ALIASES) $(TARGETS_INST_LIB_LIBDEPS)
-TARGETS += $(TARGETS_NOINST_LIB) $(TARGETS_NOINST_LIB_LIBDEPS)
-TARGETS += $(TARGETS_CHECK_LIB) $(TARGETS_CHECK_LIB_LIBDEPS) $(TARGETS_PROG_ALL)
-
-RECURSIVE_GOALS = build release nodebug debug cover everything clean install-only uninstall \
-check-norun check-debug-norun check-cover-norun check check-debug check-cover memcheck memcheck-debug
-
-.DEFAULT_GOAL :=
-
-.PHONY: all
-all: build
-
-build/local:             $(TARGETS_BUILD)
-release/local:           $(TARGETS_RELEASE)
-nodebug/local:           $(TARGETS_NODEBUG)
-debug/local:             $(TARGETS_DEBUG)
-cover/local:             $(TARGETS_COVER)
-everything/local:        $(TARGETS_EVERYTHING)
-check-norun/local:       $(TARGETS_CHECK)
-check-debug-norun/local: $(TARGETS_CHECK_DEBUG)
-check-cover-norun/local: $(TARGETS_CHECK_COVER)
-
-
-# Update everything if any makefile or any generated source has changed
-$(GENERATED_SOURCES) $(OBJECTS) $(TARGETS): $(DEP_MAKEFILES)
-$(OBJECTS): $(GENERATED_SOURCES)
-
-# Disable all suffix rules and some interfering implicit pattern rules
-.SUFFIXES:
-%: %.o
-%: %.c
-%: %.cpp
-
-
-
-# SUBPROJECTS
-
-# ARGS: recursive_goal, subdirs_for_goal, subdir_deps_for_this_dir
-define RECURSIVE_GOAL_RULES
-.PHONY: $(1) $(1)/this-dir $(1)/local
-$(1): $(1)/this-dir $(patsubst %,$(1)/subdir/%,$(2))
-ifeq ($(strip $(3)),)
-$(1)/this-dir: $(1)/local
-else
-$(1)/this-dir:
-	@$$(MAKE) --no-print-directory $(1)/local
-endif
-endef
-
-# ARGS: recursive_goal, subdir_dep_for_this_dir
-define SUBDIR_DEP_FOR_THIS_DIR_RULE
-$(1)/this-dir: $(1)/subdir/$(2)
-endef
-
-# ARGS: recursive_goal, subdir
-define RECURSIVE_GOAL_SUBDIR_RULES
-.PHONY: $(1)/subdir/$(2)
-ifeq ($(1),build)
-$(1)/subdir/$(2):
-	@$$(MAKE) -w -C $(2)
-else
-$(1)/subdir/$(2):
-	@$$(MAKE) -w -C $(2) $(1)
-endif
-endef
-
-# ARGS: recursive_goal, subdir, dep
-define SUBDIR_DEP_RULE
-ifeq ($(3),.)
-$(1)/subdir/$(2): $(1)/this-dir
-else
-$(1)/subdir/$(2): $(1)/subdir/$(3)
-endif
-endef
-
-AVAIL_PASSIVE_SUBDIRS := $(foreach x,$(PASSIVE_SUBDIRS),$(if $(realpath $(x)),$(x)))
-
-# ARGS: recursive_goal
-GET_SUBDIRS_FOR_RECURSIVE_GOAL = $(if $(filter clean,$(1)),$(SUBDIRS) $(AVAIL_PASSIVE_SUBDIRS),$(SUBDIRS))
-
-# ARGS: recursive_goal
-GET_SUBDIR_DEPS_FOR_THIS_DIR = $(if $(filter clean install-only,$(1)),,$(if $(filter uninstall,$(1)),$(SUBDIRS),$(DIR_DEPS)))
-
-# ARGS: recursive_goal, subdir
-GET_SUBDIR_DEPS = $(if $(filter clean uninstall,$(1)),,$(if $(filter install-only,$(1)),.,$($(call FOLD_TARGET,$(2))_DEPS)))
-
-# ARGS: recursive_goal, subdir, deps
-EVAL_RECURSIVE_GOAL_SUBDIR_RULES = \
-$(eval $(call RECURSIVE_GOAL_SUBDIR_RULES,$(1),$(2)))\
-$(foreach x,$(call GET_SUBDIR_DEPS,$(1),$(2)),$(eval $(call SUBDIR_DEP_RULE,$(1),$(2),$(x))))
-
-# ARGS: recursive_goal, subdir_deps_for_this_dir
-EVAL_RECURSIVE_GOAL_RULES = \
-$(eval $(call RECURSIVE_GOAL_RULES,$(1),$(call GET_SUBDIRS_FOR_RECURSIVE_GOAL,$(1)),$(2)))\
-$(foreach x,$(2),$(eval $(call SUBDIR_DEP_FOR_THIS_DIR_RULE,$(1),$(x))))\
-$(foreach x,$(SUBDIRS) $(PASSIVE_SUBDIRS),$(call EVAL_RECURSIVE_GOAL_SUBDIR_RULES,$(1),$(x)))
-
-$(foreach x,$(RECURSIVE_GOALS),$(call EVAL_RECURSIVE_GOAL_RULES,$(x),$(call GET_SUBDIR_DEPS_FOR_THIS_DIR,$(x))))
-
-
-
-# CLEANING
-
-GET_CLEAN_FILES = $(strip $(call WILDCARD_PATHS_FILTER_OUT,$(EXTRA_CLEAN),$(foreach x,$(SOURCE_DIRS),$(foreach y,*.d *.o *.gcno *.gcda,$(patsubst ./%,%,$(x))$(y))) $(TARGETS)) $(EXTRA_CLEAN))
-
-ifneq ($(word 1,$(or $(SOURCE_DIRS),$(TARGETS),$(EXTRA_CLEAN))),)
-define CLEANING_RULES
-clean/local:
-	$$(RM) $$(call GET_CLEAN_FILES)
-endef
-$(eval $(CLEANING_RULES))
-endif
-
-
-
-# INSTALL / UNINSTALL
-
-.PHONY: install
-install: build
-	@$(MAKE) install-only
-
-HAS_STAR = $(call HAS_STAR_1,$(subst *,x$(SPACE)x,$(subst $(SPACE),x,$(1))))
-HAS_STAR_1 = $(wordlist 2,$(words $(1)),$(1))
-
-CHECK_WILDCARD = $(if $(call HAS_STAR,$(word 1,$(subst /,$(SPACE),$(1)))),$(error For your safety, uninstallation wildcards are not allowed to appear at the root level of the target installation directory [$(1)]))
-CHECK_WILDCARDS = $(foreach x,$(PRIMARIES),$(foreach y,$(notdir $($(1)_$(x)_EXTRA_UNINSTALL)) $(nobase_$(1)_$(x)_EXTRA_UNINSTALL),$(call CHECK_WILDCARD,$(2)$(y))))
-$(foreach x,$(PRIMARY_PREFIXES),$(call CHECK_WILDCARDS,$(x),$(if $(filter subinclude,$(x)),$(call COND_APPEND,$(INCLUDE_SUBDIR),/))))
-
-DESTDIR_2 := $(call SHELL_ESCAPE,$(call UNHIDE_SPACE,$(patsubst %/,%,$(call HIDE_SPACE,$(value DESTDIR)))))
-
-# ARGS: install_dir, real_local_paths
-INSTALL_RECIPE_FILES   = $(NL_TAB)$$(INSTALL_DATA) $(2) $$(DESTDIR_2)$(1)
-UNINSTALL_RECIPE_FILES = $(NL_TAB)$$(RM) $(foreach x,$(2),$$(DESTDIR_2)$(1)/$(x))
-
-# ARGS: install_dir, real_local_paths
-INSTALL_RECIPE_LIBS = $(NL_TAB)$$(INSTALL_LIBRARY) $(2) $$(DESTDIR_2)$(1)
-
-# ARGS: real_local_path, version
-INSTALL_FILES_VERSIONED_LIB = $(1)
-
-# ARGS: install_dir, real_local_path, version
-INSTALL_RECIPE_VERSIONED_LIB = $(INSTALL_RECIPE_LIBS)
-
-ifeq ($(OS),Linux)
-INSTALL_FILES_VERSIONED_LIB    = $(if $(2),$(call INSTALL_FILES_VERSIONED_LIB_1,$(1),$(call MAP_SHARED_LIB_VERSION,$(2))),$(1))
-INSTALL_FILES_VERSIONED_LIB_1  = $(1) $(1).$(word 1,$(2)) $(1).$(word 2,$(2))
-INSTALL_RECIPE_VERSIONED_LIB   = $(if $(3),$(call INSTALL_RECIPE_VERSIONED_LIB_1,$(1),$(2),$(call MAP_SHARED_LIB_VERSION,$(3))),$(INSTALL_RECIPE_LIBS))
-INSTALL_RECIPE_VERSIONED_LIB_1 = $(call INSTALL_RECIPE_VERSIONED_LIB_2,$(1),$(2),$(2).$(word 1,$(3)),$(2).$(word 2,$(3)))
-INSTALL_RECIPE_VERSIONED_LIB_2 = $(call INSTALL_RECIPE_LIBS,$(1),$(4))$(NL_TAB)cd $$(DESTDIR_2)$(1) && ln -s -f $(notdir $(4)) $(notdir $(3)) && ln -s -f $(notdir $(3)) $(notdir $(2))
-endif
-
-ifeq ($(OS),Darwin)
-INSTALL_FILES_VERSIONED_LIB    = $(if $(2),$(1) $(word 1,$(call MAP_SHARED_LIB_VERSION,$(1),$(2))),$(1))
-INSTALL_RECIPE_VERSIONED_LIB   = $(if $(3),$(call INSTALL_RECIPE_VERSIONED_LIB_1,$(1),$(2),$(word 1,$(call MAP_SHARED_LIB_VERSION,$(2),$(3)))),$(INSTALL_RECIPE_LIBS))
-INSTALL_RECIPE_VERSIONED_LIB_1 = $(call INSTALL_RECIPE_LIBS,$(1),$(3))$(NL_TAB)cd $$(DESTDIR_2)$(1) && ln -s -f $(notdir $(3)) $(notdir $(2))
-endif
-
-INST_STATIC_LIB_SUFFICES :=
-INST_SHARED_LIB_SUFFICES :=
-INST_PROG_SUFFICES :=
-ifneq ($(ENABLE_INSTALL_STATIC_LIBS),)
-INST_STATIC_LIB_SUFFICES += +$(SUFFIX_LIB_STATIC_OPTIM)
-endif
-INST_SHARED_LIB_SUFFICES += +$(SUFFIX_LIB_SHARED_OPTIM)
-ifneq ($(ENABLE_INSTALL_DEBUG_LIBS),)
-INST_SHARED_LIB_SUFFICES += +$(SUFFIX_LIB_SHARED_DEBUG)
-endif
-INST_PROG_SUFFICES += +$(SUFFIX_PROG_OPTIM)
-ifneq ($(ENABLE_INSTALL_DEBUG_PROGS),)
-INST_PROG_SUFFICES += +$(SUFFIX_PROG_DEBUG)
-endif
-
-# ARGS: abstract_targets
-INSTALL_FILES_STATIC_LIBS = $(foreach x,$(1),$(foreach y,$(INST_STATIC_LIB_SUFFICES),$(call GET_LIBRARY_STEM,$(x))$(patsubst +%,%,$(y))))
-INSTALL_FILES_SHARED_LIBS = $(foreach x,$(1),$(foreach y,$(INST_SHARED_LIB_SUFFICES),$(call INSTALL_FILES_VERSIONED_LIB,$(call GET_LIBRARY_STEM,$(x))$(patsubst +%,%,$(y)),$(call GET_LIBRARY_VERSION,$(x)))))
-INSTALL_FILES_PROGRAMS    = $(foreach x,$(1),$(foreach y,$(INST_PROG_SUFFICES),$(x)$(patsubst +%,%,$(y))))
-
-# ARGS: install_dir, abstract_targets
-INSTALL_RECIPE_STATIC_LIBS = $(call INSTALL_RECIPE_STATIC_LIBS_1,$(1),$(call INSTALL_FILES_STATIC_LIBS,$(2)))
-INSTALL_RECIPE_STATIC_LIBS_1 = $(if $(2),$(call INSTALL_RECIPE_LIBS,$(1),$(2)))
-INSTALL_RECIPE_SHARED_LIBS = $(foreach x,$(2),$(foreach y,$(INST_SHARED_LIB_SUFFICES),$(call INSTALL_RECIPE_VERSIONED_LIB,$(1),$(call GET_LIBRARY_STEM,$(x))$(patsubst +%,%,$(y)),$(call GET_LIBRARY_VERSION,$(x)))$(NEWLINE)))
-INSTALL_RECIPE_PROGRAMS    = $(NL_TAB)$$(INSTALL_PROGRAM) $(call INSTALL_FILES_PROGRAMS,$(2)) $$(DESTDIR_2)$(1)
-
-# ARGS: primary, is_for_uninstall
-GET_INSTALL_DIRS = $(foreach x,$(PRIMARY_PREFIXES),$(if $(filter subinclude,$(x)),$(call GET_INSTALL_DIRS_1,$(call GET_ROOT_INSTALL_DIR,include),$(call COND_APPEND,$(INCLUDE_SUBDIR),/),$(x),$(1),$(2)),$(call GET_INSTALL_DIRS_1,$(call GET_ROOT_INSTALL_DIR,$(x)),,$(x),$(1),$(2))))
-
-# ARGS: root_install_dir, opt_include_subdir_slash, primary_prefix, primary, is_for_uninstall
-GET_INSTALL_DIRS_1 = $(call GET_INSTALL_DIRS_2,$(1),$(2),$(notdir $($(3)_$(4))) $(nobase_$(3)_$(4)),$(5))
-
-# ARGS: root_install_dir, opt_include_subdir_slash, nobase_targets, is_for_uninstall
-GET_INSTALL_DIRS_2 = $(foreach x,$(call REMOVE_DUPES,$(patsubst %/,%,$(dir $(addprefix $(2),$(3))))),$(if $(filter .,$(x)),$(if $(4),,$(1)),$(foreach y,$(call SUBDIR_PARENT_EXPAND,$(x)),$(1)/$(y))))
-
-SUBDIR_PARENT_EXPAND = $(if $(filter-out ./,$(dir $(1))),$(call SUBDIR_PARENT_EXPAND,$(patsubst %/,%,$(dir $(1)))) $(1),$(1))
-
-# ARGS: primary, get_recipes
-GET_INSTALL_RECIPES = $(foreach x,$(PRIMARY_PREFIXES),$(call GET_INSTALL_RECIPES_1,$(2),$(call GET_INSTALL_DIR,$(x)),$(strip $($(x)_$(1))),$(nobase_$(x)_$(1))))
-
-# ARGS: get_recipes, install_dir, abstract_targets, nobase_targets
-GET_INSTALL_RECIPES_1 = $(if $(3),$(call $(1),$(2),$(3))$(NEWLINE)) $(foreach x,$(call REMOVE_DUPES,$(dir $(4))),$(call $(1),$(2)$(patsubst %/,/%,$(filter-out ./,$(x))),$(strip $(foreach y,$(4),$(if $(call IS_EQUAL_TO,$(dir $(y)),$(x)),$(y)))))$(NEWLINE))
-
-# ARGS: primary, get_files
-GET_UNINSTALL_RECIPES = $(foreach x,$(PRIMARY_PREFIXES),$(call GET_UNINSTALL_RECIPES_1,$(call GET_INSTALL_DIR,$(x)),$(2),$($(x)_$(1)),$(nobase_$(x)_$(1)),$(call REMOVE_DUPES,$(notdir $($(x)_$(1)_EXTRA_UNINSTALL)) $(nobase_$(x)_$(1)_EXTRA_UNINSTALL))))
-
-# ARGS: install_dir, get_files, abstract_targets, nobase_targets, extra_uninstall
-GET_UNINSTALL_RECIPES_1 = $(call GET_UNINSTALL_RECIPES_2,$(1),$(strip $(call WILDCARD_PATHS_FILTER_OUT,$(5),$(notdir $(call $(2),$(3))) $(call $(2),$(4))) $(5)))
-
-# ARGS: install_dir, uninstall_paths
-GET_UNINSTALL_RECIPES_2 = $(if $(2), $(call UNINSTALL_RECIPE_FILES,$(1),$(2))$(NEWLINE))
-
-INSTALL_DIRS :=
-UNINSTALL_DIRS :=
-EXTRA_UNINSTALL_DIRS :=
-INSTALL_RECIPES :=
-UNINSTALL_RECIPES :=
-
-INSTALL_FILTER_2 := $(subst $(COMMA),$(SPACE),$(INSTALL_FILTER))
-
-ifneq ($(filter headers,$(INSTALL_FILTER_2)),)
-INSTALL_DIRS += $(call GET_INSTALL_DIRS,HEADERS)
-UNINSTALL_DIRS += $(call GET_INSTALL_DIRS,HEADERS,x)
-EXTRA_UNINSTALL_DIRS += $(call GET_INSTALL_DIRS,HEADERS_EXTRA_UNINSTALL,x)
-INSTALL_RECIPES += $(call GET_INSTALL_RECIPES,HEADERS,INSTALL_RECIPE_FILES)$(NEWLINE)
-UNINSTALL_RECIPES += $(call GET_UNINSTALL_RECIPES,HEADERS,IDENTITY)$(NEWLINE)
-endif
-ifneq ($(filter static-libs,$(INSTALL_FILTER_2)),)
-INSTALL_DIRS += $(call GET_INSTALL_DIRS,LIBRARIES)
-UNINSTALL_DIRS += $(call GET_INSTALL_DIRS,LIBRARIES,x)
-EXTRA_UNINSTALL_DIRS += $(call GET_INSTALL_DIRS,LIBRARIES_EXTRA_UNINSTALL,x)
-INSTALL_RECIPES += $(call GET_INSTALL_RECIPES,LIBRARIES,INSTALL_RECIPE_STATIC_LIBS)$(NEWLINE)
-UNINSTALL_RECIPES += $(call GET_UNINSTALL_RECIPES,LIBRARIES,INSTALL_FILES_STATIC_LIBS)$(NEWLINE)
-endif
-ifneq ($(filter shared-libs,$(INSTALL_FILTER_2)),)
-INSTALL_DIRS += $(call GET_INSTALL_DIRS,LIBRARIES)
-UNINSTALL_DIRS += $(call GET_INSTALL_DIRS,LIBRARIES,x)
-EXTRA_UNINSTALL_DIRS += $(call GET_INSTALL_DIRS,LIBRARIES_EXTRA_UNINSTALL,x)
-INSTALL_RECIPES += $(call GET_INSTALL_RECIPES,LIBRARIES,INSTALL_RECIPE_SHARED_LIBS)$(NEWLINE)
-UNINSTALL_RECIPES += $(call GET_UNINSTALL_RECIPES,LIBRARIES,INSTALL_FILES_SHARED_LIBS)$(NEWLINE)
-endif
-ifneq ($(filter progs,$(INSTALL_FILTER_2)),)
-INSTALL_DIRS += $(call GET_INSTALL_DIRS,PROGRAMS)
-UNINSTALL_DIRS += $(call GET_INSTALL_DIRS,PROGRAMS,x)
-EXTRA_UNINSTALL_DIRS += $(call GET_INSTALL_DIRS,PROGRAMS_EXTRA_UNINSTALL,x)
-INSTALL_RECIPES += $(call GET_INSTALL_RECIPES,PROGRAMS,INSTALL_RECIPE_PROGRAMS)$(NEWLINE)
-UNINSTALL_RECIPES += $(call GET_UNINSTALL_RECIPES,PROGRAMS,INSTALL_FILES_PROGRAMS)$(NEWLINE)
-endif
-ifneq ($(and $(filter dev-progs,$(INSTALL_FILTER_2)),$(strip $(DEV_PROGRAMS))),)
-INSTALL_DIRS += $(call GET_ROOT_INSTALL_DIR,bin)
-INSTALL_RECIPES += $(call INSTALL_RECIPE_PROGRAMS,$(call GET_ROOT_INSTALL_DIR,bin),$(DEV_PROGRAMS))$(NEWLINE)
-UNINSTALL_RECIPES += $(call UNINSTALL_RECIPE_FILES,$(call GET_ROOT_INSTALL_DIR,bin),$(call INSTALL_FILES_PROGRAMS,$(DEV_PROGRAMS)))$(NEWLINE)
-endif
-
-# ARGS: paths, extra_paths
-FILTER_UNINSTALL_DIRS = $(call FOLD_LEFT,FILTER_UNINSTALL_DIRS_1,$(1) $(2),$(2))
-FILTER_UNINSTALL_DIRS_1 = $(call REMOVE_DUPES,$(foreach x,$(1),$(if $(call WILDCARD_PATH_MATCH,$(2),$(x)),$(2),$(x))))
-
-INSTALL_DIR_RECIPES   := $(if $(strip $(INSTALL_DIRS)),$(NL_TAB)$$(INSTALL_DIR) $(foreach x,$(call REMOVE_PREFIXES,$(patsubst %,%/,$(call REMOVE_DUPES,$(INSTALL_DIRS)))),$$(DESTDIR_2)$(x))$(NEWLINE))
-UNINSTALL_DIR_RECIPES := $(foreach x,$(call LIST_REVERSE,$(call FILTER_UNINSTALL_DIRS,$(call REMOVE_DUPES,$(UNINSTALL_DIRS)),$(call REMOVE_DUPES,$(EXTRA_UNINSTALL_DIRS)))),$(NL_TAB)-rmdir $$(DESTDIR_2)$(x)/$(NEWLINE))
-
-define INSTALL_RULES
-install-only/local:$(INSTALL_DIR_RECIPES)$(INSTALL_RECIPES)
-uninstall/local:$(UNINSTALL_RECIPES)$(UNINSTALL_DIR_RECIPES)
-endef
-
-ifeq ($(ENABLE_NOINST_BUILD),)
-$(eval $(INSTALL_RULES))
-endif
-
-
-# TESTING (A.K.A CHECKING)
-
-define CHECK_RULES
-
-check/local: $(TARGETS_CHECK)
-$(foreach x,$(TARGETS_CHECK_PROG_OPTIM),$(NL_TAB)./$(x)$(NEWLINE))
-
-check-debug/local: $(TARGETS_CHECK_DEBUG)
-$(foreach x,$(TARGETS_CHECK_PROG_DEBUG),$(NL_TAB)./$(x)$(NEWLINE))
-
-memcheck/local: $(TARGETS_CHECK)
-$(foreach x,$(TARGETS_CHECK_PROG_OPTIM),$(NL_TAB)$$(VALGRIND) $$(VALGRIND_FLAGS) --error-exitcode=1 ./$(x) --no-error-exitcode$(NEWLINE))
-
-memcheck-debug/local: $(TARGETS_CHECK_DEBUG)
-$(foreach x,$(TARGETS_CHECK_PROG_DEBUG),$(NL_TAB)$$(VALGRIND) $$(VALGRIND_FLAGS) --error-exitcode=1 ./$(x) --no-error-exitcode$(NEWLINE))
-
-ifneq ($(strip $(or $(SOURCE_DIRS),$(TARGETS_CHECK_COVER))),)
-check-cover/local: $(TARGETS_CHECK_COVER)
-$(if $(SOURCE_DIRS),$(NL_TAB)$$(RM) $(foreach x,$(SOURCE_DIRS),$(patsubst ./%,%,$(x))*.gcda))
-$(foreach x,$(TARGETS_CHECK_PROG_COVER),$(NL_TAB)-./$(x)$(NEWLINE))
-endif
-
-endef
-
-$(eval $(CHECK_RULES))
-
-
-
-# LINKING PROGRAMS
-
-# ARGS: origin_pattern, target_pattern, list
-FILTER_PATSUBST = $(patsubst $(1),$(2),$(filter $(1),$(3)))
-
-# ARGS: patterns, list
-FILTER_UNPACK   = $(foreach x,$(2),$(call FILTER_UNPACK_1,$(call FIND,FILTER_UNPACK_2,$(1),$(x)),$(x)))
-FILTER_UNPACK_1 = $(and $(1),$(patsubst $(1),%,$(2)))
-FILTER_UNPACK_2 = $(filter $(1),$(2))
-
-# ARGS: func, patterns, list, optional_arg
-PATTERN_UNPACK_MAP   = $(foreach x,$(3),$(call PATTERN_UNPACK_MAP_1,$(1),$(call FIND,PATTERN_UNPACK_MAP_2,$(2),$(x)),$(x),$(4)))
-# ARGS: func, optional_matching_pattern, entry, optional_arg
-PATTERN_UNPACK_MAP_1 = $(if $(2),$(patsubst %,$(2),$(call $(1),$(patsubst $(2),%,$(3)),$(4))),$(3))
-PATTERN_UNPACK_MAP_2 = $(filter $(1),$(2))
-
-MANGLE_LIBREF = $(subst /,_s,$(subst .,_d,$(subst -,_e,$(subst _,_u,$(1)))))
-
-# Expand the contents of the `target_LIBS` variable for the specified
-# target. The target must either be a program or an installed
-# library. Relative paths in the output will be expressed relative to
-# the directory holding the local `Makefile`.
-#
-# Output for each convenience library `x/y/libfoo.a`:
-#
-#     noinst:x/y/libfoo libdeps:x/y/libfoo.libdeps
-#     ldflag-opt:flag... ldflag-dbg:flag... ldflag-cov:flag...
-#
-# For each installed library `x/y/libfoo.a` referenced directly or in
-# two steps via a convenience library:
-#
-#     inst:x/y/libfoo libdeps:x/y/libfoo.libdeps dir:x/y lib:foo
-#
-# For each installed library `x/y/libfoo.a` referenced directly or
-# indirectly in any number of steps, and installed as
-# `/foo/bar/libfoo.so`:
-#
-#     rpath:/foo/bar rpath-noinst:x/y
-#
-# ARGS: abstract_target
-EXPAND_INST_LIB_LIBREFS = $(call EXPAND_LIBREFS,$(1),rpath:$(call GET_INSTALL_DIR_FOR_LIB_TARGET,$(1)) rpath-noinst:$(patsubst %/,%,$(dir $(1))))
-# ARGS: abstract_target, initial_elems
-EXPAND_LIBREFS = $(call REMOVE_DUPES,$(2) $(foreach x,$($(call FOLD_TARGET,$(1))_LIBS),$(call EXPAND_LIBREF,$(x))))
-# ARGS: libref
-EXPAND_LIBREF = $(call EXPAND_LIBREF_1,$(1),$(call MANGLE_LIBREF,$(1)))
-EXPAND_LIBREF_1 = $(if $(GMK_CELR_$(2)),,$(eval GMK_ELR_$(2) := $$(call EXPAND_LIBREF_2,$(1))$(NEWLINE)GMK_CELR_$(2) = x))$(GMK_ELR_$(2))
-EXPAND_LIBREF_2 = $(call EXPAND_LIBREF_3,$(call GET_LIBRARY_STEM,$(x)),$(call READ_LIBDEPS,$(x)))
-# ARGS: libref_stem, libref_libdeps_contents
-EXPAND_LIBREF_3 = $(if $(filter noinst,$(2)),$(call EXPAND_LIBREF_NOINST,$(1),$(2)),$(call EXPAND_LIBREF_INST,$(1),$(2)))
-EXPAND_LIBREF_NOINST = $(call EXPAND_LIBREF_4,noinst:$(1) libdeps:$(1)$(LIB_SUFFIX_LIBDEPS) $(filter-out noinst,$(2)))
-EXPAND_LIBREF_INST   = $(call EXPAND_LIBREF_4,lib:$(1).a libdeps:$(1)$(LIB_SUFFIX_LIBDEPS) $(2))
-# ARGS: partially_expanded_libdeps
-EXPAND_LIBREF_4 = $(foreach x,$(1),$(if $(filter lib:%,$(x)),$(call EXPAND_LIBREF_5,$(call GET_LIBRARY_STEM,$(patsubst lib:%,%,$(x)))),$(x)))
-# ARGS: nested_libref_stem
-EXPAND_LIBREF_5 = $(call EXPAND_LIBREF_6,$(1),$(dir $(1)),$(notdir $(1)))
-# ARGS: nested_libref_stem, dir_part, nondir_part
-EXPAND_LIBREF_6 = inst:$(1) dir:$(patsubst %/,%,$(2)) $(patsubst lib%,lib:%,$(3))
-
-# Read the contents of the `.libdeps` file for the specified library
-# and translate relative paths such that they are expressed relative
-# to the directory holding the local `Makefile`. For referenced
-# libraries defined in the local `Makefile`, the contents needs to be
-# computed "on the fly" because the `.libdeps` file may not yet be up
-# to date.
-#
-# ARGS: abstract_libref
-READ_LIBDEPS   = $(if $(call IS_LOCAL_NOINST_LIB,$(1)),$(call MAKE_NOINST_LIBDEPS,$(1)),$(if $(call IS_LOCAL_INST_LIB,$(1)),$(call MAKE_INST_LIBDEPS,$(1)),$(call READ_LIBDEPS_1,$(1))))
-READ_LIBDEPS_1 = $(call PATTERN_UNPACK_MAP,READ_LIBDEPS_2,lib:% rpath-noinst:%,$(call CAT_OPT_FILE,$(call GET_LIBRARY_STEM,$(1))$(LIB_SUFFIX_LIBDEPS)),$(dir $(1)))
-READ_LIBDEPS_2 = $(call MAKE_REL_PATH,$(2)$(1))
-# Is the specified library one that is defined in the local Makefile?
-IS_LOCAL_INST_LIB   = $(call FIND,IS_SAME_PATH_AS,$(INST_LIBRARIES),$(1))
-IS_LOCAL_NOINST_LIB = $(call FIND,IS_SAME_PATH_AS,$(noinst_LIBRARIES) $(check_LIBRARIES),$(1))
-
-# Quote elements for shell and translate relative paths such that they
-# become relative to the specified target directory. It is assumed
-# that the relative paths are currently relative to the current
-# working directory.
-#
-# ARGS: libdeps_contents, target_dir
-EXPORT_LIBDEPS = $(foreach x,$(call PATTERN_UNPACK_MAP,EXPORT_LIBDEPS_1,lib:% rpath-noinst:%,$(1),$(2)),$(call SHELL_ESCAPE,$(x)))
-EXPORT_LIBDEPS_1 = $(call MAKE_REL_PATH,$(1),$(2))
-
-# Compute what is almost the contents to be placed in the `.libdeps`
-# file for the specified library. The only thing that sets it apart
-# from what must ultimately be placed in the file, is that all
-# relative paths in the output of this function will be expressed
-# relative to the directory holding the local `Makefile`, and not
-# relative to the directory holding the `.libdeps` file (in case they
-# differ).
-#
-# ARGS: abstract_target
-MAKE_INST_LIBDEPS     = $(call EXTRACT_INST_LIB_LIBDEPS,$(call EXPAND_INST_LIB_LIBREFS,$(1)))
-MAKE_NOINST_LIBDEPS   = $(strip noinst $(call MAKE_NOINST_LIBDEPS_1,$(1)) $(call MAKE_NOINST_LIBDEPS_2,$(1)))
-MAKE_NOINST_LIBDEPS_1 = $(foreach x,$($(call FOLD_TARGET,$(1))_LIBS),lib:$(x) $(call READ_LIBDEPS,$(x)))
-MAKE_NOINST_LIBDEPS_2 = $(call MAKE_NOINST_LIBDEPS_3,$(1)) $(call MAKE_NOINST_LIBDEPS_4,$(1)) $(call MAKE_NOINST_LIBDEPS_5,$(1))
-MAKE_NOINST_LIBDEPS_3 = $(foreach x,$(call GET_FLAGS,$(call FOLD_TARGET,$(1))_LDFLAGS,OPTIM),ldflag-opt:$(x))
-MAKE_NOINST_LIBDEPS_4 = $(foreach x,$(call GET_FLAGS,$(call FOLD_TARGET,$(1))_LDFLAGS,DEBUG),ldflag-dbg:$(x))
-MAKE_NOINST_LIBDEPS_5 = $(foreach x,$(call GET_FLAGS,$(call FOLD_TARGET,$(1))_LDFLAGS,COVER),ldflag-cov:$(x))
-
-# ARGS: expanded_librefs
-EXTRACT_INST_LIB_LIBDEPS = $(filter rpath:% rpath-noinst:%,$(1))
-
-# Add library name qualification, and select the appropriate set of
-# linker flags for the specified compilation mode.
-#
-# ARGS: expanded_librefs, compile_mode
-FINALIZE_EXPANDED_LIBREFS   = $(call SELECT_LDFLAGS_$(2),$(call QUALIFY_LIBREFS,$(1),$(2)))
-QUALIFY_LIBREFS = $(call QUALIFY_LIBREFS_1,$(1),$(SUFFIX_LIB_STATIC_$(2)),$(SUFFIX_LIB_SHARED_$(2)),$(BASE_DENOM_2)$(LIB_DENOM_$(2)))
-QUALIFY_LIBREFS_1 = $(patsubst noinst:%,noinst:%$(2),$(patsubst inst:%,inst:%$(3),$(patsubst lib:%,lib:%$(4),$(1))))
-SELECT_LDFLAGS_OPTIM = $(patsubst ldflag-opt:%,ldflag:%,$(filter-out ldflag-dbg:% ldflag-cov:%,$(1)))
-SELECT_LDFLAGS_DEBUG = $(patsubst ldflag-dbg:%,ldflag:%,$(filter-out ldflag-opt:% ldflag-cov:%,$(1)))
-SELECT_LDFLAGS_COVER = $(patsubst ldflag-cov:%,ldflag:%,$(filter-out ldflag-opt:% ldflag-dbg:%,$(1)))
-
-# ARGS: abstract_target
-GET_LIBREFS_DEP_INFO = $(call GET_LIBREFS_DEP_INFO_1,$(foreach x,$($(call FOLD_TARGET,$(1))_LIBS),$(call EXPAND_LIBREF,$(x))))
-GET_LIBREFS_DEP_INFO_1 = $(filter noinst:% inst:% libdeps:%,$(1)) $(if $(filter rpath-noinst:%,$(1)),noinst_rpath)
-
-# ARGS: librefs_dep_info, compile_mode
-FINALIZE_LIBREFS_DEP_INFO = $(call FILTER_UNPACK,noinst:% inst:% libdeps:%,$(call QUALIFY_LIBREFS,$(1),$(2)))
-
-# ARGS: finalized_expanded_librefs
-LDFLAGS_FROM_LIBREFS = $(call FILTER_PATSUBST,noinst:%,%,$(1)) $(call FILTER_PATSUBST,lib:%,-l%,$(1)) $(call FILTER_PATSUBST,dir:%,-L%,$(1)) $(call FILTER_PATSUBST,ldflag:%,%,$(1))
-RPATHS_FROM_LIBREFS = $(NOINST_RPATHS_FROM_LIBREFS)
-ifeq ($(ENABLE_NOINST_BUILD),)
-RPATHS_FROM_LIBREFS = $(foreach x,$(call FILTER_PATSUBST,rpath:%,%,$(1)),-Wl,-rpath,$(x))
-endif
-NOINST_RPATHS_FROM_LIBREFS = $(foreach x,$(call FILTER_PATSUBST,rpath-noinst:%,%,$(1)),-Wl,-rpath,\$$ORIGIN$(if $(call IS_EQUAL_TO,$(x),.),,/$(x)))
-ifeq ($(OS),Darwin)
-NOINST_RPATHS_FROM_LIBREFS = $(foreach x,$(call FILTER_PATSUBST,rpath-noinst:%,%,$(1)),-Wl,-rpath,@loader_path/$(x))
-endif
-
-# ARGS: target, objects, abstract_target, compile_mode
-NOINST_PROG_RECIPE = $(call NOINST_PROG_RECIPE_1,$(1),$(2),$(3),$(4),$(call FINALIZE_EXPANDED_LIBREFS,$(call EXPAND_LIBREFS,$(3)),$(4)))
-NOINST_PROG_RECIPE_1 = $(call LIST_CONCAT,$(strip $(LD_PROG_$(4)) $(2) $(call LDFLAGS_FROM_LIBREFS,$(5)) $(call GET_LDFLAGS_FOR_TARGET,$(3),$(4)) $(LDFLAGS_ARCH)),$(call NOINST_RPATHS_FROM_LIBREFS,$(5))) -o $(1)
-
-INST_PROG_RECIPE = $(call INST_PROG_RECIPE_1,$(1),$(2),$(3),$(4),$(call FINALIZE_EXPANDED_LIBREFS,$(call EXPAND_LIBREFS,$(3)),$(4)))
-INST_PROG_RECIPE_1 = $(strip $(LD_PROG_$(4)) $(2) $(call LDFLAGS_FROM_LIBREFS,$(5)) $(call GET_LDFLAGS_FOR_TARGET,$(3),$(4)) $(LDFLAGS_ARCH) $(call RPATHS_FROM_LIBREFS,$(5))) -o $(1)
-
-# ARGS: target, objects, deps, abstract_target, compile_mode, has_noinst_rpaths
-define NOINST_PROG_RULES
-$(1): $(2) $(3)
-	$$(call NOINST_PROG_RECIPE,$(1),$(2),$(4),$(5))
-endef
-define INST_PROG_RULES
-ifeq ($(if $(ENABLE_NOINST_BUILD),,$(6)),)
-$(1): $(2) $(3)
-	$$(call INST_PROG_RECIPE,$(1),$(2),$(4),$(5))
-else
-$(1) $(1)-noinst: $(2) $(3)
-	$$(call INST_PROG_RECIPE,$(1),$(2),$(4),$(5))
-	$$(call NOINST_PROG_RECIPE,$(1)-noinst,$(2),$(4),$(5))
-endif
-endef
-
-# ARGS: abstract_target, abstract_objects, librefs_dep_info, extra_deps, compile_mode, prog_type
-EVAL_PROG_RULES_3 = $(eval $(call $(6)_PROG_RULES,$(1)$(SUFFIX_PROG_$(5)),$(patsubst %.o,%$(SUFFIX_OBJ_STATIC_$(5)),$(2)),$(call FINALIZE_LIBREFS_DEP_INFO,$(3),$(5)) $(call GET_DEPS_FOR_TARGET,$(1)),$(1),$(5),$(filter noinst_rpath,$(3))))
-
-EVAL_PROG_RULES_2 = $(foreach x,OPTIM DEBUG COVER,$(call EVAL_PROG_RULES_3,$(1),$(2),$(3),$(4),$(x),$(5)))
-
-EVAL_PROG_RULES_1 = $(call EVAL_PROG_RULES_2,$(1),$(call GET_OBJECTS_FOR_TARGET,$(1),.o),$(call GET_LIBREFS_DEP_INFO,$(1)),$(call GET_DEPS_FOR_TARGET,$(1)),$(2))
-
-$(foreach x,$(noinst_PROGRAMS) $(check_PROGRAMS),$(call EVAL_PROG_RULES_1,$(x),NOINST))
-$(foreach x,$(INST_PROGRAMS) $(DEV_PROGRAMS),$(call EVAL_PROG_RULES_1,$(x),INST))
-
-
-
-# CREATING/LINKING LIBRARIES
-
-# For each library `libfoo.a` (installed or uninstalled) a 'libdeps'
-# file called `libfoo.libdeps` is also created. This file contains a
-# space-separated list of entries of various different kinds needed
-# when linking project-local targets against the library. The order of
-# entries is immaterial.
-#
-#
-# If `libinst.a` is an installed library, then `libinst.libdeps`
-# contains a number of `rpath:` and `noninst-rpath:` entries. The
-# `rpath:` entries are used in `-rpath` flags when linking installed
-# programs against `libinst.a`. The `rpath-noinst:` entries are
-# similar, but they are used when linking programs that are not
-# installed (i.e., those that can be executed before `libinst.a` is
-# installed). While the paths specified by the `rpath:` entries are
-# absolute, the paths specified by the `noninst-rpath:` entries are
-# always relative to the directory containing the 'libdeps' file.
-#
-# First of all, `libinst.libdeps` contains an `rpath:` and a
-# `rpath-noinst:` entry for itself. For instance:
-#
-#     rpath:/usr/local/lib rpath-noinst:.
-#
-# Further more, `libinst.libdeps` contains an `rpath:` and a
-# `rpath-noinst:` entry for each installed library `libxxx.a`, that
-# `libinst.a` depends on, and which is also part of this project,
-# unless those entries would lead to duplicates. This is true even
-# when `libxxx.a` is an indirect dependency of `libinst.a`
-# (transitivity). For example, if `libxxx.a` is an dependency of
-# `libyyy.a` and `libyyy.a` is a dependency of `libinst.a`, then
-# `libxxx.a` is an indirect dependency of `libinst.a`. Let us assume
-# that `libinst.a`, `libxxx.a`, and `libyyy.a` are located in
-# subdirectories `inst`, `xxx`, and `yyy` respectively, and all are
-# installed in `/usr/local/lib`, then `libinst.libdeps` will contain
-#
-#     rpath:/usr/local/lib rpath-noinst:. rpath-noinst:../xxx
-#     rpath-noinst:../yyy
-#
-# Had they all been located in the same directory, `libinst.libdeps`
-# would instead contain
-#
-#     rpath:/usr/local/lib rpath-noinst:.
-#
-#
-# If `libconv.a` is a convenience library (not installed), then
-# `libconv.libdeps` contains a `noinst` entry that identifies it as a
-# convenience library from the point of view of `Makefile`s in other
-# subdirectories. Apart from that, it contains a `lib:` entry for each
-# installed project-local library that `libconv.a` directly depends
-# on, and it contains the union of the contents of the 'libdeps' files
-# associated with each of those `lib:` entries with relative paths
-# transformed as necessary. Aa with `noninst-rpath:`, the paths
-# specified by the `lib:` entries are always relative to the directory
-# containing the 'libdeps' file. For example, if `libconv.a` depends
-# on `libinst.a`, and `libconv.a` is located in the root directory of
-# the project, and the installed libraries are located in distinct
-# subdirectories as described in an example above, then
-# `libconv.libdeps` will contain
-#
-#     noinst lib:inst/libinst.a rpath:/usr/local/lib rpath-noinst:inst
-#     rpath-noinst:xxx rpath-noinst:yyy
-#
-# Note how the relative paths in the `rpath-noinst:` entries have been
-# transformed such that they are now relative to the root directory.
-#
-# When extra linker flags are attached to a convenience library, those
-# flags will also be carried in the 'libdeps' file. For example,
-# `libconv.libdeps` might contain
-#
-#     ldflag-opt:-lmagic ldflag-opt:-L/opt/magic/lib
-#     ldflag-dbg:-lmagic ldflag-dbg:-L/opt/magic-debug/lib
-#     ldflag-cov:-lmagic ldflag-cov:-L/opt/magic-debug/lib
-#
-# The `ldflag-opt:` entries are used when compiling in optimized
-# (default) mode, while the `ldflag-dbg:` and the `ldflag-cov:`
-# entries are used when compiling in debug and coverage modes
-# respectively.
-
-# ARGS: target, objects, extra_deps
-define STATIC_LIBRARY_RULE
-$(1): $(2) $(3)
-	$$(RM) $(1)
-	$$(strip $$(AR) $$(ARFLAGS_GENERAL) $(1) $(2))
-endef
-
-# ARGS: real_local_path, objects, finalized_expanded_librefs, extra_deps, link_cmd, ldflags, lib_version
-SHARED_LIBRARY_RULE_HELPER = $(call SHARED_LIBRARY_RULE,$(1),$(2) $(call FILTER_UNPACK,inst:% libdeps:%,$(3)) $(4),$(5) $(2) $(call LDFLAGS_FROM_LIBREFS,$(3)) $(6) $$(LDFLAGS_ARCH),$(if $(ENABLE_NOINST_BUILD),,$(7)))
-
-# ARGS: qual_lib_name, deps, cmd, version
-SHARED_LIBRARY_RULE = $(SHARED_LIBRARY_RULE_DEFAULT)
-define SHARED_LIBRARY_RULE_DEFAULT
-$(1): $(2)
-	$$(strip $(3)) -o $(1)
-	$(STRIP) -s $(1)
-endef
-
-ifeq ($(OS),Linux)
-
-# ARGS: qual_lib_name, deps, cmd, version
-SHARED_LIBRARY_RULE = $(if $(4),$(call SHARED_LIBRARY_RULE_VER,$(1),$(2),$(3),$(call MAP_SHARED_LIB_VERSION,$(4))),$(SHARED_LIBRARY_RULE_DEFAULT))
-
-# ARGS: qual_lib_name, deps, cmd, mapped_version
-SHARED_LIBRARY_RULE_VER = $(call SHARED_LIBRARY_RULE_VER_2,$(1),$(2),$(3),$(word 1,$(4)),$(word 2,$(4)))
-
-# ARGS: qual_lib_name, deps, cmd, major_version, full_version
-define SHARED_LIBRARY_RULE_VER_2
-$(1) $(1).$(4) $(1).$(5): $(2)
-	$$(strip $(3) -Wl,-soname,$(notdir $(1).$(4))) -o $(1).$(5)
-	ln -s -f $(notdir $(1).$(5)) $(1).$(4)
-	ln -s -f $(notdir $(1).$(4)) $(1)
-endef
-
-endif
-
-ifeq ($(OS),Darwin)
-
-# See http://www.mikeash.com/pyblog/friday-qa-2009-11-06-linking-and-install-names.html
-
-# ARGS: qual_lib_name, deps, cmd, version
-SHARED_LIBRARY_RULE = $(if $(4),$(call SHARED_LIBRARY_RULE_VER,$(1),$(2),$(3),$(call MAP_SHARED_LIB_VERSION,$(1),$(4))),$(SHARED_LIBRARY_RULE_DEFAULT))
-
-# ARGS: qual_lib_name, deps, cmd, mapped_version
-SHARED_LIBRARY_RULE_VER = $(call SHARED_LIBRARY_RULE_VER_2,$(1),$(2),$(3),$(word 1,$(4)),$(word 2,$(4)),$(word 3,$(4)))
-
-# ARGS: qual_lib_name, deps, cmd, qual_lib_name_with_version, compatibility_version, current_version
-define SHARED_LIBRARY_RULE_VER_2
-$(1) $(4): $(2)
-	$$(strip $(3) -install_name @rpath/$(notdir $(4)) -compatibility_version $(5) -current_version $(6)) -o $(4)
-	ln -s -f $(notdir $(4)) $(1)
-endef
-
-endif
-
-# ARGS: target_stem_path, contents, deps
-define LIBDEPS_RULE
-$(1)$$(LIB_SUFFIX_LIBDEPS): $(3) $$(DEP_MAKEFILES)
-	echo $$(call EXPORT_LIBDEPS,$(2),$(dir $(1))) >$(1)$$(LIB_SUFFIX_LIBDEPS)
-endef
-
-# ARGS: abstract_target, extra_deps
-define NOINST_LIB_RULES
-$(call STATIC_LIBRARY_RULE,$(call GET_LIBRARY_STEM,$(1))$(SUFFIX_LIB_STATIC_OPTIM),$(call GET_OBJECTS_FOR_TARGET,$(1),$(SUFFIX_OBJ_STATIC_OPTIM)),$(3))
-$(call STATIC_LIBRARY_RULE,$(call GET_LIBRARY_STEM,$(1))$(SUFFIX_LIB_STATIC_DEBUG),$(call GET_OBJECTS_FOR_TARGET,$(1),$(SUFFIX_OBJ_STATIC_DEBUG)),$(3))
-$(call STATIC_LIBRARY_RULE,$(call GET_LIBRARY_STEM,$(1))$(SUFFIX_LIB_STATIC_COVER),$(call GET_OBJECTS_FOR_TARGET,$(1),$(SUFFIX_OBJ_STATIC_COVER)),$(3))
-$(call LIBDEPS_RULE,$(call GET_LIBRARY_STEM,$(1)),$(call MAKE_NOINST_LIBDEPS,$(1)),$(foreach x,$($(call FOLD_TARGET,$(1))_LIBS),$(call GET_LIBRARY_STEM,$(x))$(LIB_SUFFIX_LIBDEPS)))
-endef
-
-# ARGS: abstract_target, expanded_librefs, extra_deps
-define INST_LIB_RULES
-$(call STATIC_LIBRARY_RULE,$(call GET_LIBRARY_STEM,$(1))$(SUFFIX_LIB_STATIC_OPTIM),$(call GET_OBJECTS_FOR_TARGET,$(1),$(SUFFIX_OBJ_STATIC_OPTIM)),$(3))
-$(call STATIC_LIBRARY_RULE,$(call GET_LIBRARY_STEM,$(1))$(SUFFIX_LIB_STATIC_DEBUG),$(call GET_OBJECTS_FOR_TARGET,$(1),$(SUFFIX_OBJ_STATIC_DEBUG)),$(3))
-$(call STATIC_LIBRARY_RULE,$(call GET_LIBRARY_STEM,$(1))$(SUFFIX_LIB_STATIC_COVER),$(call GET_OBJECTS_FOR_TARGET,$(1),$(SUFFIX_OBJ_STATIC_COVER)),$(3))
-$(call SHARED_LIBRARY_RULE_HELPER,$(call GET_LIBRARY_STEM,$(1))$(SUFFIX_LIB_SHARED_OPTIM),$(call GET_OBJECTS_FOR_TARGET,$(1),$(SUFFIX_OBJ_SHARED_OPTIM)),$(call FINALIZE_EXPANDED_LIBREFS,$(2),OPTIM),$(3),$$(LD_LIB_OPTIM),$(call GET_LDFLAGS_FOR_TARGET,$(1),OPTIM),$(call GET_LIBRARY_VERSION,$(1)))
-$(call SHARED_LIBRARY_RULE_HELPER,$(call GET_LIBRARY_STEM,$(1))$(SUFFIX_LIB_SHARED_DEBUG),$(call GET_OBJECTS_FOR_TARGET,$(1),$(SUFFIX_OBJ_SHARED_DEBUG)),$(call FINALIZE_EXPANDED_LIBREFS,$(2),DEBUG),$(3),$$(LD_LIB_DEBUG),$(call GET_LDFLAGS_FOR_TARGET,$(1),DEBUG),$(call GET_LIBRARY_VERSION,$(1)))
-$(call SHARED_LIBRARY_RULE_HELPER,$(call GET_LIBRARY_STEM,$(1))$(SUFFIX_LIB_SHARED_COVER),$(call GET_OBJECTS_FOR_TARGET,$(1),$(SUFFIX_OBJ_SHARED_COVER)),$(call FINALIZE_EXPANDED_LIBREFS,$(2),COVER),$(3),$$(LD_LIB_COVER),$(call GET_LDFLAGS_FOR_TARGET,$(1),COVER),$(call GET_LIBRARY_VERSION,$(1)))
-$(call LIBDEPS_RULE,$(call GET_LIBRARY_STEM,$(1)),$(call EXTRACT_INST_LIB_LIBDEPS,$(2)),$(call FILTER_PATSUBST,libdeps:%,%,$(2)))
-endef
-
-define LIBRARY_RULES
-$(foreach x,$(noinst_LIBRARIES) $(check_LIBRARIES),$(NEWLINE)$(call NOINST_LIB_RULES,$(x),$(call GET_DEPS_FOR_TARGET,$(x)))$(NEWLINE))
-$(foreach x,$(INST_LIBRARIES),$(NEWLINE)$(call INST_LIB_RULES,$(x),$(call EXPAND_INST_LIB_LIBREFS,$(x)),$(call GET_DEPS_FOR_TARGET,$(x)))$(NEWLINE))
-endef
-
-$(eval $(LIBRARY_RULES))
-
-
-
-# FLEX AND BISON
-
-%.flex.cpp %.flex.hpp: %.flex $(DEP_MAKEFILES)
-	flex --outfile=$*.flex.cpp --header-file=$*.flex.hpp $<
-
-%.bison.cpp %.bison.hpp: %.bison $(DEP_MAKEFILES)
-	bison --output=$*.bison.cpp --defines=$*.bison.hpp $<
-
-
-
-# COMPILING + AUTOMATIC DEPENDENCIES
-
-$(foreach x,$(LIBRARIES) $(PROGRAMS),$(foreach y,$(call GET_OBJECTS_FOR_TARGET,$(x),.o),$(eval GMK_TARGETS_$(call FOLD_TARGET,$(y)) += $(x))))
-
-GET_CFLAGS_FOR_TARGET = $(foreach x,PROJECT DIR $(foreach y,$(GMK_TARGETS_$(call FOLD_TARGET,$(1))) $(1),$(call FOLD_TARGET,$(y))),$(call GET_FLAGS,$(x)_CFLAGS,$(2)))
-
-%$(SUFFIX_OBJ_STATIC_OPTIM): %.c
-	$(strip $(CC_STATIC_OPTIM) $(call GET_CFLAGS_FOR_TARGET,$*.o,OPTIM) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_STATIC_OPTIM): %.cpp
-	$(strip $(CXX_STATIC_OPTIM) $(call GET_CFLAGS_FOR_TARGET,$*.o,OPTIM) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_SHARED_OPTIM): %.c
-	$(strip $(CC_SHARED_OPTIM) $(call GET_CFLAGS_FOR_TARGET,$*.o,OPTIM) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_SHARED_OPTIM): %.cpp
-	$(strip $(CXX_SHARED_OPTIM) $(call GET_CFLAGS_FOR_TARGET,$*.o,OPTIM) $(CFLAGS_OTHER)) -c $< -o $@
-
-
-%$(SUFFIX_OBJ_STATIC_DEBUG): %.c
-	$(strip $(CC_STATIC_DEBUG) $(call GET_CFLAGS_FOR_TARGET,$*.o,DEBUG) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_STATIC_DEBUG): %.cpp
-	$(strip $(CXX_STATIC_DEBUG) $(call GET_CFLAGS_FOR_TARGET,$*.o,DEBUG) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_SHARED_DEBUG): %.c
-	$(strip $(CC_SHARED_DEBUG) $(call GET_CFLAGS_FOR_TARGET,$*.o,DEBUG) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_SHARED_DEBUG): %.cpp
-	$(strip $(CXX_SHARED_DEBUG) $(call GET_CFLAGS_FOR_TARGET,$*.o,DEBUG) $(CFLAGS_OTHER)) -c $< -o $@
-
-
-%$(SUFFIX_OBJ_STATIC_COVER): %.c
-	$(strip $(CC_STATIC_COVER) $(call GET_CFLAGS_FOR_TARGET,$*.o,COVER) $(CFLAGS_OTHER)) -c $(abspath $<) -o $(abspath $@)
-
-%$(SUFFIX_OBJ_STATIC_COVER): %.cpp
-	$(strip $(CXX_STATIC_COVER) $(call GET_CFLAGS_FOR_TARGET,$*.o,COVER) $(CFLAGS_OTHER)) -c $(abspath $<) -o $(abspath $@)
-
-%$(SUFFIX_OBJ_SHARED_COVER): %.c
-	$(strip $(CC_SHARED_COVER) $(call GET_CFLAGS_FOR_TARGET,$*.o,COVER) $(CFLAGS_OTHER)) -c $(abspath $<) -o $(abspath $@)
-
-%$(SUFFIX_OBJ_SHARED_COVER): %.cpp
-	$(strip $(CXX_SHARED_COVER) $(call GET_CFLAGS_FOR_TARGET,$*.o,COVER) $(CFLAGS_OTHER)) -c $(abspath $<) -o $(abspath $@)
-
-
-
-%$(SUFFIX_OBJ_STATIC_OPTIM): %.m
-	$(strip $(OCC_STATIC_OPTIM) $(call GET_CFLAGS_FOR_TARGET,$*.o,OPTIM) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_STATIC_OPTIM): %.mm
-	$(strip $(OCXX_STATIC_OPTIM) $(call GET_CFLAGS_FOR_TARGET,$*.o,OPTIM) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_SHARED_OPTIM): %.m
-	$(strip $(OCC_SHARED_OPTIM) $(call GET_CFLAGS_FOR_TARGET,$*.o,OPTIM) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_SHARED_OPTIM): %.mm
-	$(strip $(OCXX_SHARED_OPTIM) $(call GET_CFLAGS_FOR_TARGET,$*.o,OPTIM) $(CFLAGS_OTHER)) -c $< -o $@
-
-
-%$(SUFFIX_OBJ_STATIC_DEBUG): %.m
-	$(strip $(OCC_STATIC_DEBUG) $(call GET_CFLAGS_FOR_TARGET,$*.o,DEBUG) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_STATIC_DEBUG): %.mm
-	$(strip $(OCXX_STATIC_DEBUG) $(call GET_CFLAGS_FOR_TARGET,$*.o,DEBUG) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_SHARED_DEBUG): %.m
-	$(strip $(OCC_SHARED_DEBUG) $(call GET_CFLAGS_FOR_TARGET,$*.o,DEBUG) $(CFLAGS_OTHER)) -c $< -o $@
-
-%$(SUFFIX_OBJ_SHARED_DEBUG): %.mm
-	$(strip $(OCXX_SHARED_DEBUG) $(call GET_CFLAGS_FOR_TARGET,$*.o,DEBUG) $(CFLAGS_OTHER)) -c $< -o $@
-
-
-%$(SUFFIX_OBJ_STATIC_COVER): %.m
-	$(strip $(OCC_STATIC_COVER) $(call GET_CFLAGS_FOR_TARGET,$*.o,COVER) $(CFLAGS_OTHER)) -c $(abspath $<) -o $(abspath $@)
-
-%$(SUFFIX_OBJ_STATIC_COVER): %.mm
-	$(strip $(OCXX_STATIC_COVER) $(call GET_CFLAGS_FOR_TARGET,$*.o,COVER) $(CFLAGS_OTHER)) -c $(abspath $<) -o $(abspath $@)
-
-%$(SUFFIX_OBJ_SHARED_COVER): %.m
-	$(strip $(OCC_SHARED_COVER) $(call GET_CFLAGS_FOR_TARGET,$*.o,COVER) $(CFLAGS_OTHER)) -c $(abspath $<) -o $(abspath $@)
-
-%$(SUFFIX_OBJ_SHARED_COVER): %.mm
-	$(strip $(OCXX_SHARED_COVER) $(call GET_CFLAGS_FOR_TARGET,$*.o,COVER) $(CFLAGS_OTHER)) -c $(abspath $<) -o $(abspath $@)
-
-
--include $(OBJECTS:.o=.d)
diff --git a/realm/realm-jni/project.mk b/realm/realm-jni/project.mk
deleted file mode 100644
index cf9b0e6b95..0000000000
--- a/realm/realm-jni/project.mk
+++ /dev/null
@@ -1,64 +0,0 @@
-ENABLE_INSTALL_DEBUG_LIBS = 1
-
-# Construct fat binaries on Darwin when using Clang
-ifneq ($(REALM_ENABLE_FAT_BINARIES),)
-  ifeq ($(OS),Darwin)
-    ifeq ($(COMPILER_IS),clang)
-      CFLAGS_ARCH += -arch i386 -arch x86_64
-    endif
-  endif
-endif
-
-ifeq ($(OS),Darwin)
-  CFLAGS_ARCH += -mmacosx-version-min=10.8 -stdlib=libc++
-endif
-
-# FIXME: '-fno-elide-constructors' currently causes Realm to fail
-#CFLAGS_DEBUG += -fno-elide-constructors
-CFLAGS_PTHREADS += -pthread
-CFLAGS_GENERAL += -Wextra -ansi -pedantic -Wno-long-long
-
-# Avoid a warning from Clang when linking on OS X. By default,
-# `LDFLAGS_PTHREADS` inherits its value from `CFLAGS_PTHREADS`, so we
-# have to override that with an empty value.
-ifeq ($(OS),Darwin)
-  ifeq ($(LD_IS),clang)
-    LDFLAGS_PTHREADS = $(EMPTY)
-  endif
-endif
-
-# Load dynamic configuration
-#ifeq ($(NO_CONFIG_MK),)
-  #CONFIG_MK = $(GENERIC_MK_DIR)/config.mk
-  #DEP_MAKEFILES += $(CONFIG_MK)
-  #include $(CONFIG_MK)
-  LIB_SUFFIX_SHARED = $(JNI_SUFFIX)
-  #EXTRA_PRIMARY_PREFIXES = jni
-  #jnidir = $(JNI_INSTALL_DIR)
-#endif
-
-ifeq ($(REALM_ANDROID),)
-  REALM_LDFLAGS += -llog
-  CFLAGS_INCLUDE += $(JAVA_CFLAGS)
-  ifneq ($(REALM_ENABLE_MEM_USAGE),)
-    PROJECT_CFLAGS += -DREALM_ENABLE_MEM_USAGE
-    ifeq ($(shell pkg-config libprocps --exists 2>/dev/null && echo yes),yes)
-      PROCPS_CFLAGS  := $(shell pkg-config libprocps --cflags)
-      PROCPS_LDFLAGS := $(shell pkg-config libprocps --libs)
-      PROJECT_CFLAGS  += $(PROCPS_CFLAGS)
-      PROJECT_LDFLAGS += $(PROCPS_LDFLAGS)
-    else
-      PROJECT_LDFLAGS += -lproc
-    endif
-  endif
-else
-  PROJECT_CFLAGS += -DANDROID
-  CFLAGS_OPTIM = -Os -DNDEBUG
-endif
-
-PROJECT_CFLAGS_OPTIM  += ${REALM_CFLAGS_COMMON} $(REALM_CFLAGS)
-PROJECT_CFLAGS_DEBUG  += ${REALM_CFLAGS_COMMON} $(REALM_CFLAGS_DBG)
-PROJECT_CFLAGS_COVER  += ${REALM_CFLAGS_COMMON} $(REALM_CFLAGS_DBG)
-PROJECT_LDFLAGS_OPTIM += $(REALM_LDFLAGS_COMMON) $(REALM_LDFLAGS)
-PROJECT_LDFLAGS_DEBUG += $(REALM_LDFLAGS_COMMON) $(REALM_LDFLAGS_DBG)
-PROJECT_LDFLAGS_COVER += $(REALM_LDFLAGS_COMMON) $(REALM_LDFLAGS_DBG)
diff --git a/realm/realm-jni/src/Makefile b/realm/realm-jni/src/Makefile
deleted file mode 100644
index 4a8eabdd10..0000000000
--- a/realm/realm-jni/src/Makefile
+++ /dev/null
@@ -1,6 +0,0 @@
-lib_LIBRARIES = librealm-jni.a
-
-JNI_SOURCES := $(wildcard *.cpp)
-librealm_jni_a_SOURCES = $(JNI_SOURCES)
-
-include ../generic.mk
diff --git a/realm/realm-jni/src/TableSpecUtil.cpp b/realm/realm-jni/src/TableSpecUtil.cpp
deleted file mode 100644
index ed028cfd5f..0000000000
--- a/realm/realm-jni/src/TableSpecUtil.cpp
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "util.hpp"
-#include "TableSpecUtil.hpp"
-#include "columntypeutil.hpp"
-
-using namespace std;
-using namespace realm;
-
-jclass GetClassTableSpec(JNIEnv* env)
-{
-    static jclass myClass = GetClass(env, "io/realm/internal/TableSpec");
-    return myClass;
-}
-
-jmethodID GetTableSpecMethodID(JNIEnv* env, const char* methodStr, const char* typeStr)
-{
-    jclass myClass = GetClassTableSpec(env);
-    if (myClass == NULL) {
-        return NULL;
-    }
-    jmethodID myMethod = env->GetMethodID(myClass, methodStr, typeStr);
-    if (myMethod == NULL) {
-        ThrowException(env, NoSuchMethod, "TableSpec", methodStr);
-        return NULL;
-    }
-    return myMethod;
-}
-
-jlong Java_io_realm_TableSpec_getColumnCount(JNIEnv* env, jobject jTableSpec)
-{
-    static jmethodID jGetColumnCountMethodId = GetTableSpecMethodID(env, "getColumnCount", "()J");
-    if (jGetColumnCountMethodId)
-        return env->CallLongMethod(jTableSpec, jGetColumnCountMethodId);
-    return 0;
-}
-
-jobject Java_io_realm_TableSpec_getColumnType(JNIEnv* env, jobject jTableSpec, jlong columnIndex)
-{
-    static jmethodID jGetColumnTypeMethodId = GetTableSpecMethodID(env, "getColumnType", "(J)Lio/realm/RealmFieldType;");
-    if (jGetColumnTypeMethodId)
-        return env->CallObjectMethod(jTableSpec, jGetColumnTypeMethodId, columnIndex);
-    return NULL;
-}
-
-jstring Java_io_realm_TableSpec_getColumnName(JNIEnv* env, jobject jTableSpec, jlong columnIndex)
-{
-    static jmethodID jGetColumnNameMethodId = GetTableSpecMethodID(env, "getColumnName", "(J)Ljava/lang/String;");
-    if (jGetColumnNameMethodId)
-        return (jstring)env->CallObjectMethod(jTableSpec, jGetColumnNameMethodId, columnIndex);
-    return NULL;
-}
-
-jobject Java_io_realm_TableSpec_getTableSpec(JNIEnv* env, jobject jTableSpec, jlong columnIndex)
-{
-    static jmethodID jGetTableSpecMethodId = GetTableSpecMethodID(env, "getSubtableSpec", "(J)Lio/realm/internal/TableSpec;");
-    if (jGetTableSpecMethodId)
-        return env->CallObjectMethod(jTableSpec, jGetTableSpecMethodId, columnIndex);
-    return NULL;
-}
-
-jlong Java_io_realm_TableSpec_getColumnIndex(JNIEnv* env, jobject jTableSpec, jstring columnName)
-{
-    static jmethodID jGetColumnIndexMethodId = GetTableSpecMethodID(env, "getColumnIndex", "(Ljava/lang/String;)J");
-    if (jGetColumnIndexMethodId)
-        return env->CallLongMethod(jTableSpec, jGetColumnIndexMethodId, columnName);
-    return 0;
-}
-
-void set_descriptor(JNIEnv* env, Descriptor& desc, jobject jTableSpec)
-{
-    jlong n = Java_io_realm_TableSpec_getColumnCount(env, jTableSpec);
-    for (jlong i = 0; i != n; ++i) {
-        jstring jColumnName = Java_io_realm_TableSpec_getColumnName(env, jTableSpec, i);
-        JStringAccessor name(env, jColumnName);  // throws
-
-        jobject jColumnType = Java_io_realm_TableSpec_getColumnType(env, jTableSpec, i);
-        DataType type = GetColumnTypeFromJColumnType(env, jColumnType);
-        DescriptorRef subdesc;
-        desc.add_column(type, name, &subdesc); // Throws
-        if (type == type_Table) {
-            jobject jNextColumnTableSpec = Java_io_realm_TableSpec_getTableSpec(env, jTableSpec, i);
-            set_descriptor(env, *subdesc, jNextColumnTableSpec);
-        }
-    }
-}
-
-void get_descriptor(JNIEnv* env, const Descriptor& desc, jobject jTableSpec)
-{
-    static jmethodID jAddColumnMethodId = GetTableSpecMethodID(env, "addColumn", "(ILjava/lang/String;)V");
-    static jmethodID jAddSubtableColumnMethodId = GetTableSpecMethodID(env, "addSubtableColumn", 
-                                                                            "(Ljava/lang/String;)Lio/realm/internal/TableSpec;");
-
-    if (jAddColumnMethodId == NULL || jAddSubtableColumnMethodId == NULL) {
-        return;
-    }
-
-    size_t n = desc.get_column_count(); // noexcept
-    for (size_t i = 0; i != n; ++i) {
-        DataType type   = desc.get_column_type(i); // noexcept
-        StringData name = desc.get_column_name(i); // noexcept
-        if (type == type_Table) {
-            jobject jSubTableSpec = env->CallObjectMethod(jTableSpec, jAddSubtableColumnMethodId, 
-                                                          to_jstring(env, name));
-            ConstDescriptorRef subdesc = desc.get_subdescriptor(i); // Throws
-            get_descriptor(env, *subdesc, jSubTableSpec);
-        }
-        else {
-            env->CallVoidMethod(jTableSpec, jAddColumnMethodId, jint(type), to_jstring(env, name));
-        }
-    }
-}
diff --git a/realm/realm-jni/src/TableSpecUtil.hpp b/realm/realm-jni/src/TableSpecUtil.hpp
deleted file mode 100644
index d1d4715f45..0000000000
--- a/realm/realm-jni/src/TableSpecUtil.hpp
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef REALM_JAVA_TABLE_SPEC_UTIL_HPP
-#define REALM_JAVA_TABLE_SPEC_UTIL_HPP
-
-#include <cstddef>
-#include <vector>
-#include <jni.h>
-#include <realm/table.hpp>
-
-jlong Java_io_realm_TableSpec_getColumnCount(JNIEnv*, jobject jTableSpec);
-
-jobject Java_io_realm_TableSpec_getColumnType(JNIEnv*, jobject jTableSpec, jlong columnIndex);
-
-jstring Java_io_realm_TableSpec_getColumnName(JNIEnv*, jobject jTableSpec, jlong columnIndex);
-
-jobject Java_io_realm_TableSpec_getTableSpec(JNIEnv*, jobject jTableSpec, jlong columnIndex);
-
-jlong Java_io_realm_TableSpec_getColumnIndex(JNIEnv*, jobject jTableSpec, jstring columnName);
-
-void set_descriptor(JNIEnv*,       realm::Descriptor&, jobject jTableSpec);
-void get_descriptor(JNIEnv*, const realm::Descriptor&, jobject jTableSpec);
-
-jclass GetClassTableSpec(JNIEnv*);
-jmethodID GetTableSpecMethodID(JNIEnv*, const char* methodStr, const char* typeStr);
-
-#endif // REALM_JAVA_TABLE_SPEC_UTIL_HPP
diff --git a/realm/realm-jni/src/columntypeutil.cpp b/realm/realm-jni/src/columntypeutil.cpp
deleted file mode 100644
index 44e3af06d1..0000000000
--- a/realm/realm-jni/src/columntypeutil.cpp
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "util.hpp"
-#include "columntypeutil.hpp"
-
-
-static jfieldID GetFieldIDColumnType(JNIEnv* env, const char* methodStr, const char* typeStr)
-{
-    static jclass myClass = GetClass(env, "io/realm/RealmFieldType");
-    if (myClass == NULL)
-        return NULL;
-
-    jfieldID myField = env->GetFieldID(myClass, methodStr, typeStr);
-    if (myField== NULL) {
-        ThrowException(env, NoSuchField, "ColumnType", methodStr);
-        return NULL;
-    }
-    return myField;
-}
-
-DataType GetColumnTypeFromJColumnType(JNIEnv* env, jobject jColumnType)
-{
-    static jfieldID jValueFieldId = GetFieldIDColumnType(env, "nativeValue", "I");
-    if (jValueFieldId == NULL)
-        return DataType(0);
-
-    jint columnType = env->GetIntField(jColumnType, jValueFieldId);
-    return static_cast<DataType>(columnType);
-}
-
-jobject GetJColumnTypeFromColumnType(JNIEnv* env, DataType columnType)
-{
-    TR("enter GetJColumnTypeFromColumnType(%d)", columnType)
-    static jclass jColumnTypeClass = GetClass(env, "io/realm/RealmFieldType");
-
-    if (jColumnTypeClass == NULL) {
-        TR("--class is NULL");
-        return NULL;
-    }
-
-    // Couldn't figure out how to create a new enum on Java side and return as object...
-    // A workaround in java to not check for the correct ColumnTypeTable works.
-    /*
-    jmethodID jColumnTypeConsId2 = env->GetMethodID(jColumnTypeClass, "<init>", "()V");
-    if (jColumnTypeConsId2) {
-        TR((env, "-GOT INIT"));
-        return NULL;
-    }
-    */
-
-   /*
-    jfieldID subtable_id = env->GetStaticFieldID(jColumnTypeClass, "ColumnTypeTable", "LColumnType;");
-    if (!subtable_id) {
-        TR((env, "--subtable_id is NULL"));
-        return NULL;
-    }
-
-    jobject jColumnTypeConsId = env->GetStaticObjectField(jColumnTypeClass, subtable_id);
-    if (jColumnTypeConsId == NULL) {
-        TR((env, "---2.5"));
-        ThrowException(env, NoSuchMethod, "ColumnType", "<init>");
-        return NULL;
-    }
-    return jColumnTypeConsId;
-    */
-
-    return NULL;
-    //jobject jColumnType = env->NewObject(jColumnTypeClass, jColumnTypeConsId,
-                                       //  static_cast<jint>(columnType));
-    //jobject jColumnType = env->NewObject(jColumnTypeClass, jColumnTypeConsId);
-
-    //TR((env, "jni: New ColumnType %d.", columnType));
-    //return jColumnType;
-}
diff --git a/realm/realm-jni/src/columntypeutil.hpp b/realm/realm-jni/src/columntypeutil.hpp
deleted file mode 100644
index 07f3e5d324..0000000000
--- a/realm/realm-jni/src/columntypeutil.hpp
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef REALM_COLUMN_TYPE_UTIL_H
-#define REALM_COLUMN_TYPE_UTIL_H
-
-#include <jni.h>
-#include <realm.hpp>
-
-#ifdef __cplusplus
-
-using realm::DataType;
-
-extern "C" {
-
-#endif
-
-DataType GetColumnTypeFromJColumnType(JNIEnv* env, jobject jColumnType);
-jobject GetJColumnTypeFromColumnType(JNIEnv* env, DataType columnType);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/realm/realm-jni/src/io_realm_internal_CheckedRow.h b/realm/realm-jni/src/io_realm_internal_CheckedRow.h
deleted file mode 100644
index 2ef21447c4..0000000000
--- a/realm/realm-jni/src/io_realm_internal_CheckedRow.h
+++ /dev/null
@@ -1,229 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_CheckedRow */
-
-#ifndef _Included_io_realm_internal_CheckedRow
-#define _Included_io_realm_internal_CheckedRow
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetColumnCount
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnCount
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetColumnName
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnName
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetColumnIndex
- * Signature: (JLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnIndex
-  (JNIEnv *, jobject, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetColumnType
- * Signature: (JJ)I
- */
-JNIEXPORT jint JNICALL Java_io_realm_internal_CheckedRow_nativeGetColumnType
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetLong
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLong
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetBoolean
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeGetBoolean
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetFloat
- * Signature: (JJ)F
- */
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_CheckedRow_nativeGetFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetDouble
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_CheckedRow_nativeGetDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetTimestamp
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetTimestamp
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_CheckedRow_nativeGetString
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeIsNullLink
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeIsNullLink
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetByteArray
- * Signature: (JJ)[B
- */
-JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_CheckedRow_nativeGetByteArray
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetMixedType
- * Signature: (JJ)I
- */
-JNIEXPORT jint JNICALL Java_io_realm_internal_CheckedRow_nativeGetMixedType
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetMixed
- * Signature: (JJ)Lio/realm/internal/Mixed;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_CheckedRow_nativeGetMixed
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetLinkView
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLinkView
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeSetLong
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetLong
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeSetBoolean
- * Signature: (JJZ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetBoolean
-  (JNIEnv *, jobject, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeSetFloat
- * Signature: (JJF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetFloat
-  (JNIEnv *, jobject, jlong, jlong, jfloat);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeGetLink
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLink
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeSetDouble
- * Signature: (JJD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetDouble
-  (JNIEnv *, jobject, jlong, jlong, jdouble);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeSetTimestamp
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetTimestamp
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeSetString
- * Signature: (JJLjava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetString
-  (JNIEnv *, jobject, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeSetByteArray
- * Signature: (JJ[B)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetByteArray
-  (JNIEnv *, jobject, jlong, jlong, jbyteArray);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeSetMixed
- * Signature: (JJLio/realm/internal/Mixed;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetMixed
-  (JNIEnv *, jobject, jlong, jlong, jobject);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeSetLink
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetLink
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeNullifyLink
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeNullifyLink
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_CheckedRow
- * Method:    nativeIsNull
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeIsNull
-  (JNIEnv *, jobject, jlong, jlong);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm/realm-jni/src/io_realm_internal_Group.cpp b/realm/realm-jni/src/io_realm_internal_Group.cpp
deleted file mode 100644
index ad2237df66..0000000000
--- a/realm/realm-jni/src/io_realm_internal_Group.cpp
+++ /dev/null
@@ -1,328 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <realm/util/safe_int_ops.hpp>
-
-#include "util.hpp"
-#include "io_realm_internal_Group.h"
-
-using namespace realm;
-using std::string;
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative__(
-    JNIEnv*,  jobject)
-{
-    TR_ENTER()
-    Group *ptr = new Group();
-    TR("Group::createNative(): %p.", VOID_PTR(ptr))
-    return reinterpret_cast<jlong>(ptr);
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative__Ljava_lang_String_2I(
-    JNIEnv* env, jobject, jstring jFileName, jint mode, jbyteArray keyArray)
-{
-    TR_ENTER()
-
-    Group* pGroup = 0;
-    StringData file_name;
-    try {
-        JStringAccessor file_name_tmp(env, jFileName); // throws
-        file_name = StringData(file_name_tmp);
-        Group::OpenMode openmode;
-        switch (mode) {
-        case 0: openmode = Group::mode_ReadOnly; break;
-        case 1: openmode = Group::mode_ReadWrite; break;
-        case 2: openmode = Group::mode_ReadWriteNoCreate; break;
-        default:
-            TR("Invalid mode: %d", mode)
-            ThrowException(env, IllegalArgument, "Group(): Invalid mode parameter.");
-            return 0;
-        }
-
-        KeyBuffer key(env, keyArray);
-#ifdef REALM_ENABLE_ENCRYPTION
-        pGroup = new Group(file_name, key.data(), openmode);
-#else
-        pGroup = new Group(file_name, NULL, openmode);
-#endif
-
-        TR("group: %p", VOID_PTR(pGroup))
-        return reinterpret_cast<jlong>(pGroup);
-    }
-    CATCH_FILE(file_name)
-    CATCH_STD()
-
-    // Failed - cleanup
-    if (pGroup)
-        delete pGroup;
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative___3B(
-    JNIEnv* env, jobject, jbyteArray jData)
-{
-    TR_ENTER()
-    // Copy the group buffer given
-    jsize byteArrayLength = env->GetArrayLength(jData);
-    if (byteArrayLength == 0)
-        return 0;
-    jbyte* buf = static_cast<jbyte*>(malloc(S(byteArrayLength)*sizeof(jbyte)));
-    if (!buf) {
-        ThrowException(env, OutOfMemory, "copying the group buffer.");
-        return 0;
-    }
-    env->GetByteArrayRegion(jData, 0, byteArrayLength, buf);
-
-    TR("%d bytes.", byteArrayLength)
-    Group* pGroup = 0;
-    try {
-        pGroup = new Group(BinaryData(reinterpret_cast<char*>(buf), S(byteArrayLength)), true);
-        TR("groupPtr: %p", VOID_PTR(pGroup))
-        return reinterpret_cast<jlong>(pGroup);
-    }
-    CATCH_FILE("memory-buffer")
-    CATCH_STD()
-
-    // Failed - cleanup
-    if (buf)
-        free(buf);
-    return 0;
-}
-
-// FIXME: Remove this method? It's dangerous to not own the group data...
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative__Ljava_nio_ByteBuffer_2(
-    JNIEnv* env, jobject, jobject jByteBuffer)
-{
-    TR_ENTER()
-    BinaryData bin;
-    if (!GetBinaryData(env, jByteBuffer, bin))
-        return 0;
-    TR("%" PRId64 " bytes.", S64(bin.size()))
-
-    Group* pGroup = 0;
-    try {
-        pGroup = new Group(BinaryData(bin.data(), bin.size()), false);
-    }
-    CATCH_FILE("memory-buffer")
-    CATCH_STD()
-
-    TR("%p", VOID_PTR(pGroup))
-    return reinterpret_cast<jlong>(pGroup);
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeClose(
-    JNIEnv*, jclass, jlong nativeGroupPtr)
-{
-    TR_ENTER_PTR(nativeGroupPtr)
-    delete G(nativeGroupPtr);
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_nativeSize(
-    JNIEnv*, jobject, jlong nativeGroupPtr)
-{
-    TR_ENTER_PTR(nativeGroupPtr)
-    return static_cast<jlong>( G(nativeGroupPtr)->size() ); // noexcept
-}
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeHasTable(
-    JNIEnv* env, jobject, jlong nativeGroupPtr, jstring jTableName)
-{
-    TR_ENTER_PTR(nativeGroupPtr)
-    try {
-        JStringAccessor tableName(env, jTableName); // throws
-        return G(nativeGroupPtr)->has_table(tableName);
-    } CATCH_STD()
-    return false;
-}
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Group_nativeGetTableName(
-    JNIEnv* env, jobject, jlong nativeGroupPtr, jint index)
-{
-    TR_ENTER_PTR(nativeGroupPtr)
-    try {
-        return to_jstring(env, G(nativeGroupPtr)->get_table_name(index));
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeRemoveTable(
-    JNIEnv* env, jobject, jlong nativeGroupPtr, jstring name)
-{
-    TR_ENTER_PTR(nativeGroupPtr)
-    try {
-        JStringAccessor table_name(env, name);
-        G(nativeGroupPtr)->remove_table(table_name);
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeRenameTable(
-    JNIEnv* env, jobject, jlong nativeGroupPtr, jstring oldName, jstring newName)
-{
-    TR_ENTER_PTR(nativeGroupPtr)
-    try {
-        JStringAccessor old_name(env, oldName);
-        JStringAccessor new_name(env, newName);
-        G(nativeGroupPtr)->rename_table(old_name, new_name);
-    } CATCH_STD()
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_nativeGetTableNativePtr(
-    JNIEnv *env, jobject, jlong nativeGroupPtr, jstring name)
-{
-    TR_ENTER_PTR(nativeGroupPtr)
-    try {
-        JStringAccessor tableName(env, name); // throws
-        Table* pTable = LangBindHelper::get_or_add_table(*G(nativeGroupPtr), tableName);
-        return (jlong)pTable;
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeWriteToFile(
-    JNIEnv* env, jobject, jlong nativeGroupPtr, jstring jFileName, jbyteArray keyArray)
-{
-    TR_ENTER_PTR(nativeGroupPtr)
-    StringData file_name;
-    KeyBuffer key(env, keyArray);
-    try {
-        JStringAccessor file_name_tmp(env, jFileName); // throws
-        file_name = StringData(file_name_tmp);
-#ifdef REALM_ENABLE_ENCRYPTION
-        G(nativeGroupPtr)->write(file_name, key.data());
-#else
-        G(nativeGroupPtr)->write(file_name);
-#endif
-    }
-    CATCH_FILE(file_name)
-    CATCH_STD()
-}
-
-JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Group_nativeWriteToMem(
-    JNIEnv* env, jobject, jlong nativeGroupPtr)
-{
-    TR_ENTER_PTR(nativeGroupPtr)
-    BinaryData buffer;
-    char* bufPtr = 0;
-    try {
-        buffer = G(nativeGroupPtr)->write_to_mem(); // throws
-        bufPtr = const_cast<char*>(buffer.data());
-        // Copy the data to Java array, so Java owns it.
-        jbyteArray jArray = 0;
-        if (buffer.size() <= MAX_JSIZE) {
-            jsize jlen = static_cast<jsize>(buffer.size());
-            jArray = env->NewByteArray(jlen);
-            if (jArray)
-                // Copy data to Byte[]
-                env->SetByteArrayRegion(jArray, 0, jlen, reinterpret_cast<const jbyte*>(bufPtr));
-                // SetByteArrayRegion() may throw ArrayIndexOutOfBoundsException - logic error
-        }
-        if (!jArray) {
-            ThrowException(env, IndexOutOfBounds, "Group too big to copy and write.");
-        }
-        free(bufPtr);
-        return jArray;
-    }
-    CATCH_STD()
-    if (bufPtr)
-        free(bufPtr);
-    return 0;
-}
-
-JNIEXPORT jobject JNICALL Java_io_realm_internal_Group_nativeWriteToByteBuffer(
-    JNIEnv* env, jobject, jlong nativeGroupPtr)
-{
-    TR_ENTER_PTR(nativeGroupPtr)
-    BinaryData buffer;
-    try {
-        buffer = G(nativeGroupPtr)->write_to_mem();
-        if (util::int_less_than_or_equal(buffer.size(), MAX_JLONG)) {
-            return env->NewDirectByteBuffer(const_cast<char*>(buffer.data()), static_cast<jlong>(buffer.size()));
-            // Data is now owned by the Java DirectByteBuffer - so we must not free it.
-        }
-        else {
-            ThrowException(env, IndexOutOfBounds, "Group too big to write.");
-            return NULL;
-        }
-    }
-    CATCH_STD()
-    return NULL;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeCommit(
-    JNIEnv*, jobject, jlong nativeGroupPtr)
-{
-    TR_ENTER()
-    G(nativeGroupPtr)->commit();
-}
-
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Group_nativeToJson(
-    JNIEnv* env, jobject, jlong nativeGroupPtr)
-{
-    Group* grp = G(nativeGroupPtr);
-
-    try {
-        // Write group to string in JSON format
-        std::ostringstream ss;
-        ss.sync_with_stdio(false); // for performance
-        grp->to_json(ss);
-        const std::string str = ss.str();
-        return to_jstring(env, str);
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Group_nativeToString(
-    JNIEnv* env, jobject, jlong nativeGroupPtr)
-{
-    Group* grp = G(nativeGroupPtr);
-    try {
-        // Write group to string
-        std::ostringstream ss;
-        ss.sync_with_stdio(false); // for performance
-        grp->to_string(ss);
-        const std::string str = ss.str();
-        return to_jstring(env, str);
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeEquals(
-    JNIEnv* env, jobject, jlong nativeGroupPtr, jlong nativeGroupToComparePtr)
-{
-    Group* grp = G(nativeGroupPtr);
-    Group* grpToCompare = G(nativeGroupToComparePtr);
-    try {
-        return (*grp == *grpToCompare);
-    } CATCH_STD()
-    return false;
-}
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeIsEmpty(
-    JNIEnv*, jobject, jlong nativeGroupPtr)
-{
-    Group* grp = G(nativeGroupPtr);
-    const size_t table_prefix_length = TABLE_PREFIX.length();
-
-    for (size_t i = 0; i < grp->size(); ++i) {
-        ConstTableRef table = grp->get_table(i);
-        const string table_name = table->get_name();
-        if (table_name.compare(0, table_prefix_length, TABLE_PREFIX) == 0 && !table->is_empty()) {
-            return false;
-        }
-    }
-    return true;
-}
diff --git a/realm/realm-jni/src/io_realm_internal_Group.h b/realm/realm-jni/src/io_realm_internal_Group.h
deleted file mode 100644
index 6f78409cdb..0000000000
--- a/realm/realm-jni/src/io_realm_internal_Group.h
+++ /dev/null
@@ -1,157 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_Group */
-
-#ifndef _Included_io_realm_internal_Group
-#define _Included_io_realm_internal_Group
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     io_realm_internal_Group
- * Method:    createNative
- * Signature: ()J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative__
-  (JNIEnv *, jobject);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    createNative
- * Signature: (Ljava/lang/String;I)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative__Ljava_lang_String_2I
-  (JNIEnv *, jobject, jstring, jint);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    createNative
- * Signature: ([B)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative___3B
-  (JNIEnv *, jobject, jbyteArray);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    createNative
- * Signature: (Ljava/nio/ByteBuffer;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative__Ljava_nio_ByteBuffer_2
-  (JNIEnv *, jobject, jobject);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeClose
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeClose
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeSize
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_nativeSize
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeHasTable
- * Signature: (JLjava/lang/String;)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeHasTable
-  (JNIEnv *, jobject, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeGetTableName
- * Signature: (JI)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Group_nativeGetTableName
-  (JNIEnv *, jobject, jlong, jint);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeRemoveTable
- * Signature: (JLjava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeRemoveTable
-  (JNIEnv *, jobject, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeRenameTable
- * Signature: (JLjava/lang/String;Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeRenameTable
-  (JNIEnv *, jobject, jlong, jstring, jstring);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeGetTableNativePtr
- * Signature: (JLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_nativeGetTableNativePtr
-  (JNIEnv *, jobject, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeWriteToFile
- * Signature: (JLjava/lang/String;[B)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeWriteToFile
-  (JNIEnv *, jobject, jlong, jstring, jbyteArray);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeLoadFromMem
- * Signature: ([B)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_nativeLoadFromMem
-  (JNIEnv *, jclass, jbyteArray);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeWriteToMem
- * Signature: (J)[B
- */
-JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Group_nativeWriteToMem
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeToJson
- * Signature: (J)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Group_nativeToJson
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeCommit
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeCommit
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeToString
- * Signature: (J)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Group_nativeToString
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Group
- * Method:    nativeIsEmpty
- * Signature: (J)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Group_nativeIsEmpty(
-    JNIEnv*, jobject, jlong nativeGroupPtr);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm/realm-jni/src/io_realm_internal_LinkView.h b/realm/realm-jni/src/io_realm_internal_LinkView.h
deleted file mode 100644
index 61aa14cedc..0000000000
--- a/realm/realm-jni/src/io_realm_internal_LinkView.h
+++ /dev/null
@@ -1,149 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_LinkView */
-
-#ifndef _Included_io_realm_internal_LinkView
-#define _Included_io_realm_internal_LinkView
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeClose
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeClose
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeGetRow
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetRow
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeGetTargetRowIndex
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetRowIndex
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeAdd
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeAdd
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeInsert
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeInsert
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeSet
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeSet
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeMove
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeMove
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeRemove
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemove
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeClear
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeClear
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeSize
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeSize
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeIsEmpty
- * Signature: (J)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsEmpty
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeWhere
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeWhere
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeIsAttached
- * Signature: (J)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsAttached
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeFind
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeFind
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeRemoveTargetRow
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveTargetRow
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeRemoveAllTargetRows
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveAllTargetRows
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_LinkView
- * Method:    nativeGetTargetTable
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetTable
-  (JNIEnv *, jobject, jlong);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm/realm-jni/src/io_realm_internal_SharedGroup.cpp b/realm/realm-jni/src/io_realm_internal_SharedGroup.cpp
deleted file mode 100644
index c7474319c5..0000000000
--- a/realm/realm-jni/src/io_realm_internal_SharedGroup.cpp
+++ /dev/null
@@ -1,345 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <jni.h>
-
-#include "util.hpp"
-
-#include <realm/group_shared.hpp>
-#include <realm/replication.hpp>
-#include <realm/commit_log.hpp>
-
-#include "util.hpp"
-#include "io_realm_internal_SharedGroup.h"
-
-using namespace std;
-using namespace realm;
-
-inline static bool jint_to_durability_level(JNIEnv* env, jint durability, SharedGroup::DurabilityLevel &level) {
-    if (durability == 0)
-        level = SharedGroup::durability_Full;
-    else if (durability == 1)
-        level = SharedGroup::durability_MemOnly;
-    else if (durability == 2)
-#ifdef _WIN32
-        level = SharedGroup::durability_Full;   // For Windows, use Full instead of Async
-#else
-        level = SharedGroup::durability_Async;
-#endif
-    else {
-        ThrowException(env, UnsupportedOperation, "Unsupported durability.");
-        return false;
-    }
-
-    return true;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreate(
-    JNIEnv* env, jobject, jstring jfile_name, jint durability, jboolean no_create, jboolean enable_replication, jbyteArray keyArray)
-{
-    TR_ENTER()
-    StringData file_name;
-
-    SharedGroup* db = 0;
-    try {
-        JStringAccessor file_name_tmp(env, jfile_name); // throws
-        file_name = StringData(file_name_tmp);
-
-        if (enable_replication) {
-#ifdef REALM_ENABLE_REPLICATION
-            ThrowException(env, UnsupportedOperation,
-                           "Replication is not currently supported by the Java language binding.");
-//            db = new SharedGroup(SharedGroup::replication_tag(), *file_name_ptr ? file_name_ptr : 0);
-#else
-            ThrowException(env, UnsupportedOperation,
-                           "Replication was disabled in the native library at compile time.");
-#endif
-        }
-        else {
-            SharedGroup::DurabilityLevel level;
-            // Exception thrown for wrong durability value
-            if (!jint_to_durability_level(env, durability, level)) {
-                return 0;
-            }
-
-            KeyBuffer key(env, keyArray);
-#ifdef REALM_ENABLE_ENCRYPTION
-            db = new SharedGroup(file_name, no_create != 0, level, key.data());
-#else
-            db = new SharedGroup(file_name, no_create != 0, level);
-#endif
-        }
-        return reinterpret_cast<jlong>(db);
-    }
-    CATCH_FILE(file_name)
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_createNativeWithImplicitTransactions
-  (JNIEnv* env, jobject, jlong native_replication_ptr, jint durability, jbyteArray keyArray)
-{
-    TR_ENTER()
-
-    SharedGroup::DurabilityLevel level;
-    // Exception thrown for wrong durability value
-    if (!jint_to_durability_level(env, durability, level)) {
-        return 0;
-    }
-
-    try {
-        KeyBuffer key(env, keyArray);
-#ifdef REALM_ENABLE_ENCRYPTION
-        SharedGroup* db = new SharedGroup(*CH(native_replication_ptr), level, key.data());
-#else
-        SharedGroup* db = new SharedGroup(*CH(native_replication_ptr), level);
-#endif
-        return reinterpret_cast<jlong>(db);
-    }
-    CATCH_FILE()
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreateReplication
-  (JNIEnv* env, jobject, jstring jfile_name, jbyteArray keyArray)
-{
-    TR_ENTER()
-    StringData file_name;
-    try {     
-        JStringAccessor file_name_tmp(env, jfile_name); // throws
-        file_name = StringData(file_name_tmp);
-        KeyBuffer key(env, keyArray);
-#ifdef REALM_ENABLE_ENCRYPTION
-        std::unique_ptr<Replication> hist = make_client_history(file_name, key.data());
-#else
-        std::unique_ptr<Replication> hist = make_client_history(file_name);
-#endif
-        return reinterpret_cast<jlong>(hist.release());
-    }
-    CATCH_FILE(file_name)
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeBeginImplicit
-  (JNIEnv* env, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    try {
-        Group& group = const_cast<Group&>(SG(native_ptr)->begin_read());
-        return reinterpret_cast<jlong>(&group);
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeAdvanceRead
-(JNIEnv *env, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    try {
-        LangBindHelper::advance_read(*SG(native_ptr));
-    }
-    CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeAdvanceReadToVersion
-(JNIEnv *env, jobject, jlong native_ptr, jlong version, jlong index)
-{
-    TR_ENTER_PTR(native_ptr)
-    try {
-        SharedGroup::VersionID versionId(version, index);
-        LangBindHelper::advance_read(*SG(native_ptr), versionId);
-    }
-    CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativePromoteToWrite
-  (JNIEnv *env, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr) 
-    try {
-        LangBindHelper::promote_to_write(*SG(native_ptr));
-    }
-    CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCommitAndContinueAsRead
-  (JNIEnv *env, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    try {
-        LangBindHelper::commit_and_continue_as_read( *SG(native_ptr) );
-    }
-    CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCloseReplication
-  (JNIEnv *, jobject, jlong native_replication_ptr)
-{
-    TR_ENTER_PTR(native_replication_ptr)
-    delete CH(native_replication_ptr);
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeClose(
-    JNIEnv*, jclass, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    delete SG(native_ptr);
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeReserve(
-   JNIEnv *env, jobject, jlong native_ptr, jlong bytes)
-{
-    TR_ENTER_PTR(native_ptr)
-    if (bytes <= 0) {
-        ThrowException(env, UnsupportedOperation, "number of bytes must be > 0.");
-        return;
-    }
-
-    try {
-         SG(native_ptr)->reserve(S(bytes));
-    }
-    CATCH_STD()
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeBeginRead(
-    JNIEnv* env, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    try {
-        const Group& group = SG(native_ptr)->begin_read();
-        return reinterpret_cast<jlong>(&group);
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeEndRead(
-    JNIEnv *, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    SG(native_ptr)->end_read();     // noexcept
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeBeginWrite(
-    JNIEnv* env, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    try {
-        Group& group = SG(native_ptr)->begin_write();
-        return reinterpret_cast<jlong>(&group);
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCommit(
-    JNIEnv*, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    SG(native_ptr)->commit();   // noexcept
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeRollback(
-    JNIEnv*, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    SG(native_ptr)->rollback();   // noexcept
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeRollbackAndContinueAsRead(
-    JNIEnv *, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    LangBindHelper::rollback_and_continue_as_read(*SG(native_ptr));
-}
-
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeHasChanged
-  (JNIEnv *, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    return SG(native_ptr)->has_changed();   // noexcept
-}
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_SharedGroup_nativeGetDefaultReplicationDatabaseFileName(
-    JNIEnv* env, jclass)
-{
-    TR_ENTER()
-#ifdef REALM_ENABLE_REPLICATION
-    ThrowException(env, UnsupportedOperation,
-                   "Replication is not currently supported by the Java language binding.");
-    return 0;
-//    return to_jstring(env, Replication::get_path_to_database_file());
-#else
-    ThrowException(env, UnsupportedOperation,
-                   "Replication was disable in the native library at compile time");
-    return 0;
-#endif
-}
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeCompact(
-    JNIEnv* env, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    try {
-        return SG(native_ptr)->compact(); // throws
-    }
-    CATCH_FILE()
-    CATCH_STD()
-    return false;
-}
-
-JNIEXPORT jlongArray JNICALL Java_io_realm_internal_SharedGroup_nativeGetVersionID
-        (JNIEnv *env, jobject, jlong native_ptr)
-{
-    TR_ENTER()
-    SharedGroup::VersionID version_id = SG(native_ptr)->get_version_of_current_transaction();
-
-    jlong version_array [2];
-    version_array[0] = static_cast<jlong>(version_id.version);
-    version_array[1] = static_cast<jlong>(version_id.index);
-
-    jlongArray version_data = env->NewLongArray(2);
-    if (version_data == NULL) {
-        ThrowException(env, OutOfMemory, "Could not allocate memory to return versionID.");
-        return NULL;
-    }
-    env->SetLongArrayRegion(version_data, 0, 2, version_array);
-
-    return version_data;
-}
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeWaitForChange
-  (JNIEnv *env, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    try {
-        return static_cast<jboolean>(SG(native_ptr)->wait_for_change());
-    } CATCH_STD()
-    return false;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeStopWaitForChange
-  (JNIEnv *env, jobject, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    try {
-        SG(native_ptr)->wait_for_change_release();
-    } CATCH_STD()
-}
\ No newline at end of file
diff --git a/realm/realm-jni/src/io_realm_internal_SharedGroup.h b/realm/realm-jni/src/io_realm_internal_SharedGroup.h
deleted file mode 100644
index 526ec73e58..0000000000
--- a/realm/realm-jni/src/io_realm_internal_SharedGroup.h
+++ /dev/null
@@ -1,198 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_SharedGroup */
-
-#ifndef _Included_io_realm_internal_SharedGroup
-#define _Included_io_realm_internal_SharedGroup
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    createNativeWithImplicitTransactions
- * Signature: (JI[B)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_createNativeWithImplicitTransactions
-  (JNIEnv *, jobject, jlong, jint, jbyteArray);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeCreateReplication
- * Signature: (Ljava/lang/String;[B)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreateReplication
-  (JNIEnv *, jobject, jstring, jbyteArray);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeAdvanceRead
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeAdvanceRead
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeAdvanceReadToVersion
- * Signature: (JJJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeAdvanceReadToVersion
-(JNIEnv *, jobject, jlong, jlong, jlong);
-
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativePromoteToWrite
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativePromoteToWrite
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeCommitAndContinueAsRead
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCommitAndContinueAsRead
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeRollbackAndContinueAsRead
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeRollbackAndContinueAsRead
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeBeginImplicit
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeBeginImplicit
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeGetDefaultReplicationDatabaseFileName
- * Signature: ()Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_SharedGroup_nativeGetDefaultReplicationDatabaseFileName
-  (JNIEnv *, jobject);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeReserve
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeReserve
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeHasChanged
- * Signature: (J)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeHasChanged
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeBeginRead
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeBeginRead
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeEndRead
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeEndRead
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeBeginWrite
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeBeginWrite
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeCommit
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCommit
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeRollback
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeRollback
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeCreate
- * Signature: (Ljava/lang/String;IZZ[B)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreate
-  (JNIEnv *, jobject, jstring, jint, jboolean, jboolean, jbyteArray);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeCompact
- * Signature: (J)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeCompact
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeClose
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeClose
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeCloseReplication
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeCloseReplication
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeGetVersionID
- * Signature: (J)[J
- */
-JNIEXPORT jlongArray JNICALL Java_io_realm_internal_SharedGroup_nativeGetVersionID
-        (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeWaitForChange
- * Signature: (J)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedGroup_nativeWaitForChange
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_SharedGroup
- * Method:    nativeStopWaitForChange
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedGroup_nativeStopWaitForChange
-  (JNIEnv *, jobject, jlong);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm/realm-jni/src/io_realm_internal_SubtableSchema.cpp b/realm/realm-jni/src/io_realm_internal_SubtableSchema.cpp
deleted file mode 100644
index 4bfdcb8073..0000000000
--- a/realm/realm-jni/src/io_realm_internal_SubtableSchema.cpp
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "util.hpp"
-#include "io_realm_internal_SubtableSchema.h"
-
-using namespace realm;
-using namespace std;
-
-void arrayToVector(JNIEnv* env, jlongArray path, vector<size_t>& nativePath)
-{
-    jsize size = env->GetArrayLength(path);
-    nativePath.reserve(size+1);
-
-    jlong* pathElements = env->GetLongArrayElements(path, 0);
-    for (jsize i = 0; i < size; ++i) {
-        nativePath.push_back(S(pathElements[i]));
-    }
-    env->ReleaseLongArrayElements(path, pathElements, JNI_ABORT);
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SubtableSchema_nativeAddColumn
-  (JNIEnv* env, jobject, jlong  nativeTablePtr, jlongArray path, jint colType, jstring name)
-{
-    if (!TABLE_VALID(env, TBL(nativeTablePtr)))
-        return 0;
-    try {
-        JStringAccessor name2(env, name); // throws
-        vector<size_t> nativePath;
-        arrayToVector(env, path, nativePath);
-        return TBL(nativeTablePtr)->add_subcolumn(nativePath, DataType(colType), name2);
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SubtableSchema_nativeRemoveColumn
-  (JNIEnv* env, jobject, jlong nativeTablePtr, jlongArray path, jlong columnIndex)
-{
-    if (!TBL_AND_COL_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex))
-        return;
-    try {
-        vector<size_t> nativePath;
-        arrayToVector(env, path, nativePath);
-        TBL(nativeTablePtr)->remove_subcolumn(nativePath, columnIndex);
-    }
-    CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SubtableSchema_nativeRenameColumn
-  (JNIEnv* env, jobject, jlong nativeTablePtr, jlongArray path, jlong columnIndex, jstring name)
-{
-    if (!TBL_AND_COL_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex))
-        return;
-    try {
-        JStringAccessor name2(env, name);
-        vector<size_t> nativePath;
-        arrayToVector(env, path, nativePath);
-        TBL(nativeTablePtr)->rename_subcolumn(nativePath, columnIndex, name2);
-    }
-    CATCH_STD()
-}
diff --git a/realm/realm-jni/src/io_realm_internal_SubtableSchema.h b/realm/realm-jni/src/io_realm_internal_SubtableSchema.h
deleted file mode 100644
index 65d74a7336..0000000000
--- a/realm/realm-jni/src/io_realm_internal_SubtableSchema.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_SubtableSchema */
-
-#ifndef _Included_io_realm_internal_SubtableSchema
-#define _Included_io_realm_internal_SubtableSchema
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     io_realm_internal_SubtableSchema
- * Method:    nativeAddColumn
- * Signature: (J[JILjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SubtableSchema_nativeAddColumn
-  (JNIEnv *, jobject, jlong, jlongArray, jint, jstring);
-
-/*
- * Class:     io_realm_internal_SubtableSchema
- * Method:    nativeRemoveColumn
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SubtableSchema_nativeRemoveColumn
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_SubtableSchema
- * Method:    nativeRenameColumn
- * Signature: (J[JJLjava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_SubtableSchema_nativeRenameColumn
-  (JNIEnv *, jobject, jlong, jlongArray, jlong, jstring);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm/realm-jni/src/io_realm_internal_Table.h b/realm/realm-jni/src/io_realm_internal_Table.h
deleted file mode 100644
index 943c435968..0000000000
--- a/realm/realm-jni/src/io_realm_internal_Table.h
+++ /dev/null
@@ -1,836 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_Table */
-
-#ifndef _Included_io_realm_internal_Table
-#define _Included_io_realm_internal_Table
-#ifdef __cplusplus
-extern "C" {
-#endif
-#undef io_realm_internal_Table_INFINITE
-#define io_realm_internal_Table_INFINITE -1LL
-#undef io_realm_internal_Table_INTEGER_DEFAULT_VALUE
-#define io_realm_internal_Table_INTEGER_DEFAULT_VALUE 0LL
-#undef io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX
-#define io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX 0LL
-#undef io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX
-#define io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX 1LL
-#undef io_realm_internal_Table_NO_PRIMARY_KEY
-#define io_realm_internal_Table_NO_PRIMARY_KEY -2LL
-#undef io_realm_internal_Table_NULLABLE
-#define io_realm_internal_Table_NULLABLE 1L
-#undef io_realm_internal_Table_NOT_NULLABLE
-#define io_realm_internal_Table_NOT_NULLABLE 0L
-/*
- * Class:     io_realm_internal_Table
- * Method:    createNative
- * Signature: ()J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_createNative
-  (JNIEnv *, jobject);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeClose
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeClose
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeIsValid
- * Signature: (J)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsValid
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeIsRootTable
- * Signature: (J)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsRootTable
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeAddColumn
- * Signature: (JILjava/lang/String;Z)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddColumn
-  (JNIEnv *, jobject, jlong, jint, jstring, jboolean);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeAddColumnLink
- * Signature: (JILjava/lang/String;J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddColumnLink
-  (JNIEnv *, jobject, jlong, jint, jstring, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeRemoveColumn
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveColumn
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeRenameColumn
- * Signature: (JJLjava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRenameColumn
-  (JNIEnv *, jobject, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeIsColumnNullable
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsColumnNullable
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeConvertColumnToNullable
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullable
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeConvertColumnToNotNullable
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNullable
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeUpdateFromSpec
- * Signature: (JLio/realm/internal/TableSpec;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeUpdateFromSpec
-  (JNIEnv *, jobject, jlong, jobject);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSize
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSize
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeClear
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeClear
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetColumnCount
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetColumnCount
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetTableSpec
- * Signature: (J)Lio/realm/internal/TableSpec;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_Table_nativeGetTableSpec
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetColumnName
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetColumnName
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetColumnIndex
- * Signature: (JLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetColumnIndex
-  (JNIEnv *, jobject, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetColumnType
- * Signature: (JJ)I
- */
-JNIEXPORT jint JNICALL Java_io_realm_internal_Table_nativeGetColumnType
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeRemove
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemove
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeRemoveLast
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveLast
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeMoveLastOver
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMoveLastOver
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeAddEmptyRow
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddEmptyRow
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetSortedView
- * Signature: (JJZ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedView
-  (JNIEnv *, jobject, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetSortedViewMulti
- * Signature: (J[J[Z)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti
-  (JNIEnv *, jobject, jlong, jlongArray, jbooleanArray);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetLong
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLong
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetBoolean
- * Signature: (JJJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeGetBoolean
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetFloat
- * Signature: (JJJ)F
- */
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_Table_nativeGetFloat
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetDouble
- * Signature: (JJJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeGetDouble
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetTimestamp
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetTimestamp
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetString
- * Signature: (JJJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetString
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetByteArray
- * Signature: (JJJ)[B
- */
-JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Table_nativeGetByteArray
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetMixedType
- * Signature: (JJJ)I
- */
-JNIEXPORT jint JNICALL Java_io_realm_internal_Table_nativeGetMixedType
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetMixed
- * Signature: (JJJ)Lio/realm/internal/Mixed;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_Table_nativeGetMixed
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetLink
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLink
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetLinkTarget
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLinkTarget
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetSubtable
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSubtable
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetSubtableDuringInsert
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSubtableDuringInsert
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetSubtableSize
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSubtableSize
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeClearSubtable
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeClearSubtable
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetRowPtr
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetRowPtr
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetLong
- * Signature: (JJJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLong
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetBoolean
- * Signature: (JJJZ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetBoolean
-  (JNIEnv *, jobject, jlong, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetFloat
- * Signature: (JJJF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetFloat
-  (JNIEnv *, jobject, jlong, jlong, jlong, jfloat);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetDouble
- * Signature: (JJJD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetDouble
-  (JNIEnv *, jobject, jlong, jlong, jlong, jdouble);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetTimestamp
- * Signature: (JJJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetTimestamp
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetString
- * Signature: (JJJLjava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetString
-  (JNIEnv *, jobject, jlong, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetByteArray
- * Signature: (JJJ[B)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteArray
-  (JNIEnv *, jobject, jlong, jlong, jlong, jbyteArray);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetNull
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetNull
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetMixed
- * Signature: (JJJLio/realm/internal/Mixed;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetMixed
-  (JNIEnv *, jobject, jlong, jlong, jlong, jobject);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetLink
- * Signature: (JJJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLink
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSetPrimaryKey
- * Signature: (JJLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey
-  (JNIEnv *, jobject, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeMigratePrimaryKeyTableIfNeeded
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTableIfNeeded
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeAddSearchIndex
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeAddSearchIndex
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeRemoveSearchIndex
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveSearchIndex
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeHasSearchIndex
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSearchIndex
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeIsNullLink
- * Signature: (JJJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsNullLink
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeNullifyLink
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeNullifyLink
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSumInt
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSumInt
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeMaximumInt
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMaximumInt
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeMinimumInt
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMinimumInt
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeAverageInt
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeAverageInt
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSumFloat
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeSumFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeMaximumFloat
- * Signature: (JJ)F
- */
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_Table_nativeMaximumFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeMinimumFloat
- * Signature: (JJ)F
- */
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_Table_nativeMinimumFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeAverageFloat
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeAverageFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeSumDouble
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeSumDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeMaximumDouble
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeMaximumDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeMinimumDouble
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeMinimumDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeAverageDouble
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_Table_nativeAverageDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeMaximumTimestamp
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMaximumTimestamp
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeMinimumTimestamp
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeMinimumTimestamp
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeCountLong
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeCountLong
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeCountFloat
- * Signature: (JJF)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeCountFloat
-  (JNIEnv *, jobject, jlong, jlong, jfloat);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeCountDouble
- * Signature: (JJD)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeCountDouble
-  (JNIEnv *, jobject, jlong, jlong, jdouble);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeCountString
- * Signature: (JJLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeCountString
-  (JNIEnv *, jobject, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeWhere
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeWhere
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindFirstInt
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstInt
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindFirstBool
- * Signature: (JJZ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstBool
-  (JNIEnv *, jobject, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindFirstFloat
- * Signature: (JJF)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstFloat
-  (JNIEnv *, jobject, jlong, jlong, jfloat);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindFirstDouble
- * Signature: (JJD)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstDouble
-  (JNIEnv *, jobject, jlong, jlong, jdouble);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindFirstTimestamp
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstTimestamp
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindFirstString
- * Signature: (JJLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstString
-  (JNIEnv *, jobject, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindFirstNull
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstNull
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindAllInt
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllInt
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindAllBool
- * Signature: (JJZ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllBool
-  (JNIEnv *, jobject, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindAllFloat
- * Signature: (JJF)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllFloat
-  (JNIEnv *, jobject, jlong, jlong, jfloat);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindAllDouble
- * Signature: (JJD)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllDouble
-  (JNIEnv *, jobject, jlong, jlong, jdouble);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindAllTimestamp
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllTimestamp
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeFindAllString
- * Signature: (JJLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllString
-  (JNIEnv *, jobject, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeLowerBoundInt
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeLowerBoundInt
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeUpperBoundInt
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeUpperBoundInt
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativePivot
- * Signature: (JJJIJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativePivot
-  (JNIEnv *, jobject, jlong, jlong, jlong, jint, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetDistinctView
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetDistinctView
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeGetName
- * Signature: (J)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetName
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeOptimize
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeOptimize
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeToJson
- * Signature: (J)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToJson
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeToString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToString
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeRowToString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeRowToString
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeHasSameSchema
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSameSchema
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_Table
- * Method:    nativeVersion
- * Signature: (JJ)Z
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeVersion(
-        JNIEnv*, jobject, jlong);
-
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm/realm-jni/src/io_realm_internal_TableQuery.h b/realm/realm-jni/src/io_realm_internal_TableQuery.h
deleted file mode 100644
index e149942bbd..0000000000
--- a/realm/realm-jni/src/io_realm_internal_TableQuery.h
+++ /dev/null
@@ -1,619 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_TableQuery */
-
-#ifndef _Included_io_realm_internal_TableQuery
-#define _Included_io_realm_internal_TableQuery
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeClose
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeClose
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeValidateQuery
- * Signature: (J)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableQuery_nativeValidateQuery
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeTableview
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeTableview
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeGroup
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGroup
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeEndGroup
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEndGroup
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeSubtable
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeSubtable
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeParent
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeParent
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeOr
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeOr
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeNot
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNot
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeEqual
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JJ
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeNotEqual
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JJ
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeGreater
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JJ
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeGreaterEqual
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JJ
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeLess
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JJ
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeLessEqual
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JJ
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeBetween
- * Signature: (J[JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JJJ
-  (JNIEnv *, jobject, jlong, jlongArray, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeEqual
- * Signature: (J[JF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JF
-  (JNIEnv *, jobject, jlong, jlongArray, jfloat);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeNotEqual
- * Signature: (J[JF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JF
-  (JNIEnv *, jobject, jlong, jlongArray, jfloat);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeGreater
- * Signature: (J[JF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JF
-  (JNIEnv *, jobject, jlong, jlongArray, jfloat);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeGreaterEqual
- * Signature: (J[JF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JF
-  (JNIEnv *, jobject, jlong, jlongArray, jfloat);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeLess
- * Signature: (J[JF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JF
-  (JNIEnv *, jobject, jlong, jlongArray, jfloat);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeLessEqual
- * Signature: (J[JF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JF
-  (JNIEnv *, jobject, jlong, jlongArray, jfloat);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeBetween
- * Signature: (J[JFF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JFF
-  (JNIEnv *, jobject, jlong, jlongArray, jfloat, jfloat);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeEqual
- * Signature: (J[JD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JD
-  (JNIEnv *, jobject, jlong, jlongArray, jdouble);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeNotEqual
- * Signature: (J[JD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JD
-  (JNIEnv *, jobject, jlong, jlongArray, jdouble);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeGreater
- * Signature: (J[JD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JD
-  (JNIEnv *, jobject, jlong, jlongArray, jdouble);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeGreaterEqual
- * Signature: (J[JD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JD
-  (JNIEnv *, jobject, jlong, jlongArray, jdouble);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeLess
- * Signature: (J[JD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JD
-  (JNIEnv *, jobject, jlong, jlongArray, jdouble);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeLessEqual
- * Signature: (J[JD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JD
-  (JNIEnv *, jobject, jlong, jlongArray, jdouble);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeBetween
- * Signature: (J[JDD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JDD
-  (JNIEnv *, jobject, jlong, jlongArray, jdouble, jdouble);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeEqual
- * Signature: (J[JZ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JZ
-  (JNIEnv *, jobject, jlong, jlongArray, jboolean);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeEqualTimestamp
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqualTimestamp
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeNotEqualTimestamp
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqualTimestamp
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeGreaterTimestamp
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterTimestamp
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeGreaterEqualTimestamp
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqualTimestamp
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeLessTimestamp
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessTimestamp
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeLessEqualTimestamp
- * Signature: (J[JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqualTimestamp
-  (JNIEnv *, jobject, jlong, jlongArray, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeBetweenTimestamp
- * Signature: (J[JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetweenTimestamp
-  (JNIEnv *, jobject, jlong, jlongArray, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeEqual
- * Signature: (J[JLjava/lang/String;Z)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JLjava_lang_String_2Z
-  (JNIEnv *, jobject, jlong, jlongArray, jstring, jboolean);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeNotEqual
- * Signature: (J[JLjava/lang/String;Z)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JLjava_lang_String_2Z
-  (JNIEnv *, jobject, jlong, jlongArray, jstring, jboolean);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeBeginsWith
- * Signature: (J[JLjava/lang/String;Z)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBeginsWith
-  (JNIEnv *, jobject, jlong, jlongArray, jstring, jboolean);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeEndsWith
- * Signature: (J[JLjava/lang/String;Z)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEndsWith
-  (JNIEnv *, jobject, jlong, jlongArray, jstring, jboolean);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeContains
- * Signature: (J[JLjava/lang/String;Z)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeContains
-  (JNIEnv *, jobject, jlong, jlongArray, jstring, jboolean);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeFind
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFind
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeFindWithHandover
- * Signature: (JJJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindWithHandover
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeFindAll
- * Signature: (JJJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAll
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeFindAllWithHandover
- * Signature: (JJJJJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllWithHandover
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeGetDistinctViewWithHandover
- * Signature: (JJJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeGetDistinctViewWithHandover
-        (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeFindAllSortedWithHandover
- * Signature: (JJJJJJJZ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllSortedWithHandover
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeFindAllMultiSortedWithHandover
- * Signature: (JJJJJJ[J[Z)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllMultiSortedWithHandover
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong, jlongArray, jbooleanArray);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeImportHandoverTableViewIntoSharedGroup
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverTableViewIntoSharedGroup
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeImportHandoverRowIntoSharedGroup
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverRowIntoSharedGroup
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeHandoverQuery
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeHandoverQuery
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeSumInt
- * Signature: (JJJJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeSumInt
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeMaximumInt
- * Signature: (JJJJJ)Ljava/lang/Long;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumInt
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeMinimumInt
- * Signature: (JJJJJ)Ljava/lang/Long;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumInt
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeAverageInt
- * Signature: (JJJJJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageInt
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeSumFloat
- * Signature: (JJJJJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeSumFloat
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeMaximumFloat
- * Signature: (JJJJJ)Ljava/lang/Float;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumFloat
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeMinimumFloat
- * Signature: (JJJJJ)Ljava/lang/Float;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumFloat
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeAverageFloat
- * Signature: (JJJJJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageFloat
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeSumDouble
- * Signature: (JJJJJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeSumDouble
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeMaximumDouble
- * Signature: (JJJJJ)Ljava/lang/Double;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumDouble
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeMinimumDouble
- * Signature: (JJJJJ)Ljava/lang/Double;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumDouble
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeAverageDouble
- * Signature: (JJJJJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableQuery_nativeAverageDouble
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeMaximumTimestamp
- * Signature: (JJJJJ)Ljava/lang/Long;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumTimestamp
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeMinimumTimestamp
- * Signature: (JJJJJ)Ljava/lang/Long;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumTimestamp
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeIsNull
- * Signature: (J[J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull
-  (JNIEnv *, jobject, jlong, jlongArray);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeIsEmpty
- * Signature: (J[J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty
-  (JNIEnv *, jobject, jlong, jlongArray);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeIsNonEmpty
- * Signature: (J[J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNonEmpty
-  (JNIEnv *, jobject, jlong, jlongArray);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeIsNotNull
- * Signature: (J[J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNotNull
-  (JNIEnv *, jobject, jlong, jlongArray);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeCount
- * Signature: (JJJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeCount
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeRemove
- * Signature: (JJJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeRemove
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeCloseQueryHandover
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeCloseQueryHandover
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeCloseQueryHandover
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeAcceptHandoverQuery
-        (JNIEnv *, jlong, jlong , jlong);
-
-/*
- * Class:     io_realm_internal_TableQuery
- * Method:    nativeBatchUpdateQueries
- */
-JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdateQueries
-        (JNIEnv *,jobject,jlong ,jlongArray,jobjectArray,jobjectArray,jobjectArray);
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm/realm-jni/src/io_realm_internal_TableView.h b/realm/realm-jni/src/io_realm_internal_TableView.h
deleted file mode 100644
index 85c54e1420..0000000000
--- a/realm/realm-jni/src/io_realm_internal_TableView.h
+++ /dev/null
@@ -1,581 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_TableView */
-
-#ifndef _Included_io_realm_internal_TableView
-#define _Included_io_realm_internal_TableView
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeClose
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeClose
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSize
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSize
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetSourceRowIndex
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetSourceRowIndex
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetColumnCount
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetColumnCount
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetColumnName
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeGetColumnName
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetColumnIndex
- * Signature: (JLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetColumnIndex
-  (JNIEnv *, jobject, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetColumnType
- * Signature: (JJ)I
- */
-JNIEXPORT jint JNICALL Java_io_realm_internal_TableView_nativeGetColumnType
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetLong
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetLong
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetBoolean
- * Signature: (JJJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_TableView_nativeGetBoolean
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetFloat
- * Signature: (JJJ)F
- */
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_TableView_nativeGetFloat
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetDouble
- * Signature: (JJJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeGetDouble
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetTimestamp
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetTimestamp
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetString
- * Signature: (JJJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeGetString
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetByteArray
- * Signature: (JJJ)[B
- */
-JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_TableView_nativeGetByteArray
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetMixedType
- * Signature: (JJJ)I
- */
-JNIEXPORT jint JNICALL Java_io_realm_internal_TableView_nativeGetMixedType
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetMixed
- * Signature: (JJJ)Lio/realm/internal/Mixed;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeGetMixed
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetLink
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetLink
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetSubtable
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetSubtable
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeGetSubtableSize
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetSubtableSize
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeClearSubtable
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeClearSubtable
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSetLong
- * Signature: (JJJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetLong
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSetBoolean
- * Signature: (JJJZ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetBoolean
-  (JNIEnv *, jobject, jlong, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSetFloat
- * Signature: (JJJF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetFloat
-  (JNIEnv *, jobject, jlong, jlong, jlong, jfloat);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSetDouble
- * Signature: (JJJD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetDouble
-  (JNIEnv *, jobject, jlong, jlong, jlong, jdouble);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSetTimestampValue
- * Signature: (JJJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetTimestampValue
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSetString
- * Signature: (JJJLjava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetString
-  (JNIEnv *, jobject, jlong, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSetByteArray
- * Signature: (JJJ[B)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetByteArray
-  (JNIEnv *, jobject, jlong, jlong, jlong, jbyteArray);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSetMixed
- * Signature: (JJJLio/realm/internal/Mixed;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetMixed
-  (JNIEnv *, jobject, jlong, jlong, jlong, jobject);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSetLink
- * Signature: (JJJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetLink
-  (JNIEnv *, jobject, jlong, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeIsNullLink
- * Signature: (JJJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_TableView_nativeIsNullLink
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeNullifyLink
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeNullifyLink
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeClear
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeClear
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeRemoveRow
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeRemoveRow
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindFirstInt
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstInt
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindFirstBool
- * Signature: (JJZ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstBool
-  (JNIEnv *, jobject, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindFirstFloat
- * Signature: (JJF)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstFloat
-  (JNIEnv *, jobject, jlong, jlong, jfloat);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindFirstDouble
- * Signature: (JJD)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstDouble
-  (JNIEnv *, jobject, jlong, jlong, jdouble);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindFirstDate
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstDate
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindFirstString
- * Signature: (JJLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstString
-  (JNIEnv *, jobject, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindAllInt
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllInt
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindAllBool
- * Signature: (JJZ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllBool
-  (JNIEnv *, jobject, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindAllFloat
- * Signature: (JJF)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllFloat
-  (JNIEnv *, jobject, jlong, jlong, jfloat);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindAllDouble
- * Signature: (JJD)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllDouble
-  (JNIEnv *, jobject, jlong, jlong, jdouble);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindAllDate
- * Signature: (JJJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllDate
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindAllString
- * Signature: (JJLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllString
-  (JNIEnv *, jobject, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSumInt
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSumInt
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeMaximumInt
- * Signature: (JJ)Ljava/lang/Long;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumInt
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeMinimumInt
- * Signature: (JJ)Ljava/lang/Long;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumInt
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeAverageInt
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeAverageInt
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSumFloat
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeSumFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeMaximumFloat
- * Signature: (JJ)Ljava/lang/Float;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeMinimumFloat
- * Signature: (JJ)Ljava/lang/Float;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeAverageFloat
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeAverageFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSumDouble
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeSumDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeMaximumDouble
- * Signature: (JJ)Ljava/lang/Double;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeMinimumDouble
- * Signature: (JJ)Ljava/lang/Double;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeAverageDouble
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeAverageDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeMaximumTimestamp
- * Signature: (JJ)Ljava/lang/Long;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumTimestamp
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeMinimumTimestamp
- * Signature: (JJ)Ljava/lang/Long;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumTimestamp
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSort
- * Signature: (JJZ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSort
-  (JNIEnv *, jobject, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSortMulti
- * Signature: (J[J[Z)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSortMulti
-  (JNIEnv *, jobject, jlong, jlongArray, jbooleanArray);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    createNativeTableView
- * Signature: (Lio/realm/internal/Table;J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_createNativeTableView
-  (JNIEnv *, jobject, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeToJson
- * Signature: (J)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeToJson
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeToString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeToString
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeRowToString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeRowToString
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeWhere
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeWhere
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeDistinct
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeDistinct
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeMultiDistinct
- * Signature: (J[J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeDistinctMulti
-  (JNIEnv *, jobject, jlong, jlongArray);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativePivot
- * Signature: (JJJIJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativePivot
-  (JNIEnv *, jobject, jlong, jlong, jlong, jint, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeSyncIfNeeded
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSyncIfNeeded
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_TableView
- * Method:    nativeFindBySourceNdx
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindBySourceNdx
-        (JNIEnv *, jobject, jlong, jlong);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm/realm-jni/src/io_realm_internal_UncheckedRow.h b/realm/realm-jni/src/io_realm_internal_UncheckedRow.h
deleted file mode 100644
index effbcd34c6..0000000000
--- a/realm/realm-jni/src/io_realm_internal_UncheckedRow.h
+++ /dev/null
@@ -1,269 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_UncheckedRow */
-
-#ifndef _Included_io_realm_internal_UncheckedRow
-#define _Included_io_realm_internal_UncheckedRow
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetColumnCount
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnCount
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetColumnName
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnName
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetColumnIndex
- * Signature: (JLjava/lang/String;)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnIndex
-  (JNIEnv *, jobject, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetColumnType
- * Signature: (JJ)I
- */
-JNIEXPORT jint JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnType
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetIndex
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetIndex
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetLong
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLong
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetBoolean
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeGetBoolean
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetFloat
- * Signature: (JJ)F
- */
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_UncheckedRow_nativeGetFloat
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetDouble
- * Signature: (JJ)D
- */
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDouble
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetTimestamp
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetTimestamp
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetString
- * Signature: (JJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetString
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeIsNullLink
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNullLink
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetByteArray
- * Signature: (JJ)[B
- */
-JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_UncheckedRow_nativeGetByteArray
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetMixedType
- * Signature: (JJ)I
- */
-JNIEXPORT jint JNICALL Java_io_realm_internal_UncheckedRow_nativeGetMixedType
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetMixed
- * Signature: (JJ)Lio/realm/internal/Mixed;
- */
-JNIEXPORT jobject JNICALL Java_io_realm_internal_UncheckedRow_nativeGetMixed
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetLinkView
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLinkView
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetLong
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLong
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetBoolean
- * Signature: (JJZ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetBoolean
-  (JNIEnv *, jobject, jlong, jlong, jboolean);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetFloat
- * Signature: (JJF)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetFloat
-  (JNIEnv *, jobject, jlong, jlong, jfloat);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeGetLink
- * Signature: (JJ)J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLink
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetDouble
- * Signature: (JJD)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDouble
-  (JNIEnv *, jobject, jlong, jlong, jdouble);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetTimestamp
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetTimestamp
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetString
- * Signature: (JJLjava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetString
-  (JNIEnv *, jobject, jlong, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetByteArray
- * Signature: (JJ[B)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetByteArray
-  (JNIEnv *, jobject, jlong, jlong, jbyteArray);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetMixed
- * Signature: (JJLio/realm/internal/Mixed;)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetMixed
-  (JNIEnv *, jobject, jlong, jlong, jobject);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetLink
- * Signature: (JJJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLink
-  (JNIEnv *, jobject, jlong, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeNullifyLink
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeNullifyLink
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeClose
- * Signature: (J)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeClose
-  (JNIEnv *, jclass, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeIsAttached
- * Signature: (J)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsAttached
-  (JNIEnv *, jobject, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeHasColumn
- * Signature: (JLjava/lang/String;)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeHasColumn
-  (JNIEnv *, jobject, jlong, jstring);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeIsNull
- * Signature: (JJ)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNull
-  (JNIEnv *, jobject, jlong, jlong);
-
-/*
- * Class:     io_realm_internal_UncheckedRow
- * Method:    nativeSetNull
- * Signature: (JJ)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetNull
-  (JNIEnv *, jobject, jlong, jlong);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm/realm-jni/src/io_realm_internal_Util.cpp b/realm/realm-jni/src/io_realm_internal_Util.cpp
deleted file mode 100644
index c4cfaf9e4d..0000000000
--- a/realm/realm-jni/src/io_realm_internal_Util.cpp
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <jni.h>
-
-#include <realm/string_data.hpp>
-
-#include "util.hpp"
-#include "mem_usage.hpp"
-#include "io_realm_internal_Util.h"
-
-using std::string;
-
-//#define USE_VLD
-#if defined(_MSC_VER) && defined(_DEBUG) && defined(USE_VLD)
-    #include "C:\\Program Files (x86)\\Visual Leak Detector\\include\\vld.h"
-#endif
-
-// used by logging
-int trace_level = 0;
-const char* log_tag = "REALM";
-
-const string TABLE_PREFIX("class_");
-
-
-JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*)
-{
-    JNIEnv* env;
-    if (vm->GetEnv((void **) &env, JNI_VERSION_1_6) != JNI_OK) {
-        return JNI_ERR;
-    }
-    else {
-        // Loading classes and constructors for later use - used by box typed fields and a few methods' return value
-        java_lang_long        = GetClass(env, "java/lang/Long");
-        java_lang_long_init   = env->GetMethodID(java_lang_long, "<init>", "(J)V");
-        java_lang_float       = GetClass(env, "java/lang/Float");
-        java_lang_float_init  = env->GetMethodID(java_lang_float, "<init>", "(F)V");
-        java_lang_double      = GetClass(env, "java/lang/Double");
-        java_lang_double_init = env->GetMethodID(java_lang_double, "<init>", "(D)V");
-    }
-
-    return JNI_VERSION_1_6;
-}
-
-JNIEXPORT void JNI_OnUnload(JavaVM* vm, void*)
-{
-    JNIEnv* env;
-    if (vm->GetEnv((void **) &env, JNI_VERSION_1_6) != JNI_OK) {
-        return;
-    }
-    else {
-        env->DeleteGlobalRef(java_lang_long);
-        env->DeleteGlobalRef(java_lang_float);
-        env->DeleteGlobalRef(java_lang_double);
-    }
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Util_nativeSetDebugLevel(JNIEnv*, jclass, jint level)
-{
-    trace_level = level;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Util_nativeGetMemUsage(JNIEnv*, jclass)
-{
-    return GetMemUsage();
-}
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeGetTablePrefix(
-    JNIEnv* env, jclass)
-{
-    realm::StringData sd(TABLE_PREFIX);
-    return to_jstring(env, sd);
-}
-
-// -------------------------- Testcases for exception handling
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeTestcase(
-    JNIEnv *env, jclass, jint testcase, jboolean dotest, jlong)
-{
-    string expect;
-
-    switch (ExceptionKind(testcase)) {
-        case ClassNotFound:
-            expect = "java.lang.ClassNotFoundException: Class 'parm1' could not be located.";
-            if (dotest)
-                ThrowException(env, ClassNotFound, "parm1", "parm2");
-            break;
-        case NoSuchField:
-            expect = "java.lang.NoSuchFieldException: Field 'parm2' could not be located in class io.realm.parm1";
-            if (dotest)
-                ThrowException(env, NoSuchField, "parm1", "parm2");
-            break;
-        case NoSuchMethod:
-            expect = "java.lang.NoSuchMethodException: Method 'parm2' could not be located in class io.realm.parm1";
-            if (dotest)
-                ThrowException(env, NoSuchMethod, "parm1", "parm2");
-            break;
-        case IllegalArgument:
-            expect = "java.lang.IllegalArgumentException: Illegal Argument: parm1";
-            if (dotest)
-                ThrowException(env, IllegalArgument, "parm1", "parm2");
-            break;
-        case IOFailed:
-            expect = "io.realm.exceptions.RealmIOException: Failed to open parm1. parm2";
-            if (dotest)
-                ThrowException(env, IOFailed, "parm1", "parm2");
-            break;
-        case FileNotFound:
-            expect = "io.realm.exceptions.RealmIOException: File not found: parm1.";
-            if (dotest)
-                ThrowException(env, FileNotFound, "parm1", "parm2");
-            break;
-        case FileAccessError:
-            expect = "io.realm.exceptions.RealmIOException: Failed to access: parm1. parm2";
-            if (dotest)
-                ThrowException(env, FileAccessError, "parm1", "parm2");
-            break;
-        case IndexOutOfBounds:
-            expect = "java.lang.ArrayIndexOutOfBoundsException: parm1";
-            if (dotest)
-                ThrowException(env, IndexOutOfBounds, "parm1", "parm2");
-            break;
-        case TableInvalid:
-            expect = "java.lang.IllegalStateException: Illegal State: parm1";
-            if (dotest)
-                ThrowException(env, TableInvalid, "parm1", "parm2");
-            break;
-        case UnsupportedOperation:
-            expect = "java.lang.UnsupportedOperationException: parm1";
-            if (dotest)
-                ThrowException(env, UnsupportedOperation, "parm1", "parm2");
-            break;
-        case OutOfMemory:
-            expect = "io.realm.internal.OutOfMemoryError: parm1 parm2";
-            if (dotest)
-                ThrowException(env, OutOfMemory, "parm1", "parm2");
-            break;
-        case FatalError:
-            expect = "io.realm.exceptions.RealmError: Unrecoverable error. parm1";
-            if (dotest)
-                ThrowException(env, FatalError, "parm1", "parm2");
-            break;
-        case RuntimeError:
-            expect = "java.lang.RuntimeException: parm1";
-            if (dotest)
-                ThrowException(env, RuntimeError, "parm1", "parm2");
-            break;
-        case RowInvalid:
-            expect = "java.lang.IllegalStateException: Illegal State: parm1";
-            if (dotest)
-                ThrowException(env, RowInvalid, "parm1", "parm2");
-            break;
-        case CrossTableLink:
-            expect = "java.lang.IllegalStateException: This class is referenced by other classes. Remove those fields first before removing this class.";
-            if (dotest)
-                ThrowException(env, CrossTableLink, "parm1");
-            break;
-        case BadVersion:
-            expect = "io.realm.internal.async.BadVersionException: parm1";
-            if (dotest)
-                ThrowException(env, BadVersion, "parm1", "parm2");
-            break;
-
-    }
-    if (dotest) {
-        return NULL;
-    }
-    return to_jstring(env, expect);
-}
-
diff --git a/realm/realm-jni/src/io_realm_internal_Util.h b/realm/realm-jni/src/io_realm_internal_Util.h
deleted file mode 100644
index 8a41d65d19..0000000000
--- a/realm/realm-jni/src/io_realm_internal_Util.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_Util */
-
-#ifndef _Included_io_realm_internal_Util
-#define _Included_io_realm_internal_Util
-#ifdef __cplusplus
-extern "C" {
-#endif
-/*
- * Class:     io_realm_internal_Util
- * Method:    nativeGetMemUsage
- * Signature: ()J
- */
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Util_nativeGetMemUsage
-  (JNIEnv *, jclass);
-
-/*
- * Class:     io_realm_internal_Util
- * Method:    nativeSetDebugLevel
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_io_realm_internal_Util_nativeSetDebugLevel
-  (JNIEnv *, jclass, jint);
-
-/*
- * Class:     io_realm_internal_Util
- * Method:    nativeGetTablePrefix
- * Signature: ()Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeGetTablePrefix
-  (JNIEnv *, jclass);
-
-/*
- * Class:     io_realm_internal_Util
- * Method:    nativeTestcase
- * Signature: (IZJ)Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeTestcase
-  (JNIEnv *, jclass, jint, jboolean, jlong);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm/realm-jni/src/io_realm_internal_Version.cpp b/realm/realm-jni/src/io_realm_internal_Version.cpp
deleted file mode 100644
index 4fc4bc5cf8..0000000000
--- a/realm/realm-jni/src/io_realm_internal_Version.cpp
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <sstream>
-#include <string>
-
-#include "util.hpp"
-#include "io_realm_internal_Version.h"
-#include <realm/version.hpp>
-#include <realm/string_data.hpp>
-
-static int realm_jni_version = 23;
-
-
-using namespace realm;
-
-JNIEXPORT jint JNICALL Java_io_realm_internal_Version_nativeGetAPIVersion(JNIEnv*, jclass)
-{
-    return realm_jni_version;
-}
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Version_nativeGetVersion(JNIEnv *env, jclass)
-{
-    try {
-        std::string str(Version::get_version());
-        StringData sd(str);
-        return to_jstring(env, sd);
-    }
-    CATCH_STD();
-    return NULL;
-}
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Version_nativeHasFeature(JNIEnv *env, jclass, jint feature)
-{
-    switch (feature) {
-        case 0:
-            return Version::has_feature(feature_Debug);
-        case 1:
-            return Version::has_feature(feature_Replication);
-        default: {
-            std::ostringstream ss;
-            ss << "Unknown feature code: " << feature;
-            ThrowException(env, RuntimeError, ss.str());
-        }
-    }
-    return false;
-}
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Version_nativeIsAtLeast(JNIEnv *, jclass,
-    jint major, jint minor, jint patch)
-{
-    return Version::is_at_least(major, minor, patch);
-}
diff --git a/realm/realm-jni/src/io_realm_internal_Version.h b/realm/realm-jni/src/io_realm_internal_Version.h
deleted file mode 100644
index 8bbe942a7d..0000000000
--- a/realm/realm-jni/src/io_realm_internal_Version.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/* DO NOT EDIT THIS FILE - it is machine generated */
-#include <jni.h>
-/* Header for class io_realm_internal_Version */
-
-#ifndef _Included_io_realm_internal_Version
-#define _Included_io_realm_internal_Version
-#ifdef __cplusplus
-extern "C" {
-#endif
-#undef io_realm_internal_Version_CORE_MIN_MAJOR
-#define io_realm_internal_Version_CORE_MIN_MAJOR 0L
-#undef io_realm_internal_Version_CORE_MIN_MINOR
-#define io_realm_internal_Version_CORE_MIN_MINOR 1L
-#undef io_realm_internal_Version_CORE_MIN_PATCH
-#define io_realm_internal_Version_CORE_MIN_PATCH 6L
-#undef io_realm_internal_Version_REQUIRED_JNI_VERSION
-#define io_realm_internal_Version_REQUIRED_JNI_VERSION 23L
-/*
- * Class:     io_realm_internal_Version
- * Method:    nativeGetVersion
- * Signature: ()Ljava/lang/String;
- */
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Version_nativeGetVersion
-  (JNIEnv *, jclass);
-
-/*
- * Class:     io_realm_internal_Version
- * Method:    nativeHasFeature
- * Signature: (I)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Version_nativeHasFeature
-  (JNIEnv *, jclass, jint);
-
-/*
- * Class:     io_realm_internal_Version
- * Method:    nativeIsAtLeast
- * Signature: (III)Z
- */
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Version_nativeIsAtLeast
-  (JNIEnv *, jclass, jint, jint, jint);
-
-/*
- * Class:     io_realm_internal_Version
- * Method:    nativeGetAPIVersion
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_io_realm_internal_Version_nativeGetAPIVersion
-  (JNIEnv *, jclass);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
diff --git a/realm/realm-jni/src/java_lang_List_Util.cpp b/realm/realm-jni/src/java_lang_List_Util.cpp
deleted file mode 100644
index d1a1853b28..0000000000
--- a/realm/realm-jni/src/java_lang_List_Util.cpp
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "util.hpp"
-#include "java_lang_List_Util.hpp"
-
-jint java_lang_List_size(JNIEnv* env, jobject jList)
-{
-    // WARNING: do not cache these methods, list class may be different based on the object jlist
-    jclass jListClass = env->GetObjectClass(jList);
-    if (jListClass == NULL)
-        return 0;
-    jmethodID jListSizeMethodId = env->GetMethodID(jListClass, "size", "()I");
-    if (jListSizeMethodId == NULL) {
-        ThrowException(env, NoSuchMethod, "jList", "size");
-        return 0;
-    }
-    return env->CallIntMethod(jList, jListSizeMethodId);
-}
-
-jobject java_lang_List_get(JNIEnv* env, jobject jList, jint index)
-{
-    // WARNING: do not cache these methods/classes, list class may be different based on the object jlist
-    jclass jListClass = env->GetObjectClass(jList);
-     if (jListClass == NULL)
-        return NULL;
-    jmethodID jListGetMethodId = env->GetMethodID(jListClass, "get", "(I)Ljava/lang/Object;");
-    if (jListGetMethodId == NULL) {
-        ThrowException(env, NoSuchMethod, "jList", "get");
-        return NULL;
-    }
-    return env->CallObjectMethod(jList, jListGetMethodId, index);
-}
diff --git a/realm/realm-jni/src/mixedutil.cpp b/realm/realm-jni/src/mixedutil.cpp
deleted file mode 100644
index 3317ea5a03..0000000000
--- a/realm/realm-jni/src/mixedutil.cpp
+++ /dev/null
@@ -1,223 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "util.hpp"
-#include "mixedutil.hpp"
-#include "columntypeutil.hpp"
-
-using namespace realm;
-
-jclass GetClassMixed(JNIEnv* env)
-{
-    static jclass jMixedClass = GetClass(env, "io/realm/internal/Mixed");
-    return jMixedClass;
-}
-
-jmethodID GetMixedMethodID(JNIEnv* env, const char* methodStr, const char* typeStr)
-{
-    jclass myClass = GetClassMixed(env);
-    if (myClass == NULL)
-        return NULL;
-
-    jmethodID myMethod = env->GetMethodID(myClass, methodStr, typeStr);
-    if (myMethod == NULL) {
-        ThrowException(env, NoSuchMethod, "mixed", methodStr);
-        return NULL;
-    }
-    return myMethod;
-}
-
-DataType GetMixedObjectType(JNIEnv* env, jobject jMixed)
-{
-    // Call Java "Mixed.getType"
-    static jmethodID jGetTypeMethodId = GetMixedMethodID(env, "getType", "()Lio/realm/RealmFieldType;");
-    if (jGetTypeMethodId == NULL)
-        return DataType(0);
-
-    // ???TODO optimize
-    jobject jColumnType = env->CallObjectMethod(jMixed, jGetTypeMethodId);
-    return static_cast<DataType>(GetColumnTypeFromJColumnType(env, jColumnType));
-}
-
-jobject CreateJMixedFromMixed(JNIEnv* env, Mixed& mixed)
-{
-    jclass jMixedClass = GetClassMixed(env);
-    if (jMixedClass == NULL)
-        return NULL;
-
-    TR("CreateJMixedFromMixed(type %d)", mixed.get_type())
-    switch (mixed.get_type()) {
-    case type_Int:
-    {
-        jmethodID consId = GetMixedMethodID(env, "<init>", "(J)V");
-        if (consId)
-            return env->NewObject(jMixedClass, consId, mixed.get_int());
-    }
-    case type_Float:
-    {
-        jmethodID consId = GetMixedMethodID(env, "<init>", "(F)V");
-        if (consId)
-            return env->NewObject(jMixedClass, consId, mixed.get_float());
-    }
-    case type_Double:
-    {
-        jmethodID consId = GetMixedMethodID(env, "<init>", "(D)V");
-        if (consId)
-            return env->NewObject(jMixedClass, consId, mixed.get_double());
-    }
-    case type_String:
-    {
-        jmethodID consId = GetMixedMethodID(env, "<init>", "(Ljava/lang/String;)V");
-        if (consId)
-            return env->NewObject(jMixedClass, consId, to_jstring(env, mixed.get_string()));
-    }
-    case type_Bool:
-    {
-        jmethodID consId = GetMixedMethodID(env, "<init>", "(Z)V");
-        if (consId)
-            return env->NewObject(jMixedClass, consId, mixed.get_bool());
-    }
-    case type_Timestamp:
-        {
-            Timestamp timeValue = mixed.get_timestamp();
-            jclass jDateClass = env->FindClass("java/util/Date");
-            if (jDateClass == NULL) {
-                ThrowException(env, ClassNotFound, "Date");
-                return NULL;
-            }
-            jmethodID jDateConsId = env->GetMethodID(jDateClass, "<init>", "(J)V");
-            if (jDateConsId == NULL) {
-                ThrowException(env, NoSuchMethod, "Date", "<init>");
-                return NULL;
-            }
-            jobject jDate = env->NewObject(jDateClass, jDateConsId, to_milliseconds(timeValue));
-            jmethodID consId = GetMixedMethodID(env, "<init>", "(Ljava/util/Date;)V");
-            if (consId)
-                return env->NewObject(jMixedClass, consId, jDate);
-        }
-    case type_Binary:
-        {
-            BinaryData binaryData = mixed.get_binary();
-            jmethodID consId = GetMixedMethodID(env, "<init>", "(Ljava/nio/ByteBuffer;)V");
-            if (consId) {
-                jobject jByteBuffer = env->NewDirectByteBuffer(const_cast<char*>(binaryData.data()), binaryData.size());
-                return env->NewObject(jMixedClass, consId, jByteBuffer);
-            }
-        }
-    case type_Table:
-        {
-            // param input: Table* t.
-            TR("   --Mixed(type_Table)")
-            jmethodID consId = GetMixedMethodID(env, "<init>", "(Lio/realm/RealmFieldType;)V");
-
-            jobject jColumnType = NULL; // GetJColumnTypeFromColumnType(env, type_Table);
-            if (consId)
-                return env->NewObject(jMixedClass, consId, jColumnType);
-        }
-    case type_Mixed:
-        break;
-    case type_Link:
-        break;
-    case type_LinkList:
-        break;
-    case type_OldDateTime:
-        // not used anymore
-        break;
-    }
-
-    return NULL;
-}
-
-jlong GetMixedIntValue(JNIEnv* env, jobject jMixed)
-{
-    static jmethodID jGetLongValueMethodId = GetMixedMethodID(env, "getLongValue", "()J");
-
-    if (jGetLongValueMethodId)
-        return env->CallLongMethod(jMixed, jGetLongValueMethodId);
-    return 0;
-}
-
-jfloat GetMixedFloatValue(JNIEnv* env, jobject jMixed)
-{
-    static jmethodID jGetFloatValueMethodId = GetMixedMethodID(env, "getFloatValue", "()F");
-
-    if (jGetFloatValueMethodId)
-        return env->CallFloatMethod(jMixed, jGetFloatValueMethodId);
-    return 0;
-}
-
-jdouble GetMixedDoubleValue(JNIEnv* env, jobject jMixed)
-{
-    static jmethodID jGetDoubleValueMethodId = GetMixedMethodID(env, "getDoubleValue", "()D");
-
-    if (jGetDoubleValueMethodId)
-        return env->CallDoubleMethod(jMixed, jGetDoubleValueMethodId);
-    return 0;
-}
-
-jstring GetMixedStringValue(JNIEnv* env, jobject jMixed)
-{
-    static jmethodID jGetStringValueMethodId = GetMixedMethodID(env, "getStringValue", "()Ljava/lang/String;");;
-
-    if (jGetStringValueMethodId)
-        return (jstring)(env->CallObjectMethod(jMixed, jGetStringValueMethodId));
-    return 0;
-}
-
-jboolean GetMixedBooleanValue(JNIEnv* env, jobject jMixed)
-{
-    static jmethodID jGetBoolValueMethodId = GetMixedMethodID(env, "getBooleanValue", "()Z");
-
-    if (jGetBoolValueMethodId)
-        return env->CallBooleanMethod(jMixed, jGetBoolValueMethodId);
-    return 0;
-}
-
-jbyteArray GetMixedByteArrayValue(JNIEnv* env, jobject jMixed)
-{
-    static jmethodID jGetBinaryDataMethodId = GetMixedMethodID(env, "getBinaryByteArray", "()[B");
-
-    if (jGetBinaryDataMethodId)
-        return reinterpret_cast<jbyteArray>(env->CallObjectMethod(jMixed, jGetBinaryDataMethodId));
-    return 0;
-}
-
-jlong GetMixedDateTimeValue(JNIEnv* env, jobject jMixed)
-{
-    static jmethodID jGetDateTimeMethodId = GetMixedMethodID(env, "getDateTimeValue", "()J");
-
-    if (jGetDateTimeMethodId)
-        return env->CallLongMethod(jMixed, jGetDateTimeMethodId);
-    return 0;
-}
-
-jobject GetMixedByteBufferValue(JNIEnv* env, jobject jMixed)
-{
-    static jmethodID jGetBinaryValueMethodId = GetMixedMethodID(env, "getBinaryValue", "()Ljava/nio/ByteBuffer;");
-
-    if (jGetBinaryValueMethodId)
-        return env->CallObjectMethod(jMixed, jGetBinaryValueMethodId);
-    return 0;
-}
-
-jint GetMixedBinaryType(JNIEnv* env, jobject jMixed)
-{
-    static jmethodID jGetBinaryTypeMethodId = GetMixedMethodID(env, "getBinaryType", "()I");
-
-    if (jGetBinaryTypeMethodId)
-        return env->CallIntMethod(jMixed, jGetBinaryTypeMethodId);
-    return 0;
-}
diff --git a/realm/realm-jni/src/mixedutil.hpp b/realm/realm-jni/src/mixedutil.hpp
deleted file mode 100644
index e7010072b0..0000000000
--- a/realm/realm-jni/src/mixedutil.hpp
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef MIXED_UTIL_H
-#define MIXED_UTIL_H
-
-#include <jni.h>
-#include <realm.hpp>
-
-using namespace realm;
-
-DataType GetMixedObjectType(JNIEnv* env, jobject jMixed);
-jobject CreateJMixedFromMixed(JNIEnv* env, Mixed& mixed);
-jlong GetMixedIntValue(JNIEnv* env, jobject jMixed);
-jfloat GetMixedFloatValue(JNIEnv* env, jobject jMixed);
-jdouble GetMixedDoubleValue(JNIEnv* env, jobject jMixed);
-jstring GetMixedStringValue(JNIEnv* env, jobject jMixed);
-jboolean GetMixedBooleanValue(JNIEnv* env, jobject jMixed);
-jbyteArray GetMixedByteArrayValue(JNIEnv* env, jobject jMixed);
-jlong GetMixedDateTimeValue(JNIEnv* env, jobject jMixed);
-jobject GetMixedByteBufferValue(JNIEnv* env, jobject jMixed);
-jint GetMixedBinaryType(JNIEnv* env, jobject jMixed);
-
-#endif
diff --git a/realm/realm-jni/src/tablebase_tpl.hpp b/realm/realm-jni/src/tablebase_tpl.hpp
deleted file mode 100644
index 67c05beebd..0000000000
--- a/realm/realm-jni/src/tablebase_tpl.hpp
+++ /dev/null
@@ -1,245 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef REALM_JNI_TABLEBASE_TPL_HPP
-#define REALM_JNI_TABLEBASE_TPL_HPP
-
-
-template <class T>
-jbyteArray tbl_GetByteArray(JNIEnv* env, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
-{
-    if (!TBL_AND_INDEX_VALID(env, reinterpret_cast<T*>(nativeTablePtr), columnIndex, rowIndex))
-        return NULL;
-
-    BinaryData bin = reinterpret_cast<T*>(nativeTablePtr)->get_binary( S(columnIndex), S(rowIndex));
-    if (bin.is_null()) {
-        return NULL;
-    }
-    if (bin.size() <= MAX_JSIZE) {
-        jbyteArray jresult = env->NewByteArray(static_cast<jsize>(bin.size()));
-        if (jresult)
-            env->SetByteArrayRegion(jresult, 0, static_cast<jsize>(bin.size()), reinterpret_cast<const jbyte*>(bin.data()));  // throws
-        return jresult;
-    }
-    else {
-        ThrowException(env, IllegalArgument, "Length of ByteArray is larger than an Int.");
-        return NULL;
-    }
-}
-
-template <class M, class T>
-void tbl_nativeDoByteArray(M doBinary, T* pTable, JNIEnv* env, jlong columnIndex, jlong rowIndex, jbyteArray dataArray)
-{
-    jbyte* bytePtr = env->GetByteArrayElements(dataArray, NULL);
-    if (!bytePtr) {
-        ThrowException(env, IllegalArgument, "doByteArray");
-        return;
-    }
-    size_t dataLen = S(env->GetArrayLength(dataArray));
-    (pTable->*doBinary)( S(columnIndex), S(rowIndex), BinaryData(reinterpret_cast<char*>(bytePtr), dataLen));
-    env->ReleaseByteArrayElements(dataArray, bytePtr, 0);
-}
-
-
-template <class M, class T>
-void tbl_nativeDoBinary(M doBinary, T* pTable, JNIEnv* env, jlong columnIndex, jlong rowIndex, jobject byteBuffer)
-{
-    BinaryData bin;
-    if (GetBinaryData(env, byteBuffer, bin))
-        (pTable->*doBinary)( S(columnIndex), S(rowIndex), bin);
-}
-
-
-// insertMixed() or setMixed() value for TableView or Table class
-
-template <class M, class T>
-void tbl_nativeDoMixed(M doMixed, T* pTable, JNIEnv* env, jlong columnIndex, jlong rowIndex, jobject jMixedValue)
-{
-    DataType valueType = GetMixedObjectType(env, jMixedValue);
-    switch(valueType) {
-    case type_Int:
-        {
-            jlong longValue = GetMixedIntValue(env, jMixedValue);
-            (pTable->*doMixed)( S(columnIndex), S(rowIndex), Mixed(static_cast<int64_t>(longValue)));
-            return;
-        }
-    case type_Float:
-        {
-            jfloat floatValue = GetMixedFloatValue(env, jMixedValue);
-            (pTable->*doMixed)( S(columnIndex), S(rowIndex), Mixed(floatValue));
-            return;
-        }
-    case type_Double:
-        {
-            jdouble doubleValue = GetMixedDoubleValue(env, jMixedValue);
-            (pTable->*doMixed)( S(columnIndex), S(rowIndex), Mixed(doubleValue));
-            return;
-        }
-    case type_Bool:
-        {
-            jboolean boolValue = GetMixedBooleanValue(env, jMixedValue);
-            (pTable->*doMixed)( S(columnIndex), S(rowIndex), Mixed(boolValue != 0 ? true : false));
-            return;
-        }
-    case type_String:
-        {
-            jstring stringValue = GetMixedStringValue(env, jMixedValue);
-            JStringAccessor string(env, stringValue); // throws
-            (pTable->*doMixed)( S(columnIndex), S(rowIndex), StringData(string));
-            return;
-        }
-    case type_Timestamp:
-        {
-            jlong dateTimeValue = GetMixedDateTimeValue(env, jMixedValue);
-            Timestamp ts = from_milliseconds(dateTimeValue);
-            (pTable->*doMixed)( S(columnIndex), S(rowIndex), Mixed(ts));
-            return;
-        }
-    case type_Binary:
-        {
-            jint mixedBinaryType = GetMixedBinaryType(env, jMixedValue);
-            if (mixedBinaryType == 0) {
-                jbyteArray dataArray = GetMixedByteArrayValue(env, jMixedValue);
-                if (!dataArray)
-                    break;
-                char* data = reinterpret_cast<char*>(env->GetByteArrayElements(dataArray, NULL));
-                if (!data)
-                    break;
-                size_t size = S(env->GetArrayLength(dataArray));
-                (pTable->*doMixed)( S(columnIndex), S(rowIndex), BinaryData(data, size));
-                env->ReleaseByteArrayElements(dataArray, reinterpret_cast<jbyte*>(data), 0);
-                return;
-            }
-            else if (mixedBinaryType == 1) {
-                jobject jByteBuffer = GetMixedByteBufferValue(env, jMixedValue);
-                if (!jByteBuffer)
-                    break;
-                BinaryData binaryData;
-                if (GetBinaryData(env, jByteBuffer, binaryData))
-                    (pTable->*doMixed)( S(columnIndex), S(rowIndex), binaryData);
-                return;
-            }
-            break; // failed
-        }
-    case type_Table:
-        {
-            (pTable->*doMixed)( S(columnIndex), S(rowIndex), Mixed::subtable_tag());
-            return;
-        }
-    case type_Mixed:
-        break;
-    case type_Link:
-        break;
-    case type_LinkList:
-        break;
-    case type_OldDateTime:
-        // not used
-        break;
-    }
-    TR_ERR("ERROR: nativeSetMixed() failed.")
-    ThrowException(env, IllegalArgument, "nativeSetMixed()");
-}
-
-template <class R>
-void row_nativeSetMixed(R* pRow, JNIEnv* env, jlong columnIndex, jobject jMixedValue)
-{
-    DataType valueType = GetMixedObjectType(env, jMixedValue);
-    switch(valueType) {
-    case type_Int:
-        {
-            jlong longValue = GetMixedIntValue(env, jMixedValue);
-            pRow->set_mixed( S(columnIndex), Mixed(static_cast<int64_t>(longValue)));
-            return;
-        }
-    case type_Float:
-        {
-            jfloat floatValue = GetMixedFloatValue(env, jMixedValue);
-            pRow->set_mixed( S(columnIndex), Mixed(floatValue));
-            return;
-        }
-    case type_Double:
-        {
-            jdouble doubleValue = GetMixedDoubleValue(env, jMixedValue);
-            pRow->set_mixed( S(columnIndex), Mixed(doubleValue));
-            return;
-        }
-    case type_Bool:
-        {
-            jboolean boolValue = GetMixedBooleanValue(env, jMixedValue);
-            pRow->set_mixed( S(columnIndex), Mixed(boolValue != 0 ? true : false));
-            return;
-        }
-    case type_String:
-        {
-            jstring stringValue = GetMixedStringValue(env, jMixedValue);
-            JStringAccessor string(env, stringValue); // throws
-            pRow->set_mixed( S(columnIndex), StringData(string));
-            return;
-        }
-    case type_Timestamp:
-        {
-            jlong dateTimeValue = GetMixedDateTimeValue(env, jMixedValue);
-            Timestamp ts = from_milliseconds(dateTimeValue);
-            pRow->set_mixed( S(columnIndex), Mixed(ts));
-            return;
-        }
-    case type_Binary:
-        {
-            jint mixedBinaryType = GetMixedBinaryType(env, jMixedValue);
-            if (mixedBinaryType == 0) {
-                jbyteArray dataArray = GetMixedByteArrayValue(env, jMixedValue);
-                if (!dataArray)
-                    break;
-                char* data = reinterpret_cast<char*>(env->GetByteArrayElements(dataArray, NULL));
-                if (!data)
-                    break;
-                size_t size = S(env->GetArrayLength(dataArray));
-                pRow->set_mixed( S(columnIndex), BinaryData(data, size));
-                env->ReleaseByteArrayElements(dataArray, reinterpret_cast<jbyte*>(data), 0);
-                return;
-            }
-            else if (mixedBinaryType == 1) {
-                jobject jByteBuffer = GetMixedByteBufferValue(env, jMixedValue);
-                if (!jByteBuffer)
-                    break;
-                BinaryData binaryData;
-                if (GetBinaryData(env, jByteBuffer, binaryData))
-                    pRow->set_mixed( S(columnIndex), binaryData);
-                return;
-            }
-            break; // failed
-        }
-    case type_Table:
-        {
-            pRow->set_mixed( S(columnIndex), Mixed::subtable_tag());
-            return;
-        }
-    case type_Mixed:
-        break;
-    case type_Link:
-        break;
-    case type_LinkList:
-        break;
-    case type_OldDateTime:
-        // not used
-        break;
-    }
-    TR_ERR("ERROR: nativeSetMixed() failed.")
-    ThrowException(env, IllegalArgument, "nativeSetMixed()");
-}
-
-
-#endif // REALM_JNI_TABLEBASE_TPL_HPP
diff --git a/realm/realm-jni/src/tablequery.hpp b/realm/realm-jni/src/tablequery.hpp
deleted file mode 100644
index 11ab2891eb..0000000000
--- a/realm/realm-jni/src/tablequery.hpp
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef __REALM_TABLEQUERY__
-#define __REALM_TABLEQUERY__
-
-#include <vector>
-#include <assert.h>
-#include <realm.hpp>
-
-class TableQuery : public realm::Query {
-    // 'subtables' is used to figure out which subtable the query
-    // is currently working on, so that we can lookup the correct
-    // table and verify the parameters related to that table.
-    std::vector<size_t> subtables;  // holds subtable column indices
-
-public:
-    TableQuery(const Query& copy) : realm::Query(copy) {};
- 
-    void push_subtable(size_t index) {
-        subtables.push_back(index);
-    }
-
-    bool pop_subtable() {
-        if (subtables.empty())
-            return false;
-        subtables.pop_back();
-        return true;
-    }
-    
-    realm::TableRef get_current_table() {
-        realm::TableRef table = get_table();
-
-        // Go through the stack of subtables to find current subtable (if any)
-        size_t size = subtables.size(); 
-        for (size_t i = 0; i < size; ++i) {
-            size_t index = subtables[i];
-            table = table->get_subtable(index, 0);
-        }
-        return table;
-    }
-};
-
-#define TQ(ptr) reinterpret_cast<TableQuery*>(ptr)
-
-#endif // __REALM_TABLEQUERY__
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index 42f14b4651..c26ff09921 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -1,4 +1,5 @@
-apply plugin: 'android-sdk-manager'
+import java.security.MessageDigest
+
 apply plugin: 'com.android.library'
 apply plugin: 'com.neenbedankt.android-apt'
 apply plugin: 'com.github.dcendents.android-maven'
@@ -9,17 +10,58 @@ apply plugin: 'findbugs'
 apply plugin: 'pmd'
 apply plugin: 'checkstyle'
 apply plugin: 'com.github.kt3k.coveralls'
+apply plugin: 'de.undercouch.download'
+
+ext.coreVersion = '2.0.0-rc4'
+// empty or comment out this to disable hash checking
+ext.coreSha256Hash = '760d8e889b8d678da36f63be2a49924969bfc8370176696ee977659d59677717'
+ext.forceDownloadCore =
+        project.hasProperty('forceDownloadCore') ? project.getProperty('forceDownloadCore').toBoolean() : false
+// Set the core source code path. By setting this, the core will be built from source. And coreVersion will be read from
+// core source code.
+ext.coreSourcePath = project.hasProperty('coreSourcePath') ? project.getProperty('coreSourcePath') : null
+// The location of core archive.
+ext.coreArchiveDir = System.getenv("REALM_CORE_DOWNLOAD_DIR")
+if (!ext.coreArchiveDir) {
+    ext.coreArchiveDir = ".."
+}
+ext.coreArchiveFile = rootProject.file("${ext.coreArchiveDir}/core-android-${project.coreVersion}.tar.gz")
+ext.coreDistributionDir = file("${projectDir}/distribution/realm-core/")
+ext.coreDir = file("${project.coreDistributionDir.getAbsolutePath()}/core-${project.coreVersion}")
 
 android {
-    compileSdkVersion 23
-    buildToolsVersion '23.0.0'
+    compileSdkVersion 24
+    buildToolsVersion '24.0.0'
 
     defaultConfig {
         minSdkVersion 9
-        targetSdkVersion 23
+        targetSdkVersion 24
         project.archivesBaseName = "realm-android-library"
         consumerProguardFiles 'proguard-rules.pro'
         testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+        externalNativeBuild {
+            cmake {
+                arguments "-DREALM_CORE_DIST_DIR:STRING=${project.coreDir.getAbsolutePath()}",
+                          // FIXME:
+                          // This is copied from https://dl.google.com/android/repository/cmake-3.4.2909474-linux-x86_64.zip
+                          // because of the android.toolchain.cmake shipped with Android SDK CMake 3.6 doesn't work with our
+                          // JNI build currently (lack of lto linking support).
+                          // This file should be removed and use the one from Android SDK cmake package when it supports lto.
+                        "-DCMAKE_TOOLCHAIN_FILE=${project.file('src/main/cpp/android.toolchain.cmake').path}"
+                if (!project.hasProperty('android.injected.build.abi') && project.hasProperty('buildTargetABIs')) {
+                    abiFilters(*project.getProperty('buildTargetABIs').trim().split('\\s*,\\s*'))
+                } else {
+                    // armeabi is not supported anymore.
+                    abiFilters 'x86', 'x86_64', 'armeabi-v7a', 'arm64-v8a', 'mips'
+                }
+            }
+        }
+    }
+
+    externalNativeBuild {
+        cmake {
+            path 'src/main/cpp/CMakeLists.txt'
+        }
     }
 
     buildTypes {
@@ -61,9 +103,9 @@ dependencies {
     compile 'com.getkeepsafe.relinker:relinker:1.2.1'
 
     androidTestCompile 'io.reactivex:rxjava:1.1.0'
-    androidTestCompile 'com.android.support:support-annotations:23.1.1'
-    androidTestCompile 'com.android.support.test:runner:0.4.1'
-    androidTestCompile 'com.android.support.test:rules:0.4.1'
+    androidTestCompile 'com.android.support:support-annotations:24.0.0'
+    androidTestCompile 'com.android.support.test:runner:0.5'
+    androidTestCompile 'com.android.support.test:rules:0.5'
     androidTestCompile 'com.google.dexmaker:dexmaker:1.2'
     androidTestCompile 'com.google.dexmaker:dexmaker-mockito:1.2'
     androidTestCompile 'com.opencsv:opencsv:3.4'
@@ -89,6 +131,10 @@ task javadoc(type: Javadoc) {
         charSet = 'UTF-8'
         locale = 'en_US'
         overview = 'src/overview.html'
+
+        links "https://docs.oracle.com/javase/7/docs/api/"
+        links "http://reactivex.io/RxJava/javadoc/"
+        linksOffline "https://developer.android.com/reference/", "${project.android.sdkDirectory}/docs/reference"
     }
     exclude '**/internal/**'
     exclude '**/BuildConfig.java'
@@ -106,10 +152,8 @@ task javadocJar(type: Jar, dependsOn: javadoc) {
     from javadoc.destinationDir
 }
 
-preBuild.dependsOn ':realm-jni:buildAndroidJni'
-
 task findbugs(type: FindBugs) {
-    dependsOn assembleDebug
+    dependsOn assemble
     group = 'Verification'
 
     ignoreFailures = false
@@ -256,3 +300,208 @@ artifacts {
     archives javadocJar
     archives sourcesJar
 }
+
+
+def coreDownloaded = false
+
+task downloadCore(group: 'build setup', description: 'Download the latest version of Realm Core') {
+    def isHashCheckingEnabled = {
+        return project.hasProperty('coreSha256Hash') && !project.coreSha256Hash.empty
+    }
+
+    def calcSha256Hash = {File targetFile ->
+        MessageDigest sha = MessageDigest.getInstance("SHA-256");
+        Formatter hexHash = new Formatter()
+        sha.digest(targetFile.bytes).each { b -> hexHash.format('%02x', b) }
+        return hexHash.toString()
+    }
+
+    def shouldDownloadCore = {
+        if (!project.coreArchiveFile.exists()) {
+            return true
+        }
+        if (project.forceDownloadCore) {
+            return true;
+        }
+        if (!isHashCheckingEnabled()) {
+            println "Skipping hash check(empty \'coreSha256Hash\')."
+            return false
+        }
+
+        def calculatedHash = calcSha256Hash(project.coreArchiveFile)
+        if (project.coreSha256Hash.equalsIgnoreCase(calculatedHash)) {
+            return false
+        }
+
+        println "Existing archive hash mismatch (Expected: ${project.coreSha256Hash.toLowerCase()}" +
+                " but got ${calculatedHash.toLowerCase()}). Download new version."
+        return true
+    }
+
+    doLast {
+        if (shouldDownloadCore()) {
+            download {
+                src "http://static.realm.io/downloads/core/realm-core-android-${project.coreVersion}.tar.gz"
+                dest project.coreArchiveFile
+                onlyIfNewer false
+            }
+            coreDownloaded = true
+
+            if (isHashCheckingEnabled()) {
+                def calculatedHash = calcSha256Hash(project.coreArchiveFile)
+                if (!project.coreSha256Hash.equalsIgnoreCase(calculatedHash)) {
+                    throw new GradleException("Invalid checksum for file '" +
+                            "${project.coreArchiveFile.getName()}'. Expected " +
+                            "${project.coreSha256Hash.toLowerCase()} but got " +
+                            "${calculatedHash.toLowerCase()}.");
+                }
+            } else {
+                println 'Skipping hash check (empty \'coreSha256Hash\').'
+            }
+        }
+    }
+}
+
+task compileCore(group: 'build setup', description: 'Compile the core library from source code') {
+    // Build the library from core source code
+    doFirst {
+        if (!coreSourcePath) {
+            throw new GradleException('The coreSourcePath is not set.')
+        }
+        exec {
+            workingDir = coreSourcePath
+            commandLine = [
+                    "bash",
+                    "build.sh",
+                    "build-android"
+            ]
+        }
+    }
+
+    // Copy the core tar ball
+    doLast {
+        copy {
+            from "${coreSourcePath}/realm-core-android-${coreVersion}.tar.gz"
+            into project.coreArchiveFile.parent
+            rename "realm-core-android-${coreVersion}.tar.gz", "core-android-${coreVersion}.tar.gz"
+        }
+    }
+}
+
+task deployCore(group: 'build setup', description: 'Deploy the latest version of Realm Core') {
+    dependsOn {
+        coreSourcePath ? compileCore : downloadCore
+    }
+
+    outputs.upToDateWhen {
+        // Clean up the coreDir if it is newly downloaded or compiled from source
+        if (coreDownloaded || coreSourcePath) {
+            return false
+        }
+
+        return project.coreDir.exists()
+    }
+
+    doLast {
+        // Delete all files to avoid multiple copies of the same header file in Android Studio.
+        exec {
+            commandLine = [
+                    'rm',
+                    '-rf',
+                    project.coreDistributionDir.getAbsolutePath()
+            ]
+        }
+        copy {
+            from tarTree(project.coreArchiveFile)
+            into project.coreDir
+        }
+    }
+}
+
+preBuild.dependsOn deployCore
+
+if (project.hasProperty('dontCleanJniFiles')) {
+    project.afterEvaluate {
+        tasks.all { task ->
+            if (task.name.startsWith('externalNativeBuildClean')) {
+                task.enabled = false
+            }
+        }
+    }
+} else {
+    task cleanJniHeaders(type: Delete) {
+        delete project.file('src/main/cpp/jni_include')
+    }
+    clean.dependsOn cleanJniHeaders
+
+    task cleanExternalBuildFiles(type: Delete) {
+        delete project.file('.externalNativeBuild')
+    }
+    clean.dependsOn cleanExternalBuildFiles
+}
+
+project.afterEvaluate {
+    android.libraryVariants.all { variant ->
+        variant.externalNativeBuildTasks[0].dependsOn(checkNdk)
+    }
+}
+
+task checkNdk() << {
+    def ndkPathInEnvVariable = System.env.ANDROID_NDK_HOME
+    if (!ndkPathInEnvVariable) {
+        throw new GradleException("The environment variable 'ANDROID_NDK_HOME' must be set.")
+    }
+    checkNdk(ndkPathInEnvVariable)
+
+    def localPropFile = rootProject.file('local.properties')
+    if (!localPropFile.exists()) {
+        // we can skip the checks since 'ANDROID_NDK_HOME' will be used instead.
+    } else {
+        def String ndkPathInLocalProperties = getValueFromPropertiesFile(localPropFile, 'ndk.dir')
+        if (!ndkPathInLocalProperties) {
+            throw new GradleException("'ndk.dir' must be set in ${localPropFile.getAbsolutePath()}.")
+        }
+        checkNdk(ndkPathInLocalProperties)
+        if (new File(ndkPathInLocalProperties).getCanonicalPath()
+                != new File(ndkPathInEnvVariable).getCanonicalPath()) {
+            throw new GradleException(
+                    "The value of environment variable 'ANDROID_NDK_HOME' (${ndkPathInEnvVariable}) and"
+                            + " 'ndk.dir' in 'local.properties' (${ndkPathInLocalProperties}) "
+                            + ' must point the same directory.')
+        }
+    }
+}
+
+def checkNdk(String ndkPath) {
+    def detectedNdkVersion
+    def releaseFile = new File(ndkPath, 'RELEASE.TXT')
+    def propertyFile = new File(ndkPath, 'source.properties')
+    if (releaseFile.isFile()) {
+        detectedNdkVersion = releaseFile.text.trim().split()[0].split('-')[0]
+    } else if (propertyFile.isFile()) {
+        detectedNdkVersion = getValueFromPropertiesFile(propertyFile, 'Pkg.Revision')
+        if (detectedNdkVersion == null) {
+            throw new GradleException("Failed to obtain the NDK version information from ${ndkPath}/source.properties")
+        }
+    } else {
+        throw new GradleException("Neither ${releaseFile.getAbsolutePath()} nor ${propertyFile.getAbsolutePath()} is a file.")
+    }
+    if (detectedNdkVersion != project.ndkVersion) {
+        throw new GradleException("Your NDK version: ${detectedNdkVersion}."
+                +" Realm JNI must be compiled with the version ${project.ndkVersion} of NDK.")
+    }
+}
+
+def getValueFromPropertiesFile(File propFile, String key) {
+    if (!propFile.isFile() || !propFile.canRead()) {
+        return null
+    }
+    def prop = new Properties()
+    def reader = propFile.newReader()
+    try {
+        prop.load(reader)
+    } finally {
+        reader.close()
+    }
+    return prop.get(key)
+}
diff --git a/realm/realm-library/proguard-rules.pro b/realm/realm-library/proguard-rules.pro
index 0b2181d2ed..2ad1784f1a 100644
--- a/realm/realm-library/proguard-rules.pro
+++ b/realm/realm-library/proguard-rules.pro
@@ -6,3 +6,6 @@
 -dontwarn io.realm.**
 -keep class io.realm.RealmCollection
 -keep class io.realm.OrderedRealmCollection
+-keepclasseswithmembernames class io.realm.internal.** {
+    native <methods>;
+}
diff --git a/realm/realm-library/src/androidTest/assets/asset_file.realm b/realm/realm-library/src/androidTest/assets/asset_file.realm
index 1539f77dd2..c5f75da4f8 100644
Binary files a/realm/realm-library/src/androidTest/assets/asset_file.realm and b/realm/realm-library/src/androidTest/assets/asset_file.realm differ
diff --git a/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
new file mode 100644
index 0000000000..4ae12cc5c7
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
@@ -0,0 +1,916 @@
+/*
+ * Copyright 2014-2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.entities.AllTypes;
+import io.realm.entities.AllTypesPrimaryKey;
+import io.realm.entities.AnimalModule;
+import io.realm.entities.Cat;
+import io.realm.entities.CatOwner;
+import io.realm.entities.CyclicType;
+import io.realm.entities.CyclicTypePrimaryKey;
+import io.realm.entities.Dog;
+import io.realm.entities.DogPrimaryKey;
+import io.realm.entities.HumanModule;
+import io.realm.entities.NoPrimaryKeyWithPrimaryKeyObjectRelation;
+import io.realm.entities.NullTypes;
+import io.realm.entities.PrimaryKeyAsBoxedShort;
+import io.realm.entities.PrimaryKeyAsLong;
+import io.realm.entities.PrimaryKeyAsString;
+import io.realm.entities.PrimaryKeyWithNoPrimaryKeyObjectRelation;
+import io.realm.entities.pojo.AllTypesRealmModel;
+import io.realm.entities.pojo.InvalidRealmModel;
+import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmPrimaryKeyConstraintException;
+import io.realm.internal.modules.CompositeMediator;
+import io.realm.internal.modules.FilterableMediator;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static io.realm.internal.test.ExtraTests.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class BulkInsertTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private Realm realm;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void insert() {
+        AllJavaTypes obj = new AllJavaTypes();
+        obj.setFieldIgnored("cookie");
+        obj.setFieldId(42);
+        obj.setFieldLong(42);
+        obj.setFieldString("obj1");
+
+        RealmList<AllJavaTypes> list = new RealmList<AllJavaTypes>();
+        list.add(obj);
+
+        Date date = new Date();
+
+        AllJavaTypes allTypes = new AllJavaTypes();
+        allTypes.setFieldString("String");
+        allTypes.setFieldId(1L);
+        allTypes.setFieldLong(1L);
+        allTypes.setFieldFloat(1F);
+        allTypes.setFieldDouble(1D);
+        allTypes.setFieldBoolean(true);
+        allTypes.setFieldDate(date);
+        allTypes.setFieldBinary(new byte[]{1, 2, 3});
+        allTypes.setFieldObject(obj);
+        allTypes.setFieldList(list);
+
+        realm.beginTransaction();
+        realm.insert(allTypes);
+        realm.commitTransaction();
+
+        AllJavaTypes realmTypes = realm.where(AllJavaTypes.class).findFirst();
+
+        assertNotNull(realmTypes);
+        assertNotSame(allTypes, realmTypes); // Objects should not be considered equal
+        assertEquals(allTypes.getFieldString(), realmTypes.getFieldString()); // But they contain the same data
+        assertEquals(allTypes.getFieldLong(), realmTypes.getFieldLong());
+        assertEquals(allTypes.getFieldFloat(), realmTypes.getFieldFloat(), 0);
+        assertEquals(allTypes.getFieldDouble(), realmTypes.getFieldDouble(), 0);
+        assertEquals(allTypes.isFieldBoolean(), realmTypes.isFieldBoolean());
+        assertEquals(allTypes.getFieldDate(), realmTypes.getFieldDate());
+        assertArrayEquals(allTypes.getFieldBinary(), realmTypes.getFieldBinary());
+        assertEquals(allTypes.getFieldObject().getFieldString(), obj.getFieldString());
+        assertEquals(list.size(), realmTypes.getFieldList().size());
+        assertEquals(list.get(0).getFieldString(), realmTypes.getFieldList().get(0).getFieldString());
+        assertEquals(list.get(0).getFieldLong(), realmTypes.getFieldList().get(0).getFieldLong());
+        assertNull(realmTypes.getFieldList().get(0).getFieldIgnored());
+
+
+        // make sure Dog was not inserted twice in the recursive process
+        assertEquals(2, realm.where(AllJavaTypes.class).findAll().size());
+    }
+
+    @Test
+    public void insert_realmModel() {
+        AllTypesRealmModel allTypes = new AllTypesRealmModel();
+        allTypes.columnLong = 10;
+        allTypes.columnBoolean = false;
+        allTypes.columnBinary = new byte[]{1, 2, 3};
+        allTypes.columnDate = new Date();
+        allTypes.columnDouble = 3.1415;
+        allTypes.columnFloat = 1.234567f;
+        allTypes.columnString = "test data";
+        allTypes.columnByte = 0b0010_1010;
+
+        realm.beginTransaction();
+        realm.insert(allTypes);
+        realm.commitTransaction();
+
+        AllTypesRealmModel first = realm.where(AllTypesRealmModel.class).findFirst();
+        assertNotNull(first);
+        assertEquals(allTypes.columnString, first.columnString);
+        assertEquals(allTypes.columnLong, first.columnLong);
+        assertEquals(allTypes.columnBoolean, first.columnBoolean);
+        assertArrayEquals(allTypes.columnBinary, first.columnBinary);
+        assertEquals(allTypes.columnDate, first.columnDate);
+        assertEquals(allTypes.columnDouble, first.columnDouble, 0.0000001);
+        assertEquals(allTypes.columnFloat, first.columnFloat, 0.0000001);
+        assertEquals(allTypes.columnByte, first.columnByte);
+    }
+
+    @Test
+    public void insert_invalidRealmModel() {
+        InvalidRealmModel invalidRealmModel = new InvalidRealmModel();
+
+        realm.beginTransaction();
+        try {
+            realm.insert(invalidRealmModel);
+            fail("Expected Missing Proxy Class Exception");
+        } catch (RealmException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void insertOrUpdate_nullTypes() {
+        NullTypes nullTypes1 = new NullTypes();
+        nullTypes1.setId(1);
+        nullTypes1.setFieldIntegerNull(1);
+        nullTypes1.setFieldFloatNull(2F);
+        nullTypes1.setFieldDoubleNull(3D);
+        nullTypes1.setFieldBooleanNull(true);
+        nullTypes1.setFieldStringNull("4");
+        nullTypes1.setFieldDateNull(new Date(12345));
+
+        realm.beginTransaction();
+        realm.insert(nullTypes1);
+        realm.commitTransaction();
+
+        NullTypes first = realm.where(NullTypes.class).findFirst();
+
+        assertNotNull(first);
+        assertEquals(nullTypes1.getId(), first.getId());
+        assertEquals(nullTypes1.getFieldIntegerNull(), first.getFieldIntegerNull());
+        assertEquals(nullTypes1.getFieldFloatNull(), first.getFieldFloatNull());
+        assertEquals(nullTypes1.getFieldDoubleNull(), first.getFieldDoubleNull());
+        assertEquals(nullTypes1.getFieldBooleanNull(), first.getFieldBooleanNull());
+        assertEquals(nullTypes1.getFieldStringNull(), first.getFieldStringNull());
+        assertEquals(nullTypes1.getFieldDateNull(), first.getFieldDateNull());
+
+        NullTypes nullTypes2 = new NullTypes();
+        nullTypes2.setId(2);
+
+        NullTypes nullTypes3 = new NullTypes();
+        nullTypes3.setId(3);
+
+        nullTypes1 = new NullTypes();
+        nullTypes1.setId(1);
+        nullTypes1.setFieldIntegerNull(null);
+        nullTypes1.setFieldFloatNull(null);
+        nullTypes1.setFieldDoubleNull(null);
+        nullTypes1.setFieldBooleanNull(null);
+        nullTypes1.setFieldStringNull(null);
+        nullTypes1.setFieldDateNull(null);
+        nullTypes1.setFieldListNull(new RealmList<NullTypes>());
+        nullTypes1.getFieldListNull().add(nullTypes2);
+        nullTypes1.getFieldListNull().add(nullTypes3);
+
+        OrderedRealmCollection<NullTypes> collection = new RealmList<NullTypes>();
+        collection.add(nullTypes2);
+        collection.add(nullTypes1);
+        collection.add(nullTypes3);
+
+        realm.beginTransaction();
+        realm.insertOrUpdate(collection);
+        realm.commitTransaction();
+
+        first = realm.where(NullTypes.class).equalTo("id", 1).findFirst();
+
+        assertNotNull(first);
+        assertEquals(nullTypes1.getId(), first.getId());
+        assertNull(first.getFieldIntegerNull());
+        assertNull(first.getFieldFloatNull());
+        assertNull(first.getFieldDoubleNull());
+        assertNull(first.getFieldBooleanNull());
+        assertNull(first.getFieldStringNull());
+        assertNull(first.getFieldDateNull());
+        assertEquals(2, first.getFieldListNull().size());
+        assertEquals(2, first.getFieldListNull().get(0).getId());
+        assertEquals(3, first.getFieldListNull().get(1).getId());
+    }
+
+    @Test
+    public void insert_cyclicType() {
+        CyclicType oneCyclicType = new CyclicType();
+        oneCyclicType.setName("One");
+        CyclicType anotherCyclicType = new CyclicType();
+        anotherCyclicType.setName("Two");
+        oneCyclicType.setObject(anotherCyclicType);
+        anotherCyclicType.setObject(oneCyclicType);
+
+        realm.beginTransaction();
+        realm.insert(Arrays.asList(oneCyclicType, anotherCyclicType));
+        realm.commitTransaction();
+
+        RealmResults<CyclicType> realmObjects = realm.where(CyclicType.class).findAllSorted(CyclicType.FIELD_NAME);
+        assertNotNull(realmObjects);
+        assertEquals(2, realmObjects.size());
+        assertEquals("One", realmObjects.get(0).getName());
+        assertEquals("Two", realmObjects.get(0).getObject().getName());
+    }
+
+    @Test
+    public void insertOrUpdate_cyclicType() {
+        CyclicTypePrimaryKey oneCyclicType = new CyclicTypePrimaryKey(1, "One");
+        CyclicTypePrimaryKey anotherCyclicType = new CyclicTypePrimaryKey(2, "Two");
+        oneCyclicType.setObject(anotherCyclicType);
+        anotherCyclicType.setObject(oneCyclicType);
+
+        realm.beginTransaction();
+        realm.insertOrUpdate(Arrays.asList(oneCyclicType, anotherCyclicType));
+        realm.commitTransaction();
+
+        RealmResults<CyclicTypePrimaryKey> realmObjects = realm.where(CyclicTypePrimaryKey.class).findAllSorted("name");
+        assertNotNull(realmObjects);
+        assertEquals(2, realmObjects.size());
+        assertEquals("One", realmObjects.get(0).getName());
+        assertEquals("Two", realmObjects.get(0).getObject().getName());
+
+        CyclicTypePrimaryKey updatedCyclicType = new CyclicTypePrimaryKey(2, "updated");
+
+        realm.beginTransaction();
+        realm.insertOrUpdate(updatedCyclicType);
+        realm.commitTransaction();
+
+        assertEquals("One", realmObjects.get(0).getName());
+        assertEquals("updated", realmObjects.get(0).getObject().getName());
+        assertEquals(2, realm.where(CyclicTypePrimaryKey.class).count());
+    }
+
+    @Test
+    public void insert_nullPrimaryKey() {
+        PrimaryKeyAsString primaryKeyAsString = new PrimaryKeyAsString();
+        primaryKeyAsString.setId(19);
+
+        realm.beginTransaction();
+        realm.insertOrUpdate(primaryKeyAsString);
+        realm.commitTransaction();
+
+        primaryKeyAsString = realm.where(PrimaryKeyAsString.class).isNull("name").findFirst();
+        assertNotNull(primaryKeyAsString);
+        assertNull(primaryKeyAsString.getName());
+        assertEquals(19, primaryKeyAsString.getId());
+
+        PrimaryKeyAsBoxedShort primaryKeyAsShort = new PrimaryKeyAsBoxedShort();
+        primaryKeyAsShort.setName("42");
+
+        realm.beginTransaction();
+        realm.insertOrUpdate(primaryKeyAsShort);
+        realm.commitTransaction();
+
+        primaryKeyAsShort = realm.where(PrimaryKeyAsBoxedShort.class).isNull("id").findFirst();
+        assertNotNull(primaryKeyAsShort);
+        assertNull(primaryKeyAsShort.getId());
+        assertEquals("42", primaryKeyAsShort.getName());
+    }
+
+    @Test
+    public void insert_duplicatedPrimaryKeyFails() {
+
+        // Single object with 2 references to two objects with the same ID
+        AllJavaTypes obj = new AllJavaTypes(2);
+        obj.setFieldList(new RealmList<AllJavaTypes>(new AllJavaTypes(1), new AllJavaTypes(1)));
+        realm.beginTransaction();
+        try {
+            realm.insert(obj);
+            fail();
+        } catch (RealmPrimaryKeyConstraintException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+
+        // Two objects with the same ID in a list
+        realm.beginTransaction();
+        try {
+            realm.insert(Arrays.asList(new AllJavaTypes(1), new AllJavaTypes(1)));
+            fail();
+        } catch (RealmPrimaryKeyConstraintException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void insertOrUpdate() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
+                obj.setColumnString("Foo");
+                obj.setColumnLong(1);
+                obj.setColumnFloat(1.23F);
+                obj.setColumnDouble(1.234D);
+                obj.setColumnBoolean(false);
+                obj.setColumnBinary(new byte[]{1, 2, 3});
+                obj.setColumnDate(new Date(1000));
+                obj.setColumnRealmObject(new DogPrimaryKey(1, "Dog1"));
+                obj.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(2, "Dog2")));
+                obj.setColumnBoxedBoolean(true);
+                realm.insert(obj);
+
+                AllTypesPrimaryKey obj2 = new AllTypesPrimaryKey();
+                obj2.setColumnString("Bar");
+                obj2.setColumnLong(1);
+                obj2.setColumnFloat(2.23F);
+                obj2.setColumnDouble(2.234D);
+                obj2.setColumnBoolean(true);
+                obj2.setColumnBinary(new byte[]{2, 3, 4});
+                obj2.setColumnDate(new Date(2000));
+                obj2.setColumnRealmObject(new DogPrimaryKey(3, "Dog3"));
+                obj2.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(4, "Dog4")));
+                obj2.setColumnBoxedBoolean(false);
+                realm.insertOrUpdate(obj2);
+            }
+        });
+
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).count());
+        AllTypesPrimaryKey obj = realm.where(AllTypesPrimaryKey.class).findFirst();
+
+        // Check that the only element has all its properties updated
+        assertNotNull(obj);
+        assertEquals("Bar", obj.getColumnString());
+        assertEquals(1, obj.getColumnLong());
+        assertEquals(2.23F, obj.getColumnFloat(), 0);
+        assertEquals(2.234D, obj.getColumnDouble(), 0);
+        assertEquals(true, obj.isColumnBoolean());
+        assertArrayEquals(new byte[]{2, 3, 4}, obj.getColumnBinary());
+        assertEquals(new Date(2000), obj.getColumnDate());
+        assertEquals("Dog3", obj.getColumnRealmObject().getName());
+        assertEquals(1, obj.getColumnRealmList().size());
+        assertEquals("Dog4", obj.getColumnRealmList().get(0).getName());
+        assertEquals(4, realm.where(DogPrimaryKey.class).findAll().size());
+        assertFalse(obj.getColumnBoxedBoolean());
+    }
+
+    @Test
+    public void insert_list() {
+        Dog dog1 = new Dog();
+        dog1.setName("Dog 1");
+        Dog dog2 = new Dog();
+        dog2.setName("Dog 2");
+        RealmList<Dog> list = new RealmList<Dog>();
+        list.addAll(Arrays.asList(dog1, dog2));
+
+        realm.beginTransaction();
+        realm.insert(list);
+        realm.commitTransaction();
+
+
+        RealmResults<Dog> copiedList = realm.where(Dog.class).findAll();
+
+        assertEquals(2, copiedList.size());
+        assertEquals(dog1.getName(), copiedList.get(0).getName());
+        assertEquals(dog2.getName(), copiedList.get(1).getName());
+    }
+
+    @Test
+    public void insert_emptyList() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.insert(Collections.<PrimaryKeyAsLong>emptyList());
+            }
+        });
+        assertEquals(0, realm.where(PrimaryKeyAsLong.class).count());
+    }
+
+    /**
+     * added to reproduce https://github.com/realm/realm-java/issues/3103
+     */
+    @Test
+    public void insert_emptyListWithCompositeMediator() {
+        final RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .modules(new HumanModule(), new AnimalModule())
+                .name("composite.realm")
+                .build();
+        Realm.deleteRealm(config);
+
+        assertEquals(config.getSchemaMediator().getClass(), CompositeMediator.class);
+
+        final Realm realm = Realm.getInstance(config);
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            realm.executeTransaction(new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    realm.insert(Collections.<Cat>emptyList());
+                }
+            });
+            assertEquals(0, realm.where(Cat.class).count());
+        } finally {
+            realm.close();
+        }
+    }
+
+    /**
+     * added to reproduce https://github.com/realm/realm-java/issues/3103
+     */
+    @Test
+    public void insert_emptyListWithFilterableMediator() {
+        //noinspection unchecked
+        final RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .schema(CatOwner.class, Cat.class)
+                .name("filterable.realm")
+                .build();
+        Realm.deleteRealm(config);
+
+        assertEquals(config.getSchemaMediator().getClass(), FilterableMediator.class);
+
+        final Realm realm = Realm.getInstance(config);
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            realm.executeTransaction(new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    realm.insert(Collections.<Cat>emptyList());
+                }
+            });
+            assertEquals(0, realm.where(Cat.class).count());
+        } finally {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void insertOrUpdate_list() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                PrimaryKeyAsLong obj = new PrimaryKeyAsLong();
+                obj.setId(1);
+                obj.setName("Foo");
+                realm.copyToRealm(obj);
+
+                PrimaryKeyAsLong obj2 = new PrimaryKeyAsLong();
+                obj2.setId(1);
+                obj2.setName("Bar");
+
+                PrimaryKeyAsLong obj3 = new PrimaryKeyAsLong();
+                obj3.setId(1);
+                obj3.setName("Baz");
+
+                realm.insertOrUpdate(Arrays.asList(obj2, obj3));
+            }
+        });
+
+        assertEquals(1, realm.where(PrimaryKeyAsLong.class).count());
+        PrimaryKeyAsLong first = realm.where(PrimaryKeyAsLong.class).findFirst();
+        assertNotNull(first);
+        assertEquals("Baz", first.getName());
+    }
+
+    @Test
+    public void insertOrUpdate_emptyList() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.insertOrUpdate(Collections.<PrimaryKeyAsLong>emptyList());
+            }
+        });
+        assertEquals(0, realm.where(PrimaryKeyAsLong.class).count());
+    }
+
+    /**
+     * added to reproduce https://github.com/realm/realm-java/issues/3103
+     */
+    @Test
+    public void insertOrUpdate_emptyListWithCompositeMediator() {
+        final RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .modules(new HumanModule(), new AnimalModule())
+                .name("composite.realm")
+                .build();
+        Realm.deleteRealm(config);
+
+        assertEquals(config.getSchemaMediator().getClass(), CompositeMediator.class);
+
+        final Realm realm = Realm.getInstance(config);
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            realm.executeTransaction(new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    realm.insertOrUpdate(Collections.<Cat>emptyList());
+                }
+            });
+            assertEquals(0, realm.where(Cat.class).count());
+        } finally {
+            realm.close();
+        }
+    }
+
+    /**
+     * added to reproduce https://github.com/realm/realm-java/issues/3103
+     */
+    @Test
+    public void insertOrUpdate_emptyListWithFilterableMediator() {
+        //noinspection unchecked
+        final RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .schema(CatOwner.class, Cat.class)
+                .name("filterable.realm")
+                .build();
+        Realm.deleteRealm(config);
+
+        assertEquals(config.getSchemaMediator().getClass(), FilterableMediator.class);
+
+        final Realm realm = Realm.getInstance(config);
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            realm.executeTransaction(new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    realm.insertOrUpdate(Collections.<Cat>emptyList());
+                }
+            });
+            assertEquals(0, realm.where(Cat.class).count());
+        } finally {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void insertOrUpdate_mixingPrimaryKeyAndNoPrimaryKeyModels() {
+        AllTypes objB_no_pk = new AllTypes();
+        objB_no_pk.setColumnString("B");
+
+        PrimaryKeyWithNoPrimaryKeyObjectRelation objA_pk = new PrimaryKeyWithNoPrimaryKeyObjectRelation();
+        objA_pk.setColumnString("A");
+        objA_pk.setColumnRealmObjectNoPK(objB_no_pk);
+
+        realm.beginTransaction();
+        realm.insert(objA_pk);
+        realm.commitTransaction();
+
+        RealmResults<PrimaryKeyWithNoPrimaryKeyObjectRelation> all = realm.where(PrimaryKeyWithNoPrimaryKeyObjectRelation.class).findAll();
+        assertEquals(1, all.size());
+        assertEquals("A", all.get(0).getColumnString());
+        assertEquals(8, all.get(0).getColumnInt());
+        assertNotNull(all.get(0).getColumnRealmObjectNoPK());
+        assertEquals("B", all.get(0).getColumnRealmObjectNoPK().getColumnString());
+        assertEquals(1, realm.where(AllTypes.class).findAll().size());
+
+        objA_pk.setColumnInt(42);
+        objB_no_pk.setColumnString("updated B");
+
+        realm.beginTransaction();
+        realm.insertOrUpdate(objA_pk);
+        realm.commitTransaction();
+
+        all = realm.where(PrimaryKeyWithNoPrimaryKeyObjectRelation.class).findAll();
+        assertEquals(1, all.size());
+        assertEquals("A", all.get(0).getColumnString());
+        assertEquals(42, all.get(0).getColumnInt());
+        assertNotNull(all.get(0).getColumnRealmObjectNoPK());
+        assertEquals("updated B", all.get(0).getColumnRealmObjectNoPK().getColumnString());
+        // since AllTypes doesn't have a PK we now have two instances
+        assertEquals(2, realm.where(AllTypes.class).findAll().size());
+    }
+
+
+    @Test
+    public void insertOrUpdate_mixingNoPrimaryKeyAndPrimaryKeyModels() {
+        AllTypesPrimaryKey objB_pk = new AllTypesPrimaryKey();
+        objB_pk.setColumnLong(7);
+        objB_pk.setColumnString("B");
+
+        NoPrimaryKeyWithPrimaryKeyObjectRelation objA_no_pk = new NoPrimaryKeyWithPrimaryKeyObjectRelation();
+        objA_no_pk.setColumnRealmObjectPK(objB_pk);
+        objA_no_pk.setColumnString("A");
+
+        realm.beginTransaction();
+        realm.insert(objA_no_pk);
+        realm.commitTransaction();
+
+        RealmResults<NoPrimaryKeyWithPrimaryKeyObjectRelation> all = realm.where(NoPrimaryKeyWithPrimaryKeyObjectRelation.class).findAll();
+        assertEquals(1, all.size());
+        assertEquals("A", all.get(0).getColumnString());
+        assertEquals(8, all.get(0).getColumnInt());
+        assertNotNull(all.get(0).getColumnRealmObjectPK());
+        assertEquals(7, all.get(0).getColumnRealmObjectPK().getColumnLong());
+        assertEquals("B", all.get(0).getColumnRealmObjectPK().getColumnString());
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).findAll().size());
+
+        objA_no_pk.setColumnString("different A");
+        objA_no_pk.setColumnInt(42);//should insert a new instance
+        // update (since it has a PK) now both AllTypesPrimaryKey points to the same objB_pk instance
+        objB_pk.setColumnString("updated B");
+
+        realm.beginTransaction();
+        realm.insertOrUpdate(objA_no_pk);
+        realm.commitTransaction();
+
+        all = realm.where(NoPrimaryKeyWithPrimaryKeyObjectRelation.class).findAllSorted("columnString");
+        assertEquals(2, all.size());
+        assertEquals("A", all.get(0).getColumnString());
+        assertEquals(8, all.get(0).getColumnInt());
+        assertEquals("different A", all.get(1).getColumnString());
+        assertEquals(42, all.get(1).getColumnInt());
+
+        assertNotNull(all.get(0).getColumnRealmObjectPK());
+        assertNotNull(all.get(1).getColumnRealmObjectPK());
+
+        assertEquals(7, all.get(0).getColumnRealmObjectPK().getColumnLong());
+        assertEquals(7, all.get(1).getColumnRealmObjectPK().getColumnLong());
+        assertEquals("updated B", all.get(0).getColumnRealmObjectPK().getColumnString());
+        assertEquals("updated B", all.get(1).getColumnRealmObjectPK().getColumnString());
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).findAll().size());
+    }
+
+    @Test
+    public void insertOrUpdate_mixingPrimaryAndNoPrimaryKeyList() {
+        NoPrimaryKeyWithPrimaryKeyObjectRelation objA_no_pk = new NoPrimaryKeyWithPrimaryKeyObjectRelation();
+        objA_no_pk.setColumnString("A");
+        NoPrimaryKeyWithPrimaryKeyObjectRelation objB_no_pk = new NoPrimaryKeyWithPrimaryKeyObjectRelation();
+        objB_no_pk.setColumnString("B");
+        AllTypesPrimaryKey objC_pk = new AllTypesPrimaryKey();
+        objC_pk.setColumnLong(7);
+        objC_pk.setColumnString("C");
+        AllTypesPrimaryKey objD_pk = new AllTypesPrimaryKey();
+        objD_pk.setColumnLong(7);
+        objD_pk.setColumnString("D");
+
+        objA_no_pk.setColumnRealmObjectPK(objC_pk);
+        objB_no_pk.setColumnRealmObjectPK(objD_pk);
+
+        ArrayList<NoPrimaryKeyWithPrimaryKeyObjectRelation> objects = new ArrayList<NoPrimaryKeyWithPrimaryKeyObjectRelation>(2);
+        objects.add(objA_no_pk);
+        objects.add(objB_no_pk);
+
+        realm.beginTransaction();
+        realm.insertOrUpdate(objects);
+        realm.commitTransaction();
+
+        RealmResults<NoPrimaryKeyWithPrimaryKeyObjectRelation> all = realm.where(NoPrimaryKeyWithPrimaryKeyObjectRelation.class).findAllSorted("columnString", Sort.DESCENDING);
+        assertEquals(2, all.size());
+        assertEquals("B", all.get(0).getColumnString());
+        assertEquals("A", all.get(1).getColumnString());
+
+        assertNotNull(all.get(0).getColumnRealmObjectPK());
+        assertNotNull(all.get(1).getColumnRealmObjectPK());
+
+        assertEquals("D", all.get(0).getColumnRealmObjectPK().getColumnString());
+        assertEquals("D", all.get(1).getColumnRealmObjectPK().getColumnString());
+
+        assertEquals(1, realm.where(AllTypesPrimaryKey.class).findAll().size());
+    }
+
+    //any omitted argument should not end in a SIGSEGV but an exception
+
+    @Test
+    public void insert_nullObject() {
+        AllTypes nullObject = null;
+
+        realm.beginTransaction();
+        try {
+            //noinspection ConstantConditions
+            realm.insert(nullObject);
+            fail("Should trigger NullPointerException");
+        } catch (IllegalArgumentException ignore) {
+
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void inset_nullList() {
+        List<AllTypes> nullObjects = null;
+
+        realm.beginTransaction();
+        try {
+            //noinspection ConstantConditions
+            realm.insert(nullObjects);
+            fail("Should trigger IllegalArgumentException");
+        } catch (IllegalArgumentException ignore) {
+
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void insert_listWithNullElement() {
+        Dog dog1 = new Dog();
+        dog1.setName("Dog 1");
+        Dog dog2 = new Dog();
+        dog2.setName("Dog 2");
+        ArrayList<Dog> list = new ArrayList<Dog>();
+        list.addAll(Arrays.asList(dog1, null, dog2));
+
+        realm.beginTransaction();
+        try {
+            realm.insert(list);
+            fail("Should trigger IllegalArgumentException");
+        } catch (NullPointerException ignore) {
+
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    //Inserting a managed object will result in it being copied or updated again
+    @Test
+    public void insertOrUpdate_managedObject() {
+        AllJavaTypes obj = new AllJavaTypes();
+        obj.setFieldId(42);
+        obj.setFieldIgnored("cookie");
+        obj.setFieldLong(42);
+        obj.setFieldString("obj1");
+
+        realm.beginTransaction();
+        AllJavaTypes managedAllJavaTypes = realm.copyToRealm(obj);
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+
+        AllJavaTypes filedObject = new AllJavaTypes();
+        filedObject.setFieldLong(8);
+        filedObject = realm.copyToRealm(filedObject);
+        managedAllJavaTypes.setFieldObject(filedObject);
+        managedAllJavaTypes.setFieldString("updated");
+
+        realm.insertOrUpdate(managedAllJavaTypes);
+        realm.commitTransaction();
+
+        AllJavaTypes first = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_LONG, 42).findFirst();
+        assertNotNull(first);
+        assertEquals(42, first.getFieldLong(), 0);
+        assertEquals("updated", first.getFieldString());
+        assertNull(first.getFieldIgnored());
+        assertNotNull(first.getFieldObject());
+        assertEquals(8, first.getFieldObject().getFieldLong());
+
+        assertEquals(2, realm.where(AllJavaTypes.class).findAll().size());
+    }
+
+    @Test
+    public void insertOrUpdate_linkingManagedToUnmanagedObject() {
+        realm.beginTransaction();
+        AllJavaTypes managedAllJavaTypes = realm.createObject(AllJavaTypes.class, 42);
+        realm.commitTransaction();
+
+        AllJavaTypes unmanagedObject = new AllJavaTypes(8);
+        unmanagedObject.setFieldObject(managedAllJavaTypes);//Linking managed object to unmanaged object
+
+        realm.beginTransaction();
+        realm.insertOrUpdate(unmanagedObject);
+        realm.commitTransaction();
+
+        AllJavaTypes first = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_ID, 8).findFirst();
+        assertNotNull(first);
+        assertEquals(8, first.getFieldId(), 0);
+        assertNotNull(first.getFieldObject());
+        assertEquals(42, first.getFieldObject().getFieldId());
+        assertEquals(2, realm.where(AllJavaTypes.class).count());
+    }
+
+    @Test
+    public void insertManagedObjectWillNotDuplicate() {
+        realm.beginTransaction();
+        Dog managedRealmObject = realm.createObject(Dog.class);
+        managedRealmObject.setName("dog1");
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+        realm.insert(managedRealmObject);
+        realm.commitTransaction();
+
+        assertEquals(1, realm.where(Dog.class).count());
+    }
+
+    @Test
+    public void insertOrUpdate_collectionOfManagedObjects() {
+        realm.beginTransaction();
+        AllTypesPrimaryKey allTypes = realm.createObject(AllTypesPrimaryKey.class, 0);
+        allTypes.getColumnRealmList().add(realm.createObject(DogPrimaryKey.class, 0));
+        realm.commitTransaction();
+        assertEquals(1, allTypes.getColumnRealmList().size());
+
+        List<AllTypesPrimaryKey>  list = new ArrayList<AllTypesPrimaryKey>();
+        // Although there are two same objects in the list, none of them should be saved to the db since they are managed
+        // already.
+        list.add(allTypes);
+        list.add(allTypes);
+
+        realm.beginTransaction();
+        realm.insertOrUpdate(list);
+        realm.commitTransaction();
+        allTypes = realm.where(AllTypesPrimaryKey.class).findFirst();
+        assertNotNull(allTypes);
+        assertEquals(1, allTypes.getColumnRealmList().size());
+    }
+
+    // To reproduce https://github.com/realm/realm-java/issues/3105
+    @Test
+    public void insertOrUpdate_shouldNotClearRealmList() {
+        realm.beginTransaction();
+        AllTypesPrimaryKey allTypes = realm.createObject(AllTypesPrimaryKey.class, 0);
+        allTypes.getColumnRealmList().add(realm.createObject(DogPrimaryKey.class, 0));
+        realm.commitTransaction();
+        assertEquals(1, allTypes.getColumnRealmList().size());
+
+        realm.beginTransaction();
+        realm.insertOrUpdate(allTypes);
+        realm.commitTransaction();
+        allTypes = realm.where(AllTypesPrimaryKey.class).findFirst();
+        assertNotNull(allTypes);
+        assertEquals(1, allTypes.getColumnRealmList().size());
+    }
+
+    @Test
+    public void insert_collectionOfManagedObjects() {
+        realm.beginTransaction();
+        AllTypes allTypes = realm.createObject(AllTypes.class);
+        allTypes.getColumnRealmList().add(realm.createObject(Dog.class));
+        realm.commitTransaction();
+        assertEquals(1, allTypes.getColumnRealmList().size());
+
+        List<AllTypes>  list = new ArrayList<AllTypes>();
+        // Although there are two same objects in the list, none of them should be saved to the db since they are managed
+        // already.
+        list.add(allTypes);
+        list.add(allTypes);
+
+        realm.beginTransaction();
+        realm.insert(list);
+        realm.commitTransaction();
+        assertEquals(1, realm.where(AllTypes.class).count());
+        allTypes = realm.where(AllTypes.class).findFirst();
+        assertNotNull(allTypes);
+        assertEquals(1, allTypes.getColumnRealmList().size());
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void insert_collection_notInTransaction() {
+        realm.insert(Arrays.asList(new AllTypes(), new AllTypes()));
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void insert_object_notInTransaction() {
+        realm.insert(new AllTypes());
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void insertOrUpdate_collection_notInTransaction() {
+        realm.insert(Arrays.asList(new AllTypesPrimaryKey(), new AllTypesPrimaryKey()));
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void insertOrUpdate_object_notInTransaction() {
+        realm.insert(new AllTypes());
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
index d147fd591a..1ef8aad27b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
@@ -49,7 +49,7 @@
 
     // Enumerate all methods from the RealmCollection interface that depend on Realm API's.
     protected enum RealmCollectionMethod {
-        WHERE, MIN, MAX, SUM, AVERAGE, MIN_DATE, MAX_DATE, DELETE_ALL_FROM_REALM, IS_VALID
+        WHERE, MIN, MAX, SUM, AVERAGE, MIN_DATE, MAX_DATE, DELETE_ALL_FROM_REALM, IS_VALID, IS_MANAGED
     }
 
     // Enumerate all methods from the Collection interface
@@ -94,8 +94,8 @@ protected void populateRealm(Realm realm, int objects) {
             }
 
             // Add all items to the RealmList on the first object
-            AllJavaTypes firstObj = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_LONG, 0).findFirst();
-            RealmResults<AllJavaTypes> listData = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+            AllJavaTypes firstObj = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_ID, 0).findFirst();
+            RealmResults<AllJavaTypes> listData = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_ID, Sort.ASCENDING);
             RealmList<AllJavaTypes> list = firstObj.getFieldList();
             for (int i = 0; i < listData.size(); i++) {
                 list.add(listData.get(i));
@@ -200,7 +200,7 @@ protected void populatePartialNullRowsForNumericTesting(Realm realm) {
                 return realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_STRING);
 
             case MANAGED_REALMLIST:
-                AllJavaTypes first = realm.createObject(AllJavaTypes.class);
+                AllJavaTypes first = realm.createObject(AllJavaTypes.class, 0);
                 first.setFieldString(args[0]);
                 first.getFieldList().add(first);
                 for (int i = 1; i < args.length; i++) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java b/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java
new file mode 100644
index 0000000000..0205aa80ce
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import android.support.annotation.NonNull;
+import android.support.test.runner.AndroidJUnit4;
+
+import com.google.common.collect.ImmutableMap;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import io.realm.entities.Cat;
+import io.realm.entities.Dog;
+import io.realm.internal.ColumnIndices;
+import io.realm.internal.ColumnInfo;
+import io.realm.internal.RealmProxyMediator;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertNotSame;
+import static junit.framework.Assert.assertSame;
+import static org.junit.Assert.assertNotEquals;
+
+@RunWith(AndroidJUnit4.class)
+public class ColumnIndicesTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private Realm realm;
+    private RealmProxyMediator mediator;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration config = configFactory.createConfiguration();
+        realm = Realm.getInstance(config);
+        mediator = config.getSchemaMediator();
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    @NonNull
+    private ColumnIndices create(long schemaVersion) {
+        final CatRealmProxy.CatColumnInfo catColumnInfo;
+        final DogRealmProxy.DogColumnInfo dogColumnInfo;
+        catColumnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+        dogColumnInfo = (DogRealmProxy.DogColumnInfo) mediator.validateTable(Dog.class, realm.sharedRealm, false);
+
+        return new ColumnIndices(schemaVersion,
+                ImmutableMap.<Class<? extends RealmModel>, ColumnInfo>of(
+                        Cat.class, catColumnInfo,
+                        Dog.class, dogColumnInfo));
+    }
+
+    @Test
+    public void copyDeeply() {
+        final long schemaVersion = 100;
+
+        final ColumnIndices columnIndices = create(schemaVersion);
+        final ColumnIndices deepCopy = columnIndices.clone();
+
+        assertEquals(schemaVersion, deepCopy.getSchemaVersion());
+        assertEquals(columnIndices.getColumnIndex(Cat.class, Cat.FIELD_NAME),
+                deepCopy.getColumnIndex(Cat.class, Cat.FIELD_NAME));
+        assertEquals(columnIndices.getColumnIndex(Dog.class, Dog.FIELD_AGE),
+                deepCopy.getColumnIndex(Dog.class, Dog.FIELD_AGE));
+
+        // check if those are different instance.
+        assertNotSame(columnIndices, deepCopy);
+        assertNotSame(columnIndices.getColumnInfo(Cat.class), deepCopy.getColumnInfo(Cat.class));
+        assertNotSame(columnIndices.getColumnInfo(Dog.class), deepCopy.getColumnInfo(Dog.class));
+    }
+
+    @Test
+    public void copyFrom() {
+        final long sourceSchemaVersion = 101;
+        final long targetSchemaVersion = 100;
+
+        final ColumnIndices source = create(sourceSchemaVersion);
+        final ColumnIndices target = create(targetSchemaVersion);
+
+        final CatRealmProxy.CatColumnInfo catColumnInfoInSource = (CatRealmProxy.CatColumnInfo) source.getColumnInfo(Cat.class);
+        final CatRealmProxy.CatColumnInfo catColumnInfoInTarget = (CatRealmProxy.CatColumnInfo) target.getColumnInfo(Cat.class);
+
+        catColumnInfoInSource.nameIndex++;
+
+        // check preconditions
+        assertNotEquals(catColumnInfoInSource.nameIndex, catColumnInfoInTarget.nameIndex);
+        assertNotSame(catColumnInfoInSource.getIndicesMap(), catColumnInfoInTarget.getIndicesMap());
+
+        target.copyFrom(source,  mediator);
+
+        assertEquals(sourceSchemaVersion, target.getSchemaVersion());
+        assertEquals(catColumnInfoInSource.nameIndex, catColumnInfoInTarget.nameIndex);
+        assertSame(catColumnInfoInSource.getIndicesMap(), catColumnInfoInTarget.getIndicesMap());
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java b/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java
new file mode 100644
index 0000000000..ae20b233a3
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import io.realm.entities.Cat;
+import io.realm.internal.RealmProxyMediator;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertNotSame;
+import static junit.framework.Assert.assertSame;
+
+@RunWith(AndroidJUnit4.class)
+public class ColumnInfoTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private Realm realm;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration config = configFactory.createConfiguration();
+        realm = Realm.getInstance(config);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void copyColumnInfoFrom_checkIndex() {
+        final RealmProxyMediator mediator = realm.getConfiguration().getSchemaMediator();
+        final CatRealmProxy.CatColumnInfo sourceColumnInfo, targetColumnInfo;
+        sourceColumnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+        targetColumnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+
+        // check precondition
+        assertNotSame(sourceColumnInfo, targetColumnInfo);
+        assertNotSame(sourceColumnInfo.getIndicesMap(), targetColumnInfo.getIndicesMap());
+
+        sourceColumnInfo.nameIndex = 1;
+        sourceColumnInfo.ageIndex = 2;
+        sourceColumnInfo.heightIndex = 3;
+        sourceColumnInfo.weightIndex = 4;
+        sourceColumnInfo.hasTailIndex = 5;
+        sourceColumnInfo.birthdayIndex = 6;
+        sourceColumnInfo.ownerIndex = 7;
+        sourceColumnInfo.scaredOfDogIndex = 8;
+
+        targetColumnInfo.nameIndex = 0;
+        targetColumnInfo.ageIndex = 0;
+        targetColumnInfo.heightIndex = 0;
+        targetColumnInfo.weightIndex = 0;
+        targetColumnInfo.hasTailIndex = 0;
+        targetColumnInfo.birthdayIndex = 0;
+        targetColumnInfo.ownerIndex = 0;
+        targetColumnInfo.scaredOfDogIndex = 0;
+
+        targetColumnInfo.copyColumnInfoFrom(sourceColumnInfo);
+
+        assertEquals(1, targetColumnInfo.nameIndex);
+        assertEquals(2, targetColumnInfo.ageIndex);
+        assertEquals(3, targetColumnInfo.heightIndex);
+        assertEquals(4, targetColumnInfo.weightIndex);
+        assertEquals(5, targetColumnInfo.hasTailIndex);
+        assertEquals(6, targetColumnInfo.birthdayIndex);
+        assertEquals(7, targetColumnInfo.ownerIndex);
+        assertEquals(8, targetColumnInfo.scaredOfDogIndex);
+
+        // current implementation shares the indices map.
+        assertSame(sourceColumnInfo.getIndicesMap(), targetColumnInfo.getIndicesMap());
+    }
+
+    @Test
+    public void clone_hasSameValue() {
+        final RealmProxyMediator mediator = realm.getConfiguration().getSchemaMediator();
+        final CatRealmProxy.CatColumnInfo columnInfo;
+        columnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+
+        columnInfo.nameIndex = 1;
+        columnInfo.ageIndex = 2;
+        columnInfo.heightIndex = 3;
+        columnInfo.weightIndex = 4;
+        columnInfo.hasTailIndex = 5;
+        columnInfo.birthdayIndex = 6;
+        columnInfo.ownerIndex = 7;
+        columnInfo.scaredOfDogIndex = 8;
+
+        CatRealmProxy.CatColumnInfo copy = columnInfo.clone();
+
+        // modify original object
+        columnInfo.nameIndex = 0;
+        columnInfo.ageIndex = 0;
+        columnInfo.heightIndex = 0;
+        columnInfo.weightIndex = 0;
+        columnInfo.hasTailIndex = 0;
+        columnInfo.birthdayIndex = 0;
+        columnInfo.ownerIndex = 0;
+        columnInfo.scaredOfDogIndex = 0;
+
+        assertNotSame(columnInfo, copy);
+
+        assertEquals(1, copy.nameIndex);
+        assertEquals(2, copy.ageIndex);
+        assertEquals(3, copy.heightIndex);
+        assertEquals(4, copy.weightIndex);
+        assertEquals(5, copy.hasTailIndex);
+        assertEquals(6, copy.birthdayIndex);
+        assertEquals(7, copy.ownerIndex);
+        assertEquals(8, copy.scaredOfDogIndex);
+
+        // current implementation shares the indices map between copies.
+        assertSame(columnInfo.getIndicesMap(), copy.getIndicesMap());
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
index f0b3cbec91..14c9e278bb 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
@@ -37,6 +37,15 @@
 import io.realm.entities.Dog;
 import io.realm.entities.NullTypes;
 import io.realm.entities.Owner;
+import io.realm.entities.PrimaryKeyAsBoxedByte;
+import io.realm.entities.PrimaryKeyAsBoxedInteger;
+import io.realm.entities.PrimaryKeyAsBoxedLong;
+import io.realm.entities.PrimaryKeyAsBoxedShort;
+import io.realm.entities.PrimaryKeyAsByte;
+import io.realm.entities.PrimaryKeyAsInteger;
+import io.realm.entities.PrimaryKeyAsLong;
+import io.realm.entities.PrimaryKeyAsShort;
+import io.realm.entities.PrimaryKeyAsString;
 import io.realm.exceptions.RealmException;
 import io.realm.rule.TestRealmConfigurationFactory;
 
@@ -68,7 +77,7 @@ public void setUp() {
         RealmConfiguration realmConfig = configFactory.createConfiguration();
         realm = Realm.getInstance(realmConfig);
         realm.beginTransaction();
-        typedObj = realm.createObject(AllJavaTypes.class);
+        typedObj = realm.createObject(AllJavaTypes.class, 1);
         typedObj.setFieldString("str");
         typedObj.setFieldShort((short) 1);
         typedObj.setFieldInt(1);
@@ -122,6 +131,11 @@ public void constructor_deletedObjectThrows() {
         new DynamicRealmObject(typedObj);
     }
 
+    @Test (expected = IllegalArgumentException.class)
+    public void constructor_unmanagedObjectThrows() {
+        new DynamicRealmObject(new AllTypes());
+    }
+
     // Test that all getters fail if given invalid field name
     @Test
     public void typedGetter_illegalFieldNameThrows() {
@@ -144,6 +158,22 @@ public void typedGetter_illegalFieldNameThrows() {
         }
     }
 
+    @Test
+    public void typedGetter_wrongUnderlyingTypeThrows() {
+        for (SupportedType type : SupportedType.values()) {
+            try {
+                // Make sure we hit the wrong underlying type for all types.
+                if (type == SupportedType.DOUBLE) {
+                    callGetter(type, Arrays.asList(AllJavaTypes.FIELD_STRING));
+                } else {
+                    callGetter(type, Arrays.asList(AllJavaTypes.FIELD_DOUBLE));
+                }
+                fail(type + " failed to throw.");
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
     // Helper method for calling getters with different field names
     private void callGetter(SupportedType type, List<String> fieldNames) {
         for (String fieldName : fieldNames) {
@@ -186,6 +216,69 @@ public void typedSetter_illegalFieldNameThrows() {
         }
     }
 
+    @Test
+    public void typedSetter_wrongUnderlyingTypeThrows() {
+        for (SupportedType type : SupportedType.values()) {
+            realm.beginTransaction();
+            try {
+                // Make sure we hit the wrong underlying type for all types.
+                if (type == SupportedType.STRING) {
+                    callSetter(type, Arrays.asList(AllJavaTypes.FIELD_BOOLEAN));
+                } else {
+                    callSetter(type, Arrays.asList(AllJavaTypes.FIELD_STRING));
+                }
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            } finally {
+                realm.cancelTransaction();
+            }
+        }
+    }
+
+    private void callSetterOnPrimaryKey(String className, DynamicRealmObject object) {
+        switch (className) {
+            case PrimaryKeyAsByte.CLASS_NAME:
+                object.setByte(PrimaryKeyAsByte.FIELD_ID, (byte) 42);
+                break;
+            case PrimaryKeyAsShort.CLASS_NAME:
+                object.setShort(PrimaryKeyAsShort.FIELD_ID, (short) 42);
+                break;
+            case PrimaryKeyAsInteger.CLASS_NAME:
+                object.setInt(PrimaryKeyAsInteger.FIELD_ID, 42);
+                break;
+            case PrimaryKeyAsLong.CLASS_NAME:
+                object.setLong(PrimaryKeyAsLong.FIELD_ID, 42);
+                break;
+            case PrimaryKeyAsString.CLASS_NAME:
+                object.setString(PrimaryKeyAsString.FIELD_PRIMARY_KEY, "42");
+                break;
+            default:
+                fail();
+        }
+    }
+
+    @Test
+    public void typedSetter_changePrimaryKeyThrows() {
+        final String[] primaryKeyClasses = {PrimaryKeyAsByte.CLASS_NAME, PrimaryKeyAsShort.CLASS_NAME,
+                PrimaryKeyAsInteger.CLASS_NAME, PrimaryKeyAsLong.CLASS_NAME, PrimaryKeyAsString.CLASS_NAME};
+        for (String pkClass : primaryKeyClasses) {
+            dynamicRealm.beginTransaction();
+            DynamicRealmObject object;
+            if (pkClass.equals(PrimaryKeyAsString.CLASS_NAME)) {
+                object = dynamicRealm.createObject(pkClass, "");
+            } else {
+                object = dynamicRealm.createObject(pkClass, 0);
+            }
+
+            try {
+                callSetterOnPrimaryKey(pkClass, object);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+            dynamicRealm.cancelTransaction();
+        }
+    }
+
     // Helper method for calling setters with different field names
     private void callSetter(SupportedType type, List<String> fieldNames) {
         for (String fieldName : fieldNames) {
@@ -212,7 +305,7 @@ private void callSetter(SupportedType type, List<String> fieldNames) {
     @Test
     public void typedGettersAndSetters() {
         realm.beginTransaction();
-        AllJavaTypes obj = realm.createObject(AllJavaTypes.class);
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class, 0);
         DynamicRealmObject dObj = new DynamicRealmObject(obj);
         try {
             for (SupportedType type : SupportedType.values()) {
@@ -276,7 +369,7 @@ public void typedGettersAndSetters() {
     @Test
     public void setter_null() {
         realm.beginTransaction();
-        NullTypes obj = realm.createObject(NullTypes.class);
+        NullTypes obj = realm.createObject(NullTypes.class, 0);
         DynamicRealmObject dObj = new DynamicRealmObject(obj);
         try {
             for (SupportedType type : SupportedType.values()) {
@@ -349,7 +442,7 @@ public void setter_null() {
     @Test
     public void setter_nullOnRequiredFieldsThrows() {
         realm.beginTransaction();
-        NullTypes obj = realm.createObject(NullTypes.class);
+        NullTypes obj = realm.createObject(NullTypes.class, 0);
         DynamicRealmObject dObj = new DynamicRealmObject(obj);
         try {
             for (SupportedType type : SupportedType.values()) {
@@ -383,7 +476,7 @@ public void setter_nullOnRequiredFieldsThrows() {
     @Test
     public void typedSetter_null() {
         realm.beginTransaction();
-        NullTypes obj = realm.createObject(NullTypes.class);
+        NullTypes obj = realm.createObject(NullTypes.class, 0);
         DynamicRealmObject dObj = new DynamicRealmObject(obj);
         try {
             for (SupportedType type : SupportedType.values()) {
@@ -426,6 +519,29 @@ public void typedSetter_null() {
         }
     }
 
+    @Test
+    public void setNull_changePrimaryKeyThrows() {
+        final String[] primaryKeyClasses = {PrimaryKeyAsBoxedByte.CLASS_NAME, PrimaryKeyAsBoxedShort.CLASS_NAME,
+                PrimaryKeyAsBoxedInteger.CLASS_NAME, PrimaryKeyAsBoxedLong.CLASS_NAME, PrimaryKeyAsString.CLASS_NAME};
+        for (String pkClass : primaryKeyClasses) {
+            dynamicRealm.beginTransaction();
+            DynamicRealmObject object;
+            boolean isStringPK = pkClass.equals(PrimaryKeyAsString.CLASS_NAME);
+            if (isStringPK) {
+                object = dynamicRealm.createObject(pkClass, "");
+            } else {
+                object = dynamicRealm.createObject(pkClass, 0);
+            }
+
+            try {
+                object.setNull(isStringPK ? PrimaryKeyAsString.FIELD_PRIMARY_KEY : "id");
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+            dynamicRealm.cancelTransaction();
+        }
+    }
+
     @Test
     public void setObject_differentType() {
         realm.beginTransaction();
@@ -443,7 +559,7 @@ public void setObject_differentType() {
     @Test
     public void setObject_wrongTypeThrows() {
         realm.beginTransaction();
-        AllJavaTypes obj = realm.createObject(AllJavaTypes.class);
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class, 0);
         Dog otherObj = realm.createObject(Dog.class);
         DynamicRealmObject dynamicObj = new DynamicRealmObject(obj);
         DynamicRealmObject dynamicWrongType = new DynamicRealmObject(otherObj);
@@ -576,8 +692,7 @@ public void untypedSetter_listWrongTypeThrows() {
     @Test
     public void untypedSetter_listMixedTypesThrows() {
         realm.beginTransaction();
-        AllJavaTypes obj1 = realm.createObject(AllJavaTypes.class);
-        obj1.setFieldLong(2);
+        AllJavaTypes obj1 = realm.createObject(AllJavaTypes.class, 2);
         CyclicType obj2 = realm.createObject(CyclicType.class);
 
         RealmList<DynamicRealmObject> list = new RealmList<DynamicRealmObject>();
@@ -609,7 +724,7 @@ public void getList() {
     @Test
     public void untypedGetterSetter() {
         realm.beginTransaction();
-        AllJavaTypes obj = realm.createObject(AllJavaTypes.class);
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class, 0);
         DynamicRealmObject dObj = new DynamicRealmObject(obj);
         try {
             for (SupportedType type : SupportedType.values()) {
@@ -678,7 +793,7 @@ public void untypedGetterSetter() {
     @Test
     public void untypedSetter_usingStringConversion() {
         realm.beginTransaction();
-        AllJavaTypes obj = realm.createObject(AllJavaTypes.class);
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class, 0);
         DynamicRealmObject dObj = new DynamicRealmObject(obj);
         try {
             for (SupportedType type : SupportedType.values()) {
@@ -732,7 +847,7 @@ public void untypedSetter_usingStringConversion() {
     @Test
     public void untypedSetter_illegalImplicitConversionThrows() {
         realm.beginTransaction();
-        AllJavaTypes obj = realm.createObject(AllJavaTypes.class);
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class, 0);
         DynamicRealmObject dObj = new DynamicRealmObject(obj);
         try {
             for (SupportedType type : SupportedType.values()) {
@@ -745,7 +860,7 @@ public void untypedSetter_illegalImplicitConversionThrows() {
                             dObj.set(AllJavaTypes.FIELD_INT, "foo");
                             break;
                         case LONG:
-                            dObj.set(AllJavaTypes.FIELD_LONG, "foo");
+                            dObj.set(AllJavaTypes.FIELD_ID, "foo");
                             break;
                         case FLOAT:
                             dObj.set(AllJavaTypes.FIELD_FLOAT, "foo");
@@ -784,6 +899,38 @@ public void untypedSetter_illegalImplicitConversionThrows() {
         }
     }
 
+    private void testChangePrimaryKeyThroughUntypedSetter(String value) {
+        final String[] primaryKeyClasses = {PrimaryKeyAsBoxedByte.CLASS_NAME, PrimaryKeyAsBoxedShort.CLASS_NAME,
+                PrimaryKeyAsBoxedInteger.CLASS_NAME, PrimaryKeyAsBoxedLong.CLASS_NAME, PrimaryKeyAsString.CLASS_NAME};
+        for (String pkClass : primaryKeyClasses) {
+            dynamicRealm.beginTransaction();
+            DynamicRealmObject object;
+            boolean isStringPK = pkClass.equals(PrimaryKeyAsString.CLASS_NAME);
+            if (isStringPK) {
+                object = dynamicRealm.createObject(pkClass, "");
+            } else {
+                object = dynamicRealm.createObject(pkClass, 0);
+            }
+
+            try {
+                object.set(isStringPK ? PrimaryKeyAsString.FIELD_PRIMARY_KEY : "id", value);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+            dynamicRealm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void untypedSetter_setValue_changePrimaryKeyThrows() {
+        testChangePrimaryKeyThroughUntypedSetter("42");
+    }
+
+    @Test
+    public void untypedSetter_setNull_changePrimaryKeyThrows() {
+        testChangePrimaryKeyThroughUntypedSetter(null);
+    }
+
     @Test
     public void isNull_nullNotSupportedField() {
         assertFalse(dObjTyped.isNull(AllJavaTypes.FIELD_INT));
@@ -792,7 +939,7 @@ public void isNull_nullNotSupportedField() {
     @Test
     public void isNull_true() {
         realm.beginTransaction();
-        AllJavaTypes obj = realm.createObject(AllJavaTypes.class);
+        AllJavaTypes obj = realm.createObject(AllJavaTypes.class, 0);
         realm.commitTransaction();
 
         assertTrue(new DynamicRealmObject(obj).isNull(AllJavaTypes.FIELD_OBJECT));
@@ -805,10 +952,10 @@ public void isNull_false() {
 
     @Test
     public void getFieldNames() {
-        String[] expectedKeys = {AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_SHORT, AllJavaTypes.FIELD_INT,
-                AllJavaTypes.FIELD_LONG, AllJavaTypes.FIELD_BYTE, AllJavaTypes.FIELD_FLOAT, AllJavaTypes.FIELD_DOUBLE,
-                AllJavaTypes.FIELD_BOOLEAN, AllJavaTypes.FIELD_DATE, AllJavaTypes.FIELD_BINARY,
-                AllJavaTypes.FIELD_OBJECT, AllJavaTypes.FIELD_LIST};
+        String[] expectedKeys = {AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_ID, AllJavaTypes.FIELD_LONG,
+                AllJavaTypes.FIELD_SHORT, AllJavaTypes.FIELD_INT, AllJavaTypes.FIELD_BYTE, AllJavaTypes.FIELD_FLOAT,
+                AllJavaTypes.FIELD_DOUBLE, AllJavaTypes.FIELD_BOOLEAN, AllJavaTypes.FIELD_DATE,
+                AllJavaTypes.FIELD_BINARY, AllJavaTypes.FIELD_OBJECT, AllJavaTypes.FIELD_LIST};
         String[] keys = dObjTyped.getFieldNames();
         assertArrayEquals(expectedKeys, keys);
     }
@@ -878,7 +1025,7 @@ public void toString_test() {
     @Test
     public void toString_nullValues() {
         dynamicRealm.beginTransaction();
-        final DynamicRealmObject obj = dynamicRealm.createObject(NullTypes.CLASS_NAME);
+        final DynamicRealmObject obj = dynamicRealm.createObject(NullTypes.CLASS_NAME, 0);
         dynamicRealm.commitTransaction();
 
         String str = obj.toString();
@@ -896,6 +1043,7 @@ public void toString_nullValues() {
         assertTrue(str.contains(NullTypes.FIELD_LIST_NULL + ":RealmList<NullTypes>[0]"));
     }
 
+
     public void testExceptionMessage() {
         // test for https://github.com/realm/realm-java/issues/2141
         realm.beginTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
index aaa191cd70..9821c20c12 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
@@ -23,6 +23,7 @@
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
 import java.util.Date;
@@ -39,7 +40,9 @@
 import io.realm.entities.PrimaryKeyAsBoxedLong;
 import io.realm.entities.PrimaryKeyAsBoxedShort;
 import io.realm.entities.PrimaryKeyAsString;
-import io.realm.internal.log.RealmLog;
+import io.realm.exceptions.RealmException;
+import io.realm.internal.HandlerControllerConstants;
+import io.realm.log.RealmLog;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -58,6 +61,9 @@
     @Rule
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
 
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
     private RealmConfiguration defaultConfig;
     private DynamicRealm realm;
 
@@ -228,6 +234,12 @@ public void createObject_illegalPrimaryKeyValue() {
         realm.createObject(DogPrimaryKey.CLASS_NAME, "bar");
     }
 
+    @Test(expected = RealmException.class)
+    public void createObject_absentPrimaryKeyThrows() {
+        realm.beginTransaction();
+        realm.createObject(DogPrimaryKey.CLASS_NAME);
+    }
+
     @Test
     public void where() {
         realm.beginTransaction();
@@ -337,6 +349,7 @@ public void findFirstAsync() {
                 .between(AllTypes.FIELD_LONG, 4, 9)
                 .findFirstAsync();
         assertFalse(allTypes.isLoaded());
+        looperThread.keepStrongReference.add(allTypes);
         allTypes.addChangeListener(new RealmChangeListener<DynamicRealmObject>() {
             @Override
             public void onChange(DynamicRealmObject object) {
@@ -395,11 +408,12 @@ public void onChange(RealmResults<DynamicRealmObject> object) {
         });
     }
 
-    // Initialize a Dynamic Realm used by the *Async tests.
+    // Initialize a Dynamic Realm used by the *Async tests and keep it ref in the looperThread.
     private DynamicRealm initializeDynamicRealm() {
         RealmConfiguration defaultConfig = looperThread.realmConfiguration;
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(defaultConfig);
         populateTestRealm(dynamicRealm, 10);
+        looperThread.keepStrongReference.add(dynamicRealm);
         return dynamicRealm;
     }
 
@@ -521,7 +535,7 @@ public void accessingDynamicRealmObjectBeforeAsyncQueryCompleted() {
             @Override
             public boolean onInterceptInMessage(int what) {
                 switch (what) {
-                    case HandlerController.COMPLETED_ASYNC_REALM_OBJECT: {
+                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_OBJECT: {
                         post(new Runnable() {
                             @Override
                             public void run() {
@@ -661,4 +675,18 @@ public void run() throws Exception {
             }
         });
     }
+
+    @Test
+    public void equalTo_noFieldObjectShouldThrow() {
+        final String className = "NoField";
+        RealmConfiguration emptyConfig = configFactory.createConfiguration("empty");
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(emptyConfig);
+        dynamicRealm.beginTransaction();
+        dynamicRealm.getSchema().create(className);
+        dynamicRealm.commitTransaction();
+
+        thrown.expect(IllegalArgumentException.class);
+        thrown.expectMessage("Field 'nonExisting' does not exist.");
+        dynamicRealm.where(className).equalTo("nonExisting", 1);
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
index bca324f3cc..c903d110c7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
@@ -170,7 +170,7 @@ public void tearDown() {
         switch (collectionClass) {
             case MANAGED_REALMLIST:
                 realm.beginTransaction();
-                NullTypes obj = realm.createObject(NullTypes.class);
+                NullTypes obj = realm.createObject(NullTypes.class, 0);
                 realm.commitTransaction();
                 return obj.getFieldListNull();
 
@@ -470,7 +470,7 @@ public void sort_usingChildObject() {
     public void sort_nullArguments() {
         OrderedRealmCollection<AllJavaTypes> result = collection;
         try {
-            result.sort(null);
+            result.sort((String) null);
             fail("Sorting with a null field name should throw an IllegalArgumentException");
         } catch (IllegalArgumentException ignored) {
         }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
index 0812e5f972..0c40da4b90 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
@@ -139,7 +139,7 @@ public void tearDown() {
         switch (collectionClass) {
             case MANAGED_REALMLIST:
                 realm.beginTransaction();
-                NullTypes obj = realm.createObject(NullTypes.class);
+                NullTypes obj = realm.createObject(NullTypes.class, 0);
                 realm.commitTransaction();
                 return obj.getFieldListNull();
 
@@ -522,6 +522,7 @@ public void realmMethods_invalidFieldNames() {
                         case WHERE:
                         case DELETE_ALL_FROM_REALM:
                         case IS_VALID:
+                        case IS_MANAGED:
                             continue;
 
                         default:
@@ -553,6 +554,7 @@ public void realmMethods_invalidFieldType() {
                     case WHERE:
                     case DELETE_ALL_FROM_REALM:
                     case IS_VALID:
+                    case IS_MANAGED:
                         continue;
 
                     default:
@@ -636,6 +638,11 @@ public void isValid_realmClosed() {
         assertFalse(collection.isValid());
     }
 
+    @Test
+    public void isManaged() {
+        assertTrue(collection.isManaged());
+    }
+
     @Test
     public void contains_deletedRealmObject() {
         AllJavaTypes obj = collection.iterator().next();
@@ -717,6 +724,7 @@ public Boolean call() throws Exception {
                         case MAX_DATE: collection.maxDate(AllJavaTypes.FIELD_DATE); break;
                         case DELETE_ALL_FROM_REALM: collection.deleteAllFromRealm(); break;
                         case IS_VALID: collection.isValid(); break;
+                        case IS_MANAGED: collection.isManaged(); return true;
                     }
                     return false;
                 } catch (IllegalStateException ignored) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
index 1fb67510d6..90625fc4f8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
@@ -28,14 +28,13 @@
 
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
 import java.lang.ref.WeakReference;
-import java.util.Map;
 import java.util.concurrent.Callable;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
@@ -48,8 +47,8 @@
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.Dog;
-import io.realm.internal.log.Logger;
-import io.realm.internal.log.RealmLog;
+import io.realm.log.Logger;
+import io.realm.log.RealmLog;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -81,6 +80,7 @@ public void setUp() {
 
     @After
     public void tearDown() {
+        Realm.asyncTaskExecutor.resume();
         if (realm != null) {
             realm.close();
         }
@@ -246,86 +246,6 @@ public Boolean call() throws Exception {
         RealmCache.invokeWithGlobalRefCount(realmConfig, new TestHelper.ExpectedCountCallback(0));
     }
 
-    // @Test
-    // FIXME: This test is being replaced by https://github.com/realm/realm-java/pull/2319/files
-    public void realmResultsStableDuringLooperEvent() throws InterruptedException, ExecutionException {
-        final int TEST_SIZE = 10;
-        final AtomicInteger counter = new AtomicInteger(0);
-        final AtomicBoolean isReady = new AtomicBoolean(false);
-        final AtomicBoolean isRealmOpen = new AtomicBoolean(true);
-        final Map<Integer, Integer> results = new ConcurrentHashMap<Integer, Integer>();
-        final Looper[] looper = new Looper[1];
-        final RealmChangeListener<Realm> listener[] = new RealmChangeListener[1];
-
-        ExecutorService executorService = Executors.newSingleThreadExecutor();
-        Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
-
-            @Override
-            public Boolean call() throws Exception {
-                Looper.prepare();
-                looper[0] = Looper.myLooper();
-                Realm realm = null;
-                try {
-                    realm = Realm.getInstance(realmConfig);
-                    final RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
-                    assertEquals(0, dogs.size());
-                    listener[0] = new RealmChangeListener<Realm>() {
-                        @Override
-                        public void onChange(Realm object) {
-                            int c = counter.incrementAndGet();
-                            results.put(c, dogs.size());
-                        }
-                    };
-                    realm.addChangeListener(listener[0]);
-                    isReady.set(true);
-                    Looper.loop();
-                } finally {
-                    if (realm != null) {
-                        realm.close();
-                        isRealmOpen.set(false);
-                    }
-                }
-                return true;
-            }
-        });
-
-        // Wait until the looper is started
-        while (!isReady.get()) {
-            Thread.sleep(5);
-        }
-        Thread.sleep(100);
-
-        Realm realm = Realm.getInstance(realmConfig);
-        realm.beginTransaction();
-        for (int i = 0; i < TEST_SIZE; i++) {
-            Dog dog = realm.createObject(Dog.class);
-            dog.setName("Rex " + i);
-        }
-        realm.commitTransaction();
-        assertEquals(TEST_SIZE, realm.where(Dog.class).count());
-        realm.close();
-
-        try {
-            future.get(2, TimeUnit.SECONDS);
-        } catch (TimeoutException ignore) {
-        } finally {
-            looper[0].quit();
-        }
-
-        // Wait until the Looper thread is actually closed
-        while (isRealmOpen.get()) {
-            Thread.sleep(5);
-        }
-
-        assertEquals(1, results.size());
-
-        assertTrue(results.containsKey(1));
-        assertEquals(TEST_SIZE, results.get(1).intValue());
-
-        assertEquals(1, counter.get());
-        RealmCache.invokeWithGlobalRefCount(realmConfig, new TestHelper.ExpectedCountCallback(0));
-    }
-
     @Test
     public void closeClearingHandlerMessages() throws InterruptedException, TimeoutException, ExecutionException {
         final int TEST_SIZE = 10;
@@ -347,9 +267,9 @@ public Boolean call() throws Exception {
                 }
                 addHandlerMessages.await(1, TimeUnit.SECONDS); // Wait for main thread to add update messages
 
-                // Find the current Handler for the thread now. All message and references will be
+                // Create a Handler for the thread now. All message and references for the notification handler will be
                 // cleared once we call close().
-                Handler threadHandler = realm.handler;
+                Handler threadHandler = new Handler(Looper.myLooper());
                 realm.close(); // Close native resources + associated handlers.
 
                 // Looper now reads the update message from the main thread if the Handler was not
@@ -357,12 +277,13 @@ public Boolean call() throws Exception {
                 // If it works correctly. The looper will just block on an empty message queue.
                 // This is normal behavior but is bad for testing, so we add a custom quit message
                 // at the end so we can evaluate results faster.
-                threadHandler.post(new Runnable() {
+                // 500 ms delay is to make sure the notification daemon thread gets time to send notification.
+                threadHandler.postDelayed(new Runnable() {
                     @Override
                     public void run() {
                         TestHelper.quitLooperOrFail();
                     }
-                });
+                }, 500);
 
                 try {
                     Looper.loop();
@@ -395,24 +316,6 @@ public void run() {
         assertTrue(result);
     }
 
-    @Test
-    @UiThreadTest
-    public void handlerNotRemovedToSoon() {
-        RealmConfiguration realmConfig = configFactory.createConfiguration("private-realm");
-        Realm.deleteRealm(realmConfig);
-        Realm instance1 = Realm.getInstance(realmConfig);
-        Realm instance2 = Realm.getInstance(realmConfig);
-        assertEquals(instance1.getPath(), instance2.getPath());
-        assertNotNull(instance1.handler);
-
-        // If multiple instances are open on the same thread, don't remove handler on that thread
-        // until last instance is closed.
-        instance2.close();
-        assertNotNull(instance1.handler);
-        instance1.close();
-        assertNull(instance1.handler);
-    }
-
     @Test
     @RunTestInLooperThread
     public void commitTransaction_delayChangeListenerOnSameThread() {
@@ -652,9 +555,9 @@ public void onChange(Realm object) {
     // prevents commitTransaction from accidentally posting messages to Handlers which might reference a closed Realm.
     @Test
     public void doNotUseClosedHandler() throws InterruptedException {
-        final AssertionFailedError[] threadAssertionError = new AssertionFailedError[1]; // Keep track of errors in test threads.
         final CountDownLatch handlerNotified = new CountDownLatch(1);
-        final CountDownLatch backgroundThreadClosed = new CountDownLatch(1);
+        final CountDownLatch backgroundThread1Started = new CountDownLatch(1);
+        final CountDownLatch backgroundThread2Closed = new CountDownLatch(1);
 
         // Create Handler on Thread1 by opening a Realm instance
         new Thread("thread1") {
@@ -671,6 +574,7 @@ public void onChange(Realm object) {
                     }
                 };
                 realm.addChangeListener(listener);
+                backgroundThread1Started.countDown();
                 Looper.loop();
             }
         }.start();
@@ -684,38 +588,31 @@ public void run() {
                 RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
                     @Override
                     public void onChange(Realm object) {
-                        try {
-                            fail("This handler should not be notified");
-                        } catch (AssertionFailedError e) {
-                            threadAssertionError[0] = e;
-                            handlerNotified.countDown(); // Make sure that that await() doesn't fail instead.
-                        }
+                        fail("This handler should not be notified");
                     }
                 };
                 realm.addChangeListener(listener);
                 realm.close();
-                backgroundThreadClosed.countDown();
+                backgroundThread2Closed.countDown();
                 Looper.loop();
             }
 
         }.start();
 
-        // Any REALM_CHANGED message should now only reach the open Handler on Thread1
-        backgroundThreadClosed.await();
+        TestHelper.awaitOrFail(backgroundThread1Started);
+        TestHelper.awaitOrFail(backgroundThread2Closed);
         Realm realm = Realm.getInstance(realmConfig);
         realm.beginTransaction();
         realm.commitTransaction();
+        // Any REALM_CHANGED message should now only reach the open Handler on Thread1
         try {
+            // TODO: Waiting 5 seconds is not a reliable condition. Figure out a better way for this.
             if (!handlerNotified.await(5, TimeUnit.SECONDS)) {
                 fail("Handler didn't receive message");
             }
         } finally {
             realm.close();
         }
-
-        if (threadAssertionError[0] != null) {
-            throw threadAssertionError[0];
-        }
     }
 
     // Test that we handle a Looper thread quiting it's looper before it is done executing the current loop ( = Realm.close()
@@ -852,122 +749,91 @@ public void onChange(Realm object) {
     // to advance to the latest version. We make sure in this test that all Realm listeners will be notified
     // regardless of the presence of an async RealmResults that will delay the `REALM_CHANGE` sometimes
     @Test
-    public void asyncRealmResultsShouldNotBlockBackgroundCommitNotification() throws Throwable {
-        final AtomicInteger numberOfRealmCallbackInvocation = new AtomicInteger(0);
-        final AtomicInteger numberOfAsyncRealmResultsCallbackInvocation = new AtomicInteger(0);
-        final CountDownLatch signalTestFinished = new CountDownLatch(2);
-        final CountDownLatch signalClosedRealm = new CountDownLatch(1);
-        final Realm[] realm = new Realm[1];
-        final Throwable[] threadAssertionError = new Throwable[1];
-        final Looper[] backgroundLooper = new Looper[1];
-        ExecutorService executorService = Executors.newSingleThreadExecutor();
-        executorService.submit(new Runnable() {
+    @RunTestInLooperThread
+    public void asyncRealmResultsShouldNotBlockBackgroundCommitNotification() {
+        final Realm realm = looperThread.realm;
+        final RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
+        final AtomicBoolean resultsListenerDone = new AtomicBoolean(false);
+        final AtomicBoolean realmListenerDone = new AtomicBoolean(false);
+
+        looperThread.keepStrongReference.add(dogs);
+        assertTrue(dogs.load());
+        assertEquals(0, dogs.size());
+        dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
-            public void run() {
-                Looper.prepare();
-                backgroundLooper[0] = Looper.myLooper();
-
-                try {
-                    realm[0] = Realm.getInstance(realmConfig);
-                    realm[0].addChangeListener(new RealmChangeListener<Realm>() {
-                        @Override
-                        public void onChange(Realm object) {
-                            RealmResults<Dog> dogs; // to keep it as a strong reference
-                            switch (numberOfRealmCallbackInvocation.incrementAndGet()) {
-                                case 1: {
-                                    // first commit
-                                    dogs = realm[0].where(Dog.class).findAllAsync();
-                                    assertTrue(dogs.load());
-                                    dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
-                                        @Override
-                                        public void onChange(RealmResults<Dog> object) {
-                                            numberOfAsyncRealmResultsCallbackInvocation.incrementAndGet();
-                                        }
-                                    });
-
-                                    new Thread() {
-                                        @Override
-                                        public void run() {
-                                            Realm realm = Realm.getInstance(realmConfig);
-                                            realm.beginTransaction();
-                                            realm.createObject(Dog.class);
-                                            realm.commitTransaction();
-                                            realm.close();
-                                            signalTestFinished.countDown();
-                                        }
-                                    }.start();
-                                    break;
-                                }
-                                case 2: {
-                                    // finish test
-                                    signalTestFinished.countDown();
-                                    break;
-                                }
-                            }
-                        }
-                    });
+            public void onChange(RealmResults<Dog> results) {
+                if (dogs.size() == 2) {
+                    // Results has the latest changes
+                    resultsListenerDone.set(true);
+                    if (realmListenerDone.get()) {
+                        looperThread.testComplete();
+                    }
+                }
+            }
+        });
 
-                    realm[0].handler.post(new Runnable() {
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
+            @Override
+            public void onChange(Realm element) {
+                if (dogs.size() == 1) {
+                    // Step 2. Create the second dog
+                    realm.executeTransactionAsync(new Realm.Transaction() {
                         @Override
-                        public void run() {
-                            realm[0].beginTransaction();
-                            realm[0].createObject(Dog.class);
-                            realm[0].commitTransaction();
+                        public void execute(Realm realm) {
+                            realm.createObject(Dog.class);
                         }
                     });
-
-                    Looper.loop();
-
-                } catch (Throwable e) {
-                    threadAssertionError[0] = e;
-
-                } finally {
-                    if (realm.length > 0 && realm[0] != null) {
-                        realm[0].close();
-                    }
-                    signalClosedRealm.countDown();
-
-                    if (signalTestFinished.getCount() > 0) {
-                        signalTestFinished.countDown();
+                } else if (dogs.size() == 2) {
+                    // Realm listener can see the latest changes
+                    realmListenerDone.set(true);
+                    if (resultsListenerDone.get()) {
+                        looperThread.testComplete();
                     }
                 }
             }
         });
 
-        TestHelper.exitOrThrow(executorService, signalTestFinished, signalClosedRealm, backgroundLooper, threadAssertionError);
+        // Step 1. Create the first dog
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(Dog.class);
+            }
+        });
     }
 
-    // The presence of async RealmResults block any `REALM_CHANGE` notification causing historically the Realm
-    // to advance to the latest version. We make sure in this test that all Realm listeners will be notified
-    // regardless of the presence of an async RealmObject that will delay the `REALM_CHANGE` sometimes
+    // The presence of async RealmResults blocks any `REALM_CHANGE` notification . We make sure in this test that all
+    // Realm listeners will be notified regardless of the presence of an async RealmObject. RealmObjects are special
+    // in the sense that once you got a row accessor to that object, it is automatically up to date as soon as you
+    // call advance_read().
     @Test
     @RunTestInLooperThread
     public void asyncRealmObjectShouldNotBlockBackgroundCommitNotification() {
         final AtomicInteger numberOfRealmCallbackInvocation = new AtomicInteger(0);
         final CountDownLatch signalClosedRealm = new CountDownLatch(1);
-        looperThread.realm.addChangeListener(new RealmChangeListener<Realm>() {
+        final Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
-            public void onChange(Realm object) {
+            public void onChange(final Realm realm) {
                 switch (numberOfRealmCallbackInvocation.incrementAndGet()) {
                     case 1: {
                         // first commit
-                        Dog dog = looperThread.realm.where(Dog.class).findFirstAsync();
+                        Dog dog = realm.where(Dog.class).findFirstAsync();
                         assertTrue(dog.load());
                         dog.addChangeListener(new RealmChangeListener<Dog>() {
                             @Override
                             public void onChange(Dog dog) {
                             }
                         });
-                        looperThread.keepStrongReference.add(dog);
 
                         new Thread() {
                             @Override
                             public void run() {
-                                Realm realm = Realm.getInstance(looperThread.realmConfiguration);
-                                realm.beginTransaction();
-                                realm.createObject(Dog.class);
-                                realm.commitTransaction();
-                                realm.close();
+                                Realm threadRealm = Realm.getInstance(realm.getConfiguration());
+                                threadRealm.beginTransaction();
+                                threadRealm.createObject(Dog.class);
+                                threadRealm.commitTransaction();
+                                threadRealm.close();
                                 signalClosedRealm.countDown();
                             }
                         }.start();
@@ -986,9 +852,9 @@ public void run() {
         looperThread.postRunnable(new Runnable() {
             @Override
             public void run() {
-                looperThread.realm.beginTransaction();
-                looperThread.realm.createObject(Dog.class);
-                looperThread.realm.commitTransaction();
+                realm.beginTransaction();
+                realm.createObject(Dog.class);
+                realm.commitTransaction();
             }
         });
     }
@@ -1017,6 +883,7 @@ public void realmResultsListenerAddedAfterCommit() {
         realm.createObject(AllTypes.class);
         realm.commitTransaction();
 
+        looperThread.keepStrongReference.add(results);
         results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
@@ -1044,4 +911,450 @@ public void onChange(AllTypes object) {
             }
         });
     }
+
+    public static class PopulateOneAllTypes implements RunInLooperThread.RunnableBefore {
+
+        @Override
+        public void run(RealmConfiguration realmConfig) {
+            Realm realm = Realm.getInstance(realmConfig);
+            realm.executeTransaction(new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    realm.createObject(AllTypes.class);
+                }
+            });
+            realm.close();
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PopulateOneAllTypes.class)
+    public void realmListener_realmResultShouldBeSynced() {
+        final Realm realm = looperThread.realm;
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+        assertEquals(1, results.size());
+
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+                assertNotNull(allTypes);
+                allTypes.deleteFromRealm();
+                assertEquals(0, realm.where(AllTypes.class).count());
+            }
+        });
+
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
+            @Override
+            public void onChange(Realm element) {
+                // Change event triggered by deletion in async transaction.
+                assertEquals(0, realm.where(AllTypes.class).count());
+                assertEquals(0, results.size());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    // FIXME check if the SharedRealm Changed in handleAsyncTransactionCompleted and reenable this test.
+    // We precisely depend on the order of triggering change listeners right now.
+    // So it should be:
+    // 1. Synced object listener
+    // 2. Synced results listener
+    // 3. Global listener
+    // Async listeners are not concerned by this test. Since they are triggered by different event and no advance read
+    // involved.
+    // If this case fails on your code, think twice before changing the test!
+    // https://github.com/realm/realm-java/issues/2408 is related to this test!
+    @Test
+    @Ignore("Listener on Realm might be trigger more times, ignore for now")
+    @RunTestInLooperThread
+    public void callingOrdersOfListeners() {
+        final Realm realm = looperThread.realm;
+        final AtomicInteger count = new AtomicInteger(0);
+
+        final RealmChangeListener<RealmResults<AllTypes>> syncedResultsListener =
+                new RealmChangeListener<RealmResults<AllTypes>>() {
+                    @Override
+                    public void onChange(RealmResults<AllTypes> element) {
+                        // First called
+                        assertEquals(0, count.getAndIncrement());
+                    }
+                };
+
+        final RealmChangeListener<AllTypes> syncedObjectListener = new RealmChangeListener<AllTypes>() {
+            @Override
+            public void onChange(AllTypes element) {
+                // Second called
+                assertEquals(1, count.getAndIncrement());
+            }
+        };
+        final RealmChangeListener<Realm> globalListener = new RealmChangeListener<Realm>() {
+            @Override
+            public void onChange(Realm element) {
+                // third called
+                assertEquals(2, count.getAndIncrement());
+                looperThread.testComplete();
+            }
+        };
+
+
+        realm.beginTransaction();
+        final AllTypes allTypes = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        // We need to create one objects first and let the pass the first change event
+        final RealmChangeListener<Realm> initListener = new RealmChangeListener<Realm>() {
+            @Override
+            public void onChange(Realm element) {
+                looperThread.postRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        // Clear the change listeners
+                        realm.removeAllChangeListeners();
+
+                        // Now we can start testing
+                        allTypes.addChangeListener(syncedObjectListener);
+                        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+                        results.addChangeListener(syncedResultsListener);
+                        realm.addChangeListener(globalListener);
+
+                        // Now we trigger those listeners
+                        realm.executeTransactionAsync(new Realm.Transaction() {
+                            @Override
+                            public void execute(Realm realm) {
+                                AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+                                assertNotNull(allTypes);
+                                allTypes.setColumnLong(42);
+                            }
+                        });
+                    }
+                });
+            }
+        };
+        realm.addChangeListener(initListener);
+    }
+
+    // See https://github.com/realm/realm-android-adapters/issues/48
+    // Step 1: Populate the db
+    // Step 2: Post a runnable to caller thread.
+    //         Event Queue: |Posted Runnable| <- TOP
+    // Step 3: Delete object which will make the results contain an invalid object at this moment
+    //         Right Event Queue: |LOCAL_COMMIT   |   Wrong Event Queue: |Posted Runnable           |  <- TOP
+    //                            |Posted Runnable|                      |REALM_CHANGED/LOCAL_COMMIT|
+    // Step 4: Posted runnable called.
+    @Test
+    @RunTestInLooperThread(/*step1*/ before = PopulateOneAllTypes.class)
+    public void realmListener_localChangeShouldBeSendAtFrontOfTheQueue() {
+        final Realm realm = looperThread.realm;
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+        assertEquals(1, results.size());
+
+        // Step 2
+        // The transaction later will trigger the results sync, and it should be run before this runnable.
+        looperThread.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                // Step 4
+                assertEquals(0, results.size());
+                realm.close();
+                looperThread.testComplete();
+            }
+        });
+
+        // Step 3
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+                assertNotNull(allTypes);
+                allTypes.deleteFromRealm();
+                assertEquals(0, realm.where(AllTypes.class).count());
+                assertFalse(results.get(0).isValid());
+            }
+        });
+    }
+
+    // See https://github.com/realm/realm-android-adapters/issues/48
+    // Step 1: Populate the db
+    // Step 2: Create a async query, and wait until it finishes
+    // Step 3: Post a runnable to caller thread.
+    //         Event Queue: |Posted Runnable| <- TOP
+    // Step 4: Delete object which will make the results contain a invalid object at this moment
+    //         Right Event Queue: |LOCAL_COMMIT   |   Wrong Event Queue: |Posted Runnable           |  <- TOP
+    //                            |Posted Runnable|                      |REALM_CHANGED/LOCAL_COMMIT|
+    // Step 5: Posted runnable called.
+    @Test
+    @RunTestInLooperThread(/*step1*/before = PopulateOneAllTypes.class)
+    public void realmListener_localChangeShouldBeSendAtFrontOfTheQueueWithLoadedAsync() {
+        final AtomicBoolean changedFirstTime = new AtomicBoolean(false);
+        final Realm realm = looperThread.realm;
+        final RealmResults<AllTypes> asyncResults = realm.where(AllTypes.class).findAllAsync();
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+
+        assertEquals(1, results.size());
+
+        looperThread.keepStrongReference.add(asyncResults);
+        asyncResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> element) {
+                if (!changedFirstTime.get()) {
+                    // Step 2
+                    // The transaction later will trigger the results sync, and it should be run before this runnable.
+                    looperThread.postRunnable(new Runnable() {
+                        @Override
+                        public void run() {
+                            // Step 5
+                            assertEquals(0, asyncResults.size());
+                            assertEquals(0, results.size());
+                            looperThread.testComplete();
+                        }
+                    });
+
+                    // Step 3
+                    realm.executeTransaction(new Realm.Transaction() {
+                        @Override
+                        public void execute(Realm realm) {
+                            AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+                            assertNotNull(allTypes);
+                            allTypes.deleteFromRealm();
+                            assertEquals(0, realm.where(AllTypes.class).count());
+                            assertFalse(results.get(0).isValid());
+                        }
+                    });
+                    changedFirstTime.set(true);
+                }
+            }
+        });
+    }
+
+    // See https://github.com/realm/realm-android-adapters/issues/48
+    // Step 1: Populate the db
+    // Step 2: Create a async query, and pause it
+    // Step 3: Post a runnable to caller thread.
+    //         Event Queue: |Posted Runnable| <- TOP
+    // Step 4: Delete object which will make the results contain a invalid object at this moment
+    //         Right Event Queue: |LOCAL_COMMIT   |   Wrong Event Queue: |Posted Runnable           |  <- TOP
+    //                            |Posted Runnable|                      |REALM_CHANGED/LOCAL_COMMIT|
+    // Step 5: Posted runnable called.
+    //
+    @Test
+    @RunTestInLooperThread(/*step1*/before = PopulateOneAllTypes.class)
+    public void realmListener_localChangeShouldBeSendAtFrontOfTheQueueWithPausedAsync() {
+        final Realm realm = looperThread.realm;
+
+        Realm.asyncTaskExecutor.pause();
+        final RealmResults<AllTypes> asyncResults = realm.where(AllTypes.class).findAllAsync();
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+
+        assertEquals(1, results.size());
+
+        // Step 2
+        // The transaction later will trigger the results sync, and it should be run before this runnable.
+        looperThread.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                // Step 5
+                assertFalse(asyncResults.isLoaded());
+                assertEquals(0, results.size());
+                looperThread.testComplete();
+            }
+        });
+
+        // Step 3
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                AllTypes allTypes = realm.where(AllTypes.class).findFirst();
+                assertNotNull(allTypes);
+                allTypes.deleteFromRealm();
+                assertEquals(0, realm.where(AllTypes.class).count());
+                assertFalse(results.get(0).isValid());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void warnIfMixingSyncWritesAndAsyncQueries() {
+        final Realm realm = looperThread.realm;
+        final AtomicBoolean warningLogged = new AtomicBoolean(false);
+        final TestHelper.TestLogger testLogger = new TestHelper.TestLogger() {
+            @Override
+            public void warn(Throwable t, String message, Object... args) {
+                assertTrue(message.contains("Mixing asynchronous queries with local writes should be avoided."));
+                warningLogged.set(true);
+            }
+        };
+        RealmLog.add(testLogger);
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
+        looperThread.keepStrongReference.add(results);
+        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> element) {
+                RealmLog.remove(testLogger);
+                assertTrue(warningLogged.get());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void accessingSyncRealmResultInsideAsyncResultListener() {
+        final Realm realm = looperThread.realm;
+        final AtomicInteger asyncResultCallback = new AtomicInteger(0);
+
+        final RealmResults<AllTypes> syncResults = realm.where(AllTypes.class).findAll();
+
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
+        looperThread.keepStrongReference.add(results);
+        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> results) {
+                switch (asyncResultCallback.incrementAndGet()) {
+                    case 1:
+                        // Called when first async query completes
+                        assertEquals(0, results.size());
+                        realm.executeTransactionAsync(new Realm.Transaction() {
+                            @Override
+                            public void execute(Realm realm) {
+                                realm.createObject(AllTypes.class);
+                            }
+                        });
+                        break;
+
+                    case 2:
+                        // Called after async transaction completes, A REALM_CHANGED event has been triggered,
+                        // async queries have rerun, and listeners are triggered again
+                        assertEquals(1, results.size());
+                        assertEquals(1, syncResults.size()); // If syncResults is not in sync yet, this will fail.
+                        looperThread.testComplete();
+                        break;
+                }
+            }
+        });
+    }
+
+    // If RealmResults are updated just before their change listener are notified, one change listener might
+    // reference another RealmResults that have been advance_read, but not yet called sync_if_needed.
+    // This can result in accessing detached rows and other errors.
+    @Test
+    @RunTestInLooperThread
+    public void accessingSyncRealmResultsInsideAnotherResultListener() {
+        final Realm realm = looperThread.realm;
+        final RealmResults<AllTypes> syncResults1 = realm.where(AllTypes.class).findAll();
+        final RealmResults<AllTypes> syncResults2 = realm.where(AllTypes.class).findAll();
+
+        looperThread.keepStrongReference.add(syncResults1);
+        syncResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> element) {
+                assertEquals(1, syncResults1.size());
+                assertEquals(1, syncResults2.size()); // If syncResults2 is not in sync yet, this will fail.
+                looperThread.testComplete();
+            }
+        });
+
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread(threadName = "IntentService[1]")
+    public void listenersNotAllowedOnIntentServiceThreads() {
+        final Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        AllTypes obj = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+
+        // Global listener
+        try {
+            realm.addChangeListener(new RealmChangeListener<Realm>() {
+                @Override
+                public void onChange(Realm element) {
+
+                }
+            });
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        // RealmResults listener
+        try {
+            results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+                @Override
+                public void onChange(RealmResults<AllTypes> element) {
+
+                }
+            });
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        // Object listener
+        try {
+            obj.addChangeListener(new RealmChangeListener<RealmModel>() {
+                @Override
+                public void onChange(RealmModel element) {
+
+                }
+            });
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        looperThread.testComplete();
+    }
+
+    @Test
+    public void listenersNotAllowedOnNonLooperThreads() {
+        realm = Realm.getInstance(realmConfig);
+        realm.beginTransaction();
+        AllTypes obj = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+
+        // Global listener
+        try {
+            realm.addChangeListener(new RealmChangeListener<Realm>() {
+                @Override
+                public void onChange(Realm element) {
+
+                }
+            });
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        // RealmResults listener
+        try {
+            results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+                @Override
+                public void onChange(RealmResults<AllTypes> element) {
+
+                }
+            });
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        // Object listener
+        try {
+            obj.addChangeListener(new RealmChangeListener<RealmModel>() {
+                @Override
+                public void onChange(RealmModel element) {
+
+                }
+            });
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
index 7fbed86aca..0643ba9316 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
@@ -126,7 +126,7 @@ private void appendElementToCollection(Realm realm, CollectionClass collection)
     }
 
     private void createNewObject() {
-        Number currentMax = realm.where(AllJavaTypes.class).max(AllJavaTypes.FIELD_LONG);
+        Number currentMax = realm.where(AllJavaTypes.class).max(AllJavaTypes.FIELD_ID);
         long nextId = 0;
         if (currentMax != null) {
             nextId = currentMax.longValue() + 1;
@@ -724,6 +724,7 @@ public void iterator_outsideChangeToSizeThrowsConcurrentModification_managedColl
                 case MIN_DATE:
                 case MAX_DATE:
                 case IS_VALID:
+                case IS_MANAGED:
                     realm.cancelTransaction();
                     continue;
                 default:
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
index 81c4938f31..6677482d9c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
@@ -50,7 +50,7 @@ public void setUp() {
         RealmConfiguration realmConfig = configFactory.createConfiguration();
         realm = Realm.getInstance(realmConfig);
         realm.beginTransaction();
-        AnnotationTypes object = realm.createObject(AnnotationTypes.class);
+        AnnotationTypes object = realm.createObject(AnnotationTypes.class, 0);
         object.setNotIndexString("String 1");
         object.setIndexString("String 2");
         object.setIgnoreString("String 3");
@@ -102,9 +102,8 @@ public void index() {
     public void primaryKey_migration_long() {
         realm.beginTransaction();
         for (int i = 1; i <= 2; i++) {
-            PrimaryKeyAsString obj = realm.createObject(PrimaryKeyAsString.class);
+            PrimaryKeyAsString obj = realm.createObject(PrimaryKeyAsString.class, "String" + i);
             obj.setId(i);
-            obj.setName("String" + i);
         }
 
         Table table = realm.getTable(PrimaryKeyAsString.class);
@@ -118,9 +117,8 @@ public void primaryKey_migration_long() {
     public void primaryKey_migration_longDuplicateValues() {
         realm.beginTransaction();
         for (int i = 1; i <= 2; i++) {
-            PrimaryKeyAsString obj = realm.createObject(PrimaryKeyAsString.class);
+            PrimaryKeyAsString obj = realm.createObject(PrimaryKeyAsString.class, "String" + i);
             obj.setId(1); // Create duplicate values
-            obj.setName("String" + i);
         }
 
         Table table = realm.getTable(PrimaryKeyAsString.class);
@@ -139,8 +137,7 @@ public void primaryKey_migration_longDuplicateValues() {
     public void primaryKey_migration_string() {
         realm.beginTransaction();
         for (int i = 1; i <= 2; i++) {
-            PrimaryKeyAsLong obj = realm.createObject(PrimaryKeyAsLong.class);
-            obj.setId(i);
+            PrimaryKeyAsLong obj = realm.createObject(PrimaryKeyAsLong.class, i);
             obj.setName("String" + i);
         }
 
@@ -155,8 +152,7 @@ public void primaryKey_migration_string() {
     public void primaryKey_migration_stringDuplicateValues() {
         realm.beginTransaction();
         for (int i = 1; i <= 2; i++) {
-            PrimaryKeyAsLong obj = realm.createObject(PrimaryKeyAsLong.class);
-            obj.setId(i);
+            PrimaryKeyAsLong obj = realm.createObject(PrimaryKeyAsLong.class, i);
             obj.setName("String"); // Create duplicate values
         }
 
@@ -175,7 +171,7 @@ public void primaryKey_migration_stringDuplicateValues() {
     public void primaryKey_checkPrimaryKeyOnCreate() {
         realm.beginTransaction();
         try {
-            realm.createObject(AnnotationTypes.class);
+            realm.createObject(AnnotationTypes.class, 0);
             fail("Two empty objects cannot be created on the same table if a primary key is defined");
         } catch (RealmPrimaryKeyConstraintException ignored) {
         } finally {
@@ -183,32 +179,12 @@ public void primaryKey_checkPrimaryKeyOnCreate() {
         }
     }
 
-    // It should be allowed to override the primary key value with the same value
-    @Test
-    public void primaryKey_defaultStringValue() {
-        realm.beginTransaction();
-        PrimaryKeyAsString str = realm.createObject(PrimaryKeyAsString.class);
-        str.setName("");
-        realm.commitTransaction();
-    }
-
-    // It should be allowed to override the primary key value with the same value
-    @Test
-    public void primaryKey_defaultLongValue() {
-        realm.beginTransaction();
-        PrimaryKeyAsLong str = realm.createObject(PrimaryKeyAsLong.class);
-        str.setId(0);
-        realm.commitTransaction();
-    }
-
     @Test
     public void primaryKey_errorOnInsertingSameObject() {
         try {
             realm.beginTransaction();
-            AnnotationTypes obj1 = realm.createObject(AnnotationTypes.class);
-            obj1.setId(1);
-            AnnotationTypes obj2 = realm.createObject(AnnotationTypes.class);
-            obj2.setId(1);
+            realm.createObject(AnnotationTypes.class, 1);
+            realm.createObject(AnnotationTypes.class, 1);
             fail("Inserting two objects with same primary key should fail");
         } catch (RealmPrimaryKeyConstraintException ignored) {
         } finally {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index 142bf015be..dc17dab814 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -42,9 +42,11 @@
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.Owner;
 import io.realm.instrumentation.MockActivityManager;
+import io.realm.internal.HandlerControllerConstants;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.async.RealmThreadPoolExecutor;
-import io.realm.internal.log.RealmLog;
+import io.realm.log.LogLevel;
+import io.realm.log.RealmLog;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -170,7 +172,7 @@ public void onChange(Realm object) {
     @Test
     @RunTestInLooperThread
     public void executeTransactionAsync_exceptionHandling() throws Throwable {
-        final TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
+        final TestHelper.TestLogger testLogger = new TestHelper.TestLogger(LogLevel.DEBUG);
         RealmLog.add(testLogger);
 
         final Realm realm = looperThread.realm;
@@ -281,6 +283,35 @@ public void execute(Realm realm) {
         }, transactionCallback);
     }
 
+    // Test case for https://github.com/realm/realm-java/issues/1893
+    // Ensure that onSuccess is called with the correct Realm version for async transaction.
+    @Test
+    @RunTestInLooperThread
+    public void executeTransactionAsync_asyncQuery() {
+        final Realm realm = looperThread.realm;
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
+        assertEquals(0, results.size());
+
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(AllTypes.class);
+            }
+        }, new Realm.Transaction.OnSuccess() {
+            @Override
+            public void onSuccess() {
+                assertEquals(1, realm.where(AllTypes.class).count());
+                assertEquals(1, results.size());
+                looperThread.testComplete();
+            }
+        }, new Realm.Transaction.OnError() {
+            @Override
+            public void onError(Throwable error) {
+                fail();
+            }
+        });
+    }
+
     // ************************************
     // *** promises based async queries ***
     // ************************************
@@ -298,6 +329,7 @@ public void findAllAsync() throws Throwable {
         assertFalse(results.isLoaded());
         assertEquals(0, results.size());
 
+        looperThread.keepStrongReference.add(results);
         results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
@@ -334,7 +366,8 @@ public void unmanagedObjectAsyncBehaviour() {
         dog.setAge(10);
 
         assertTrue(dog.isLoaded());
-        assertFalse(dog.isValid());
+        assertTrue(dog.isValid());
+        assertFalse(dog.isManaged());
     }
 
     @Test
@@ -407,6 +440,7 @@ public void findAllAsync_forceLoad() throws Throwable {
                 .between("columnLong", 0, 4)
                 .findAllAsync();
 
+        looperThread.keepStrongReference.add(realmResults);
         // notification should be called as well
         realmResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
@@ -459,7 +493,7 @@ public boolean onInterceptInMessage(int what) {
                 switch (what) {
                     // 5. Intercept all messages from other threads. On the first complete, we advance the tread
                     // which will cause the async query to rerun instead of triggering the change listener.
-                    case HandlerController.COMPLETED_ASYNC_REALM_RESULTS:
+                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS:
                         if (intercepts == 1) {
                             // We advance the Realm so we can simulate a retry
                             realm.beginTransaction();
@@ -482,6 +516,7 @@ public boolean onInterceptInMessage(int what) {
         assertEquals(0, realmResults.size());
 
         // 6. Callback triggered after retry has completed
+        looperThread.keepStrongReference.add(realmResults);
         realmResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
@@ -516,7 +551,7 @@ public void findAllAsync_batchUpdate() throws Throwable {
             @Override
             public boolean onInterceptInMessage(int what) {
                 int intercepts = numberOfIntercept.getAndIncrement();
-                if (what == HandlerController.COMPLETED_ASYNC_REALM_RESULTS && intercepts == 1) {
+                if (what == HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS && intercepts == 1) {
                     // 4. The first time the async queries complete we start an update from
                     // another background thread. This will cause queries to rerun when the
                     // background thread notifies this thread.
@@ -564,6 +599,9 @@ public void run() {
             }
         };
 
+        looperThread.keepStrongReference.add(realmResults1);
+        looperThread.keepStrongReference.add(realmResults2);
+
         realmResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
@@ -623,7 +661,7 @@ public boolean onInterceptInMessage(int what) {
                 // Intercepts in order [QueryCompleted, RealmChanged, QueryUpdated]
                 int intercepts = numberOfIntercept.incrementAndGet();
                 switch (what) {
-                    case HandlerController.COMPLETED_ASYNC_REALM_RESULTS: {
+                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS: {
                         // we advance the Realm so we can simulate a retry
                         if (intercepts == 1) {
                             realm.beginTransaction();
@@ -645,6 +683,8 @@ public boolean onInterceptInMessage(int what) {
         assertFalse(realmResults.isLoaded());
         assertEquals(0, realmResults.size());
 
+        looperThread.keepStrongReference.add(realmResults);
+
         // Add change listener that should only be called once
         realmResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
@@ -681,7 +721,7 @@ public void findAllAsync_callerThreadBehind() throws Throwable {
             @Override
             public boolean onInterceptInMessage(int what) {
                 switch (what) {
-                    case HandlerController.REALM_CHANGED: {
+                    case HandlerControllerConstants.REALM_CHANGED: {
                         // should only intercept the first REALM_CHANGED coming from the
                         // background update thread
 
@@ -691,11 +731,11 @@ public boolean onInterceptInMessage(int what) {
                         // upcoming REALM_CHANGED to batch update all async queries
                         return numberOfInterceptedChangeMessage.getAndIncrement() == 0;
                     }
-                    case HandlerController.COMPLETED_ASYNC_REALM_RESULTS: {
+                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS: {
                         if (numberOfCompletedAsyncQuery.incrementAndGet() == 2) {
                             // both queries have completed now (& their results should be ignored)
                             // now send the REALM_CHANGED event that should batch update all queries
-                            sendEmptyMessage(HandlerController.REALM_CHANGED);
+                            sendEmptyMessage(HandlerControllerConstants.REALM_CHANGED);
                         }
                     }
                 }
@@ -742,6 +782,9 @@ public void run() {
             }
         };
 
+        looperThread.keepStrongReference.add(realmResults1);
+        looperThread.keepStrongReference.add(realmResults2);
+
         realmResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
@@ -779,7 +822,7 @@ public void findFirstAsync() {
         final AllTypes asyncObj = realm.where(AllTypes.class).findFirstAsync();
         assertFalse(asyncObj.isValid());
         assertFalse(asyncObj.isLoaded());
-
+        looperThread.keepStrongReference.add(asyncObj);
         asyncObj.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
             public void onChange(AllTypes object) {
@@ -795,6 +838,7 @@ public void onChange(AllTypes object) {
     public void findFirstAsync_initalEmptyRow() throws Throwable {
         Realm realm = looperThread.realm;
         final AllTypes firstAsync = realm.where(AllTypes.class).findFirstAsync();
+        looperThread.keepStrongReference.add(firstAsync);
         firstAsync.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
             public void onChange(AllTypes object) {
@@ -829,6 +873,7 @@ public void findFirstAsync_updatedIfsyncRealmObjectIsUpdated() throws Throwable
         assertEquals(0, firstAsync.getColumnLong());
         assertEquals("test data 0", firstAsync.getColumnString());
 
+        looperThread.keepStrongReference.add(firstAsync);
         firstAsync.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
             public void onChange(AllTypes object) {
@@ -853,6 +898,7 @@ public void findFirstAsync_withNotification() throws Throwable {
                 .between("columnLong", 4, 9)
                 .findFirstAsync();
 
+        looperThread.keepStrongReference.add(realmResults);
         realmResults.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
             public void onChange(AllTypes object) {
@@ -915,7 +961,7 @@ public void findFirstAsync_retry() throws Throwable {
             public boolean onInterceptInMessage(int what) {
                 int intercepts = numberOfIntercept.incrementAndGet();
                 switch (what) {
-                    case HandlerController.COMPLETED_ASYNC_REALM_OBJECT: {
+                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_OBJECT: {
                         if (intercepts == 1) {
                             // we advance the Realm so we can simulate a retry
                             realm.beginTransaction();
@@ -946,6 +992,7 @@ public boolean onInterceptInMessage(int what) {
         }
 
         // Add change listener that should only be called once after the retry completed.
+        looperThread.keepStrongReference.add(realmResults);
         realmResults.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
             public void onChange(AllTypes object) {
@@ -976,6 +1023,7 @@ public void findAllSortedAsync() throws Throwable {
         assertFalse(results.isLoaded());
         assertEquals(0, results.size());
 
+        looperThread.keepStrongReference.add(results);
         results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
@@ -1011,7 +1059,7 @@ public boolean onInterceptInMessage(int what) {
                 // In order [QueryCompleted, RealmChanged, QueryUpdated]
                 int intercepts = numberOfIntercept.incrementAndGet();
                 switch (what) {
-                    case HandlerController.COMPLETED_ASYNC_REALM_RESULTS: {
+                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS: {
                         if (intercepts == 1) {
                             // We advance the Realm so we can simulate a retry before listeners are
                             // called.
@@ -1038,6 +1086,7 @@ public boolean onInterceptInMessage(int what) {
         // 4. Intercepting the query completed event the first time will
         // cause a commit that should cause the findAllSortedAsync to be re-run.
         // This change listener should only be called with the final result.
+        looperThread.keepStrongReference.add(realmResults);
         realmResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
@@ -1074,8 +1123,8 @@ public void findAllSortedAsync_batchUpdate() {
             @Override
             public boolean onInterceptInMessage(int what) {
                 switch (what) {
-                    case HandlerController.COMPLETED_ASYNC_REALM_RESULTS: {
-                        if (numberOfIntercept.incrementAndGet() == 1) {
+                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS: {
+                        if (numberOfIntercept.incrementAndGet() == 2 /* 2 queries are both completed */) {
                             // 6. The first time the async queries complete we start an update from
                             // another background thread. This will cause queries to rerun when the
                             // background thread notifies this thread.
@@ -1131,6 +1180,9 @@ public void run() {
             }
         };
 
+        looperThread.keepStrongReference.add(realmResults1);
+        looperThread.keepStrongReference.add(realmResults2);
+
         realmResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
@@ -1211,7 +1263,7 @@ public void findAllSortedAsync_multipleFields_batchUpdate() throws Throwable {
             @Override
             public boolean onInterceptInMessage(int what) {
                 int intercepts = numberOfIntercept.incrementAndGet();
-                if (what == HandlerController.COMPLETED_ASYNC_REALM_RESULTS && intercepts == 1) {
+                if (what == HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS && intercepts == 1) {
                     // 6. The first time the async queries complete we start an update from
                     // another background thread. This will cause queries to rerun when the
                     // background thread notifies this thread.
@@ -1272,6 +1324,9 @@ public void run() {
             }
         };
 
+        looperThread.keepStrongReference.add(realmResults1);
+        looperThread.keepStrongReference.add(realmResults2);
+
         realmResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
@@ -1481,7 +1536,7 @@ public void onChange(RealmResults<AllTypes> object) {
         });
         looperThread.keepStrongReference.add(allAsync);
 
-        looperThread.realm.handler.postDelayed(new Runnable() {
+        looperThread.postRunnableDelayed(new Runnable() {
             @Override
             public void run() {
                 backgroundThread.start();
@@ -1528,6 +1583,10 @@ public void run() {
             }
         };
 
+        looperThread.keepStrongReference.add(distinctBool);
+        looperThread.keepStrongReference.add(distinctLong);
+        looperThread.keepStrongReference.add(distinctDate);
+        looperThread.keepStrongReference.add(distinctString);
         distinctBool.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
             public void onChange(RealmResults<AnnotationIndexTypes> object) {
@@ -1737,6 +1796,7 @@ public void queryingLinkHandover() throws Throwable {
         final Realm realm = looperThread.realm;
 
         final RealmResults<Dog> allAsync = realm.where(Dog.class).equalTo("owner.name", "kiba").findAllAsync();
+        looperThread.keepStrongReference.add(allAsync);
         allAsync.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
             public void onChange(RealmResults<Dog> object) {
@@ -1796,6 +1856,7 @@ public void testFindFirstUsesCallerThreadVersion() throws Throwable {
         Realm.asyncTaskExecutor.pause();
 
         final AllTypes firstAsync = looperThread.realm.where(AllTypes.class).findFirstAsync();
+        looperThread.keepStrongReference.add(firstAsync);
         firstAsync.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
             public void onChange(AllTypes object) {
@@ -1811,8 +1872,8 @@ public void onChange(AllTypes object) {
             public void run() {
                 Realm bgRealm = Realm.getInstance(looperThread.realmConfiguration);
                 // Advancing the Realm without generating notifications
-                bgRealm.sharedGroupManager.promoteToWrite();
-                bgRealm.sharedGroupManager.commitAndContinueAsRead();
+                bgRealm.sharedRealm.beginTransaction();
+                bgRealm.sharedRealm.commitTransaction();
                 Realm.asyncTaskExecutor.resume();
                 bgRealm.close();
                 signalClosedRealm.countDown();
@@ -1825,7 +1886,7 @@ public void run() {
     @Test
     @UiThreadTest
     public void badVersion_findAll() throws NoSuchFieldException, IllegalAccessException {
-        TestHelper.replaceRealmThreadExectutor(RealmThreadPoolExecutor.newSingleThreadExecutor());
+        TestHelper.replaceRealmThreadExecutor(RealmThreadPoolExecutor.newSingleThreadExecutor());
         RealmConfiguration config = configFactory.createConfiguration();
         Realm realm = Realm.getInstance(config);
         realm.executeTransactionAsync(new Realm.Transaction() {
@@ -1852,6 +1913,7 @@ public void execute(Realm realm) {
         } finally {
             realm.close();
         }
+        TestHelper.resetRealmThreadExecutor();
     }
 
     // Test case for https://github.com/realm/realm-java/issues/2417
@@ -1859,7 +1921,7 @@ public void execute(Realm realm) {
     @Test
     @UiThreadTest
     public void badVersion_findAllSortedAsync() throws NoSuchFieldException, IllegalAccessException {
-        TestHelper.replaceRealmThreadExectutor(RealmThreadPoolExecutor.newSingleThreadExecutor());
+        TestHelper.replaceRealmThreadExecutor(RealmThreadPoolExecutor.newSingleThreadExecutor());
         RealmConfiguration config = configFactory.createConfiguration();
         Realm realm = Realm.getInstance(config);
         realm.executeTransactionAsync(new Realm.Transaction() {
@@ -1884,6 +1946,7 @@ public void execute(Realm realm) {
                 .findAllSortedAsync(AllTypes.FIELD_STRING, Sort.ASCENDING, AllTypes.FIELD_LONG, Sort.DESCENDING)
                 .load();
         realm.close();
+        TestHelper.resetRealmThreadExecutor();
     }
 
     // Test case for https://github.com/realm/realm-java/issues/2417
@@ -1891,7 +1954,7 @@ public void execute(Realm realm) {
     @Test
     @UiThreadTest
     public void badVersion_distinct() throws NoSuchFieldException, IllegalAccessException {
-        TestHelper.replaceRealmThreadExectutor(RealmThreadPoolExecutor.newSingleThreadExecutor());
+        TestHelper.replaceRealmThreadExecutor(RealmThreadPoolExecutor.newSingleThreadExecutor());
         RealmConfiguration config = configFactory.createConfiguration();
         Realm realm = Realm.getInstance(config);
         realm.executeTransactionAsync(new Realm.Transaction() {
@@ -1917,6 +1980,7 @@ public void execute(Realm realm) {
                 .load();
 
         realm.close();
+        TestHelper.resetRealmThreadExecutor();
     }
 
     // Test case for https://github.com/realm/realm-java/issues/2417
@@ -1924,11 +1988,12 @@ public void execute(Realm realm) {
     @Test
     @RunTestInLooperThread
     public void badVersion_syncTransaction() throws NoSuchFieldException, IllegalAccessException {
-        TestHelper.replaceRealmThreadExectutor(RealmThreadPoolExecutor.newSingleThreadExecutor());
+        TestHelper.replaceRealmThreadExecutor(RealmThreadPoolExecutor.newSingleThreadExecutor());
         Realm realm = looperThread.realm;
 
         // 1. Make sure that async query is not started
         final RealmResults<AllTypes> result = realm.where(AllTypes.class).findAllSortedAsync(AllTypes.FIELD_STRING);
+        looperThread.keepStrongReference.add(result);
         result.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
@@ -1949,6 +2014,7 @@ public void onChange(RealmResults<AllTypes> object) {
 
         // 3. The async query should now (hopefully) fail with a BadVersion
         result.load();
+        TestHelper.resetRealmThreadExecutor();
     }
 
     // handlerController#emptyAsyncRealmObject is accessed from different threads
@@ -2047,6 +2113,57 @@ public void run() {
         realm.close();
     }
 
+    // This test reproduce the issue in https://secure.helpscout.net/conversation/244053233/6163/?folderId=366141
+    // First it creates 512 async queries, then trigger a transaction to make the queries gets update with
+    // nativeBatchUpdateQueries. It should not exceed the limits of local ref map size in JNI.
+    @Test
+    @RunTestInLooperThread
+    public void batchUpdate_localRefIsDeletedInLoopOfNativeBatchUpdateQueries() {
+        final Realm realm = looperThread.realm;
+        // For Android, the size of local ref map is 512. Use 1024 for more pressure.
+        final int TEST_COUNT = 1024;
+        final AtomicBoolean updatesTriggered = new AtomicBoolean(false);
+        // The first time onChange gets called for every results.
+        final AtomicInteger firstOnChangeCounter = new AtomicInteger(0);
+        // The second time onChange gets called for every results which is triggered by the transaction.
+        final AtomicInteger secondOnChangeCounter = new AtomicInteger(0);
+
+        final RealmChangeListener<RealmResults<AllTypes>> listener = new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> element) {
+                if (updatesTriggered.get())  {
+                    // Step 4: Test finished after all results's onChange gets called the 2nd time.
+                    int count  = secondOnChangeCounter.addAndGet(1);
+                    if (count == TEST_COUNT) {
+                        realm.removeAllChangeListeners();
+                        looperThread.testComplete();
+                    }
+                } else {
+                    int count  = firstOnChangeCounter.addAndGet(1);
+                    if (count == TEST_COUNT) {
+                        // Step 3: Commit the transaction to trigger queries updates.
+                        updatesTriggered.set(true);
+                        realm.executeTransactionAsync(new Realm.Transaction() {
+                            @Override
+                            public void execute(Realm realm) {
+                                realm.createObject(AllTypes.class);
+                            }
+                        });
+                    } else {
+                        // Step 2: Create 2nd - TEST_COUNT queries.
+                        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
+                        results.addChangeListener(this);
+                        looperThread.keepStrongReference.add(results);
+                    }
+                }
+            }
+        };
+        // Step 1. Create first async to kick the test start.
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
+        results.addChangeListener(listener);
+        looperThread.keepStrongReference.add(results);
+    }
+
     // *** Helper methods ***
 
     private void populateTestRealm(final Realm testRealm, int objects) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
index abbc3a37dc..c8213e7d9c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
@@ -31,6 +31,7 @@
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.StringOnly;
+import io.realm.exceptions.RealmFileException;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
@@ -105,7 +106,8 @@ public void getInstanceClearsCacheWhenFailed() {
         realm.close();
         try {
             Realm.getInstance(configB); // Try to open with key 2
-        } catch (IllegalArgumentException ignored) {
+        } catch (RealmFileException expected) {
+            assertEquals(expected.getKind(), RealmFileException.Kind.ACCESS_ERROR);
             // Delete Realm so key 2 works. This should work as a Realm shouldn't be cached
             // if initialization failed.
             assertTrue(Realm.deleteRealm(configA));
@@ -152,7 +154,8 @@ public void dontCacheWrongConfigurations() throws IOException {
         try {
             Realm.getInstance(wrongConfig);
             fail();
-        } catch (IllegalArgumentException ignored) {
+        } catch (RealmFileException expected) {
+            assertEquals(expected.getKind(), RealmFileException.Kind.ACCESS_ERROR);
         }
 
         // Try again with proper key
@@ -179,7 +182,7 @@ public void deletingRealmAlsoClearsConfigurationCache() throws IOException {
 
         // 1. Write a copy of the encrypted Realm to a new file
         Realm testRealm = Realm.getInstance(config);
-        File copiedRealm = new File(config.getRealmFolder(), "encrypted-copy.realm");
+        File copiedRealm = new File(config.getRealmDirectory(), "encrypted-copy.realm");
         if (copiedRealm.exists()) {
             assertTrue(copiedRealm.delete());
         }
@@ -190,7 +193,7 @@ public void deletingRealmAlsoClearsConfigurationCache() throws IOException {
         Realm.deleteRealm(config);
 
         // 3. Rename the new file to the old file name.
-        assertTrue(copiedRealm.renameTo(new File(config.getRealmFolder(), REALM_NAME)));
+        assertTrue(copiedRealm.renameTo(new File(config.getRealmDirectory(), REALM_NAME)));
 
         // 4. Try to open the file again with the new password
         // If the configuration cache wasn't cleared this would fail as we would detect two
@@ -263,9 +266,9 @@ public void releaseCacheInOneThread() {
         Realm realmA = RealmCache.createRealmOrGetFromCache(defaultConfig, Realm.class);
         Realm realmB = RealmCache.createRealmOrGetFromCache(defaultConfig, Realm.class);
         RealmCache.release(realmA);
-        assertNotNull(realmA.sharedGroupManager);
+        assertNotNull(realmA.sharedRealm);
         RealmCache.release(realmB);
-        assertNull(realmB.sharedGroupManager);
+        assertNull(realmB.sharedRealm);
         // No crash but warning in the log
         RealmCache.release(realmB);
 
@@ -275,9 +278,9 @@ public void releaseCacheInOneThread() {
         DynamicRealm dynamicRealmB = RealmCache.createRealmOrGetFromCache(defaultConfig,
                 DynamicRealm.class);
         RealmCache.release(dynamicRealmA);
-        assertNotNull(dynamicRealmA.sharedGroupManager);
+        assertNotNull(dynamicRealmA.sharedRealm);
         RealmCache.release(dynamicRealmB);
-        assertNull(dynamicRealmB.sharedGroupManager);
+        assertNull(dynamicRealmB.sharedRealm);
         // No crash but warning in the log
         RealmCache.release(dynamicRealmB);
 
@@ -285,8 +288,8 @@ public void releaseCacheInOneThread() {
         realmA = RealmCache.createRealmOrGetFromCache(defaultConfig, Realm.class);
         dynamicRealmA = RealmCache.createRealmOrGetFromCache(defaultConfig, DynamicRealm.class);
         RealmCache.release(realmA);
-        assertNull(realmA.sharedGroupManager);
+        assertNull(realmA.sharedRealm);
         RealmCache.release(dynamicRealmA);
-        assertNull(realmA.sharedGroupManager);
+        assertNull(realmA.sharedRealm);
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java
index 4778fbe2e9..b058f3357a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java
@@ -98,6 +98,7 @@ public void onChange(DynamicRealm dynRealm) {
     public void returnedRealmResultsIsNotNull() {
         Realm realm = looperThread.realm;
         RealmResults<Cat> cats = realm.where(Cat.class).findAll();
+        looperThread.keepStrongReference.add(cats);
         cats.addChangeListener(new RealmChangeListener<RealmResults<Cat>>() {
             @Override
             public void onChange(RealmResults<Cat> result) {
@@ -116,6 +117,7 @@ public void onChange(RealmResults<Cat> result) {
     public void returnedRealmResultsOfModelIsNotNull() {
         Realm realm = looperThread.realm;
         RealmResults<AllTypesRealmModel> alltypes = realm.where(AllTypesRealmModel.class).findAll();
+        looperThread.keepStrongReference.add(alltypes);
         alltypes.addChangeListener(new RealmChangeListener<RealmResults<AllTypesRealmModel>>() {
             @Override
             public void onChange(RealmResults<AllTypesRealmModel> result) {
@@ -125,7 +127,7 @@ public void onChange(RealmResults<AllTypesRealmModel> result) {
         });
 
         realm.beginTransaction();
-        AllTypesRealmModel model = realm.createObject(AllTypesRealmModel.class);
+        AllTypesRealmModel model = realm.createObject(AllTypesRealmModel.class, 0);
         model.columnString = "data 1";
         realm.commitTransaction();
     }
@@ -139,6 +141,7 @@ public void returnedRealmObjectIsNotNull() {
         Cat cat = looperThread.realm.createObject(Cat.class);
         realm.commitTransaction();
 
+        looperThread.keepStrongReference.add(cat);
         cat.addChangeListener(new RealmChangeListener<Cat>() {
             @Override
             public void onChange(Cat object) {
@@ -157,9 +160,10 @@ public void onChange(Cat object) {
     public void returnedRealmModelIsNotNull() {
         Realm realm = looperThread.realm;
         realm.beginTransaction();
-        AllTypesRealmModel model = realm.createObject(AllTypesRealmModel.class);
+        AllTypesRealmModel model = realm.createObject(AllTypesRealmModel.class, 0);
         realm.commitTransaction();
 
+        looperThread.keepStrongReference.add(model);
         RealmObject.addChangeListener(model, new RealmChangeListener<AllTypesRealmModel>() {
             @Override
             public void onChange(AllTypesRealmModel object) {
@@ -184,6 +188,7 @@ public void returnedDynamicRealmObjectIsNotNull() {
         DynamicRealmObject allTypes = dynamicRealm.createObject(AllTypes.CLASS_NAME);
         dynamicRealm.commitTransaction();
 
+        looperThread.keepStrongReference.add(allTypes);
         allTypes.addChangeListener(new RealmChangeListener<DynamicRealmObject>() {
             @Override
             public void onChange(DynamicRealmObject object) {
@@ -205,6 +210,7 @@ public void returnedDynamicRealmResultsIsNotNull() {
 
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.realmConfiguration);
         RealmResults<DynamicRealmObject> all = dynamicRealm.where(AllTypes.CLASS_NAME).findAll();
+        looperThread.keepStrongReference.add(all);
         all.addChangeListener(new RealmChangeListener<RealmResults<DynamicRealmObject>>() {
             @Override
             public void onChange(RealmResults<DynamicRealmObject> result) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
index 4daa4e751c..1fcc0c64df 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
@@ -137,7 +137,7 @@ public void tearDown() {
         switch (collectionClass) {
             case MANAGED_REALMLIST:
                 realm.beginTransaction();
-                NullTypes obj = realm.createObject(NullTypes.class);
+                NullTypes obj = realm.createObject(NullTypes.class, 0);
                 realm.commitTransaction();
                 return obj.getFieldListNull();
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
index d799572319..3237aab39d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
@@ -20,6 +20,7 @@
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
 import android.content.Context;
@@ -35,6 +36,7 @@
 import io.realm.entities.AllTypes;
 import io.realm.entities.AllTypesPrimaryKey;
 import io.realm.entities.AnimalModule;
+import io.realm.entities.AssetFileModule;
 import io.realm.entities.Cat;
 import io.realm.entities.CatOwner;
 import io.realm.entities.CyclicType;
@@ -42,7 +44,7 @@
 import io.realm.entities.HumanModule;
 import io.realm.entities.Owner;
 import io.realm.exceptions.RealmException;
-import io.realm.exceptions.RealmIOException;
+import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.modules.CompositeMediator;
 import io.realm.internal.modules.FilterableMediator;
@@ -69,11 +71,16 @@
     @Rule
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
 
-    RealmConfiguration defaultConfig;
-    Realm realm;
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private Context context;
+    private  RealmConfiguration defaultConfig;
+    private Realm realm;
 
     @Before
     public void setUp() {
+        context = InstrumentationRegistry.getTargetContext();
         defaultConfig = configFactory.createConfiguration();
     }
 
@@ -120,40 +127,42 @@ public void getInstance_nullConfigThrows() {
     }
 
     @Test
-    public void constructBuilder_nullDirThrows() {
+    public void constructBuilder_nullNameThrows() {
         try {
-            new RealmConfiguration.Builder((File) null).build();
+            new RealmConfiguration.Builder(context).name(null);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
     }
 
     @Test
-    public void constructBuilder_createSubFoldersThrows() {
-        File folder = new File(configFactory.getRoot() + "/subfolder1/subfolder2/");
+    public void constructBuilder_emptyNameThrows() {
         try {
-            new RealmConfiguration.Builder(folder).build();
-            fail("Assuming that sub folders are created automatically should fail.");
+            new RealmConfiguration.Builder(context).name("");
+            fail();
         } catch (IllegalArgumentException ignored) {
         }
     }
 
+    @Test(expected = IllegalArgumentException.class)
+    public void directory_null() {
+        new RealmConfiguration.Builder(context).directory(null);
+    }
+
     @Test
-    public void constructBuilder_nullNameThrows() {
-        try {
-            new RealmConfiguration.Builder(configFactory.getRoot()).name(null).build();
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
+    public void directory_writeProtectedDir() {
+        File dir = new File("/");
+        thrown.expect(IllegalArgumentException.class);
+        new RealmConfiguration.Builder(context).directory(dir);
     }
 
     @Test
-    public void constructBuilder_emptyNameThrows() {
-        try {
-            new RealmConfiguration.Builder(configFactory.getRoot()).name("").build();
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
+    public void directory_dirIsAFile() throws IOException {
+        File dir = configFactory.getRoot();
+        File file = new File(dir, "dummyfile");
+        assertTrue(file.createNewFile());
+        thrown.expect(IllegalArgumentException.class);
+        new RealmConfiguration.Builder(context).directory(file);
     }
 
     @Test
@@ -172,7 +181,7 @@ public void getInstance_idForHashCollision() {
     @Test
     public void constructBuilder_nullKeyThrows() {
         try {
-            new RealmConfiguration.Builder(configFactory.getRoot()).encryptionKey(null).build();
+            new RealmConfiguration.Builder(context).encryptionKey(null);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -187,7 +196,7 @@ public void constructBuilder_wrongKeyLengthThrows() {
         };
         for (byte[] key : wrongKeys) {
             try {
-                new RealmConfiguration.Builder(configFactory.getRoot()).encryptionKey(key).build();
+                new RealmConfiguration.Builder(context).encryptionKey(key);
                 fail("Key with length " + key.length + " should throw an exception");
             } catch (IllegalArgumentException ignored) {
             }
@@ -197,7 +206,7 @@ public void constructBuilder_wrongKeyLengthThrows() {
     @Test
     public void constructBuilder_negativeVersionThrows() {
         try {
-            new RealmConfiguration.Builder(configFactory.getRoot()).schemaVersion(-1).build();
+            new RealmConfiguration.Builder(context).schemaVersion(-1);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -205,14 +214,19 @@ public void constructBuilder_negativeVersionThrows() {
 
     @Test
     public void constructBuilder_versionLessThanDiscVersionThrows() {
-        realm = Realm.getInstance(new RealmConfiguration.Builder(configFactory.getRoot()).schemaVersion(42).build());
+        realm = Realm.getInstance(new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .schemaVersion(42)
+                .build());
         realm.close();
 
         int[] wrongVersions = new int[] { 0, 1, 41 };
         for (int version : wrongVersions) {
             try {
-                realm = Realm.getInstance(new RealmConfiguration.Builder(configFactory.getRoot())
-                        .schemaVersion(version).build());
+                realm = Realm.getInstance(new RealmConfiguration.Builder(context)
+                        .directory(configFactory.getRoot())
+                        .schemaVersion(version)
+                        .build());
                 fail("Version " + version + " should throw an exception");
             } catch (IllegalArgumentException ignored) {
             }
@@ -222,14 +236,20 @@ public void constructBuilder_versionLessThanDiscVersionThrows() {
     @Test
     public void constructBuilder_versionEqualWhenSchemaChangesThrows() {
         // Create initial Realm
-        RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot())
-                .schemaVersion(42).schema(Dog.class).build();
+        RealmConfiguration config = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .schemaVersion(42)
+                .schema(Dog.class)
+                .build();
         Realm.getInstance(config).close();
 
         // Create new instance with a configuration containing another schema
         try {
-            config = new RealmConfiguration.Builder(configFactory.getRoot())
-                    .schemaVersion(42).schema(AllTypesPrimaryKey.class).build();
+            config = new RealmConfiguration.Builder(context)
+                    .directory(configFactory.getRoot())
+                    .schemaVersion(42)
+                    .schema(AllTypesPrimaryKey.class)
+                    .build();
             realm = Realm.getInstance(config);
             fail("A migration should be required");
         } catch (RealmMigrationNeededException ignored) {
@@ -238,7 +258,10 @@ public void constructBuilder_versionEqualWhenSchemaChangesThrows() {
 
     @Test
     public void customSchemaDontIncludeLinkedClasses() {
-        RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot()).schema(Dog.class).build();
+        RealmConfiguration config = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .schema(Dog.class)
+                .build();
         realm = Realm.getInstance(config);
         try {
             assertEquals(3, realm.getTable(Owner.class).getColumnCount());
@@ -250,24 +273,24 @@ public void customSchemaDontIncludeLinkedClasses() {
     @Test
     public void migration_nullThrows() {
         try {
-            new RealmConfiguration.Builder(configFactory.getRoot()).migration(null).build();
+            new RealmConfiguration.Builder(context).migration(null).build();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
     }
 
     @Test
-    public void setModules_nonRealmModulesThrows() {
+    public void modules_nonRealmModulesThrows() {
         // Test first argument
         try {
-            new RealmConfiguration.Builder(configFactory.getRoot()).modules(new Object());
+            new RealmConfiguration.Builder(context).modules(new Object());
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
         // Test second argument
         try {
-            new RealmConfiguration.Builder(configFactory.getRoot()).modules(Realm.getDefaultModule(), new Object());
+            new RealmConfiguration.Builder(context).modules(Realm.getDefaultModule(), new Object());
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -275,8 +298,10 @@ public void setModules_nonRealmModulesThrows() {
 
     @Test
     public void modules() {
-        RealmConfiguration realmConfig = new RealmConfiguration.Builder(configFactory.getRoot())
-                .modules(Realm.getDefaultModule(), (Object) null).build();
+        RealmConfiguration realmConfig = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .modules(Realm.getDefaultModule(), (Object) null)
+                .build();
         realm = Realm.getInstance(realmConfig);
         assertNotNull(realm.getTable(AllTypes.class));
     }
@@ -297,7 +322,8 @@ public void getInstance() {
 
     @Test
     public void standardSetup() {
-        RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot())
+        RealmConfiguration config = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
                 .name("foo.realm")
                 .encryptionKey(TestHelper.getRandomKey())
                 .schemaVersion(42)
@@ -319,7 +345,8 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
     @Test
     public void deleteRealmIfMigrationNeeded() {
         // Populate v0 of a Realm with an object
-        RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot())
+        RealmConfiguration config = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
                 .schema(Dog.class)
                 .schemaVersion(0)
                 .build();
@@ -332,7 +359,8 @@ public void deleteRealmIfMigrationNeeded() {
         realm.close();
 
         // Change schema and verify that Realm has been cleared
-        config = new RealmConfiguration.Builder(configFactory.getRoot())
+        config = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
                 .schema(Owner.class, Dog.class)
                 .schemaVersion(1)
                 .deleteRealmIfMigrationNeeded()
@@ -341,6 +369,23 @@ public void deleteRealmIfMigrationNeeded() {
         assertEquals(0, realm.where(Dog.class).count());
     }
 
+    @Test
+    public void deleteRealmIfMigrationNeeded_failsWhenAssetFileProvided() {
+        Context context = InstrumentationRegistry.getInstrumentation().getContext();
+
+        // have a builder instance to isolate codepath
+        RealmConfiguration.Builder builder = new RealmConfiguration.Builder(context);
+        try {
+            builder
+                .assetFile("asset_file.realm")
+                .deleteRealmIfMigrationNeeded();
+            fail();
+        } catch (IllegalStateException expected) {
+            assertEquals("Realm cannot clear its schema when previously configured to use an asset file by calling assetFile().",
+                    expected.getMessage());
+        }
+    }
+
     @Test
     public void upgradeVersionWithNoMigration() {
         realm = Realm.getInstance(defaultConfig);
@@ -349,8 +394,10 @@ public void upgradeVersionWithNoMigration() {
 
         // Version upgrades should always require a migration.
         try {
-            realm = Realm.getInstance(new RealmConfiguration.Builder(configFactory.getRoot())
-                    .schemaVersion(42).build());
+            realm = Realm.getInstance(new RealmConfiguration.Builder(context)
+                    .directory(configFactory.getRoot())
+                    .schemaVersion(42)
+                    .build());
             fail();
         } catch (RealmMigrationNeededException ignored) {
         }
@@ -358,35 +405,37 @@ public void upgradeVersionWithNoMigration() {
 
     @Test
     public void equals() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context).build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context).build();
         assertTrue(config1.equals(config2));
     }
 
     @Test
     public void equalsWhenRxJavaUnavailable() {
         // test for https://github.com/realm/realm-java/issues/2416
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build();
         TestHelper.emulateRxJavaUnavailable(config1);
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build();
         TestHelper.emulateRxJavaUnavailable(config2);
         assertTrue(config1.equals(config2));
     }
 
     @Test
     public void hashCode_Test() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build();
         assertEquals(config1.hashCode(), config2.hashCode());
     }
 
     @Test
     public void equals_withCustomModules() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot())
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
                 .modules(new HumanModule(), new AnimalModule())
                 .build();
 
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot())
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
                 .modules(new AnimalModule(), new HumanModule())
                 .build();
 
@@ -395,10 +444,12 @@ public void equals_withCustomModules() {
 
     @Test
     public void hashCode_withCustomModules() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot())
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
                 .modules(new HumanModule(), new AnimalModule())
                 .build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot())
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
                 .modules(new AnimalModule(), new HumanModule())
                 .build();
 
@@ -407,10 +458,12 @@ public void hashCode_withCustomModules() {
 
     @Test
     public void hashCode_withDifferentRxObservableFactory() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot())
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
                 .rxFactory(new RealmObservableFactory())
                 .build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot())
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
                 .rxFactory(new RealmObservableFactory() {
                     @Override
                     public int hashCode() {
@@ -424,8 +477,8 @@ public int hashCode() {
 
     @Test
     public void equals_configurationsReturnCachedRealm() {
-        Realm realm1 = Realm.getInstance(new RealmConfiguration.Builder(configFactory.getRoot()).build());
-        Realm realm2 = Realm.getInstance(new RealmConfiguration.Builder(configFactory.getRoot()).build());
+        Realm realm1 = Realm.getInstance(new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build());
+        Realm realm2 = Realm.getInstance(new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build());
         try {
             assertEquals(realm1, realm2);
         } finally {
@@ -436,8 +489,8 @@ public void equals_configurationsReturnCachedRealm() {
 
     @Test
     public void schemaVersion_differentVersionsThrows() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot()).schemaVersion(1).build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot()).schemaVersion(2).build();
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).schemaVersion(1).build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).schemaVersion(2).build();
 
         Realm realm1 = Realm.getInstance(config1);
         try {
@@ -451,10 +504,14 @@ public void schemaVersion_differentVersionsThrows() {
 
     @Test
     public void encryptionKey_differentEncryptionKeysThrows() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot())
-                .encryptionKey(TestHelper.getRandomKey()).build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot())
-                .encryptionKey(TestHelper.getRandomKey()).build();
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .encryptionKey(TestHelper.getRandomKey())
+                .build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .encryptionKey(TestHelper.getRandomKey())
+                .build();
 
         Realm realm1 = Realm.getInstance(config1);
         try {
@@ -468,9 +525,12 @@ public void encryptionKey_differentEncryptionKeysThrows() {
 
     @Test
     public void schema_differentSchemasThrows() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot())
-                .schema(AllTypes.class).build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot())
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .schema(AllTypes.class)
+                .build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
                 .schema(CyclicType.class).build();
 
         Realm realm1 = Realm.getInstance(config1);
@@ -486,8 +546,13 @@ public void schema_differentSchemasThrows() {
     // Creating Realm instances with same name but different durabilities is not allowed.
     @Test
     public void inMemory_differentDurabilityThrows() {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot()).inMemory().build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .inMemory()
+                .build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .build();
 
         // Create In-memory Realm first.
         Realm realm1 = Realm.getInstance(config1);
@@ -515,8 +580,8 @@ public void inMemory_differentDurabilityThrows() {
     // It is allowed to create multiple Realm with same name but in different directory
     @Test
     public void constructBuilder_differentDirSameName() throws IOException {
-        RealmConfiguration config1 = new RealmConfiguration.Builder(configFactory.getRoot()).build();
-        RealmConfiguration config2 = new RealmConfiguration.Builder(configFactory.newFolder()).build();
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context).directory(configFactory.getRoot()).build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context).directory(configFactory.newFolder()).build();
 
         Realm realm1 = Realm.getInstance(config1);
         Realm realm2 = Realm.getInstance(config2);
@@ -529,7 +594,10 @@ public void encryptionKey_keyStorage() throws Exception {
         // Generate a key and use it in a RealmConfiguration
         byte[] oldKey = TestHelper.getRandomKey(12345);
         byte[] key = oldKey;
-        RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot()).encryptionKey(key).build();
+        RealmConfiguration config = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .encryptionKey(key)
+                .build();
 
         // Generate a different key and assign it to the same variable
         byte[] newKey = TestHelper.getRandomKey(67890);
@@ -559,8 +627,10 @@ public void modelClassesForDefaultMediator() throws Exception {
 
     @Test
     public void modelClasses_forGeneratedMediator() throws Exception {
-        final RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot())
-                .modules(new HumanModule()).build();
+        final RealmConfiguration config = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .modules(new HumanModule())
+                .build();
         assertTrue(config.getSchemaMediator() instanceof HumanModuleMediator);
 
         final Set<Class<? extends RealmModel>> realmClasses = config.getRealmObjectClasses();
@@ -579,8 +649,10 @@ public void modelClasses_forGeneratedMediator() throws Exception {
 
     @Test
     public void modelClasses_forCompositeMediator() throws Exception {
-        final RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot())
-                .modules(new HumanModule(), new AnimalModule()).build();
+        final RealmConfiguration config = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .modules(new HumanModule(), new AnimalModule())
+                .build();
         assertTrue(config.getSchemaMediator() instanceof CompositeMediator);
 
         final Set<Class<? extends RealmModel>> realmClasses = config.getRealmObjectClasses();
@@ -600,8 +672,10 @@ public void modelClasses_forCompositeMediator() throws Exception {
     @Test
     public void modelClasses_forFilterableMediator() throws Exception {
         //noinspection unchecked
-        final RealmConfiguration config = new RealmConfiguration.Builder(configFactory.getRoot())
-                .schema(AllTypes.class, CatOwner.class).build();
+        final RealmConfiguration config = new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .schema(AllTypes.class, CatOwner.class)
+                .build();
         assertTrue(config.getSchemaMediator() instanceof FilterableMediator);
 
         final Set<Class<? extends RealmModel>> realmClasses = config.getRealmObjectClasses();
@@ -771,6 +845,7 @@ public void initialDataTransactionAssetFile() throws IOException {
 
         Realm.Transaction transaction = mock(Realm.Transaction.class);
         RealmConfiguration configuration = configFactory.createConfigurationBuilder()
+                .modules(new AssetFileModule())
                 .initialData(transaction)
                 .build();
 
@@ -781,15 +856,14 @@ public void initialDataTransactionAssetFile() throws IOException {
 
     @Test
     public void assetFileNullAndEmptyFileName() {
-        Context context = InstrumentationRegistry.getInstrumentation().getContext();
         try {
-            new RealmConfiguration.Builder(context).assetFile(context, null).build();
+            new RealmConfiguration.Builder(context).assetFile(null).build();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
         try {
-            new RealmConfiguration.Builder(context).assetFile(context, "").build();
+            new RealmConfiguration.Builder(context).assetFile("").build();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -797,13 +871,11 @@ public void assetFileNullAndEmptyFileName() {
 
     @Test
     public void assetFileWithInMemoryConfig() {
-        Context context = InstrumentationRegistry.getInstrumentation().getContext();
-
         // Ensure that there is no data
         Realm.deleteRealm(new RealmConfiguration.Builder(context).build());
 
         try {
-            new RealmConfiguration.Builder(context).assetFile(context, "asset_file.realm").inMemory().build();
+            new RealmConfiguration.Builder(context).assetFile("asset_file.realm").inMemory().build();
             fail();
         } catch (RealmException ignored) {
         }
@@ -811,27 +883,27 @@ public void assetFileWithInMemoryConfig() {
 
     @Test
     public void assetFileFakeFile() {
-        Context context = InstrumentationRegistry.getInstrumentation().getContext();
-
         // Ensure that there is no data
         Realm.deleteRealm(new RealmConfiguration.Builder(context).build());
 
-        RealmConfiguration configuration = new RealmConfiguration.Builder(context).assetFile(context, "no_file").build();
+        RealmConfiguration configuration = new RealmConfiguration.Builder(context).assetFile("no_file").build();
         try {
             Realm.getInstance(configuration);
             fail();
-        } catch (RealmIOException ignored) {
+        } catch (RealmFileException expected) {
+            assertEquals(expected.getKind(), RealmFileException.Kind.ACCESS_ERROR);
         }
     }
 
     @Test
     public void assetFileValidFile() throws IOException {
-        Context context = InstrumentationRegistry.getInstrumentation().getContext();
-
         // Ensure that there is no data
         Realm.deleteRealm(new RealmConfiguration.Builder(context).build());
 
-        RealmConfiguration configuration = new RealmConfiguration.Builder(context).assetFile(context, "asset_file.realm")
+        RealmConfiguration configuration = new RealmConfiguration
+                .Builder(context)
+                .modules(new AssetFileModule())
+                .assetFile("asset_file.realm")
                 .build();
         Realm.deleteRealm(configuration);
 
@@ -856,6 +928,23 @@ public void assetFileValidFile() throws IOException {
         assertFalse(realmFile.exists());
     }
 
+    @Test
+    public void assetFile_failsWhenDeleteRealmIfMigrationNeededConfigured() {
+        Context context = InstrumentationRegistry.getInstrumentation().getContext();
+
+        // have a builder instance to isolate codepath
+        RealmConfiguration.Builder builder = new RealmConfiguration.Builder(context);
+        try {
+            builder
+                    .deleteRealmIfMigrationNeeded()
+                    .assetFile("asset_file.realm");
+            fail();
+        } catch (IllegalStateException expected) {
+            assertEquals("Realm cannot use an asset file when previously configured to clear its schema in migration by calling deleteRealmIfMigrationNeeded().",
+                    expected.getMessage());
+        }
+    }
+
     private static class MigrationWithNoEquals implements RealmMigration {
         @Override
         public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java b/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
index a2ed08b3e1..c1a572e9c6 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
@@ -28,6 +28,7 @@
 import java.util.concurrent.TimeUnit;
 
 import io.realm.entities.Dog;
+import io.realm.exceptions.RealmFileException;
 
 public class RealmInMemoryTest extends AndroidTestCase {
 
@@ -127,7 +128,7 @@ public void testDelete() {
     }
 
     // Test if an in-memory Realm can be written to disk with/without encryption
-    public void testWriteCopyTo() throws IOException {
+    public void testWriteCopyTo() {
         byte[] key = TestHelper.getRandomKey();
         String fileName = IDENTIFIER + ".realm";
         String encFileName = IDENTIFIER + ".enc.realm";
@@ -165,8 +166,9 @@ public void testWriteCopyTo() throws IOException {
                     .encryptionKey(TestHelper.getRandomKey(42))
                     .build();
             Realm.getInstance(wrongKeyConf);
-            fail("Realm.getInstance should fail with illegal argument");
-        } catch (IllegalArgumentException ignored) {
+            fail("Realm.getInstance should fail with RealmFileException");
+        } catch (RealmFileException expected) {
+            assertEquals(expected.getKind(), RealmFileException.Kind.ACCESS_ERROR);
         }
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonAbsentPrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonAbsentPrimaryKeyTests.java
new file mode 100644
index 0000000000..c985be7e62
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonAbsentPrimaryKeyTests.java
@@ -0,0 +1,161 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.io.IOException;
+import java.util.Arrays;
+
+import io.realm.entities.PrimaryKeyAsBoxedByte;
+import io.realm.entities.PrimaryKeyAsBoxedInteger;
+import io.realm.entities.PrimaryKeyAsBoxedLong;
+import io.realm.entities.PrimaryKeyAsBoxedShort;
+import io.realm.entities.PrimaryKeyAsString;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+@RunWith(Parameterized.class)
+public class RealmJsonAbsentPrimaryKeyTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    protected Realm realm;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    // parameters for testing absent primary key value. PrimaryKey field is absent.
+    @Parameterized.Parameters
+    public static Iterable<Object[]> data() {
+        return Arrays.asList(new Object[][]{
+            {PrimaryKeyAsBoxedByte.class,    "{ \"name\":\"HaHaHaHaHaHaHaHaH\" }"},
+            {PrimaryKeyAsBoxedShort.class,   "{ \"name\":\"KeyValueTestIsFun\" }"},
+            {PrimaryKeyAsBoxedInteger.class, "{ \"name\":\"FunValueTestIsKey\" }"},
+            {PrimaryKeyAsBoxedLong.class,    "{ \"name\":\"NameAsBoxedLong-!\" }"},
+            {PrimaryKeyAsString.class,       "{ \"id\":2429214 }"}
+        });
+    }
+
+    final private Class<? extends RealmObject> clazz;
+    final private String jsonString;
+
+    public RealmJsonAbsentPrimaryKeyTests(Class<? extends RealmObject> clazz, String jsonString) {
+        this.jsonString = jsonString;
+        this.clazz = clazz;
+    }
+
+    // Testing absent primary key value for createObjectFromJson()
+    @Test
+    public void createObjectFromJson_primaryKey_isAbsent_fromJsonObject() throws JSONException {
+        realm.beginTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        realm.createObjectFromJson(clazz, new JSONObject(jsonString));
+        realm.commitTransaction();
+    }
+
+    // Testing absent primary key value for createOrUpdateObjectFromJson()
+    @Test
+    public void createOrUpdateObjectFromJson_primaryKey_isAbsent_fromJsonObject() throws JSONException {
+        realm.beginTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        realm.createOrUpdateObjectFromJson(clazz, new JSONObject(jsonString));
+        realm.commitTransaction();
+    }
+
+    // Testing absent primary key value for createAllFromJson()
+    @Test
+    public void createAllFromJson_primaryKey_isAbsent_fromJsonObject() throws JSONException {
+        JSONArray jsonArray = new JSONArray();
+        jsonArray.put(new JSONObject(jsonString));
+        realm.beginTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        realm.createAllFromJson(clazz, jsonArray);
+        realm.commitTransaction();
+    }
+
+    // Testing absent primary key value for createOrUpdateAllFromJson()
+    @Test
+    public void createOrUpdateAllFromJson_primaryKey_isAbsent_fromJsonObject() throws JSONException {
+        JSONArray jsonArray = new JSONArray();
+        jsonArray.put(new JSONObject(jsonString));
+        realm.beginTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        realm.createOrUpdateAllFromJson(clazz, jsonArray);
+        realm.commitTransaction();
+    }
+
+    // Testing absent primary key value for createObjectFromJson() stream version
+    @Test
+    public void createObjectFromJson_primaryKey_isAbsent_fromJsonStream() throws JSONException, IOException {
+        realm.beginTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        realm.createObjectFromJson(clazz, TestHelper.stringToStream(jsonString));
+        realm.commitTransaction();
+    }
+
+    // Testing absent primary key value for createOrUpdateObjectFromJson() stream version
+    @Test
+    public void createOrUpdateObjectFromJson_primaryKey_isAbsent_fromJsonStream() throws JSONException, IOException {
+        realm.beginTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        realm.createOrUpdateObjectFromJson(clazz, TestHelper.stringToStream(jsonString));
+        realm.commitTransaction();
+    }
+
+    // Testing absent primary key value for createAllFromJson() stream version
+    @Test
+    public void createAllFromJson_primaryKey_isAbsent_fromJsonStream() throws JSONException, IOException {
+        JSONArray jsonArray = new JSONArray();
+        jsonArray.put(new JSONObject(jsonString));
+        realm.beginTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        realm.createAllFromJson(clazz, TestHelper.stringToStream(jsonArray.toString()));
+        realm.commitTransaction();
+    }
+
+    // Testing absent primary key value for createOrUpdateAllFromJson() stream version
+    @Test
+    public void createOrUpdateAllFromJson_primaryKey_isAbsent_fromJsonStream() throws JSONException, IOException {
+        JSONArray jsonArray = new JSONArray();
+        jsonArray.put(new JSONObject(jsonString));
+        realm.beginTransaction();
+        thrown.expect(IllegalArgumentException.class);
+        realm.createOrUpdateAllFromJson(clazz, TestHelper.stringToStream(jsonArray.toString()));
+        realm.commitTransaction();
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java
index c5482eb151..f0345f07bd 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonNullPrimaryKeyTests.java
@@ -57,7 +57,7 @@ public void tearDown() {
         }
     }
 
-    // parameters for testing null primary key value. PrimaryKey field is explicitly null or absent.
+    // parameters for testing null primary key value. PrimaryKey field is explicitly null
     @Parameterized.Parameters
     public static Iterable<Object[]> data() {
         return Arrays.asList(new Object[][]{
@@ -65,12 +65,7 @@ public void tearDown() {
             {PrimaryKeyAsBoxedShort.class,   "YouBetItIsNullKey", "{ \"id\":null, \"name\":\"YouBetItIsNullKey\" }"},
             {PrimaryKeyAsBoxedInteger.class, "Gosh Didnt KnowIt", "{ \"id\":null, \"name\":\"Gosh Didnt KnowIt\" }"},
             {PrimaryKeyAsBoxedLong.class,    "?YOUNOWKNOWRIGHT?", "{ \"id\":null, \"name\":\"?YOUNOWKNOWRIGHT?\" }"},
-            {PrimaryKeyAsBoxedByte.class,    "HaHaHaHaHaHaHaHaH", "{ \"name\":\"HaHaHaHaHaHaHaHaH\" }"},
-            {PrimaryKeyAsBoxedShort.class,   "KeyValueTestIsFun", "{ \"name\":\"KeyValueTestIsFun\" }"},
-            {PrimaryKeyAsBoxedInteger.class, "FunValueTestIsKey", "{ \"name\":\"FunValueTestIsKey\" }"},
-            {PrimaryKeyAsBoxedLong.class,    "NameAsBoxedLong-!", "{ \"name\":\"NameAsBoxedLong-!\" }"},
             {PrimaryKeyAsString.class,       "4299121",           "{ \"name\":null, \"id\":4299121  }"},
-            {PrimaryKeyAsString.class,       "2429214",           "{ \"id\":2429214 }"}
         });
     }
 
@@ -84,9 +79,9 @@ public RealmJsonNullPrimaryKeyTests(Class<? extends RealmObject> clazz, String s
         this.clazz = clazz;
     }
 
-    // Testing null or absent primary key value for createObjectFromJson()
+    // Testing null primary key value for createObjectFromJson()
     @Test
-    public void createObjectFromJson_primaryKey_isNullOrAbsent_fromJsonObject() throws JSONException {
+    public void createObjectFromJson_primaryKey_isNull_fromJsonObject() throws JSONException {
         realm.beginTransaction();
         realm.createObjectFromJson(clazz, new JSONObject(jsonString));
         realm.commitTransaction();
@@ -107,9 +102,9 @@ public void createObjectFromJson_primaryKey_isNullOrAbsent_fromJsonObject() thro
         }
     }
 
-    // Testing null or absent primary key value for createOrUpdateObjectFromJson()
+    // Testing null primary key value for createOrUpdateObjectFromJson()
     @Test
-    public void createOrUpdateObjectFromJson_primaryKey_isNullOrAbsent_fromJsonObject() throws JSONException {
+    public void createOrUpdateObjectFromJson_primaryKey_isNull_fromJsonObject() throws JSONException {
         realm.beginTransaction();
         realm.createOrUpdateObjectFromJson(clazz, new JSONObject(jsonString));
         realm.commitTransaction();
@@ -130,11 +125,11 @@ public void createOrUpdateObjectFromJson_primaryKey_isNullOrAbsent_fromJsonObjec
         }
     }
 
-    // Testing null or absent primary key value for createObject() -> createOrUpdateObjectFromJson()
+    // Testing null primary key value for createObject() -> createOrUpdateObjectFromJson()
     @Test
-    public void createOrUpdateObjectFromJson_primaryKey_isNullOrAbsent_updateFromJsonObject() throws JSONException {
+    public void createOrUpdateObjectFromJson_primaryKey_isNull_updateFromJsonObject() throws JSONException {
         realm.beginTransaction();
-        realm.createObject(clazz); // name = null, id = 0
+        realm.createObject(clazz, null); // name = null, id =null
         realm.createOrUpdateObjectFromJson(clazz, new JSONObject(jsonString));
         realm.commitTransaction();
 
@@ -144,7 +139,6 @@ public void createOrUpdateObjectFromJson_primaryKey_isNullOrAbsent_updateFromJso
             assertEquals(1, results.size());
             assertEquals(Long.valueOf(secondaryFieldValue).longValue(), results.first().getId());
             assertEquals(null, results.first().getName());
-
         // PrimaryKeyAsNumber
         } else {
             RealmResults results = realm.where(clazz).findAll();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
index fbcc2fdcf8..2f1219acd6 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
@@ -19,8 +19,11 @@
 import android.content.Context;
 import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
+import android.text.TextUtils;
 import android.util.Base64;
 
+import com.google.gson.internal.bind.util.ISO8601Utils;
+
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -42,10 +45,12 @@
 import io.realm.entities.AllTypes;
 import io.realm.entities.AllTypesPrimaryKey;
 import io.realm.entities.AnnotationTypes;
+import io.realm.entities.DefaultValueOfField;
 import io.realm.entities.Dog;
 import io.realm.entities.NoPrimaryKeyNullTypes;
 import io.realm.entities.NullTypes;
 import io.realm.entities.OwnerPrimaryKey;
+import io.realm.entities.RandomPrimaryKey;
 import io.realm.exceptions.RealmException;
 import io.realm.rule.TestRealmConfigurationFactory;
 
@@ -363,6 +368,220 @@ public void createAllFromJson_jsonArray() throws JSONException {
         assertEquals(1, realm.where(Dog.class).equalTo("name", "Fido-3").findAll().size());
     }
 
+    @Test
+    public void createFromJson_respectDefaultValues() throws JSONException {
+        final long fieldLongPrimaryKeyValue = DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE + 1;
+
+        // Step 1: Prepare almost empty JSON
+        final JSONObject json = new JSONObject();
+        json.put(DefaultValueOfField.FIELD_LONG_PRIMARY_KEY, fieldLongPrimaryKeyValue);
+
+        // Step 2: Update with almost empty JSONObject
+        realm.beginTransaction();
+        final DefaultValueOfField managedObj = realm.createOrUpdateObjectFromJson(DefaultValueOfField.class, json);
+        realm.commitTransaction();
+
+        // Step 3: Check that default values are applied
+        assertEquals(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE,
+                managedObj.getFieldIgnored());
+        assertEquals(DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE, managedObj.getFieldString());
+        assertFalse(TextUtils.isEmpty(managedObj.getFieldRandomString()));
+        assertEquals(DefaultValueOfField.FIELD_SHORT_DEFAULT_VALUE, managedObj.getFieldShort());
+        assertEquals(DefaultValueOfField.FIELD_INT_DEFAULT_VALUE, managedObj.getFieldInt());
+        assertEquals(fieldLongPrimaryKeyValue, managedObj.getFieldLongPrimaryKey());
+        assertEquals(DefaultValueOfField.FIELD_LONG_DEFAULT_VALUE, managedObj.getFieldLong());
+        assertEquals(DefaultValueOfField.FIELD_BYTE_DEFAULT_VALUE, managedObj.getFieldByte());
+        assertEquals(DefaultValueOfField.FIELD_FLOAT_DEFAULT_VALUE, managedObj.getFieldFloat(), 0f);
+        assertEquals(DefaultValueOfField.FIELD_DOUBLE_DEFAULT_VALUE, managedObj.getFieldDouble(), 0d);
+        assertEquals(DefaultValueOfField.FIELD_BOOLEAN_DEFAULT_VALUE, managedObj.isFieldBoolean());
+        assertEquals(DefaultValueOfField.FIELD_DATE_DEFAULT_VALUE, managedObj.getFieldDate());
+        assertTrue(Arrays.equals(DefaultValueOfField.FIELD_BINARY_DEFAULT_VALUE, managedObj.getFieldBinary()));
+        assertEquals(RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE, managedObj.getFieldObject().getFieldInt());
+        assertEquals(1, managedObj.getFieldList().size());
+        assertEquals(RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE, managedObj.getFieldList().first().getFieldInt());
+
+        // make sure that excess object by default value is not created.
+        assertEquals(2, realm.where(RandomPrimaryKey.class).count());
+    }
+
+    @Test
+    public void createFromJson_defaultValuesAreIgnored() throws JSONException {
+        final long fieldLongPrimaryKeyValue = DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE + 1;
+
+        // Step 1: Prepare JSON
+        final String fieldIgnoredValue = DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE + ".modified";
+        final String fieldStringValue = DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE + ".modified";
+        final String fieldRandomStringValue = "non-random";
+        final short fieldShortValue = (short) (DefaultValueOfField.FIELD_SHORT_DEFAULT_VALUE + 1);
+        final int fieldIntValue = DefaultValueOfField.FIELD_INT_DEFAULT_VALUE + 1;
+        final long fieldLongValue = DefaultValueOfField.FIELD_LONG_DEFAULT_VALUE + 1;
+        final byte fieldByteValue = (byte) (DefaultValueOfField.FIELD_BYTE_DEFAULT_VALUE + 1);
+        final float fieldFloatValue = DefaultValueOfField.FIELD_FLOAT_DEFAULT_VALUE + 1;
+        final double fieldDoubleValue = DefaultValueOfField.FIELD_DOUBLE_DEFAULT_VALUE + 1;
+        final boolean fieldBooleanValue = !DefaultValueOfField.FIELD_BOOLEAN_DEFAULT_VALUE;
+        final Date fieldDateValue = new Date(DefaultValueOfField.FIELD_DATE_DEFAULT_VALUE.getTime() + 1);
+        final byte[] fieldBinaryValue = {(byte) (DefaultValueOfField.FIELD_BINARY_DEFAULT_VALUE[0] - 1)};
+        final int fieldObjectIntValue = RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 1;
+        final int fieldListIntValue = RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 2;
+
+        final JSONObject json = new JSONObject();
+        json.put(DefaultValueOfField.FIELD_LONG_PRIMARY_KEY, fieldLongPrimaryKeyValue);
+        json.put(DefaultValueOfField.FIELD_IGNORED, fieldIgnoredValue);
+        json.put(DefaultValueOfField.FIELD_STRING, fieldStringValue);
+        json.put(DefaultValueOfField.FIELD_RANDOM_STRING, fieldRandomStringValue);
+        json.put(DefaultValueOfField.FIELD_SHORT, fieldShortValue);
+        json.put(DefaultValueOfField.FIELD_INT, fieldIntValue);
+        json.put(DefaultValueOfField.FIELD_LONG, fieldLongValue);
+        json.put(DefaultValueOfField.FIELD_BYTE, fieldByteValue);
+        json.put(DefaultValueOfField.FIELD_FLOAT, fieldFloatValue);
+        json.put(DefaultValueOfField.FIELD_DOUBLE, fieldDoubleValue);
+        json.put(DefaultValueOfField.FIELD_BOOLEAN, fieldBooleanValue);
+        json.put(DefaultValueOfField.FIELD_DATE, ISO8601Utils.format(fieldDateValue, true));
+        json.put(DefaultValueOfField.FIELD_BINARY, Base64.encodeToString(fieldBinaryValue, Base64.DEFAULT));
+        // value for 'fieldObject'
+        final JSONObject fieldObjectJson = new JSONObject();
+        fieldObjectJson.put(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY, "pk of fieldObject");
+        fieldObjectJson.put(RandomPrimaryKey.FIELD_INT, fieldObjectIntValue);
+        json.put(DefaultValueOfField.FIELD_OBJECT, fieldObjectJson);
+        // value for 'fieldList'
+        final JSONArray fieldListArrayJson = new JSONArray();
+        final JSONObject fieldListItem0Json = new JSONObject();
+        fieldListItem0Json.put(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY, "pk1 of fieldList");
+        fieldListItem0Json.put(RandomPrimaryKey.FIELD_INT, fieldListIntValue);
+        fieldListArrayJson.put(fieldListItem0Json);
+        final JSONObject fieldListItem1Json = new JSONObject();
+        fieldListItem1Json.put(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY, "pk2 of fieldList");
+        fieldListItem1Json.put(RandomPrimaryKey.FIELD_INT, fieldListIntValue + 1);
+        fieldListArrayJson.put(fieldListItem1Json);
+        json.put(DefaultValueOfField.FIELD_LIST, fieldListArrayJson);
+
+        // Step 3: Update with JSONObject
+        realm.beginTransaction();
+        final DefaultValueOfField managedObj = realm.createOrUpdateObjectFromJson(DefaultValueOfField.class, json);
+        realm.commitTransaction();
+
+        // Step 4: Check that properly created
+        assertEquals(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE/*not fieldIgnoredValue*/,
+                managedObj.getFieldIgnored());
+        assertEquals(fieldStringValue, managedObj.getFieldString());
+        assertEquals(fieldRandomStringValue, managedObj.getFieldRandomString());
+        assertEquals(fieldShortValue, managedObj.getFieldShort());
+        assertEquals(fieldIntValue, managedObj.getFieldInt());
+        assertEquals(fieldLongPrimaryKeyValue, managedObj.getFieldLongPrimaryKey());
+        assertEquals(fieldLongValue, managedObj.getFieldLong());
+        assertEquals(fieldByteValue, managedObj.getFieldByte());
+        assertEquals(fieldFloatValue, managedObj.getFieldFloat(), 0f);
+        assertEquals(fieldDoubleValue, managedObj.getFieldDouble(), 0d);
+        assertEquals(fieldBooleanValue, managedObj.isFieldBoolean());
+        assertEquals(fieldDateValue, managedObj.getFieldDate());
+        assertTrue(Arrays.equals(fieldBinaryValue, managedObj.getFieldBinary()));
+        assertEquals(fieldObjectJson.getString(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY),
+                managedObj.getFieldObject().getFieldRandomPrimaryKey());
+        assertEquals(fieldObjectIntValue, managedObj.getFieldObject().getFieldInt());
+        assertEquals(2, managedObj.getFieldList().size());
+        assertEquals(fieldListItem0Json.get(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY),
+                managedObj.getFieldList().get(0).getFieldRandomPrimaryKey());
+        assertEquals(fieldListIntValue, managedObj.getFieldList().get(0).getFieldInt());
+        assertEquals(fieldListItem1Json.get(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY),
+                managedObj.getFieldList().get(1).getFieldRandomPrimaryKey());
+        assertEquals(fieldListIntValue + 1, managedObj.getFieldList().get(1).getFieldInt());
+
+        // make sure that excess object by default value is not created.
+        assertEquals(3, realm.where(RandomPrimaryKey.class).count());
+    }
+
+    @Test
+    public void updateFromJson_defaultValuesAreIgnored() throws JSONException {
+        final long fieldLongPrimaryKeyValue = DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE + 1;
+
+        // Step 1: Create an object with default values
+        final DefaultValueOfField original;
+        realm.beginTransaction(); {
+            original = realm.createObject(DefaultValueOfField.class, fieldLongPrimaryKeyValue);
+        }
+        realm.commitTransaction();
+
+        // Step 2: Prepare JSON
+        final String fieldIgnoredValue = DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE + ".modified";
+        final String fieldStringValue = DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE + ".modified";
+        final String fieldRandomStringValue = "non-random";
+        final short fieldShortValue = (short) (DefaultValueOfField.FIELD_SHORT_DEFAULT_VALUE + 1);
+        final int fieldIntValue = DefaultValueOfField.FIELD_INT_DEFAULT_VALUE + 1;
+        final long fieldLongValue = DefaultValueOfField.FIELD_LONG_DEFAULT_VALUE + 1;
+        final byte fieldByteValue = (byte) (DefaultValueOfField.FIELD_BYTE_DEFAULT_VALUE + 1);
+        final float fieldFloatValue = DefaultValueOfField.FIELD_FLOAT_DEFAULT_VALUE + 1;
+        final double fieldDoubleValue = DefaultValueOfField.FIELD_DOUBLE_DEFAULT_VALUE + 1;
+        final boolean fieldBooleanValue = !DefaultValueOfField.FIELD_BOOLEAN_DEFAULT_VALUE;
+        final Date fieldDateValue = new Date(DefaultValueOfField.FIELD_DATE_DEFAULT_VALUE.getTime() + 1);
+        final byte[] fieldBinaryValue = {(byte) (DefaultValueOfField.FIELD_BINARY_DEFAULT_VALUE[0] - 1)};
+        final int fieldObjectIntValue = RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 1;
+        final int fieldListIntValue = RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 2;
+
+        final JSONObject json = new JSONObject();
+        json.put(DefaultValueOfField.FIELD_LONG_PRIMARY_KEY, fieldLongPrimaryKeyValue);
+        json.put(DefaultValueOfField.FIELD_IGNORED, fieldIgnoredValue);
+        json.put(DefaultValueOfField.FIELD_STRING, fieldStringValue);
+        json.put(DefaultValueOfField.FIELD_RANDOM_STRING, fieldRandomStringValue);
+        json.put(DefaultValueOfField.FIELD_SHORT, fieldShortValue);
+        json.put(DefaultValueOfField.FIELD_INT, fieldIntValue);
+        json.put(DefaultValueOfField.FIELD_LONG, fieldLongValue);
+        json.put(DefaultValueOfField.FIELD_BYTE, fieldByteValue);
+        json.put(DefaultValueOfField.FIELD_FLOAT, fieldFloatValue);
+        json.put(DefaultValueOfField.FIELD_DOUBLE, fieldDoubleValue);
+        json.put(DefaultValueOfField.FIELD_BOOLEAN, fieldBooleanValue);
+        json.put(DefaultValueOfField.FIELD_DATE, ISO8601Utils.format(fieldDateValue, true));
+        json.put(DefaultValueOfField.FIELD_BINARY, Base64.encodeToString(fieldBinaryValue, Base64.DEFAULT));
+        // value for 'fieldObject'
+        final JSONObject fieldObjectJson = new JSONObject();
+        fieldObjectJson.put(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY,
+                original.getFieldObject().getFieldRandomPrimaryKey());
+        fieldObjectJson.put(RandomPrimaryKey.FIELD_INT, fieldObjectIntValue);
+        json.put(DefaultValueOfField.FIELD_OBJECT, fieldObjectJson);
+        // value for 'fieldList'
+        final JSONArray fieldListArrayJson = new JSONArray();
+        final JSONObject fieldListItem0Json = new JSONObject(); // to be added
+        fieldListItem0Json.put(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY,  "unique value");
+        fieldListItem0Json.put(RandomPrimaryKey.FIELD_INT, fieldListIntValue);
+        fieldListArrayJson.put(fieldListItem0Json);
+        final JSONObject fieldListItem1Json = new JSONObject(); // to be updated
+        fieldListItem1Json.put(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY,
+                original.getFieldList().first().getFieldRandomPrimaryKey());
+        fieldListItem1Json.put(RandomPrimaryKey.FIELD_INT, fieldListIntValue + 1);
+        fieldListArrayJson.put(fieldListItem1Json);
+        json.put(DefaultValueOfField.FIELD_LIST, fieldListArrayJson);
+
+        // Step 3: Update with JSONObject
+        realm.beginTransaction();
+        final DefaultValueOfField managedObj = realm.createOrUpdateObjectFromJson(DefaultValueOfField.class, json);
+        realm.commitTransaction();
+
+        // Step 4: Check that properly updated
+        assertEquals(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE/*not fieldIgnoredValue*/,
+                managedObj.getFieldIgnored());
+        assertEquals(fieldStringValue, managedObj.getFieldString());
+        assertEquals(fieldRandomStringValue, managedObj.getFieldRandomString());
+        assertEquals(fieldShortValue, managedObj.getFieldShort());
+        assertEquals(fieldIntValue, managedObj.getFieldInt());
+        assertEquals(fieldLongPrimaryKeyValue, managedObj.getFieldLongPrimaryKey());
+        assertEquals(fieldLongValue, managedObj.getFieldLong());
+        assertEquals(fieldByteValue, managedObj.getFieldByte());
+        assertEquals(fieldFloatValue, managedObj.getFieldFloat(), 0f);
+        assertEquals(fieldDoubleValue, managedObj.getFieldDouble(), 0d);
+        assertEquals(fieldBooleanValue, managedObj.isFieldBoolean());
+        assertEquals(fieldDateValue, managedObj.getFieldDate());
+        assertTrue(Arrays.equals(fieldBinaryValue, managedObj.getFieldBinary()));
+        assertEquals(fieldObjectIntValue, managedObj.getFieldObject().getFieldInt());
+        assertEquals(2, managedObj.getFieldList().size());
+        assertEquals("unique value", managedObj.getFieldList().get(0).getFieldRandomPrimaryKey());
+        assertEquals(fieldListIntValue, managedObj.getFieldList().get(0).getFieldInt());
+        assertEquals(fieldListItem1Json.get(RandomPrimaryKey.FIELD_RANDOM_PRIMARY_KEY),
+                managedObj.getFieldList().get(1).getFieldRandomPrimaryKey());
+        assertEquals(fieldListIntValue + 1, managedObj.getFieldList().get(1).getFieldInt());
+
+        // make sure that excess object by default value is not created.
+        assertEquals(3/* 2 updated + 1 added*/, realm.where(RandomPrimaryKey.class).count());
+    }
+
     // Test if Json object doesn't have the field, then the field should have default value.
     @Test
     public void createObjectFromJson_noValues() throws JSONException {
@@ -396,6 +615,7 @@ public void createObjectFromJson_jsonException() throws JSONException {
         realm.beginTransaction();
         try {
             realm.createObjectFromJson(AllTypes.class, json);
+            fail();
         } catch (RealmException ignored) {
         } finally {
             realm.commitTransaction();
@@ -409,6 +629,7 @@ public void createObjectFromJson_jsonException() throws JSONException {
     @Test
     public void createObjectFromJson_respectIgnoredFields() throws JSONException {
         JSONObject json = new JSONObject();
+        json.put("id", 0);
         json.put("indexString", "Foo");
         json.put("notIndexString", "Bar");
         json.put("ignoreString", "Baz");
@@ -763,7 +984,7 @@ public void createOrUpdateObjectFromJson_inputStream() throws IOException {
     public void createOrUpdateObjectFromJson_objectWithPrimaryKeySetValueDirectlyFromStream() throws JSONException, IOException {
         InputStream stream = TestHelper.stringToStream("{\"id\": 1, \"name\": \"bar\"}");
         realm.beginTransaction();
-        realm.createObject(OwnerPrimaryKey.class); // id = 0
+        realm.createObject(OwnerPrimaryKey.class, 0); // id = 0
         realm.createOrUpdateObjectFromJson(OwnerPrimaryKey.class, stream);
         realm.commitTransaction();
 
@@ -961,7 +1182,7 @@ public void createOrUpdateObjectFromJson_invalidJsonObject() throws JSONExceptio
     public void createOrUpdateObjectFromJson_objectWithPrimaryKeySetValueDirectlyFromJsonObject() throws JSONException {
         JSONObject newObject = new JSONObject("{\"id\": 1, \"name\": \"bar\"}");
         realm.beginTransaction();
-        realm.createObject(OwnerPrimaryKey.class); // id = 0
+        realm.createObject(OwnerPrimaryKey.class, 0); // id = 0
         realm.createOrUpdateObjectFromJson(OwnerPrimaryKey.class, newObject);
         realm.commitTransaction();
 
@@ -1140,7 +1361,7 @@ public void createObjectFromJson_updateNullTypesJSONWithNulls() throws IOExcepti
 
         RealmResults<NullTypes> nullTypesRealmResults = realm.where(NullTypes.class).findAll();
         assertEquals(2, nullTypesRealmResults.size());
-        checkNullableValuesAreNotNull(nullTypesRealmResults.first());
+        checkNullableValuesAreNotNull(nullTypesRealmResults.where().equalTo("id", 1).findFirst());
 
         // Update object with id 1, nullable fields should have null values
         JSONArray array = new JSONArray(json);
@@ -1367,7 +1588,7 @@ public void createObjectFromJson_nullTypesJSONStreamToNotNullFields() throws IOE
     public void createObjectFromJson_objectWithPrimaryKeySetValueDirectlyFromJsonObject() throws JSONException {
         JSONObject newObject = new JSONObject("{\"id\": 1, \"name\": \"bar\"}");
         realm.beginTransaction();
-        realm.createObject(OwnerPrimaryKey.class); // id = 0
+        realm.createObject(OwnerPrimaryKey.class, 0); // id = 0
         realm.createObjectFromJson(OwnerPrimaryKey.class, newObject);
         realm.commitTransaction();
 
@@ -1393,7 +1614,7 @@ public void createObjectFromJson_objectNullClass() throws JSONException {
     public void createObjectFromJson_objectWithPrimaryKeySetValueDirectlyFromStream() throws JSONException, IOException {
         InputStream stream = TestHelper.stringToStream("{\"id\": 1, \"name\": \"bar\"}");
         realm.beginTransaction();
-        realm.createObject(OwnerPrimaryKey.class); // id = 0
+        realm.createObject(OwnerPrimaryKey.class, 0); // id = 0
         realm.createObjectFromJson(OwnerPrimaryKey.class, stream);
         realm.commitTransaction();
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
index 9f72d7d348..fd1af8a287 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
@@ -16,7 +16,13 @@
 
 package io.realm;
 
-import android.test.AndroidTestCase;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
 import java.util.Date;
 
@@ -24,16 +30,29 @@
 import io.realm.entities.Cat;
 import io.realm.entities.Dog;
 import io.realm.entities.Owner;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
 
-public class RealmLinkTests extends AndroidTestCase {
+@RunWith(AndroidJUnit4.class)
+public class RealmLinkTests {
 
-    protected Realm testRealm;
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
 
-    protected void setUp() {
-        RealmConfiguration realmConfig = TestHelper.createConfiguration(getContext());
-        Realm.deleteRealm(realmConfig);
+    private Realm testRealm;
+    private RealmConfiguration realmConfig;
+
+    @Before
+    public void setUp() {
+        realmConfig = configFactory.createConfiguration();
         testRealm = Realm.getInstance(realmConfig);
 
+        populate();
+    }
+
+    private void populate() {
         testRealm.beginTransaction();
         testRealm.delete(Dog.class);
         testRealm.delete(Cat.class);
@@ -76,12 +95,15 @@ protected void setUp() {
         testRealm.commitTransaction();
     }
 
-    @Override
-    protected void tearDown() throws Exception {
-        testRealm.close();
+    @After
+    public void tearDown() {
+        if (testRealm != null) {
+            testRealm.close();
+        }
     }
 
-    public void testObjects() {
+    @Test
+    public void objects() {
         RealmResults<Owner> owners = testRealm.where(Owner.class).findAll();
         assertEquals(1, owners.size());
         assertEquals(2, owners.first().getDogs().size());
@@ -102,7 +124,8 @@ public void testObjects() {
     }
 
 
-    public void testReamListQuery() {
+    @Test
+    public void reamListQuery() {
         RealmResults<Owner> owners = testRealm.where(Owner.class).findAll();
         RealmResults<Dog> dogs = owners.get(0).getDogs().where().contains("name", "o").findAll();
         assertEquals(2, dogs.size());
@@ -110,7 +133,8 @@ public void testReamListQuery() {
         assertEquals("Fido", dogs.get(1).getName());
     }
 
-    public void testQuerySingleRelationBoolean() {
+    @Test
+    public void querySingleRelationBoolean() {
         RealmResults<Owner> owners = testRealm.where(Owner.class).equalTo("cat.hasTail", true).findAll();
         assertEquals(1, owners.size());
         assertEquals(12, owners.first().getCat().getAge());
@@ -119,7 +143,8 @@ public void testQuerySingleRelationBoolean() {
         assertEquals(0, none.size());
     }
 
-    public void testQuerySingleRelationInteger() {
+    @Test
+    public void querySingleRelationInteger() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).equalTo("cat.age", 12).findAll();
         assertEquals(1, owners1.size());
         assertEquals(12, owners1.first().getCat().getAge());
@@ -157,7 +182,8 @@ public void testQuerySingleRelationInteger() {
         }
     }
 
-    public void testQuerySingleRelationDate() {
+    @Test
+    public void querySingleRelationDate() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).equalTo("cat.birthday", new Date(6000)).findAll();
         assertEquals(1, owners1.size());
         assertEquals(12, owners1.first().getCat().getAge());
@@ -196,7 +222,8 @@ public void testQuerySingleRelationDate() {
         }
     }
 
-    public void testQuerySingleRelationFloat() {
+    @Test
+    public void querySingleRelationFloat() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).greaterThanOrEqualTo("cat.height", 0.2f).findAll();
         assertEquals(1, owners1.size());
         assertEquals(12, owners1.first().getCat().getAge());
@@ -227,7 +254,8 @@ public void testQuerySingleRelationFloat() {
         }
     }
 
-    public void testQuerySingleRelationDouble() {
+    @Test
+    public void querySingleRelationDouble() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).greaterThanOrEqualTo("cat.weight", 0.2).findAll();
         assertEquals(1, owners1.size());
         assertEquals(12, owners1.first().getCat().getAge());
@@ -259,8 +287,8 @@ public void testQuerySingleRelationDouble() {
         }
     }
 
-
-    public void testQuerySingleRelationString() {
+    @Test
+    public void querySingleRelationString() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).equalTo("cat.name", "Blackie").findAll();
         assertEquals(1, owners1.size());
 
@@ -286,7 +314,8 @@ public void testQuerySingleRelationString() {
         assertEquals(1, owners6.size());
     }
 
-    public void testQueryMultipleRelationsBoolean() {
+    @Test
+    public void queryMultipleRelationsBoolean() {
         RealmResults<Owner> owners = testRealm.where(Owner.class).equalTo("dogs.hasTail", true).findAll();
         assertEquals(1, owners.size());
 
@@ -294,7 +323,8 @@ public void testQueryMultipleRelationsBoolean() {
         assertEquals(0, none.size());
     }
 
-    public void testQueryMultipleRelationsInteger() {
+    @Test
+    public void queryMultipleRelationsInteger() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).equalTo("dogs.age", 10).findAll();
         assertEquals(1, owners1.size());
 
@@ -326,7 +356,8 @@ public void testQueryMultipleRelationsInteger() {
         }
     }
 
-    public void testQueryMultipleRelationsDate() {
+    @Test
+    public void queryMultipleRelationsDate() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).equalTo("dogs.birthday", new Date(2000)).findAll();
         assertEquals(1, owners1.size());
 
@@ -359,7 +390,8 @@ public void testQueryMultipleRelationsDate() {
         }
     }
 
-    public void testQueryMultipleRelationsFloat() {
+    @Test
+    public void queryMultipleRelationsFloat() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).greaterThanOrEqualTo("dogs.height", 0.2f).findAll();
         assertEquals(1, owners1.size());
         assertEquals(12, owners1.first().getCat().getAge());
@@ -391,7 +423,8 @@ public void testQueryMultipleRelationsFloat() {
         }
     }
 
-    public void testQueryMultipleRelationsDouble() {
+    @Test
+    public void queryMultipleRelationsDouble() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).greaterThanOrEqualTo("dogs.weight", 0.2).findAll();
         assertEquals(1, owners1.size());
         assertEquals(12, owners1.first().getCat().getAge());
@@ -423,8 +456,8 @@ public void testQueryMultipleRelationsDouble() {
         }
     }
 
-
-    public void testQueryMultipleRelationsString() {
+    @Test
+    public void queryMultipleRelationsString() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).equalTo("dogs.name", "Pluto").findAll();
         assertEquals(1, owners1.size());
 
@@ -447,7 +480,8 @@ public void testQueryMultipleRelationsString() {
         assertEquals(0, owners5.size());
     }
 
-    public void testQueryShouldFail() {
+    @Test
+    public void queryShouldFail() {
         try {
             RealmResults<Owner> owners = testRealm.where(Owner.class).equalTo("cat..hasTail", true).findAll();
             fail("Should throw Exception");
@@ -470,7 +504,8 @@ public void testQueryShouldFail() {
         }
     }
 
-    public void testWhere() throws Exception {
+    @Test
+    public void where() throws Exception {
         RealmResults<Owner> owners = testRealm.where(Owner.class).findAll();
         RealmResults<Dog> dogs = owners.first().getDogs().where().equalTo("name", "Pluto").findAll();
         assertEquals(1, dogs.size());
@@ -481,13 +516,15 @@ public void testWhere() throws Exception {
         assertEquals(0, none.size());
     }
 
-    public void testSubquery() {
+    @Test
+    public void subquery() {
         RealmResults<Owner> owners = testRealm.where(Owner.class).equalTo("dogs.name", "Pluto").findAll();
         RealmResults<Owner> subOwners = owners.where().equalTo("cat.name", "Blackie").findAll();
         assertEquals(1, subOwners.size());
     }
 
-    public void testLinkIsNull() {
+    @Test
+    public void linkIsNull() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).isNull("cat").findAll();
         assertEquals(0, owners1.size());
 
@@ -499,7 +536,8 @@ public void testLinkIsNull() {
         assertEquals(1, owners2.size());
     }
 
-    public void testLinkIsNotNull() {
+    @Test
+    public void linkIsNotNull() {
         RealmResults<Owner> owners1 = testRealm.where(Owner.class).isNotNull("cat").findAll();
         assertEquals(1, owners1.size());
 
@@ -511,7 +549,8 @@ public void testLinkIsNotNull() {
         assertEquals(0, owners2.size());
     }
 
-    public void testIsNullWrongType() {
+    @Test
+    public void isNullWrongType() {
         try {
             // AllTypes.columnFloat is not nullable
             testRealm.where(AllTypes.class).isNull("columnFloat").findAll();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
index 1230a7c761..7dc7177144 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
@@ -120,7 +120,7 @@ public void constructor_unmanaged_null() {
     public void isValid_unmanagedMode() {
         //noinspection MismatchedQueryAndUpdateOfCollection
         RealmList<AllTypes> list = new RealmList<AllTypes>();
-        assertFalse(list.isValid());
+        assertTrue(list.isValid());
     }
 
     @Test
@@ -724,6 +724,7 @@ public void realmMethods_onDeletedLinkView() {
                     case MAX_DATE: results.maxDate(CyclicType.FIELD_DATE); break;
                     case DELETE_ALL_FROM_REALM: results.deleteAllFromRealm(); break;
                     case IS_VALID: continue; // Does not throw
+                    case IS_MANAGED: continue; // Does not throw
                 }
                 fail(method + " should have thrown an Exception.");
             } catch (IllegalStateException ignored) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
index 2c81d4fb9d..cbba8cc04c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -47,11 +47,20 @@
 import io.realm.entities.PrimaryKeyAsShort;
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.entities.StringOnly;
+import io.realm.entities.migration.MigrationClassRenamed;
+import io.realm.entities.migration.MigrationFieldRenamed;
+import io.realm.entities.migration.MigrationFieldTypeToInt;
+import io.realm.entities.migration.MigrationFieldTypeToInteger;
+import io.realm.entities.migration.MigrationPosteriorIndexOnly;
+import io.realm.entities.migration.MigrationPriorIndexOnly;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.Table;
+import io.realm.migration.MigrationPrimaryKey;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -226,6 +235,405 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         }
     }
 
+    /**
+     * Builds a temporary schema to be modified later in a migration. {@link MigrationPrimaryKey} is
+     * the base class when specified.
+     *
+     * <p>MigrationPrimaryKey is supposed to be a RealmObject, but that would hamper our steps toward
+     * testing migrations as Realm looks for it in migration. It is thus set to be an interface.
+     *
+     * @param className a class whose schema is to be re-created
+     * @param createBase create a schema named "MigrationPrimaryKey" instead of {@code className} if {@code true}
+     */
+    private void buildInitialMigrationSchema(final String className, final boolean createBase) {
+        Realm realm = Realm.getInstance(configFactory.createConfigurationBuilder().build());
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                // first, remove an existing schema
+                realm.getSchema().remove(className);
+                // then recreate the deleted schema or build a base schema
+                realm.getSchema()
+                        .create(createBase ? MigrationPrimaryKey.CLASS_NAME : className)
+                        .addField(MigrationPrimaryKey.FIELD_FIRST,   Byte.class)
+                        .addField(MigrationPrimaryKey.FIELD_SECOND,  Short.class)
+                        .addField(MigrationPrimaryKey.FIELD_PRIMARY, String.class, FieldAttribute.PRIMARY_KEY)
+                        .addField(MigrationPrimaryKey.FIELD_FOURTH,  Integer.class)
+                        .addField(MigrationPrimaryKey.FIELD_FIFTH,   Long.class);
+            }
+        });
+        realm.close();
+    }
+
+    // Test to show renaming a class does not hinder its PK field's attribute
+    @Test
+    public void renameClassTransferPrimaryKey() {
+        buildInitialMigrationSchema(MigrationClassRenamed.CLASS_NAME, true);
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                realm.getSchema()
+                        .rename(MigrationPrimaryKey.CLASS_NAME, MigrationClassRenamed.CLASS_NAME);
+            }
+        };
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(MigrationClassRenamed.class)
+                .migration(migration)
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+
+        Table table = realm.getSchema().getTable(MigrationClassRenamed.class);
+        assertTrue(table.hasPrimaryKey());
+        assertEquals(MigrationClassRenamed.DEFAULT_FIELDS_COUNT, table.getColumnCount());
+        assertEquals(MigrationClassRenamed.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
+        assertEquals(MigrationClassRenamed.FIELD_PRIMARY, table.getColumnName(table.getPrimaryKey()));
+        //old schema does not exist
+        assertNull(realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME));
+    }
+
+    @Test
+    public void rename_noSimilarPrimaryKeyWithOldSchema() {
+        buildInitialMigrationSchema(MigrationClassRenamed.CLASS_NAME, true);
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                // Let us rename the old schema.
+                realm.getSchema()
+                        .rename(MigrationPrimaryKey.CLASS_NAME, MigrationClassRenamed.CLASS_NAME);
+
+                // Then recreate the original schema to see if Realm is going to get confused.
+                // Unlike the first time with buildInitialMigrationSchema(), we will not have a primary key.
+                realm.getSchema()
+                        .create(MigrationPrimaryKey.CLASS_NAME)
+                        .addField(MigrationPrimaryKey.FIELD_FIRST,   Byte.class)
+                        .addField(MigrationPrimaryKey.FIELD_SECOND,  Short.class)
+                        .addField(MigrationPrimaryKey.FIELD_PRIMARY, String.class)
+                        .addField(MigrationPrimaryKey.FIELD_FOURTH,  Integer.class)
+                        .addField(MigrationPrimaryKey.FIELD_FIFTH,   Long.class);
+            }
+        };
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(MigrationClassRenamed.class)
+                .migration(migration)
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+
+        assertTrue(realm.getSchema().get(MigrationClassRenamed.CLASS_NAME).hasPrimaryKey());
+        assertFalse(realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME).hasPrimaryKey());
+    }
+
+    // Test to show that renaming a class does not effect the primary key
+    @Test
+    public void setClassName_transferPrimaryKey() {
+        buildInitialMigrationSchema(MigrationClassRenamed.CLASS_NAME, true);
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                realm.getSchema()
+                        .get(MigrationPrimaryKey.CLASS_NAME)
+                        .setClassName(MigrationClassRenamed.CLASS_NAME);
+            }
+        };
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(MigrationClassRenamed.class)
+                .migration(migration)
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+
+        Table table = realm.getSchema().getTable(MigrationClassRenamed.class);
+        assertTrue(table.hasPrimaryKey());
+        assertEquals(MigrationClassRenamed.DEFAULT_FIELDS_COUNT, table.getColumnCount());
+        assertEquals(MigrationClassRenamed.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
+        assertEquals(MigrationClassRenamed.FIELD_PRIMARY, table.getColumnName(table.getPrimaryKey()));
+        //old schema does not exist
+        assertNull(realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME));
+    }
+
+    @Test
+    public void setClassName_noSimilarPrimaryKeyWithOldSchema() {
+        buildInitialMigrationSchema(MigrationClassRenamed.CLASS_NAME, true);
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                // Let us set a new class name
+                realm.getSchema()
+                        .get(MigrationPrimaryKey.CLASS_NAME)
+                        .setClassName(MigrationClassRenamed.CLASS_NAME);
+
+                // Then recreate the original schema to see if Realm is going to get confused.
+                // Unlike the first time with buildInitialMigrationSchema(), we will not have a primary key.
+                realm.getSchema()
+                        .create(MigrationPrimaryKey.CLASS_NAME)
+                        .addField(MigrationPrimaryKey.FIELD_FIRST,   Byte.class)
+                        .addField(MigrationPrimaryKey.FIELD_SECOND,  Short.class)
+                        .addField(MigrationPrimaryKey.FIELD_PRIMARY, String.class)
+                        .addField(MigrationPrimaryKey.FIELD_FOURTH,  Integer.class)
+                        .addField(MigrationPrimaryKey.FIELD_FIFTH,   Long.class);
+            }
+        };
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(MigrationClassRenamed.class)
+                .migration(migration)
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+
+        assertTrue(realm.getSchema().get(MigrationClassRenamed.CLASS_NAME).hasPrimaryKey());
+        assertFalse(realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME).hasPrimaryKey());
+    }
+
+    @Test
+    public void setClassName_throwOnLongClassName() {
+        // create the first version of schema
+        Realm realm = Realm.getInstance(configFactory.createConfigurationBuilder().build());
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.getSchema().create(MigrationPrimaryKey.CLASS_NAME);
+            }
+        });
+        realm.close();
+
+        // get ready for the 2nd version migration
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                realm.getSchema()
+                        .get(MigrationPrimaryKey.CLASS_NAME)
+                        // 57 characters
+                        .setClassName("MigrationNameIsLongerThan56charThisShouldThrowAnException");
+            }
+        };
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .migration(migration)
+                .build();
+
+        // create Realm instance fails
+        try {
+            Realm.getInstance(realmConfig);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Class name is to long. Limit is 56 characters: 'MigrationNameIsLongerThan56charThisShouldThrowAnException' (57)",
+                    expected.getMessage());
+        }
+    }
+
+    // Removing fields before a pk field does not affect the pk
+    @Test
+    public void removeFieldsBeforePrimaryKey() {
+        buildInitialMigrationSchema(MigrationPosteriorIndexOnly.CLASS_NAME, false);
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                realm.getSchema().get(MigrationPosteriorIndexOnly.CLASS_NAME)
+                        .removeField(MigrationPrimaryKey.FIELD_FIRST)
+                        .removeField(MigrationPrimaryKey.FIELD_SECOND);
+            }
+        };
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(MigrationPosteriorIndexOnly.class)
+                .migration(migration)
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+        Table table = realm.getSchema().getTable(MigrationPosteriorIndexOnly.class);
+
+        assertTrue(table.hasPrimaryKey());
+        assertEquals(MigrationPosteriorIndexOnly.DEFAULT_FIELDS_COUNT, table.getColumnCount());
+        assertEquals(MigrationPosteriorIndexOnly.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
+        assertEquals(MigrationPosteriorIndexOnly.FIELD_PRIMARY, table.getColumnName(table.getPrimaryKey()));
+    }
+
+    // Removing fields after a pk field does not affect the pk
+    @Test
+    public void removeFieldsAfterPrimaryKey() {
+        buildInitialMigrationSchema(MigrationPriorIndexOnly.CLASS_NAME, false);
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                realm.getSchema().get(MigrationPriorIndexOnly.CLASS_NAME)
+                        .removeField(MigrationPrimaryKey.FIELD_FOURTH)
+                        .removeField(MigrationPrimaryKey.FIELD_FIFTH);
+            }
+        };
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(MigrationPriorIndexOnly.class)
+                .migration(migration)
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+        Table table = realm.getSchema().getTable(MigrationPriorIndexOnly.class);
+
+        assertTrue(table.hasPrimaryKey());
+        assertEquals(MigrationPriorIndexOnly.DEFAULT_FIELDS_COUNT, table.getColumnCount());
+        assertEquals(MigrationPriorIndexOnly.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
+        assertEquals(MigrationPriorIndexOnly.FIELD_PRIMARY, table.getColumnName(table.getPrimaryKey()));
+    }
+
+    // Renaming the class should also rename the the class entry in the pk metadata table that tracks primary keys
+    @Test
+    public void renamePrimaryKeyFieldInMigration() {
+        buildInitialMigrationSchema(MigrationFieldRenamed.CLASS_NAME, false);
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                realm.getSchema().get(MigrationFieldRenamed.CLASS_NAME)
+                        .renameField(MigrationPrimaryKey.FIELD_PRIMARY, MigrationFieldRenamed.FIELD_PRIMARY);
+            }
+        };
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(MigrationFieldRenamed.class)
+                .migration(migration)
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+
+        Table table = realm.getSchema().getTable(MigrationFieldRenamed.class);
+        assertTrue(table.hasPrimaryKey());
+        assertEquals(MigrationFieldRenamed.DEFAULT_FIELDS_COUNT, table.getColumnCount());
+        assertEquals(MigrationFieldRenamed.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
+
+        RealmObjectSchema objectSchema = realm.getSchema().getSchemaForClass(MigrationFieldRenamed.class);
+        assertFalse(objectSchema.hasField(MigrationPrimaryKey.FIELD_PRIMARY));
+        assertEquals(MigrationFieldRenamed.FIELD_PRIMARY, objectSchema.getPrimaryKey());
+    }
+
+    private void createObjectsWithOldPrimaryKey(final String className, final boolean insertNullValue) {
+        DynamicRealm realm = DynamicRealm.getInstance(configFactory.createConfigurationBuilder().build());
+        try {
+            realm.executeTransaction(new DynamicRealm.Transaction() {
+                @Override
+                public void execute(DynamicRealm realm) {
+                    realm.createObject(className, "12");
+                    if (insertNullValue) {
+                        realm.createObject(className, null);
+                    }
+                }
+            });
+        } finally {
+            realm.close();
+        }
+    }
+
+    // This is to test how PK type can change to non-nullable int in migration
+    @Test
+    public void modifyPrimaryKeyFieldTypeToIntInMigration() {
+        final String TEMP_FIELD_ID = "temp_id";
+        buildInitialMigrationSchema(MigrationFieldTypeToInt.CLASS_NAME, false);
+        // create objects with the schema provided
+        createObjectsWithOldPrimaryKey(MigrationFieldTypeToInt.CLASS_NAME, true);
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                realm.getSchema().get(MigrationFieldTypeToInt.CLASS_NAME)
+                        .addField("temp_id", int.class)
+                        .transform(new RealmObjectSchema.Function() {
+                            @Override
+                            public void apply(DynamicRealmObject obj) {
+                                String fieldValue = obj.getString(MigrationPrimaryKey.FIELD_PRIMARY);
+                                if (fieldValue != null && fieldValue.length() != 0) {
+                                    obj.setInt(TEMP_FIELD_ID, Integer.valueOf(fieldValue).intValue());
+                                } else {
+                                    // Since this cannot be accepted as proper pk value, we'll delete it.
+                                    // *You can modify with some other value such as 0, but that's not
+                                    // counted in this scenario.
+                                    obj.deleteFromRealm();
+                                }
+                            }
+                        })
+                        .removeField(MigrationPrimaryKey.FIELD_PRIMARY)
+                        .renameField(TEMP_FIELD_ID, MigrationFieldTypeToInt.FIELD_PRIMARY)
+                        .addPrimaryKey(MigrationFieldTypeToInt.FIELD_PRIMARY);
+            }
+        };
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(MigrationFieldTypeToInt.class)
+                .migration(migration)
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+
+        Table table = realm.getSchema().getTable(MigrationFieldTypeToInt.class);
+        assertTrue(table.hasPrimaryKey());
+        assertEquals(MigrationFieldTypeToInt.DEFAULT_FIELDS_COUNT, table.getColumnCount());
+        assertEquals(MigrationFieldTypeToInt.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
+
+        RealmObjectSchema objectSchema = realm.getSchema().getSchemaForClass(MigrationFieldTypeToInt.class);
+        assertFalse(objectSchema.hasField(MigrationPrimaryKey.FIELD_PRIMARY));
+        assertEquals(MigrationFieldTypeToInt.FIELD_PRIMARY, objectSchema.getPrimaryKey());
+        assertEquals(1, realm.where(MigrationFieldTypeToInt.class).count());
+        assertEquals(12, realm.where(MigrationFieldTypeToInt.class).findFirst().fieldIntPrimary);
+    }
+
+    // This is to test how PK type can change to nullable Integer in migration
+    @Test
+    public void modifyPrimaryKeyFieldTypeToIntegerInMigration() {
+        final String TEMP_FIELD_ID = "temp_id";
+        buildInitialMigrationSchema(MigrationFieldTypeToInteger.CLASS_NAME, false);
+        // create objects with the schema provided
+        createObjectsWithOldPrimaryKey(MigrationFieldTypeToInteger.CLASS_NAME, true);
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                realm.getSchema().get(MigrationFieldTypeToInteger.CLASS_NAME)
+                        .addField("temp_id", Integer.class)
+                        .transform(new RealmObjectSchema.Function() {
+                            @Override
+                            public void apply(DynamicRealmObject obj) {
+                                String fieldValue = obj.getString(MigrationPrimaryKey.FIELD_PRIMARY);
+                                if (fieldValue != null && fieldValue.length() != 0) {
+                                    obj.setInt(TEMP_FIELD_ID, Integer.valueOf(fieldValue));
+                                } else {
+                                    obj.setNull(TEMP_FIELD_ID);
+                                }
+                            }
+                        })
+                        .removeField(MigrationPrimaryKey.FIELD_PRIMARY)
+                        .renameField(TEMP_FIELD_ID, MigrationFieldTypeToInteger.FIELD_PRIMARY)
+                        .addPrimaryKey(MigrationFieldTypeToInteger.FIELD_PRIMARY);
+            }
+        };
+        RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schemaVersion(1)
+                .schema(MigrationFieldTypeToInteger.class)
+                .migration(migration)
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+
+        Table table = realm.getSchema().getTable(MigrationFieldTypeToInteger.class);
+        assertTrue(table.hasPrimaryKey());
+        assertEquals(MigrationFieldTypeToInteger.DEFAULT_FIELDS_COUNT, table.getColumnCount());
+        assertEquals(MigrationFieldTypeToInteger.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
+
+        RealmObjectSchema objectSchema = realm.getSchema().getSchemaForClass(MigrationFieldTypeToInteger.class);
+        assertFalse(objectSchema.hasField(MigrationPrimaryKey.FIELD_PRIMARY));
+        assertEquals(MigrationFieldTypeToInteger.FIELD_PRIMARY, objectSchema.getPrimaryKey());
+        assertEquals(2, realm.where(MigrationFieldTypeToInteger.class).count());
+
+        // not-null value
+        assertEquals(1, realm.where(MigrationFieldTypeToInteger.class)
+                             .equalTo(MigrationFieldTypeToInteger.FIELD_PRIMARY, Integer.valueOf(12))
+                             .count());
+
+        // null value
+        assertEquals(1, realm.where(MigrationFieldTypeToInteger.class)
+                             .equalTo(MigrationFieldTypeToInteger.FIELD_PRIMARY, (Integer) null)
+                             .count());
+    }
+
     @Test
     public void settingPrimaryKeyWithObjectSchema() {
         // Create v0 of the Realm
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
index 5bf386836c..4c1a04a037 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
@@ -45,6 +45,7 @@
 
 import static io.realm.internal.test.ExtraTests.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
 // tests API methods when using a model class implementing RealmModel instead
@@ -101,8 +102,7 @@ public void createObject() {
         for (int i = 1; i < 43; i++) { // using i = 0 as PK will crash subsequent createObject
                                        // since createObject uses default values
             realm.beginTransaction();
-            AllTypesRealmModel allTypesRealmModel = realm.createObject(AllTypesRealmModel.class);
-            allTypesRealmModel.columnLong = i;
+            realm.createObject(AllTypesRealmModel.class, i);
             realm.commitTransaction();
         }
 
@@ -154,6 +154,7 @@ public void execute(Realm realm) {
         assertEquals(1, realm.where(AllTypesRealmModel.class).count());
 
         AllTypesRealmModel obj = realm.where(AllTypesRealmModel.class).findFirst();
+        assertNotNull(obj);
         assertEquals("Foo", obj.columnString);
     }
 
@@ -165,6 +166,7 @@ public void createOrUpdateAllFromJson() throws IOException {
 
         assertEquals(1, realm.where(AllTypesRealmModel.class).count());
         AllTypesRealmModel obj = realm.where(AllTypesRealmModel.class).findFirst();
+        assertNotNull(obj);
         assertEquals("Bar", obj.columnString);
         assertEquals(2.23F, obj.columnFloat, 0.000000001);
         assertEquals(2.234D, obj.columnDouble, 0.000000001);
@@ -192,6 +194,7 @@ public void async_query() {
         populateTestRealm(realm, TEST_DATA_SIZE);
 
         final RealmResults<AllTypesRealmModel> allTypesRealmModels = realm.where(AllTypesRealmModel.class).distinctAsync(AllTypesRealmModel.FIELD_STRING);
+        looperThread.keepStrongReference.add(allTypesRealmModels);
         allTypesRealmModels.addChangeListener(new RealmChangeListener<RealmResults<AllTypesRealmModel>>() {
             @Override
             public void onChange(RealmResults<AllTypesRealmModel> object) {
@@ -206,12 +209,13 @@ public void dynamicObject() {
         populateTestRealm(realm, TEST_DATA_SIZE);
 
         AllTypesRealmModel typedObj = realm.where(AllTypesRealmModel.class).findFirst();
+        assertNotNull(typedObj);
         DynamicRealmObject dObj = new DynamicRealmObject(typedObj);
 
         realm.beginTransaction();
-        dObj.setLong(AllTypesRealmModel.FIELD_LONG, 42L);
-        assertEquals(42, dObj.getLong(AllTypesRealmModel.FIELD_LONG));
-        assertEquals(42, typedObj.columnLong);
+        dObj.setByte(AllTypesRealmModel.FIELD_BYTE, (byte) 42);
+        assertEquals(42, dObj.getLong(AllTypesRealmModel.FIELD_BYTE));
+        assertEquals(42, typedObj.columnByte);
 
         dObj.setBlob(AllTypesRealmModel.FIELD_BINARY, new byte[]{1, 2, 3});
         Assert.assertArrayEquals(new byte[]{1, 2, 3}, dObj.getBlob(AllTypesRealmModel.FIELD_BINARY));
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
index cb9cf3f5c3..efd306014f 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -33,6 +33,7 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -730,6 +731,28 @@ public void getPrimaryKey_nonExistFieldThrows() {
         schema.getPrimaryKey();
     }
 
+    @Test
+    public void getFieldIndex() {
+        final String className = "NoField";
+        final String fieldName = "field";
+        RealmConfiguration emptyConfig = configFactory.createConfiguration("empty");
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(emptyConfig);
+        dynamicRealm.beginTransaction();
+        RealmObjectSchema objectSchema = dynamicRealm.getSchema().create(className);
+
+        assertNull(objectSchema.getFieldIndex(fieldName));
+
+        objectSchema.addField(fieldName, long.class);
+        //noinspection ConstantConditions
+        assertTrue(objectSchema.getFieldIndex(fieldName) >= 0);
+
+        objectSchema.removeField(fieldName);
+        assertNull(objectSchema.getFieldIndex(fieldName));
+
+        dynamicRealm.cancelTransaction();
+        dynamicRealm.close();
+    }
+
     private interface FieldRunnable {
         void run(String fieldName);
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
index 644d3caa34..0224d6496c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
@@ -40,6 +40,7 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicReference;
 
+import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
 import io.realm.entities.AllTypesPrimaryKey;
 import io.realm.entities.ConflictingFieldName;
@@ -48,6 +49,7 @@
 import io.realm.entities.Dog;
 import io.realm.entities.NullTypes;
 import io.realm.entities.StringAndInt;
+import io.realm.exceptions.RealmException;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.Table;
@@ -523,7 +525,7 @@ public void execute(Realm realm) {
             realm_differentName.close();
         }
 
-        // Check the hash code of the object from a Realm in different folder.
+        // Check the hash code of the object from a Realm in different directory.
         RealmConfiguration realmConfig_differentPath = configFactory.createConfiguration(
                 "anotherDir", realmConfig.getRealmFileName());
         Realm realm_differentPath = Realm.getInstance(realmConfig_differentPath);
@@ -933,7 +935,7 @@ public void classNameConflictsWithFrameworkClass() {
     @Test
     public void isValid_unmanagedObject() {
         AllTypes allTypes = new AllTypes();
-        assertFalse(allTypes.isValid());
+        assertTrue(allTypes.isValid());
     }
 
     @Test
@@ -971,7 +973,7 @@ public void isValid_managedObject() {
     @Test
     public void set_get_nullOnNullableFields() {
         realm.beginTransaction();
-        NullTypes nullTypes = realm.createObject(NullTypes.class);
+        NullTypes nullTypes = realm.createObject(NullTypes.class, 0);
         // 1 String
         nullTypes.setFieldStringNull(null);
         // 2 Bytes
@@ -1024,7 +1026,7 @@ public void get_set_nonNullValueOnNullableFields() {
         final byte[] testBytes = new byte[] {42};
         final Date testDate = newDate(2000, 1, 1);
         realm.beginTransaction();
-        NullTypes nullTypes = realm.createObject(NullTypes.class);
+        NullTypes nullTypes = realm.createObject(NullTypes.class, 0);
         // 1 String
         nullTypes.setFieldStringNull(testString);
         // 2 Bytes
@@ -1075,7 +1077,7 @@ public void get_set_nonNullValueOnNullableFields() {
     public void set_nullValuesToNonNullableFields() {
         try {
             realm.beginTransaction();
-            NullTypes nullTypes = realm.createObject(NullTypes.class);
+            NullTypes nullTypes = realm.createObject(NullTypes.class, 0);
             // 1 String
             try {
                 nullTypes.setFieldStringNotNull(null);
@@ -1144,7 +1146,7 @@ public void set_nullValuesToNonNullableFields() {
     @Test
     public void defaultValuesForNewObject() {
         realm.beginTransaction();
-        NullTypes nullTypes = realm.createObject(NullTypes.class);
+        NullTypes nullTypes = realm.createObject(NullTypes.class, 0);
         realm.commitTransaction();
 
         assertNotNull(nullTypes);
@@ -1227,6 +1229,21 @@ public void isValid() {
         assertFalse(dog.isValid());
     }
 
+    @Test
+    public void isManaged_managedObject() {
+        realm.beginTransaction();
+        Dog dog = realm.createObject(Dog.class);
+        realm.commitTransaction();
+
+        assertTrue(dog.isManaged());
+    }
+
+    @Test
+    public void isManaged_unmanagedObject() {
+        Dog dog = new Dog();
+        assertFalse(dog.isManaged());
+    }
+
     // Test NaN value on float and double columns
     @Test
     public void float_double_NaN() {
@@ -1557,6 +1574,15 @@ public void setter_nullValueInNullableField() {
         assertNull(realm.where(NullTypes.class).findFirst().getFieldDateNull());
     }
 
+    @Test
+    public void setter_changePrimaryKeyThrows() {
+        realm.beginTransaction();
+        AllJavaTypes allJavaTypes = realm.createObject(AllJavaTypes.class, 42);
+        thrown.expect(RealmException.class);
+        allJavaTypes.setFieldId(111);
+        realm.cancelTransaction();
+    }
+
     @Test
     @RunTestInLooperThread
     public void addChangeListener_throwOnAddingNullListenerFromLooperThread() {
@@ -1716,6 +1742,7 @@ public void addChangeListener_returnedObjectOfCopyToRealmOrUpdate() {
         allTypesPrimaryKey = realm.copyToRealmOrUpdate(allTypesPrimaryKey);
         realm.commitTransaction();
 
+        looperThread.keepStrongReference.add(allTypesPrimaryKey);
         allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
             @Override
             public void onChange(AllTypesPrimaryKey element) {
@@ -1793,6 +1820,7 @@ public void addChangeListener_checkHandlerRealmObjectsWhenCallingOnAsyncObject()
                 realm.handlerController.realmObjects;
 
         final AllTypesPrimaryKey allTypesPrimaryKey = realm.where(AllTypesPrimaryKey.class).findFirstAsync();
+        looperThread.keepStrongReference.add(allTypesPrimaryKey);
         allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
             @Override
             public void onChange(AllTypesPrimaryKey element) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java
new file mode 100644
index 0000000000..9facd69f7f
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.HashSet;
+import java.util.Set;
+
+import io.realm.entities.Cat;
+import io.realm.internal.RealmProxyMediator;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmProxyMediatorTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private Realm realm;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration config = configFactory.createConfiguration();
+        realm = Realm.getInstance(config);
+    }
+
+    @After
+    public void tearDown() {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void validateTable_noDuplicateIndexInIndexFields() {
+        RealmProxyMediator mediator = realm.getConfiguration().getSchemaMediator();
+        CatRealmProxy.CatColumnInfo columnInfo;
+        columnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+
+        final Set<Long> indexSet = new HashSet<>();
+        int indexCount = 0;
+
+        indexSet.add(columnInfo.nameIndex);
+        indexCount++;
+        indexSet.add(columnInfo.ageIndex);
+        indexCount++;
+        indexSet.add(columnInfo.heightIndex);
+        indexCount++;
+        indexSet.add(columnInfo.weightIndex);
+        indexCount++;
+        indexSet.add(columnInfo.hasTailIndex);
+        indexCount++;
+        indexSet.add(columnInfo.birthdayIndex);
+        indexCount++;
+        indexSet.add(columnInfo.ownerIndex);
+        indexCount++;
+        indexSet.add(columnInfo.scaredOfDogIndex);
+        indexCount++;
+
+        assertEquals(indexCount, indexSet.size());
+    }
+
+    @Test
+    public void validateTable_noDuplicateIndexInIndicesMap() {
+        RealmProxyMediator mediator = realm.getConfiguration().getSchemaMediator();
+        CatRealmProxy.CatColumnInfo columnInfo;
+        columnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+
+        final Set<Long> indexSet = new HashSet<>();
+        int indexCount = 0;
+
+        // get index for each field and then put into set
+        for (Field field : Cat.class.getDeclaredFields()) {
+            if (Modifier.isStatic(field.getModifiers())) {
+                continue;
+            }
+            indexSet.add(columnInfo.getIndicesMap().get(field.getName()));
+            indexCount++;
+        }
+
+        assertEquals("if no duplicates, size of set equals to field count.",
+                indexCount, indexSet.size());
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index 9c50d7123c..d23e6796c1 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -42,6 +42,7 @@
 import io.realm.entities.Cat;
 import io.realm.entities.CatOwner;
 import io.realm.entities.Dog;
+import io.realm.entities.NoPrimaryKeyNullTypes;
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.NullTypes;
 import io.realm.entities.Owner;
@@ -71,6 +72,7 @@
     public final RunInLooperThread looperThread = new RunInLooperThread();
 
     protected final static int TEST_DATA_SIZE = 10;
+    protected final static int TEST_NO_PRIMARY_KEY_NULL_TYPES_SIZE = 200;
 
     private final static long DECADE_MILLIS = 10 * TimeUnit.DAYS.toMillis(365);
 
@@ -89,14 +91,14 @@ public void tearDown() throws Exception {
         }
     }
 
-    private void populateTestRealm(Realm testRealm, int objects) {
+    private void populateTestRealm(Realm testRealm, int dataSize) {
         testRealm.beginTransaction();
         testRealm.deleteAll();
-        for (int i = 0; i < objects; ++i) {
+        for (int i = 0; i < dataSize; ++i) {
             AllTypes allTypes = testRealm.createObject(AllTypes.class);
             allTypes.setColumnBoolean((i % 3) == 0);
             allTypes.setColumnBinary(new byte[]{1, 2, 3});
-            allTypes.setColumnDate(new Date(DECADE_MILLIS * (i - (objects / 2))));
+            allTypes.setColumnDate(new Date(DECADE_MILLIS * (i - (dataSize / 2))));
             allTypes.setColumnDouble(3.1415);
             allTypes.setColumnFloat(1.234567f + i);
             allTypes.setColumnString("test data " + i);
@@ -114,6 +116,37 @@ private void populateTestRealm() {
         populateTestRealm(realm, TEST_DATA_SIZE);
     }
 
+    private void populateNoPrimaryKeyNullTypesRows(Realm testRealm, int dataSize) {
+        testRealm.beginTransaction();
+        testRealm.deleteAll();
+        for (int i = 0; i < dataSize; ++i) {
+            NoPrimaryKeyNullTypes noPrimaryKeyNullTypes = testRealm.createObject(NoPrimaryKeyNullTypes.class);
+            noPrimaryKeyNullTypes.setFieldStringNull((i % 3) == 0 ? null : "test data " + i);
+            noPrimaryKeyNullTypes.setFieldStringNotNull("test data " + i);
+            noPrimaryKeyNullTypes.setFieldBooleanNull((i % 3) == 0 ? null : (i % 3) == 1);
+            noPrimaryKeyNullTypes.setFieldBooleanNotNull((i % 3) == 0);
+            noPrimaryKeyNullTypes.setFieldByteNull((i % 3) == 0 ? null : (byte) i);
+            noPrimaryKeyNullTypes.setFieldByteNotNull((byte) i);
+            noPrimaryKeyNullTypes.setFieldShortNull((i % 3) == 0 ? null : (short) i);
+            noPrimaryKeyNullTypes.setFieldShortNotNull((short) i);
+            noPrimaryKeyNullTypes.setFieldIntegerNull((i % 3) == 0 ? null : i);
+            noPrimaryKeyNullTypes.setFieldIntegerNotNull(i);
+            noPrimaryKeyNullTypes.setFieldLongNull((i % 3) == 0 ? null : (long) i);
+            noPrimaryKeyNullTypes.setFieldLongNotNull((long) i);
+            noPrimaryKeyNullTypes.setFieldFloatNull((i % 3) == 0 ? null : 1.234567f + i);
+            noPrimaryKeyNullTypes.setFieldFloatNotNull(1.234567f + i);
+            noPrimaryKeyNullTypes.setFieldDoubleNull((i % 3) == 0 ? null : 3.1415 + i);
+            noPrimaryKeyNullTypes.setFieldDoubleNotNull(3.1415 + i);
+            noPrimaryKeyNullTypes.setFieldDateNull((i % 3) == 0 ? null : new Date(DECADE_MILLIS * (i - (dataSize / 2))));
+            noPrimaryKeyNullTypes.setFieldDateNotNull(new Date(DECADE_MILLIS * (i - (dataSize / 2))));
+        }
+        testRealm.commitTransaction();
+    }
+
+    private void populateNoPrimaryKeyNullTypesRows() {
+        populateNoPrimaryKeyNullTypesRows(realm, TEST_NO_PRIMARY_KEY_NULL_TYPES_SIZE);
+    }
+
     @Test
     public void between() {
         final int TEST_OBJECTS_COUNT = 200;
@@ -404,6 +437,359 @@ public void equalTo_nonLatinCharacters() {
         assertEquals(0, resultList.size());
     }
 
+    private void doTestForInString(String targetField) {
+        populateNoPrimaryKeyNullTypesRows();
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, (String[]) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new String[]{}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new String[]{"test data 14"}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new String[]{"test data 14", "test data 118", "test data 31", "test data 199"}).findAll();
+        assertEquals(4, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new String[]{"TEST data 14", "test data 118", "test data 31", "test DATA 199"}, Case.INSENSITIVE).findAll();
+        assertEquals(4, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new String[]{"TEST data 14", "test data 118", "test data 31", "test DATA 199"}, Case.INSENSITIVE).findAll();
+        assertEquals(196, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new String[]{"TEST data 14", "test data 118", "test data 31", "test DATA 199"}, Case.INSENSITIVE).findAll();
+        assertEquals(196, resultList.size());
+    }
+
+    private void doTestForInBoolean(String targetField, int expected1, int expected2, int expected3, int expected4) {
+        populateNoPrimaryKeyNullTypesRows();
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, (Boolean[]) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Boolean[]{}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Boolean[]{false}).findAll();
+        assertEquals(expected1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Boolean[]{true}).findAll();
+        assertEquals(expected2, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Boolean[]{true, false}).findAll();
+        assertEquals(expected3, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Boolean[]{true, false}).findAll();
+        assertEquals(expected4, resultList.size());
+    }
+
+    private void doTestForInDate(String targetField) {
+        populateNoPrimaryKeyNullTypesRows();
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, (Date[]) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Date[]{}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Date[]{new Date(DECADE_MILLIS * -80)}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Date[]{new Date(0)}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Date[]{new Date(DECADE_MILLIS * -80), new Date(0)}).findAll();
+        assertEquals(2, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Date[]{new Date(DECADE_MILLIS * -80), new Date(0)}).findAll();
+        assertEquals(198, resultList.size());
+    }
+
+    private void doTestForInDouble(String targetField) {
+        populateNoPrimaryKeyNullTypesRows();
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, (Double[]) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Double[]{}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Double[]{3.1415d + 1}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Double[]{3.1415d + 2}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Double[]{3.1415d + 1, 3.1415d + 2}).findAll();
+        assertEquals(2, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Double[]{3.1415d + 1, 3.1415d + 2}).findAll();
+        assertEquals(198, resultList.size());
+    }
+
+    private void doTestForInFloat(String targetField) {
+        populateNoPrimaryKeyNullTypesRows();
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, (Float[]) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Float[]{}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Float[]{1.234567f + 1}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Float[]{1.234567f + 2}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Float[]{1.234567f + 1, 1.234567f + 2}).findAll();
+        assertEquals(2, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Float[]{1.234567f + 1, 1.234567f + 2}).findAll();
+        assertEquals(198, resultList.size());
+    }
+
+    private void doTestForInByte(String targetField) {
+        populateNoPrimaryKeyNullTypesRows();
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, (Byte[]) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Byte[]{}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Byte[]{11}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Byte[]{13}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Byte[]{11, 13, 16, 98}).findAll();
+        assertEquals(4, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Byte[]{11, 13, 16, 98}).findAll();
+        assertEquals(196, resultList.size());
+    }
+
+    private void doTestForInShort(String targetField) {
+        populateNoPrimaryKeyNullTypesRows();
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, (Short[]) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Short[]{}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Short[]{11}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Short[]{4}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Short[]{2, 4, 5, 8}).findAll();
+        assertEquals(4, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Short[]{2, 4, 5, 8}).findAll();
+        assertEquals(196, resultList.size());
+    }
+
+    private void doTestForInInteger(String targetField) {
+        populateNoPrimaryKeyNullTypesRows();
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, (Integer[]) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Integer[]{}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Integer[]{11}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Integer[]{1}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Integer[]{1, 2, 4, 5}).findAll();
+        assertEquals(4, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Integer[]{1, 2, 4, 5}).findAll();
+        assertEquals(196, resultList.size());
+    }
+
+    private void doTestForInLong(String targetField) {
+        populateNoPrimaryKeyNullTypesRows();
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, (Long[]) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Long[]{}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Long[]{11l}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Long[]{13l}).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).in(targetField, new Long[]{13l, 14l, 16l, 98l}).findAll();
+        assertEquals(4, resultList.size());
+        resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(targetField, new Long[]{13l, 14l, 16l, 98l}).findAll();
+        assertEquals(196, resultList.size());
+    }
+
+    @Test
+    public void in_stringNotNull() {
+        doTestForInString(NoPrimaryKeyNullTypes.FIELD_STRING_NOT_NULL);
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_STRING_NOT_NULL, new String[]{"TEST data 14", "test data 118", null, "test DATA 199"}, Case.INSENSITIVE).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void in_stringNull() {
+        doTestForInString(NoPrimaryKeyNullTypes.FIELD_STRING_NULL);
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_STRING_NULL, new String[]{"TEST data 14", "test data 118", null, "test DATA 199"}, Case.INSENSITIVE).findAll();
+        assertEquals(130, resultList.size());
+    }
+
+    @Test
+    public void in_booleanNotNull() {
+        doTestForInBoolean(NoPrimaryKeyNullTypes.FIELD_BOOLEAN_NOT_NULL, 133, 67, 200, 0);
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_BOOLEAN_NOT_NULL, new Boolean[]{true, null, false}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void in_booleanNull() {
+        doTestForInBoolean(NoPrimaryKeyNullTypes.FIELD_BOOLEAN_NULL, 66, 67, 133, 67);
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_BOOLEAN_NULL, new Boolean[]{true, null, false}).findAll();
+        assertEquals(0, resultList.size());
+    }
+
+    @Test
+    public void in_dateNotNull() {
+        doTestForInDate(NoPrimaryKeyNullTypes.FIELD_DATE_NOT_NULL);
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_DATE_NOT_NULL, new Date[]{new Date(DECADE_MILLIS * -80), null, new Date(0)}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void in_dateNull() {
+        doTestForInDate(NoPrimaryKeyNullTypes.FIELD_DATE_NULL);
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_DATE_NULL, new Date[]{new Date(DECADE_MILLIS * -80), null, new Date(0)}).findAll();
+        assertEquals(131, resultList.size());
+    }
+
+    @Test
+    public void in_doubleNotNull() {
+        doTestForInDouble(NoPrimaryKeyNullTypes.FIELD_DOUBLE_NOT_NULL);
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_DOUBLE_NOT_NULL, new Double[]{3.1415d + 1, null, 3.1415d + 2}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void in_doubleNull() {
+        doTestForInDouble(NoPrimaryKeyNullTypes.FIELD_DOUBLE_NULL);
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_DOUBLE_NULL, new Double[]{3.1415d + 1, null, 3.1415d + 2}).findAll();
+        assertEquals(131, resultList.size());
+    }
+
+    @Test
+    public void in_floatNotNull() {
+        doTestForInFloat(NoPrimaryKeyNullTypes.FIELD_FLOAT_NOT_NULL);
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_FLOAT_NOT_NULL, new Float[]{1.234567f + 1, null, 1.234567f + 2}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void in_floatNull() {
+        doTestForInFloat(NoPrimaryKeyNullTypes.FIELD_FLOAT_NULL);
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_FLOAT_NULL, new Float[]{1.234567f + 1, null, 1.234567f + 2}).findAll();
+        assertEquals(131, resultList.size());
+    }
+
+    @Test
+    public void in_byteNotNull() {
+        doTestForInByte(NoPrimaryKeyNullTypes.FIELD_BYTE_NOT_NULL);
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_BYTE_NOT_NULL, new Byte[]{11, null, 13, 99}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void in_byteNull() {
+        doTestForInByte(NoPrimaryKeyNullTypes.FIELD_BYTE_NULL);
+        RealmResults resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_BYTE_NULL, new Byte[]{11, null, 13, 99}).findAll();
+        assertEquals(131, resultList.size());
+    }
+
+    @Test
+    public void in_shortNotNull() {
+        doTestForInShort(NoPrimaryKeyNullTypes.FIELD_SHORT_NOT_NULL);
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_SHORT_NOT_NULL, new Short[]{2, null, 5, 8}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void in_shortNull() {
+        doTestForInShort(NoPrimaryKeyNullTypes.FIELD_SHORT_NULL);
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_SHORT_NULL, new Short[]{2, null, 5, 8}).findAll();
+        assertEquals(130, resultList.size());
+    }
+
+    @Test
+    public void in_integerNotNull() {
+        doTestForInInteger(NoPrimaryKeyNullTypes.FIELD_INTEGER_NOT_NULL);
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_INTEGER_NOT_NULL, new Integer[]{1, null, 4, 5}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void in_integerNull() {
+        doTestForInInteger(NoPrimaryKeyNullTypes.FIELD_INTEGER_NULL);
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_INTEGER_NULL, new Integer[]{1, null, 4, 5}).findAll();
+        assertEquals(130, resultList.size());
+    }
+
+    @Test
+    public void in_longNotNull() {
+        doTestForInLong(NoPrimaryKeyNullTypes.FIELD_LONG_NOT_NULL);
+        try {
+            realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_LONG_NOT_NULL, new Long[]{13l, null, 16l, 98l}).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void in_longNull() {
+        doTestForInLong(NoPrimaryKeyNullTypes.FIELD_LONG_NULL);
+        RealmResults<NoPrimaryKeyNullTypes> resultList = realm.where(NoPrimaryKeyNullTypes.class).not().in(NoPrimaryKeyNullTypes.FIELD_LONG_NULL, new Long[]{13l, null, 16l, 98l}).findAll();
+        assertEquals(130, resultList.size());
+    }
+
     @Test
     public void notEqualTo() {
         final int TEST_OBJECTS_COUNT = 200;
@@ -525,7 +911,6 @@ public void queryLink() {
         assertEquals(dog1, dog);
     }
 
-
     @Test
     public void findAllSorted_multiFailures() {
         // zero fields specified
@@ -658,7 +1043,12 @@ public void equalTo_notNullableFields() {
             fail();
         } catch (IllegalArgumentException ignored) {
         }
-        // 2 Bytes skipped, doesn't support equalTo query
+        // 2 Bytes
+        try {
+            realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BYTES_NOT_NULL, (byte[]) null).findAll();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
         // 3 Boolean
         try {
             realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BOOLEAN_NOT_NULL, (Boolean) null).findAll();
@@ -835,37 +1225,37 @@ public void notEqualTo_nullPrimaryKeys() {
         // String
         assertEquals(SECONDARY_FIELD_NUMBER, realm.where(PrimaryKeyAsString.class).notEqualTo(PrimaryKeyAsString.FIELD_PRIMARY_KEY,             "-1").findAll().first().getId());
         // Boxed Byte
-        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedByte.class).notEqualTo(PrimaryKeyAsBoxedByte.FIELD_PRIMARY_KEY,       Byte.valueOf((byte)-1)).findAll().first().getName());
+        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedByte.class).notEqualTo(PrimaryKeyAsBoxedByte.FIELD_PRIMARY_KEY,       Byte.valueOf((byte) -1)).findAll().first().getName());
         // Boxed Short
-        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedShort.class).notEqualTo(PrimaryKeyAsBoxedShort.FIELD_PRIMARY_KEY,     Short.valueOf((short)-1)).findAll().first().getName());
+        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedShort.class).notEqualTo(PrimaryKeyAsBoxedShort.FIELD_PRIMARY_KEY,     Short.valueOf((short) -1)).findAll().first().getName());
         // Boxed Integer
         assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedInteger.class).notEqualTo(PrimaryKeyAsBoxedInteger.FIELD_PRIMARY_KEY, Integer.valueOf(-1)).findAll().first().getName());
         // Boxed Long
-        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedLong.class).notEqualTo(PrimaryKeyAsBoxedLong.FIELD_PRIMARY_KEY,       Long.valueOf((long)-1)).findAll().first().getName());
+        assertEquals(SECONDARY_FIELD_STRING, realm.where(PrimaryKeyAsBoxedLong.class).notEqualTo(PrimaryKeyAsBoxedLong.FIELD_PRIMARY_KEY,       Long.valueOf((long) -1)).findAll().first().getName());
     }
 
     @Test
     public void beginWith_nullStringPrimaryKey() {
         final long SECONDARY_FIELD_NUMBER = 49992417L;
-        TestHelper.populateTestRealmWithStringPrimaryKey(realm,  (String) null,  SECONDARY_FIELD_NUMBER, 10, -5);
+        TestHelper.populateTestRealmWithStringPrimaryKey(realm, (String) null, SECONDARY_FIELD_NUMBER, 10, -5);
 
-        assertEquals(SECONDARY_FIELD_NUMBER, realm.where(PrimaryKeyAsString.class).beginsWith(PrimaryKeyAsString.FIELD_PRIMARY_KEY, null).findAll().first().getId());
+        assertEquals(SECONDARY_FIELD_NUMBER, realm.where(PrimaryKeyAsString.class).beginsWith(PrimaryKeyAsString.FIELD_PRIMARY_KEY, (String) null).findAll().first().getId());
     }
 
     @Test
     public void contains_nullStringPrimaryKey() {
         final long SECONDARY_FIELD_NUMBER = 49992417L;
-        TestHelper.populateTestRealmWithStringPrimaryKey(realm,  (String) null,  SECONDARY_FIELD_NUMBER, 10, -5);
+        TestHelper.populateTestRealmWithStringPrimaryKey(realm, (String) null, SECONDARY_FIELD_NUMBER, 10, -5);
 
-        assertEquals(SECONDARY_FIELD_NUMBER, realm.where(PrimaryKeyAsString.class).contains(PrimaryKeyAsString.FIELD_PRIMARY_KEY, null).findAll().first().getId());
+        assertEquals(SECONDARY_FIELD_NUMBER, realm.where(PrimaryKeyAsString.class).contains(PrimaryKeyAsString.FIELD_PRIMARY_KEY, (String) null).findAll().first().getId());
     }
 
     @Test
     public void endsWith_nullStringPrimaryKey() {
         final long SECONDARY_FIELD_NUMBER = 49992417L;
-        TestHelper.populateTestRealmWithStringPrimaryKey(realm,  (String) null,  SECONDARY_FIELD_NUMBER, 10, -5);
+        TestHelper.populateTestRealmWithStringPrimaryKey(realm, (String) null, SECONDARY_FIELD_NUMBER, 10, -5);
 
-        assertEquals(SECONDARY_FIELD_NUMBER, realm.where(PrimaryKeyAsString.class).endsWith(PrimaryKeyAsString.FIELD_PRIMARY_KEY, null).findAll().first().getId());
+        assertEquals(SECONDARY_FIELD_NUMBER, realm.where(PrimaryKeyAsString.class).endsWith(PrimaryKeyAsString.FIELD_PRIMARY_KEY, (String) null).findAll().first().getId());
     }
 
     @Test
@@ -964,46 +1354,50 @@ public void equalTo_nullableFields() {
         TestHelper.populateTestRealmForNullTests(realm);
 
         // 1 String
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_STRING_NULL, "Horse").findAll().size());
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_STRING_NULL, (String) null).findAll().size());
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_STRING_NULL, "Fish").findAll().size());
-        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_STRING_NULL, "Goat").findAll().size());
-        // 2 Bytes skipped, doesn't support equalTo query
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_STRING_NULL, "Horse").count());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_STRING_NULL, (String) null).count());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_STRING_NULL, "Fish").count());
+        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_STRING_NULL, "Goat").count());
+        // 2 Bytes
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BYTES_NULL, new byte[] {0}).count());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BYTES_NULL, (byte[]) null).count());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BYTES_NULL, new byte[] {1, 2}).count());
+        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BYTES_NULL, new byte[] {1, 2, 3}).count());
         // 3 Boolean
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BOOLEAN_NULL, true).findAll().size());
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BOOLEAN_NULL, (Boolean) null).findAll().size());
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BOOLEAN_NULL, false).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BOOLEAN_NULL, true).count());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BOOLEAN_NULL, (Boolean) null).count());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BOOLEAN_NULL, false).count());
         // 4 Byte
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BYTE_NULL, 1).findAll().size());
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BYTE_NULL, (byte) 1).findAll().size());
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BYTE_NULL, (Byte) null).findAll().size());
-        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BYTE_NULL, (byte) 42).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BYTE_NULL, 1).count());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BYTE_NULL, (byte) 1).count());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BYTE_NULL, (Byte) null).count());
+        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_BYTE_NULL, (byte) 42).count());
         // 5 Short for other long based columns, only test null
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_SHORT_NULL, 1).findAll().size());
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_SHORT_NULL, (short) 1).findAll().size());
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_SHORT_NULL, (Short) null).findAll().size());
-        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_SHORT_NULL, (short) 42).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_SHORT_NULL, 1).count());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_SHORT_NULL, (short) 1).count());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_SHORT_NULL, (Short) null).count());
+        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_SHORT_NULL, (short) 42).count());
         // 6 Integer
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_INTEGER_NULL, 1).findAll().size());
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_INTEGER_NULL, (Integer) null).findAll().size());
-        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_INTEGER_NULL, 42).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_INTEGER_NULL, 1).count());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_INTEGER_NULL, (Integer) null).count());
+        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_INTEGER_NULL, 42).count());
         // 7 Long
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_LONG_NULL, 1).findAll().size());
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_LONG_NULL, (long) 1).findAll().size());
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_LONG_NULL, (Long) null).findAll().size());
-        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_LONG_NULL, (long) 42).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_LONG_NULL, 1).count());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_LONG_NULL, (long) 1).count());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_LONG_NULL, (Long) null).count());
+        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_LONG_NULL, (long) 42).count());
         // 8 Float
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_FLOAT_NULL, 1F).findAll().size());
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_FLOAT_NULL, (Float) null).findAll().size());
-        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_FLOAT_NULL, 42F).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_FLOAT_NULL, 1F).count());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_FLOAT_NULL, (Float) null).count());
+        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_FLOAT_NULL, 42F).count());
         // 9 Double
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_DOUBLE_NULL, 1D).findAll().size());
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_DOUBLE_NULL, (Double) null).findAll().size());
-        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_DOUBLE_NULL, 42D).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_DOUBLE_NULL, 1D).count());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_DOUBLE_NULL, (Double) null).count());
+        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_DOUBLE_NULL, 42D).count());
         // 10 Date
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_DATE_NULL, new Date(0)).findAll().size());
-        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_DATE_NULL, (Date) null).findAll().size());
-        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_DATE_NULL, new Date(424242)).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_DATE_NULL, new Date(0)).count());
+        assertEquals(1, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_DATE_NULL, (Date) null).count());
+        assertEquals(0, realm.where(NullTypes.class).equalTo(NullTypes.FIELD_DATE_NULL, new Date(424242)).count());
         // 11 Object skipped, doesn't support equalTo query
     }
 
@@ -1013,27 +1407,27 @@ public void isNull_nullableFields() {
         TestHelper.populateTestRealmForNullTests(realm);
 
         // 1 String
-        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_STRING_NULL).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_STRING_NULL).count());
         // 2 Bytes
-        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_BYTES_NULL).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_BYTES_NULL).count());
         // 3 Boolean
-        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_BOOLEAN_NULL).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_BOOLEAN_NULL).count());
         // 4 Byte
-        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_BYTE_NULL).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_BYTE_NULL).count());
         // 5 Short
-        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_SHORT_NULL).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_SHORT_NULL).count());
         // 6 Integer
-        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_INTEGER_NULL).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_INTEGER_NULL).count());
         // 7 Long
-        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_LONG_NULL).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_LONG_NULL).count());
         // 8 Float
-        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_FLOAT_NULL).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_FLOAT_NULL).count());
         // 9 Double
-        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_DOUBLE_NULL).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_DOUBLE_NULL).count());
         // 10 Date
-        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_DATE_NULL).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_DATE_NULL).count());
         // 11 Object
-        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_OBJECT_NULL).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).isNull(NullTypes.FIELD_OBJECT_NULL).count());
     }
 
     // Querying nullable field for not null
@@ -1041,33 +1435,35 @@ public void isNull_nullableFields() {
     public void notEqualTo_nullableFields() {
         TestHelper.populateTestRealmForNullTests(realm);
         // 1 String
-        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_STRING_NULL, "Horse").findAll().size());
-        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_STRING_NULL, (String) null).findAll().size());
-        // 2 Bytes skipped, doesn't support notEqualTo query
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_STRING_NULL, "Horse").count());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_STRING_NULL, (String) null).count());
+        // 2 Bytes
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_BYTES_NULL, new byte[] {1, 2}).count());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_BYTES_NULL, (byte[]) null).count());
         // 3 Boolean
-        assertEquals(1, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_BOOLEAN_NULL, false).findAll().size());
-        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_BOOLEAN_NULL, (Boolean) null).findAll().size());
+        assertEquals(1, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_BOOLEAN_NULL, false).count());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_BOOLEAN_NULL, (Boolean) null).count());
         // 4 Byte
-        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_BYTE_NULL, (byte) 1).findAll().size());
-        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_BYTE_NULL, (Byte) null).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_BYTE_NULL, (byte) 1).count());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_BYTE_NULL, (Byte) null).count());
         // 5 Short
-        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_SHORT_NULL, (short) 1).findAll().size());
-        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_SHORT_NULL, (Byte) null).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_SHORT_NULL, (short) 1).count());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_SHORT_NULL, (Byte) null).count());
         // 6 Integer
-        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_INTEGER_NULL, 1).findAll().size());
-        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_INTEGER_NULL, (Integer) null).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_INTEGER_NULL, 1).count());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_INTEGER_NULL, (Integer) null).count());
         // 7 Long
-        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_LONG_NULL, 1).findAll().size());
-        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_LONG_NULL, (Integer) null).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_LONG_NULL, 1).count());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_LONG_NULL, (Integer) null).count());
         // 8 Float
-        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_FLOAT_NULL, 1F).findAll().size());
-        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_FLOAT_NULL, (Float) null).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_FLOAT_NULL, 1F).count());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_FLOAT_NULL, (Float) null).count());
         // 9 Double
-        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_DOUBLE_NULL, 1D).findAll().size());
-        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_DOUBLE_NULL, (Double) null).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_DOUBLE_NULL, 1D).count());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_DOUBLE_NULL, (Double) null).count());
         // 10 Date
-        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_DATE_NULL, new Date(0)).findAll().size());
-        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_DATE_NULL, (Date) null).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_DATE_NULL, new Date(0)).count());
+        assertEquals(2, realm.where(NullTypes.class).notEqualTo(NullTypes.FIELD_DATE_NULL, (Date) null).count());
         // 11 Object skipped, doesn't support notEqualTo query
     }
 
@@ -1077,27 +1473,27 @@ public void isNotNull_nullableFields() {
         TestHelper.populateTestRealmForNullTests(realm);
 
         // 1 String
-        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_STRING_NULL).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_STRING_NULL).count());
         // 2 Bytes
-        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_BYTES_NULL).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_BYTES_NULL).count());
         // 3 Boolean
-        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_BOOLEAN_NULL).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_BOOLEAN_NULL).count());
         // 4 Byte
-        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_BYTE_NULL).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_BYTE_NULL).count());
         // 5 Short
-        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_SHORT_NULL).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_SHORT_NULL).count());
         // 6 Integer
-        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_INTEGER_NULL).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_INTEGER_NULL).count());
         // 7 Long
-        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_LONG_NULL).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_LONG_NULL).count());
         // 8 Float
-        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_FLOAT_NULL).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_FLOAT_NULL).count());
         // 9 Double
-        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_DOUBLE_NULL).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_DOUBLE_NULL).count());
         // 10 Date
-        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_DATE_NULL).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_DATE_NULL).count());
         // 11 Object
-        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_OBJECT_NULL).findAll().size());
+        assertEquals(2, realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_OBJECT_NULL).count());
     }
 
     // Querying nullable field with beginsWith - all strings begin with null
@@ -1105,7 +1501,7 @@ public void isNotNull_nullableFields() {
     public void beginWith_nullForNullableStrings() {
         TestHelper.populateTestRealmForNullTests(realm);
         assertEquals("Fish", realm.where(NullTypes.class).beginsWith(NullTypes.FIELD_STRING_NULL,
-                null).findFirst().getFieldStringNotNull());
+                (String) null).findFirst().getFieldStringNotNull());
     }
 
     // Querying nullable field with endsWith - all strings contain with null
@@ -1113,7 +1509,7 @@ public void beginWith_nullForNullableStrings() {
     public void contains_nullForNullableStrings() {
         TestHelper.populateTestRealmForNullTests(realm);
         assertEquals("Fish", realm.where(NullTypes.class).contains(NullTypes.FIELD_STRING_NULL,
-                null).findFirst().getFieldStringNotNull());
+                (String) null).findFirst().getFieldStringNotNull());
     }
 
     // Querying nullable field with endsWith - all strings end with null
@@ -1121,7 +1517,7 @@ public void contains_nullForNullableStrings() {
     public void endsWith_nullForNullableStrings() {
         TestHelper.populateTestRealmForNullTests(realm);
         assertEquals("Fish", realm.where(NullTypes.class).endsWith(NullTypes.FIELD_STRING_NULL,
-                null).findFirst().getFieldStringNotNull());
+                (String) null).findFirst().getFieldStringNotNull());
     }
 
     // Querying with between and table has null values in row.
@@ -1232,6 +1628,86 @@ public void buildQueryFromResultsGC() {
         }
     }
 
+    private static byte[][] binaries = {{1, 2, 3}, {1, 2}, {1, 2, 3}, {2, 3}, {2}, {4, 5, 6}};
+
+    private void createBinaryOnlyDataSet() {
+        realm.beginTransaction();
+        for (int i = 0; i < binaries.length; i++) {
+            AllJavaTypes binaryOnly = new AllJavaTypes((long) i);
+            binaryOnly.setFieldBinary(binaries[i]);
+            realm.copyToRealm(binaryOnly);
+        }
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void equalTo_binary() {
+        createBinaryOnlyDataSet();
+
+        RealmResults<AllJavaTypes> resultList;
+        resultList = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_BINARY, binaries[0]).findAll();
+        assertEquals(2, resultList.size());
+        resultList = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_BINARY, binaries[1]).findAll();
+        assertEquals(1, resultList.size());
+        resultList = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_BINARY, new byte[] {1}).findAll();
+        assertEquals(0, resultList.size());
+    }
+
+    @Test
+    public void equalTo_binary_multiFailures() {
+        createBinaryOnlyDataSet();
+
+        // Non-binary field.
+        try {
+            RealmResults<AllJavaTypes> resultList = realm.where(AllJavaTypes.class)
+                    .equalTo(AllJavaTypes.FIELD_INT, binaries[0]).findAll();
+            fail("Should throw exception.");
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // Non-existent field.
+        try {
+            RealmResults<AllJavaTypes> resultList = realm.where(AllJavaTypes.class)
+                    .equalTo("NotAField", binaries[0]).findAll();
+            fail("Should throw exception.");
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void notEqualTo_binary() {
+        createBinaryOnlyDataSet();
+
+        RealmResults<AllJavaTypes> resultList;
+        resultList = realm.where(AllJavaTypes.class).notEqualTo(AllJavaTypes.FIELD_BINARY, binaries[0]).findAll();
+        assertEquals(4, resultList.size());
+        resultList = realm.where(AllJavaTypes.class).notEqualTo(AllJavaTypes.FIELD_BINARY, binaries[1]).findAll();
+        assertEquals(5, resultList.size());
+        resultList = realm.where(AllJavaTypes.class).notEqualTo(AllJavaTypes.FIELD_BINARY, new byte[] {1}).findAll();
+        assertEquals(6, resultList.size());
+    }
+
+    @Test
+    public void notEqualTo_binary_multiFailures() {
+        createBinaryOnlyDataSet();
+
+        // Non-binary field.
+        try {
+            RealmResults<AllJavaTypes> resultList = realm.where(AllJavaTypes.class)
+                    .notEqualTo(AllJavaTypes.FIELD_INT, binaries[0]).findAll();
+            fail("Should throw exception.");
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // Non-existent field.
+        try {
+            RealmResults<AllJavaTypes> resultList = realm.where(AllJavaTypes.class)
+                    .notEqualTo("NotAField", binaries[0]).findAll();
+            fail("Should throw exception.");
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
     // Test min on empty columns
     @Test
     public void min_emptyColumns() {
@@ -1773,6 +2249,9 @@ public void resultOfTableViewQuery() {
         populateTestRealm();
 
         final RealmResults<AllTypes> results = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, 3L).findAll();
+        assertEquals(1, results.size());
+        assertEquals("test data 3", results.first().getColumnString());
+
         final RealmQuery<AllTypes> tableViewQuery = results.where();
         assertEquals("test data 3", tableViewQuery.findAll().first().getColumnString());
         assertEquals("test data 3", tableViewQuery.findFirst().getColumnString());
@@ -1835,7 +2314,7 @@ private void createIsEmptyDataSet(Realm realm) {
         realm.beginTransaction();
 
         AllJavaTypes emptyValues = new AllJavaTypes();
-        emptyValues.setFieldLong(1);
+        emptyValues.setFieldId(1);
         emptyValues.setFieldString("");
         emptyValues.setFieldBinary(new byte[0]);
         emptyValues.setFieldObject(emptyValues);
@@ -1843,7 +2322,7 @@ private void createIsEmptyDataSet(Realm realm) {
         realm.copyToRealm(emptyValues);
 
         AllJavaTypes nonEmpty = new AllJavaTypes();
-        nonEmpty.setFieldLong(2);
+        nonEmpty.setFieldId(2);
         nonEmpty.setFieldString("Foo");
         nonEmpty.setFieldBinary(new byte[]{1, 2, 3});
         nonEmpty.setFieldObject(nonEmpty);
@@ -1958,7 +2437,7 @@ private void createIsNotEmptyDataSet(Realm realm) {
         realm.beginTransaction();
 
         AllJavaTypes emptyValues = new AllJavaTypes();
-        emptyValues.setFieldLong(1);
+        emptyValues.setFieldId(1);
         emptyValues.setFieldString("");
         emptyValues.setFieldBinary(new byte[0]);
         emptyValues.setFieldObject(emptyValues);
@@ -1966,7 +2445,7 @@ private void createIsNotEmptyDataSet(Realm realm) {
         realm.copyToRealm(emptyValues);
 
         AllJavaTypes notEmpty = new AllJavaTypes();
-        notEmpty.setFieldLong(2);
+        notEmpty.setFieldId(2);
         notEmpty.setFieldString("Foo");
         notEmpty.setFieldBinary(new byte[]{1, 2, 3});
         notEmpty.setFieldObject(notEmpty);
@@ -2071,8 +2550,7 @@ public void execute(Realm realm) {
                 // Crash with i == 1000, 500, 100, 89, 85, 84
                 // Doesn't crash for i == 10, 50, 75, 82, 83
                 for (int i = 0; i < 84; i++) {
-                    AllJavaTypes obj = realm.createObject(AllJavaTypes.class);
-                    obj.setFieldLong(i + 1);
+                    AllJavaTypes obj = realm.createObject(AllJavaTypes.class, i + 1);
                     obj.setFieldBoolean(i % 2 == 0);
                     obj.setFieldObject(obj);
 
@@ -2311,6 +2789,10 @@ public void run() {
             }
         };
 
+        looperThread.keepStrongReference.add(distinctBool);
+        looperThread.keepStrongReference.add(distinctLong);
+        looperThread.keepStrongReference.add(distinctDate);
+        looperThread.keepStrongReference.add(distinctString);
         distinctBool.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
             public void onChange(RealmResults<AnnotationIndexTypes> object) {
@@ -2522,32 +3004,32 @@ public void distinctMultiArgs_emptyField() {
         }
         // a null string field in the middle
         try {
-            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null, AnnotationIndexTypes.FIELD_INDEX_INT);
+            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String) null, AnnotationIndexTypes.FIELD_INDEX_INT);
         } catch (IllegalArgumentException ignored) {
         }
         // a null string field at the end
         try {
-            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, (String)null);
+            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, (String) null);
         } catch (IllegalArgumentException ignored) {
         }
         // (String)null makes varargs a null array.
         try {
-            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null);
+            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String) null);
         } catch (IllegalArgumentException ignored) {
         }
         // Two (String)null for first and varargs fields
         try {
-            query.distinct((String)null, (String)null);
+            query.distinct((String) null, (String) null);
         } catch (IllegalArgumentException ignored) {
         }
         // "" & (String)null combination
         try {
-            query.distinct("", (String)null);
+            query.distinct("", (String) null);
         } catch (IllegalArgumentException ignored) {
         }
         // "" & (String)null combination
         try {
-            query.distinct((String)null, "");
+            query.distinct((String) null, "");
         } catch (IllegalArgumentException ignored) {
         }
         // Two empty fields tests
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
index ebc5546a4f..cbce2dfd79 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
@@ -27,6 +27,7 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mockito;
 
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
 import java.util.List;
@@ -37,9 +38,11 @@
 import io.realm.entities.AllTypes;
 import io.realm.entities.AnnotationIndexTypes;
 import io.realm.entities.CyclicType;
+import io.realm.entities.DefaultValueOfField;
 import io.realm.entities.Dog;
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.Owner;
+import io.realm.entities.RandomPrimaryKey;
 import io.realm.entities.StringOnly;
 import io.realm.internal.Table;
 import io.realm.rule.RunInLooperThread;
@@ -342,7 +345,7 @@ public void distinct_invalidTypesLinkedFields() {
     @Test
     @RunTestInLooperThread
     public void changeListener_syncIfNeeded_updatedFromOtherThread() {
-        final Realm realm = Realm.getInstance(looperThread.createConfiguration("Foo"));
+        final Realm realm = looperThread.realm;
         populateTestRealm(realm, 10);
 
         final RealmResults<AllTypes> results = realm.where(AllTypes.class).lessThan(AllTypes.FIELD_LONG, 10).findAll();
@@ -450,6 +453,10 @@ public void run() {
             }
         };
 
+        looperThread.keepStrongReference.add(distinctBool);
+        looperThread.keepStrongReference.add(distinctLong);
+        looperThread.keepStrongReference.add(distinctDate);
+        looperThread.keepStrongReference.add(distinctString);
         distinctBool.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
             public void onChange(RealmResults<AnnotationIndexTypes> object) {
@@ -512,6 +519,8 @@ public void run() {
             }
         };
 
+        looperThread.keepStrongReference.add(distinctDate);
+        looperThread.keepStrongReference.add(distinctString);
         distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
             @Override
             public void onChange(RealmResults<AnnotationIndexTypes> object) {
@@ -856,6 +865,7 @@ public void addChangeListener() {
         Realm realm = looperThread.realm;
         RealmResults<AllTypes> collection = realm.where(AllTypes.class).findAll();
 
+        looperThread.keepStrongReference.add(collection);
         collection.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
@@ -900,6 +910,7 @@ public void run() {
         });
 
         // Adding it twice will be ignored, so removing it will not cause the listener to be triggered.
+        looperThread.keepStrongReference.add(collection);
         collection.addChangeListener(listener);
         collection.addChangeListener(listener);
         collection.removeChangeListener(listener);
@@ -933,6 +944,7 @@ public void onChange(RealmResults<AllTypes> object) {
             }
         };
 
+        looperThread.keepStrongReference.add(collection);
         collection.addChangeListener(listener);
         collection.removeChangeListener(listener);
 
@@ -983,6 +995,7 @@ public void onChange(RealmResults<AllTypes> object) {
             }
         };
 
+        looperThread.keepStrongReference.add(collection);
         collection.addChangeListener(listenerA);
         collection.addChangeListener(listenerB);
         collection.removeChangeListeners();
@@ -1027,4 +1040,79 @@ public void deleteAndDeleteAll() {
 
         assertEquals(0, realm.where(StringOnly.class).findAll().size());
     }
+
+    @Test
+    public void syncQuery_defaultValuesAreIgnored() {
+        final String fieldIgnoredValue = DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE + ".modified";
+        final String fieldStringValue = DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE + ".modified";
+        final String fieldRandomStringValue = "non-random";
+        final short fieldShortValue = (short) (DefaultValueOfField.FIELD_SHORT_DEFAULT_VALUE + 1);
+        final int fieldIntValue = DefaultValueOfField.FIELD_INT_DEFAULT_VALUE + 1;
+        final long fieldLongPrimaryKeyValue = DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE + 1;
+        final long fieldLongValue = DefaultValueOfField.FIELD_LONG_DEFAULT_VALUE + 1;
+        final byte fieldByteValue = (byte) (DefaultValueOfField.FIELD_BYTE_DEFAULT_VALUE + 1);
+        final float fieldFloatValue = DefaultValueOfField.FIELD_FLOAT_DEFAULT_VALUE + 1;
+        final double fieldDoubleValue = DefaultValueOfField.FIELD_DOUBLE_DEFAULT_VALUE + 1;
+        final boolean fieldBooleanValue = !DefaultValueOfField.FIELD_BOOLEAN_DEFAULT_VALUE;
+        final Date fieldDateValue = new Date(DefaultValueOfField.FIELD_DATE_DEFAULT_VALUE.getTime() + 1);
+        final byte[] fieldBinaryValue = {(byte) (DefaultValueOfField.FIELD_BINARY_DEFAULT_VALUE[0] - 1)};
+        final int fieldObjectIntValue = RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 1;
+        final int fieldListIntValue = RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 2;
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final DefaultValueOfField obj = new DefaultValueOfField();
+                obj.setFieldIgnored(fieldIgnoredValue);
+                obj.setFieldString(fieldStringValue);
+                obj.setFieldRandomString(fieldRandomStringValue);
+                obj.setFieldShort(fieldShortValue);
+                obj.setFieldInt(fieldIntValue);
+                obj.setFieldLongPrimaryKey(fieldLongPrimaryKeyValue);
+                obj.setFieldLong(fieldLongValue);
+                obj.setFieldByte(fieldByteValue);
+                obj.setFieldFloat(fieldFloatValue);
+                obj.setFieldDouble(fieldDoubleValue);
+                obj.setFieldBoolean(fieldBooleanValue);
+                obj.setFieldDate(fieldDateValue);
+                obj.setFieldBinary(fieldBinaryValue);
+
+                final RandomPrimaryKey fieldObjectValue = new RandomPrimaryKey();
+                fieldObjectValue.setFieldInt(fieldObjectIntValue);
+                obj.setFieldObject(fieldObjectValue);
+
+                final RealmList<RandomPrimaryKey> list = new RealmList<>();
+                final RandomPrimaryKey listItem = new RandomPrimaryKey();
+                listItem.setFieldInt(fieldListIntValue);
+                list.add(listItem);
+                obj.setFieldList(list);
+
+                realm.copyToRealm(obj);
+            }
+        });
+
+        final RealmResults<DefaultValueOfField> result = realm.where(DefaultValueOfField.class)
+                .equalTo(DefaultValueOfField.FIELD_LONG_PRIMARY_KEY,
+                        fieldLongPrimaryKeyValue).findAll();
+
+        final DefaultValueOfField obj = result.first();
+
+        assertEquals(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE/*not fieldIgnoredValue*/,
+                obj.getFieldIgnored());
+        assertEquals(fieldStringValue, obj.getFieldString());
+        assertEquals(fieldRandomStringValue, obj.getFieldRandomString());
+        assertEquals(fieldShortValue, obj.getFieldShort());
+        assertEquals(fieldIntValue, obj.getFieldInt());
+        assertEquals(fieldLongPrimaryKeyValue, obj.getFieldLongPrimaryKey());
+        assertEquals(fieldLongValue, obj.getFieldLong());
+        assertEquals(fieldByteValue, obj.getFieldByte());
+        assertEquals(fieldFloatValue, obj.getFieldFloat(), 0f);
+        assertEquals(fieldDoubleValue, obj.getFieldDouble(), 0d);
+        assertEquals(fieldBooleanValue, obj.isFieldBoolean());
+        assertEquals(fieldDateValue, obj.getFieldDate());
+        assertTrue(Arrays.equals(fieldBinaryValue, obj.getFieldBinary()));
+        assertEquals(fieldObjectIntValue, obj.getFieldObject().getFieldInt());
+        assertEquals(1, obj.getFieldList().size());
+        assertEquals(fieldListIntValue, obj.getFieldList().first().getFieldInt());
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 3a31fc86b0..9f44948320 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -22,7 +22,6 @@
 import android.os.Looper;
 import android.os.SystemClock;
 import android.support.test.InstrumentationRegistry;
-import android.support.test.annotation.UiThreadTest;
 import android.support.test.rule.UiThreadTestRule;
 import android.support.test.runner.AndroidJUnit4;
 
@@ -64,6 +63,9 @@
 import io.realm.entities.Cat;
 import io.realm.entities.CyclicType;
 import io.realm.entities.CyclicTypePrimaryKey;
+import io.realm.entities.DefaultValueConstructor;
+import io.realm.entities.DefaultValueOfField;
+import io.realm.entities.DefaultValueSetter;
 import io.realm.entities.Dog;
 import io.realm.entities.DogPrimaryKey;
 import io.realm.entities.NoPrimaryKeyNullTypes;
@@ -83,11 +85,14 @@
 import io.realm.entities.PrimaryKeyRequiredAsBoxedLong;
 import io.realm.entities.PrimaryKeyRequiredAsBoxedShort;
 import io.realm.entities.PrimaryKeyRequiredAsString;
+import io.realm.entities.RandomPrimaryKey;
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.RealmException;
-import io.realm.exceptions.RealmIOException;
+import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmPrimaryKeyConstraintException;
-import io.realm.internal.log.RealmLog;
+import io.realm.internal.SharedRealm;
+import io.realm.internal.Table;
+import io.realm.log.RealmLog;
 import io.realm.objectid.NullPrimaryKey;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
@@ -95,9 +100,12 @@
 import io.realm.util.ExceptionHolder;
 import io.realm.util.RealmThread;
 
+import static io.realm.TestHelper.testNoObjectFound;
+import static io.realm.TestHelper.testOneObjectFound;
 import static io.realm.internal.test.ExtraTests.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertNull;
@@ -173,20 +181,27 @@ private void populateTestRealm() {
         populateTestRealm(realm, TEST_DATA_SIZE);
     }
 
-    @Test(expected = IllegalArgumentException.class)
-    public void getInstance_nullDir() {
-        Realm.getInstance(new RealmConfiguration.Builder((File) null).build());
-    }
-
     @Test
-    public void getInstance_writeProtectedDir() {
-        File folder = new File("/");
-        thrown.expect(IllegalArgumentException.class);
-        Realm.getInstance(new RealmConfiguration.Builder(folder).build());
+    public void getInstance_writeProtectedFile() throws IOException {
+        String REALM_FILE = "readonly.realm";
+        File folder = configFactory.getRoot();
+        File realmFile = new File(folder, REALM_FILE);
+        assertFalse(realmFile.exists());
+        assertTrue(realmFile.createNewFile());
+        assertTrue(realmFile.setWritable(false));
+
+        try {
+            Realm.getInstance(new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext())
+                    .directory(folder)
+                    .name(REALM_FILE)
+                    .build());
+        } catch (RealmFileException expected) {
+            assertEquals(expected.getKind(), RealmFileException.Kind.PERMISSION_DENIED);
+        }
     }
 
     @Test
-    public void getInstance_writeProtectedFile() throws IOException {
+    public void getInstance_writeProtectedFileWithContext() throws IOException {
         String REALM_FILE = "readonly.realm";
         File folder = configFactory.getRoot();
         File realmFile = new File(folder, REALM_FILE);
@@ -194,8 +209,11 @@ public void getInstance_writeProtectedFile() throws IOException {
         assertTrue(realmFile.createNewFile());
         assertTrue(realmFile.setWritable(false));
 
-        thrown.expect(RealmIOException.class);
-        Realm.getInstance(new RealmConfiguration.Builder(folder).name(REALM_FILE).build());
+        try {
+            Realm.getInstance(new RealmConfiguration.Builder(context).directory(folder).name(REALM_FILE).build());
+        } catch (RealmFileException expected) {
+            assertEquals(expected.getKind(), RealmFileException.Kind.PERMISSION_DENIED);
+        }
     }
 
     @Test
@@ -232,38 +250,6 @@ public void checkIfValid() {
         realm = null;
     }
 
-    @Test
-    @UiThreadTest
-    public void internalRealmChangedHandlersRemoved() {
-        realm.close(); // Clear handler created by testRealm in setUp()
-        assertEquals(0, Realm.getHandlers().size());
-        final String REALM_NAME = "test-internalhandlers";
-        RealmConfiguration realmConfig = configFactory.createConfiguration(REALM_NAME);
-        Realm.deleteRealm(realmConfig);
-
-        // Open and close first instance of a Realm
-        Realm realm = null;
-        try {
-            realm = Realm.getInstance(realmConfig);
-            assertFalse(this.realm == realm);
-            assertEquals(1, Realm.getHandlers().size());
-            realm.close();
-
-            // All Realms closed. No handlers should be alive.
-            assertEquals(0, Realm.getHandlers().size());
-
-            // Open instance the 2nd time. Old handler should now be gone
-            realm = Realm.getInstance(realmConfig);
-            assertEquals(1, Realm.getHandlers().size());
-            realm.close();
-
-        } finally {
-            if (realm != null) {
-                realm.close();
-            }
-        }
-    }
-
     @Test
     public void getInstance() {
         assertNotNull("Realm.getInstance unexpectedly returns null", realm);
@@ -482,7 +468,7 @@ public void nestedTransaction() {
             realm.beginTransaction();
             fail();
         } catch (IllegalStateException e) {
-            assertEquals("Nested transactions are not allowed. Use commitTransaction() after each beginTransaction().", e.getMessage());
+            assertTrue(e.getMessage().startsWith("The Realm is already in a write transaction"));
         }
         realm.commitTransaction();
     }
@@ -494,12 +480,17 @@ public void nestedTransaction() {
         METHOD_DELETE_TYPE,
         METHOD_DELETE_ALL,
         METHOD_CREATE_OBJECT,
+        METHOD_CREATE_OBJECT_WITH_PRIMARY_KEY,
         METHOD_COPY_TO_REALM,
         METHOD_COPY_TO_REALM_OR_UPDATE,
         METHOD_CREATE_ALL_FROM_JSON,
         METHOD_CREATE_OR_UPDATE_ALL_FROM_JSON,
         METHOD_CREATE_FROM_JSON,
-        METHOD_CREATE_OR_UPDATE_FROM_JSON
+        METHOD_CREATE_OR_UPDATE_FROM_JSON,
+        METHOD_INSERT_COLLECTION,
+        METHOD_INSERT_OBJECT,
+        METHOD_INSERT_OR_UPDATE_COLLECTION,
+        METHOD_INSERT_OR_UPDATE_OBJECT
     }
 
     // Calling methods on a wrong thread will fail.
@@ -532,6 +523,9 @@ public Boolean call() throws Exception {
                         case METHOD_CREATE_OBJECT:
                             realm.createObject(AllTypes.class);
                             break;
+                        case METHOD_CREATE_OBJECT_WITH_PRIMARY_KEY:
+                            realm.createObject(AllJavaTypes.class, 1L);
+                            break;
                         case METHOD_COPY_TO_REALM:
                             realm.copyToRealm(new AllTypes());
                             break;
@@ -542,13 +536,27 @@ public Boolean call() throws Exception {
                             realm.createAllFromJson(AllTypes.class, "[{}]");
                             break;
                         case METHOD_CREATE_OR_UPDATE_ALL_FROM_JSON:
-                            realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, "[{\"columnLong\":1}]");
+                            realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, "[{\"columnLong\":1," +
+                                    " \"columnBoolean\": true}]");
                             break;
                         case METHOD_CREATE_FROM_JSON:
                             realm.createObjectFromJson(AllTypes.class, "{}");
                             break;
                         case METHOD_CREATE_OR_UPDATE_FROM_JSON:
-                            realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, "{\"columnLong\":1}");
+                            realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, "{\"columnLong\":1," +
+                                    " \"columnBoolean\": true}");
+                            break;
+                        case METHOD_INSERT_COLLECTION:
+                            realm.insert(Arrays.asList(new AllTypes(), new AllTypes()));
+                            break;
+                        case METHOD_INSERT_OBJECT:
+                            realm.insert(new AllTypes());
+                            break;
+                        case METHOD_INSERT_OR_UPDATE_COLLECTION:
+                            realm.insert(Arrays.asList(new AllTypesPrimaryKey(), new AllTypesPrimaryKey()));
+                            break;
+                        case METHOD_INSERT_OR_UPDATE_OBJECT:
+                            realm.insertOrUpdate(new AllTypesPrimaryKey());
                             break;
                     }
                     return false;
@@ -620,13 +628,14 @@ public void cancelTransaction() {
 
     @Test
     public void executeTransaction_null() {
+        SharedRealm.VersionID oldVersion = realm.sharedRealm.getVersionID();
         try {
             realm.executeTransaction(null);
             fail("null transaction should throw");
         } catch (IllegalArgumentException ignored) {
-
         }
-        assertFalse(realm.hasChanged());
+        SharedRealm.VersionID newVersion = realm.sharedRealm.getVersionID();
+        assertEquals(oldVersion, newVersion);
     }
 
     @Test
@@ -1067,7 +1076,6 @@ public void copyToRealm_fromOtherRealm() {
     @Test
     public void copyToRealm() {
         Date date = new Date();
-        date.setTime(1000); // Remove ms. precision as Realm doesn't support it yet.
         Dog dog = new Dog();
         dog.setName("Fido");
         RealmList<Dog> list = new RealmList<Dog>();
@@ -1117,6 +1125,54 @@ public void copyToRealm_cyclicObjectReferences() {
         assertEquals("One", realmObject.getName());
         assertEquals("Two", realmObject.getObject().getName());
         assertEquals(2, realm.where(CyclicType.class).count());
+
+        // testing copyToRealm overload that uses the Iterator
+        // making sure we reuse the same graph cache Map to avoid duplicates
+        realm.beginTransaction();
+        realm.deleteAll();
+        realm.commitTransaction();
+
+        assertEquals(0, realm.where(CyclicType.class).count());
+
+        realm.beginTransaction();
+        List<CyclicType> cyclicTypes = realm.copyToRealm(Arrays.asList(oneCyclicType, anotherCyclicType));
+        realm.commitTransaction();
+        assertEquals(2, cyclicTypes.size());
+        assertEquals("One", cyclicTypes.get(0).getName());
+        assertEquals("Two", cyclicTypes.get(1).getName());
+        assertEquals(2, realm.where(CyclicType.class).count());
+    }
+
+    @Test
+    public void copyToRealm_cyclicObjectReferencesWithPK() {
+        CyclicTypePrimaryKey oneCyclicType = new CyclicTypePrimaryKey(1, "One");
+        CyclicTypePrimaryKey anotherCyclicType = new CyclicTypePrimaryKey(2, "Two");
+        oneCyclicType.setObject(anotherCyclicType);
+        anotherCyclicType.setObject(oneCyclicType);
+
+        realm.beginTransaction();
+        CyclicTypePrimaryKey realmObject = realm.copyToRealm(oneCyclicType);
+        realm.commitTransaction();
+
+        assertEquals("One", realmObject.getName());
+        assertEquals("Two", realmObject.getObject().getName());
+        assertEquals(2, realm.where(CyclicTypePrimaryKey.class).count());
+
+        // testing copyToRealm overload that uses the Iterator
+        // making sure we reuse the same graph cache Map to avoid duplicates
+        realm.beginTransaction();
+        realm.deleteAll();
+        realm.commitTransaction();
+
+        assertEquals(0, realm.where(CyclicTypePrimaryKey.class).count());
+
+        realm.beginTransaction();
+        List<CyclicTypePrimaryKey> cyclicTypes = realm.copyToRealm(Arrays.asList(oneCyclicType, anotherCyclicType));
+        realm.commitTransaction();
+        assertEquals(2, cyclicTypes.size());
+        assertEquals("One", cyclicTypes.get(0).getName());
+        assertEquals("Two", cyclicTypes.get(1).getName());
+        assertEquals(2, realm.where(CyclicTypePrimaryKey.class).count());
     }
 
     @Test
@@ -1153,7 +1209,7 @@ public void copyToRealm_convertsNullToDefaultValue() {
     @Test
     public void copyToRealm_primaryKeyIsSetDirectly() {
         realm.beginTransaction();
-        realm.createObject(OwnerPrimaryKey.class);
+        realm.createObject(OwnerPrimaryKey.class, 0);
         realm.copyToRealm(new OwnerPrimaryKey(1, "Foo"));
         realm.commitTransaction();
         assertEquals(2, realm.where(OwnerPrimaryKey.class).count());
@@ -1233,9 +1289,8 @@ public void copyToRealm_doNotCopyReferencedObjectIfManaged() {
         realm.beginTransaction();
 
         // Child object is managed by Realm
-        CyclicTypePrimaryKey childObj = realm.createObject(CyclicTypePrimaryKey.class);
+        CyclicTypePrimaryKey childObj = realm.createObject(CyclicTypePrimaryKey.class, 1);
         childObj.setName("Child");
-        childObj.setId(1);
 
         // Parent object is an unmanaged object
         CyclicTypePrimaryKey parentObj = new CyclicTypePrimaryKey(2);
@@ -1647,7 +1702,7 @@ public void copyToRealmOrUpdate_objectInOtherThreadThrows() {
         final CountDownLatch bgThreadDoneLatch = new CountDownLatch(1);
 
         realm.beginTransaction();
-        final OwnerPrimaryKey ownerPrimaryKey = realm.createObject(OwnerPrimaryKey.class);
+        final OwnerPrimaryKey ownerPrimaryKey = realm.createObject(OwnerPrimaryKey.class, 0);
         realm.commitTransaction();
 
         new Thread(new Runnable() {
@@ -1755,11 +1810,7 @@ public void writeEncryptedCopyTo() throws Exception {
 
         // Write encrypted copy from a unencrypted Realm
         File destination = new File(encryptedRealmConfig.getPath());
-        try {
-            realm.writeEncryptedCopyTo(destination, encryptedRealmConfig.getEncryptionKey());
-        } catch (Exception e) {
-            fail(e.getMessage());
-        }
+        realm.writeEncryptedCopyTo(destination, encryptedRealmConfig.getEncryptionKey());
 
         Realm encryptedRealm = null;
         try {
@@ -1769,11 +1820,7 @@ public void writeEncryptedCopyTo() throws Exception {
             assertEquals(TEST_DATA_SIZE, encryptedRealm.where(AllTypes.class).count());
 
             destination = new File(reEncryptedRealmConfig.getPath());
-            try {
-                encryptedRealm.writeEncryptedCopyTo(destination, reEncryptedRealmConfig.getEncryptionKey());
-            } catch (Exception e) {
-                fail(e.getMessage());
-            }
+            encryptedRealm.writeEncryptedCopyTo(destination, reEncryptedRealmConfig.getEncryptionKey());
 
             // Verify re-encrypted copy
             Realm reEncryptedRealm = null;
@@ -1791,11 +1838,7 @@ public void writeEncryptedCopyTo() throws Exception {
 
             // Write non-encrypted copy from the encrypted version
             destination = new File(decryptedRealmConfig.getPath());
-            try {
-                encryptedRealm.writeEncryptedCopyTo(destination, null);
-            } catch (Exception e) {
-                fail(e.getMessage());
-            }
+            encryptedRealm.writeEncryptedCopyTo(destination, null);
 
             // Verify decrypted Realm and cleanup
             Realm decryptedRealm = null;
@@ -1820,6 +1863,14 @@ public void writeEncryptedCopyTo() throws Exception {
         }
     }
 
+    @Test
+    public void writeEncryptedCopyTo_wrongKeyLength() {
+        byte[]  wrongLengthKey = new byte[42];
+        File destination = new File(configFactory.getRoot(), "wrong_key.realm");
+        thrown.expect(IllegalArgumentException.class);
+        realm.writeEncryptedCopyTo(destination, wrongLengthKey);
+    }
+
     @Test
     public void deleteRealm_failures() {
         final String OTHER_REALM_NAME = "yetAnotherRealm.realm";
@@ -1859,8 +1910,7 @@ public void setter_updateField() throws Exception {
         realm.beginTransaction();
 
         // Create an owner with two dogs
-        OwnerPrimaryKey owner = realm.createObject(OwnerPrimaryKey.class);
-        owner.setId(1);
+        OwnerPrimaryKey owner = realm.createObject(OwnerPrimaryKey.class, 1);
         owner.setName("Jack");
         Dog rex = realm.createObject(Dog.class);
         rex.setName("Rex");
@@ -1888,8 +1938,11 @@ public void deleteRealm() throws InterruptedException {
         File tempDirRenamed = new File(configFactory.getRoot(), "delete_test_dir_2");
         assertTrue(tempDir.mkdir());
 
-        final RealmConfiguration configuration = new RealmConfiguration.Builder(tempDir).build();
+        final RealmConfiguration configuration = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext())
+                .directory(tempDir)
+                .build();
 
+        final CountDownLatch bgThreadReadyLatch = new CountDownLatch(1);
         final CountDownLatch readyToCloseLatch = new CountDownLatch(1);
         final CountDownLatch closedLatch = new CountDownLatch(1);
 
@@ -1899,6 +1952,7 @@ public void deleteRealm() throws InterruptedException {
             @Override
             public void run() {
                 Realm realm = Realm.getInstance(configuration);
+                bgThreadReadyLatch.countDown();
                 try {
                     readyToCloseLatch.await();
                 } catch (InterruptedException ignored) {
@@ -1911,6 +1965,10 @@ public void run() {
         realm.beginTransaction();
         realm.createObject(AllTypes.class);
         realm.commitTransaction();
+
+        // Wait for bg thread's opening the same Realm.
+        TestHelper.awaitOrFail(bgThreadReadyLatch);
+
         // A core upgrade might change the location of the files
         assertTrue(tempDir.renameTo(tempDirRenamed));
         readyToCloseLatch.countDown();
@@ -1923,7 +1981,9 @@ public void run() {
         assertTrue(Realm.deleteRealm(configuration));
 
         // Directory should be empty now
-        assertEquals(0, tempDir.listFiles().length);
+        // FIXME: .note file is the named pipe for OS android notification. Just don't delete it until we figure out
+        // one single daemon thread for notification.
+        assertEquals(/*0*/1, tempDir.listFiles().length);
     }
 
     // Test that all methods that require a transaction (ie. any function that mutates Realm data)
@@ -2040,12 +2100,18 @@ public void createObject_cannotCreateDynamicRealmObject() {
         }
     }
 
+    @Test(expected = RealmException.class)
+    public void createObject_absentPrimaryKeyThrows() {
+        realm.beginTransaction();
+        realm.createObject(DogPrimaryKey.class);
+    }
+
     @Test
     public void createObjectWithPrimaryKey() {
         realm.beginTransaction();
         AllJavaTypes obj = realm.createObject(AllJavaTypes.class, 42);
         assertEquals(1, realm.where(AllJavaTypes.class).count());
-        assertEquals(42, obj.getFieldLong());
+        assertEquals(42, obj.getFieldId());
     }
 
     @Test
@@ -2206,6 +2272,310 @@ public void createObjectWithPrimaryKey_nullDuplicated() {
         realm.cancelTransaction();
     }
 
+    @Test
+    public void createObject_defaultValueFromModelField() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                // create a DefaultValueOfField with non-default primary key value
+                realm.createObject(DefaultValueOfField.class,
+                        DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
+            }
+        });
+        final String createdRandomString = DefaultValueOfField.lastRandomStringValue;
+
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_STRING,
+                DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_RANDOM_STRING, createdRandomString);
+        testOneObjectFound(realm, DefaultValueOfField.class,DefaultValueOfField.FIELD_SHORT,
+                DefaultValueOfField.FIELD_SHORT_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_INT,
+                DefaultValueOfField.FIELD_INT_DEFAULT_VALUE);
+        // default value for pk must be ignored
+        testNoObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_LONG_PRIMARY_KEY,
+                DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_LONG_PRIMARY_KEY,
+                DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_LONG,
+                DefaultValueOfField.FIELD_LONG_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_BYTE,
+                DefaultValueOfField.FIELD_BYTE_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_FLOAT,
+                DefaultValueOfField.FIELD_FLOAT_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_DOUBLE,
+                DefaultValueOfField.FIELD_DOUBLE_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_BOOLEAN,
+                DefaultValueOfField.FIELD_BOOLEAN_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_DATE,
+                DefaultValueOfField.FIELD_DATE_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_BINARY,
+                DefaultValueOfField.FIELD_BINARY_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_OBJECT + "." + RandomPrimaryKey.FIELD_INT,
+                RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueOfField.class,
+                DefaultValueOfField.FIELD_LIST + "." + RandomPrimaryKey.FIELD_INT,
+                RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
+    }
+
+    @Test
+    public void createObject_defaultValueFromModelConstructor() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                // create a DefaultValueConstructor with non-default primary key value
+                realm.createObject(DefaultValueConstructor.class,
+                        DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
+            }
+        });
+        final String createdRandomString = DefaultValueConstructor.lastRandomStringValue;
+
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_STRING,
+                DefaultValueConstructor.FIELD_STRING_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_RANDOM_STRING,
+                createdRandomString);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_SHORT,
+                DefaultValueConstructor.FIELD_SHORT_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_INT,
+                DefaultValueConstructor.FIELD_INT_DEFAULT_VALUE);;
+        // default value for pk must be ignored
+        testNoObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY,
+                        DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY,
+                        DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_LONG,
+                DefaultValueConstructor.FIELD_LONG_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_BYTE,
+                DefaultValueConstructor.FIELD_BYTE_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_FLOAT,
+                DefaultValueConstructor.FIELD_FLOAT_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_DOUBLE,
+                DefaultValueConstructor.FIELD_DOUBLE_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_BOOLEAN,
+                DefaultValueConstructor.FIELD_BOOLEAN_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_DATE, DefaultValueConstructor.FIELD_DATE_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_BINARY,
+                DefaultValueConstructor.FIELD_BINARY_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_OBJECT + "." + RandomPrimaryKey.FIELD_INT,
+                        RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueConstructor.class,
+                DefaultValueConstructor.FIELD_LIST + "." + RandomPrimaryKey.FIELD_INT,
+                        RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
+    }
+
+    @Test
+    public void createObject_defaultValueSetterInConstructor() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                // create a DefaultValueSetter with non-default primary key value
+                realm.createObject(DefaultValueSetter.class,
+                        DefaultValueSetter.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
+            }
+        });
+        final String createdRandomString = DefaultValueSetter.lastRandomStringValue;
+
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_STRING,
+                DefaultValueSetter.FIELD_STRING_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_RANDOM_STRING,
+                createdRandomString);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_SHORT,
+                DefaultValueSetter.FIELD_SHORT_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_INT,
+                DefaultValueSetter.FIELD_INT_DEFAULT_VALUE);
+        // default value for pk must be ignored
+        testNoObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_LONG_PRIMARY_KEY,
+                        DefaultValueSetter.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_LONG_PRIMARY_KEY,
+                        DefaultValueSetter.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_LONG,
+                DefaultValueSetter.FIELD_LONG_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_BYTE,
+                DefaultValueSetter.FIELD_BYTE_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_FLOAT,
+                DefaultValueSetter.FIELD_FLOAT_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_DOUBLE,
+                DefaultValueSetter.FIELD_DOUBLE_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_BOOLEAN,
+                DefaultValueSetter.FIELD_BOOLEAN_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_DATE,
+                DefaultValueSetter.FIELD_DATE_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_BINARY,
+                DefaultValueSetter.FIELD_BINARY_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_OBJECT + "." + RandomPrimaryKey.FIELD_INT,
+                        RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_LIST + "." + RandomPrimaryKey.FIELD_INT,
+                        RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
+        testOneObjectFound(realm, DefaultValueSetter.class,
+                DefaultValueSetter.FIELD_LIST+ "." + RandomPrimaryKey.FIELD_INT,
+                        RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 1);
+    }
+
+    @Test
+    public void copyToRealm_defaultValuesAreIgnored() {
+        final String fieldIgnoredValue = DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE + ".modified";
+        final String fieldStringValue = DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE + ".modified";
+        final String fieldRandomStringValue = "non-random";
+        final short fieldShortValue = (short) (DefaultValueOfField.FIELD_SHORT_DEFAULT_VALUE + 1);
+        final int fieldIntValue = DefaultValueOfField.FIELD_INT_DEFAULT_VALUE + 1;
+        final long fieldLongPrimaryKeyValue = DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE + 1;
+        final long fieldLongValue = DefaultValueOfField.FIELD_LONG_DEFAULT_VALUE + 1;
+        final byte fieldByteValue = (byte) (DefaultValueOfField.FIELD_BYTE_DEFAULT_VALUE + 1);
+        final float fieldFloatValue = DefaultValueOfField.FIELD_FLOAT_DEFAULT_VALUE + 1;
+        final double fieldDoubleValue = DefaultValueOfField.FIELD_DOUBLE_DEFAULT_VALUE + 1;
+        final boolean fieldBooleanValue = !DefaultValueOfField.FIELD_BOOLEAN_DEFAULT_VALUE;
+        final Date fieldDateValue = new Date(DefaultValueOfField.FIELD_DATE_DEFAULT_VALUE.getTime() + 1);
+        final byte[] fieldBinaryValue = {(byte) (DefaultValueOfField.FIELD_BINARY_DEFAULT_VALUE[0] - 1)};
+        final int fieldObjectIntValue = RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 1;
+        final int fieldListIntValue = RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 2;
+
+        final DefaultValueOfField managedObj;
+        realm.beginTransaction(); {
+            final DefaultValueOfField obj = new DefaultValueOfField();
+            obj.setFieldIgnored(fieldIgnoredValue);
+            obj.setFieldString(fieldStringValue);
+            obj.setFieldRandomString(fieldRandomStringValue);
+            obj.setFieldShort(fieldShortValue);
+            obj.setFieldInt(fieldIntValue);
+            obj.setFieldLongPrimaryKey(fieldLongPrimaryKeyValue);
+            obj.setFieldLong(fieldLongValue);
+            obj.setFieldByte(fieldByteValue);
+            obj.setFieldFloat(fieldFloatValue);
+            obj.setFieldDouble(fieldDoubleValue);
+            obj.setFieldBoolean(fieldBooleanValue);
+            obj.setFieldDate(fieldDateValue);
+            obj.setFieldBinary(fieldBinaryValue);
+
+            final RandomPrimaryKey fieldObjectValue = new RandomPrimaryKey();
+            fieldObjectValue.setFieldInt(fieldObjectIntValue);
+            obj.setFieldObject(fieldObjectValue);
+
+            final RealmList<RandomPrimaryKey> list = new RealmList<>();
+            final RandomPrimaryKey listItem = new RandomPrimaryKey();
+            listItem.setFieldInt(fieldListIntValue);
+            list.add(listItem);
+            obj.setFieldList(list);
+
+            managedObj = realm.copyToRealm(obj);
+        }
+        realm.commitTransaction();
+
+        assertEquals(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE/*not fieldIgnoredValue*/,
+                managedObj.getFieldIgnored());
+        assertEquals(fieldStringValue, managedObj.getFieldString());
+        assertEquals(fieldRandomStringValue, managedObj.getFieldRandomString());
+        assertEquals(fieldShortValue, managedObj.getFieldShort());
+        assertEquals(fieldIntValue, managedObj.getFieldInt());
+        assertEquals(fieldLongPrimaryKeyValue, managedObj.getFieldLongPrimaryKey());
+        assertEquals(fieldLongValue, managedObj.getFieldLong());
+        assertEquals(fieldByteValue, managedObj.getFieldByte());
+        assertEquals(fieldFloatValue, managedObj.getFieldFloat(), 0f);
+        assertEquals(fieldDoubleValue, managedObj.getFieldDouble(), 0d);
+        assertEquals(fieldBooleanValue, managedObj.isFieldBoolean());
+        assertEquals(fieldDateValue, managedObj.getFieldDate());
+        assertTrue(Arrays.equals(fieldBinaryValue, managedObj.getFieldBinary()));
+        assertEquals(fieldObjectIntValue, managedObj.getFieldObject().getFieldInt());
+        assertEquals(1, managedObj.getFieldList().size());
+        assertEquals(fieldListIntValue, managedObj.getFieldList().first().getFieldInt());
+
+        // make sure that excess object by default value is not created.
+        assertEquals(2, realm.where(RandomPrimaryKey.class).count());
+    }
+
+    @Test
+    public void copyFromRealm_defaultValuesAreIgnored() {
+        final DefaultValueOfField managedObj;
+        realm.beginTransaction(); {
+            final DefaultValueOfField obj = new DefaultValueOfField();
+            obj.setFieldIgnored(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE + ".modified");
+            obj.setFieldString(DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE + ".modified");
+            obj.setFieldRandomString("non-random");
+            obj.setFieldShort((short) (DefaultValueOfField.FIELD_SHORT_DEFAULT_VALUE + 1));
+            obj.setFieldInt(DefaultValueOfField.FIELD_INT_DEFAULT_VALUE + 1);
+            obj.setFieldLongPrimaryKey(DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE + 1);
+            obj.setFieldLong(DefaultValueOfField.FIELD_LONG_DEFAULT_VALUE + 1);
+            obj.setFieldByte((byte) (DefaultValueOfField.FIELD_BYTE_DEFAULT_VALUE + 1));
+            obj.setFieldFloat(DefaultValueOfField.FIELD_FLOAT_DEFAULT_VALUE + 1);
+            obj.setFieldDouble(DefaultValueOfField.FIELD_DOUBLE_DEFAULT_VALUE + 1);
+            obj.setFieldBoolean(!DefaultValueOfField.FIELD_BOOLEAN_DEFAULT_VALUE);
+            obj.setFieldDate(new Date(DefaultValueOfField.FIELD_DATE_DEFAULT_VALUE.getTime() + 1));
+            obj.setFieldBinary(new byte[] {(byte) (DefaultValueOfField.FIELD_BINARY_DEFAULT_VALUE[0] - 1)});
+
+            final RandomPrimaryKey fieldObjectValue = new RandomPrimaryKey();
+            fieldObjectValue.setFieldInt(RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 1);
+            obj.setFieldObject(fieldObjectValue);
+
+            final RealmList<RandomPrimaryKey> list = new RealmList<>();
+            final RandomPrimaryKey listItem = new RandomPrimaryKey();
+            listItem.setFieldInt(RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 2);
+            list.add(listItem);
+            obj.setFieldList(list);
+
+            managedObj = realm.copyToRealm(obj);
+        }
+        realm.commitTransaction();
+
+        final DefaultValueOfField copy = realm.copyFromRealm(managedObj);
+
+        assertEquals(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE, copy.getFieldIgnored());
+        assertEquals(managedObj.getFieldString(), copy.getFieldString());
+        assertEquals(managedObj.getFieldRandomString(), copy.getFieldRandomString());
+        assertEquals(managedObj.getFieldShort(), copy.getFieldShort());
+        assertEquals(managedObj.getFieldInt(), copy.getFieldInt());
+        assertEquals(managedObj.getFieldLongPrimaryKey(), copy.getFieldLongPrimaryKey());
+        assertEquals(managedObj.getFieldLong(), copy.getFieldLong());
+        assertEquals(managedObj.getFieldByte(), copy.getFieldByte());
+        assertEquals(managedObj.getFieldFloat(), copy.getFieldFloat(), 0f);
+        assertEquals(managedObj.getFieldDouble(), copy.getFieldDouble(), 0d);
+        assertEquals(managedObj.isFieldBoolean(), copy.isFieldBoolean());
+        assertEquals(managedObj.getFieldDate(), copy.getFieldDate());
+        assertTrue(Arrays.equals(managedObj.getFieldBinary(), copy.getFieldBinary()));
+        assertEquals(managedObj.getFieldObject().getFieldInt(), copy.getFieldObject().getFieldInt());
+        assertEquals(1, copy.getFieldList().size());
+        assertEquals(managedObj.getFieldList().first().getFieldInt(), copy.getFieldList().first().getFieldInt());
+    }
+
     // Test close Realm in another thread different from where it is created.
     @Test
     public void close_differentThread() throws InterruptedException {
@@ -2719,7 +3089,7 @@ public void execute(Realm realm) {
     @Test
     @RunTestInLooperThread
     public void closeRealmInChangeListenerWhenThereIsListenerOnEmptyObject() {
-        final Realm realm = Realm.getInstance(looperThread.createConfiguration());
+        final Realm realm = looperThread.realm;
         final RealmChangeListener<AllTypes> dummyListener = new RealmChangeListener<AllTypes>() {
             @Override
             public void onChange(AllTypes object) {
@@ -2760,7 +3130,7 @@ public void execute(Realm realm) {
     @Test
     @RunTestInLooperThread
     public void closeRealmInChangeListenerWhenThereIsListenerOnObject() {
-        final Realm realm = Realm.getInstance(looperThread.createConfiguration());
+        final Realm realm = looperThread.realm;
         final RealmChangeListener<AllTypes> dummyListener = new RealmChangeListener<AllTypes>() {
             @Override
             public void onChange(AllTypes object) {
@@ -2805,7 +3175,7 @@ public void execute(Realm realm) {
     @Test
     @RunTestInLooperThread
     public void closeRealmInChangeListenerWhenThereIsListenerOnResults() {
-        final Realm realm = Realm.getInstance(looperThread.createConfiguration());
+        final Realm realm = looperThread.realm;
         final RealmChangeListener<RealmResults<AllTypes>> dummyListener = new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
@@ -3332,4 +3702,49 @@ public void run(Realm realm) {
         TestHelper.awaitOrFail(bgRealmFished);
         assertFalse(bgRealmChangeResult.get());
     }
+
+    @Test
+    public void schemaIndexCacheIsUpdatedAfterSchemaChange() {
+        final CatRealmProxy.CatColumnInfo catColumnInfo;
+        catColumnInfo = (CatRealmProxy.CatColumnInfo) realm.schema.columnIndices.getColumnInfo(Cat.class);
+
+        final long nameIndex = catColumnInfo.nameIndex;
+        final AtomicLong nameIndexNew = new AtomicLong(-1L);
+
+        // change column index of "name"
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final Table catTable = realm.getSchema().getTable(Cat.CLASS_NAME);
+                final long nameIndex = catTable.getColumnIndex(Cat.FIELD_NAME);
+                catTable.removeColumn(nameIndex);
+                final long newIndex = catTable.addColumn(RealmFieldType.STRING,
+                        Cat.FIELD_NAME, true);
+
+                realm.setVersion(realm.getConfiguration().getSchemaVersion() + 1);
+
+                nameIndexNew.set(newIndex);
+            }
+        });
+        // we need ↓ to update index cache if the schema version was changed in the same thread.
+        realm.sharedRealm.invokeSchemaChangeListenerIfSchemaChanged();
+
+        // check if the index was changed
+        assertNotEquals(nameIndex, nameIndexNew);
+
+        // check if index in the ColumnInfo is updated
+        assertEquals(nameIndexNew.get(), catColumnInfo.nameIndex);
+        assertEquals(nameIndexNew.get(), (long) catColumnInfo.getIndicesMap().get(Cat.FIELD_NAME));
+
+        // check by actual get and set
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final Cat cat = realm.createObject(Cat.class);
+                cat.setName("pochi");
+            }
+        });
+        //noinspection ConstantConditions
+        assertEquals("pochi", realm.where(Cat.class).findFirst().getName());
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
index bce5a2d917..ba4898e4a3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
@@ -202,10 +202,10 @@ public void call(RealmResults<AllTypes> rxResults) {
     @Test
     @UiThreadTest
     public void dynamicRealmResults_emittedOnSubscribe() {
-        final DynamicRealm dynamicRealm = DynamicRealm.createInstance(realm.getConfiguration());
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
         final RealmResults<DynamicRealmObject> results = dynamicRealm.where(AllTypes.CLASS_NAME).findAll();
-        results.asObservable().subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
+        subscription = results.asObservable().subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
             @Override
             public void call(RealmResults<DynamicRealmObject> rxResults) {
                 assertTrue(rxResults == results);
@@ -214,6 +214,7 @@ public void call(RealmResults<DynamicRealmObject> rxResults) {
         });
         assertTrue(subscribedNotified.get());
         dynamicRealm.close();
+        subscription.unsubscribe();
     }
 
     @Test
@@ -243,12 +244,12 @@ public void call(RealmResults<AllTypes> allTypes) {
     @RunTestInLooperThread
     public void dynamicRealmResults_emittedOnUpdate() {
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
-        final DynamicRealm dynamicRealm = DynamicRealm.createInstance(looperThread.realmConfiguration);
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.realmConfiguration);
         dynamicRealm.beginTransaction();
         RealmResults<DynamicRealmObject> results = dynamicRealm.where(AllTypes.CLASS_NAME).findAll();
         dynamicRealm.commitTransaction();
 
-        results.asObservable().subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
+        subscription = results.asObservable().subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
             @Override
             public void call(RealmResults<DynamicRealmObject> allTypes) {
                 if (subscriberCalled.incrementAndGet() == 2) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
index 7c787c5f59..bb2f61f4cb 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
@@ -153,19 +153,19 @@ private void checkSortTwoFieldsStringAscendingIntAscending(RealmResults<AllTypes
 
         assertEquals("Adam", results.get(0).getColumnString());
         assertEquals(4, results.get(0).getColumnLong());
-        assertEquals(2, ((TableView) results.getTable()).getSourceRowIndex(0));
+        assertEquals(2, ((TableView) results.getTableOrView()).getSourceRowIndex(0));
 
         assertEquals("Adam", results.get(1).getColumnString());
         assertEquals(5, results.get(1).getColumnLong());
-        assertEquals(0, ((TableView) results.getTable()).getSourceRowIndex(1));
+        assertEquals(0, ((TableView) results.getTableOrView()).getSourceRowIndex(1));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(5, results.get(2).getColumnLong());
-        assertEquals(3, ((TableView) results.getTable()).getSourceRowIndex(2));
+        assertEquals(3, ((TableView) results.getTableOrView()).getSourceRowIndex(2));
 
         assertEquals("Brian", results.get(3).getColumnString());
         assertEquals(4, results.get(3).getColumnLong());
-        assertEquals(1, ((TableView) results.getTable()).getSourceRowIndex(3));
+        assertEquals(1, ((TableView) results.getTableOrView()).getSourceRowIndex(3));
     }
 
     private void checkSortTwoFieldsIntString(RealmResults<AllTypes> results) {
@@ -179,19 +179,19 @@ private void checkSortTwoFieldsIntString(RealmResults<AllTypes> results) {
 
         assertEquals("Adam", results.get(0).getColumnString());
         assertEquals(4, results.get(0).getColumnLong());
-        assertEquals(2, ((TableView) results.getTable()).getSourceRowIndex(0));
+        assertEquals(2, ((TableView) results.getTableOrView()).getSourceRowIndex(0));
 
         assertEquals("Brian", results.get(1).getColumnString());
         assertEquals(4, results.get(1).getColumnLong());
-        assertEquals(1, ((TableView) results.getTable()).getSourceRowIndex(1));
+        assertEquals(1, ((TableView) results.getTableOrView()).getSourceRowIndex(1));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(5, results.get(2).getColumnLong());
-        assertEquals(0, ((TableView) results.getTable()).getSourceRowIndex(2));
+        assertEquals(0, ((TableView) results.getTableOrView()).getSourceRowIndex(2));
 
         assertEquals("Adam", results.get(3).getColumnString());
         assertEquals(5, results.get(3).getColumnLong());
-        assertEquals(3, ((TableView) results.getTable()).getSourceRowIndex(3));
+        assertEquals(3, ((TableView) results.getTableOrView()).getSourceRowIndex(3));
     }
 
     private void checkSortTwoFieldsIntAscendingStringDescending(RealmResults<AllTypes> results) {
@@ -205,19 +205,19 @@ private void checkSortTwoFieldsIntAscendingStringDescending(RealmResults<AllType
 
         assertEquals("Brian", results.get(0).getColumnString());
         assertEquals(4, results.get(0).getColumnLong());
-        assertEquals(1, ((TableView) results.getTable()).getSourceRowIndex(0));
+        assertEquals(1, ((TableView) results.getTableOrView()).getSourceRowIndex(0));
 
         assertEquals("Adam", results.get(1).getColumnString());
         assertEquals(4, results.get(1).getColumnLong());
-        assertEquals(2, ((TableView) results.getTable()).getSourceRowIndex(1));
+        assertEquals(2, ((TableView) results.getTableOrView()).getSourceRowIndex(1));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(5, results.get(2).getColumnLong());
-        assertEquals(0, ((TableView) results.getTable()).getSourceRowIndex(2));
+        assertEquals(0, ((TableView) results.getTableOrView()).getSourceRowIndex(2));
 
         assertEquals("Adam", results.get(3).getColumnString());
         assertEquals(5, results.get(3).getColumnLong());
-        assertEquals(3, ((TableView) results.getTable()).getSourceRowIndex(3));
+        assertEquals(3, ((TableView) results.getTableOrView()).getSourceRowIndex(3));
     }
 
     private void checkSortTwoFieldsStringAscendingIntDescending(RealmResults<AllTypes> results) {
@@ -231,19 +231,19 @@ private void checkSortTwoFieldsStringAscendingIntDescending(RealmResults<AllType
 
         assertEquals("Adam", results.get(0).getColumnString());
         assertEquals(5, results.get(0).getColumnLong());
-        assertEquals(0, ((TableView) results.getTable()).getSourceRowIndex(0));
+        assertEquals(0, ((TableView) results.getTableOrView()).getSourceRowIndex(0));
 
         assertEquals("Adam", results.get(1).getColumnString());
         assertEquals(5, results.get(1).getColumnLong());
-        assertEquals(3, ((TableView) results.getTable()).getSourceRowIndex(1));
+        assertEquals(3, ((TableView) results.getTableOrView()).getSourceRowIndex(1));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(4, results.get(2).getColumnLong());
-        assertEquals(2, ((TableView) results.getTable()).getSourceRowIndex(2));
+        assertEquals(2, ((TableView) results.getTableOrView()).getSourceRowIndex(2));
 
         assertEquals("Brian", results.get(3).getColumnString());
         assertEquals(4, results.get(3).getColumnLong());
-        assertEquals(1, ((TableView) results.getTable()).getSourceRowIndex(3));
+        assertEquals(1, ((TableView) results.getTableOrView()).getSourceRowIndex(3));
     }
 
     @Test
@@ -344,7 +344,7 @@ public void realmSortMultiFailures() {
     public void resorting() throws InterruptedException {
         final AtomicInteger changeListenerCalled = new AtomicInteger(4);
 
-        final Realm realm = Realm.getInstance(looperThread.createConfiguration());
+        final Realm realm = looperThread.realm;
         realm.setAutoRefresh(true);
 
         final Runnable endTest = new Runnable() {
@@ -365,6 +365,7 @@ public void run() {
 
         // rr0: [0, 1, 2, 3]
         final RealmResults<AllTypes> rr0 = realm.where(AllTypes.class).findAll();
+        looperThread.keepStrongReference.add(rr0);
         rr0.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> element) {
@@ -376,6 +377,7 @@ public void onChange(RealmResults<AllTypes> element) {
 
         // rr1: [1, 2, 0, 3]
         final RealmResults<AllTypes> rr1 = realm.where(AllTypes.class).findAll().sort(FIELD_LONG, Sort.ASCENDING);
+        looperThread.keepStrongReference.add(rr1);
         rr1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> element) {
@@ -391,6 +393,7 @@ public void onChange(RealmResults<AllTypes> element) {
 
         // rr2: [0, 3, 1, 2]
         final RealmResults<AllTypes> rr2 = realm.where(AllTypes.class).findAll().sort(FIELD_LONG, Sort.DESCENDING);
+        looperThread.keepStrongReference.add(rr2);
         rr2.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> element) {
@@ -479,6 +482,7 @@ public void run() {
 
         RealmResults<AllTypes> objectsAscending = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_DATE, Sort.ASCENDING);
         assertEquals(TEST_SIZE, objectsAscending.size());
+        looperThread.keepStrongReference.add(objectsAscending);
         objectsAscending.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> element) {
@@ -494,6 +498,7 @@ public void onChange(RealmResults<AllTypes> element) {
 
         RealmResults<AllTypes> objectsDescending = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_DATE, Sort.DESCENDING);
         assertEquals(TEST_SIZE, objectsDescending.size());
+        looperThread.keepStrongReference.add(objectsDescending);
         objectsDescending.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> element) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index 4d44544c27..cade67abf7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -19,6 +19,7 @@
 import android.content.Context;
 import android.content.res.AssetManager;
 import android.os.Looper;
+import android.support.test.InstrumentationRegistry;
 import android.util.Log;
 
 import org.junit.Assert;
@@ -56,9 +57,12 @@
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.async.RealmThreadPoolExecutor;
-import io.realm.internal.log.Logger;
+import io.realm.log.AndroidLogger;
+import io.realm.log.LogLevel;
+import io.realm.log.Logger;
 import io.realm.rule.TestRealmConfigurationFactory;
 
+import static android.R.id.message;
 import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertEquals;
 
@@ -110,9 +114,7 @@ public static Table getTableWithAllColumnTypes() {
         t.addColumn(RealmFieldType.DOUBLE, "double");
         t.addColumn(RealmFieldType.FLOAT, "float");
         t.addColumn(RealmFieldType.INTEGER, "long");
-        t.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "mixed");
         t.addColumn(RealmFieldType.STRING, "string");
-        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
 
         return t;
     }
@@ -173,7 +175,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
      * @return Logger implementation
      */
     public static Logger getFailureLogger(final int failureLevel) {
-        return new Logger() {
+        return new AndroidLogger(Log.VERBOSE) {
 
             private void failIfEqualOrAbove(int logLevel, int failureLevel) {
                 if (logLevel >= failureLevel) {
@@ -182,54 +184,35 @@ private void failIfEqualOrAbove(int logLevel, int failureLevel) {
             }
 
             @Override
-            public void v(String message) {
+            public void trace(Throwable t, String message, Object... args) {
                 failIfEqualOrAbove(Log.VERBOSE, failureLevel);
             }
 
             @Override
-            public void v(String message, Throwable t) {
-                failIfEqualOrAbove(Log.VERBOSE, failureLevel);
-            }
-
-            @Override
-            public void d(String message) {
-                failIfEqualOrAbove(Log.DEBUG, failureLevel);
-            }
-
-            @Override
-            public void d(String message, Throwable t) {
+            public void debug(Throwable t, String message, Object... args) {
                 failIfEqualOrAbove(Log.DEBUG, failureLevel);
             }
 
             @Override
-            public void i(String message) {
+            public void info(Throwable t, String message, Object... args) {
                 failIfEqualOrAbove(Log.INFO, failureLevel);
             }
 
             @Override
-            public void i(String message, Throwable t) {
-                failIfEqualOrAbove(Log.INFO, failureLevel);
-            }
-
-            @Override
-            public void w(String message) {
+            public void warn(Throwable t, String message, Object... args) {
                 failIfEqualOrAbove(Log.WARN, failureLevel);
             }
 
             @Override
-            public void w(String message, Throwable t) {
-                failIfEqualOrAbove(Log.WARN, failureLevel);
-            }
-
-            @Override
-            public void e(String message) {
+            public void error(Throwable t, String message, Object... args) {
                 failIfEqualOrAbove(Log.ERROR, failureLevel);
             }
 
             @Override
-            public void e(String message, Throwable t) {
+            public void fatal(Throwable t, String message, Object... args) {
                 failIfEqualOrAbove(Log.ERROR, failureLevel);
             }
+
         };
     }
 
@@ -247,62 +230,67 @@ public static String getRandomString(int length) {
      */
     public static class TestLogger implements Logger {
 
+        private final int minimumLevel;
         public String message;
         public Throwable throwable;
 
-        @Override
-        public void v(String message) {
-            this.message = message;
+        public TestLogger() {
+            this(LogLevel.DEBUG);
         }
 
-        @Override
-        public void v(String message, Throwable t) {
-            this.message = message;
-            this.throwable = t;
+        public TestLogger(int minimumLevel) {
+            this.minimumLevel = minimumLevel;
         }
 
         @Override
-        public void d(String message) {
-            this.message = message;
+        public int getMinimumNativeDebugLevel() {
+            return minimumLevel;
         }
 
         @Override
-        public void d(String message, Throwable t) {
-            this.message = message;
-            this.throwable = t;
-        }
-
-        @Override
-        public void i(String message) {
-            this.message = message;
+        public void trace(Throwable t, String message, Object... args) {
+            if (minimumLevel <= LogLevel.TRACE) {
+                this.message = (message != null) ? String.format(message, args) : null;
+                this.throwable = t;
+            }
         }
 
         @Override
-        public void i(String message, Throwable t) {
-            this.message = message;
-            this.throwable = t;
+        public void debug(Throwable t, String message, Object... args) {
+            if (minimumLevel <= LogLevel.DEBUG) {
+                this.message = (message != null) ? String.format(message, args) : null;
+                this.throwable = t;
+            }
         }
 
         @Override
-        public void w(String message) {
-            this.message = message;
+        public void info(Throwable t, String message, Object... args) {
+            if (minimumLevel <= LogLevel.INFO) {
+                this.message = (message != null) ? String.format(message, args) : null;
+                this.throwable = t;
+            }
         }
 
         @Override
-        public void w(String message, Throwable t) {
-            this.message = message;
+        public void warn(Throwable t, String message, Object... args) {
+            this.message = (message != null) ? String.format(message, args) : null;
             this.throwable = t;
         }
 
         @Override
-        public void e(String message) {
-            this.message = message;
+        public void error(Throwable t, String message, Object... args) {
+            if (minimumLevel <= LogLevel.ERROR) {
+                this.message = (message != null) ? String.format(message, args) : null;
+                this.throwable = t;
+            }
         }
 
         @Override
-        public void e(String message, Throwable t) {
-            this.message = message;
-            this.throwable = t;
+        public void fatal(Throwable t, String message, Object... args) {
+            if (minimumLevel <= LogLevel.FATAL) {
+                this.message = (message != null) ? String.format(message, args) : null;
+                this.throwable = t;
+            }
         }
     }
 
@@ -384,7 +372,9 @@ public static RealmConfiguration createConfiguration(Context context, String nam
      */
     @Deprecated
     public static RealmConfiguration createConfiguration(File dir, String name, byte[] key) {
-        RealmConfiguration.Builder config = new RealmConfiguration.Builder(dir).name(name);
+        RealmConfiguration.Builder config = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext())
+                .directory(dir)
+                .name(name);
         if (key != null) {
             config.encryptionKey(key);
         }
@@ -885,8 +875,6 @@ public static void exitOrThrow(final ExecutorService executorService,
             // used. Any exception in the `after()` code will mask the original error.
             TestHelper.awaitOrFail(signalTestFinished);
         } finally {
-            // close the executor
-            executorService.shutdownNow();
             if (looper[0] != null) {
                 // failing to quit the looper will not execute the finally block responsible
                 // of closing the Realm
@@ -895,6 +883,9 @@ public static void exitOrThrow(final ExecutorService executorService,
 
             // wait for the finally block to execute & close the Realm
             TestHelper.awaitOrFail(signalClosedRealm);
+            // Close the executor.
+            // This needs to be called after waiting since it might interrupt waitRealmThreadExecutorFinish().
+            executorService.shutdownNow();
 
             if (throwable[0] != null) {
                 // throw any assertion errors happened in the background thread
@@ -946,13 +937,73 @@ public static void quitLooperOrFail() {
         }
     }
 
+    public static void testNoObjectFound(
+            Realm realm,
+            Class<? extends RealmModel> clazz,
+            String fieldName, Object value) {
+        testObjectCount(realm, 0L, clazz, fieldName, value);
+    }
+
+    public static void testOneObjectFound(
+            Realm realm,
+            Class<? extends RealmModel> clazz,
+            String fieldName, Object value) {
+        testObjectCount(realm, 1L, clazz, fieldName, value);
+    }
+
+    public static void testObjectCount(
+            Realm realm,
+            long expectedCount,
+            Class<? extends RealmModel> clazz,
+            String fieldName, Object value) {
+        final RealmQuery<? extends RealmModel> query;
+        switch (value.getClass().getSimpleName()) {
+            case "String":
+                query = realm.where(clazz).equalTo(fieldName, (String) value);
+                break;
+            case "Byte":
+                query = realm.where(clazz).equalTo(fieldName, (Byte) value);
+                break;
+            case "Short":
+                query = realm.where(clazz).equalTo(fieldName, (Short) value);
+                break;
+            case "Integer":
+                query = realm.where(clazz).equalTo(fieldName, (Integer) value);
+                break;
+            case "Long":
+                query = realm.where(clazz).equalTo(fieldName, (Long) value);
+                break;
+            case "Float":
+                query = realm.where(clazz).equalTo(fieldName, (Float) value);
+                break;
+            case "Double":
+                query = realm.where(clazz).equalTo(fieldName, (Double) value);
+                break;
+            case "Boolean":
+                query = realm.where(clazz).equalTo(fieldName, (Boolean) value);
+                break;
+            case "Date":
+                query = realm.where(clazz).equalTo(fieldName, (Date) value);
+                break;
+            case "byte[]":
+                query = realm.where(clazz).equalTo(fieldName, (byte[]) value);
+                break;
+            default:
+                throw new AssertionError("unknown type: " + value.getClass().getSimpleName());
+        }
+
+        assertEquals(expectedCount, query.count());
+    }
+
     /**
      * Replaces the current thread executor with a another one for testing.
      * WARNING: This method should only be called before any async tasks have been started.
+     *          Call {@link #resetRealmThreadExecutor()} before test return to reset the excutor to default.
      *
      * @param executor {@link RealmThreadPoolExecutor} that should replace the current one
      */
-    public static RealmThreadPoolExecutor replaceRealmThreadExectutor(RealmThreadPoolExecutor executor) throws NoSuchFieldException, IllegalAccessException {
+    public static RealmThreadPoolExecutor replaceRealmThreadExecutor(RealmThreadPoolExecutor executor)
+            throws NoSuchFieldException, IllegalAccessException {
         Field field = BaseRealm.class.getDeclaredField("asyncTaskExecutor");
         field.setAccessible(true);
         RealmThreadPoolExecutor oldExecutor = (RealmThreadPoolExecutor) field.get(null);
@@ -960,6 +1011,37 @@ public static RealmThreadPoolExecutor replaceRealmThreadExectutor(RealmThreadPoo
         return oldExecutor;
     }
 
+    /**
+     * This will first wait for finishing all tasks in BaseRealm.asyncTaskExecutor, throws if time out.
+     * Then reset the BaseRealm.asyncTaskExecutor to the default value.
+     *
+     * @throws NoSuchFieldException
+     * @throws IllegalAccessException
+     */
+    public static void resetRealmThreadExecutor() throws NoSuchFieldException, IllegalAccessException {
+        waitRealmThreadExecutorFinish();
+        replaceRealmThreadExecutor(RealmThreadPoolExecutor.newDefaultExecutor());
+    }
+
+    /**
+     * Wait and check if all tasks in BaseRealm.asyncTaskExecutor can be finished in 5 seconds, otherwise fail the test.
+     */
+    public static void waitRealmThreadExecutorFinish() {
+        int counter = 50;
+        while (counter > 0) {
+            if (BaseRealm.asyncTaskExecutor.getActiveCount() == 0) {
+                return;
+            }
+            try {
+                Thread.sleep(100);
+            } catch (InterruptedException e) {
+                fail(e.getMessage());
+            }
+            counter--;
+        }
+        fail("'BaseRealm.asyncTaskExecutor' is not finished in " + counter/10 + " seconds");
+    }
+
     /**
      * Emulates an environment where RxJava is not available.
      *
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
index ae3d2f8526..b3784cbe05 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
@@ -89,7 +89,7 @@ public void callback_should_trigger_for_createObject() {
             @Override
             public void onChange(Realm object) {
                 if (globalCommitInvocations.incrementAndGet() == 1) {
-                    realm.handler.post(new Runnable() {
+                    looperThread.postRunnable(new Runnable() {
                         @Override
                         public void run() {
                             assertEquals(1, typebasedCommitInvocations.get());
@@ -104,6 +104,7 @@ public void run() {
         final Dog dog = realm.createObject(Dog.class);
         realm.commitTransaction();
 
+        looperThread.keepStrongReference.add(dog);
         dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
             public void onChange(Dog object) {
@@ -121,11 +122,12 @@ public void onChange(Dog object) {
     @RunTestInLooperThread
     public void callback_should_trigger_for_createObject_dynamic_realm() {
         final DynamicRealm realm = DynamicRealm.getInstance(looperThread.realmConfiguration);
+        looperThread.keepStrongReference.add(realm);
         realm.addChangeListener(new RealmChangeListener<DynamicRealm>() {
             @Override
             public void onChange(DynamicRealm object) {
                 if (globalCommitInvocations.incrementAndGet() == 1) {
-                    realm.handler.post(new Runnable() {
+                    looperThread.postRunnable(new Runnable() {
                         @Override
                         public void run() {
                             realm.close();
@@ -141,6 +143,7 @@ public void run() {
         final DynamicRealmObject dog = realm.createObject("Dog");
         realm.commitTransaction();
 
+        looperThread.keepStrongReference.add(dog);
         dog.addChangeListener(new RealmChangeListener<DynamicRealmObject>() {
             @Override
             public void onChange(DynamicRealmObject object) {
@@ -163,7 +166,7 @@ public void callback_should_trigger_for_copyToRealm() {
             @Override
             public void onChange(Realm object) {
                 if (globalCommitInvocations.incrementAndGet() == 1) {
-                    realm.handler.post(new Runnable() {
+                    looperThread.postRunnable(new Runnable() {
                         @Override
                         public void run() {
                             assertEquals(1, typebasedCommitInvocations.get());
@@ -180,6 +183,7 @@ public void run() {
         final Dog dog = realm.copyToRealm(akamaru);
         realm.commitTransaction();
 
+        looperThread.keepStrongReference.add(dog);
         dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
             public void onChange(Dog object) {
@@ -202,7 +206,7 @@ public void callback_should_trigger_for_copyToRealmOrUpdate() {
             @Override
             public void onChange(Realm object) {
                 if (globalCommitInvocations.incrementAndGet() == 1) {
-                    realm.handler.post(new Runnable() {
+                    looperThread.postRunnable(new Runnable() {
                         @Override
                         public void run() {
                             assertEquals(1, typebasedCommitInvocations.get());
@@ -221,6 +225,7 @@ public void run() {
         final PrimaryKeyAsLong primaryKeyAsLong = realm.copyToRealmOrUpdate(obj);
         realm.commitTransaction();
 
+        looperThread.keepStrongReference.add(primaryKeyAsLong);
         primaryKeyAsLong.addChangeListener(new RealmChangeListener<PrimaryKeyAsLong>() {
             @Override
             public void onChange(PrimaryKeyAsLong object) {
@@ -250,7 +255,7 @@ public void callback_should_trigger_for_createObjectFromJson() {
             @Override
             public void onChange(Realm object) {
                 if (globalCommitInvocations.incrementAndGet() == 1) {
-                    realm.handler.post(new Runnable() {
+                    looperThread.postRunnable(new Runnable() {
                         @Override
                         public void run() {
                             assertEquals(1, typebasedCommitInvocations.get());
@@ -268,6 +273,7 @@ public void run() {
             realm.commitTransaction();
             in.close();
 
+            looperThread.keepStrongReference.add(objectFromJson);
             objectFromJson.addChangeListener(new RealmChangeListener<AllTypes>() {
                 @Override
                 public void onChange(AllTypes object) {
@@ -299,7 +305,7 @@ public void callback_should_trigger_for_createObjectFromJson_from_JSONObject() {
             @Override
             public void onChange(Realm object) {
                 if (globalCommitInvocations.incrementAndGet() == 1) {
-                    realm.handler.post(new Runnable() {
+                    looperThread.postRunnable(new Runnable() {
                         @Override
                         public void run() {
                             assertEquals(1, typebasedCommitInvocations.get());
@@ -323,6 +329,7 @@ public void run() {
             final AllTypes objectFromJson = realm.createObjectFromJson(AllTypes.class, json);
             realm.commitTransaction();
 
+            looperThread.keepStrongReference.add(objectFromJson);
             objectFromJson.addChangeListener(new RealmChangeListener<AllTypes>() {
                 @Override
                 public void onChange(AllTypes object) {
@@ -354,7 +361,7 @@ public void callback_should_trigger_for_createOrUpdateObjectFromJson() {
             @Override
             public void onChange(Realm object) {
                 if (globalCommitInvocations.incrementAndGet() == 1) {
-                    realm.handler.post(new Runnable() {
+                    looperThread.postRunnable(new Runnable() {
                         @Override
                         public void run() {
                             assertEquals(1, typebasedCommitInvocations.get());
@@ -386,6 +393,7 @@ public void run() {
             realm.commitTransaction();
             in.close();
 
+            looperThread.keepStrongReference.add(objectFromJson);
             objectFromJson.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
                 @Override
                 public void onChange(AllTypesPrimaryKey object) {
@@ -418,7 +426,7 @@ public void callback_should_trigger_for_createOrUpdateObjectFromJson_from_JSONOb
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
-                realm.handler.post(new Runnable() {
+                looperThread.postRunnable(new Runnable() {
                     @Override
                     public void run() {
                         assertEquals(1, typebasedCommitInvocations.get());
@@ -445,6 +453,7 @@ public void run() {
         final AllTypesPrimaryKey newObj = realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, json);
         realm.commitTransaction();
 
+        looperThread.keepStrongReference.add(newObj);
         newObj.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
             @Override
             public void onChange(AllTypesPrimaryKey object) {
@@ -478,6 +487,7 @@ public void callback_with_relevant_commit_realmobject_sync() {
         realm.commitTransaction();
 
         final Dog dog = realm.where(Dog.class).findFirst();
+        looperThread.keepStrongReference.add(dog);
         dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
             public void onChange(Dog object) {
@@ -508,7 +518,7 @@ public void onChange(Realm object) {
 
                     case 3:
                         // Step 5: Complete test
-                        realm.handler.post(new Runnable() {
+                        looperThread.postRunnable(new Runnable() {
                             @Override
                             public void run() {
                                 assertEquals(1, typebasedCommitInvocations.get());
@@ -536,6 +546,7 @@ public void callback_with_relevant_commit_realmobject_async() {
         final Dog dog = realm.where(Dog.class).findFirstAsync();
         assertTrue(dog.load());
 
+        looperThread.keepStrongReference.add(dog);
         dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
             public void onChange(Dog object) {
@@ -573,7 +584,7 @@ public void onChange(Realm object) {
 
                     case 3:
                         // Step 5: Complete test
-                        realm.handler.post(new Runnable() {
+                        looperThread.postRunnable(new Runnable() {
                             @Override
                             public void run() {
                                 assertEquals(3, globalCommitInvocations.get());
@@ -613,6 +624,7 @@ public void onChange(Realm object) {
 
         final Dog dog = realm.where(Dog.class).findFirstAsync();
         assertTrue(dog.load());
+        looperThread.keepStrongReference.add(dog);
         dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
             public void onChange(Dog object) {
@@ -653,7 +665,7 @@ public void run() {
 
                     case 3: // triggered by relevant commit from LooperThread2
                         assertEquals("Akamaru", dog.getName());
-                        realm.handler.post(new Runnable() {
+                        looperThread.postRunnable(new Runnable() {
                             @Override
                             public void run() {
                                 // trigger second callback invocation
@@ -677,7 +689,7 @@ public void run() {
                         // posting as an event will give the handler a chance
                         // to deliver the notification for globalCommitInvocations
                         // otherwise, test will exit before the callback get a chance to be invoked
-                        realm.handler.post(new Runnable() {
+                        looperThread.postRunnable(new Runnable() {
                             @Override
                             public void run() {
                                 assertEquals(3, globalCommitInvocations.get());
@@ -713,6 +725,7 @@ public void onChange(Realm object) {
 
         final Dog dog = realm.where(Dog.class).findFirstAsync();
         assertTrue(dog.load());
+        looperThread.keepStrongReference.add(dog);
         dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
             public void onChange(Dog object) {
@@ -743,7 +756,7 @@ protected void doInBackground(Realm realm) {
                     }
                     case 3: {
                         assertEquals("Akamaru", dog.getName());
-                        realm.handler.postDelayed(new Runnable() {
+                        looperThread.postRunnable(new Runnable() {
                             @Override
                             public void run() {
                                 // trigger second callback invocation
@@ -759,7 +772,7 @@ public void run() {
                                     }
                                 }.start();
                             }
-                        }, TimeUnit.SECONDS.toMillis(0));
+                        });
                         break;
                     }
                     case 4: {
@@ -768,7 +781,7 @@ public void run() {
                         // posting as an event will give the handler a chance
                         // to deliver the notification for globalCommitInvocations
                         // otherwise, test will exit before the callback get a chance to be invoked
-                        realm.handler.post(new Runnable() {
+                        looperThread.postRunnable(new Runnable() {
                             @Override
                             public void run() {
                                 assertEquals(3, globalCommitInvocations.get());
@@ -797,6 +810,7 @@ public void callback_with_relevant_commit_realmresults_sync() {
         realm.commitTransaction();
 
         final RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
+        looperThread.keepStrongReference.add(dogs);
         dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
             public void onChange(RealmResults<Dog> object) {
@@ -828,7 +842,7 @@ public void onChange(Realm object) {
 
                     case 3:
                         // Step 5: Complete test
-                        realm.handler.post(new Runnable() {
+                        looperThread.postRunnable(new Runnable() {
                             @Override
                             public void run() {
                                 assertEquals(1, typebasedCommitInvocations.get());
@@ -854,6 +868,7 @@ public void callback_with_relevant_commit_realmresults_async() {
 
         final RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
         assertTrue(dogs.load());
+        looperThread.keepStrongReference.add(dogs);
         dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
             public void onChange(RealmResults<Dog> object) {
@@ -890,7 +905,7 @@ public void onChange(Realm object) {
 
                     case 3:
                         // Step 5: Complete test
-                        realm.handler.post(new Runnable() {
+                        looperThread.postRunnable(new Runnable() {
                             @Override
                             public void run() {
                                 assertEquals(2, typebasedCommitInvocations.get());
@@ -915,7 +930,7 @@ public void multiple_callbacks_should_be_invoked_realmobject_sync() {
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
-                realm.handler.post(new Runnable() {
+                looperThread.postRunnable(new Runnable() {
                     @Override
                     public void run() {
                         assertEquals(NUMBER_OF_LISTENERS, typebasedCommitInvocations.get());
@@ -930,6 +945,7 @@ public void run() {
         realm.commitTransaction();
 
         Dog dog = realm.where(Dog.class).findFirst();
+        looperThread.keepStrongReference.add(dog);
         for (int i = 0; i < NUMBER_OF_LISTENERS; i++) {
             dog.addChangeListener(new RealmChangeListener<Dog>() {
                 @Override
@@ -953,7 +969,7 @@ public void multiple_callbacks_should_be_invoked_realmobject_async() {
         RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
-                realm.handler.post(new Runnable() {
+                looperThread.postRunnable(new Runnable() {
                     @Override
                     public void run() {
                         assertEquals(NUMBER_OF_LISTENERS, typebasedCommitInvocations.get());
@@ -971,6 +987,7 @@ public void run() {
 
         Dog dog = realm.where(Dog.class).findFirstAsync();
         assertTrue(dog.load());
+        looperThread.keepStrongReference.add(dog);
         for (int i = 0; i < NUMBER_OF_LISTENERS; i++) {
             dog.addChangeListener(new RealmChangeListener<Dog>() {
                 @Override
@@ -994,7 +1011,7 @@ public void multiple_callbacks_should_be_invoked_realmresults_sync() {
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
-                realm.handler.post(new Runnable() {
+                looperThread.postRunnable(new Runnable() {
                     @Override
                     public void run() {
                         assertEquals(NUMBER_OF_LISTENERS, typebasedCommitInvocations.get());
@@ -1009,6 +1026,7 @@ public void run() {
         realm.commitTransaction();
 
         RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
+        looperThread.keepStrongReference.add(dogs);
         for (int i = 0; i < NUMBER_OF_LISTENERS; i++) {
             dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
                 @Override
@@ -1032,7 +1050,7 @@ public void multiple_callbacks_should_be_invoked_realmresults_async() {
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
-                realm.handler.post(new Runnable() {
+                looperThread.postRunnable(new Runnable() {
                     @Override
                     public void run() {
                         assertEquals(NUMBER_OF_LISTENERS, typebasedCommitInvocations.get());
@@ -1049,6 +1067,7 @@ public void run() {
         RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
         assertTrue(dogs.load());
 
+        looperThread.keepStrongReference.add(dogs);
         for (int i = 0; i < NUMBER_OF_LISTENERS; i++) {
             dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
                 @Override
@@ -1080,7 +1099,7 @@ public void non_looper_thread_commit_realmobject_sync() {
             @Override
             public void onChange(Realm object) {
                 if (realm.where(Dog.class).count() == 2) {
-                    realm.handler.post(new Runnable() {
+                    looperThread.postRunnable(new Runnable() {
                         @Override
                         public void run() {
                             assertEquals(1, typebasedCommitInvocations.get());
@@ -1096,6 +1115,7 @@ public void run() {
         realm.commitTransaction();
 
         Dog dog = realm.where(Dog.class).findFirst();
+        looperThread.keepStrongReference.add(dog);
         dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
             public void onChange(Dog object) {
@@ -1134,7 +1154,7 @@ public void non_looper_thread_commit_realmobject_async() {
             public void onChange(Realm object) {
                 // Check if the 2nd transaction is committed.
                 if (realm.where(Dog.class).count() == 2) {
-                    realm.handler.post(new Runnable() {
+                    looperThread.postRunnable(new Runnable() {
                         @Override
                         public void run() {
                             assertEquals(2, typebasedCommitInvocations.get());
@@ -1168,6 +1188,7 @@ public void run() {
         };
 
         Dog dog = realm.where(Dog.class).findFirstAsync();
+        looperThread.keepStrongReference.add(dog);
         dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
             public void onChange(Dog object) {
@@ -1198,7 +1219,7 @@ public void non_looper_thread_commit_realmresults_sync() {
             @Override
             public void onChange(Realm object) {
                 if (realm.where(Dog.class).count() == 2) {
-                    realm.handler.post(new Runnable() {
+                    looperThread.postRunnable(new Runnable() {
                         @Override
                         public void run() {
                             assertEquals(typebasedCommitInvocations.get(), 1);
@@ -1214,6 +1235,7 @@ public void run() {
         realm.commitTransaction();
 
         final RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
+        looperThread.keepStrongReference.add(dogs);
         dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
             public void onChange(RealmResults<Dog> object) {
@@ -1252,7 +1274,7 @@ public void non_looper_thread_commit_realmresults_async() {
             @Override
             public void onChange(Realm object) {
                 if (realm.where(Dog.class).count() == 2) {
-                    realm.handler.post(new Runnable() {
+                    looperThread.postRunnable(new Runnable() {
                         @Override
                         public void run() {
                             assertEquals(2, typebasedCommitInvocations.get());
@@ -1279,6 +1301,7 @@ public void run() {
         };
 
         final RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
+        looperThread.keepStrongReference.add(dogs);
         dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
             public void onChange(RealmResults<Dog> object) {
@@ -1426,6 +1449,8 @@ public void onChange(Object object) {
                 finishedLatch.countDown();
             }
         };
+        looperThread.keepStrongReference.add(results1);
+        looperThread.keepStrongReference.add(results2);
         results1.addChangeListener(listener);
         results2.addChangeListener(listener);
 
@@ -1451,6 +1476,7 @@ public void changeListener_onResultsBuiltOnDeletedLinkView() {
 
         final RealmResults<Dog> dogs =
                 allTypes.getColumnRealmList().where().equalTo(Dog.FIELD_NAME, "name_0").findAll();
+        looperThread.keepStrongReference.add(dogs);
         dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
             public void onChange(RealmResults<Dog> object) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/UnManagedOrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/UnManagedOrderedRealmCollectionTests.java
index d2d2bc41f9..ea515284b7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/UnManagedOrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/UnManagedOrderedRealmCollectionTests.java
@@ -173,7 +173,7 @@ public void load() {
 
     @Test
     public void isValid() {
-        assertFalse(collection.isValid());
+        assertTrue(collection.isValid());
     }
 
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/UnManagedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/UnManagedRealmCollectionTests.java
index 70f6aab05d..d74ed31181 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/UnManagedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/UnManagedRealmCollectionTests.java
@@ -99,7 +99,8 @@ public void unsupportedMethods_unManagedCollections() {
                     case DELETE_ALL_FROM_REALM: collection.deleteAllFromRealm(); break;
 
                     // Supported methods
-                    case IS_VALID: assertFalse(collection.isValid()); continue;
+                    case IS_VALID: assertTrue(collection.isValid()); continue;
+                    case IS_MANAGED: assertFalse(collection.isManaged()); continue;
                 }
                 fail(method + " should have thrown an exception.");
             } catch (UnsupportedOperationException ignored) {
@@ -119,7 +120,12 @@ public void load() {
 
     @Test
     public void isValid() {
-        assertFalse(collection.isValid());
+        assertTrue(collection.isValid());
+    }
+
+    @Test
+    public void isManaged() {
+        assertFalse(collection.isManaged());
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
index 2a5308d913..515eea403c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
@@ -32,6 +32,7 @@
     public static String FIELD_SHORT = "fieldShort";
     public static String FIELD_INT = "fieldInt";
     public static String FIELD_LONG = "fieldLong";
+    public static String FIELD_ID = "fieldId";
     public static String FIELD_BYTE = "fieldByte";
     public static String FIELD_FLOAT = "fieldFloat";
     public static String FIELD_DOUBLE = "fieldDouble";
@@ -46,9 +47,10 @@
 
     @Ignore private String fieldIgnored;
     @Index private String fieldString;
+    @PrimaryKey private long fieldId;
+    private long fieldLong;
     private short fieldShort;
     private int fieldInt;
-    @PrimaryKey private long fieldLong;
     private byte fieldByte;
     private float fieldFloat;
     private double fieldDouble;
@@ -63,6 +65,7 @@ public AllJavaTypes() {
     }
 
     public AllJavaTypes(long fieldLong) {
+        this.fieldId = fieldLong;
         this.fieldLong = fieldLong;
     }
 
@@ -90,6 +93,14 @@ public void setFieldShort(short fieldShort) {
         this.fieldShort = fieldShort;
     }
 
+    public long getFieldLong() {
+        return fieldLong;
+    }
+
+    public void setFieldLong(long fieldLong) {
+        this.fieldLong = fieldLong;
+    }
+
     public int getFieldInt() {
         return fieldInt;
     }
@@ -98,12 +109,12 @@ public void setFieldInt(int fieldInt) {
         this.fieldInt = fieldInt;
     }
 
-    public long getFieldLong() {
-        return fieldLong;
+    public long getFieldId() {
+        return fieldId;
     }
 
-    public void setFieldLong(long fieldLong) {
-        this.fieldLong = fieldLong;
+    public void setFieldId(long fieldId) {
+        this.fieldId = fieldId;
     }
 
     public byte getFieldByte() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/PhoneData.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AssetFileModule.java
similarity index 68%
rename from realm/realm-library/src/androidTest/java/io/realm/internal/test/PhoneData.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/AssetFileModule.java
index cbeb2c0c1b..0b791f675e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/test/PhoneData.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AssetFileModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2016 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,16 +14,13 @@
  * limitations under the License.
  */
 
-package io.realm.internal.test;
+package io.realm.entities;
 
-public class PhoneData {
-
-    public String type;
-    public String number;
-
-    public PhoneData(String type, String number) {
-        this.type = type;
-        this.number = number;
-    }
+import io.realm.annotations.RealmModule;
 
+/**
+ * module definition for "asset_file.realm"
+ */
+@RealmModule(classes = {Owner.class, Cat.class, Dog.class, DogPrimaryKey.class})
+public class AssetFileModule {
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/Cat.java b/realm/realm-library/src/androidTest/java/io/realm/entities/Cat.java
index 03e961f055..b9e218f3e2 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/Cat.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/Cat.java
@@ -23,6 +23,14 @@
 public class Cat extends RealmObject {
 
     public static final String CLASS_NAME = "Cat";
+    public static final String FIELD_NAME = "name";
+    public static final String FIELD_AGE = "age";
+    public static final String FIELD_HEIGHT = "height";
+    public static final String FIELD_WEIGHT = "weight";
+    public static final String FIELD_HAS_TAIL = "hasTail";
+    public static final String FIELD_BIRTHDAY = "birthday";
+    public static final String FIELD_OWNER = "owner";
+    public static final String FIELD_SCARED_OF_DOG = "scaredOfDog";
 
     private String name;
     private long age;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/CustomMethods.java b/realm/realm-library/src/androidTest/java/io/realm/entities/CustomMethods.java
index a81d653aad..66ad9a11c8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/CustomMethods.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/CustomMethods.java
@@ -42,7 +42,7 @@ public boolean equals(Object o) {
             return reverseEquals;
         }
         CustomMethods other = (CustomMethods) o;
-        if (isValid() == other.isValid() && other.name.equals(name)) {
+        if (isManaged() == other.isManaged() && other.name.equals(name)) {
             return !reverseEquals;
         } else {
             return reverseEquals;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueConstructor.java b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueConstructor.java
new file mode 100644
index 0000000000..4aed4562b7
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueConstructor.java
@@ -0,0 +1,227 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import java.util.Date;
+import java.util.UUID;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.Ignore;
+import io.realm.annotations.PrimaryKey;
+
+public class DefaultValueConstructor extends RealmObject {
+
+    public static final String CLASS_NAME = "DefaultValueOfField";
+    public static String FIELD_IGNORED = "fieldIgnored";
+    public static String FIELD_RANDOM_STRING = "fieldRandomString";
+    public static String FIELD_STRING = "fieldString";
+    public static String FIELD_SHORT = "fieldShort";
+    public static String FIELD_INT = "fieldInt";
+    public static String FIELD_LONG_PRIMARY_KEY = "fieldLongPrimaryKey";
+    public static String FIELD_LONG = "fieldLong";
+    public static String FIELD_BYTE = "fieldByte";
+    public static String FIELD_FLOAT = "fieldFloat";
+    public static String FIELD_DOUBLE = "fieldDouble";
+    public static String FIELD_BOOLEAN = "fieldBoolean";
+    public static String FIELD_DATE = "fieldDate";
+    public static String FIELD_BINARY = "fieldBinary";
+    public static String FIELD_OBJECT = "fieldObject";
+    public static String FIELD_LIST = "fieldList";
+
+
+    public static String FIELD_IGNORED_DEFAULT_VALUE = "ignored";
+    public static String FIELD_STRING_DEFAULT_VALUE = "defaultString";
+    public static short FIELD_SHORT_DEFAULT_VALUE = 1234;
+    public static int FIELD_INT_DEFAULT_VALUE = 123456;
+    public static long FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE = 2L * Integer.MAX_VALUE;
+    public static long FIELD_LONG_DEFAULT_VALUE = 3L * Integer.MAX_VALUE;
+    public static byte FIELD_BYTE_DEFAULT_VALUE = 100;
+    public static float FIELD_FLOAT_DEFAULT_VALUE = 0.5f;
+    public static double FIELD_DOUBLE_DEFAULT_VALUE = 0.25;
+    public static boolean FIELD_BOOLEAN_DEFAULT_VALUE = true;
+    public static Date FIELD_DATE_DEFAULT_VALUE = new Date(1473691826000L /*2016/9/12 23:56:26 JST*/);
+    public static byte[] FIELD_BINARY_DEFAULT_VALUE = new byte[] {123, -100, 0, 2};
+    public static RandomPrimaryKey FIELD_OBJECT_DEFAULT_VALUE;
+    public static RealmList<RandomPrimaryKey> FIELD_LIST_DEFAULT_VALUE;
+
+    static {
+        FIELD_OBJECT_DEFAULT_VALUE = new RandomPrimaryKey();
+        FIELD_LIST_DEFAULT_VALUE = new RealmList<RandomPrimaryKey>();
+        FIELD_LIST_DEFAULT_VALUE.add(new RandomPrimaryKey());
+    }
+
+    public static String lastRandomStringValue;
+
+    @Ignore private String fieldIgnored;
+    private String fieldString;
+    private String fieldRandomString;
+    private short fieldShort;
+    private int fieldInt;
+    @PrimaryKey private long fieldLongPrimaryKey;
+    private long fieldLong;
+    private byte fieldByte;
+    private float fieldFloat;
+    private double fieldDouble;
+    private boolean fieldBoolean;
+    private Date fieldDate;
+    private byte[] fieldBinary;
+    private RandomPrimaryKey fieldObject;
+    private RealmList<RandomPrimaryKey> fieldList;
+
+    public DefaultValueConstructor() {
+        fieldIgnored = FIELD_IGNORED_DEFAULT_VALUE;
+        fieldString = FIELD_STRING_DEFAULT_VALUE;
+        fieldRandomString = lastRandomStringValue = UUID.randomUUID().toString();
+        fieldShort = FIELD_SHORT_DEFAULT_VALUE;
+        fieldInt = FIELD_INT_DEFAULT_VALUE;
+        fieldLongPrimaryKey = FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE;
+        fieldLong = FIELD_LONG_DEFAULT_VALUE;
+        fieldByte = FIELD_BYTE_DEFAULT_VALUE;
+        fieldFloat = FIELD_FLOAT_DEFAULT_VALUE;
+        fieldDouble = FIELD_DOUBLE_DEFAULT_VALUE;
+        fieldBoolean = FIELD_BOOLEAN_DEFAULT_VALUE;
+        fieldDate = FIELD_DATE_DEFAULT_VALUE;
+        fieldBinary = FIELD_BINARY_DEFAULT_VALUE;
+        fieldObject = FIELD_OBJECT_DEFAULT_VALUE;
+        fieldList = FIELD_LIST_DEFAULT_VALUE;
+    }
+
+    public DefaultValueConstructor(long fieldLong) {
+        this.fieldLong = fieldLong;
+    }
+
+    public String getFieldIgnored() {
+        return fieldIgnored;
+    }
+
+    public void setFieldIgnored(String fieldIgnored) {
+        this.fieldIgnored = fieldIgnored;
+    }
+
+    public String getFieldString() {
+        return fieldString;
+    }
+
+    public void setFieldString(String fieldString) {
+        this.fieldString = fieldString;
+    }
+
+    public String getFieldRandomString() {
+        return fieldRandomString;
+    }
+
+    public void setFieldRandomString(String fieldRandomString) {
+        this.fieldRandomString = fieldRandomString;
+    }
+
+    public short getFieldShort() {
+        return fieldShort;
+    }
+
+    public void setFieldShort(short fieldShort) {
+        this.fieldShort = fieldShort;
+    }
+
+    public int getFieldInt() {
+        return fieldInt;
+    }
+
+    public void setFieldInt(int fieldInt) {
+        this.fieldInt = fieldInt;
+    }
+
+    public long getFieldLongPrimaryKey() {
+        return fieldLongPrimaryKey;
+    }
+
+    public void setFieldLongPrimaryKey(long fieldLongPrimaryKey) {
+        this.fieldLongPrimaryKey = fieldLongPrimaryKey;
+    }
+
+    public long getFieldLong() {
+        return fieldLong;
+    }
+
+    public void setFieldLong(long fieldLong) {
+        this.fieldLong = fieldLong;
+    }
+
+    public byte getFieldByte() {
+        return fieldByte;
+    }
+
+    public void setFieldByte(byte fieldByte) {
+        this.fieldByte = fieldByte;
+    }
+
+    public float getFieldFloat() {
+        return fieldFloat;
+    }
+
+    public void setFieldFloat(float fieldFloat) {
+        this.fieldFloat = fieldFloat;
+    }
+
+    public double getFieldDouble() {
+        return fieldDouble;
+    }
+
+    public void setFieldDouble(double fieldDouble) {
+        this.fieldDouble = fieldDouble;
+    }
+
+    public boolean isFieldBoolean() {
+        return fieldBoolean;
+    }
+
+    public void setFieldBoolean(boolean fieldBoolean) {
+        this.fieldBoolean = fieldBoolean;
+    }
+
+    public Date getFieldDate() {
+        return fieldDate;
+    }
+
+    public void setFieldDate(Date fieldDate) {
+        this.fieldDate = fieldDate;
+    }
+
+    public byte[] getFieldBinary() {
+        return fieldBinary;
+    }
+
+    public void setFieldBinary(byte[] fieldBinary) {
+        this.fieldBinary = fieldBinary;
+    }
+
+    public RandomPrimaryKey getFieldObject() {
+        return fieldObject;
+    }
+
+    public void setFieldObject(RandomPrimaryKey fieldObject) {
+        this.fieldObject = fieldObject;
+    }
+
+    public RealmList<RandomPrimaryKey> getFieldList() {
+        return fieldList;
+    }
+
+    public void setFieldList(RealmList<RandomPrimaryKey> fieldList) {
+        this.fieldList = fieldList;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueOfField.java b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueOfField.java
new file mode 100644
index 0000000000..0378e64817
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueOfField.java
@@ -0,0 +1,213 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import java.util.Date;
+import java.util.UUID;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.Ignore;
+import io.realm.annotations.PrimaryKey;
+
+public class DefaultValueOfField extends RealmObject {
+
+    public static final String CLASS_NAME = "DefaultValueOfField";
+    public static String FIELD_IGNORED = "fieldIgnored";
+    public static String FIELD_RANDOM_STRING = "fieldRandomString";
+    public static String FIELD_STRING = "fieldString";
+    public static String FIELD_SHORT = "fieldShort";
+    public static String FIELD_INT = "fieldInt";
+    public static String FIELD_LONG_PRIMARY_KEY = "fieldLongPrimaryKey";
+    public static String FIELD_LONG = "fieldLong";
+    public static String FIELD_BYTE = "fieldByte";
+    public static String FIELD_FLOAT = "fieldFloat";
+    public static String FIELD_DOUBLE = "fieldDouble";
+    public static String FIELD_BOOLEAN = "fieldBoolean";
+    public static String FIELD_DATE = "fieldDate";
+    public static String FIELD_BINARY = "fieldBinary";
+    public static String FIELD_OBJECT = "fieldObject";
+    public static String FIELD_LIST = "fieldList";
+
+
+    public static String FIELD_IGNORED_DEFAULT_VALUE = "ignored";
+    public static String FIELD_STRING_DEFAULT_VALUE = "defaultString";
+    public static short FIELD_SHORT_DEFAULT_VALUE = 1234;
+    public static int FIELD_INT_DEFAULT_VALUE = 123456;
+    public static long FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE = 2L * Integer.MAX_VALUE;
+    public static long FIELD_LONG_DEFAULT_VALUE = 3L * Integer.MAX_VALUE;
+    public static byte FIELD_BYTE_DEFAULT_VALUE = 100;
+    public static float FIELD_FLOAT_DEFAULT_VALUE = 0.5f;
+    public static double FIELD_DOUBLE_DEFAULT_VALUE = 0.25;
+    public static boolean FIELD_BOOLEAN_DEFAULT_VALUE = true;
+    public static Date FIELD_DATE_DEFAULT_VALUE = new Date(1473691826000L /*2016/9/12 23:56:26 JST*/);
+    public static byte[] FIELD_BINARY_DEFAULT_VALUE = new byte[] {123, -100, 0, 2};
+    public static RandomPrimaryKey FIELD_OBJECT_DEFAULT_VALUE;
+    public static RealmList<RandomPrimaryKey> FIELD_LIST_DEFAULT_VALUE;
+
+    static {
+        FIELD_OBJECT_DEFAULT_VALUE = new RandomPrimaryKey();
+        FIELD_LIST_DEFAULT_VALUE = new RealmList<RandomPrimaryKey>();
+        FIELD_LIST_DEFAULT_VALUE.add(new RandomPrimaryKey());
+    }
+
+    public static String lastRandomStringValue;
+
+    @Ignore private String fieldIgnored = FIELD_IGNORED_DEFAULT_VALUE;
+    private String fieldString = FIELD_STRING_DEFAULT_VALUE;
+    private String fieldRandomString = lastRandomStringValue = UUID.randomUUID().toString();
+    private short fieldShort = FIELD_SHORT_DEFAULT_VALUE;
+    private int fieldInt = FIELD_INT_DEFAULT_VALUE;
+    @PrimaryKey private long fieldLongPrimaryKey = FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE;
+    private long fieldLong = FIELD_LONG_DEFAULT_VALUE;
+    private byte fieldByte = FIELD_BYTE_DEFAULT_VALUE;
+    private float fieldFloat = FIELD_FLOAT_DEFAULT_VALUE;
+    private double fieldDouble = FIELD_DOUBLE_DEFAULT_VALUE;
+    private boolean fieldBoolean = FIELD_BOOLEAN_DEFAULT_VALUE;
+    private Date fieldDate = FIELD_DATE_DEFAULT_VALUE;
+    private byte[] fieldBinary = FIELD_BINARY_DEFAULT_VALUE;
+    private RandomPrimaryKey fieldObject = FIELD_OBJECT_DEFAULT_VALUE;
+    private RealmList<RandomPrimaryKey> fieldList = FIELD_LIST_DEFAULT_VALUE;
+
+    public DefaultValueOfField() {
+
+    }
+
+    public DefaultValueOfField(long fieldLong) {
+        this.fieldLong = fieldLong;
+    }
+
+    public String getFieldIgnored() {
+        return fieldIgnored;
+    }
+
+    public void setFieldIgnored(String fieldIgnored) {
+        this.fieldIgnored = fieldIgnored;
+    }
+
+    public String getFieldString() {
+        return fieldString;
+    }
+
+    public void setFieldString(String fieldString) {
+        this.fieldString = fieldString;
+    }
+
+    public String getFieldRandomString() {
+        return fieldRandomString;
+    }
+
+    public void setFieldRandomString(String fieldRandomString) {
+        this.fieldRandomString = fieldRandomString;
+    }
+
+    public short getFieldShort() {
+        return fieldShort;
+    }
+
+    public void setFieldShort(short fieldShort) {
+        this.fieldShort = fieldShort;
+    }
+
+    public int getFieldInt() {
+        return fieldInt;
+    }
+
+    public void setFieldInt(int fieldInt) {
+        this.fieldInt = fieldInt;
+    }
+
+    public long getFieldLongPrimaryKey() {
+        return fieldLongPrimaryKey;
+    }
+
+    public void setFieldLongPrimaryKey(long fieldLongPrimaryKey) {
+        this.fieldLongPrimaryKey = fieldLongPrimaryKey;
+    }
+
+    public long getFieldLong() {
+        return fieldLong;
+    }
+
+    public void setFieldLong(long fieldLong) {
+        this.fieldLong = fieldLong;
+    }
+
+    public byte getFieldByte() {
+        return fieldByte;
+    }
+
+    public void setFieldByte(byte fieldByte) {
+        this.fieldByte = fieldByte;
+    }
+
+    public float getFieldFloat() {
+        return fieldFloat;
+    }
+
+    public void setFieldFloat(float fieldFloat) {
+        this.fieldFloat = fieldFloat;
+    }
+
+    public double getFieldDouble() {
+        return fieldDouble;
+    }
+
+    public void setFieldDouble(double fieldDouble) {
+        this.fieldDouble = fieldDouble;
+    }
+
+    public boolean isFieldBoolean() {
+        return fieldBoolean;
+    }
+
+    public void setFieldBoolean(boolean fieldBoolean) {
+        this.fieldBoolean = fieldBoolean;
+    }
+
+    public Date getFieldDate() {
+        return fieldDate;
+    }
+
+    public void setFieldDate(Date fieldDate) {
+        this.fieldDate = fieldDate;
+    }
+
+    public byte[] getFieldBinary() {
+        return fieldBinary;
+    }
+
+    public void setFieldBinary(byte[] fieldBinary) {
+        this.fieldBinary = fieldBinary;
+    }
+
+    public RandomPrimaryKey getFieldObject() {
+        return fieldObject;
+    }
+
+    public void setFieldObject(RandomPrimaryKey fieldObject) {
+        this.fieldObject = fieldObject;
+    }
+
+    public RealmList<RandomPrimaryKey> getFieldList() {
+        return fieldList;
+    }
+
+    public void setFieldList(RealmList<RandomPrimaryKey> fieldList) {
+        this.fieldList = fieldList;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueSetter.java b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueSetter.java
new file mode 100644
index 0000000000..e4583a9dc0
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueSetter.java
@@ -0,0 +1,231 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import java.util.Date;
+import java.util.UUID;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.Ignore;
+import io.realm.annotations.PrimaryKey;
+
+public class DefaultValueSetter extends RealmObject {
+
+    public static final String CLASS_NAME = "DefaultValueOfField";
+    public static String FIELD_IGNORED = "fieldIgnored";
+    public static String FIELD_RANDOM_STRING = "fieldRandomString";
+    public static String FIELD_STRING = "fieldString";
+    public static String FIELD_SHORT = "fieldShort";
+    public static String FIELD_INT = "fieldInt";
+    public static String FIELD_LONG_PRIMARY_KEY = "fieldLongPrimaryKey";
+    public static String FIELD_LONG = "fieldLong";
+    public static String FIELD_BYTE = "fieldByte";
+    public static String FIELD_FLOAT = "fieldFloat";
+    public static String FIELD_DOUBLE = "fieldDouble";
+    public static String FIELD_BOOLEAN = "fieldBoolean";
+    public static String FIELD_DATE = "fieldDate";
+    public static String FIELD_BINARY = "fieldBinary";
+    public static String FIELD_OBJECT = "fieldObject";
+    public static String FIELD_LIST = "fieldList";
+
+
+    public static String FIELD_IGNORED_DEFAULT_VALUE = "ignored";
+    public static String FIELD_STRING_DEFAULT_VALUE = "defaultString";
+    public static short FIELD_SHORT_DEFAULT_VALUE = 1234;
+    public static int FIELD_INT_DEFAULT_VALUE = 123456;
+    public static long FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE = 2L * Integer.MAX_VALUE;
+    public static long FIELD_LONG_DEFAULT_VALUE = 3L * Integer.MAX_VALUE;
+    public static byte FIELD_BYTE_DEFAULT_VALUE = 100;
+    public static float FIELD_FLOAT_DEFAULT_VALUE = 0.5f;
+    public static double FIELD_DOUBLE_DEFAULT_VALUE = 0.25;
+    public static boolean FIELD_BOOLEAN_DEFAULT_VALUE = true;
+    public static Date FIELD_DATE_DEFAULT_VALUE = new Date(1473691826000L /*2016/9/12 23:56:26 JST*/);
+    public static byte[] FIELD_BINARY_DEFAULT_VALUE = new byte[] {123, -100, 0, 2};
+    public static RandomPrimaryKey FIELD_OBJECT_DEFAULT_VALUE;
+    public static RealmList<RandomPrimaryKey> FIELD_LIST_DEFAULT_VALUE;
+
+    static {
+        FIELD_OBJECT_DEFAULT_VALUE = new RandomPrimaryKey();
+        FIELD_LIST_DEFAULT_VALUE = new RealmList<RandomPrimaryKey>();
+        FIELD_LIST_DEFAULT_VALUE.add(new RandomPrimaryKey());
+    }
+
+    public static String lastRandomStringValue;
+
+    @Ignore private String fieldIgnored;
+    private String fieldString;
+    private String fieldRandomString;
+    private short fieldShort;
+    private int fieldInt;
+    @PrimaryKey private long fieldLongPrimaryKey;
+    private long fieldLong;
+    private byte fieldByte;
+    private float fieldFloat;
+    private double fieldDouble;
+    private boolean fieldBoolean;
+    private Date fieldDate;
+    private byte[] fieldBinary;
+    private RandomPrimaryKey fieldObject;
+    private RealmList<RandomPrimaryKey> fieldList;
+
+    public DefaultValueSetter() {
+        setFieldIgnored(FIELD_IGNORED_DEFAULT_VALUE);
+        setFieldString(FIELD_STRING_DEFAULT_VALUE);
+        setFieldRandomString(lastRandomStringValue = UUID.randomUUID().toString());
+        setFieldShort(FIELD_SHORT_DEFAULT_VALUE);
+        setFieldInt(FIELD_INT_DEFAULT_VALUE);
+        setFieldLongPrimaryKey(FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE);
+        setFieldLong(FIELD_LONG_DEFAULT_VALUE);
+        setFieldByte(FIELD_BYTE_DEFAULT_VALUE);
+        setFieldFloat(FIELD_FLOAT_DEFAULT_VALUE);
+        setFieldDouble(FIELD_DOUBLE_DEFAULT_VALUE);
+        setFieldBoolean(FIELD_BOOLEAN_DEFAULT_VALUE);
+        setFieldDate(FIELD_DATE_DEFAULT_VALUE);
+        setFieldBinary(FIELD_BINARY_DEFAULT_VALUE);
+        setFieldObject(FIELD_OBJECT_DEFAULT_VALUE);
+        setFieldList(FIELD_LIST_DEFAULT_VALUE);
+
+        final RandomPrimaryKey listItem2 = new RandomPrimaryKey();
+        listItem2.setFieldInt(listItem2.getFieldInt() + 1);
+        getFieldList().add(listItem2);
+    }
+
+    public DefaultValueSetter(long fieldLong) {
+        this.fieldLong = fieldLong;
+    }
+
+    public String getFieldIgnored() {
+        return fieldIgnored;
+    }
+
+    public void setFieldIgnored(String fieldIgnored) {
+        this.fieldIgnored = fieldIgnored;
+    }
+
+    public String getFieldString() {
+        return fieldString;
+    }
+
+    public void setFieldString(String fieldString) {
+        this.fieldString = fieldString;
+    }
+
+    public String getFieldRandomString() {
+        return fieldRandomString;
+    }
+
+    public void setFieldRandomString(String fieldRandomString) {
+        this.fieldRandomString = fieldRandomString;
+    }
+
+    public short getFieldShort() {
+        return fieldShort;
+    }
+
+    public void setFieldShort(short fieldShort) {
+        this.fieldShort = fieldShort;
+    }
+
+    public int getFieldInt() {
+        return fieldInt;
+    }
+
+    public void setFieldInt(int fieldInt) {
+        this.fieldInt = fieldInt;
+    }
+
+    public long getFieldLongPrimaryKey() {
+        return fieldLongPrimaryKey;
+    }
+
+    public void setFieldLongPrimaryKey(long fieldLongPrimaryKey) {
+        this.fieldLongPrimaryKey = fieldLongPrimaryKey;
+    }
+
+    public long getFieldLong() {
+        return fieldLong;
+    }
+
+    public void setFieldLong(long fieldLong) {
+        this.fieldLong = fieldLong;
+    }
+
+    public byte getFieldByte() {
+        return fieldByte;
+    }
+
+    public void setFieldByte(byte fieldByte) {
+        this.fieldByte = fieldByte;
+    }
+
+    public float getFieldFloat() {
+        return fieldFloat;
+    }
+
+    public void setFieldFloat(float fieldFloat) {
+        this.fieldFloat = fieldFloat;
+    }
+
+    public double getFieldDouble() {
+        return fieldDouble;
+    }
+
+    public void setFieldDouble(double fieldDouble) {
+        this.fieldDouble = fieldDouble;
+    }
+
+    public boolean isFieldBoolean() {
+        return fieldBoolean;
+    }
+
+    public void setFieldBoolean(boolean fieldBoolean) {
+        this.fieldBoolean = fieldBoolean;
+    }
+
+    public Date getFieldDate() {
+        return fieldDate;
+    }
+
+    public void setFieldDate(Date fieldDate) {
+        this.fieldDate = fieldDate;
+    }
+
+    public byte[] getFieldBinary() {
+        return fieldBinary;
+    }
+
+    public void setFieldBinary(byte[] fieldBinary) {
+        this.fieldBinary = fieldBinary;
+    }
+
+    public RandomPrimaryKey getFieldObject() {
+        return fieldObject;
+    }
+
+    public void setFieldObject(RandomPrimaryKey fieldObject) {
+        this.fieldObject = fieldObject;
+    }
+
+    public RealmList<RandomPrimaryKey> getFieldList() {
+        return fieldList;
+    }
+
+    public void setFieldList(RealmList<RandomPrimaryKey> fieldList) {
+        this.fieldList = fieldList;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/NoPrimaryKeyNullTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/NoPrimaryKeyNullTypes.java
index dbac8543f2..d8ee4e85aa 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/NoPrimaryKeyNullTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/NoPrimaryKeyNullTypes.java
@@ -35,6 +35,25 @@
 // 11 Object
 public class NoPrimaryKeyNullTypes extends RealmObject {
 
+    public static String FIELD_STRING_NOT_NULL = "fieldStringNotNull";
+    public static String FIELD_STRING_NULL = "fieldStringNull";
+    public static String FIELD_BOOLEAN_NOT_NULL = "fieldBooleanNotNull";
+    public static String FIELD_BOOLEAN_NULL = "fieldBooleanNull";
+    public static String FIELD_BYTE_NOT_NULL = "fieldByteNotNull";
+    public static String FIELD_BYTE_NULL = "fieldByteNull";
+    public static String FIELD_SHORT_NOT_NULL = "fieldShortNotNull";
+    public static String FIELD_SHORT_NULL = "fieldShortNull";
+    public static String FIELD_INTEGER_NOT_NULL = "fieldIntegerNotNull";
+    public static String FIELD_INTEGER_NULL = "fieldIntegerNull";
+    public static String FIELD_LONG_NOT_NULL = "fieldLongNotNull";
+    public static String FIELD_LONG_NULL = "fieldLongNull";
+    public static String FIELD_FLOAT_NOT_NULL = "fieldFloatNotNull";
+    public static String FIELD_FLOAT_NULL = "fieldFloatNull";
+    public static String FIELD_DOUBLE_NOT_NULL = "fieldDoubleNotNull";
+    public static String FIELD_DOUBLE_NULL = "fieldDoubleNull";
+    public static String FIELD_DATE_NOT_NULL = "fieldDateNotNull";
+    public static String FIELD_DATE_NULL = "fieldDateNull";
+
     @Required
     private String fieldStringNotNull = "";
     private String fieldStringNull;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/NoPrimaryKeyWithPrimaryKeyObjectRelation.java b/realm/realm-library/src/androidTest/java/io/realm/entities/NoPrimaryKeyWithPrimaryKeyObjectRelation.java
new file mode 100644
index 0000000000..e540166b4a
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/NoPrimaryKeyWithPrimaryKeyObjectRelation.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+
+public class NoPrimaryKeyWithPrimaryKeyObjectRelation extends RealmObject {
+    private String columnString;
+
+    private AllTypesPrimaryKey columnRealmObjectPK;
+
+    private int columnInt = 8;
+
+    public String getColumnString() {
+        return columnString;
+    }
+
+    public void setColumnString(String columnString) {
+        this.columnString = columnString;
+    }
+
+    public AllTypesPrimaryKey getColumnRealmObjectPK() {
+        return columnRealmObjectPK;
+    }
+
+    public void setColumnRealmObjectPK(AllTypesPrimaryKey columnRealmObjectPK) {
+        this.columnRealmObjectPK = columnRealmObjectPK;
+    }
+
+    public int getColumnInt() {
+        return columnInt;
+    }
+
+    public void setColumnInt(int columnInt) {
+        this.columnInt = columnInt;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedLong.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedLong.java
index 6ad4929040..839681ba72 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedLong.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsBoxedLong.java
@@ -24,6 +24,7 @@
 
     public static final String CLASS_NAME = "PrimaryKeyAsBoxedLong";
     public static final String FIELD_PRIMARY_KEY = "id";
+    public static final String FIELD_NAME = "name";
 
     @PrimaryKey
     private Long id;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsByte.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsByte.java
index a7474a743c..95eeb8aa88 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsByte.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsByte.java
@@ -21,6 +21,9 @@
 
 public class PrimaryKeyAsByte extends RealmObject {
 
+    public static final String CLASS_NAME = "PrimaryKeyAsByte";
+    public static final String FIELD_ID = "id";
+
     @PrimaryKey
     private byte id;
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsInteger.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsInteger.java
index 4b12691d84..c54aa7b6fa 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsInteger.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsInteger.java
@@ -21,6 +21,9 @@
 
 public class PrimaryKeyAsInteger extends RealmObject {
 
+    public static final String CLASS_NAME = "PrimaryKeyAsInteger";
+    public static final String FIELD_ID = "id";
+
     @PrimaryKey
     private int id;
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsLong.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsLong.java
index 9b803899ad..19fd734383 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsLong.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsLong.java
@@ -21,6 +21,9 @@
 
 public class PrimaryKeyAsLong extends RealmObject {
 
+    public static final String CLASS_NAME = "PrimaryKeyAsLong";
+    public static final String FIELD_ID = "id";
+
     @PrimaryKey
     private long id;
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsShort.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsShort.java
index b2a28c2213..092d256dd4 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsShort.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsShort.java
@@ -21,6 +21,9 @@
 
 public class PrimaryKeyAsShort extends RealmObject {
 
+    public static final String CLASS_NAME = "PrimaryKeyAsShort";
+    public static final String FIELD_ID = "id";
+
     @PrimaryKey
     private short id;
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyWithNoPrimaryKeyObjectRelation.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyWithNoPrimaryKeyObjectRelation.java
new file mode 100644
index 0000000000..0206a2974c
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyWithNoPrimaryKeyObjectRelation.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+
+public class PrimaryKeyWithNoPrimaryKeyObjectRelation extends RealmObject {
+    public static final String CLASS_NAME = "PrimaryKeyWithNoPrimaryKeyObjectRelation";
+    public static final String FIELD_COLUMN_STRING = "columnString";
+    public static final String FIELD_COLUMN_REALM_OBJECT_NO_PK = "columnRealmObjectNoPK";
+    public static final String FIELD_COLUMN_INT = "columnInt";
+
+    public static final int FIELD_COLUMN_INT_DEFAULT_VALUE = 8;
+
+    @PrimaryKey
+    private String columnString;
+
+    private AllTypes columnRealmObjectNoPK;
+
+    private int columnInt = FIELD_COLUMN_INT_DEFAULT_VALUE;
+
+    public String getColumnString() {
+        return columnString;
+    }
+
+    public void setColumnString(String columnString) {
+        this.columnString = columnString;
+    }
+
+    public AllTypes getColumnRealmObjectNoPK() {
+        return columnRealmObjectNoPK;
+    }
+
+    public void setColumnRealmObjectNoPK(AllTypes columnRealmObjectNoPK) {
+        this.columnRealmObjectNoPK = columnRealmObjectNoPK;
+    }
+
+    public int getColumnInt() {
+        return columnInt;
+    }
+
+    public void setColumnInt(int columnInt) {
+        this.columnInt = columnInt;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/RandomPrimaryKey.java b/realm/realm-library/src/androidTest/java/io/realm/entities/RandomPrimaryKey.java
new file mode 100644
index 0000000000..d8d434e1ab
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/RandomPrimaryKey.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import java.util.UUID;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+
+public class RandomPrimaryKey extends RealmObject {
+
+    public static final String CLASS_NAME = "RandomPrimaryKey";
+    public static String FIELD_RANDOM_PRIMARY_KEY = "fieldRandomPrimaryKey";
+    public static String FIELD_INT = "fieldInt";
+
+
+    public static int FIELD_INT_DEFAULT_VALUE = 1357924;
+
+    @PrimaryKey private String fieldRandomPrimaryKey = UUID.randomUUID().toString();
+    private int fieldInt = FIELD_INT_DEFAULT_VALUE;
+
+    public RandomPrimaryKey() {
+    }
+
+    public String getFieldRandomPrimaryKey() {
+        return fieldRandomPrimaryKey;
+    }
+
+    public void setFieldRandomPrimaryKey(String fieldRandomPrimaryKey) {
+        this.fieldRandomPrimaryKey = fieldRandomPrimaryKey;
+    }
+
+    public int getFieldInt() {
+        return fieldInt;
+    }
+
+    public void setFieldInt(int fieldInt) {
+        this.fieldInt = fieldInt;
+    }
+}
diff --git a/realm/realm-jni/src/java_lang_List_Util.hpp b/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/List.java
similarity index 64%
rename from realm/realm-jni/src/java_lang_List_Util.hpp
rename to realm/realm-library/src/androidTest/java/io/realm/entities/conflict/List.java
index a360a247b4..eab61441a1 100644
--- a/realm/realm-jni/src/java_lang_List_Util.hpp
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/List.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2016 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,20 +14,16 @@
  * limitations under the License.
  */
 
-#ifndef JAVA_LANG_LIST_UTIL_H
-#define JAVA_LANG_LIST_UTIL_H
+package io.realm.entities.conflict;
 
-#include <jni.h>
+import io.realm.RealmList;
+import io.realm.RealmObject;
 
-#ifdef __cplusplus
-extern "C" {
-#endif
+public class List extends RealmObject {
+    public RealmList<Map> mapList;
+    public Map map;
 
-jint java_lang_List_size(JNIEnv* env, jobject jList);
-jobject java_lang_List_get(JNIEnv* env, jobject jList, jint index);
-
-#ifdef __cplusplus
+    public java.lang.String str;
+    public String strObj;
+    public RealmList<String> strList;
 }
-#endif
-
-#endif
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/ColumnTypeData.java b/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/Map.java
similarity index 67%
rename from realm/realm-library/src/androidTest/java/io/realm/internal/test/ColumnTypeData.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/conflict/Map.java
index e841f2daee..046ec3ea4a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/test/ColumnTypeData.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/Map.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2016 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,15 +14,15 @@
  * limitations under the License.
  */
 
-package io.realm.internal.test;
+package io.realm.entities.conflict;
 
-import io.realm.RealmFieldType;
+import io.realm.RealmList;
+import io.realm.RealmModel;
+import io.realm.annotations.RealmClass;
 
-public class ColumnTypeData {
+@RealmClass
+public class Map implements RealmModel {
 
-    public RealmFieldType type;
-
-    public ColumnTypeData(RealmFieldType type) {
-        this.type = type;
-    }
+    public Map Map;
+    public RealmList<Map> mapList;
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/String.java b/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/String.java
new file mode 100644
index 0000000000..7b57935d58
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/String.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.conflict;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+
+public class String extends RealmObject {
+    public String str;
+    public RealmList<String> strList;
+
+    public Map map;
+    public RealmList<Map> mapList;
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/TestValue.java b/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/package-info.java
similarity index 69%
rename from realm/realm-library/src/androidTest/java/io/realm/internal/test/TestValue.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/conflict/package-info.java
index d85661cc79..ea43938900 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/test/TestValue.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/package-info.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2016 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,14 +14,9 @@
  * limitations under the License.
  */
 
-package io.realm.internal.test;
-
-public class TestValue {
-
-    public Object value;
-
-    public TestValue(Object value) {
-        this.value = value;
-    }
-}
-
+/**
+ * The classes in this package have conflicting name with classes used in Realm proxy classes.
+ *
+ * Those model classes test https://github.com/realm/realm-java/issues/3077
+ */
+package io.realm.entities.conflict;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationClassRenamed.java b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationClassRenamed.java
new file mode 100644
index 0000000000..ddcf95c8aa
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationClassRenamed.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.migration;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.migration.MigrationPrimaryKey;
+
+// Class used to test what happens if you modify a class name in a migration.
+public class MigrationClassRenamed extends RealmObject implements MigrationPrimaryKey {
+    public static String CLASS_NAME = "MigrationClassRenamed";
+
+    public static long DEFAULT_FIELDS_COUNT = 5;
+    public static long DEFAULT_PRIMARY_INDEX = 2;
+
+    private Byte fieldFirst;
+    private Short fieldSecond;
+
+    // PK is placed in the middle to check if prior/posterior fields' removal is properly reflected
+    // during migration step.
+    @PrimaryKey
+    private String fieldPrimary;
+    private Integer fieldFourth;
+    private Long fieldFifth;
+
+    public void setFieldFirst(Byte fieldFirst) {
+        this.fieldFirst = fieldFirst;
+    }
+
+    public Byte getFieldFirst() {
+        return this.fieldFirst;
+    }
+
+    public void setFieldSecond(Short fieldSecond) {
+        this.fieldSecond = fieldSecond;
+    }
+
+    public Short getFieldSecond() {
+        return this.fieldSecond;
+    }
+
+    public void setFieldPrimary(String fieldPrimary) {
+        this.fieldPrimary = fieldPrimary;
+    }
+
+    public String getFieldPrimary() {
+        return this.fieldPrimary;
+    }
+
+    public void setFieldFourth(Integer fieldFourth) {
+        this.fieldFourth = fieldFourth;
+    }
+
+    public Integer getFieldFourth() {
+        return this.fieldFourth;
+    }
+
+    public void setFieldFifth(Long fieldFifth) {
+        this.fieldFifth = fieldFifth;
+    }
+
+    public Long getFieldFifth() {
+        return this.fieldFifth;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationFieldRenamed.java b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationFieldRenamed.java
new file mode 100644
index 0000000000..7f03c819a4
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationFieldRenamed.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.migration;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.migration.MigrationPrimaryKey;
+
+// Class used to test what happens if you rename a primary field in a migration.
+public class MigrationFieldRenamed extends RealmObject implements MigrationPrimaryKey {
+    public static String CLASS_NAME = "MigrationFieldRenamed";
+
+    public static long DEFAULT_FIELDS_COUNT = 5;
+    public static long DEFAULT_PRIMARY_INDEX = 2;
+
+    public static String FIELD_PRIMARY = "fieldRenamedPrimary";
+
+    private Byte fieldFirst;
+    private Short fieldSecond;
+
+    // PK is placed in the middle to check if prior/posterior fields' removal is properly reflected
+    // during migration step. The MigrationPrimaryKey interface' PK field name is `fieldPrimary`.
+    @PrimaryKey
+    private String fieldRenamedPrimary;
+    private Integer fieldFourth;
+    private Long fieldFifth;
+
+    public void setFieldFirst(Byte fieldFirst) {
+        this.fieldFirst = fieldFirst;
+    }
+
+    public Byte getFieldFirst() {
+        return this.fieldFirst;
+    }
+
+    public void setFieldSecond(Short fieldSecond) {
+        this.fieldSecond = fieldSecond;
+    }
+
+    public Short getFieldSecond() {
+        return this.fieldSecond;
+    }
+
+    public void setFieldRenamedPrimary(String fieldRenamedPrimary) {
+        this.fieldRenamedPrimary = fieldRenamedPrimary;
+    }
+
+    public String getFieldRenamedPrimary() {
+        return this.fieldRenamedPrimary;
+    }
+
+    public void setFieldFourth(Integer fieldFourth) {
+        this.fieldFourth = fieldFourth;
+    }
+
+    public Integer getFieldFourth() {
+        return this.fieldFourth;
+    }
+
+    public void setFieldFifth(Long fieldFifth) {
+        this.fieldFifth = fieldFifth;
+    }
+
+    public Long getFieldFifth() {
+        return this.fieldFifth;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationFieldTypeToInt.java b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationFieldTypeToInt.java
new file mode 100644
index 0000000000..8f2ae79491
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationFieldTypeToInt.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.migration;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.migration.MigrationPrimaryKey;
+
+// Class used to test what happens if you modify a String type primary key field to int type in a migration.
+public class MigrationFieldTypeToInt extends RealmObject implements MigrationPrimaryKey {
+    public static String CLASS_NAME = "MigrationFieldTypeToInt";
+
+    public static long DEFAULT_FIELDS_COUNT = 5;
+    public static long DEFAULT_PRIMARY_INDEX = 4;
+
+    public static String FIELD_PRIMARY = "fieldIntPrimary";
+
+    public Byte fieldFirst;
+    public Short fieldSecond;
+    @PrimaryKey
+    public int fieldIntPrimary;
+    public Integer fieldFourth;
+    public Long fieldFifth;
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationFieldTypeToInteger.java b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationFieldTypeToInteger.java
new file mode 100644
index 0000000000..777d163fbd
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationFieldTypeToInteger.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.migration;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.migration.MigrationPrimaryKey;
+
+// Class used to test what happens if you modify a String type primary key field to nullable Integer type in a migration.
+public class MigrationFieldTypeToInteger extends RealmObject implements MigrationPrimaryKey {
+    public static String CLASS_NAME = "MigrationFieldTypeToInteger";
+
+    public static long DEFAULT_FIELDS_COUNT = 5;
+    public static long DEFAULT_PRIMARY_INDEX = 4;
+
+    public static String FIELD_PRIMARY = "fieldIntegerPrimary";
+
+    public Byte fieldFirst;
+    public Short fieldSecond;
+    @PrimaryKey
+    public Integer fieldIntegerPrimary;
+    public Integer fieldFourth;
+    public Long fieldFifth;
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationPosteriorIndexOnly.java b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationPosteriorIndexOnly.java
new file mode 100644
index 0000000000..5406532b72
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationPosteriorIndexOnly.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.migration;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.migration.MigrationPrimaryKey;
+
+// Class used for testing what happens if you modify fields defined after the primary key field
+public class MigrationPosteriorIndexOnly extends RealmObject implements MigrationPrimaryKey {
+    public static String CLASS_NAME = "MigrationPosteriorIndexOnly";
+
+    public static long DEFAULT_FIELDS_COUNT = 3;
+    public static long DEFAULT_PRIMARY_INDEX = 0;
+
+    @PrimaryKey
+    private String fieldPrimary;
+    private Integer fieldFourth;
+    private Long fieldFifth;
+
+    public void setFieldPrimary(String fieldPrimary) {
+        this.fieldPrimary = fieldPrimary;
+    }
+
+    public String getFieldPrimary() {
+        return this.fieldPrimary;
+    }
+
+    public void setFieldFourth(Integer fieldFourth) {
+        this.fieldFourth = fieldFourth;
+    }
+
+    public Integer getFieldFourth() {
+        return this.fieldFourth;
+    }
+
+    public void setFieldFifth(Long fieldFifth) {
+        this.fieldFifth = fieldFifth;
+    }
+
+    public Long getFieldFifth() {
+        return this.fieldFifth;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationPriorIndexOnly.java b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationPriorIndexOnly.java
new file mode 100644
index 0000000000..e8d0d8ca7c
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/migration/MigrationPriorIndexOnly.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities.migration;
+
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+import io.realm.migration.MigrationPrimaryKey;
+
+// Class used for testing what happens if you modify fields defined before the primary key field
+public class MigrationPriorIndexOnly extends RealmObject implements MigrationPrimaryKey {
+    public static String CLASS_NAME = "MigrationPriorIndexOnly";
+
+    public static long DEFAULT_FIELDS_COUNT = 3;
+    public static long DEFAULT_PRIMARY_INDEX = 2;
+
+    private Byte fieldFirst;
+    private Short fieldSecond;
+    @PrimaryKey
+    private String fieldPrimary;
+
+    public void setFieldFirst(Byte fieldFirst) {
+        this.fieldFirst = fieldFirst;
+    }
+
+    public Byte getFieldFirst() {
+        return this.fieldFirst;
+    }
+
+    public void setFieldSecond(Short fieldSecond) {
+        this.fieldSecond = fieldSecond;
+    }
+
+    public Short getFieldSecond() {
+        return this.fieldSecond;
+    }
+
+    public void setFieldPrimary(String fieldPrimary) {
+        this.fieldPrimary = fieldPrimary;
+    }
+
+    public String getFieldPrimary() {
+        return this.fieldPrimary;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/AllTypesRealmModel.java b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/AllTypesRealmModel.java
index 6e87305827..4998ef8bb7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/AllTypesRealmModel.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/pojo/AllTypesRealmModel.java
@@ -29,6 +29,7 @@
 public class AllTypesRealmModel implements RealmModel {
     public static final String CLASS_NAME = "AllTypesRealmModel";
     public static final String FIELD_LONG = "columnLong";
+    public static final String FIELD_BYTE = "columnByte";
     public static final String FIELD_DOUBLE = "columnDouble";
     public static final String FIELD_STRING = "columnString";
     public static final String FIELD_BINARY = "columnBinary";
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIBinaryTypeTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIBinaryTypeTest.java
deleted file mode 100644
index e6ac3b88a6..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIBinaryTypeTest.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import junit.framework.TestCase;
-
-import io.realm.RealmFieldType;
-
-public class JNIBinaryTypeTest extends TestCase {
-
-    protected Table table;
-    protected byte [] testArray = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 };
-
-    @Override
-    public void setUp() {
-        RealmCore.loadLibrary();
-        //util.setDebugLevel(0); //Set to 1 to see more JNI debug messages
-
-        table = new Table();
-        table.addColumn(RealmFieldType.BINARY, "bin");
-    }
-
-    @Override
-    public void tearDown() {
-        //table.close();
-        table = null;
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNICloseTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNICloseTest.java
index a798ecb28c..d7c477cd7a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNICloseTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNICloseTest.java
@@ -18,86 +18,11 @@
 
 import android.test.AndroidTestCase;
 
-import java.io.Closeable;
-import java.io.File;
-import java.util.ArrayList;
-import java.util.List;
-
 import io.realm.RealmFieldType;
 import io.realm.TestHelper;
 
-// Tables get detached
-
 public class JNICloseTest extends AndroidTestCase {
 
-    public void testCloseable() {
-
-        String testFile = new File(
-                this.getContext().getFilesDir(),
-                "closeableTest.realm").toString();
-        File f = new File(testFile);
-        if (f.exists()) {
-            boolean result = f.delete();
-            if (!result) {
-                fail();
-            }
-        }
-
-        List<Closeable> resources = new ArrayList<Closeable>();
-
-        SharedGroup sg = new SharedGroup(testFile);
-        resources.add(sg);
-
-        WriteTransaction wt = sg.beginWrite();
-        resources.add(wt);
-        try {
-            Table t = wt.getTable("test");
-            resources.add(t);
-            t.addColumn(RealmFieldType.STRING, "StringColumn");
-
-            t.add("abc");
-            t.add("cba");
-
-            wt.commit();
-
-        } catch(Throwable t) {
-            wt.rollback();
-        } finally {
-            for (Closeable c : resources) {
-                try {
-                    c.close();
-                } catch(java.io.IOException e) {
-                    e.printStackTrace();
-                }
-            }
-        }
-    }
-
-    public void testShouldCloseTable() throws Throwable {
-        Table table = new Table();
-        table.close();
-
-        try { table.size();                            fail("Table is closed"); } catch (IllegalStateException e) { }
-        try { table.getColumnCount();                  fail("Table is closed"); } catch (IllegalStateException e) { }
-        try { table.addColumn(RealmFieldType.STRING, "");  fail("Table is closed"); } catch (IllegalStateException e) { }
-
-        // TODO: Test all methods...
-    }
-
-    // TODO: Much more testing needed.
-    // Verify that methods make exceptions when Tables are invalidated.
-    // Verify subtables are invalidated when table is changed/updated in any way.
-    // Check that Group.close works
-
-    public void testShouldCloseGroup() {
-
-        Group group = new Group();
-        group.close();
-
-        try { group.getTable("t");    fail("Group is closed"); } catch (IllegalStateException e) { }
-        try { group.size();                     fail("Group is closed"); } catch (IllegalStateException e) { }
-    }
-
     /**
      * Make sure, that it's possible to use the query on a closed table
      */
@@ -108,8 +33,7 @@ public void testQueryAccessibleAfterTableClose() throws Throwable{
             table.setLong(5, i, i);
         TableQuery query = table.where();
         // Closes the table, it _should_ be allowed to access the query thereafter
-        table.close();
-        table = null;
+        Table.nativeClose(table.nativePtr);
         Table table2 = TestHelper.getTableWithAllColumnTypes();
         table2.addEmptyRows(10);
         for (int i=0; i<table2.size(); i++)
@@ -127,8 +51,7 @@ public void testAccessingViewMethodsAfterTableClose() {
         TableQuery query = table.where();
         TableView view = query.findAll();
         //Closes the table, it should be allowed to access the view thereafter (table is ref-counted)
-        table.close();
-        table = null;
+        Table.nativeClose(table.nativePtr);
 
         // Accessing methods should be ok.
         view.size();
@@ -138,50 +61,7 @@ public void testAccessingViewMethodsAfterTableClose() {
         view.getDouble(3, 0);
         view.getFloat(4, 0);
         view.getLong(5, 0);
-        view.getMixed(6, 0);
-        view.getString(7, 0);
 
         // TODO - add all methods from view
     }
-
-// TODO: this test is crashing
-/*    public void testShouldThrowWhenAccessingViewAfterTableIsDetached() {
-        final String testFile = "closetest.realm";
-        SharedGroup db;
-        File f = new File(this.getContext().getFilesDir(), testFile);
-        if (f.exists()) {
-            boolean result = f.delete();
-            if (!result) {
-                fail("Could not delete test file");
-            }
-        }
-        db = new SharedGroup(f.toString());
-
-        WriteTransaction trans = db.beginWrite();
-        Table tbl = trans.getTable("EmployeeTable");
-        tbl.addColumn(RealmFieldType.STRING, "name");
-        tbl.addColumn(RealmFieldType.INTEGER, "number");
-        TableView view = tbl.where().findAll();
-
-        trans.commit();
-
-        //methods below should throw exception, as table is invalid after commit
-        try { view.size();                       fail(); } catch (IllegalStateException e){}
-        try { view.getBinaryByteArray(0, 0);     fail(); } catch (IllegalStateException e){}
-        try { view.getBoolean(1, 0);             fail(); } catch (IllegalStateException e){}
-        try { view.getDate(2, 0);                fail(); } catch (IllegalStateException e){}
-        try { view.getDouble(3, 0);              fail(); } catch (IllegalStateException e){}
-        try { view.getFloat(4, 0);               fail(); } catch (IllegalStateException e){}
-        try { view.getLong(5, 0);                fail(); } catch (IllegalStateException e){}
-        try { view.getMixed(6, 0);               fail(); } catch (IllegalStateException e){}
-        try { view.getString(7, 0);              fail(); } catch (IllegalStateException e){}
-        // TODO: Add more methods
-
-        db.close();
-        boolean result = f.delete();
-        if (!result) {
-            fail("Could not delete test file");
-        }
-    }*/
-
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorQueryTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorQueryTest.java
deleted file mode 100644
index 3ca74bc1e4..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorQueryTest.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import junit.framework.TestCase;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import io.realm.RealmFieldType;
-
-// Tables get detached
-
-public class JNIGarbageCollectorQueryTest extends TestCase {
-
-    private Table t;
-
-
-    public void t1(long count){
-        List<TableQuery> views = new ArrayList<TableQuery>();
-
-        for (long i=0;i<count;i++){
-            t.addEmptyRow();
-            Table sub = t.getSubtable(0, i);
-            views.add(sub.where());
-            sub.close();
-        }
-    }
-
-    public void t2(long count){
-        for (long i=0;i<count;i++){
-            Table sub = t.getSubtable(0, i);
-            TableQuery query = sub.where();
-            sub.close();
-            query.count();
-        }
-    }
-
-    public void t3(long count){
-        for (long i=0;i<count;i++){
-            Table sub = t.getSubtable(0, i);
-            TableQuery query = sub.where();
-            sub.close();
-            query.count();
-            query.close();
-        }
-    }
-
-    public void testGetSubtable(){
-
-        t = new Table();
-        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-
-        long count = 100;
-        long loop = 100;
-
-        for (int i=0;i<loop;i++){
-            t1(count);
-            t2(count);
-            t3(count);
-        }
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorSubtableSchemaTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorSubtableSchemaTest.java
deleted file mode 100644
index 4f44a3c174..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorSubtableSchemaTest.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import junit.framework.TestCase;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import io.realm.RealmFieldType;
-
-
-// Tables get detached
-
-public class JNIGarbageCollectorSubtableSchemaTest extends TestCase {
-
-    private Table t;
-
-
-    public void t1(long count){
-        t = new Table();
-
-        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-        t.addEmptyRow();
-
-        List<TableSchema> tables = new ArrayList<TableSchema>();
-
-        for (long i=0;i<count;i++){
-            t.addEmptyRow();
-            tables.add(t.getSubtableSchema(0));
-        }
-        
-        t.close();
-    }
-
-    public void t2(long count){
-        t = new Table();
-
-        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-        t.addEmptyRow();
-
-        for (long i=0;i<count;i++){
-            t.addEmptyRow();
-
-            TableSchema schema = t.getSubtableSchema(0);
-            schema.toString();
-        }
-        
-        t.close();
-    }
-
-    public void t3(long count){
-        t = new Table();
-
-        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-        t.addEmptyRow();
-
-        for (long i=0;i<count;i++){
-            t.addEmptyRow();
-
-            TableSchema schema = t.getSubtableSchema(0);
-            schema.toString();
-            //schema.close();
-        }
-        
-        t.close();
-    }
-
-    public void testGetSubtable(){
-
-        long count = 10; // 1000;
-        long loop = 10; //  1000;
-
-        for (int i=0;i<loop;i++){
-            t1(count);
-            t2(count);
-            t3(count);
-        }
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableTest.java
deleted file mode 100644
index 309b0611fd..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableTest.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import junit.framework.TestCase;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import io.realm.RealmFieldType;
-
-
-// Tables get detached
-
-public class JNIGarbageCollectorTableTest extends TestCase {
-
-    private Table t;
-
-
-    public void t1(long count){
-        t = new Table();
-
-        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-        t.addEmptyRow();
-
-        List<Table> tables = new ArrayList<Table>();
-
-        for (long i=0;i<count;i++){
-            t.addEmptyRow();
-            tables.add(t.getSubtable(0, i));
-        }
-        
-        t.close();
-    }
-
-    public void t2(long count){
-        t = new Table();
-
-        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-        t.addEmptyRow();
-
-        for (long i=0;i<count;i++){
-            t.addEmptyRow();
-
-            Table sub = t.getSubtable(0, i);
-            sub.size();
-        }
-        
-        t.close();
-    }
-
-    public void t3(long count){
-        t = new Table();
-
-        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-        t.addEmptyRow();
-
-        for (long i=0;i<count;i++){
-            t.addEmptyRow();
-
-            Table sub = t.getSubtable(0, i);
-            sub.size();
-            sub.close();
-        }
-        
-        t.close();
-    }
-
-    public void testGetSubtable(){
-
-        long count = 10; //1000;
-        long loop = 100;
-
-        for (int i=0;i<loop;i++){
-            t1(count);
-            t2(count);
-            t3(count);
-        }
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableViewTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableViewTest.java
deleted file mode 100644
index a6d9024d57..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIGarbageCollectorTableViewTest.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import junit.framework.TestCase;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import io.realm.RealmFieldType;
-
-// Tables get detached
-
-public class JNIGarbageCollectorTableViewTest extends TestCase {
-
-    private Table t;
-
-
-    public void t1(long count){
-        List<TableView> views = new ArrayList<TableView>();
-
-        for (long i=0;i<count;i++){
-            t.addEmptyRow();
-            Table sub = t.getSubtable(0, i);
-            views.add(sub.where().findAll());
-            sub.close();
-        }
-    }
-
-    public void t2(long count){
-        for (long i=0;i<count;i++){
-            Table sub = t.getSubtable(0, i);
-            TableView view = sub.where().findAll();
-            sub.close();
-            view.size();
-        }
-    }
-
-    public void t3(long count){
-        for (long i=0;i<count;i++){
-            Table sub = t.getSubtable(0, i);
-            TableView view = sub.where().findAll();
-            sub.close();
-            view.size();
-            view.close();
-        }
-    }
-
-    public void testGetSubtableView(){
-        
-        t = new Table();
-        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-
-        long count = 10; // 1000;
-        long loop = 100;
-
-        for (int i=0;i<loop;i++){
-            t1(count);
-            t2(count);
-            t3(count);
-        }
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIImplicitTransactionsTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIImplicitTransactionsTest.java
deleted file mode 100644
index bbfcbbf011..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIImplicitTransactionsTest.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import android.test.AndroidTestCase;
-
-import java.io.File;
-import java.util.Arrays;
-
-import io.realm.RealmFieldType;
-
-public class JNIImplicitTransactionsTest extends AndroidTestCase {
-
-    String testFile;
-
-    @Override
-    protected void setUp() throws Exception {
-        testFile = new File(this.getContext().getFilesDir(), "implicit.realm").toString();
-    }
-
-    private void deleteFile() {
-        for (String fileToDelete : Arrays.asList(testFile, testFile + ".lock")) {
-            File f = new File(fileToDelete);
-            if (f.exists()) {
-                boolean result = f.delete();
-                if (!result) {
-                    fail();
-                }
-            }
-        }
-    }
-
-    public void testImplicitTransactions() {
-        deleteFile();
-        SharedGroup sg = new SharedGroup(testFile, true, SharedGroup.Durability.FULL, null); // TODO: try with encryption
-
-        // Create a table
-        WriteTransaction wt = sg.beginWrite();
-        if (!wt.hasTable("test")) {
-            Table table = wt.getTable("test");
-            table.addColumn(RealmFieldType.INTEGER, "integer");
-            table.addEmptyRow();
-        }
-        wt.commit();
-
-        // Add a row in a write transaction and continue with read transaction
-        ImplicitTransaction t = sg.beginImplicitTransaction();
-        Table test = t.getTable("test");
-        assertEquals(1, test.size());
-        t.promoteToWrite();
-        test.addEmptyRow();
-        t.commitAndContinueAsRead();
-
-        // Should throw as this is now a read transaction
-        try {
-            test.addEmptyRow();
-            fail();
-        } catch (IllegalStateException e) {
-            assertNotNull(e);
-        }
-    }
-
-    public void testCannotUseClosedImplicitTransaction() {
-        deleteFile();
-        SharedGroup sg = new SharedGroup(testFile, true, SharedGroup.Durability.FULL, null);
-        WriteTransaction wt = sg.beginWrite();
-        if (!wt.hasTable("test")) {
-            Table table = wt.getTable("test");
-            table.addColumn(RealmFieldType.INTEGER, "integer");
-            table.addEmptyRow();
-        }
-        wt.commit();
-        ImplicitTransaction t = sg.beginImplicitTransaction();
-
-        sg.close();
-        try {
-            t.advanceRead();
-        } catch (IllegalStateException e) {
-            return;
-        }
-
-        fail("It should not be possible to advanceRead on a transaction which SharedGroup is closed");
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNILinkTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNILinkTest.java
index ba674f6664..c4b962149e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNILinkTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNILinkTest.java
@@ -16,19 +16,45 @@
 
 package io.realm.internal;
 
-import junit.framework.TestCase;
+import android.support.test.runner.AndroidJUnit4;
 
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.RealmConfiguration;
 import io.realm.RealmFieldType;
+import io.realm.rule.TestRealmConfigurationFactory;
 
-public class JNILinkTest extends TestCase {
+import static junit.framework.Assert.assertEquals;
 
-    public void testLinkColumns() {
+@RunWith(AndroidJUnit4.class)
+public class JNILinkTest {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private SharedRealm sharedRealm;
 
-        Group group = new Group();
+    @Before
+    public void setUp() {
+        RealmConfiguration config = configFactory.createConfiguration();
+        sharedRealm = SharedRealm.getInstance(config);
+        sharedRealm.beginTransaction();
+    }
 
-        Table table1 = group.getTable("table1");
+    @After
+    public void tearDown() {
+        sharedRealm.cancelTransaction();
+        sharedRealm.close();
+    }
 
-        Table table2 = group.getTable("table2");
+    @Test
+    public void testLinkColumns() {
+        Table table1 = sharedRealm.getTable("table1");
+
+        Table table2 = sharedRealm.getTable("table2");
         table2.addColumn(RealmFieldType.INTEGER, "int");
         table2.addColumn(RealmFieldType.STRING, "string");
 
@@ -53,18 +79,16 @@ public void testLinkColumns() {
 
     }
 
+    @Test
     public void testLinkList() {
-
-        Group group = new Group();
-
-        Table table1 = group.getTable("table1");
+        Table table1 = sharedRealm.getTable("table1");
         table1.addColumn(RealmFieldType.INTEGER, "int");
         table1.addColumn(RealmFieldType.STRING, "string");
         table1.add(1, "c");
         table1.add(2, "b");
         table1.add(3, "a");
 
-        Table table2 = group.getTable("table2");
+        Table table2 = sharedRealm.getTable("table2");
 
         table2.addColumnLink(RealmFieldType.LIST, "LinkList", table1);
 
@@ -93,7 +117,5 @@ public void testLinkList() {
 
         assertEquals(links.getUncheckedRow(0).getString(1), "a");
         assertEquals(links.size(), 1);
-
     }
-
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIMixedSubtableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIMixedSubtableTest.java
deleted file mode 100644
index fcce79d622..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIMixedSubtableTest.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import junit.framework.TestCase;
-
-import java.util.Date;
-
-import io.realm.RealmFieldType;
-
-public class JNIMixedSubtableTest extends TestCase {
-
-    public void testGetSubtableFromMixedColumnTest() {
-        Util.setDebugLevel(2);
-        Table table = new Table();
-
-        table.addColumn(RealmFieldType.INTEGER, "num");
-        table.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "mix");
-
-        // No rows added yet
-        try { Table subtable = table.getSubtable(1, 0); fail("No rows added, index out of bounds"); } catch (ArrayIndexOutOfBoundsException e) { }
-
-        // addEmptyRow() will put Mixed(0) as default value into the mixed column.
-        table.addEmptyRow();
-        // Getting a subtable on a mixed with a 0 int value should not work
-        try { Table subtable = table.getSubtable(1, 0); fail("Mixed contains an int, not a subtable"); } catch (IllegalArgumentException e) { }
-
-        // Now we set the Mixed value to a binary
-        table.setMixed(1, 0, new Mixed(new byte[] {1,2,3}));
-        // Getting a subtable on a mixed with a date value should not work
-        try { Table subtable = table.getSubtable(1, 0); fail("Mixed contains an binary, not a subtable"); } catch (IllegalArgumentException e) { }
-
-        // Now we set the Mixed value to a bool
-        table.setMixed(1, 0, new Mixed(true));
-        // Getting a subtable on a mixed with a String value should not work
-        try { Table subtable = table.getSubtable(1, 0); fail("Mixed contains a bool, not a subtable"); } catch (IllegalArgumentException e) { }
-
-        // Now we set the Mixed value to a date
-        table.setMixed(1, 0, new Mixed(new Date()));
-        // Getting a subtable on a mixed with a date value should not work
-        try { Table subtable = table.getSubtable(1, 0); fail("Mixed contains a date, not a subtable"); } catch (IllegalArgumentException e) { }
-
-        // Now we set the Mixed value to a double
-        table.setMixed(1, 0, new Mixed(3.0d));
-        // Getting a subtable on a mixed with a date value should not work
-        try { Table subtable = table.getSubtable(1, 0); fail("Mixed contains a double, not a subtable"); } catch (IllegalArgumentException e) { }
-
-        // Now we set the Mixed value to a float
-        table.setMixed(1, 0, new Mixed(3.0f));
-        // Getting a subtable on a mixed with a date value should not work
-        try { Table subtable = table.getSubtable(1, 0); fail("Mixed contains a float, not a subtable"); } catch (IllegalArgumentException e) { }
-
-        // Now we set the Mixed value to a int
-        table.setMixed(1, 0, new Mixed(300));
-        // Getting a subtable on a mixed with a date value should not work
-        try { Table subtable = table.getSubtable(1, 0); fail("Mixed contains an int, not a subtable"); } catch (IllegalArgumentException e) { }
-
-        // Now we set the Mixed value to a String
-        table.setMixed(1, 0, new Mixed("s"));
-        // Getting a subtable on a mixed with a String value should not work
-        try { Table subtable = table.getSubtable(1, 0); fail("Mixed contains a String, not a subtable"); } catch (IllegalArgumentException e) { }
-
-        /* FIXME: Subtable in Mixed is currently not supported
-        // Now we specifically set the Mixed value to a subtable
-        table.setMixed(1, 0, new Mixed(RealmFieldType.UNSUPPORTED_TABLE));
-        // Getting a subtable on the mixed column is now allowed
-        Table subtable = table.getSubtable(1, 0);
-        */
-    }
-
-    // Test uses TableSpec..
-    public void testShouldCreateSubtableInMixedTypeColumn() {
-        Table table = new Table();
-
-        TableSpec tableSpec = new TableSpec();
-        tableSpec.addColumn(RealmFieldType.INTEGER, "num");
-        tableSpec.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "mix");
-        TableSpec subspec = tableSpec.addSubtableColumn("subtable");
-        subspec.addColumn(RealmFieldType.INTEGER, "num");
-        table.updateFromSpec(tableSpec);
-
-        // Shouldn't work: no Mixed stored yet
-        //Mixed m1 = table.getMixed(1, 0);
-        //ColumnType mt = table.getMixedType(1,0);
-
-        // You can't "getSubtable()" unless there is one. And the addEmptyRow will put in a Mixed(0) as default.
-        // You now get an exception instead of crash if you try anyway
-        {
-            table.addEmptyRow();
-
-            try { Table subtable = table.getSubtable(1, 0); fail("Mixed contains 0, not a subtable");  } catch (IllegalArgumentException e) {}
-            table.removeLast();
-        }
-
-        /* FIXME: Subtable in Mixed is currently not supported
-        long ROW = 0;
-        // Add empty row - the simple way
-        table.addEmptyRow();
-        table.setMixed(1, ROW, new Mixed(RealmFieldType.UNSUPPORTED_TABLE));
-        assertEquals(1, table.size());
-        assertEquals(0, table.getSubtableSize(1, 0));
-
-        // Create schema for the one Mixed cell with a subtable
-        Table subtable = table.getSubtable(1, ROW);
-        TableSpec subspecMixed = subtable.getTableSpec();
-        subspecMixed.addColumn(RealmFieldType.INTEGER, "num");
-        subtable.updateFromSpec(subspecMixed);
-
-        // Insert value in the Mixed subtable
-        subtable.add(27);
-        subtable.add(273);
-        assertEquals(2, subtable.size());
-        assertEquals(2, table.getSubtableSize(1, ROW));
-        assertEquals(27, subtable.getLong(0, ROW));
-        assertEquals(273, subtable.getLong(0, ROW+1));
-        */
-    }
-
-    /* FIXME: Subtable in Mixed is currently not supported
-    public void testShouldCreateSubtableInMixedTypeColumn2() {
-        Table table = new Table();
-
-        TableSpec tableSpec = new TableSpec();
-        tableSpec.addColumn(RealmFieldType.INTEGER, "num");
-        tableSpec.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "mix");
-        table.updateFromSpec(tableSpec);
-
-        table.addEmptyRow();
-        table.setMixed(1, 0, new Mixed(RealmFieldType.UNSUPPORTED_TABLE));
-
-        Table subtable = table.getSubtable(1, 0);
-    }
-    */
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIMixedTypeTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIMixedTypeTest.java
deleted file mode 100644
index 5c630f7ff6..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIMixedTypeTest.java
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.List;
-
-import io.realm.RealmFieldType;
-import io.realm.internal.test.MixedData;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.fail;
-
-@RunWith(Parameterized.class)
-public class JNIMixedTypeTest {
-
-    List<MixedData> mixedDataList = new ArrayList<MixedData>();
-
-    @Parameterized.Parameters
-    public static List<Object[]> parameters() {
-        //Adding MixedData to the list
-        List<MixedData> mixedDataList = new ArrayList<MixedData>();
-        mixedDataList.add(0, new MixedData(RealmFieldType.INTEGER, 123L));
-        mixedDataList.add(1, new MixedData(RealmFieldType.FLOAT, 987.123f));
-        mixedDataList.add(2, new MixedData(RealmFieldType.DOUBLE, 1234567.898d));
-        mixedDataList.add(3, new MixedData(RealmFieldType.BOOLEAN, true));
-        mixedDataList.add(4, new MixedData(RealmFieldType.STRING, "abc"));
-        mixedDataList.add(5, new MixedData(RealmFieldType.BINARY, new byte[]{1, 2, 3, 4, 5}));
-        mixedDataList.add(6, new MixedData(RealmFieldType.DATE, new Date(645342)));
-
-        return Arrays.asList(
-                new Object[]{mixedDataList},
-                new Object[]{mixedDataList},
-                new Object[]{mixedDataList},
-                new Object[]{mixedDataList}
-        );
-    }
-
-    public JNIMixedTypeTest(List<MixedData> mixedDataList) {
-        this.mixedDataList = mixedDataList;
-    }
-
-    @Test
-    public void testShouldMatchMixedValues() {
-        for (int i = 0; i < mixedDataList.size(); i++) {
-            for (int j = 0; j < mixedDataList.size(); j++) {
-                if (mixedDataList.get(i).value == mixedDataList.get(j).value) {
-                    assertEquals(mixedDataList.get(i).value, mixedDataList.get(j).value);
-
-                } else {
-                    assertNotSame(mixedDataList.get(i).value, mixedDataList.get(j).value);
-
-                }
-            }
-        }
-    }
-
-    @Test
-    public void testShouldFailOnWrongTypeRetrieval() {
-        for (int i = 0; i < mixedDataList.size(); i++) {
-            Object value = mixedDataList.get(i).type != RealmFieldType.STRING ? "abc" : 123;
-            Mixed mixed = Mixed.mixedValue(value);
-
-            switch (mixedDataList.get(i).type) {
-                case BINARY:
-                    try {
-                        mixed.getBinaryByteArray();
-                        fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException ignored) {
-                    }
-                    break;
-                case DATE:
-                    try {
-                        mixed.getDateValue();
-                        fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException ignored) {
-                    }
-                    break;
-                case BOOLEAN:
-                    try {
-                        mixed.getBooleanValue();
-                        fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException ignored) {
-                    }
-                    break;
-                case INTEGER:
-                    try {
-                        mixed.getLongValue();
-                        fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException ignored) {
-                    }
-                    break;
-                case FLOAT:
-                    try {
-                        mixed.getFloatValue();
-                        fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException ignored) {
-                    }
-                    break;
-                case DOUBLE:
-                    try {
-                        mixed.getDoubleValue();
-                        fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException ignored) {
-                    }
-                    break;
-                case STRING:
-                    try {
-                        mixed.getStringValue();
-                        fail("Wrong mixed type");
-                    } catch (IllegalMixedTypeException ignored) {
-                    }
-                    break;
-                default:
-                    fail("wrong type");
-                    break;
-            }
-        }
-    }
-}
-
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNI_nativeTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNINativeTest.java
similarity index 51%
rename from realm/realm-library/src/androidTest/java/io/realm/internal/JNI_nativeTests.java
rename to realm/realm-library/src/androidTest/java/io/realm/internal/JNINativeTest.java
index e05e3ab8ef..8847528a20 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNI_nativeTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNINativeTest.java
@@ -16,22 +16,26 @@
 
 package io.realm.internal;
 
-import junit.framework.TestCase;
+import android.support.test.runner.AndroidJUnit4;
 
-public class JNI_nativeTests extends TestCase {
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
-    public void testNativeExceptions() {
-        String expect = "";
-        for (Util.Testcase test : Util.Testcase.values()) {
-            expect = test.expectedResult(0);
+import static junit.framework.Assert.assertEquals;
+
+@RunWith(AndroidJUnit4.class)
+public class JNINativeTest {
+
+    @Test
+    public void nativeExceptions() {
+        long maxExceptionNumber = TestUtil.getMaxExceptionNumber();
+        for (long i = 0; i < maxExceptionNumber; i++) {
+            String expect = TestUtil.getExpectedMessage(i);
             try {
-                test.execute(0);
-            } catch (Exception e) {
-                assertEquals(expect, e.toString());
-            } catch (Error e) {
-                assertEquals(expect, e.toString());
+                TestUtil.testThrowExceptions(i);
+            } catch (Throwable throwable) {
+                assertEquals("Exception kind: " + i, expect, throwable.toString());
             }
-
         }
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
index 4942a9497e..71f504509d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
@@ -44,18 +44,6 @@ void init() {
         assertEquals(6, table.size());
     }
 
-    public void shouldQueryOnSortedView() {
-
-        init();
-
-        TableView sortedView = table.getSortedView(0, Sort.DESCENDING);
-
-        TableView result = sortedView.where().findAll();
-
-        assertEquals(result.size(), table.size());
-
-    }
-
     public void testShouldQuery() {
         init();
         TableQuery query = table.where();
@@ -439,7 +427,7 @@ public void testQueryTestForNoMatches() {
         Table t = new Table();
         t = TestHelper.getTableWithAllColumnTypes();
 
-        t.add(new byte[]{1,2,3}, true, new Date(1384423149761l), 4.5d, 5.7f, 100, new Mixed("mixed"), "string", null);
+        t.add(new byte[]{1,2,3}, true, new Date(1384423149761l), 4.5d, 5.7f, 100, "string");
 
         TableQuery q = t.where().greaterThan(new long[]{5}, 1000); // No matches
 
@@ -457,18 +445,16 @@ public void testQueryWithWrongDataType() {
         TableQuery query = table.where();
 
         // Compare strings in non string columns
-        for (int i = 0; i <= 8; i++) {
-            if (i != 7) {
-                try { query.equalTo(new long[]{i}, "string");                 assert(false); } catch(IllegalArgumentException e) {}
-                try { query.notEqualTo(new long[]{i}, "string");              assert(false); } catch(IllegalArgumentException e) {}
-                try { query.beginsWith(new long[]{i}, "string");            assert(false); } catch(IllegalArgumentException e) {}
-                try { query.endsWith(new long[]{i}, "string");              assert(false); } catch(IllegalArgumentException e) {}
-                try { query.contains(new long[]{i}, "string");              assert(false); } catch(IllegalArgumentException e) {}
-            }
+        for (int i = 0; i <= 6; i++) {
+            try { query.equalTo(new long[]{i}, "string");                 assert(false); } catch(IllegalArgumentException e) {}
+            try { query.notEqualTo(new long[]{i}, "string");              assert(false); } catch(IllegalArgumentException e) {}
+            try { query.beginsWith(new long[]{i}, "string");            assert(false); } catch(IllegalArgumentException e) {}
+            try { query.endsWith(new long[]{i}, "string");              assert(false); } catch(IllegalArgumentException e) {}
+            try { query.contains(new long[]{i}, "string");              assert(false); } catch(IllegalArgumentException e) {}
         }
 
         // Compare integer in non integer columns
-        for (int i = 0; i <= 8; i++) {
+        for (int i = 0; i <= 6; i++) {
             if (i != 5) {
                 try { query.equalTo(new long[]{i}, 123);                      assert(false); } catch(IllegalArgumentException e) {}
                 try { query.notEqualTo(new long[]{i}, 123);                   assert(false); } catch(IllegalArgumentException e) {}
@@ -481,7 +467,7 @@ public void testQueryWithWrongDataType() {
         }
 
         // Compare float in non float columns
-        for (int i = 0; i <= 8; i++) {
+        for (int i = 0; i <= 6; i++) {
             if (i != 4) {
                 try { query.equalTo(new long[]{i}, 123F);                     assert(false); } catch(IllegalArgumentException e) {}
                 try { query.notEqualTo(new long[]{i}, 123F);                  assert(false); } catch(IllegalArgumentException e) {}
@@ -494,7 +480,7 @@ public void testQueryWithWrongDataType() {
         }
 
         // Compare double in non double columns
-        for (int i = 0; i <= 8; i++) {
+        for (int i = 0; i <= 6; i++) {
             if (i != 3) {
                 try { query.equalTo(new long[]{i}, 123D);                     assert(false); } catch(IllegalArgumentException e) {}
                 try { query.notEqualTo(new long[]{i}, 123D);                  assert(false); } catch(IllegalArgumentException e) {}
@@ -507,7 +493,7 @@ public void testQueryWithWrongDataType() {
         }
 
         // Compare boolean in non boolean columns
-        for (int i = 0; i <= 8; i++) {
+        for (int i = 0; i <= 6; i++) {
             if (i != 1) {
               try { query.equalTo(new long[]{i}, true);                       assert(false); } catch(IllegalArgumentException e) {}
             }
@@ -547,12 +533,6 @@ public void testColumnIndexOutOfBounds() {
         try { query.minimumInt(6);                 assert(false); } catch(IllegalArgumentException e) {}
         try { query.minimumFloat(6);            assert(false); } catch(IllegalArgumentException e) {}
         try { query.minimumDouble(6);           assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumInt(7);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumFloat(7);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumDouble(7);           assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumInt(8);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumFloat(8);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumDouble(8);           assert(false); } catch(IllegalArgumentException e) {}
 
         try { query.maximumInt(0);                 assert(false); } catch(IllegalArgumentException e) {}
         try { query.maximumFloat(0);            assert(false); } catch(IllegalArgumentException e) {}
@@ -566,12 +546,6 @@ public void testColumnIndexOutOfBounds() {
         try { query.maximumInt(6);                 assert(false); } catch(IllegalArgumentException e) {}
         try { query.maximumFloat(6);            assert(false); } catch(IllegalArgumentException e) {}
         try { query.maximumDouble(6);           assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumInt(7);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumFloat(7);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumDouble(7);           assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumInt(8);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumFloat(8);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumDouble(8);           assert(false); } catch(IllegalArgumentException e) {}
 
         try { query.sumInt(0);                     assert(false); } catch(IllegalArgumentException e) {}
         try { query.sumFloat(0);                assert(false); } catch(IllegalArgumentException e) {}
@@ -585,12 +559,6 @@ public void testColumnIndexOutOfBounds() {
         try { query.sumInt(6);                     assert(false); } catch(IllegalArgumentException e) {}
         try { query.sumFloat(6);                assert(false); } catch(IllegalArgumentException e) {}
         try { query.sumDouble(6);               assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumInt(7);                     assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumFloat(7);                assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumDouble(7);               assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumInt(8);                     assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumFloat(8);                assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumDouble(8);               assert(false); } catch(IllegalArgumentException e) {}
 
         try { query.averageInt(0);                 assert(false); } catch(IllegalArgumentException e) {}
         try { query.averageFloat(0);            assert(false); } catch(IllegalArgumentException e) {}
@@ -604,52 +572,46 @@ public void testColumnIndexOutOfBounds() {
         try { query.averageInt(6);                 assert(false); } catch(IllegalArgumentException e) {}
         try { query.averageFloat(6);            assert(false); } catch(IllegalArgumentException e) {}
         try { query.averageDouble(6);           assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageInt(7);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageFloat(7);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageDouble(7);           assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageInt(8);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageFloat(8);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageDouble(8);           assert(false); } catch(IllegalArgumentException e) {}
         // Out of bounds for string
-        try { query.equalTo(new long[]{9}, "string");                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.beginsWith(new long[]{9}, "string");            assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.endsWith(new long[]{9}, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{9}, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{7}, "string");                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{7}, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.beginsWith(new long[]{7}, "string");            assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.endsWith(new long[]{7}, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{7}, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
 
 
         // Out of bounds for integer
-        try { query.equalTo(new long[]{9}, 123);                      assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, 123);                   assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{9}, 123);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{9}, 123);              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{9}, 123);                  assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{9}, 123);           assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{9}, 123, 321);                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{7}, 123);                      assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{7}, 123);                   assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{7}, 123);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{7}, 123);              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{7}, 123);                  assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{7}, 123);           assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{7}, 123, 321);                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
 
 
         // Out of bounds for float
-        try { query.equalTo(new long[]{9}, 123F);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, 123F);                  assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{9}, 123F);                    assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{9}, 123F);             assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{9}, 123F);                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{9}, 123F);          assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{9}, 123F, 321F);               assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{7}, 123F);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{7}, 123F);                  assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{7}, 123F);                    assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{7}, 123F);             assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{7}, 123F);                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{7}, 123F);          assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{7}, 123F, 321F);               assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
 
 
         // Out of bounds for double
-        try { query.equalTo(new long[]{9}, 123D);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, 123D);                  assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{9}, 123D);                    assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{9}, 123D);             assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{9}, 123D);                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{9}, 123D);          assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{9}, 123D, 321D);               assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{7}, 123D);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{7}, 123D);                  assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{7}, 123D);                    assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{7}, 123D);             assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{7}, 123D);                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{7}, 123D);          assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{7}, 123D, 321D);               assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
 
 
         // Out of bounds for boolean
-        try { query.equalTo(new long[]{9}, true);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{7}, true);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
     }
 
 
@@ -702,48 +664,6 @@ public void testQueryOnViewWithAlreadyQueriedTable() {
         assertEquals(1, view2.size());
     }
 
-
-
-    public void testQueryWithSubtable() {
-        Table table = new Table();
-        table.addColumn(RealmFieldType.STRING, "username");
-        table.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "tasks");
-        table.addColumn(RealmFieldType.STRING, "username2");
-
-        TableSchema tasks = table.getSubtableSchema(1);
-        tasks.addColumn(RealmFieldType.STRING, "name");
-        tasks.addColumn(RealmFieldType.INTEGER, "score");
-        tasks.addColumn(RealmFieldType.BOOLEAN, "completed");
-
-        // Insert some values
-        table.add("Arnold", new Object[][] {{"task1", 120, false},
-                                            {"task2", 321, false},
-                                            {"task3", 78, false}}, "");
-        table.add("Jane", new Object[][] {{"task2", 400, true},
-                                          {"task3", 375, true}}, "");
-        table.add("Erik", new Object[][] {{"task1", 562, true},
-                                          {"task3", 14, false}}, "");
-
-        // Query the table
-        TableView view = table.where().subtable(1).equalTo(new long[]{2}, true).endSubtable().findAll();
-        assertEquals(2, view.size());
-    }
-
-
-    public void testQueryWithUnbalancedSubtable() {
-        Table table = new Table();
-        table.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "sub");
-
-        TableSchema tasks = table.getSubtableSchema(0);
-        tasks.addColumn(RealmFieldType.STRING, "name");
-
-        try { table.where().subtable(0).count();               assert(false); } catch (UnsupportedOperationException e) {}
-        try { table.where().endSubtable().count();             assert(false); } catch (UnsupportedOperationException e) {}
-        try { table.where().endSubtable().subtable(0).count(); assert(false); } catch (UnsupportedOperationException e) {}
-        try { table.where().subtable(0).endSubtable().count(); assert(false); } catch (UnsupportedOperationException e) {}
-    }
-
-
     public void testMaximumDate() {
 
         Table table = new Table();
@@ -866,4 +786,30 @@ public void testDateQuery() throws Exception {
         assertEquals(0L, table.where().between(new long[]{0}, distantFuture, future).count());
         assertEquals(1L, table.where().between(new long[]{0}, distantFuture, distantFuture).count());
     }
+
+    public void testByteArrayQuery() throws Exception {
+
+        Table table = new Table();
+        table.addColumn(RealmFieldType.BINARY, "binary");
+
+        final byte[] binary1 = new byte[] {0x01, 0x02, 0x03, 0x04};
+        final byte[] binary2 = new byte[] {0x05, 0x02, 0x03, 0x08};
+        final byte[] binary3 = new byte[] {0x09, 0x0a, 0x0b, 0x04};
+        final byte[] binary4 = new byte[] {0x05, 0x0a, 0x0b, 0x10};
+
+        table.add((Object) binary1);
+        table.add((Object) binary2);
+        table.add((Object) binary3);
+        table.add((Object) binary4);
+
+        // Equal to
+
+        assertEquals(1L, table.where().equalTo(new long[]{0}, binary1).count());
+        assertEquals(1L, table.where().equalTo(new long[]{0}, binary3).count());
+
+        // Not equal to
+
+        assertEquals(3L, table.where().notEqualTo(new long[]{0}, binary2).count());
+        assertEquals(3L, table.where().notEqualTo(new long[]{0}, binary4).count());
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIRowTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIRowTest.java
index 96f6c359d6..8b9c613d0b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIRowTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIRowTest.java
@@ -74,26 +74,6 @@ public void testRow() {
         MoreAsserts.assertEquals(newData, row.getBinaryByteArray(6));
     }
 
-    public void testMixed() {
-        Table table = new Table();
-
-        table.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "mixed");
-
-        table.addEmptyRows(2);
-
-        UncheckedRow row = table.getUncheckedRow(0);
-        row.setMixed(0, new Mixed(1.5));
-
-        assertEquals(1.5, row.getMixed(0).getDoubleValue());
-
-        UncheckedRow row2 = table.getUncheckedRow(1);
-        row2.setMixed(0, new Mixed("test"));
-
-        assertEquals("test", row2.getMixed(0).getStringValue());
-
-
-    }
-
     public void testNull() {
 
         Table table = new Table();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNISubtableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNISubtableTest.java
deleted file mode 100644
index 50a3650938..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNISubtableTest.java
+++ /dev/null
@@ -1,278 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import junit.framework.TestCase;
-
-import io.realm.RealmFieldType;
-
-public class JNISubtableTest extends TestCase {
-
-    public void testShouldSynchronizeNestedTables() throws Throwable {
-        Group group = new Group();
-        Table table = group.getTable("emp");
-
-        TableSpec tableSpec = new TableSpec();
-        tableSpec.addColumn(RealmFieldType.STRING, "name");
-
-        TableSpec subspec = tableSpec.addSubtableColumn("sub");
-        subspec.addColumn(RealmFieldType.INTEGER, "num");
-
-        table.updateFromSpec(tableSpec);
-
-        table.add("Foo", null);
-        assertEquals(1, table.size());
-
-        Table subtable1 = table.getSubtable(1, 0);
-        subtable1.add(123);
-        assertEquals(1, subtable1.size());
-        subtable1.close();
-
-        Table subtable2 = table.getSubtable(1, 0);
-        assertEquals(1, subtable2.size());
-        assertEquals(123, subtable2.getLong(0, 0));
-
-        table.clear();
-    }
-
-    public void testShouldInsertNestedTablesNested() {
-        Group group = new Group();
-        Table table = group.getTable("emp");
-
-        // Define table
-        TableSpec tableSpec = new TableSpec();
-        tableSpec.addColumn(RealmFieldType.STRING, "name");
-
-        TableSpec subspec = tableSpec.addSubtableColumn("sub");
-        subspec.addColumn(RealmFieldType.INTEGER, "num");
-
-        tableSpec.addColumn(RealmFieldType.INTEGER, "Int");
-        table.updateFromSpec(tableSpec);
-
-        // Insert values
-        table.add("Foo", null, 123456);
-        table.getSubtable(1, 0).add(123);
-        assertEquals(1, table.getSubtable(1, 0).size());
-        assertEquals(123, table.getSubtable(1, 0).getLong(0,0));
-
-        assertEquals(1, table.size());
-    }
-
-    public void testShouldReturnSubtableIfNullIsInsertedAsSubtable() {
-        Group group = new Group();
-        Table table = group.getTable("emp");
-
-        table.addColumn(RealmFieldType.STRING, "string");
-        long subtableColIndex = table.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-
-        table.add("val", null);
-        assertEquals(0,  table.getSubtable(subtableColIndex, 0).getColumnCount());
-    }
-
-    public void testGetSubtableOutOfRange() {
-        Group group = new Group();
-        Table table = group.getTable("emp");
-
-        table.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-
-        // No rows added
-        try { 
-            table.getSubtable(0, 0); 
-            fail("rowIndex > available rows."); 
-        } catch (ArrayIndexOutOfBoundsException e) {
-            assertNotNull(e);
-        }
-
-        try { 
-            table.getSubtable(1, 0); 
-            fail("columnIndex > available columns."); 
-        } catch (ArrayIndexOutOfBoundsException e) {
-            assertNotNull(e);
-        }
-
-        table.addEmptyRow();
-
-        try { 
-            table.getSubtable(1, 0); 
-            fail("columnIndex > available columns."); 
-        } catch (ArrayIndexOutOfBoundsException e) {
-            assertNotNull(e);
-        }
-    }
-
-    public void testSubtableSort() {
-        Group group = new Group();
-        Table table = group.getTable("emp");
-
-        table.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "table");
-        TableSchema subSchema = table.getSubtableSchema(0);
-        long subtableIntColIndex = subSchema.addColumn(RealmFieldType.INTEGER, "int col");
-        long subtableStringColIndex = subSchema.addColumn(RealmFieldType.STRING, "string col");
-
-        table.addEmptyRow();
-
-        Table subtable = table.getSubtable(0, 0);
-        subtable.add(10, "s");
-        subtable.add(100, "ss");
-        subtable.add(1000, "sss");
-
-        TableView subView = subtable.where().findAll();
-        subView.sort(subtableIntColIndex);
-
-        assertEquals(10, subView.getLong(0, 0));
-        assertEquals(100, subView.getLong(0, 1));
-        assertEquals(1000, subView.getLong(0, 2));
-    }
-
-    public void testAddColumnsToSubtables() {
-
-        // Table definition
-        Table persons = new Table();
-        persons.addColumn(RealmFieldType.STRING, "name");
-        persons.addColumn(RealmFieldType.STRING, "email");
-        persons.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "addresses");
-
-        // Add a subtable
-        TableSchema addresses = persons.getSubtableSchema(2);
-        addresses.addColumn(RealmFieldType.STRING, "street");
-        addresses.addColumn(RealmFieldType.INTEGER, "zipcode");
-        addresses.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "phone_numbers");
-
-        TableSchema phone_numbers = addresses.getSubtableSchema(2);
-        phone_numbers.addColumn(RealmFieldType.INTEGER, "number");
-
-        // Inserting data
-        persons.add("Mr X", "xx@xxxx.com", new Object[][] {{ "X Street", 1234, new Object[][] {{ 12345678 }} }});
-
-        // Assertions
-        assertEquals(persons.getColumnName(2), "addresses");
-        assertEquals(persons.getSubtable(2,0).getColumnName(2), "phone_numbers");
-        assertEquals(persons.getSubtable(2,0).getSubtable(2,0).getColumnName(0), "number");
-
-        assertEquals(persons.getString(1,0), "xx@xxxx.com");
-        assertEquals(persons.getSubtable(2,0).getString(0,0), "X Street");
-        assertEquals(persons.getSubtable(2,0).getSubtable(2,0).getLong(0,0), 12345678);
-    }
-
-
-    public void testSubtableAddColumnsCheckNames() {
-
-        // Table definition
-        Table persons = new Table();
-
-        persons.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "sub");
-
-        TableSchema addresses = persons.getSubtableSchema(0);
-        try {
-            addresses.addColumn(RealmFieldType.STRING, "I am 64 characters..............................................");
-            fail("Only 63 characters supported"); }
-        catch (IllegalArgumentException e) {
-            assertNotNull(e);
-        }
-
-        addresses.addColumn(RealmFieldType.STRING, "I am 63 characters.............................................");
-    }
-
-    public void testRemoveColumnFromSubtable() {
-
-        // Table definition
-        Table persons = new Table();
-        persons.addColumn(RealmFieldType.STRING, "name");
-        persons.addColumn(RealmFieldType.STRING, "email");
-        persons.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "addresses");
-
-        TableSchema addresses = persons.getSubtableSchema(2);
-        addresses.addColumn(RealmFieldType.STRING, "street");
-        addresses.addColumn(RealmFieldType.INTEGER, "zipcode");
-        addresses.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "phone_numbers");
-
-        TableSchema phone_numbers = addresses.getSubtableSchema(2);
-        phone_numbers.addColumn(RealmFieldType.INTEGER, "number");
-
-        // Inserting data
-        persons.add("Mr X", "xx@xxxx.com", new Object[][] {{ "X Street", 1234, new Object[][] {{ 12345678 }} }});
-
-        // Assertions
-        assertEquals(persons.getSubtable(2,0).getColumnCount(), 3);
-        addresses.removeColumn(1);
-        assertEquals(persons.getSubtable(2,0).getColumnCount(), 2);
-    }
-
-    public void testRenameColumnInSubtable() {
-
-        // Table definition
-        Table persons = new Table();
-        persons.addColumn(RealmFieldType.STRING, "name");
-        persons.addColumn(RealmFieldType.STRING, "email");
-        persons.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "addresses");
-
-        // Define subtable
-        TableSchema addresses = persons.getSubtableSchema(2);
-        addresses.addColumn(RealmFieldType.STRING, "street");
-        addresses.addColumn(RealmFieldType.INTEGER, "zipcode");
-        addresses.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "phone_numbers");
-
-        TableSchema phone_numbers = addresses.getSubtableSchema(2);
-        phone_numbers.addColumn(RealmFieldType.INTEGER, "number");
-
-        // Inserting data
-        persons.add("Mr X", "xx@xxxx.com", new Object[][] {{ "X Street", 1234, new Object[][] {{ 12345678 }} }});
-
-        // Assertions
-        assertEquals("zipcode", persons.getSubtable(2,0).getColumnName(1));
-        addresses.renameColumn(1, "zip");
-        assertEquals("zip", persons.getSubtable(2,0).getColumnName(1));
-    }
-
-    public void testShouldThrowOnGetSubtableDefinitionFromSubtable() {
-        // Table definition
-        Table persons = new Table();
-        persons.addColumn(RealmFieldType.STRING, "name");
-        persons.addColumn(RealmFieldType.STRING, "email");
-        persons.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "addresses");
-
-        TableSchema addresses = persons.getSubtableSchema(2);
-        addresses.addColumn(RealmFieldType.STRING, "street");
-        addresses.addColumn(RealmFieldType.INTEGER, "zipcode");
-        addresses.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "phone_numbers");
-
-        TableSchema phone_numbers = addresses.getSubtableSchema(2);
-        phone_numbers.addColumn(RealmFieldType.INTEGER, "number");
-
-        // Inserting data
-        persons.add("Mr X", "xx@xxxx.com", new Object[][] {{ "X Street", 1234, new Object[][] {{ 12345678 }} }});
-
-        try {
-            // Should throw
-            persons.getSubtable(2,0).addColumn(RealmFieldType.INTEGER, "i");
-            fail("expected exception.");
-        } catch (UnsupportedOperationException e) {
-            assertNotNull(e);
-        }
-
-        try {
-            // Should throw
-            persons.getSubtable(2,0).getSubtableSchema(2);
-            fail("expected exception.");
-        } catch (UnsupportedOperationException e) {
-            assertNotNull(e);
-        }
-
-    }
-
-    // TODO: try on mixed columns - it should work there
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableInsertTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableInsertTest.java
index 675a46ac1f..36507e6f58 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableInsertTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableInsertTest.java
@@ -61,28 +61,6 @@ public JNITableInsertTest(List<Object> value) {
         this.value = value;
     }
 
-    public void verifyRow(Table tbl, long rowIndex, Object[] values) {
-        assertTrue((Boolean) (values[0]) == tbl.getBoolean(0, rowIndex));
-        assertEquals(((Number) values[1]).longValue(), tbl.getLong(1, rowIndex));
-        assertEquals((String) values[2], tbl.getString(2, rowIndex));
-        if (values[3] instanceof byte[])
-            MoreAsserts.assertEquals((byte[]) values[3], tbl.getBinaryByteArray(3, rowIndex));
-        assertEquals(((Date) values[4]).getTime() / 1000, tbl.getDate(4, rowIndex).getTime() / 1000);
-
-        //      Mixed mix1 = Mixed.mixedValue(values[5]);
-        //      Mixed mix2 =  tbl.getMixed(5, rowIndex);
-        // TODO:        assertTrue(mix1.equals(mix2));
-
-        Table subtable = tbl.getSubtable(6, rowIndex);
-        Object[] subValues = (Object[]) values[6];
-        for (long i = 0; i < subtable.size(); i++) {
-            Object[] val = (Object[]) subValues[(int) i];
-            assertTrue(((Number) val[0]).longValue() == subtable.getLong(0, i));
-            assertEquals(((String) val[1]), subtable.getString(1, i));
-        }
-        assertTrue(tbl.isValid());
-    }
-
     @Test
     public void testShouldThrowExceptionWhenColumnNameIsTooLong() {
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableSpecTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableSpecTest.java
deleted file mode 100644
index 8eeb871773..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableSpecTest.java
+++ /dev/null
@@ -1,207 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Date;
-
-import io.realm.RealmFieldType;
-import io.realm.internal.test.ColumnTypeData;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-@RunWith(Parameterized.class)
-public class JNITableSpecTest {
-
-    TableSpec spec, spec2 = new TableSpec();
-    Table table = new Table();
-    ColumnTypeData columnTypeData = new ColumnTypeData(null);
-
-    @Parameterized.Parameters
-    public static Collection<Object[]> parameters() {
-        return Arrays.asList(
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.INTEGER)},
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.FLOAT)},
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.DOUBLE)},
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.BOOLEAN)},
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.STRING)},
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.BINARY)},
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.UNSUPPORTED_MIXED)},
-                new Object[]{new TableSpec(), new TableSpec(), new Table(), new ColumnTypeData(RealmFieldType.UNSUPPORTED_TABLE)}
-        );
-    }
-
-    public JNITableSpecTest(TableSpec spec, TableSpec spec2,
-                            Table table, ColumnTypeData columnTypeData) {
-        this.spec = spec;
-        this.spec2 = spec2;
-        this.table = table;
-        this.columnTypeData = columnTypeData;
-    }
-
-    @Test
-    public void testShouldDefineOneColumnTable() {
-        spec.addColumn(columnTypeData.type, "foo");
-        assertEquals(0, spec.getColumnIndex("foo"));
-        assertEquals(-1, spec.getColumnIndex("xx"));
-
-        spec2.addColumn(columnTypeData.type, "foo");
-        checkSpecIdentity(spec, spec2);
-
-        Table table = new Table();
-        table.updateFromSpec(spec);
-    }
-
-    public void checkSpecIdentity(TableSpec spec, TableSpec spec2) {
-        assertEquals(spec, spec2);
-        assertEquals(spec.hashCode(), spec2.hashCode());
-    }
-
-    @Test
-    public void testShouldDefineTwoColumnsTable() {
-        TableSpec subSpec = spec.addSubtableColumn("bar");
-        subSpec.addColumn(columnTypeData.type, "subbar");
-        assertEquals(0, spec.getColumnIndex("foo"));
-        assertEquals(1, spec.getColumnIndex("bar"));
-        assertEquals(0, subSpec.getColumnIndex("subbar"));
-        assertEquals(-1, subSpec.getColumnIndex("xx"));
-
-        TableSpec subSpec2 = spec2.addSubtableColumn("bar");
-        subSpec2.addColumn(columnTypeData.type, "subbar");
-
-        checkSpecIdentity(spec, spec2);
-        Table table = new Table();
-        table.updateFromSpec(spec);
-    }
-
-    @Test
-    public void testShouldHandleColumnsDynamically() {
-        table.addColumn(RealmFieldType.INTEGER, "0");
-        assertEquals(1, table.getColumnCount());
-        assertEquals(0, table.getColumnIndex("0"));
-        assertEquals("0", table.getColumnName(0));
-        assertEquals(RealmFieldType.INTEGER, table.getColumnType(0));
-        table.add(23);
-
-        table.addColumn(RealmFieldType.FLOAT, "1");
-        table.add(11, 11.1f);
-        table.addColumn(RealmFieldType.DOUBLE, "2");
-        table.add(22, 22.2f, -22.2);
-        table.addColumn(RealmFieldType.BOOLEAN, "3");
-        table.add(33, 33.3f, -33.3, true);
-        table.addColumn(RealmFieldType.STRING, "4");
-        table.add(44, 44.4f, -44.4, true, "44");
-        table.addColumn(RealmFieldType.DATE, "5");
-        Date date = new Date();
-        table.add(55, 55.5f, -55.5, false, "55", date);
-        table.addColumn(RealmFieldType.BINARY, "6");
-        table.add(66, 66.6f, -66.6, false, "66", date, new byte[]{6});
-        table.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "7");
-        table.add(77, 77.7f, -77.7, true, "77", date, new byte[]{7, 7}, "mix");
-        table.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "8");
-        table.add(88, 88.8f, -88.8, false, "88", date, new byte[]{8, 8, 8}, "mixed", null);
-
-        table.addEmptyRows(10);
-        assertEquals(9 + 10, table.size());
-        checkColumnsTest(table);
-        renameColumnsTest(table);
-        removeColumnsTest(table);
-    }
-
-    public void checkColumnsTest(Table table) {
-        // Check columns
-        long columns = 9;
-        assertEquals(columns, table.getColumnCount());
-        for (long i = 0; i < columns; i++) {
-            String name = "" + i;
-            assertEquals(name, table.getColumnName(i));
-            assertEquals(i, table.getColumnIndex(name));
-        }
-    }
-
-    public void renameColumnsTest(Table table) {
-        // Test renameColumn():
-        long columns = 9;
-        for (long i = 0; i < columns; i++)
-            table.renameColumn(i, "New " + i);
-        for (long i = 0; i < columns; i++)
-            assertEquals("New " + i, table.getColumnName(i));
-    }
-
-    public void removeColumnsTest(Table table) {
-        // Test removeColumn():
-        long columns = 9;
-        table.removeColumn(1);
-        assertEquals(columns - 1, table.getColumnCount());
-        assertEquals("New 0", table.getColumnName(0));
-        for (long i = 1; i < columns - 1; i++)
-            assertEquals("New " + (i + 1), table.getColumnName(i));
-        // remove first
-        table.removeColumn(0);
-        assertEquals(columns - 2, table.getColumnCount());
-        for (long i = 0; i < columns - 2; i++)
-            assertEquals("New " + (i + 2), table.getColumnName(i));
-        // remove last
-        table.removeColumn(columns - 3);
-        assertEquals(columns - 3, table.getColumnCount());
-        for (long i = 0; i < columns - 3; i++)
-            assertEquals("New " + (i + 2), table.getColumnName(i));
-        // remove all but "New 4"
-        table.removeColumn(0);
-        table.removeColumn(0);
-        assertEquals(columns - 5, table.getColumnCount());
-        for (long i = 0; i < columns - 6; i++)
-            table.removeColumn(1);
-        assertEquals(1, table.getColumnCount());
-        assertEquals("New 4", table.getColumnName(0));
-        assertEquals("44", table.getString(0, 4));
-    }
-
-    @Test
-    public void testShouldThrowOnUpdateFromTableSpecOnSubtable() {
-        // Table definition
-        Table persons = new Table();
-
-        persons.addColumn(RealmFieldType.STRING, "name");
-        persons.addColumn(RealmFieldType.STRING, "email");
-        persons.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "addresses");
-
-        TableSchema addresses = persons.getSubtableSchema(2);
-        addresses.addColumn(RealmFieldType.STRING, "street");
-        addresses.addColumn(RealmFieldType.INTEGER, "zipcode");
-        addresses.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "phone_numbers");
-
-        persons.add(new Object[]{"Mr X", "xx@xxxx.com", new Object[][]{{"X Street", 1234, null}}});
-
-        Table address = persons.getSubtable(2, 0);
-
-        spec.addColumn(RealmFieldType.INTEGER, "foo");
-
-        try {
-            address.updateFromSpec(spec);
-            fail("Address is subtable. Not allowed to update from spec");
-        } catch (UnsupportedOperationException e) {
-        }
-    }
-}
-
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
index ba83afb0b2..5df16b658b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
@@ -16,30 +16,42 @@
 
 package io.realm.internal;
 
-import android.test.AndroidTestCase;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
-import java.io.File;
 import java.util.Date;
 
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
 import io.realm.RealmFieldType;
-import io.realm.Sort;
 import io.realm.TestHelper;
+import io.realm.rule.TestRealmConfigurationFactory;
 
-public class JNITableTest extends AndroidTestCase {
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertFalse;
+import static junit.framework.Assert.assertNotNull;
+import static junit.framework.Assert.assertNull;
+import static junit.framework.Assert.assertTrue;
+import static junit.framework.Assert.fail;
 
-    Table t;
+@RunWith(AndroidJUnit4.class)
+public class JNITableTest {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
 
-    Table createTestTable() {
-        Table t = new Table();
-        return t;
-    }
+    private Table t;
 
-    @Override
+    @Before
     public void setUp() {
-        t = createTestTable();
+        t = new Table();
     }
 
-    public void testTableToString() {
+    @Test
+    public void tableToString() {
         Table t = new Table();
 
         t.addColumn(RealmFieldType.STRING, "stringCol");
@@ -49,15 +61,12 @@ public void testTableToString() {
         t.add("s1", 1, true);
         t.add("s2", 2, false);
 
-        String expected =
-"    stringCol  intCol  boolCol\n" +
-"0:  s1              1     true\n" +
-"1:  s2              2    false\n" ;
-
+        String expected = "The Table contains 3 columns: stringCol, intCol, boolCol. And 2 rows.";
         assertEquals(expected, t.toString());
     }
 
-    public void testRowOperationsOnZeroRow(){
+    @Test
+    public void rowOperationsOnZeroRow(){
 
         Table t = new Table();
         // Remove rows without columns
@@ -71,7 +80,8 @@ public void testRowOperationsOnZeroRow(){
 
     }
 
-    public void testZeroColOperations() {
+    @Test
+    public void zeroColOperations() {
         Table tableZeroCols = new Table();
 
         // Add rows
@@ -87,25 +97,26 @@ public void testZeroColOperations() {
         try { tableZeroCols.renameColumn(10, "newName");    fail("No columns in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
     }
 
-    public void testFindFirstNonExisting() {
+    @Test
+    public void findFirstNonExisting() {
         Table t = TestHelper.getTableWithAllColumnTypes();
-        t.add(new byte[]{1, 2, 3}, true, new Date(1384423149761l), 4.5d, 5.7f, 100, new Mixed("mixed"), "string", null);
+        t.add(new byte[]{1, 2, 3}, true, new Date(1384423149761L), 4.5d, 5.7f, 100, "string");
 
         assertEquals(-1, t.findFirstBoolean(1, false));
         // FIXME: reenable when core implements find_first_timestamp(): assertEquals(-1, t.findFirstDate(2, new Date(138442314986l)));
         assertEquals(-1, t.findFirstDouble(3, 1.0d));
         assertEquals(-1, t.findFirstFloat(4, 1.0f));
         assertEquals(-1, t.findFirstLong(5, 50));
-        assertEquals(-1, t.findFirstString(7, "other string"));
     }
 
-    public void testFindFirst() {
+    @Test
+    public void findFirst() {
         final int TEST_SIZE = 10;
         Table t = TestHelper.getTableWithAllColumnTypes();
         for (int i = 0; i < TEST_SIZE; i++) {
-            t.add(new byte[]{1,2,3}, true, new Date(i), (double)i, (float)i, i, new Mixed("mixed " + i), "string " + i, null);
+            t.add(new byte[]{1,2,3}, true, new Date(i), (double)i, (float)i, i, "string " + i);
         }
-        t.add(new byte[]{1, 2, 3}, true, new Date(TEST_SIZE), (double) TEST_SIZE, (float) TEST_SIZE, TEST_SIZE, new Mixed("mixed " + TEST_SIZE), "", null);
+        t.add(new byte[]{1, 2, 3}, true, new Date(TEST_SIZE), (double) TEST_SIZE, (float) TEST_SIZE, TEST_SIZE, "");
 
         assertEquals(0, t.findFirstBoolean(1, true));
         for (int i = 0; i < TEST_SIZE; i++) {
@@ -113,13 +124,10 @@ public void testFindFirst() {
             assertEquals(i, t.findFirstDouble(3, (double) i));
             assertEquals(i, t.findFirstFloat(4, (float) i));
             assertEquals(i, t.findFirstLong(5, i));
-            assertEquals(i, t.findFirstString(7, "string " + i));
         }
 
-        assertEquals(TEST_SIZE, t.findFirstString(7, ""));
-
         try {
-            t.findFirstString(7, null);
+            t.findFirstString(6, null);
             fail();
         } catch (IllegalArgumentException ignored) {}
 
@@ -129,8 +137,8 @@ public void testFindFirst() {
         } catch (IllegalArgumentException ignored) {}
     }
 
-
-    public void testGetValuesFromNonExistingColumn() {
+    @Test
+    public void getValuesFromNonExistingColumn() {
         Table t = TestHelper.getTableWithAllColumnTypes();
         t.addEmptyRows(10);
 
@@ -158,21 +166,13 @@ public void testGetValuesFromNonExistingColumn() {
         try { t.getLong(-10, 0);                    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
         try { t.getLong(9, 0);                      fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
 
-        try { t.getMixed(-1, 0);                    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getMixed(-10, 0);                   fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getMixed(9, 0);                     fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-
         try { t.getString(-1, 0);                   fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
         try { t.getString(-10, 0);                  fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
         try { t.getString(9, 0);                    fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-
-        try { t.getSubtable(-1, 0);                 fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getSubtable(-10, 0);                fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getSubtable(9, 0);                  fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-
     }
 
-    public void testGetNonExistingColumn() {
+    @Test
+    public void getNonExistingColumn() {
         Table t = new Table();
         t.addColumn(RealmFieldType.INTEGER, "int");
 
@@ -180,152 +180,45 @@ public void testGetNonExistingColumn() {
         try { t.getColumnIndex(null); fail("column name null"); } catch (IllegalArgumentException ignored) { }
     }
 
-
-    public void testGetSortedView() {
-        Table t = new Table();
-        t.addColumn(RealmFieldType.INTEGER, "");
-        t.addColumn(RealmFieldType.STRING, "");
-        t.addColumn(RealmFieldType.DOUBLE, "");
-
-        t.add(1, "s", 1000d);
-        t.add(3,"sss", 10d);
-        t.add(2, "ss", 100d);
-
-
-        // Check the order is as it is added
-        assertEquals(1, t.getLong(0, 0));
-        assertEquals(3, t.getLong(0, 1));
-        assertEquals(2, t.getLong(0, 2));
-        assertEquals("s", t.getString(1, 0));
-        assertEquals("sss", t.getString(1, 1));
-        assertEquals("ss", t.getString(1, 2));
-        assertEquals(1000d, t.getDouble(2, 0));
-        assertEquals(10d, t.getDouble(2, 1));
-        assertEquals(100d, t.getDouble(2, 2));
-
-        // Get the sorted view on first column
-        TableView v = t.getSortedView(0);
-
-        // Check the new order
-        assertEquals(1, v.getLong(0, 0));
-        assertEquals(2, v.getLong(0, 1));
-        assertEquals(3, v.getLong(0, 2));
-        assertEquals("s", v.getString(1, 0));
-        assertEquals("ss", v.getString(1, 1));
-        assertEquals("sss", v.getString(1, 2));
-        assertEquals(1000d, v.getDouble(2, 0));
-        assertEquals(100d, v.getDouble(2, 1));
-        assertEquals(10d, v.getDouble(2, 2));
-
-        // Get the sorted view on first column descending
-        v = t.getSortedView(0, Sort.DESCENDING);
-
-        // Check the new order
-        assertEquals(3, v.getLong(0, 0));
-        assertEquals(2, v.getLong(0, 1));
-        assertEquals(1, v.getLong(0, 2));
-        assertEquals("sss", v.getString(1, 0));
-        assertEquals("ss", v.getString(1, 1));
-        assertEquals("s", v.getString(1, 2));
-        assertEquals(10d, v.getDouble(2, 0));
-        assertEquals(100d, v.getDouble(2, 1));
-        assertEquals(1000d, v.getDouble(2, 2));
-
-        // Some out of bounds test cases
-        try { t.getSortedView(-1, Sort.DESCENDING);    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getSortedView(-100, Sort.DESCENDING);  fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getSortedView(100, Sort.DESCENDING);   fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-
-    }
-
-    public void testSetNulls() {
+    @Test
+    public void setNulls() {
         Table t = new Table();
         t.addColumn(RealmFieldType.STRING, "");
         t.addColumn(RealmFieldType.DATE, "");
-        t.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "");
         t.addColumn(RealmFieldType.BINARY, "");
-        t.add("String val", new Date(), new Mixed(""), new byte[]{1, 2, 3});
+        t.add("String val", new Date(), new byte[]{1, 2, 3});
 
         try { t.setString(0, 0, null);  fail("null string not allowed"); } catch (IllegalArgumentException ignored) { }
         try { t.setDate(1, 0, null);    fail("null Date not allowed"); } catch (IllegalArgumentException ignored) { }
     }
 
-    public void testAddNegativeEmptyRows() {
+    @Test
+    public void addNegativeEmptyRows() {
         Table t = new Table();
         t.addColumn(RealmFieldType.STRING, "colName");
 
         try { t.addEmptyRows(-1); fail("Argument is negative"); } catch (IllegalArgumentException ignored) { }
     }
 
-    public void testAddNullInMixedColumn() {
-        Table t = new Table();
-        t.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "mixed");
-        t.add(new Mixed(true));
-
-        try { t.setMixed(0, 0, null); fail("Argument is null"); } catch (IllegalArgumentException ignored) { }
-    }
-
-    public void testImmutableInsertNotAllowed() {
-
-        String FILENAME = new File(this.getContext().getFilesDir(), "only-test-file.realm").toString();
-        String TABLENAME = "tableName";
-
-        new File(FILENAME).delete();
-        new File(FILENAME+".lock").delete();
-        SharedGroup group = new SharedGroup(FILENAME);
-
-        // Write transaction must be run so we are sure a db exists with the correct table
-        WriteTransaction wt = group.beginWrite();
-        try {
-            Table table = wt.getTable(TABLENAME);
-            table.addColumn(RealmFieldType.STRING, "col0");
-            table.add("value0");
-            table.add("value1");
-            table.add("value2");
-
-            wt.commit();
-        } catch (Throwable t) {
-            wt.rollback();
-        }
-
-        ReadTransaction rt = group.beginRead();
-        try {
-            Table table = rt.getTable(TABLENAME);
-
-            try {
-                table.addEmptyRow();
-                fail("Exception expected when inserting in read transaction");
-            } catch (IllegalStateException ignored) {
-            }
-
-        } finally {
-            rt.endRead();
-        }
-    }
-
-    public void testGetName() {
-        String FILENAME = new File(this.getContext().getFilesDir(), "only-test-file.realm").toString();
-        String TABLENAME = "tableName";
+    @Test
+    public void getName() {
+        String TABLE_NAME = "tableName";
+        RealmConfiguration configuration = configFactory.createConfiguration();
+        Realm.deleteRealm(configuration);
 
-        new File(FILENAME).delete();
-        new File(FILENAME+".lock").delete();
-        SharedGroup group = new SharedGroup(FILENAME);
+        SharedRealm sharedRealm = SharedRealm.getInstance(configuration);
 
         // Write transaction must be run so we are sure a db exists with the correct table
-        WriteTransaction wt = group.beginWrite();
-        try {
-            wt.getTable(TABLENAME);
-            wt.commit();
-        } catch (Throwable t) {
-            wt.rollback();
-        }
+        sharedRealm.beginTransaction();
+        sharedRealm.getTable(TABLE_NAME);
+        sharedRealm.commitTransaction();
 
-        ReadTransaction rt = group.beginRead();
-        Table table = rt.getTable(TABLENAME);
-        assertEquals(TABLENAME, table.getName());
+        Table table = sharedRealm.getTable(TABLE_NAME);
+        assertEquals(TABLE_NAME, table.getName());
     }
 
-    public void testShouldThrowWhenSetIndexOnWrongRealmFieldType() {
+    @Test
+    public void shouldThrowWhenSetIndexOnWrongRealmFieldType() {
         for (long colIndex = 0; colIndex < t.getColumnCount(); colIndex++) {
 
             // All types supported addSearchIndex and removeSearchIndex
@@ -360,13 +253,15 @@ public void testShouldThrowWhenSetIndexOnWrongRealmFieldType() {
         }
     }
 
-    public void testColumnName() {
+    @Test
+    public void columnName() {
         Table t = new Table();
         try { t.addColumn(RealmFieldType.STRING, "I am 64 characters.............................................."); fail("Only 63 characters supported"); } catch (IllegalArgumentException ignored) { }
         t.addColumn(RealmFieldType.STRING, "I am 63 characters.............................................");
     }
 
-    public void testTableNumbers() {
+    @Test
+    public void tableNumbers() {
         Table t = new Table();
         t.addColumn(RealmFieldType.INTEGER, "intCol");
         t.addColumn(RealmFieldType.DOUBLE, "doubleCol");
@@ -412,7 +307,8 @@ public void testTableNumbers() {
         assertEquals(3000.0f, t.getFloat(2, 5));
     }
 
-    public void testMaximumDate() {
+    @Test
+    public void maximumDate() {
 
         Table table = new Table();
         table.addColumn(RealmFieldType.DATE, "date");
@@ -425,7 +321,8 @@ public void testMaximumDate() {
 
     }
 
-    public void testMinimumDate() {
+    @Test
+    public void minimumDate() {
 
         Table table = new Table();
         table.addColumn(RealmFieldType.DATE, "date");
@@ -439,7 +336,8 @@ public void testMinimumDate() {
     }
 
     // testing the migration of a string column to be nullable.
-    public void testConvertToNullable() {
+    @Test
+    public void convertToNullable() {
         RealmFieldType[] columnTypes = {RealmFieldType.BOOLEAN, RealmFieldType.DATE, RealmFieldType.DOUBLE,
                 RealmFieldType.FLOAT, RealmFieldType.INTEGER, RealmFieldType.BINARY, RealmFieldType.STRING};
         for (RealmFieldType columnType : columnTypes) {
@@ -514,7 +412,8 @@ public void testConvertToNullable() {
         }
     }
 
-    public void testConvertToNotNullable() {
+    @Test
+    public void convertToNotNullable() {
         RealmFieldType[] columnTypes = {RealmFieldType.BOOLEAN, RealmFieldType.DATE, RealmFieldType.DOUBLE,
                 RealmFieldType.FLOAT, RealmFieldType.INTEGER, RealmFieldType.BINARY, RealmFieldType.STRING};
         for (RealmFieldType columnType : columnTypes) {
@@ -604,19 +503,9 @@ else if (columnType == RealmFieldType.INTEGER)
         }
     }
 
-    // migrating an mixed column to be nullable is not supported
-    public void testConvertMixedToNullable() {
-        Table table = new Table();
-        table.addColumn(RealmFieldType.UNSUPPORTED_MIXED, "mixed", Table.NOT_NULLABLE);
-        try {
-            table.convertColumnToNullable(0);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
     // add column and read back if it is nullable or not
-    public void testIsNullable() {
+    @Test
+    public void isNullable() {
         Table table = new Table();
         table.addColumn(RealmFieldType.STRING, "string1", Table.NOT_NULLABLE);
         table.addColumn(RealmFieldType.STRING, "string2", Table.NULLABLE);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java
deleted file mode 100644
index 0f0631baa2..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITransactions.java
+++ /dev/null
@@ -1,454 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
-
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.List;
-
-import io.realm.Realm;
-import io.realm.RealmFieldType;
-import io.realm.exceptions.RealmException;
-import io.realm.exceptions.RealmPrimaryKeyConstraintException;
-import io.realm.rule.TestRealmConfigurationFactory;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-@RunWith(AndroidJUnit4.class)
-public class JNITransactions {
-
-    @Rule
-    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
-
-    private String testFile;
-    private android.content.Context context;
-
-    @Before
-    public void setUp() throws Exception {
-        testFile = new File(
-                configFactory.getRoot(),
-                System.currentTimeMillis() + "_transact.realm").getAbsolutePath();
-        context = InstrumentationRegistry.getInstrumentation().getContext();
-        RealmCore.loadLibrary(context);
-    }
-
-    private Table getTableWithStringPrimaryKey() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-        WriteTransaction trans = db.beginWrite();
-        Table t = trans.getTable("TestTable");
-        t.addColumn(RealmFieldType.STRING, "colName", true);
-        t.setPrimaryKey("colName");
-        return t;
-    }
-
-    private Table getTableWithIntegerPrimaryKey() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-        WriteTransaction trans = db.beginWrite();
-        Table t = trans.getTable("TestTable");
-        t.addColumn(RealmFieldType.INTEGER, "colName");
-        t.setPrimaryKey("colName");
-        return t;
-    }
-
-    protected void writeOneTransaction(SharedGroup db, long rows) {
-        WriteTransaction trans = db.beginWrite();
-        Table tbl = trans.getTable("EmployeeTable");
-        tbl.addColumn(RealmFieldType.STRING, "name");
-        tbl.addColumn(RealmFieldType.INTEGER, "number");
-
-
-        for (long row=0; row < rows; row++)
-            tbl.add("Hi", 1);
-        assertEquals(rows, tbl.size());
-        trans.commit();
-
-        // must throw exception as table is invalid now.
-        try {
-            assertEquals(1, tbl.size());
-            fail();
-        } catch (IllegalStateException e) {
-            assertNotNull(e);
-        }
-
-    }
-
-    protected void checkRead(SharedGroup db, int rows) {
-        // Read transaction
-        ReadTransaction trans = db.beginRead();
-        Table tbl = trans.getTable("EmployeeTable");
-        assertEquals(true, tbl.isValid());
-        assertEquals(rows, tbl.size());
-        trans.endRead();
-    }
-
-    // TODO: tests should be done both for all Durability options
-
-    @Test
-    public void mustWriteAndReadEmpty() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-        writeOneTransaction(db, 0);
-        checkRead(db, 0);
-    }
-
-    @Test
-    public void mustWriteCommit() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-        writeOneTransaction(db, 10);
-        checkRead(db, 10);
-    }
-
-    @Test
-    public void shouldThrowExceptionAfterClosedReadTransaction() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-        writeOneTransaction(db, 10);
-        ReadTransaction rt = db.beginRead();
-
-        try {
-            Table tbl = rt.getTable("EmployeeTable");
-            rt.endRead();
-            try {
-                tbl.getColumnCount(); //Should throw exception, the table is invalid when transaction has been closed
-                fail();
-            } catch (IllegalStateException ignored) {
-            }
-        } finally {
-            rt.endRead();
-        }
-    }
-
-    @Test
-    public void shouldThrowExceptionAfterClosedReadTransactionWhenWriting() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-        writeOneTransaction(db, 10);
-        ReadTransaction rt = db.beginRead();
-
-        try {
-            Table tbl = rt.getTable("EmployeeTable");
-            rt.endRead();
-            try {
-                tbl.addColumn(RealmFieldType.STRING, "newString"); //Should throw exception, as adding a column is not allowed in read transaction
-                fail();
-            } catch (IllegalStateException e) {
-                //assertNotNull(e);
-            }
-        } finally {
-            rt.endRead();
-        }
-    }
-
-    @Test
-    public void shouldThrowExceptionWhenWritingInReadTrans() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-        ReadTransaction rt = db.beginRead();
-
-        try {
-            try {
-                rt.getTable("newTable");  //Should throw exception, as this method creates a new table, if the table does not exists, thereby making it a mutable operation
-                fail();
-            } catch (IllegalStateException e) {
-                assertNotNull(e);
-            }
-        } finally {
-            rt.endRead();
-        }
-    }
-
-    @Test
-    public void onlyOneCommit() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-        WriteTransaction trans = db.beginWrite();
-
-        try {
-            Table tbl = trans.getTable("EmployeeTable");
-            tbl.addColumn(RealmFieldType.STRING, "name");
-            trans.commit();
-            try {
-                trans.commit(); // should throw
-                fail();
-            } catch (IllegalStateException e){
-                assertNotNull(e);
-            }
-
-        } catch (Throwable t){
-            trans.rollback();
-        }
-    }
-
-    @Test
-    public void mustRollback() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-        writeOneTransaction(db, 1);
-        WriteTransaction trans = db.beginWrite();
-        Table tbl = trans.getTable("EmployeeTable");
-
-        tbl.add("Hello", 1);
-        assertEquals(2, tbl.size());
-        trans.rollback();
-
-        checkRead(db, 1); // Only 1 row now.
-    }
-
-    @Test
-    public void mustAllowDoubleCommitAndRollback() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-        {
-            WriteTransaction trans = db.beginWrite();
-            Table tbl = trans.getTable("EmployeeTable");
-            tbl.addColumn(RealmFieldType.STRING, "name");
-            tbl.addColumn(RealmFieldType.INTEGER, "number");
-
-            // allow commit before any changes
-            assertEquals(0, tbl.size());
-            tbl.add("Hello", 1);
-            trans.commit();
-        }
-        {
-            WriteTransaction trans = db.beginWrite();
-            Table tbl = trans.getTable("EmployeeTable");
-            // allow double rollback
-            tbl.add("Hello", 2);
-            assertEquals(2, tbl.size());
-            trans.rollback();
-            trans.rollback();
-            trans.rollback();
-            trans.rollback();
-        }
-        {
-            ReadTransaction trans = db.beginRead();
-            Table tbl = trans.getTable("EmployeeTable");
-            assertEquals(1, tbl.size());
-            trans.endRead();
-        }
-    }
-
-    // TODO:
-    // Test: exception at all mutable methods in TableBase, TableView,
-    // Test: above in custom Typed Tables
-    // TableQuery.... in ReadTransactions
-
-    @Test
-    public void mustFailOnWriteInReadTransactions() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-
-        writeOneTransaction(db, 1);
-
-        ReadTransaction t = db.beginRead();
-        Table table = t.getTable("EmployeeTable");
-
-        try { table.addEmptyRow();                  fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.addEmptyRows(1);                fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.clear();                        fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.clearSubtable(0,0);             fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.optimize();                     fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.remove(0);                      fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.removeLast();                   fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.setBinaryByteArray(0,0,null);   fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.setBoolean(0,0,false);          fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.setDate(0,0,new Date(0));       fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.addSearchIndex(0);              fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.setLong(0,0,0);                 fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.setMixed(0,0,null);             fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.setString(0,0,"");              fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { table.updateFromSpec(null);           fail();} catch (IllegalStateException e) {assertNotNull(e);}
-
-        TableQuery q = table.where();
-        try { q.remove();                           fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { q.remove(0,0);                        fail();} catch (IllegalStateException e) {assertNotNull(e);}
-
-        TableView v = q.findAll();
-        try { v.clear();                            fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { v.clearSubtable(0, 0);                fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { v.remove(0);                          fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { v.removeLast();                       fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { v.setBinaryByteArray(0, 0, null);     fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { v.setBoolean(0, 0, false);            fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { v.setDate(0, 0, new Date());          fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { v.setLong(0, 0, 0);                   fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { v.setString(0,0,"");                  fail();} catch (IllegalStateException e) {assertNotNull(e);}
-        try { v.setMixed(0, 0, null);               fail();} catch (IllegalStateException e) {assertNotNull(e);}
-
-        t.endRead();
-    }
-
-    // Test that primary key constraints are actually removed
-    @Test
-    public void removingPrimaryKeyRemovesConstraint() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-
-        WriteTransaction trans = db.beginWrite();
-        Table tbl = trans.getTable("EmployeeTable");
-        tbl.addColumn(RealmFieldType.STRING, "name");
-        tbl.addColumn(RealmFieldType.INTEGER, "number");
-        tbl.setPrimaryKey("name");
-
-        tbl.add("Foo", 42);
-        try {
-            tbl.add("Foo", 41);
-        } catch (RealmPrimaryKeyConstraintException e1) {
-            // Primary key check worked, now remove it and try again.
-            tbl.setPrimaryKey("");
-            try {
-                tbl.add("Foo", 41);
-                return;
-            } catch (RealmException e2) {
-                fail("Primary key not removed");
-            }
-        }
-
-        fail("Primary key not enforced.");
-    }
-
-    // Test that primary key constraints are actually removed
-    @Test
-    public void removingPrimaryKeyRemovesConstraint_typeSetters() {
-        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
-
-        WriteTransaction trans = db.beginWrite();
-        Table tbl = trans.getTable("EmployeeTable");
-        tbl.addColumn(RealmFieldType.STRING, "name");
-        tbl.setPrimaryKey("name");
-
-        // Create first entry with name "foo"
-        tbl.setString(0, tbl.addEmptyRow(), "Foo");
-
-        long rowIndex = tbl.addEmptyRow();
-        try {
-            tbl.setString(0, rowIndex, "Foo"); // Try to create 2nd entry with name Foo
-        } catch (RealmPrimaryKeyConstraintException e1) {
-            tbl.setPrimaryKey(""); // Primary key check worked, now remove it and try again.
-            try {
-                tbl.setString(0, rowIndex, "Foo");
-                return;
-            } catch (RealmException e2) {
-                fail("Primary key not removed");
-            }
-        }
-
-        fail("Primary key not enforced.");
-    }
-
-    @Test
-    public void addEmptyRowWithPrimaryKeyWrongTypeStringThrows() {
-        Table t = getTableWithStringPrimaryKey();
-        try {
-            t.addEmptyRowWithPrimaryKey(42);
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void addEmptyRowWithPrimaryKeyNullString() {
-        Table t = getTableWithStringPrimaryKey();
-        t.addEmptyRowWithPrimaryKey(null);
-        assertEquals(1, t.size());
-    }
-
-    @Test
-    public void addEmptyRowWithPrimaryKeyWrongTypeIntegerThrows() {
-        Table t = getTableWithIntegerPrimaryKey();
-        try {
-            t.addEmptyRowWithPrimaryKey("Foo");
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void addEmptyRowWithPrimaryKeyString() {
-        Table t = getTableWithStringPrimaryKey();
-        long rowIndex = t.addEmptyRowWithPrimaryKey("Foo");
-        assertEquals(1, t.size());
-        assertEquals("Foo", t.getUncheckedRow(rowIndex).getString(0));
-    }
-
-    @Test
-    public void addEmptyRowWithPrimaryKeyLong() {
-        Table t = getTableWithIntegerPrimaryKey();
-        long rowIndex = t.addEmptyRowWithPrimaryKey(42);
-        assertEquals(1, t.size());
-        assertEquals(42, t.getUncheckedRow(rowIndex).getLong(0));
-    }
-
-    @Test
-    public void firstPrimaryKeyTableMigration() throws IOException {
-        configFactory.copyRealmFromAssets(context, "080_annotationtypes.realm", "default.realm");
-        SharedGroup db = new SharedGroup(new File(configFactory.getRoot(),
-                Realm.DEFAULT_REALM_NAME).getAbsolutePath(), SharedGroup.Durability.FULL, null);
-        ImplicitTransaction tr = db.beginImplicitTransaction();
-        Table t = tr.getTable("class_AnnotationTypes");
-        assertEquals(t.getColumnIndex("id"), t.getPrimaryKey());
-        assertTrue(t.hasPrimaryKey());
-        assertEquals(RealmFieldType.STRING, tr.getTable("pk").getColumnType(0));
-        db.close();
-    }
-
-    @Test
-    public void secondPrimaryKeyTableMigration() throws IOException {
-        configFactory.copyRealmFromAssets(context, "0841_annotationtypes.realm", "default.realm");
-        SharedGroup db = new SharedGroup(new File(configFactory.getRoot(),
-                Realm.DEFAULT_REALM_NAME).getAbsolutePath(), SharedGroup.Durability.FULL, null);
-        ImplicitTransaction tr = db.beginImplicitTransaction();
-        Table t = tr.getTable("class_AnnotationTypes");
-        assertEquals(t.getColumnIndex("id"), t.getPrimaryKey());
-        assertTrue(t.hasPrimaryKey());
-        assertEquals("AnnotationTypes", tr.getTable("pk").getString(0, 0));
-        db.close();
-    }
-
-    // See https://github.com/realm/realm-java/issues/1775 .
-    // Before 0.84.2, pk table added prefix "class_" to every class's name.
-    // After 0.84.2, the pk table should be migrated automatically to remove the "class_".
-    // In 0.84.2, the class names in pk table has been renamed to some incorrect names like "Thclass", "Mclass",
-    // "NClass", "Meclass" and etc..
-    // The 0841_pk_migration.realm is made to produce the issue.
-    @Test
-    public void primaryKeyTableMigratedWithRightName() throws IOException {
-        List<String> tableNames = Arrays.asList(
-                "ChatList", "Drafts", "Member", "Message", "Notifs", "NotifyLink", "PopularPost",
-                "Post", "Tags", "Threads", "User");
-
-        configFactory.copyRealmFromAssets(context, "0841_pk_migration.realm", "default.realm");
-        SharedGroup db = new SharedGroup(new File(configFactory.getRoot(),
-                Realm.DEFAULT_REALM_NAME).getAbsolutePath(), SharedGroup.Durability.FULL, null);
-
-        ImplicitTransaction tr = db.beginImplicitTransaction();
-        // To trigger migratePrimaryKeyTableIfNeeded.
-        tr.getTable("class_ChatList").getPrimaryKey();
-
-        Table table =  tr.getTable("pk");
-        for (int i = 0; i < table.size(); i++) {
-            UncheckedRow row = table.getUncheckedRow(i);
-            // io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX 0LL
-            assertTrue(tableNames.contains(row.getString(0)));
-        }
-        db.close();
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
index fb058944aa..9a3d5669e7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
@@ -43,15 +43,11 @@ public void setUp() {
         t.addColumn(RealmFieldType.INTEGER,    "Age");
         t.addColumn(RealmFieldType.DATE,   "Birthday");
 
-        // Add unsupported column types
-        t.addColumn(RealmFieldType.UNSUPPORTED_MIXED,  "Unsupported3");
-        t.addColumn(RealmFieldType.UNSUPPORTED_TABLE,  "Unsupported4");
-
         //Add data
-        t.add("cc", true,  24, date1, 0, null);
-        t.add("dd", false, 35, date2, 0, null);
-        t.add("bb", true,  22, date3, 0, null);
-        t.add("aa", false, 22, date4, 0, null);
+        t.add("cc", true,  24, date1);
+        t.add("dd", false, 35, date2);
+        t.add("bb", true,  22, date3);
+        t.add("aa", false, 22, date4);
 
         assertEquals(date1, t.getDate(3, 0));
         assertEquals(date2, t.getDate(3, 1));
@@ -140,39 +136,6 @@ public void testSetBinary() {
         MoreAsserts.assertEquals(arr2, view.getBinaryByteArray(0, 0));
     }
 
-
-    public void testSubtable() {
-        Table persons = new Table();
-        persons.addColumn(RealmFieldType.STRING, "name");
-        persons.addColumn(RealmFieldType.STRING, "email");
-        persons.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "addresses");
-
-        TableSchema addresses = persons.getSubtableSchema(2);
-        addresses.addColumn(RealmFieldType.STRING, "street");
-        addresses.addColumn(RealmFieldType.INTEGER, "zipcode");
-        addresses.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "phone_numbers");
-
-        TableSchema phone_numbers = addresses.getSubtableSchema(2);
-        phone_numbers.addColumn(RealmFieldType.INTEGER, "number");
-
-        // Inserting data
-        persons.add("Mr X", "xx@xxxx.com",
-                new Object[][] { { "X Street", 1234, new Object[][] {{ 12345678 }} },
-                                 { "Y Street", 1234, new Object[][] {{ 12345678 }} }
-                               });
-
-        TableView personsView = persons.where().findAll();
-
-        assertEquals(2, personsView.getSubtableSize(2, 0));
-
-        Table address = personsView.getSubtable(2, 0);
-        assertEquals(2, address.size());
-        assertEquals(3, address.getColumnCount());
-
-        personsView.clearSubtable(2, 0);
-        assertEquals(0, personsView.getSubtableSize(2, 0));
-    }
-
     public void testSortOnNonexistingColumn() {
         TableView view = t.where().findAll();
 
@@ -184,7 +147,7 @@ public void testSortOnNonexistingColumn() {
 
     public void testFindFirstNonExisting() {
         Table tt = TestHelper.getTableWithAllColumnTypes();
-        tt.add(new byte[]{1,2,3}, true, new Date(1384423149761l), 4.5d, 5.7f, 100, new Mixed("mixed"), "string", null);
+        tt.add(new byte[]{1,2,3}, true, new Date(1384423149761l), 4.5d, 5.7f, 100, "string");
         TableView v = tt.where().findAll();
 
         assertEquals(-1, v.findFirstBoolean(1, false));
@@ -192,7 +155,6 @@ public void testFindFirstNonExisting() {
         assertEquals(-1, v.findFirstDouble(3, 1.0d));
         assertEquals(-1, v.findFirstFloat(4, 1.0f));
         assertEquals(-1, v.findFirstLong(5, 50));
-        assertEquals(-1, v.findFirstString(7, "other string"));
     }
 
 
@@ -224,17 +186,9 @@ public void testGetValuesFromNonExistingColumn() {
         try { view.getLong(-10, 0);             fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getLong(100, 0);             fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
 
-        try { view.getMixed(-1, 0);             fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getMixed(-10, 0);            fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getMixed(100, 0);            fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-
         try { view.getString(-1, 0);            fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getString(-10, 0);           fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
         try { view.getString(100, 0);           fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-
-        try { view.getSubtable(-1, 0);          fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getSubtable(-10, 0);         fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getSubtable(100, 0);         fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
     }
 
 
@@ -300,20 +254,6 @@ public void testShouldSortViewBool() {
         assertEquals("bb", view.getString(0, 3));
     }
 
-
-
-    public void testShouldThrowExceptionForUnsupportedColumns() {
-        TableView view = t.where().findAll();
-        long colIndex;
-        for (colIndex = 4; colIndex <= 5; colIndex++) {
-            try {
-                view.sort(colIndex); // Must throw for invalid column types
-                fail("expected exception.");
-            } catch (IllegalArgumentException e) {
-            }
-        }
-    }
-
     public void testShouldSearchByColumnValue() {
         Table table = new Table();
         table.addColumn(RealmFieldType.STRING, "name");
@@ -375,10 +315,7 @@ public void testViewToString() {
 
         TableView view = t.where().findAll();
 
-        String expected =
-                "    stringCol  intCol  boolCol\n" +
-                        "0:  s1              1     true\n" +
-                        "1:  s2              2    false\n" ;
+        String expected = "The TableView contains 3 columns: stringCol, intCol, boolCol. And 2 rows.";
 
         assertEquals(expected, view.toString());
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java
index 6b5aa39009..1ee36c4c23 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java
@@ -59,27 +59,4 @@ public void testPivotTable(){
         try { t.pivot(colIndexHired, colIndexAge, PivotType.SUM); fail("Group by not a String column"); } catch (UnsupportedOperationException e) { }
         try { t.pivot(colIndexSex, colIndexHired, PivotType.SUM); fail("Aggregation not an int column"); } catch (UnsupportedOperationException e) { }
     }
-
-
-    public void testPivotTableView(){
-
-        TableView view = t.getSortedView(colIndexAge);
-
-        Table resultCount = view.pivot(colIndexSex, colIndexAge, PivotType.COUNT);
-        assertEquals(2, resultCount.size());
-        assertEquals(25000, resultCount.getLong(1, 0));
-        assertEquals(25000, resultCount.getLong(1, 1));
-
-        Table resultMin = view.pivot(colIndexSex, colIndexAge, PivotType.MIN);
-        assertEquals(20, resultMin.getLong(1, 0));
-        assertEquals(21, resultMin.getLong(1, 1));
-
-        Table resultMax = view.pivot(colIndexSex, colIndexAge, PivotType.MAX);
-        assertEquals(38, resultMax.getLong(1, 0));
-        assertEquals(39, resultMax.getLong(1, 1));
-
-
-        try { view.pivot(colIndexHired, colIndexAge, PivotType.SUM); fail("Group by not a String column"); } catch (UnsupportedOperationException e) { }
-        try { view.pivot(colIndexSex, colIndexHired, PivotType.SUM); fail("Aggregation not an int column"); } catch (UnsupportedOperationException e) { }
-    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
new file mode 100644
index 0000000000..9dab44e638
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
@@ -0,0 +1,234 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+
+import io.realm.RealmConfiguration;
+import io.realm.exceptions.RealmError;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertFalse;
+import static junit.framework.Assert.assertTrue;
+
+@RunWith(AndroidJUnit4.class)
+public class SharedRealmTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private RealmConfiguration config;
+    private SharedRealm sharedRealm;
+
+    @Before
+    public void setUp() {
+        config = configFactory.createConfiguration();
+        sharedRealm = SharedRealm.getInstance(config);
+    }
+
+    @After
+    public void tearDown() {
+        sharedRealm.close();
+    }
+
+    @Test
+    public void getVersionID() {
+        SharedRealm.VersionID versionID1 = sharedRealm.getVersionID();
+        sharedRealm.beginTransaction();
+        sharedRealm.commitTransaction();
+        SharedRealm.VersionID versionID2 = sharedRealm.getVersionID();
+        assertFalse(versionID1.equals(versionID2));
+    }
+
+    @Test
+    public void hasTable() {
+        assertFalse(sharedRealm.hasTable("MyTable"));
+        sharedRealm.beginTransaction();
+        sharedRealm.getTable("MyTable");
+        sharedRealm.commitTransaction();
+        assertTrue(sharedRealm.hasTable("MyTable"));
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void getTable_createNotInTransactionThrows() {
+        sharedRealm.getTable("NON-EXISTING");
+    }
+
+    @Test
+    public void getTable() {
+        assertFalse(sharedRealm.hasTable("MyTable"));
+        sharedRealm.beginTransaction();
+        sharedRealm.getTable("MyTable");
+        sharedRealm.commitTransaction();
+        assertTrue(sharedRealm.hasTable("MyTable"));
+
+        // Table is existing, no need transaction to create it
+        sharedRealm.getTable("MyTable");
+    }
+
+    @Test
+    public void isInTransaction() {
+        assertFalse(sharedRealm.isInTransaction());
+        sharedRealm.beginTransaction();
+        assertTrue(sharedRealm.isInTransaction());
+        sharedRealm.cancelTransaction();
+        assertFalse(sharedRealm.isInTransaction());
+    }
+
+    @Test
+    public void removeTable() {
+        sharedRealm.beginTransaction();
+        sharedRealm.getTable("TableToRemove");
+        assertTrue(sharedRealm.hasTable("TableToRemove"));
+        sharedRealm.removeTable("TableToRemove");
+        assertFalse(sharedRealm.hasTable("TableToRemove"));
+        sharedRealm.commitTransaction();
+    }
+
+    @Test
+    public void removeTable_notInTransactionThrows() {
+        sharedRealm.beginTransaction();
+        sharedRealm.getTable("TableToRemove");
+        sharedRealm.commitTransaction();
+        thrown.expect(IllegalStateException.class);
+        sharedRealm.removeTable("TableToRemove");
+    }
+
+    @Test
+    public void removeTable_tableNotExist() {
+        sharedRealm.beginTransaction();
+        assertFalse(sharedRealm.hasTable("TableToRemove"));
+        thrown.expect(RealmError.class);
+        sharedRealm.removeTable("TableToRemove");
+        sharedRealm.cancelTransaction();
+    }
+
+    @Test
+    public void renameTable() {
+        sharedRealm.beginTransaction();
+        sharedRealm.getTable("OldTable");
+        assertTrue(sharedRealm.hasTable("OldTable"));
+        sharedRealm.renameTable("OldTable", "NewTable");
+        assertFalse(sharedRealm.hasTable("OldTable"));
+        assertTrue(sharedRealm.hasTable("NewTable"));
+        sharedRealm.commitTransaction();
+    }
+
+    @Test
+    public void renameTable_notInTransactionThrows() {
+        sharedRealm.beginTransaction();
+        sharedRealm.getTable("OldTable");
+        sharedRealm.commitTransaction();
+        thrown.expect(IllegalStateException.class);
+        sharedRealm.renameTable("OldTable", "NewTable");
+    }
+
+    @Test
+    public void renameTable_tableNotExist() {
+        sharedRealm.beginTransaction();
+        assertFalse(sharedRealm.hasTable("TableToRemove"));
+        thrown.expect(RealmError.class);
+        sharedRealm.renameTable("TableToRemove", "newName");
+        sharedRealm.cancelTransaction();
+    }
+
+    @Test
+    public void beginTransaction_SchemaVersionListener() {
+        final AtomicBoolean listenerCalled = new AtomicBoolean(false);
+        final AtomicLong schemaVersionFromListener = new AtomicLong(-1L);
+
+        sharedRealm.close();
+        sharedRealm = SharedRealm.getInstance(config, null, new SharedRealm.SchemaVersionListener() {
+            @Override
+            public void onSchemaVersionChanged(long currentVersion) {
+                listenerCalled.set(true);
+                schemaVersionFromListener.set(currentVersion);
+            }
+        });
+
+        final long before = sharedRealm.getSchemaVersion();
+
+        sharedRealm.beginTransaction();
+        try {
+            // listener is not called if there was no schema change
+            assertFalse(listenerCalled.get());
+
+            // change the schema version
+            sharedRealm.setSchemaVersion(before + 1);
+        } finally {
+            sharedRealm.commitTransaction();
+        }
+
+        // listener is not yet called
+        assertFalse(listenerCalled.get());
+
+        sharedRealm.beginTransaction();
+        try {
+            assertTrue(listenerCalled.get());
+            assertEquals(before + 1, schemaVersionFromListener.get());
+        } finally {
+            sharedRealm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void refresh_SchemaVersionListener() {
+        final AtomicBoolean listenerCalled = new AtomicBoolean(false);
+        final AtomicLong schemaVersionFromListener = new AtomicLong(-1L);
+
+        sharedRealm.close();
+        sharedRealm = SharedRealm.getInstance(config, null, new SharedRealm.SchemaVersionListener() {
+            @Override
+            public void onSchemaVersionChanged(long currentVersion) {
+                listenerCalled.set(true);
+                schemaVersionFromListener.set(currentVersion);
+            }
+        });
+
+        final long before = sharedRealm.getSchemaVersion();
+
+        sharedRealm.refresh();
+        // listener is not called if there was no schema change
+        assertFalse(listenerCalled.get());
+
+        sharedRealm.beginTransaction();
+        try {
+            // change the schema version
+            sharedRealm.setSchemaVersion(before + 1);
+        } finally {
+            sharedRealm.commitTransaction();
+        }
+
+        // listener is not yet called
+        assertFalse(listenerCalled.get());
+
+        sharedRealm.refresh();
+        assertTrue(listenerCalled.get());
+        assertEquals(before + 1, schemaVersionFromListener.get());
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
index d8587d2bc3..751158bc98 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
@@ -142,24 +142,6 @@ public void testShouldThrowDistinctErrorWhenWrongColumnType() {
         }
     }
 
-    /**
-     * Is used to run a test multiple times,
-     * that corresponds to the number of columns in the Table generated
-     * in TestHelper.getTableWithAllColumnTypes
-     * @return
-     */
-
-// TODO: parametric test
-/*    @DataProvider(name = "columnIndex")
-    public Iterator<Object[]> mixedValuesProvider() {
-        Long[] values = {
-               0L,1L,2L,3L,4L,5L,6L,7L,8L
-        };
-
-        List<?> mixedValues = Arrays.asList(values);
-        return DataProviderUtil.allCombinations(mixedValues);
-    }*/
-
     public void testRemoveSearchIndex() {
         init();
         table.addSearchIndex(1);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/TableSpecEqualityTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/TableSpecEqualityTest.java
deleted file mode 100644
index 89539fc9fc..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/TableSpecEqualityTest.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import junit.framework.TestCase;
-
-import io.realm.RealmFieldType;
-
-public class TableSpecEqualityTest extends TestCase {
-
-    public void testShouldMatchIdenticalSimpleSpecs() {
-        TableSpec spec1 = new TableSpec();
-        spec1.addColumn(RealmFieldType.STRING, "foo");
-        spec1.addColumn(RealmFieldType.BOOLEAN, "bar");
-
-        TableSpec spec2 = new TableSpec();
-        spec2.addColumn(RealmFieldType.STRING, "foo");
-        spec2.addColumn(RealmFieldType.BOOLEAN, "bar");
-
-        assertTrue(spec1.equals(spec2));
-    }
-
-    public void testShouldntMatchSpecsWithDifferentColumnNames() {
-        TableSpec spec1 = new TableSpec();
-        spec1.addColumn(RealmFieldType.STRING, "foo");
-        spec1.addColumn(RealmFieldType.BOOLEAN, "bar");
-
-        TableSpec spec2 = new TableSpec();
-        spec2.addColumn(RealmFieldType.STRING, "foo");
-        spec2.addColumn(RealmFieldType.BOOLEAN, "bar2");
-
-        assertFalse(spec1.equals(spec2));
-    }
-
-    public void testShouldntMatchSpecsWithDifferentColumnTypes() {
-        TableSpec spec1 = new TableSpec();
-        spec1.addColumn(RealmFieldType.STRING, "foo");
-        spec1.addColumn(RealmFieldType.BOOLEAN, "bar");
-
-        TableSpec spec2 = new TableSpec();
-        spec2.addColumn(RealmFieldType.STRING, "foo");
-        spec2.addColumn(RealmFieldType.BINARY, "bar");
-
-        assertFalse(spec1.equals(spec2));
-    }
-
-    public void testShouldMatchDeepRecursiveIdenticalSpecs() {
-        TableSpec spec1 = new TableSpec();
-        spec1.addColumn(RealmFieldType.STRING, "foo");
-        spec1.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "bar");
-        spec1.getSubtableSpec(1).addColumn(RealmFieldType.INTEGER, "x");
-        spec1.getSubtableSpec(1).addColumn(RealmFieldType.UNSUPPORTED_TABLE, "sub");
-        spec1.getSubtableSpec(1).getSubtableSpec(1).addColumn(RealmFieldType.BOOLEAN, "b");
-
-        TableSpec spec2 = new TableSpec();
-        spec2.addColumn(RealmFieldType.STRING, "foo");
-        spec2.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "bar");
-        spec2.getSubtableSpec(1).addColumn(RealmFieldType.INTEGER, "x");
-        spec2.getSubtableSpec(1).addColumn(RealmFieldType.UNSUPPORTED_TABLE, "sub");
-        spec2.getSubtableSpec(1).getSubtableSpec(1).addColumn(RealmFieldType.BOOLEAN, "b");
-
-        assertTrue(spec1.equals(spec2));
-    }
-
-    public void testShouldNotMatchDeepRecursiveDifferentSpecs() {
-        TableSpec spec1 = new TableSpec();
-        spec1.addColumn(RealmFieldType.STRING, "foo");
-        spec1.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "bar");
-        spec1.getSubtableSpec(1).addColumn(RealmFieldType.INTEGER, "x");
-        spec1.getSubtableSpec(1).addColumn(RealmFieldType.UNSUPPORTED_TABLE, "sub");
-        spec1.getSubtableSpec(1).getSubtableSpec(1).addColumn(RealmFieldType.BOOLEAN, "b");
-
-        TableSpec spec2 = new TableSpec();
-        spec2.addColumn(RealmFieldType.STRING, "foo");
-        spec2.addColumn(RealmFieldType.UNSUPPORTED_TABLE, "bar");
-        spec2.getSubtableSpec(1).addColumn(RealmFieldType.INTEGER, "x");
-        spec2.getSubtableSpec(1).addColumn(RealmFieldType.UNSUPPORTED_TABLE, "sub2");
-        spec2.getSubtableSpec(1).getSubtableSpec(1).addColumn(RealmFieldType.BOOLEAN, "b");
-
-        assertFalse(spec1.equals(spec2));
-    }
-
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/CodeGenTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/CodeGenTest.java
deleted file mode 100644
index 7bc898b5c8..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/test/CodeGenTest.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.test;
-
-import io.realm.internal.DefineTable;
-
-/**
- * A helper class containing model(s) for simple code generation tests.
- */
-class CodeGenTest {
-
-    @DefineTable // this is enabled only for occasional local tests
-    class someModel {
-        String name;
-        int age;
-    }
-
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/DataProviderUtil.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/DataProviderUtil.java
deleted file mode 100644
index db78aa4ff6..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/test/DataProviderUtil.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.test;
-
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.List;
-
-
-public class DataProviderUtil {
-
-    public static Iterator<Object[]> allCombinations(List<?>... lists) {
-        Iterator<Object[]> iterator = new VariationsIterator<Object>(Arrays.asList(lists));
-        return iterator;
-    }
-
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/EmployeeData.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/EmployeeData.java
deleted file mode 100644
index e8436e35a6..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/test/EmployeeData.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.test;
-
-import java.nio.ByteBuffer;
-import java.util.Date;
-
-import io.realm.internal.Mixed;
-
-public class EmployeeData {
-
-    public String firstName;
-    public String lastName;
-    public int salary;
-    public boolean driver;
-    public byte[] photo;
-    public Date birthdate;
-    public Object extra;
-    public PhoneData[] phones;
-
-    public EmployeeData(String firstName, String lastName, int salary, boolean driver, byte[] photo, Date birthdate, Object extra, PhoneData[] phones) {
-        this.firstName = firstName;
-        this.lastName = lastName;
-        this.salary = salary;
-        this.driver = driver;
-        this.photo = photo;
-        this.birthdate = birthdate;
-        this.extra = extra;
-        this.phones = phones;
-    }
-
-    public Object get(int index) {
-        switch (index) {
-        case 0:
-            return firstName;
-        case 1:
-            return lastName;
-        case 2:
-            return new Long(salary);
-        case 3:
-            return new Boolean(driver);
-        case 4:
-            return ByteBuffer.wrap(photo);
-        case 5:
-            return birthdate;
-        case 6:
-            return Mixed.mixedValue(extra);
-        case 7:
-            return phones;
-        default:
-            throw new IllegalArgumentException("Incorrect index: " + index);
-        }
-    }
-
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/EmployeesFixture.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/EmployeesFixture.java
deleted file mode 100644
index d1f4c85453..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/test/EmployeesFixture.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.test;
-
-import java.util.Date;
-
-public class EmployeesFixture {
-
-    public static final PhoneData[][] PHONES = {
-        { new PhoneData("home", "123") },
-        { new PhoneData("mobile", "456") },
-        { new PhoneData("work", "789"), new PhoneData("mobile", "012") }
-    };
-
-    public static final EmployeeData[] EMPLOYEES = { new EmployeeData("John", "Doe", 10000, true, new byte[] { 1, 2, 3 }, new Date(111111), "extra", PHONES[0]),
-            new EmployeeData("Nikolche", "Mihajlovski", 30000, false, new byte[] { 4, 5 }, new Date(2222), 1234, PHONES[1]),
-            new EmployeeData("Johny", "B. Good", 10000, true, new byte[] { 1, 2, 3 }, new Date(333343333), true, PHONES[2]) };
-
-    public static Object[] getAll(int index) {
-        Object[] values = new Object[EMPLOYEES.length];
-
-        for (int i = 0; i < values.length; i++) {
-            values[i] = EMPLOYEES[i].get(index);
-        }
-
-        return values;
-    }
-
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/MixedData.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/MixedData.java
deleted file mode 100644
index 3f748bef60..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/test/MixedData.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.test;
-
-import io.realm.RealmFieldType;
-
-public class MixedData {
-
-    public RealmFieldType type;
-
-    public Object value;
-
-    public MixedData(RealmFieldType type, Object value) {
-        this.type = type;
-        this.value = value;
-    }
-
-    @Override
-    public String toString() {
-        return "MixedData [type=" + type + ", value=" + value + "]";
-    }
-
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/TestTableModel.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/TestTableModel.java
deleted file mode 100644
index 51182615b5..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/test/TestTableModel.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.test;
-
-import java.util.Date;
-
-import io.realm.internal.DefineTable;
-
-/**
- * This model is used to generate classes that are used only for the tests.
- */
-public class TestTableModel {
-
-    @DefineTable
-    class TestEmployee {
-        String firstName;
-        String lastName;
-        int salary;
-        boolean driver;
-        byte[] photo;
-        Date birthdate;
-        Object extra;
-        TestPhone phones;
-    }
-
-    @DefineTable
-    class TestPhone {
-        String type;
-        String number;
-    }
-
-    @DefineTable
-    class TestNumbers {
-        long longNum;
-        float floatNum;
-        double doubleNum;
-    }
-
-    @DefineTable
-    class TestQueryTable {
-        long longNum;
-        float floatNum;
-        double doubleNum;
-        String stringVal;
-    }
-
-    @DefineTable
-    class AllTypes {
-        boolean  boolCol;
-        java.util.Date dateCol;
-        double doubleCol;
-        int intCol;
-        long longCol;
-        float floatCol;
-        String stringCol;
-        byte[] byteCol;
-        Car carTableCol; // Subtable of the type Car defined as a typed table
-        Object mixedCol; // Can hold any of the types
-    }
-
-    @DefineTable
-    class Car {
-        String  brand;
-        String  model;
-        int year;
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/test/VariationsIterator.java b/realm/realm-library/src/androidTest/java/io/realm/internal/test/VariationsIterator.java
deleted file mode 100644
index 03a7d85ab5..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/test/VariationsIterator.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.test;
-
-import java.util.Iterator;
-import java.util.List;
-
-public class VariationsIterator<T> implements Iterator<Object[]> {
-
-    private final List<List<?>> lists;
-
-    private int[] sizes;
-    private int[] indexes;
-
-    private boolean hasNext = true;
-
-    public VariationsIterator(List<List<?>> lists) {
-        this.lists = lists;
-
-        sizes = new int[lists.size()];
-        indexes = new int[lists.size()];
-
-        for (int i = 0; i < lists.size(); i++) {
-            if (lists.get(i).isEmpty()) {
-                throw new RuntimeException("Each list must contain at least 1 item!");
-            }
-
-            sizes[i] = lists.get(i).size();
-            indexes[i] = 0;
-        }
-    }
-
-    public Object[] next() {
-        Object[] result = new Object[lists.size()];
-
-        for (int i = 0; i < lists.size(); i++) {
-            result[i] = lists.get(i).get(indexes[i]);
-        }
-
-        increase();
-        return result;
-    }
-
-    public boolean hasNext() {
-        return hasNext;
-    }
-
-    private void increase() {
-        for (int i = 0; i < indexes.length; i++) {
-            indexes[i] = (indexes[i] + 1) % sizes[i];
-            if (indexes[i] > 0) {
-                hasNext = true;
-                return;
-            }
-        }
-        hasNext = false;
-    }
-
-    public void remove() {
-        throw new UnsupportedOperationException();
-    }
-
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/migration/MigrationPrimaryKey.java b/realm/realm-library/src/androidTest/java/io/realm/migration/MigrationPrimaryKey.java
new file mode 100644
index 0000000000..f53221b9ef
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/migration/MigrationPrimaryKey.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.migration;
+
+/**
+ * This interface should be used as a stub for dynamically creating the first version of schema.
+ * As this is an interface and does not inherit RealmObject, a schema for {@link MigrationPrimaryKey}
+ * there does not exist.
+ */
+public interface MigrationPrimaryKey {
+    public static String CLASS_NAME    = "MigrationPrimaryKey";
+
+    public static String FIELD_FIRST   = "fieldFirst";
+    public static String FIELD_SECOND  = "fieldSecond";
+
+    // this is original primary key field name.
+    public static String FIELD_PRIMARY = "fieldPrimary";
+    public static String FIELD_FOURTH  = "fieldFourth";
+    public static String FIELD_FIFTH   = "fieldFifth";
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
index 29060837c0..8a77d1e983 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
@@ -24,11 +24,13 @@
 
 import java.io.PrintWriter;
 import java.io.StringWriter;
+import java.lang.annotation.Annotation;
 import java.util.LinkedList;
 import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadFactory;
 
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
@@ -75,7 +77,8 @@ protected void after() {
 
     @Override
     public Statement apply(final Statement base, Description description) {
-        if (description.getAnnotation(RunTestInLooperThread.class) == null) {
+        final RunTestInLooperThread annotation = description.getAnnotation(RunTestInLooperThread.class);
+        if (annotation == null) {
             return base;
         }
         return new Statement() {
@@ -84,11 +87,21 @@ public Statement apply(final Statement base, Description description) {
             @Override
             public void evaluate() throws Throwable {
                 before();
+                final String threadName = annotation.threadName();
+                Class<? extends RunnableBefore> runnableBefore = annotation.before();
+                if (!runnableBefore.isInterface()) {
+                    runnableBefore.newInstance().run(realmConfiguration);
+                }
                 try {
                     final CountDownLatch signalClosedRealm = new CountDownLatch(1);
                     final Throwable[] threadAssertionError = new Throwable[1];
                     final Looper[] backgroundLooper = new Looper[1];
-                    final ExecutorService executorService = Executors.newSingleThreadExecutor();
+                    final ExecutorService executorService = Executors.newSingleThreadExecutor(new ThreadFactory() {
+                        @Override
+                        public Thread newThread(Runnable runnable) {
+                            return new Thread(runnable, threadName);
+                        }
+                    });
                     executorService.submit(new Runnable() {
                         @Override
                         public void run() {
@@ -111,9 +124,7 @@ public void run() {
                                     }
                                     unitTestFailed = true;
                                 }
-                                if (signalTestCompleted.getCount() > 0) {
-                                    signalTestCompleted.countDown();
-                                }
+                                signalTestCompleted.countDown();
                                 if (realm != null) {
                                     realm.close();
                                 }
@@ -190,10 +201,25 @@ public void postRunnable(Runnable runnable) {
         backgroundHandler.post(runnable);
     }
 
+    /**
+     * Posts a runnable to this worker threads looper with a delay in milli second.
+     */
+    public void postRunnableDelayed(Runnable runnable, long delayMillis) {
+        backgroundHandler.postDelayed(runnable, delayMillis);
+    }
+
     /**
      * Tear down logic which is guaranteed to run after the looper test has either completed or failed.
      * This will run on the same thread as the looper test.
      */
     public void looperTearDown() {
     }
+
+    /**
+     * If an implementation of this is supplied with the annotation, the {@link RunnableBefore#run(RealmConfiguration)}
+     * will be executed before the looper thread starts. It is normally for populating the Realm before the test.
+     */
+    public interface RunnableBefore {
+        void run(RealmConfiguration realmConfig);
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestInLooperThread.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestInLooperThread.java
index 149412fbcb..c24c085983 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestInLooperThread.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestInLooperThread.java
@@ -25,8 +25,12 @@
  * This annotation should be used along with {@link RunInLooperThread}
  * When the annotation is present, the test method is executed on a worker thread with a looper.
  * This will also uses {@link org.junit.rules.TemporaryFolder} to create and open a Realm.
+ * Annotation param {@link io.realm.rule.RunInLooperThread.RunnableBefore} can be supplied which will run before the
+ * looper thread.
  */
-@Target(METHOD) @Retention(RUNTIME)
+@Target(METHOD)
+@Retention(RUNTIME)
 public @interface RunTestInLooperThread {
-
+        String threadName() default "RunTestInLooperThread";
+        Class<?extends RunInLooperThread.RunnableBefore> before() default RunInLooperThread.RunnableBefore.class;
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
index 2681563436..b646cc7257 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
@@ -18,6 +18,7 @@
 
 import android.content.Context;
 import android.content.res.AssetManager;
+import android.support.test.InstrumentationRegistry;
 
 import org.junit.rules.TemporaryFolder;
 import org.junit.runner.Description;
@@ -34,6 +35,7 @@
 
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
+import io.realm.TestHelper;
 
 import static org.junit.Assert.assertTrue;
 
@@ -73,6 +75,10 @@ protected void before() throws Throwable {
 
     @Override
     protected void after() {
+        // Wait all async tasks done to ensure successful deleteRealm call.
+        // This will throw when timeout. And the reason of timeout needs to be solved properly.
+        TestHelper.waitRealmThreadExecutorFinish();
+
         try {
             for (RealmConfiguration configuration : configurations) {
                 Realm.deleteRealm(configuration);
@@ -83,13 +89,14 @@ protected void after() {
                 throw e;
             }
         } finally {
-            // This will delete the temp folder.
+            // This will delete the temp directory.
             super.after();
         }
     }
 
     public RealmConfiguration createConfiguration() {
-        RealmConfiguration configuration = new RealmConfiguration.Builder(getRoot())
+        RealmConfiguration configuration = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext())
+                .directory(getRoot())
                 .build();
 
         configurations.add(configuration);
@@ -99,7 +106,8 @@ public RealmConfiguration createConfiguration() {
     public RealmConfiguration createConfiguration(String subDir, String name) {
         final File folder = new File(getRoot(), subDir);
         assertTrue(folder.mkdirs());
-        RealmConfiguration configuration = new RealmConfiguration.Builder(folder)
+        RealmConfiguration configuration = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext())
+                .directory(folder)
                 .name(name)
                 .build();
 
@@ -108,7 +116,8 @@ public RealmConfiguration createConfiguration(String subDir, String name) {
     }
 
     public RealmConfiguration createConfiguration(String name) {
-        RealmConfiguration configuration = new RealmConfiguration.Builder(getRoot())
+        RealmConfiguration configuration = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext())
+                .directory(getRoot())
                 .name(name)
                 .build();
 
@@ -117,7 +126,8 @@ public RealmConfiguration createConfiguration(String name) {
     }
 
     public RealmConfiguration createConfiguration(String name, byte[] key) {
-        RealmConfiguration configuration = new RealmConfiguration.Builder(getRoot())
+        RealmConfiguration configuration = new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext())
+                .directory(getRoot())
                 .name(name)
                 .encryptionKey(key)
                 .build();
@@ -127,14 +137,15 @@ public RealmConfiguration createConfiguration(String name, byte[] key) {
     }
 
     public RealmConfiguration.Builder createConfigurationBuilder() {
-        return new RealmConfiguration.Builder(getRoot());
+        return new RealmConfiguration.Builder(InstrumentationRegistry.getTargetContext()).directory(getRoot());
     }
 
     // Copies a Realm file from assets to temp dir
     public void copyRealmFromAssets(Context context, String realmPath, String newName)
             throws IOException {
         // Delete the existing file before copy
-        RealmConfiguration configToDelete = new RealmConfiguration.Builder(getRoot())
+        RealmConfiguration configToDelete = new RealmConfiguration.Builder(context)
+                .directory(getRoot())
                 .name(newName)
                 .build();
         Realm.deleteRealm(configToDelete);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/tests/api/entities/AllColumns.java b/realm/realm-library/src/androidTest/java/io/realm/tests/api/entities/AllColumns.java
deleted file mode 100644
index 380bd44f08..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/tests/api/entities/AllColumns.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* TODO: re-enable
-
-
-package io.realm.tests.typed.entities;
-
-import java.util.Date;
-
-import io.realm.RealmObject;
-
-public class AllColumns extends RealmObject {
-
-    private String columnString;
-    private long columnLong;
-    private float columnFloat;
-    private double columnDouble;
-    private boolean columnBoolean;
-    private Date columnDate;
-    private byte[] columnBinary;
-    private User columnRealmObject;
-
-    public String getColumnString() {
-        return columnString;
-    }
-
-    public void setColumnString(String columnString) {
-        this.columnString = columnString;
-    }
-
-    public long getColumnLong() {
-        return columnLong;
-    }
-
-    public void setColumnLong(long columnLong) {
-        this.columnLong = columnLong;
-    }
-
-    public float getColumnFloat() {
-        return columnFloat;
-    }
-
-    public void setColumnFloat(float columnFloat) {
-        this.columnFloat = columnFloat;
-    }
-
-    public double getColumnDouble() {
-        return columnDouble;
-    }
-
-    public void setColumnDouble(double columnDouble) {
-        this.columnDouble = columnDouble;
-    }
-
-    public boolean isColumnBoolean() {
-        return columnBoolean;
-    }
-
-    public void setColumnBoolean(boolean columnBoolean) {
-        this.columnBoolean = columnBoolean;
-    }
-
-    public Date getColumnDate() {
-        return columnDate;
-    }
-
-    public void setColumnDate(Date columnDate) {
-        this.columnDate = columnDate;
-    }
-
-    public byte[] getColumnBinary() {
-        return columnBinary;
-    }
-
-    public void setColumnBinary(byte[] columnBinary) {
-        this.columnBinary = columnBinary;
-    }
-
-    public User getColumnRealmObject() {
-        return columnRealmObject;
-    }
-
-    public void setColumnRealmObject(User columnRealmObject) {
-        this.columnRealmObject = columnRealmObject;
-    }
-}
-*/
diff --git a/realm/realm-library/src/androidTest/java/io/realm/tests/api/entities/Dog.java b/realm/realm-library/src/androidTest/java/io/realm/tests/api/entities/Dog.java
deleted file mode 100644
index e08d5270d8..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/tests/api/entities/Dog.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* TODO: re-enable
-
-
-package io.realm.tests.api.entities;
-
-import io.realm.RealmArrayList;
-import io.realm.RealmList;
-import io.realm.RealmObject;
-
-public class Dog extends RealmObject {
-
-    private RealmList<User> owners = new RealmArrayList<User>();
-    private String name;
-
-    public RealmList<User> getOwners() {
-        return owners;
-    }
-
-    public void setOwners(RealmList<User> owners) {
-        this.owners = owners;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-}
-*/
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmResultsBenchmarks.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmResultsBenchmarks.java
index 88010f9502..5a25e95ee0 100644
--- a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmResultsBenchmarks.java
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmResultsBenchmarks.java
@@ -106,4 +106,11 @@ public void sum(long reps) {
             Number sum = results.sum(AllTypes.FIELD_LONG);
         }
     }
+
+    @Benchmark
+    public void sort(long reps) {
+        for (long i = 0; i < reps; i++) {
+            RealmResults<AllTypes> sorted = results.sort(AllTypes.FIELD_STRING);
+        }
+    }
 }
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/BenchmarkConfig.java b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/BenchmarkConfig.java
index 47a1136b30..da65aab166 100644
--- a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/BenchmarkConfig.java
+++ b/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/BenchmarkConfig.java
@@ -31,13 +31,13 @@
 public class BenchmarkConfig {
 
     public static SpannerConfig getConfiguration(String className) {
-        // Document folder is located at: /sdcard/realm-benchmarks
+        // Document directory is located at: /sdcard/realm-benchmarks
         // Benchmarks results should be saved in <documentFolder>/results/<className>.json
         // Baseline data should be found in <documentFolder>/baselines/<className>.json
         // Custom CSV files should be found in <documentFolder>/csv/<className>.csv
         File externalDocuments = new File(Environment.getExternalStorageDirectory(), "realm-benchmarks");
         if (!externalDocuments.exists() && !externalDocuments.mkdir()) {
-            throw new RuntimeException("Could not create benchmark folder: " + externalDocuments);
+            throw new RuntimeException("Could not create benchmark directory: " + externalDocuments);
         }
         File resultsDir = new File(externalDocuments, "results");
         File baselineDir = new File(externalDocuments, "baselines");
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
new file mode 100644
index 0000000000..22adbba0cf
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -0,0 +1,117 @@
+cmake_minimum_required(VERSION 3.6.0)
+
+# find javah
+find_package(Java COMPONENTS Development)
+if (NOT Java_Development_FOUND)
+    if (DEFINED ENV{JAVA_HOME} AND EXISTS "$ENV{JAVA_HOME}/bin/javah")
+      set(Java_JAVAH_EXECUTABLE "$ENV{JAVA_HOME}/bin/javah")
+    elseif (EXISTS "/usr/bin/javah")
+      set(Java_JAVAH_EXECUTABLE "/usr/bin/javah")
+    else()
+      message(FATAL_ERROR "Cannot find javah")
+    endif()
+endif()
+include (UseJava)
+
+set(CMAKE_VERBOSE_MAKEFILE ON)
+# Generate compile_commands.json
+set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
+
+if (CMAKE_BUILD_TYPE STREQUAL "Release")
+    set(classes_PATH ${CMAKE_SOURCE_DIR}/../../../build/intermediates/classes/release/)
+else()
+    set(classes_PATH ${CMAKE_SOURCE_DIR}/../../../build/intermediates/classes/debug/)
+endif()
+
+create_javah(TARGET jni_headers
+  CLASSES io.realm.internal.Table io.realm.internal.TableView io.realm.internal.CheckedRow
+  io.realm.internal.LinkView io.realm.internal.Util io.realm.internal.UncheckedRow
+  io.realm.internal.TableQuery io.realm.internal.SharedRealm io.realm.internal.TestUtil
+  io.realm.log.LogLevel
+
+  CLASSPATH ${classes_PATH}
+  OUTPUT_DIR ${CMAKE_SOURCE_DIR}/jni_include
+  DEPENDS ${classes_PATH}
+)
+
+# TODO: Ideally the debug build should link with core's debug build. But core dbg lib has
+# some compile options problems with arm, especially with macro REALM_DEBUG. Link to core
+# dbg for debug build when that gets solved.
+# We always link to the non-dbg version of core libs for now.
+# This means only JNI part has debugging symbols with debug build.
+# Debugging with core source code will also be done though anther approach -- compiling the core
+# with cmake inside android project.
+# Configure import realm core lib
+set(core_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-android-${ANDROID_ABI}.a)
+# Workaround for old core's funny ABI nicknames
+if (NOT EXISTS ${core_lib_PATH})
+    if (ARMEABI)
+        set(core_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-android-arm.a)
+    elseif (ARMEABI_V7A)
+        set(core_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-android-arm-v7a.a)
+    elseif (ARM64_V8A)
+        set(core_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-android-arm64.a)
+    else()
+        message(FATAL_ERROR "Cannot find core lib file: ${core_lib_PATH}")
+    endif()
+endif()
+
+add_library(lib_realm_core STATIC IMPORTED)
+set_target_properties(lib_realm_core PROPERTIES IMPORTED_LOCATION ${core_lib_PATH})
+
+# build application's shared lib
+include_directories(${REALM_CORE_DIST_DIR}/include
+    ${CMAKE_SOURCE_DIR}
+    ${CMAKE_SOURCE_DIR}/jni_include
+    ${CMAKE_SOURCE_DIR}/object-store/src)
+
+set(ANDROID_STL "gnustl_static")
+
+if (ARMEABI)
+    set(ABI_CXX_FLAGS "-mthumb")
+elseif (ARMEABI_V7A)
+    set(ABI_CXX_FLAGS "-mthumb -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16")
+endif()
+
+#FIXME uninitialized is reported by query_expression.hpp:1070
+#      d.init(ValueBase::m_from_link_list, ValueBase::m_values, D{});
+#FIXME maybe-uninitialized is reported by table_view.cpp:272:15:
+#     'best.m_nanoseconds' was declared here
+set(WARNING_CXX_FLAGS "-Werror -Wall -Wextra -pedantic -Wno-long-long -Wno-variadic-macros \
+-Wno-missing-field-initializers -Wmissing-declarations -Wno-error=uninitialized -Wno-error=maybe-uninitialized")
+set(REALM_COMMON_CXX_FLAGS "-DREALM_ANDROID -DREALM_HAVE_CONFIG -DPIC -pthread -fvisibility=hidden -std=c++14")
+# There might be an issue with -Os of ndk gcc 4.9. It will hang the encryption related tests.
+# And this issue doesn't seem to impact the core compiling.
+set(CMAKE_CXX_FLAGS_RELEASE "-O2 -DNDEBUG -flto")
+#-ggdb doesn't play well with -flto
+set(CMAKE_CXX_FLAGS_DEBUG "-ggdb -Og -DNDEBUG")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${REALM_COMMON_CXX_FLAGS} ${WARNING_CXX_FLAGS} ${ABI_CXX_FLAGS}")
+
+# Set link flags
+set(REALM_LINKER_FLAGS "")
+set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} ${REALM_LINKER_FLAGS}")
+
+file(GLOB jni_SRC
+    "*.cpp"
+)
+file(GLOB objectstore_SRC
+    "object-store/src/*.cpp"
+    "object-store/src/impl/*.cpp"
+    "object-store/src/impl/android/*.cpp"
+    "object-store/src/util/*.cpp"
+)
+add_library(realm-jni SHARED ${jni_SRC} ${objectstore_SRC})
+add_dependencies(realm-jni jni_headers)
+# -latomic is not set by default for mips. See https://code.google.com/p/android/issues/detail?id=182094
+target_link_libraries(realm-jni log android atomic lib_realm_core)
+
+# Strip the release so files and backup the unstripped versions
+if (CMAKE_BUILD_TYPE STREQUAL "Release")
+    set(unstripped_SO_DIR "${CMAKE_SOURCE_DIR}/../../../build/outputs/jniLibs-unstripped/${ANDROID_ABI}")
+    add_custom_command(TARGET realm-jni
+        POST_BUILD
+        COMMAND ${CMAKE_COMMAND} -E make_directory ${unstripped_SO_DIR}
+        COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_FILE:realm-jni> ${unstripped_SO_DIR}
+        COMMAND ${CMAKE_STRIP} $<TARGET_FILE:realm-jni>)
+endif()
+
diff --git a/realm/realm-library/src/main/cpp/android.toolchain.cmake b/realm/realm-library/src/main/cpp/android.toolchain.cmake
new file mode 100644
index 0000000000..86046dfa45
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/android.toolchain.cmake
@@ -0,0 +1,1703 @@
+# Copyright (c) 2010-2011, Ethan Rublee
+# Copyright (c) 2011-2014, Andrey Kamaev
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#
+# 1.  Redistributions of source code must retain the above copyright notice,
+#     this list of conditions and the following disclaimer.
+#
+# 2.  Redistributions in binary form must reproduce the above copyright notice,
+#     this list of conditions and the following disclaimer in the documentation
+#     and/or other materials provided with the distribution.
+#
+# 3.  Neither the name of the copyright holder nor the names of its
+#     contributors may be used to endorse or promote products derived from this
+#     software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+# ------------------------------------------------------------------------------
+#  Android CMake toolchain file, for use with the Android NDK r5-r10d
+#  Requires cmake 2.6.3 or newer (2.8.9 or newer is recommended).
+#  See home page: https://github.com/taka-no-me/android-cmake
+#
+#  Usage Linux:
+#   $ export ANDROID_NDK=/absolute/path/to/the/android-ndk
+#   $ mkdir build && cd build
+#   $ cmake -DCMAKE_TOOLCHAIN_FILE=path/to/the/android.toolchain.cmake ..
+#   $ make -j8
+#
+#  Usage Windows:
+#     You need native port of make to build your project.
+#     Android NDK r7 (and newer) already has make.exe on board.
+#     For older NDK you have to install it separately.
+#     For example, this one: http://gnuwin32.sourceforge.net/packages/make.htm
+#
+#   $ SET ANDROID_NDK=C:\absolute\path\to\the\android-ndk
+#   $ mkdir build && cd build
+#   $ cmake.exe -G"MinGW Makefiles"
+#       -DCMAKE_TOOLCHAIN_FILE=path\to\the\android.toolchain.cmake
+#       -DCMAKE_MAKE_PROGRAM="%ANDROID_NDK%\prebuilt\windows\bin\make.exe" ..
+#   $ cmake.exe --build .
+#
+#
+#  Options (can be set as cmake parameters: -D<option_name>=<value>):
+#    ANDROID_NDK=/opt/android-ndk - path to the NDK root.
+#      Can be set as environment variable. Can be set only at first cmake run.
+#
+#    ANDROID_ABI=armeabi-v7a - specifies the target Application Binary
+#      Interface (ABI). This option nearly matches to the APP_ABI variable
+#      used by ndk-build tool from Android NDK.
+#
+#      Possible targets are:
+#        "armeabi" - ARMv5TE based CPU with software floating point operations
+#        "armeabi-v7a" - ARMv7 based devices with hardware FPU instructions
+#            this ABI target is used by default
+#        "armeabi-v7a with NEON" - same as armeabi-v7a, but
+#            sets NEON as floating-point unit
+#        "armeabi-v7a with VFPV3" - same as armeabi-v7a, but
+#            sets VFPV3 as floating-point unit (has 32 registers instead of 16)
+#        "armeabi-v6 with VFP" - tuned for ARMv6 processors having VFP
+#        "x86" - IA-32 instruction set
+#        "mips" - MIPS32 instruction set
+#
+#      64-bit ABIs for NDK r10 and newer:
+#        "arm64-v8a" - ARMv8 AArch64 instruction set
+#        "x86_64" - Intel64 instruction set (r1)
+#        "mips64" - MIPS64 instruction set (r6)
+#
+#    ANDROID_NATIVE_API_LEVEL=android-9 - level of Android API compile for.
+#      Option is read-only when standalone toolchain is used.
+#      Note: building for "android-L" requires explicit configuration.
+#
+#    ANDROID_TOOLCHAIN_NAME=arm-linux-androideabi-4.9 - the name of compiler
+#      toolchain to be used. The list of possible values depends on the NDK
+#      version. For NDK r10c the possible values are:
+#
+#        * aarch64-linux-android-4.9
+#        * aarch64-linux-android-clang3.4
+#        * aarch64-linux-android-clang3.5
+#        * arm-linux-androideabi-4.6
+#        * arm-linux-androideabi-4.8
+#        * arm-linux-androideabi-4.9 (default)
+#        * arm-linux-androideabi-clang3.4
+#        * arm-linux-androideabi-clang3.5
+#        * mips64el-linux-android-4.9
+#        * mips64el-linux-android-clang3.4
+#        * mips64el-linux-android-clang3.5
+#        * mipsel-linux-android-4.6
+#        * mipsel-linux-android-4.8
+#        * mipsel-linux-android-4.9
+#        * mipsel-linux-android-clang3.4
+#        * mipsel-linux-android-clang3.5
+#        * x86-4.6
+#        * x86-4.8
+#        * x86-4.9
+#        * x86-clang3.4
+#        * x86-clang3.5
+#        * x86_64-4.9
+#        * x86_64-clang3.4
+#        * x86_64-clang3.5
+#
+#    ANDROID_FORCE_ARM_BUILD=OFF - set ON to generate 32-bit ARM instructions
+#      instead of Thumb. Is not available for "armeabi-v6 with VFP"
+#      (is forced to be ON) ABI.
+#
+#    ANDROID_NO_UNDEFINED=ON - set ON to show all undefined symbols as linker
+#      errors even if they are not used.
+#
+#    ANDROID_SO_UNDEFINED=OFF - set ON to allow undefined symbols in shared
+#      libraries. Automatically turned for NDK r5x and r6x due to GLESv2
+#      problems.
+#
+#    ANDROID_STL=gnustl_static - specify the runtime to use.
+#
+#      Possible values are:
+#        none           -> Do not configure the runtime.
+#        system         -> Use the default minimal system C++ runtime library.
+#                          Implies -fno-rtti -fno-exceptions.
+#                          Is not available for standalone toolchain.
+#        system_re      -> Use the default minimal system C++ runtime library.
+#                          Implies -frtti -fexceptions.
+#                          Is not available for standalone toolchain.
+#        gabi++_static  -> Use the GAbi++ runtime as a static library.
+#                          Implies -frtti -fno-exceptions.
+#                          Available for NDK r7 and newer.
+#                          Is not available for standalone toolchain.
+#        gabi++_shared  -> Use the GAbi++ runtime as a shared library.
+#                          Implies -frtti -fno-exceptions.
+#                          Available for NDK r7 and newer.
+#                          Is not available for standalone toolchain.
+#        stlport_static -> Use the STLport runtime as a static library.
+#                          Implies -fno-rtti -fno-exceptions for NDK before r7.
+#                          Implies -frtti -fno-exceptions for NDK r7 and newer.
+#                          Is not available for standalone toolchain.
+#        stlport_shared -> Use the STLport runtime as a shared library.
+#                          Implies -fno-rtti -fno-exceptions for NDK before r7.
+#                          Implies -frtti -fno-exceptions for NDK r7 and newer.
+#                          Is not available for standalone toolchain.
+#        gnustl_static  -> Use the GNU STL as a static library.
+#                          Implies -frtti -fexceptions.
+#        gnustl_shared  -> Use the GNU STL as a shared library.
+#                          Implies -frtti -fno-exceptions.
+#                          Available for NDK r7b and newer.
+#                          Silently degrades to gnustl_static if not available.
+#
+#    ANDROID_STL_FORCE_FEATURES=ON - turn rtti and exceptions support based on
+#      chosen runtime. If disabled, then the user is responsible for settings
+#      these options.
+#
+#  What?:
+#    android-cmake toolchain searches for NDK/toolchain in the following order:
+#      ANDROID_NDK - cmake parameter
+#      ANDROID_NDK - environment variable
+#      ANDROID_STANDALONE_TOOLCHAIN - cmake parameter
+#      ANDROID_STANDALONE_TOOLCHAIN - environment variable
+#      ANDROID_NDK - default locations
+#      ANDROID_STANDALONE_TOOLCHAIN - default locations
+#
+#    Make sure to do the following in your scripts:
+#      SET( CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${my_cxx_flags}" )
+#      SET( CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${my_cxx_flags}" )
+#    The flags will be prepopulated with critical flags, so don't loose them.
+#    Also be aware that toolchain also sets configuration-specific compiler
+#    flags and linker flags.
+#
+#    ANDROID and BUILD_ANDROID will be set to true, you may test any of these
+#    variables to make necessary Android-specific configuration changes.
+#
+#    Also ARMEABI or ARMEABI_V7A or X86 or MIPS or ARM64_V8A or X86_64 or MIPS64
+#    will be set true, mutually exclusive. NEON option will be set true
+#    if VFP is set to NEON.
+#
+# ------------------------------------------------------------------------------
+
+# FIXME:
+# This is copied from https://dl.google.com/android/repository/cmake-3.4.2909474-linux-x86_64.zip
+# because of the android.toolchain.cmake shipped with Android SDK CMake 3.6 doesn't work with our
+# JNI build currently (lack of lto linking support.). Two modifications are made to avoid warnings
+# with CMake 3.6 -- disable CMAKE_FORCE_CXX_COMPILER & CMAKE_FORCE_C_COMPILER.
+# This file should be removed and use the one from Android SDK cmake package when it supports lto.
+
+cmake_minimum_required( VERSION 2.6.3 )
+
+if( DEFINED CMAKE_CROSSCOMPILING )
+ # subsequent toolchain loading is not really needed
+ return()
+endif()
+
+if( CMAKE_TOOLCHAIN_FILE )
+ # touch toolchain variable to suppress "unused variable" warning
+endif()
+
+# inherit settings in recursive loads
+get_property( _CMAKE_IN_TRY_COMPILE GLOBAL PROPERTY IN_TRY_COMPILE )
+if( _CMAKE_IN_TRY_COMPILE )
+ include( "${CMAKE_CURRENT_SOURCE_DIR}/../android.toolchain.config.cmake" OPTIONAL )
+endif()
+
+# this one is important
+if( CMAKE_VERSION VERSION_GREATER "3.0.99" )
+ set( CMAKE_SYSTEM_NAME Android )
+else()
+ set( CMAKE_SYSTEM_NAME Linux )
+endif()
+
+# this one not so much
+set( CMAKE_SYSTEM_VERSION 1 )
+
+# rpath makes low sense for Android
+set( CMAKE_SHARED_LIBRARY_RUNTIME_C_FLAG "" )
+set( CMAKE_SKIP_RPATH TRUE CACHE BOOL "If set, runtime paths are not added when using shared libraries." )
+
+# NDK search paths
+set( ANDROID_SUPPORTED_NDK_VERSIONS ${ANDROID_EXTRA_NDK_VERSIONS} -r10d -r10c -r10b -r10 -r9d -r9c -r9b -r9 -r8e -r8d -r8c -r8b -r8 -r7c -r7b -r7 -r6b -r6 -r5c -r5b -r5 "" )
+if( NOT DEFINED ANDROID_NDK_SEARCH_PATHS )
+ if( CMAKE_HOST_WIN32 )
+  file( TO_CMAKE_PATH "$ENV{PROGRAMFILES}" ANDROID_NDK_SEARCH_PATHS )
+  set( ANDROID_NDK_SEARCH_PATHS "${ANDROID_NDK_SEARCH_PATHS}" "$ENV{SystemDrive}/NVPACK" )
+ else()
+  file( TO_CMAKE_PATH "$ENV{HOME}" ANDROID_NDK_SEARCH_PATHS )
+  set( ANDROID_NDK_SEARCH_PATHS /opt "${ANDROID_NDK_SEARCH_PATHS}/NVPACK" )
+ endif()
+endif()
+if( NOT DEFINED ANDROID_STANDALONE_TOOLCHAIN_SEARCH_PATH )
+ set( ANDROID_STANDALONE_TOOLCHAIN_SEARCH_PATH /opt/android-toolchain )
+endif()
+
+# known ABIs
+set( ANDROID_SUPPORTED_ABIS_arm "armeabi-v7a;armeabi;armeabi-v7a with NEON;armeabi-v7a with VFPV3;armeabi-v6 with VFP" )
+set( ANDROID_SUPPORTED_ABIS_arm64 "arm64-v8a" )
+set( ANDROID_SUPPORTED_ABIS_x86 "x86" )
+set( ANDROID_SUPPORTED_ABIS_x86_64 "x86_64" )
+set( ANDROID_SUPPORTED_ABIS_mips "mips" )
+set( ANDROID_SUPPORTED_ABIS_mips64 "mips64" )
+
+# API level defaults
+set( ANDROID_DEFAULT_NDK_API_LEVEL 9 )
+set( ANDROID_DEFAULT_NDK_API_LEVEL_arm64 21 )
+set( ANDROID_DEFAULT_NDK_API_LEVEL_x86 9 )
+set( ANDROID_DEFAULT_NDK_API_LEVEL_x86_64 21 )
+set( ANDROID_DEFAULT_NDK_API_LEVEL_mips 9 )
+set( ANDROID_DEFAULT_NDK_API_LEVEL_mips64 21 )
+
+
+macro( __LIST_FILTER listvar regex )
+  if( ${listvar} )
+    foreach( __val ${${listvar}} )
+      if( __val MATCHES "${regex}" )
+        list( REMOVE_ITEM ${listvar} "${__val}" )
+      endif()
+    endforeach()
+  endif()
+endmacro()
+
+macro( __INIT_VARIABLE var_name )
+  set( __test_path 0 )
+  foreach( __var ${ARGN} )
+    if( __var STREQUAL "PATH" )
+      set( __test_path 1 )
+      break()
+    endif()
+  endforeach()
+
+  if( __test_path AND NOT EXISTS "${${var_name}}" )
+    unset( ${var_name} CACHE )
+  endif()
+
+  if( " ${${var_name}}" STREQUAL " " )
+    set( __values 0 )
+    foreach( __var ${ARGN} )
+      if( __var STREQUAL "VALUES" )
+        set( __values 1 )
+      elseif( NOT __var STREQUAL "PATH" )
+        if( __var MATCHES "^ENV_.*$" )
+          string( REPLACE "ENV_" "" __var "${__var}" )
+          set( __value "$ENV{${__var}}" )
+        elseif( DEFINED ${__var} )
+          set( __value "${${__var}}" )
+        elseif( __values )
+          set( __value "${__var}" )
+        else()
+          set( __value "" )
+        endif()
+
+        if( NOT " ${__value}" STREQUAL " " AND (NOT __test_path OR EXISTS "${__value}") )
+          set( ${var_name} "${__value}" )
+          break()
+        endif()
+      endif()
+    endforeach()
+    unset( __value )
+    unset( __values )
+  endif()
+
+  if( __test_path )
+    file( TO_CMAKE_PATH "${${var_name}}" ${var_name} )
+  endif()
+  unset( __test_path )
+endmacro()
+
+macro( __DETECT_NATIVE_API_LEVEL _var _path )
+  set( __ndkApiLevelRegex "^[\t ]*#define[\t ]+__ANDROID_API__[\t ]+([0-9]+)[\t ]*.*$" )
+  file( STRINGS ${_path} __apiFileContent REGEX "${__ndkApiLevelRegex}" )
+  if( NOT __apiFileContent )
+    message( SEND_ERROR "Could not get Android native API level. Probably you have specified invalid level value, or your copy of NDK/toolchain is broken." )
+  endif()
+  string( REGEX REPLACE "${__ndkApiLevelRegex}" "\\1" ${_var} "${__apiFileContent}" )
+  unset( __apiFileContent )
+  unset( __ndkApiLevelRegex )
+endmacro()
+
+macro( __DETECT_TOOLCHAIN_MACHINE_NAME _var _root )
+ if( EXISTS "${_root}" )
+    file( GLOB __gccExePath RELATIVE "${_root}/bin/" "${_root}/bin/*-gcc${TOOL_OS_SUFFIX}" )
+    __LIST_FILTER( __gccExePath "^[.].*" )
+    list( LENGTH __gccExePath __gccExePathsCount )
+    if( NOT __gccExePathsCount EQUAL 1  AND NOT _CMAKE_IN_TRY_COMPILE )
+      message( WARNING "Could not determine machine name for compiler from ${_root}" )
+      set( ${_var} "" )
+    else()
+      get_filename_component( __gccExeName "${__gccExePath}" NAME_WE )
+      string( REPLACE "-gcc" "" ${_var} "${__gccExeName}" )
+    endif()
+    unset( __gccExePath )
+    unset( __gccExePathsCount )
+    unset( __gccExeName )
+  else()
+    set( ${_var} "" )
+  endif()
+endmacro()
+
+
+# fight against cygwin
+set( ANDROID_FORBID_SYGWIN TRUE CACHE BOOL "Prevent cmake from working under cygwin and using cygwin tools")
+mark_as_advanced( ANDROID_FORBID_SYGWIN )
+if( ANDROID_FORBID_SYGWIN )
+ if( CYGWIN )
+  message( FATAL_ERROR "Android NDK and android-cmake toolchain are not welcome Cygwin. It is unlikely that this cmake toolchain will work under cygwin. But if you want to try then you can set cmake variable ANDROID_FORBID_SYGWIN to FALSE and rerun cmake." )
+ endif()
+
+ if( CMAKE_HOST_WIN32 )
+  # remove cygwin from PATH
+  set( __new_path "$ENV{PATH}")
+  __LIST_FILTER( __new_path "cygwin" )
+  set(ENV{PATH} "${__new_path}")
+  unset(__new_path)
+ endif()
+endif()
+
+
+# detect current host platform
+if( NOT DEFINED ANDROID_NDK_HOST_X64 AND (CMAKE_HOST_SYSTEM_PROCESSOR MATCHES "amd64|x86_64|AMD64" OR CMAKE_HOST_APPLE) )
+ set( ANDROID_NDK_HOST_X64 1 CACHE BOOL "Try to use 64-bit compiler toolchain" )
+ mark_as_advanced( ANDROID_NDK_HOST_X64 )
+endif()
+
+set( TOOL_OS_SUFFIX "" )
+if( CMAKE_HOST_APPLE )
+ set( ANDROID_NDK_HOST_SYSTEM_NAME "darwin-x86_64" )
+ set( ANDROID_NDK_HOST_SYSTEM_NAME2 "darwin-x86" )
+elseif( CMAKE_HOST_WIN32 )
+ set( ANDROID_NDK_HOST_SYSTEM_NAME "windows-x86_64" )
+ set( ANDROID_NDK_HOST_SYSTEM_NAME2 "windows" )
+ set( TOOL_OS_SUFFIX ".exe" )
+elseif( CMAKE_HOST_UNIX )
+ set( ANDROID_NDK_HOST_SYSTEM_NAME "linux-x86_64" )
+ set( ANDROID_NDK_HOST_SYSTEM_NAME2 "linux-x86" )
+else()
+ message( FATAL_ERROR "Cross-compilation on your platform is not supported by this cmake toolchain" )
+endif()
+
+if( NOT ANDROID_NDK_HOST_X64 )
+ set( ANDROID_NDK_HOST_SYSTEM_NAME ${ANDROID_NDK_HOST_SYSTEM_NAME2} )
+endif()
+
+# see if we have path to Android NDK
+if( NOT ANDROID_NDK AND NOT ANDROID_STANDALONE_TOOLCHAIN )
+  __INIT_VARIABLE( ANDROID_NDK PATH ENV_ANDROID_NDK )
+endif()
+if( NOT ANDROID_NDK )
+ # see if we have path to Android standalone toolchain
+ __INIT_VARIABLE( ANDROID_STANDALONE_TOOLCHAIN PATH ENV_ANDROID_STANDALONE_TOOLCHAIN )
+
+ if( NOT ANDROID_STANDALONE_TOOLCHAIN )
+  #try to find Android NDK in one of the the default locations
+  set( __ndkSearchPaths )
+  foreach( __ndkSearchPath ${ANDROID_NDK_SEARCH_PATHS} )
+   foreach( suffix ${ANDROID_SUPPORTED_NDK_VERSIONS} )
+    list( APPEND __ndkSearchPaths "${__ndkSearchPath}/android-ndk${suffix}" )
+   endforeach()
+  endforeach()
+  __INIT_VARIABLE( ANDROID_NDK PATH VALUES ${__ndkSearchPaths} )
+  unset( __ndkSearchPaths )
+
+  if( ANDROID_NDK )
+   message( STATUS "Using default path for Android NDK: ${ANDROID_NDK}" )
+   message( STATUS "  If you prefer to use a different location, please define a cmake or environment variable: ANDROID_NDK" )
+  else()
+   #try to find Android standalone toolchain in one of the the default locations
+   __INIT_VARIABLE( ANDROID_STANDALONE_TOOLCHAIN PATH ANDROID_STANDALONE_TOOLCHAIN_SEARCH_PATH )
+
+   if( ANDROID_STANDALONE_TOOLCHAIN )
+    message( STATUS "Using default path for standalone toolchain ${ANDROID_STANDALONE_TOOLCHAIN}" )
+    message( STATUS "  If you prefer to use a different location, please define the variable: ANDROID_STANDALONE_TOOLCHAIN" )
+   endif( ANDROID_STANDALONE_TOOLCHAIN )
+  endif( ANDROID_NDK )
+ endif( NOT ANDROID_STANDALONE_TOOLCHAIN )
+endif( NOT ANDROID_NDK )
+
+# remember found paths
+if( ANDROID_NDK )
+ get_filename_component( ANDROID_NDK "${ANDROID_NDK}" ABSOLUTE )
+ set( ANDROID_NDK "${ANDROID_NDK}" CACHE INTERNAL "Path of the Android NDK" FORCE )
+ set( BUILD_WITH_ANDROID_NDK True )
+ if( EXISTS "${ANDROID_NDK}/RELEASE.TXT" )
+  file( STRINGS "${ANDROID_NDK}/RELEASE.TXT" ANDROID_NDK_RELEASE_FULL LIMIT_COUNT 1 REGEX "r[0-9]+[a-z]?" )
+  string( REGEX MATCH "r([0-9]+)([a-z]?)" ANDROID_NDK_RELEASE "${ANDROID_NDK_RELEASE_FULL}" )
+ else()
+  set( ANDROID_NDK_RELEASE "r1x" )
+  set( ANDROID_NDK_RELEASE_FULL "unreleased" )
+ endif()
+ string( REGEX REPLACE "r([0-9]+)([a-z]?)" "\\1*1000" ANDROID_NDK_RELEASE_NUM "${ANDROID_NDK_RELEASE}" )
+ string( FIND " abcdefghijklmnopqastuvwxyz" "${CMAKE_MATCH_2}" __ndkReleaseLetterNum )
+ math( EXPR ANDROID_NDK_RELEASE_NUM "${ANDROID_NDK_RELEASE_NUM}+${__ndkReleaseLetterNum}" )
+elseif( ANDROID_STANDALONE_TOOLCHAIN )
+ get_filename_component( ANDROID_STANDALONE_TOOLCHAIN "${ANDROID_STANDALONE_TOOLCHAIN}" ABSOLUTE )
+ # try to detect change
+ if( CMAKE_AR )
+  string( LENGTH "${ANDROID_STANDALONE_TOOLCHAIN}" __length )
+  string( SUBSTRING "${CMAKE_AR}" 0 ${__length} __androidStandaloneToolchainPreviousPath )
+  if( NOT __androidStandaloneToolchainPreviousPath STREQUAL ANDROID_STANDALONE_TOOLCHAIN )
+   message( FATAL_ERROR "It is not possible to change path to the Android standalone toolchain on subsequent run." )
+  endif()
+  unset( __androidStandaloneToolchainPreviousPath )
+  unset( __length )
+ endif()
+ set( ANDROID_STANDALONE_TOOLCHAIN "${ANDROID_STANDALONE_TOOLCHAIN}" CACHE INTERNAL "Path of the Android standalone toolchain" FORCE )
+ set( BUILD_WITH_STANDALONE_TOOLCHAIN True )
+else()
+ list(GET ANDROID_NDK_SEARCH_PATHS 0 ANDROID_NDK_SEARCH_PATH)
+ message( FATAL_ERROR "Could not find neither Android NDK nor Android standalone toolchain.
+    You should either set an environment variable:
+      export ANDROID_NDK=~/my-android-ndk
+    or
+      export ANDROID_STANDALONE_TOOLCHAIN=~/my-android-toolchain
+    or put the toolchain or NDK in the default path:
+      sudo ln -s ~/my-android-ndk ${ANDROID_NDK_SEARCH_PATH}/android-ndk
+      sudo ln -s ~/my-android-toolchain ${ANDROID_STANDALONE_TOOLCHAIN_SEARCH_PATH}" )
+endif()
+
+# android NDK layout
+if( BUILD_WITH_ANDROID_NDK )
+ if( NOT DEFINED ANDROID_NDK_LAYOUT )
+  # try to automatically detect the layout
+  if( EXISTS "${ANDROID_NDK}/RELEASE.TXT")
+   set( ANDROID_NDK_LAYOUT "RELEASE" )
+  elseif( EXISTS "${ANDROID_NDK}/../../linux-x86/toolchain/" )
+   set( ANDROID_NDK_LAYOUT "LINARO" )
+  elseif( EXISTS "${ANDROID_NDK}/../../gcc/" )
+   set( ANDROID_NDK_LAYOUT "ANDROID" )
+  endif()
+ endif()
+ set( ANDROID_NDK_LAYOUT "${ANDROID_NDK_LAYOUT}" CACHE STRING "The inner layout of NDK" )
+ mark_as_advanced( ANDROID_NDK_LAYOUT )
+ if( ANDROID_NDK_LAYOUT STREQUAL "LINARO" )
+  set( ANDROID_NDK_HOST_SYSTEM_NAME ${ANDROID_NDK_HOST_SYSTEM_NAME2} ) # only 32-bit at the moment
+  set( ANDROID_NDK_TOOLCHAINS_PATH "${ANDROID_NDK}/../../${ANDROID_NDK_HOST_SYSTEM_NAME}/toolchain" )
+  set( ANDROID_NDK_TOOLCHAINS_SUBPATH  "" )
+  set( ANDROID_NDK_TOOLCHAINS_SUBPATH2 "" )
+ elseif( ANDROID_NDK_LAYOUT STREQUAL "ANDROID" )
+  set( ANDROID_NDK_HOST_SYSTEM_NAME ${ANDROID_NDK_HOST_SYSTEM_NAME2} ) # only 32-bit at the moment
+  set( ANDROID_NDK_TOOLCHAINS_PATH "${ANDROID_NDK}/../../gcc/${ANDROID_NDK_HOST_SYSTEM_NAME}/arm" )
+  set( ANDROID_NDK_TOOLCHAINS_SUBPATH  "" )
+  set( ANDROID_NDK_TOOLCHAINS_SUBPATH2 "" )
+ else() # ANDROID_NDK_LAYOUT STREQUAL "RELEASE"
+  set( ANDROID_NDK_TOOLCHAINS_PATH "${ANDROID_NDK}/toolchains" )
+  set( ANDROID_NDK_TOOLCHAINS_SUBPATH  "/prebuilt/${ANDROID_NDK_HOST_SYSTEM_NAME}" )
+  set( ANDROID_NDK_TOOLCHAINS_SUBPATH2 "/prebuilt/${ANDROID_NDK_HOST_SYSTEM_NAME2}" )
+ endif()
+ get_filename_component( ANDROID_NDK_TOOLCHAINS_PATH "${ANDROID_NDK_TOOLCHAINS_PATH}" ABSOLUTE )
+
+ # try to detect change of NDK
+ if( CMAKE_AR )
+  string( LENGTH "${ANDROID_NDK_TOOLCHAINS_PATH}" __length )
+  string( SUBSTRING "${CMAKE_AR}" 0 ${__length} __androidNdkPreviousPath )
+  if( NOT __androidNdkPreviousPath STREQUAL ANDROID_NDK_TOOLCHAINS_PATH )
+   message( FATAL_ERROR "It is not possible to change the path to the NDK on subsequent CMake run. You must remove all generated files from your build folder first.
+   " )
+  endif()
+  unset( __androidNdkPreviousPath )
+  unset( __length )
+ endif()
+endif()
+
+
+# get all the details about standalone toolchain
+if( BUILD_WITH_STANDALONE_TOOLCHAIN )
+ __DETECT_NATIVE_API_LEVEL( ANDROID_SUPPORTED_NATIVE_API_LEVELS "${ANDROID_STANDALONE_TOOLCHAIN}/sysroot/usr/include/android/api-level.h" )
+ set( ANDROID_STANDALONE_TOOLCHAIN_API_LEVEL ${ANDROID_SUPPORTED_NATIVE_API_LEVELS} )
+ set( __availableToolchains "standalone" )
+ __DETECT_TOOLCHAIN_MACHINE_NAME( __availableToolchainMachines "${ANDROID_STANDALONE_TOOLCHAIN}" )
+ if( NOT __availableToolchainMachines )
+  message( FATAL_ERROR "Could not determine machine name of your toolchain. Probably your Android standalone toolchain is broken." )
+ endif()
+ if( __availableToolchainMachines MATCHES x86_64 )
+  set( __availableToolchainArchs "x86_64" )
+ elseif( __availableToolchainMachines MATCHES i686 )
+  set( __availableToolchainArchs "x86" )
+ elseif( __availableToolchainMachines MATCHES aarch64 )
+  set( __availableToolchainArchs "arm64" )
+ elseif( __availableToolchainMachines MATCHES arm )
+  set( __availableToolchainArchs "arm" )
+ elseif( __availableToolchainMachines MATCHES mips64el )
+  set( __availableToolchainArchs "mips64" )
+ elseif( __availableToolchainMachines MATCHES mipsel )
+  set( __availableToolchainArchs "mips" )
+ endif()
+ execute_process( COMMAND "${ANDROID_STANDALONE_TOOLCHAIN}/bin/${__availableToolchainMachines}-gcc${TOOL_OS_SUFFIX}" -dumpversion
+                  OUTPUT_VARIABLE __availableToolchainCompilerVersions OUTPUT_STRIP_TRAILING_WHITESPACE )
+ string( REGEX MATCH "[0-9]+[.][0-9]+([.][0-9]+)?" __availableToolchainCompilerVersions "${__availableToolchainCompilerVersions}" )
+ if( EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/bin/clang${TOOL_OS_SUFFIX}" )
+  list( APPEND __availableToolchains "standalone-clang" )
+  list( APPEND __availableToolchainMachines ${__availableToolchainMachines} )
+  list( APPEND __availableToolchainArchs ${__availableToolchainArchs} )
+  list( APPEND __availableToolchainCompilerVersions ${__availableToolchainCompilerVersions} )
+ endif()
+endif()
+
+macro( __GLOB_NDK_TOOLCHAINS __availableToolchainsVar __availableToolchainsLst __toolchain_subpath )
+ foreach( __toolchain ${${__availableToolchainsLst}} )
+  if( "${__toolchain}" MATCHES "-clang3[.][0-9]$" AND NOT EXISTS "${ANDROID_NDK_TOOLCHAINS_PATH}/${__toolchain}${__toolchain_subpath}" )
+   SET( __toolchainVersionRegex "^TOOLCHAIN_VERSION[\t ]+:=[\t ]+(.*)$" )
+   FILE( STRINGS "${ANDROID_NDK_TOOLCHAINS_PATH}/${__toolchain}/setup.mk" __toolchainVersionStr REGEX "${__toolchainVersionRegex}" )
+   if( __toolchainVersionStr )
+    string( REGEX REPLACE "${__toolchainVersionRegex}" "\\1" __toolchainVersionStr "${__toolchainVersionStr}" )
+    string( REGEX REPLACE "-clang3[.][0-9]$" "-${__toolchainVersionStr}" __gcc_toolchain "${__toolchain}" )
+   else()
+    string( REGEX REPLACE "-clang3[.][0-9]$" "-4.6" __gcc_toolchain "${__toolchain}" )
+   endif()
+   unset( __toolchainVersionStr )
+   unset( __toolchainVersionRegex )
+  else()
+   set( __gcc_toolchain "${__toolchain}" )
+  endif()
+  __DETECT_TOOLCHAIN_MACHINE_NAME( __machine "${ANDROID_NDK_TOOLCHAINS_PATH}/${__gcc_toolchain}${__toolchain_subpath}" )
+  if( __machine )
+   string( REGEX MATCH "[0-9]+[.][0-9]+([.][0-9x]+)?$" __version "${__gcc_toolchain}" )
+   if( __machine MATCHES x86_64 )
+    set( __arch "x86_64" )
+   elseif( __machine MATCHES i686 )
+    set( __arch "x86" )
+   elseif( __machine MATCHES aarch64 )
+    set( __arch "arm64" )
+   elseif( __machine MATCHES arm )
+    set( __arch "arm" )
+   elseif( __machine MATCHES mips64el )
+    set( __arch "mips64" )
+   elseif( __machine MATCHES mipsel )
+    set( __arch "mips" )
+   else()
+    set( __arch "" )
+   endif()
+   #message("machine: !${__machine}!\narch: !${__arch}!\nversion: !${__version}!\ntoolchain: !${__toolchain}!\n")
+   if (__arch)
+    list( APPEND __availableToolchainMachines "${__machine}" )
+    list( APPEND __availableToolchainArchs "${__arch}" )
+    list( APPEND __availableToolchainCompilerVersions "${__version}" )
+    list( APPEND ${__availableToolchainsVar} "${__toolchain}" )
+   endif()
+  endif()
+  unset( __gcc_toolchain )
+ endforeach()
+endmacro()
+
+# get all the details about NDK
+if( BUILD_WITH_ANDROID_NDK )
+ file( GLOB ANDROID_SUPPORTED_NATIVE_API_LEVELS RELATIVE "${ANDROID_NDK}/platforms" "${ANDROID_NDK}/platforms/android-*" )
+ string( REPLACE "android-" "" ANDROID_SUPPORTED_NATIVE_API_LEVELS "${ANDROID_SUPPORTED_NATIVE_API_LEVELS}" )
+ set( __availableToolchains "" )
+ set( __availableToolchainMachines "" )
+ set( __availableToolchainArchs "" )
+ set( __availableToolchainCompilerVersions "" )
+ if( ANDROID_TOOLCHAIN_NAME AND EXISTS "${ANDROID_NDK_TOOLCHAINS_PATH}/${ANDROID_TOOLCHAIN_NAME}/" )
+  # do not go through all toolchains if we know the name
+  set( __availableToolchainsLst "${ANDROID_TOOLCHAIN_NAME}" )
+  __GLOB_NDK_TOOLCHAINS( __availableToolchains __availableToolchainsLst "${ANDROID_NDK_TOOLCHAINS_SUBPATH}" )
+  if( NOT __availableToolchains AND NOT ANDROID_NDK_TOOLCHAINS_SUBPATH STREQUAL ANDROID_NDK_TOOLCHAINS_SUBPATH2 )
+   __GLOB_NDK_TOOLCHAINS( __availableToolchains __availableToolchainsLst "${ANDROID_NDK_TOOLCHAINS_SUBPATH2}" )
+   if( __availableToolchains )
+    set( ANDROID_NDK_TOOLCHAINS_SUBPATH ${ANDROID_NDK_TOOLCHAINS_SUBPATH2} )
+   endif()
+  endif()
+ endif()
+ if( NOT __availableToolchains )
+  file( GLOB __availableToolchainsLst RELATIVE "${ANDROID_NDK_TOOLCHAINS_PATH}" "${ANDROID_NDK_TOOLCHAINS_PATH}/*" )
+  if( __availableToolchainsLst )
+   list(SORT __availableToolchainsLst) # we need clang to go after gcc
+  endif()
+  __LIST_FILTER( __availableToolchainsLst "^[.]" )
+  __LIST_FILTER( __availableToolchainsLst "llvm" )
+  __LIST_FILTER( __availableToolchainsLst "renderscript" )
+  __GLOB_NDK_TOOLCHAINS( __availableToolchains __availableToolchainsLst "${ANDROID_NDK_TOOLCHAINS_SUBPATH}" )
+  if( NOT __availableToolchains AND NOT ANDROID_NDK_TOOLCHAINS_SUBPATH STREQUAL ANDROID_NDK_TOOLCHAINS_SUBPATH2 )
+   __GLOB_NDK_TOOLCHAINS( __availableToolchains __availableToolchainsLst "${ANDROID_NDK_TOOLCHAINS_SUBPATH2}" )
+   if( __availableToolchains )
+    set( ANDROID_NDK_TOOLCHAINS_SUBPATH ${ANDROID_NDK_TOOLCHAINS_SUBPATH2} )
+   endif()
+  endif()
+ endif()
+ if( NOT __availableToolchains )
+  message( FATAL_ERROR "Could not find any working toolchain in the NDK. Probably your Android NDK is broken." )
+ endif()
+endif()
+
+# build list of available ABIs
+set( ANDROID_SUPPORTED_ABIS "" )
+set( __uniqToolchainArchNames ${__availableToolchainArchs} )
+list( REMOVE_DUPLICATES __uniqToolchainArchNames )
+list( SORT __uniqToolchainArchNames )
+foreach( __arch ${__uniqToolchainArchNames} )
+ list( APPEND ANDROID_SUPPORTED_ABIS ${ANDROID_SUPPORTED_ABIS_${__arch}} )
+endforeach()
+unset( __uniqToolchainArchNames )
+if( NOT ANDROID_SUPPORTED_ABIS )
+ message( FATAL_ERROR "No one of known Android ABIs is supported by this cmake toolchain." )
+endif()
+
+# choose target ABI
+__INIT_VARIABLE( ANDROID_ABI VALUES ${ANDROID_SUPPORTED_ABIS} )
+# verify that target ABI is supported
+list( FIND ANDROID_SUPPORTED_ABIS "${ANDROID_ABI}" __androidAbiIdx )
+if( __androidAbiIdx EQUAL -1 )
+ string( REPLACE ";" "\", \"" PRINTABLE_ANDROID_SUPPORTED_ABIS  "${ANDROID_SUPPORTED_ABIS}" )
+ message( FATAL_ERROR "Specified ANDROID_ABI = \"${ANDROID_ABI}\" is not supported by this cmake toolchain or your NDK/toolchain.
+   Supported values are: \"${PRINTABLE_ANDROID_SUPPORTED_ABIS}\"
+   " )
+endif()
+unset( __androidAbiIdx )
+
+# set target ABI options
+if( ANDROID_ABI STREQUAL "x86" )
+ set( X86 true )
+ set( ANDROID_NDK_ABI_NAME "x86" )
+ set( ANDROID_ARCH_NAME "x86" )
+ set( ANDROID_LLVM_TRIPLE "i686-none-linux-android" )
+ set( CMAKE_SYSTEM_PROCESSOR "i686" )
+elseif( ANDROID_ABI STREQUAL "x86_64" )
+ set( X86 true )
+ set( X86_64 true )
+ set( ANDROID_NDK_ABI_NAME "x86_64" )
+ set( ANDROID_ARCH_NAME "x86_64" )
+ set( CMAKE_SYSTEM_PROCESSOR "x86_64" )
+ set( ANDROID_LLVM_TRIPLE "x86_64-none-linux-android" )
+elseif( ANDROID_ABI STREQUAL "mips64" )
+ set( MIPS64 true )
+ set( ANDROID_NDK_ABI_NAME "mips64" )
+ set( ANDROID_ARCH_NAME "mips64" )
+ set( ANDROID_LLVM_TRIPLE "mips64el-none-linux-android" )
+ set( CMAKE_SYSTEM_PROCESSOR "mips64" )
+elseif( ANDROID_ABI STREQUAL "mips" )
+ set( MIPS true )
+ set( ANDROID_NDK_ABI_NAME "mips" )
+ set( ANDROID_ARCH_NAME "mips" )
+ set( ANDROID_LLVM_TRIPLE "mipsel-none-linux-android" )
+ set( CMAKE_SYSTEM_PROCESSOR "mips" )
+elseif( ANDROID_ABI STREQUAL "arm64-v8a" )
+ set( ARM64_V8A true )
+ set( ANDROID_NDK_ABI_NAME "arm64-v8a" )
+ set( ANDROID_ARCH_NAME "arm64" )
+ set( ANDROID_LLVM_TRIPLE "aarch64-none-linux-android" )
+ set( CMAKE_SYSTEM_PROCESSOR "aarch64" )
+ set( VFPV3 true )
+ set( NEON true )
+elseif( ANDROID_ABI STREQUAL "armeabi" )
+ set( ARMEABI true )
+ set( ANDROID_NDK_ABI_NAME "armeabi" )
+ set( ANDROID_ARCH_NAME "arm" )
+ set( ANDROID_LLVM_TRIPLE "armv5te-none-linux-androideabi" )
+ set( CMAKE_SYSTEM_PROCESSOR "armv5te" )
+elseif( ANDROID_ABI STREQUAL "armeabi-v6 with VFP" )
+ set( ARMEABI_V6 true )
+ set( ANDROID_NDK_ABI_NAME "armeabi" )
+ set( ANDROID_ARCH_NAME "arm" )
+ set( ANDROID_LLVM_TRIPLE "armv5te-none-linux-androideabi" )
+ set( CMAKE_SYSTEM_PROCESSOR "armv6" )
+ # need always fallback to older platform
+ set( ARMEABI true )
+elseif( ANDROID_ABI STREQUAL "armeabi-v7a")
+ set( ARMEABI_V7A true )
+ set( ANDROID_NDK_ABI_NAME "armeabi-v7a" )
+ set( ANDROID_ARCH_NAME "arm" )
+ set( ANDROID_LLVM_TRIPLE "armv7-none-linux-androideabi" )
+ set( CMAKE_SYSTEM_PROCESSOR "armv7-a" )
+elseif( ANDROID_ABI STREQUAL "armeabi-v7a with VFPV3" )
+ set( ARMEABI_V7A true )
+ set( ANDROID_NDK_ABI_NAME "armeabi-v7a" )
+ set( ANDROID_ARCH_NAME "arm" )
+ set( ANDROID_LLVM_TRIPLE "armv7-none-linux-androideabi" )
+ set( CMAKE_SYSTEM_PROCESSOR "armv7-a" )
+ set( VFPV3 true )
+elseif( ANDROID_ABI STREQUAL "armeabi-v7a with NEON" )
+ set( ARMEABI_V7A true )
+ set( ANDROID_NDK_ABI_NAME "armeabi-v7a" )
+ set( ANDROID_ARCH_NAME "arm" )
+ set( ANDROID_LLVM_TRIPLE "armv7-none-linux-androideabi" )
+ set( CMAKE_SYSTEM_PROCESSOR "armv7-a" )
+ set( VFPV3 true )
+ set( NEON true )
+else()
+ message( SEND_ERROR "Unknown ANDROID_ABI=\"${ANDROID_ABI}\" is specified." )
+endif()
+
+if( CMAKE_BINARY_DIR AND EXISTS "${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeSystem.cmake" )
+ # really dirty hack
+ # it is not possible to change CMAKE_SYSTEM_PROCESSOR after the first run...
+ file( APPEND "${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeSystem.cmake" "SET(CMAKE_SYSTEM_PROCESSOR \"${CMAKE_SYSTEM_PROCESSOR}\")\n" )
+endif()
+
+if( ANDROID_ARCH_NAME STREQUAL "arm" AND NOT ARMEABI_V6 )
+ __INIT_VARIABLE( ANDROID_FORCE_ARM_BUILD VALUES OFF )
+ set( ANDROID_FORCE_ARM_BUILD ${ANDROID_FORCE_ARM_BUILD} CACHE BOOL "Use 32-bit ARM instructions instead of Thumb-1" FORCE )
+ mark_as_advanced( ANDROID_FORCE_ARM_BUILD )
+else()
+ unset( ANDROID_FORCE_ARM_BUILD CACHE )
+endif()
+
+# choose toolchain
+if( ANDROID_TOOLCHAIN_NAME )
+ list( FIND __availableToolchains "${ANDROID_TOOLCHAIN_NAME}" __toolchainIdx )
+ if( __toolchainIdx EQUAL -1 )
+  list( SORT __availableToolchains )
+  string( REPLACE ";" "\n  * " toolchains_list "${__availableToolchains}" )
+  set( toolchains_list "  * ${toolchains_list}")
+  message( FATAL_ERROR "Specified toolchain \"${ANDROID_TOOLCHAIN_NAME}\" is missing in your NDK or broken. Please verify that your NDK is working or select another compiler toolchain.
+To configure the toolchain set CMake variable ANDROID_TOOLCHAIN_NAME to one of the following values:\n${toolchains_list}\n" )
+ endif()
+ list( GET __availableToolchainArchs ${__toolchainIdx} __toolchainArch )
+ if( NOT __toolchainArch STREQUAL ANDROID_ARCH_NAME )
+  message( SEND_ERROR "Selected toolchain \"${ANDROID_TOOLCHAIN_NAME}\" is not able to compile binaries for the \"${ANDROID_ARCH_NAME}\" platform." )
+ endif()
+else()
+ set( __toolchainIdx -1 )
+ set( __applicableToolchains "" )
+ set( __toolchainMaxVersion "0.0.0" )
+ list( LENGTH __availableToolchains __availableToolchainsCount )
+ math( EXPR __availableToolchainsCount "${__availableToolchainsCount}-1" )
+ foreach( __idx RANGE ${__availableToolchainsCount} )
+  list( GET __availableToolchainArchs ${__idx} __toolchainArch )
+  if( __toolchainArch STREQUAL ANDROID_ARCH_NAME )
+   list( GET __availableToolchainCompilerVersions ${__idx} __toolchainVersion )
+   string( REPLACE "x" "99" __toolchainVersion "${__toolchainVersion}")
+   if( __toolchainVersion VERSION_GREATER __toolchainMaxVersion )
+    set( __toolchainMaxVersion "${__toolchainVersion}" )
+    set( __toolchainIdx ${__idx} )
+   endif()
+  endif()
+ endforeach()
+ unset( __availableToolchainsCount )
+ unset( __toolchainMaxVersion )
+ unset( __toolchainVersion )
+endif()
+unset( __toolchainArch )
+if( __toolchainIdx EQUAL -1 )
+ message( FATAL_ERROR "No one of available compiler toolchains is able to compile for ${ANDROID_ARCH_NAME} platform." )
+endif()
+list( GET __availableToolchains ${__toolchainIdx} ANDROID_TOOLCHAIN_NAME )
+list( GET __availableToolchainMachines ${__toolchainIdx} ANDROID_TOOLCHAIN_MACHINE_NAME )
+list( GET __availableToolchainCompilerVersions ${__toolchainIdx} ANDROID_COMPILER_VERSION )
+
+unset( __toolchainIdx )
+unset( __availableToolchains )
+unset( __availableToolchainMachines )
+unset( __availableToolchainArchs )
+unset( __availableToolchainCompilerVersions )
+
+# choose native API level
+__INIT_VARIABLE( ANDROID_NATIVE_API_LEVEL ENV_ANDROID_NATIVE_API_LEVEL ANDROID_API_LEVEL ENV_ANDROID_API_LEVEL ANDROID_STANDALONE_TOOLCHAIN_API_LEVEL ANDROID_DEFAULT_NDK_API_LEVEL_${ANDROID_ARCH_NAME} ANDROID_DEFAULT_NDK_API_LEVEL )
+string( REPLACE "android-" "" ANDROID_NATIVE_API_LEVEL "${ANDROID_NATIVE_API_LEVEL}" )
+string( STRIP "${ANDROID_NATIVE_API_LEVEL}" ANDROID_NATIVE_API_LEVEL )
+# adjust API level
+set( __real_api_level ${ANDROID_DEFAULT_NDK_API_LEVEL_${ANDROID_ARCH_NAME}} )
+foreach( __level ${ANDROID_SUPPORTED_NATIVE_API_LEVELS} )
+ if( (__level LESS ANDROID_NATIVE_API_LEVEL OR __level STREQUAL ANDROID_NATIVE_API_LEVEL) AND NOT __level LESS __real_api_level )
+  set( __real_api_level ${__level} )
+ endif()
+endforeach()
+if( __real_api_level AND NOT ANDROID_NATIVE_API_LEVEL STREQUAL __real_api_level )
+ message( STATUS "Adjusting Android API level 'android-${ANDROID_NATIVE_API_LEVEL}' to 'android-${__real_api_level}'")
+ set( ANDROID_NATIVE_API_LEVEL ${__real_api_level} )
+endif()
+unset(__real_api_level)
+# validate
+list( FIND ANDROID_SUPPORTED_NATIVE_API_LEVELS "${ANDROID_NATIVE_API_LEVEL}" __levelIdx )
+if( __levelIdx EQUAL -1 )
+ message( SEND_ERROR "Specified Android native API level 'android-${ANDROID_NATIVE_API_LEVEL}' is not supported by your NDK/toolchain." )
+else()
+ if( BUILD_WITH_ANDROID_NDK )
+  __DETECT_NATIVE_API_LEVEL( __realApiLevel "${ANDROID_NDK}/platforms/android-${ANDROID_NATIVE_API_LEVEL}/arch-${ANDROID_ARCH_NAME}/usr/include/android/api-level.h" )
+  if( NOT __realApiLevel EQUAL ANDROID_NATIVE_API_LEVEL AND NOT __realApiLevel GREATER 9000 )
+   message( SEND_ERROR "Specified Android API level (${ANDROID_NATIVE_API_LEVEL}) does not match to the level found (${__realApiLevel}). Probably your copy of NDK is broken." )
+  endif()
+  unset( __realApiLevel )
+ endif()
+ set( ANDROID_NATIVE_API_LEVEL "${ANDROID_NATIVE_API_LEVEL}" CACHE STRING "Android API level for native code" FORCE )
+ set( CMAKE_ANDROID_API ${ANDROID_NATIVE_API_LEVEL} )
+ if( CMAKE_VERSION VERSION_GREATER "2.8" )
+  list( SORT ANDROID_SUPPORTED_NATIVE_API_LEVELS )
+  set_property( CACHE ANDROID_NATIVE_API_LEVEL PROPERTY STRINGS ${ANDROID_SUPPORTED_NATIVE_API_LEVELS} )
+ endif()
+endif()
+unset( __levelIdx )
+
+
+# remember target ABI
+set( ANDROID_ABI "${ANDROID_ABI}" CACHE STRING "The target ABI for Android. If arm, then armeabi-v7a is recommended for hardware floating point." FORCE )
+if( CMAKE_VERSION VERSION_GREATER "2.8" )
+ list( SORT ANDROID_SUPPORTED_ABIS_${ANDROID_ARCH_NAME} )
+ set_property( CACHE ANDROID_ABI PROPERTY STRINGS ${ANDROID_SUPPORTED_ABIS_${ANDROID_ARCH_NAME}} )
+endif()
+
+
+# runtime choice (STL, rtti, exceptions)
+if( NOT ANDROID_STL )
+  set( ANDROID_STL gnustl_static )
+endif()
+set( ANDROID_STL "${ANDROID_STL}" CACHE STRING "C++ runtime" )
+set( ANDROID_STL_FORCE_FEATURES ON CACHE BOOL "automatically configure rtti and exceptions support based on C++ runtime" )
+mark_as_advanced( ANDROID_STL ANDROID_STL_FORCE_FEATURES )
+
+if( BUILD_WITH_ANDROID_NDK )
+ if( NOT "${ANDROID_STL}" MATCHES "^(none|system|system_re|gabi\\+\\+_static|gabi\\+\\+_shared|stlport_static|stlport_shared|gnustl_static|gnustl_shared)$")
+  message( FATAL_ERROR "ANDROID_STL is set to invalid value \"${ANDROID_STL}\".
+The possible values are:
+  none           -> Do not configure the runtime.
+  system         -> Use the default minimal system C++ runtime library.
+  system_re      -> Same as system but with rtti and exceptions.
+  gabi++_static  -> Use the GAbi++ runtime as a static library.
+  gabi++_shared  -> Use the GAbi++ runtime as a shared library.
+  stlport_static -> Use the STLport runtime as a static library.
+  stlport_shared -> Use the STLport runtime as a shared library.
+  gnustl_static  -> (default) Use the GNU STL as a static library.
+  gnustl_shared  -> Use the GNU STL as a shared library.
+" )
+ endif()
+elseif( BUILD_WITH_STANDALONE_TOOLCHAIN )
+ if( NOT "${ANDROID_STL}" MATCHES "^(none|gnustl_static|gnustl_shared)$")
+  message( FATAL_ERROR "ANDROID_STL is set to invalid value \"${ANDROID_STL}\".
+The possible values are:
+  none           -> Do not configure the runtime.
+  gnustl_static  -> (default) Use the GNU STL as a static library.
+  gnustl_shared  -> Use the GNU STL as a shared library.
+" )
+ endif()
+endif()
+
+unset( ANDROID_RTTI )
+unset( ANDROID_EXCEPTIONS )
+unset( ANDROID_STL_INCLUDE_DIRS )
+unset( __libstl )
+unset( __libsupcxx )
+
+if( NOT _CMAKE_IN_TRY_COMPILE AND ANDROID_NDK_RELEASE STREQUAL "r7b" AND ARMEABI_V7A AND NOT VFPV3 AND ANDROID_STL MATCHES "gnustl" )
+ message( WARNING  "The GNU STL armeabi-v7a binaries from NDK r7b can crash non-NEON devices. The files provided with NDK r7b were not configured properly, resulting in crashes on Tegra2-based devices and others when trying to use certain floating-point functions (e.g., cosf, sinf, expf).
+You are strongly recommended to switch to another NDK release.
+" )
+endif()
+
+if( NOT _CMAKE_IN_TRY_COMPILE AND X86 AND ANDROID_STL MATCHES "gnustl" AND ANDROID_NDK_RELEASE STREQUAL "r6" )
+  message( WARNING  "The x86 system header file from NDK r6 has incorrect definition for ptrdiff_t. You are recommended to upgrade to a newer NDK release or manually patch the header:
+See https://android.googlesource.com/platform/development.git f907f4f9d4e56ccc8093df6fee54454b8bcab6c2
+  diff --git a/ndk/platforms/android-9/arch-x86/include/machine/_types.h b/ndk/platforms/android-9/arch-x86/include/machine/_types.h
+  index 5e28c64..65892a1 100644
+  --- a/ndk/platforms/android-9/arch-x86/include/machine/_types.h
+  +++ b/ndk/platforms/android-9/arch-x86/include/machine/_types.h
+  @@ -51,7 +51,11 @@ typedef long int       ssize_t;
+   #endif
+   #ifndef _PTRDIFF_T
+   #define _PTRDIFF_T
+  -typedef long           ptrdiff_t;
+  +#  ifdef __ANDROID__
+  +     typedef int            ptrdiff_t;
+  +#  else
+  +     typedef long           ptrdiff_t;
+  +#  endif
+   #endif
+" )
+endif()
+
+
+# setup paths and STL for standalone toolchain
+if( BUILD_WITH_STANDALONE_TOOLCHAIN )
+ set( ANDROID_TOOLCHAIN_ROOT "${ANDROID_STANDALONE_TOOLCHAIN}" )
+ set( ANDROID_CLANG_TOOLCHAIN_ROOT "${ANDROID_STANDALONE_TOOLCHAIN}" )
+ set( ANDROID_SYSROOT "${ANDROID_STANDALONE_TOOLCHAIN}/sysroot" )
+
+ if( NOT ANDROID_STL STREQUAL "none" )
+  set( ANDROID_STL_INCLUDE_DIRS "${ANDROID_STANDALONE_TOOLCHAIN}/include/c++/${ANDROID_COMPILER_VERSION}" )
+  if( NOT EXISTS "${ANDROID_STL_INCLUDE_DIRS}" )
+   # old location ( pre r8c )
+   set( ANDROID_STL_INCLUDE_DIRS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/include/c++/${ANDROID_COMPILER_VERSION}" )
+  endif()
+  if( ARMEABI_V7A AND EXISTS "${ANDROID_STL_INCLUDE_DIRS}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/${CMAKE_SYSTEM_PROCESSOR}/bits" )
+   list( APPEND ANDROID_STL_INCLUDE_DIRS "${ANDROID_STL_INCLUDE_DIRS}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/${CMAKE_SYSTEM_PROCESSOR}" )
+  elseif( ARMEABI AND NOT ANDROID_FORCE_ARM_BUILD AND EXISTS "${ANDROID_STL_INCLUDE_DIRS}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/thumb/bits" )
+   list( APPEND ANDROID_STL_INCLUDE_DIRS "${ANDROID_STL_INCLUDE_DIRS}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/thumb" )
+  else()
+   list( APPEND ANDROID_STL_INCLUDE_DIRS "${ANDROID_STL_INCLUDE_DIRS}/${ANDROID_TOOLCHAIN_MACHINE_NAME}" )
+  endif()
+  # always search static GNU STL to get the location of libsupc++.a
+  if( ARMEABI_V7A AND NOT ANDROID_FORCE_ARM_BUILD AND EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/thumb/libstdc++.a" )
+   set( __libstl "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/thumb" )
+  elseif( ARMEABI_V7A AND EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/libstdc++.a" )
+   set( __libstl "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}" )
+  elseif( ARMEABI AND NOT ANDROID_FORCE_ARM_BUILD AND EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/thumb/libstdc++.a" )
+   set( __libstl "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/thumb" )
+  elseif( EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/libstdc++.a" )
+   set( __libstl "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib" )
+  endif()
+  if( __libstl )
+   set( __libsupcxx "${__libstl}/libsupc++.a" )
+   set( __libstl    "${__libstl}/libstdc++.a" )
+  endif()
+  if( NOT EXISTS "${__libsupcxx}" )
+   message( FATAL_ERROR "The required libstdsupc++.a is missing in your standalone toolchain.
+ Usually it happens because of bug in make-standalone-toolchain.sh script from NDK r7, r7b and r7c.
+ You need to either upgrade to newer NDK or manually copy
+     $ANDROID_NDK/sources/cxx-stl/gnu-libstdc++/libs/${ANDROID_NDK_ABI_NAME}/libsupc++.a
+ to
+     ${__libsupcxx}
+   " )
+  endif()
+  if( ANDROID_STL STREQUAL "gnustl_shared" )
+   if( ARMEABI_V7A AND EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/libgnustl_shared.so" )
+    set( __libstl "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/libgnustl_shared.so" )
+   elseif( ARMEABI AND NOT ANDROID_FORCE_ARM_BUILD AND EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/thumb/libgnustl_shared.so" )
+    set( __libstl "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/thumb/libgnustl_shared.so" )
+   elseif( EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/libgnustl_shared.so" )
+    set( __libstl "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/libgnustl_shared.so" )
+   endif()
+  endif()
+ endif()
+endif()
+
+# clang
+if( "${ANDROID_TOOLCHAIN_NAME}" STREQUAL "standalone-clang" )
+ set( ANDROID_COMPILER_IS_CLANG 1 )
+ execute_process( COMMAND "${ANDROID_CLANG_TOOLCHAIN_ROOT}/bin/clang${TOOL_OS_SUFFIX}" --version OUTPUT_VARIABLE ANDROID_CLANG_VERSION OUTPUT_STRIP_TRAILING_WHITESPACE )
+ string( REGEX MATCH "[0-9]+[.][0-9]+" ANDROID_CLANG_VERSION "${ANDROID_CLANG_VERSION}")
+elseif( "${ANDROID_TOOLCHAIN_NAME}" MATCHES "-clang3[.][0-9]?$" )
+ string( REGEX MATCH "3[.][0-9]$" ANDROID_CLANG_VERSION "${ANDROID_TOOLCHAIN_NAME}")
+ string( REGEX REPLACE "-clang${ANDROID_CLANG_VERSION}$" "-${ANDROID_COMPILER_VERSION}" ANDROID_GCC_TOOLCHAIN_NAME "${ANDROID_TOOLCHAIN_NAME}" )
+ if( NOT EXISTS "${ANDROID_NDK_TOOLCHAINS_PATH}/llvm-${ANDROID_CLANG_VERSION}${ANDROID_NDK_TOOLCHAINS_SUBPATH}/bin/clang${TOOL_OS_SUFFIX}" )
+  message( FATAL_ERROR "Could not find the Clang compiler driver" )
+ endif()
+ set( ANDROID_COMPILER_IS_CLANG 1 )
+ set( ANDROID_CLANG_TOOLCHAIN_ROOT "${ANDROID_NDK_TOOLCHAINS_PATH}/llvm-${ANDROID_CLANG_VERSION}${ANDROID_NDK_TOOLCHAINS_SUBPATH}" )
+else()
+ set( ANDROID_GCC_TOOLCHAIN_NAME "${ANDROID_TOOLCHAIN_NAME}" )
+ unset( ANDROID_COMPILER_IS_CLANG CACHE )
+endif()
+
+string( REPLACE "." "" _clang_name "clang${ANDROID_CLANG_VERSION}" )
+if( NOT EXISTS "${ANDROID_CLANG_TOOLCHAIN_ROOT}/bin/${_clang_name}${TOOL_OS_SUFFIX}" )
+ set( _clang_name "clang" )
+endif()
+
+
+# setup paths and STL for NDK
+if( BUILD_WITH_ANDROID_NDK )
+ set( ANDROID_TOOLCHAIN_ROOT "${ANDROID_NDK_TOOLCHAINS_PATH}/${ANDROID_GCC_TOOLCHAIN_NAME}${ANDROID_NDK_TOOLCHAINS_SUBPATH}" )
+ set( ANDROID_SYSROOT "${ANDROID_NDK}/platforms/android-${ANDROID_NATIVE_API_LEVEL}/arch-${ANDROID_ARCH_NAME}" )
+
+ if( ANDROID_STL STREQUAL "none" )
+  # do nothing
+ elseif( ANDROID_STL STREQUAL "system" )
+  set( ANDROID_RTTI             OFF )
+  set( ANDROID_EXCEPTIONS       OFF )
+  set( ANDROID_STL_INCLUDE_DIRS "${ANDROID_NDK}/sources/cxx-stl/system/include" )
+ elseif( ANDROID_STL STREQUAL "system_re" )
+  set( ANDROID_RTTI             ON )
+  set( ANDROID_EXCEPTIONS       ON )
+  set( ANDROID_STL_INCLUDE_DIRS "${ANDROID_NDK}/sources/cxx-stl/system/include" )
+ elseif( ANDROID_STL MATCHES "gabi" )
+  if( ANDROID_NDK_RELEASE_NUM LESS 7000 ) # before r7
+   message( FATAL_ERROR "gabi++ is not available in your NDK. You have to upgrade to NDK r7 or newer to use gabi++.")
+  endif()
+  set( ANDROID_RTTI             ON )
+  set( ANDROID_EXCEPTIONS       OFF )
+  set( ANDROID_STL_INCLUDE_DIRS "${ANDROID_NDK}/sources/cxx-stl/gabi++/include" )
+  set( __libstl                 "${ANDROID_NDK}/sources/cxx-stl/gabi++/libs/${ANDROID_NDK_ABI_NAME}/libgabi++_static.a" )
+ elseif( ANDROID_STL MATCHES "stlport" )
+  if( NOT ANDROID_NDK_RELEASE_NUM LESS 8004 ) # before r8d
+   set( ANDROID_EXCEPTIONS       ON )
+  else()
+   set( ANDROID_EXCEPTIONS       OFF )
+  endif()
+  if( ANDROID_NDK_RELEASE_NUM LESS 7000 ) # before r7
+   set( ANDROID_RTTI            OFF )
+  else()
+   set( ANDROID_RTTI            ON )
+  endif()
+  set( ANDROID_STL_INCLUDE_DIRS "${ANDROID_NDK}/sources/cxx-stl/stlport/stlport" )
+  set( __libstl                 "${ANDROID_NDK}/sources/cxx-stl/stlport/libs/${ANDROID_NDK_ABI_NAME}/libstlport_static.a" )
+ elseif( ANDROID_STL MATCHES "gnustl" )
+  set( ANDROID_EXCEPTIONS       ON )
+  set( ANDROID_RTTI             ON )
+  if( EXISTS "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++/${ANDROID_COMPILER_VERSION}" )
+   if( ARMEABI_V7A AND ANDROID_COMPILER_VERSION VERSION_EQUAL "4.7" AND ANDROID_NDK_RELEASE STREQUAL "r8d" )
+    # gnustl binary for 4.7 compiler is buggy :(
+    # TODO: look for right fix
+    set( __libstl                "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++/4.6" )
+   else()
+    set( __libstl                "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++/${ANDROID_COMPILER_VERSION}" )
+   endif()
+  else()
+   set( __libstl                "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++" )
+  endif()
+  set( ANDROID_STL_INCLUDE_DIRS "${__libstl}/include" "${__libstl}/libs/${ANDROID_NDK_ABI_NAME}/include" "${__libstl}/include/backward" )
+  if( EXISTS "${__libstl}/libs/${ANDROID_NDK_ABI_NAME}/libgnustl_static.a" )
+   set( __libstl                "${__libstl}/libs/${ANDROID_NDK_ABI_NAME}/libgnustl_static.a" )
+  else()
+   set( __libstl                "${__libstl}/libs/${ANDROID_NDK_ABI_NAME}/libstdc++.a" )
+  endif()
+ else()
+  message( FATAL_ERROR "Unknown runtime: ${ANDROID_STL}" )
+ endif()
+ # find libsupc++.a - rtti & exceptions
+ if( ANDROID_STL STREQUAL "system_re" OR ANDROID_STL MATCHES "gnustl" )
+  set( __libsupcxx "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++/${ANDROID_COMPILER_VERSION}/libs/${ANDROID_NDK_ABI_NAME}/libsupc++.a" ) # r8b or newer
+  if( NOT EXISTS "${__libsupcxx}" )
+   set( __libsupcxx "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++/libs/${ANDROID_NDK_ABI_NAME}/libsupc++.a" ) # r7-r8
+  endif()
+  if( NOT EXISTS "${__libsupcxx}" ) # before r7
+   if( ARMEABI_V7A )
+    if( ANDROID_FORCE_ARM_BUILD )
+     set( __libsupcxx "${ANDROID_TOOLCHAIN_ROOT}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/libsupc++.a" )
+    else()
+     set( __libsupcxx "${ANDROID_TOOLCHAIN_ROOT}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/thumb/libsupc++.a" )
+    endif()
+   elseif( ARMEABI AND NOT ANDROID_FORCE_ARM_BUILD )
+    set( __libsupcxx "${ANDROID_TOOLCHAIN_ROOT}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/thumb/libsupc++.a" )
+   else()
+    set( __libsupcxx "${ANDROID_TOOLCHAIN_ROOT}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/libsupc++.a" )
+   endif()
+  endif()
+  if( NOT EXISTS "${__libsupcxx}")
+   message( ERROR "Could not find libsupc++.a for a chosen platform. Either your NDK is not supported or is broken.")
+  endif()
+ endif()
+endif()
+
+
+# case of shared STL linkage
+if( ANDROID_STL MATCHES "shared" AND DEFINED __libstl )
+ string( REPLACE "_static.a" "_shared.so" __libstl "${__libstl}" )
+ # TODO: check if .so file exists before the renaming
+endif()
+
+
+# ccache support
+__INIT_VARIABLE( _ndk_ccache NDK_CCACHE ENV_NDK_CCACHE )
+if( _ndk_ccache )
+ if( DEFINED NDK_CCACHE AND NOT EXISTS NDK_CCACHE )
+  unset( NDK_CCACHE CACHE )
+ endif()
+ find_program( NDK_CCACHE "${_ndk_ccache}" DOC "The path to ccache binary")
+else()
+ unset( NDK_CCACHE CACHE )
+endif()
+unset( _ndk_ccache )
+
+
+# setup the cross-compiler
+if( NOT CMAKE_C_COMPILER )
+ if( NDK_CCACHE AND NOT ANDROID_SYSROOT MATCHES "[ ;\"]" )
+  set( CMAKE_C_COMPILER   "${NDK_CCACHE}" CACHE PATH "ccache as C compiler" )
+  set( CMAKE_CXX_COMPILER "${NDK_CCACHE}" CACHE PATH "ccache as C++ compiler" )
+  if( ANDROID_COMPILER_IS_CLANG )
+   set( CMAKE_C_COMPILER_ARG1   "${ANDROID_CLANG_TOOLCHAIN_ROOT}/bin/${_clang_name}${TOOL_OS_SUFFIX}"   CACHE PATH "C compiler")
+   set( CMAKE_CXX_COMPILER_ARG1 "${ANDROID_CLANG_TOOLCHAIN_ROOT}/bin/${_clang_name}++${TOOL_OS_SUFFIX}" CACHE PATH "C++ compiler")
+  else()
+   set( CMAKE_C_COMPILER_ARG1   "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-gcc${TOOL_OS_SUFFIX}" CACHE PATH "C compiler")
+   set( CMAKE_CXX_COMPILER_ARG1 "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-g++${TOOL_OS_SUFFIX}" CACHE PATH "C++ compiler")
+  endif()
+ else()
+  if( ANDROID_COMPILER_IS_CLANG )
+   set( CMAKE_C_COMPILER   "${ANDROID_CLANG_TOOLCHAIN_ROOT}/bin/${_clang_name}${TOOL_OS_SUFFIX}"   CACHE PATH "C compiler")
+   set( CMAKE_CXX_COMPILER "${ANDROID_CLANG_TOOLCHAIN_ROOT}/bin/${_clang_name}++${TOOL_OS_SUFFIX}" CACHE PATH "C++ compiler")
+  else()
+   set( CMAKE_C_COMPILER   "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-gcc${TOOL_OS_SUFFIX}"    CACHE PATH "C compiler" )
+   set( CMAKE_CXX_COMPILER "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-g++${TOOL_OS_SUFFIX}"    CACHE PATH "C++ compiler" )
+  endif()
+ endif()
+ set( CMAKE_ASM_COMPILER "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-gcc${TOOL_OS_SUFFIX}"     CACHE PATH "assembler" )
+ set( CMAKE_STRIP        "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-strip${TOOL_OS_SUFFIX}"   CACHE PATH "strip" )
+ if( EXISTS "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-gcc-ar${TOOL_OS_SUFFIX}" )
+  # Use gcc-ar if we have it for better LTO support.
+  set( CMAKE_AR           "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-gcc-ar${TOOL_OS_SUFFIX}"      CACHE PATH "archive" )
+ else()
+  set( CMAKE_AR           "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-ar${TOOL_OS_SUFFIX}"      CACHE PATH "archive" )
+ endif()
+ set( CMAKE_LINKER       "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-ld${TOOL_OS_SUFFIX}"      CACHE PATH "linker" )
+ set( CMAKE_NM           "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-nm${TOOL_OS_SUFFIX}"      CACHE PATH "nm" )
+ set( CMAKE_OBJCOPY      "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-objcopy${TOOL_OS_SUFFIX}" CACHE PATH "objcopy" )
+ set( CMAKE_OBJDUMP      "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-objdump${TOOL_OS_SUFFIX}" CACHE PATH "objdump" )
+ set( CMAKE_RANLIB       "${ANDROID_TOOLCHAIN_ROOT}/bin/${ANDROID_TOOLCHAIN_MACHINE_NAME}-ranlib${TOOL_OS_SUFFIX}"  CACHE PATH "ranlib" )
+endif()
+
+set( _CMAKE_TOOLCHAIN_PREFIX "${ANDROID_TOOLCHAIN_MACHINE_NAME}-" )
+if( CMAKE_VERSION VERSION_LESS 2.8.5 )
+ set( CMAKE_ASM_COMPILER_ARG1 "-c" )
+endif()
+if( APPLE )
+ find_program( CMAKE_INSTALL_NAME_TOOL NAMES install_name_tool )
+ if( NOT CMAKE_INSTALL_NAME_TOOL )
+  message( FATAL_ERROR "Could not find install_name_tool, please check your installation." )
+ endif()
+ mark_as_advanced( CMAKE_INSTALL_NAME_TOOL )
+endif()
+
+# Force set compilers because standard identification works badly for us
+include( CMakeForceCompiler )
+# CMAKE_FORCE_C_COMPILER( "${CMAKE_C_COMPILER}" GNU )
+if( ANDROID_COMPILER_IS_CLANG )
+ set( CMAKE_C_COMPILER_ID Clang )
+endif()
+set( CMAKE_C_PLATFORM_ID Linux )
+if( X86_64 OR MIPS64 OR ARM64_V8A )
+ set( CMAKE_C_SIZEOF_DATA_PTR 8 )
+else()
+ set( CMAKE_C_SIZEOF_DATA_PTR 4 )
+endif()
+set( CMAKE_C_HAS_ISYSROOT 1 )
+set( CMAKE_C_COMPILER_ABI ELF )
+# CMAKE_FORCE_CXX_COMPILER( "${CMAKE_CXX_COMPILER}" GNU )
+if( ANDROID_COMPILER_IS_CLANG )
+ set( CMAKE_CXX_COMPILER_ID Clang)
+endif()
+set( CMAKE_CXX_PLATFORM_ID Linux )
+set( CMAKE_CXX_SIZEOF_DATA_PTR ${CMAKE_C_SIZEOF_DATA_PTR} )
+set( CMAKE_CXX_HAS_ISYSROOT 1 )
+set( CMAKE_CXX_COMPILER_ABI ELF )
+set( CMAKE_CXX_SOURCE_FILE_EXTENSIONS cc cp cxx cpp CPP c++ C )
+# force ASM compiler (required for CMake < 2.8.5)
+set( CMAKE_ASM_COMPILER_ID_RUN TRUE )
+set( CMAKE_ASM_COMPILER_ID GNU )
+set( CMAKE_ASM_COMPILER_WORKS TRUE )
+set( CMAKE_ASM_COMPILER_FORCED TRUE )
+set( CMAKE_COMPILER_IS_GNUASM 1)
+set( CMAKE_ASM_SOURCE_FILE_EXTENSIONS s S asm )
+
+foreach( lang C CXX ASM )
+ if( ANDROID_COMPILER_IS_CLANG )
+  set( CMAKE_${lang}_COMPILER_VERSION ${ANDROID_CLANG_VERSION} )
+ else()
+  set( CMAKE_${lang}_COMPILER_VERSION ${ANDROID_COMPILER_VERSION} )
+ endif()
+endforeach()
+
+# flags and definitions
+remove_definitions( -DANDROID )
+add_definitions( -DANDROID )
+
+if( ANDROID_SYSROOT MATCHES "[ ;\"]" )
+ if( CMAKE_HOST_WIN32 )
+  # try to convert path to 8.3 form
+  file( WRITE "${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/cvt83.cmd" "@echo %~s1" )
+  execute_process( COMMAND "$ENV{ComSpec}" /c "${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/cvt83.cmd" "${ANDROID_SYSROOT}"
+                   OUTPUT_VARIABLE __path OUTPUT_STRIP_TRAILING_WHITESPACE
+                   RESULT_VARIABLE __result ERROR_QUIET )
+  if( __result EQUAL 0 )
+   file( TO_CMAKE_PATH "${__path}" ANDROID_SYSROOT )
+   set( ANDROID_CXX_FLAGS "--sysroot=${ANDROID_SYSROOT}" )
+  else()
+   set( ANDROID_CXX_FLAGS "--sysroot=\"${ANDROID_SYSROOT}\"" )
+  endif()
+ else()
+  set( ANDROID_CXX_FLAGS "'--sysroot=${ANDROID_SYSROOT}'" )
+ endif()
+ if( NOT _CMAKE_IN_TRY_COMPILE )
+  # quotes can break try_compile and compiler identification
+  message(WARNING "Path to your Android NDK (or toolchain) has non-alphanumeric symbols.\nThe build might be broken.\n")
+ endif()
+else()
+ set( ANDROID_CXX_FLAGS "--sysroot=${ANDROID_SYSROOT}" )
+endif()
+
+# NDK flags
+if (ARM64_V8A )
+ set( ANDROID_CXX_FLAGS         "${ANDROID_CXX_FLAGS} -funwind-tables" )
+ set( ANDROID_CXX_FLAGS_RELEASE "-fomit-frame-pointer -fstrict-aliasing" )
+ set( ANDROID_CXX_FLAGS_DEBUG   "-fno-omit-frame-pointer -fno-strict-aliasing" )
+ if( NOT ANDROID_COMPILER_IS_CLANG )
+  set( ANDROID_CXX_FLAGS_RELEASE "${ANDROID_CXX_FLAGS_RELEASE} -funswitch-loops -finline-limit=300" )
+ endif()
+elseif( ARMEABI OR ARMEABI_V7A)
+ set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -funwind-tables" )
+ if( NOT ANDROID_FORCE_ARM_BUILD AND NOT ARMEABI_V6 )
+  set( ANDROID_CXX_FLAGS_RELEASE "-mthumb -fomit-frame-pointer -fno-strict-aliasing" )
+  set( ANDROID_CXX_FLAGS_DEBUG   "-marm -fno-omit-frame-pointer -fno-strict-aliasing" )
+  if( NOT ANDROID_COMPILER_IS_CLANG )
+   set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -finline-limit=64" )
+  endif()
+ else()
+  # always compile ARMEABI_V6 in arm mode; otherwise there is no difference from ARMEABI
+  set( ANDROID_CXX_FLAGS_RELEASE "-marm -fomit-frame-pointer -fstrict-aliasing" )
+  set( ANDROID_CXX_FLAGS_DEBUG   "-marm -fno-omit-frame-pointer -fno-strict-aliasing" )
+  if( NOT ANDROID_COMPILER_IS_CLANG )
+   set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -funswitch-loops -finline-limit=300" )
+  endif()
+ endif()
+elseif( X86 OR X86_64 )
+ set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -funwind-tables" )
+ if( NOT ANDROID_COMPILER_IS_CLANG )
+  set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -funswitch-loops -finline-limit=300" )
+ endif()
+ set( ANDROID_CXX_FLAGS_RELEASE "-fomit-frame-pointer -fstrict-aliasing" )
+ set( ANDROID_CXX_FLAGS_DEBUG   "-fno-omit-frame-pointer -fno-strict-aliasing" )
+elseif( MIPS OR MIPS64 )
+ set( ANDROID_CXX_FLAGS         "${ANDROID_CXX_FLAGS} -fno-strict-aliasing -finline-functions -funwind-tables -fmessage-length=0" )
+ set( ANDROID_CXX_FLAGS_RELEASE "-fomit-frame-pointer" )
+ set( ANDROID_CXX_FLAGS_DEBUG   "-fno-omit-frame-pointer" )
+ if( NOT ANDROID_COMPILER_IS_CLANG )
+  set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -fno-inline-functions-called-once -fgcse-after-reload -frerun-cse-after-loop -frename-registers" )
+  set( ANDROID_CXX_FLAGS_RELEASE "${ANDROID_CXX_FLAGS_RELEASE} -funswitch-loops -finline-limit=300" )
+ endif()
+elseif()
+ set( ANDROID_CXX_FLAGS_RELEASE "" )
+ set( ANDROID_CXX_FLAGS_DEBUG   "" )
+endif()
+
+set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -fsigned-char" ) # good/necessary when porting desktop libraries
+
+if( NOT X86 AND NOT ANDROID_COMPILER_IS_CLANG )
+ set( ANDROID_CXX_FLAGS "-Wno-psabi ${ANDROID_CXX_FLAGS}" )
+endif()
+
+if( NOT ANDROID_COMPILER_VERSION VERSION_LESS "4.6" )
+ set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -no-canonical-prefixes" ) # see https://android-review.googlesource.com/#/c/47564/
+endif()
+
+# ABI-specific flags
+if( ARMEABI_V7A )
+ set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -march=armv7-a -mfloat-abi=softfp" )
+ if( NEON )
+  set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -mfpu=neon" )
+ elseif( VFPV3 )
+  set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -mfpu=vfpv3" )
+ else()
+  set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -mfpu=vfpv3-d16" )
+ endif()
+elseif( ARMEABI_V6 )
+ set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -march=armv6 -mfloat-abi=softfp -mfpu=vfp" ) # vfp == vfpv2
+elseif( ARMEABI )
+ set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -march=armv5te -mtune=xscale -msoft-float" )
+endif()
+
+if( ANDROID_STL MATCHES "gnustl" AND (EXISTS "${__libstl}" OR EXISTS "${__libsupcxx}") )
+ set( CMAKE_CXX_CREATE_SHARED_LIBRARY "<CMAKE_C_COMPILER> <CMAKE_SHARED_LIBRARY_CXX_FLAGS> <LANGUAGE_COMPILE_FLAGS> <LINK_FLAGS> <CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS> <CMAKE_SHARED_LIBRARY_SONAME_CXX_FLAG><TARGET_SONAME> -o <TARGET> <OBJECTS> <LINK_LIBRARIES>" )
+ set( CMAKE_CXX_CREATE_SHARED_MODULE  "<CMAKE_C_COMPILER> <CMAKE_SHARED_LIBRARY_CXX_FLAGS> <LANGUAGE_COMPILE_FLAGS> <LINK_FLAGS> <CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS> <CMAKE_SHARED_LIBRARY_SONAME_CXX_FLAG><TARGET_SONAME> -o <TARGET> <OBJECTS> <LINK_LIBRARIES>" )
+ set( CMAKE_CXX_LINK_EXECUTABLE       "<CMAKE_C_COMPILER> <FLAGS> <CMAKE_CXX_LINK_FLAGS> <LINK_FLAGS> <OBJECTS> -o <TARGET> <LINK_LIBRARIES>" )
+else()
+ set( CMAKE_CXX_CREATE_SHARED_LIBRARY "<CMAKE_CXX_COMPILER> <CMAKE_SHARED_LIBRARY_CXX_FLAGS> <LANGUAGE_COMPILE_FLAGS> <LINK_FLAGS> <CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS> <CMAKE_SHARED_LIBRARY_SONAME_CXX_FLAG><TARGET_SONAME> -o <TARGET> <OBJECTS> <LINK_LIBRARIES>" )
+ set( CMAKE_CXX_CREATE_SHARED_MODULE  "<CMAKE_CXX_COMPILER> <CMAKE_SHARED_LIBRARY_CXX_FLAGS> <LANGUAGE_COMPILE_FLAGS> <LINK_FLAGS> <CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS> <CMAKE_SHARED_LIBRARY_SONAME_CXX_FLAG><TARGET_SONAME> -o <TARGET> <OBJECTS> <LINK_LIBRARIES>" )
+ set( CMAKE_CXX_LINK_EXECUTABLE       "<CMAKE_CXX_COMPILER> <FLAGS> <CMAKE_CXX_LINK_FLAGS> <LINK_FLAGS> <OBJECTS> -o <TARGET> <LINK_LIBRARIES>" )
+endif()
+
+# STL
+if( EXISTS "${__libstl}" OR EXISTS "${__libsupcxx}" )
+ if( EXISTS "${__libstl}" )
+  set( CMAKE_CXX_CREATE_SHARED_LIBRARY "${CMAKE_CXX_CREATE_SHARED_LIBRARY} \"${__libstl}\"" )
+  set( CMAKE_CXX_CREATE_SHARED_MODULE  "${CMAKE_CXX_CREATE_SHARED_MODULE} \"${__libstl}\"" )
+  set( CMAKE_CXX_LINK_EXECUTABLE       "${CMAKE_CXX_LINK_EXECUTABLE} \"${__libstl}\"" )
+ endif()
+ if( EXISTS "${__libsupcxx}" )
+  set( CMAKE_CXX_CREATE_SHARED_LIBRARY "${CMAKE_CXX_CREATE_SHARED_LIBRARY} \"${__libsupcxx}\"" )
+  set( CMAKE_CXX_CREATE_SHARED_MODULE  "${CMAKE_CXX_CREATE_SHARED_MODULE} \"${__libsupcxx}\"" )
+  set( CMAKE_CXX_LINK_EXECUTABLE       "${CMAKE_CXX_LINK_EXECUTABLE} \"${__libsupcxx}\"" )
+  # C objects:
+  set( CMAKE_C_CREATE_SHARED_LIBRARY "<CMAKE_C_COMPILER> <CMAKE_SHARED_LIBRARY_C_FLAGS> <LANGUAGE_COMPILE_FLAGS> <LINK_FLAGS> <CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS> <CMAKE_SHARED_LIBRARY_SONAME_C_FLAG><TARGET_SONAME> -o <TARGET> <OBJECTS> <LINK_LIBRARIES>" )
+  set( CMAKE_C_CREATE_SHARED_MODULE  "<CMAKE_C_COMPILER> <CMAKE_SHARED_LIBRARY_C_FLAGS> <LANGUAGE_COMPILE_FLAGS> <LINK_FLAGS> <CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS> <CMAKE_SHARED_LIBRARY_SONAME_C_FLAG><TARGET_SONAME> -o <TARGET> <OBJECTS> <LINK_LIBRARIES>" )
+  set( CMAKE_C_LINK_EXECUTABLE       "<CMAKE_C_COMPILER> <FLAGS> <CMAKE_C_LINK_FLAGS> <LINK_FLAGS> <OBJECTS> -o <TARGET> <LINK_LIBRARIES>" )
+  set( CMAKE_C_CREATE_SHARED_LIBRARY "${CMAKE_C_CREATE_SHARED_LIBRARY} \"${__libsupcxx}\"" )
+  set( CMAKE_C_CREATE_SHARED_MODULE  "${CMAKE_C_CREATE_SHARED_MODULE} \"${__libsupcxx}\"" )
+  set( CMAKE_C_LINK_EXECUTABLE       "${CMAKE_C_LINK_EXECUTABLE} \"${__libsupcxx}\"" )
+ endif()
+ if( ANDROID_STL MATCHES "gnustl" )
+  if( NOT EXISTS "${ANDROID_LIBM_PATH}" )
+   set( ANDROID_LIBM_PATH -lm )
+  endif()
+  set( CMAKE_CXX_CREATE_SHARED_LIBRARY "${CMAKE_CXX_CREATE_SHARED_LIBRARY} ${ANDROID_LIBM_PATH}" )
+  set( CMAKE_CXX_CREATE_SHARED_MODULE  "${CMAKE_CXX_CREATE_SHARED_MODULE} ${ANDROID_LIBM_PATH}" )
+  set( CMAKE_CXX_LINK_EXECUTABLE       "${CMAKE_CXX_LINK_EXECUTABLE} ${ANDROID_LIBM_PATH}" )
+ endif()
+endif()
+
+# variables controlling optional build flags
+if( ANDROID_NDK_RELEASE_NUM LESS 7000 ) # before r7
+ # libGLESv2.so in NDK's prior to r7 refers to missing external symbols.
+ # So this flag option is required for all projects using OpenGL from native.
+ __INIT_VARIABLE( ANDROID_SO_UNDEFINED                      VALUES ON )
+else()
+ __INIT_VARIABLE( ANDROID_SO_UNDEFINED                      VALUES OFF )
+endif()
+__INIT_VARIABLE( ANDROID_NO_UNDEFINED                       VALUES ON )
+__INIT_VARIABLE( ANDROID_FUNCTION_LEVEL_LINKING             VALUES ON )
+__INIT_VARIABLE( ANDROID_GOLD_LINKER                        VALUES ON )
+__INIT_VARIABLE( ANDROID_NOEXECSTACK                        VALUES ON )
+__INIT_VARIABLE( ANDROID_RELRO                              VALUES ON )
+
+set( ANDROID_NO_UNDEFINED           ${ANDROID_NO_UNDEFINED}           CACHE BOOL "Show all undefined symbols as linker errors" )
+set( ANDROID_SO_UNDEFINED           ${ANDROID_SO_UNDEFINED}           CACHE BOOL "Allows or disallows undefined symbols in shared libraries" )
+set( ANDROID_FUNCTION_LEVEL_LINKING ${ANDROID_FUNCTION_LEVEL_LINKING} CACHE BOOL "Put each function in separate section and enable garbage collection of unused input sections at link time" )
+set( ANDROID_GOLD_LINKER            ${ANDROID_GOLD_LINKER}            CACHE BOOL "Enables gold linker" )
+set( ANDROID_NOEXECSTACK            ${ANDROID_NOEXECSTACK}            CACHE BOOL "Allows or disallows undefined symbols in shared libraries" )
+set( ANDROID_RELRO                  ${ANDROID_RELRO}                  CACHE BOOL "Enables RELRO - a memory corruption mitigation technique" )
+mark_as_advanced( ANDROID_NO_UNDEFINED ANDROID_SO_UNDEFINED ANDROID_FUNCTION_LEVEL_LINKING ANDROID_GOLD_LINKER ANDROID_NOEXECSTACK ANDROID_RELRO )
+
+# linker flags
+set( ANDROID_LINKER_FLAGS "" )
+
+if( ARMEABI_V7A )
+ # this is *required* to use the following linker flags that routes around
+ # a CPU bug in some Cortex-A8 implementations:
+ set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -Wl,--fix-cortex-a8" )
+endif()
+
+if( ANDROID_NO_UNDEFINED )
+ if( MIPS )
+  # there is some sysroot-related problem in mips linker...
+  if( NOT ANDROID_SYSROOT MATCHES "[ ;\"]" )
+   set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -Wl,--no-undefined -Wl,-rpath-link,${ANDROID_SYSROOT}/usr/lib" )
+  endif()
+ else()
+  set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -Wl,--no-undefined" )
+ endif()
+endif()
+
+if( ANDROID_SO_UNDEFINED )
+ set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -Wl,-allow-shlib-undefined" )
+endif()
+
+if( ANDROID_FUNCTION_LEVEL_LINKING )
+ set( ANDROID_CXX_FLAGS    "${ANDROID_CXX_FLAGS} -fdata-sections -ffunction-sections" )
+ set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -Wl,--gc-sections" )
+endif()
+
+if( ANDROID_COMPILER_VERSION VERSION_EQUAL "4.6" )
+ if( ANDROID_GOLD_LINKER AND (CMAKE_HOST_UNIX OR ANDROID_NDK_RELEASE_NUM GREATER 8002) AND (ARMEABI OR ARMEABI_V7A OR X86) )
+  set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -fuse-ld=gold" )
+ elseif( ANDROID_NDK_RELEASE_NUM GREATER 8002 ) # after r8b
+  set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -fuse-ld=bfd" )
+ elseif( ANDROID_NDK_RELEASE STREQUAL "r8b" AND ARMEABI AND NOT _CMAKE_IN_TRY_COMPILE )
+  message( WARNING "The default bfd linker from arm GCC 4.6 toolchain can fail with 'unresolvable R_ARM_THM_CALL relocation' error message. See https://code.google.com/p/android/issues/detail?id=35342
+  On Linux and OS X host platform you can workaround this problem using gold linker (default).
+  Rerun cmake with -DANDROID_GOLD_LINKER=ON option in case of problems.
+" )
+ endif()
+endif() # version 4.6
+
+if( ANDROID_NOEXECSTACK )
+ if( ANDROID_COMPILER_IS_CLANG )
+  set( ANDROID_CXX_FLAGS    "${ANDROID_CXX_FLAGS} -Xclang -mnoexecstack" )
+ else()
+  set( ANDROID_CXX_FLAGS    "${ANDROID_CXX_FLAGS} -Wa,--noexecstack" )
+ endif()
+ set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -Wl,-z,noexecstack" )
+endif()
+
+if( ANDROID_RELRO )
+ set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -Wl,-z,relro -Wl,-z,now" )
+endif()
+
+if( ANDROID_COMPILER_IS_CLANG )
+ set( ANDROID_CXX_FLAGS "-target ${ANDROID_LLVM_TRIPLE} -Qunused-arguments ${ANDROID_CXX_FLAGS}" )
+ if( BUILD_WITH_ANDROID_NDK )
+  set( ANDROID_CXX_FLAGS "-gcc-toolchain ${ANDROID_TOOLCHAIN_ROOT} ${ANDROID_CXX_FLAGS}" )
+ endif()
+endif()
+
+# cache flags
+set( CMAKE_CXX_FLAGS           ""                                  CACHE STRING "c++ flags" )
+set( CMAKE_C_FLAGS             ""                                  CACHE STRING "c flags" )
+set( CMAKE_CXX_FLAGS_RELEASE   "-O3 -DNDEBUG"                      CACHE STRING "c++ Release flags" )
+set( CMAKE_C_FLAGS_RELEASE     "-O3 -DNDEBUG"                      CACHE STRING "c Release flags" )
+set( CMAKE_CXX_FLAGS_DEBUG     "-O0 -g -DDEBUG -D_DEBUG"           CACHE STRING "c++ Debug flags" )
+set( CMAKE_C_FLAGS_DEBUG       "-O0 -g -DDEBUG -D_DEBUG"           CACHE STRING "c Debug flags" )
+set( CMAKE_SHARED_LINKER_FLAGS "-Wl,--build-id"                    CACHE STRING "shared linker flags" )
+set( CMAKE_MODULE_LINKER_FLAGS "-Wl,--build-id"                    CACHE STRING "module linker flags" )
+set( CMAKE_EXE_LINKER_FLAGS    "-Wl,--build-id -Wl,-z,nocopyreloc" CACHE STRING "executable linker flags" )
+
+# put flags to cache (for debug purpose only)
+set( ANDROID_CXX_FLAGS         "${ANDROID_CXX_FLAGS}"         CACHE INTERNAL "Android specific c/c++ flags" )
+set( ANDROID_CXX_FLAGS_RELEASE "${ANDROID_CXX_FLAGS_RELEASE}" CACHE INTERNAL "Android specific c/c++ Release flags" )
+set( ANDROID_CXX_FLAGS_DEBUG   "${ANDROID_CXX_FLAGS_DEBUG}"   CACHE INTERNAL "Android specific c/c++ Debug flags" )
+set( ANDROID_LINKER_FLAGS      "${ANDROID_LINKER_FLAGS}"      CACHE INTERNAL "Android specific c/c++ linker flags" )
+
+# finish flags
+set( CMAKE_CXX_FLAGS           "${ANDROID_CXX_FLAGS} ${CMAKE_CXX_FLAGS}" )
+set( CMAKE_C_FLAGS             "${ANDROID_CXX_FLAGS} ${CMAKE_C_FLAGS}" )
+set( CMAKE_CXX_FLAGS_RELEASE   "${ANDROID_CXX_FLAGS_RELEASE} ${CMAKE_CXX_FLAGS_RELEASE}" )
+set( CMAKE_C_FLAGS_RELEASE     "${ANDROID_CXX_FLAGS_RELEASE} ${CMAKE_C_FLAGS_RELEASE}" )
+set( CMAKE_CXX_FLAGS_DEBUG     "${ANDROID_CXX_FLAGS_DEBUG} ${CMAKE_CXX_FLAGS_DEBUG}" )
+set( CMAKE_C_FLAGS_DEBUG       "${ANDROID_CXX_FLAGS_DEBUG} ${CMAKE_C_FLAGS_DEBUG}" )
+set( CMAKE_SHARED_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} ${CMAKE_SHARED_LINKER_FLAGS}" )
+set( CMAKE_MODULE_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} ${CMAKE_MODULE_LINKER_FLAGS}" )
+set( CMAKE_EXE_LINKER_FLAGS    "${ANDROID_LINKER_FLAGS} ${CMAKE_EXE_LINKER_FLAGS}" )
+
+if( MIPS AND BUILD_WITH_ANDROID_NDK AND ANDROID_NDK_RELEASE STREQUAL "r8" )
+ set( CMAKE_SHARED_LINKER_FLAGS "-Wl,-T,${ANDROID_NDK_TOOLCHAINS_PATH}/${ANDROID_GCC_TOOLCHAIN_NAME}/mipself.xsc ${CMAKE_SHARED_LINKER_FLAGS}" )
+ set( CMAKE_MODULE_LINKER_FLAGS "-Wl,-T,${ANDROID_NDK_TOOLCHAINS_PATH}/${ANDROID_GCC_TOOLCHAIN_NAME}/mipself.xsc ${CMAKE_MODULE_LINKER_FLAGS}" )
+ set( CMAKE_EXE_LINKER_FLAGS    "-Wl,-T,${ANDROID_NDK_TOOLCHAINS_PATH}/${ANDROID_GCC_TOOLCHAIN_NAME}/mipself.x ${CMAKE_EXE_LINKER_FLAGS}" )
+endif()
+
+# pie/pic
+if( NOT (ANDROID_NATIVE_API_LEVEL LESS 16) AND (NOT DEFINED ANDROID_APP_PIE OR ANDROID_APP_PIE) AND (CMAKE_VERSION VERSION_GREATER 2.8.8) )
+ set( CMAKE_POSITION_INDEPENDENT_CODE TRUE )
+ set( CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -fPIE -pie")
+else()
+ set( CMAKE_POSITION_INDEPENDENT_CODE FALSE )
+ set( CMAKE_CXX_FLAGS "-fpic ${CMAKE_CXX_FLAGS}" )
+ set( CMAKE_C_FLAGS   "-fpic ${CMAKE_C_FLAGS}" )
+endif()
+
+# configure rtti
+if( DEFINED ANDROID_RTTI AND ANDROID_STL_FORCE_FEATURES )
+ if( ANDROID_RTTI )
+  set( CMAKE_CXX_FLAGS "-frtti ${CMAKE_CXX_FLAGS}" )
+ else()
+  set( CMAKE_CXX_FLAGS "-fno-rtti ${CMAKE_CXX_FLAGS}" )
+ endif()
+endif()
+
+# configure exceptios
+if( DEFINED ANDROID_EXCEPTIONS AND ANDROID_STL_FORCE_FEATURES )
+ if( ANDROID_EXCEPTIONS )
+  set( CMAKE_CXX_FLAGS "-fexceptions ${CMAKE_CXX_FLAGS}" )
+  set( CMAKE_C_FLAGS "-fexceptions ${CMAKE_C_FLAGS}" )
+ else()
+  set( CMAKE_CXX_FLAGS "-fno-exceptions ${CMAKE_CXX_FLAGS}" )
+  set( CMAKE_C_FLAGS "-fno-exceptions ${CMAKE_C_FLAGS}" )
+ endif()
+endif()
+
+# global includes and link directories
+include_directories( SYSTEM "${ANDROID_SYSROOT}/usr/include" ${ANDROID_STL_INCLUDE_DIRS} )
+get_filename_component(__android_install_path "${CMAKE_INSTALL_PREFIX}/libs/${ANDROID_NDK_ABI_NAME}" ABSOLUTE) # avoid CMP0015 policy warning
+link_directories( "${__android_install_path}" )
+
+# detect if need link crtbegin_so.o explicitly
+if( NOT DEFINED ANDROID_EXPLICIT_CRT_LINK )
+ set( __cmd "${CMAKE_CXX_CREATE_SHARED_LIBRARY}" )
+ string( REPLACE "<CMAKE_CXX_COMPILER>" "${CMAKE_CXX_COMPILER} ${CMAKE_CXX_COMPILER_ARG1}" __cmd "${__cmd}" )
+ string( REPLACE "<CMAKE_C_COMPILER>"   "${CMAKE_C_COMPILER} ${CMAKE_C_COMPILER_ARG1}"   __cmd "${__cmd}" )
+ string( REPLACE "<CMAKE_SHARED_LIBRARY_CXX_FLAGS>" "${CMAKE_CXX_FLAGS}" __cmd "${__cmd}" )
+ string( REPLACE "<LANGUAGE_COMPILE_FLAGS>" "" __cmd "${__cmd}" )
+ string( REPLACE "<LINK_FLAGS>" "${CMAKE_SHARED_LINKER_FLAGS}" __cmd "${__cmd}" )
+ string( REPLACE "<CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS>" "-shared" __cmd "${__cmd}" )
+ string( REPLACE "<CMAKE_SHARED_LIBRARY_SONAME_CXX_FLAG>" "" __cmd "${__cmd}" )
+ string( REPLACE "<TARGET_SONAME>" "" __cmd "${__cmd}" )
+ string( REPLACE "<TARGET>" "${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/toolchain_crtlink_test.so" __cmd "${__cmd}" )
+ string( REPLACE "<OBJECTS>" "\"${ANDROID_SYSROOT}/usr/lib/crtbegin_so.o\"" __cmd "${__cmd}" )
+ string( REPLACE "<LINK_LIBRARIES>" "" __cmd "${__cmd}" )
+ separate_arguments( __cmd )
+ foreach( __var ANDROID_NDK ANDROID_NDK_TOOLCHAINS_PATH ANDROID_STANDALONE_TOOLCHAIN )
+  if( ${__var} )
+   set( __tmp "${${__var}}" )
+   separate_arguments( __tmp )
+   string( REPLACE "${__tmp}" "${${__var}}" __cmd "${__cmd}")
+  endif()
+ endforeach()
+ string( REPLACE "'" "" __cmd "${__cmd}" )
+ string( REPLACE "\"" "" __cmd "${__cmd}" )
+ execute_process( COMMAND ${__cmd} RESULT_VARIABLE __cmd_result OUTPUT_QUIET ERROR_QUIET )
+ if( __cmd_result EQUAL 0 )
+  set( ANDROID_EXPLICIT_CRT_LINK ON )
+ else()
+  set( ANDROID_EXPLICIT_CRT_LINK OFF )
+ endif()
+endif()
+
+if( ANDROID_EXPLICIT_CRT_LINK )
+ set( CMAKE_CXX_CREATE_SHARED_LIBRARY "${CMAKE_CXX_CREATE_SHARED_LIBRARY} \"${ANDROID_SYSROOT}/usr/lib/crtbegin_so.o\"" )
+ set( CMAKE_CXX_CREATE_SHARED_MODULE  "${CMAKE_CXX_CREATE_SHARED_MODULE} \"${ANDROID_SYSROOT}/usr/lib/crtbegin_so.o\"" )
+endif()
+
+# setup output directories
+set( CMAKE_INSTALL_PREFIX "${ANDROID_TOOLCHAIN_ROOT}/user" CACHE STRING "path for installing" )
+
+if( DEFINED LIBRARY_OUTPUT_PATH_ROOT
+      OR EXISTS "${CMAKE_SOURCE_DIR}/AndroidManifest.xml"
+      OR (EXISTS "${CMAKE_SOURCE_DIR}/../AndroidManifest.xml" AND EXISTS "${CMAKE_SOURCE_DIR}/../jni/") )
+  set( LIBRARY_OUTPUT_PATH_ROOT ${CMAKE_SOURCE_DIR} CACHE PATH "Root for binaries output, set this to change where Android libs are installed to" )
+  if( NOT _CMAKE_IN_TRY_COMPILE )
+    if( EXISTS "${CMAKE_SOURCE_DIR}/jni/CMakeLists.txt" )
+      set( EXECUTABLE_OUTPUT_PATH "${LIBRARY_OUTPUT_PATH_ROOT}/bin/${ANDROID_NDK_ABI_NAME}" CACHE PATH "Output directory for applications" )
+    else()
+      set( EXECUTABLE_OUTPUT_PATH "${LIBRARY_OUTPUT_PATH_ROOT}/bin" CACHE PATH "Output directory for applications" )
+    endif()
+    set( LIBRARY_OUTPUT_PATH "${LIBRARY_OUTPUT_PATH_ROOT}/libs/${ANDROID_NDK_ABI_NAME}" CACHE PATH "Output directory for Android libs" )
+  endif()
+endif()
+
+# copy shaed stl library to build directory
+if( NOT _CMAKE_IN_TRY_COMPILE AND __libstl MATCHES "[.]so$" AND DEFINED LIBRARY_OUTPUT_PATH )
+  get_filename_component( __libstlname "${__libstl}" NAME )
+  execute_process( COMMAND "${CMAKE_COMMAND}" -E copy_if_different "${__libstl}" "${LIBRARY_OUTPUT_PATH}/${__libstlname}" RESULT_VARIABLE __fileCopyProcess )
+  if( NOT __fileCopyProcess EQUAL 0 OR NOT EXISTS "${LIBRARY_OUTPUT_PATH}/${__libstlname}")
+    message( SEND_ERROR "Failed copying of ${__libstl} to the ${LIBRARY_OUTPUT_PATH}/${__libstlname}" )
+  endif()
+  unset( __fileCopyProcess )
+  unset( __libstlname )
+endif()
+
+
+# set these global flags for cmake client scripts to change behavior
+set( ANDROID True )
+set( BUILD_ANDROID True )
+
+# where is the target environment
+set( CMAKE_FIND_ROOT_PATH "${ANDROID_TOOLCHAIN_ROOT}/bin" "${ANDROID_TOOLCHAIN_ROOT}/${ANDROID_TOOLCHAIN_MACHINE_NAME}" "${ANDROID_SYSROOT}" "${CMAKE_INSTALL_PREFIX}" "${CMAKE_INSTALL_PREFIX}/share" )
+
+# only search for libraries and includes in the ndk toolchain
+set( CMAKE_FIND_ROOT_PATH_MODE_PROGRAM ONLY )
+set( CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY )
+set( CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY )
+
+
+# macro to find packages on the host OS
+macro( find_host_package )
+ set( CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER )
+ set( CMAKE_FIND_ROOT_PATH_MODE_LIBRARY NEVER )
+ set( CMAKE_FIND_ROOT_PATH_MODE_INCLUDE NEVER )
+ if( CMAKE_HOST_WIN32 )
+  SET( WIN32 1 )
+  SET( UNIX )
+ elseif( CMAKE_HOST_APPLE )
+  SET( APPLE 1 )
+  SET( UNIX )
+ endif()
+ find_package( ${ARGN} )
+ SET( WIN32 )
+ SET( APPLE )
+ SET( UNIX 1 )
+ set( CMAKE_FIND_ROOT_PATH_MODE_PROGRAM ONLY )
+ set( CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY )
+ set( CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY )
+endmacro()
+
+
+# macro to find programs on the host OS
+macro( find_host_program )
+ set( CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER )
+ set( CMAKE_FIND_ROOT_PATH_MODE_LIBRARY NEVER )
+ set( CMAKE_FIND_ROOT_PATH_MODE_INCLUDE NEVER )
+ if( CMAKE_HOST_WIN32 )
+  SET( WIN32 1 )
+  SET( UNIX )
+ elseif( CMAKE_HOST_APPLE )
+  SET( APPLE 1 )
+  SET( UNIX )
+ endif()
+ find_program( ${ARGN} )
+ SET( WIN32 )
+ SET( APPLE )
+ SET( UNIX 1 )
+ set( CMAKE_FIND_ROOT_PATH_MODE_PROGRAM ONLY )
+ set( CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY )
+ set( CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY )
+endmacro()
+
+
+# export toolchain settings for the try_compile() command
+if( NOT _CMAKE_IN_TRY_COMPILE )
+ set( __toolchain_config "")
+ foreach( __var NDK_CCACHE  LIBRARY_OUTPUT_PATH_ROOT  ANDROID_FORBID_SYGWIN
+                ANDROID_NDK_HOST_X64
+                ANDROID_NDK
+                ANDROID_NDK_LAYOUT
+                ANDROID_STANDALONE_TOOLCHAIN
+                ANDROID_TOOLCHAIN_NAME
+                ANDROID_ABI
+                ANDROID_NATIVE_API_LEVEL
+                ANDROID_STL
+                ANDROID_STL_FORCE_FEATURES
+                ANDROID_FORCE_ARM_BUILD
+                ANDROID_NO_UNDEFINED
+                ANDROID_SO_UNDEFINED
+                ANDROID_FUNCTION_LEVEL_LINKING
+                ANDROID_GOLD_LINKER
+                ANDROID_NOEXECSTACK
+                ANDROID_RELRO
+                ANDROID_LIBM_PATH
+                ANDROID_EXPLICIT_CRT_LINK
+                ANDROID_APP_PIE
+                )
+  if( DEFINED ${__var} )
+   if( ${__var} MATCHES " ")
+    set( __toolchain_config "${__toolchain_config}set( ${__var} \"${${__var}}\" CACHE INTERNAL \"\" )\n" )
+   else()
+    set( __toolchain_config "${__toolchain_config}set( ${__var} ${${__var}} CACHE INTERNAL \"\" )\n" )
+   endif()
+  endif()
+ endforeach()
+ file( WRITE "${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/android.toolchain.config.cmake" "${__toolchain_config}" )
+ unset( __toolchain_config )
+endif()
+
+
+# force cmake to produce / instead of \ in build commands for Ninja generator
+if( CMAKE_GENERATOR MATCHES "Ninja" AND CMAKE_HOST_WIN32 )
+ # it is a bad hack after all
+ # CMake generates Ninja makefiles with UNIX paths only if it thinks that we are going to build with MinGW
+ set( CMAKE_COMPILER_IS_MINGW TRUE ) # tell CMake that we are MinGW
+ set( CMAKE_CROSSCOMPILING TRUE )    # stop recursion
+ enable_language( C )
+ enable_language( CXX )
+ # unset( CMAKE_COMPILER_IS_MINGW ) # can't unset because CMake does not convert back-slashes in response files without it
+ unset( MINGW )
+endif()
+
+# Variables need by cmAndroidGradleBuild to generate android_gradle_build.json
+set(CMAKE_ANDROID_ARCH_ABI ${ANDROID_ABI})
+
+
+# Variables controlling behavior or set by cmake toolchain:
+#   ANDROID_ABI : "armeabi-v7a" (default), "armeabi", "armeabi-v7a with NEON", "armeabi-v7a with VFPV3", "armeabi-v6 with VFP", "x86", "mips", "arm64-v8a", "x86_64", "mips64"
+#   ANDROID_NATIVE_API_LEVEL : 3,4,5,8,9,14,15,16,17,18,19,21 (depends on NDK version)
+#   ANDROID_STL : gnustl_static/gnustl_shared/stlport_static/stlport_shared/gabi++_static/gabi++_shared/system_re/system/none
+#   ANDROID_FORBID_SYGWIN : ON/OFF
+#   ANDROID_NO_UNDEFINED : ON/OFF
+#   ANDROID_SO_UNDEFINED : OFF/ON  (default depends on NDK version)
+#   ANDROID_FUNCTION_LEVEL_LINKING : ON/OFF
+#   ANDROID_GOLD_LINKER : ON/OFF
+#   ANDROID_NOEXECSTACK : ON/OFF
+#   ANDROID_RELRO : ON/OFF
+#   ANDROID_FORCE_ARM_BUILD : ON/OFF
+#   ANDROID_STL_FORCE_FEATURES : ON/OFF
+#   ANDROID_LIBM_PATH : path to libm.so (set to something like $(TOP)/out/target/product/<product_name>/obj/lib/libm.so) to workaround unresolved `sincos`
+# Can be set only at the first run:
+#   ANDROID_NDK : path to your NDK install
+#   NDK_CCACHE : path to your ccache executable
+#   ANDROID_TOOLCHAIN_NAME : the NDK name of compiler toolchain
+#   ANDROID_NDK_HOST_X64 : try to use x86_64 toolchain (default for x64 host systems)
+#   ANDROID_NDK_LAYOUT : the inner NDK structure (RELEASE, LINARO, ANDROID)
+#   LIBRARY_OUTPUT_PATH_ROOT : <any valid path>
+#   ANDROID_STANDALONE_TOOLCHAIN
+#
+# Primary read-only variables:
+#   ANDROID : always TRUE
+#   ARMEABI : TRUE for arm v6 and older devices
+#   ARMEABI_V6 : TRUE for arm v6
+#   ARMEABI_V7A : TRUE for arm v7a
+#   ARM64_V8A : TRUE for arm64-v8a
+#   NEON : TRUE if NEON unit is enabled
+#   VFPV3 : TRUE if VFP version 3 is enabled
+#   X86 : TRUE if configured for x86
+#   X86_64 : TRUE if configured for x86_64
+#   MIPS : TRUE if configured for mips
+#   MIPS64 : TRUE if configured for mips64
+#   BUILD_WITH_ANDROID_NDK : TRUE if NDK is used
+#   BUILD_WITH_STANDALONE_TOOLCHAIN : TRUE if standalone toolchain is used
+#   ANDROID_NDK_HOST_SYSTEM_NAME : "windows", "linux-x86" or "darwin-x86" depending on host platform
+#   ANDROID_NDK_ABI_NAME : "armeabi", "armeabi-v7a", "x86", "mips", "arm64-v8a", "x86_64", "mips64" depending on ANDROID_ABI
+#   ANDROID_NDK_RELEASE : from r5 to r10d; set only for NDK
+#   ANDROID_NDK_RELEASE_NUM : numeric ANDROID_NDK_RELEASE version (1000*major+minor)
+#   ANDROID_ARCH_NAME : "arm", "x86", "mips", "arm64", "x86_64", "mips64" depending on ANDROID_ABI
+#   ANDROID_SYSROOT : path to the compiler sysroot
+#   TOOL_OS_SUFFIX : "" or ".exe" depending on host platform
+#   ANDROID_COMPILER_IS_CLANG : TRUE if clang compiler is used
+#
+# Secondary (less stable) read-only variables:
+#   ANDROID_COMPILER_VERSION : GCC version used (not Clang version)
+#   ANDROID_CLANG_VERSION : version of clang compiler if clang is used
+#   ANDROID_CXX_FLAGS : C/C++ compiler flags required by Android platform
+#   ANDROID_SUPPORTED_ABIS : list of currently allowed values for ANDROID_ABI
+#   ANDROID_TOOLCHAIN_MACHINE_NAME : "arm-linux-androideabi", "arm-eabi" or "i686-android-linux"
+#   ANDROID_TOOLCHAIN_ROOT : path to the top level of toolchain (standalone or placed inside NDK)
+#   ANDROID_CLANG_TOOLCHAIN_ROOT : path to clang tools
+#   ANDROID_SUPPORTED_NATIVE_API_LEVELS : list of native API levels found inside NDK
+#   ANDROID_STL_INCLUDE_DIRS : stl include paths
+#   ANDROID_RTTI : if rtti is enabled by the runtime
+#   ANDROID_EXCEPTIONS : if exceptions are enabled by the runtime
+#   ANDROID_GCC_TOOLCHAIN_NAME : read-only, differs from ANDROID_TOOLCHAIN_NAME only if clang is used
+#
+# Defaults:
+#   ANDROID_DEFAULT_NDK_API_LEVEL
+#   ANDROID_DEFAULT_NDK_API_LEVEL_${ARCH}
+#   ANDROID_NDK_SEARCH_PATHS
+#   ANDROID_SUPPORTED_ABIS_${ARCH}
+#   ANDROID_SUPPORTED_NDK_VERSIONS
diff --git a/realm/realm-jni/src/io_realm_internal_CheckedRow.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp
similarity index 88%
rename from realm/realm-jni/src/io_realm_internal_CheckedRow.cpp
rename to realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp
index 79ceb7a496..e9116d021b 100644
--- a/realm/realm-jni/src/io_realm_internal_CheckedRow.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp
@@ -18,8 +18,6 @@
 #include "io_realm_internal_UncheckedRow.h"
 
 #include "util.hpp"
-#include "mixedutil.hpp"
-#include "tablebase_tpl.hpp"
 
 using namespace realm;
 
@@ -130,24 +128,6 @@ JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_CheckedRow_nativeGetByteArra
     return Java_io_realm_internal_UncheckedRow_nativeGetByteArray(env, obj, nativeRowPtr, columnIndex);
 }
 
-JNIEXPORT jint JNICALL Java_io_realm_internal_CheckedRow_nativeGetMixedType
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
-{
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Mixed))
-        return 0;
-
-    return Java_io_realm_internal_UncheckedRow_nativeGetMixedType(env, obj, nativeRowPtr, columnIndex);
-}
-
-JNIEXPORT jobject JNICALL Java_io_realm_internal_CheckedRow_nativeGetMixed
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
-{
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Mixed))
-        return NULL;
-
-    return Java_io_realm_internal_UncheckedRow_nativeGetMixed(env, obj, nativeRowPtr, columnIndex);
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLink
   (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
 {
@@ -167,7 +147,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeIsNullLink
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLinkView
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex)
+  (JNIEnv* env, jclass obj, jlong nativeRowPtr, jlong columnIndex)
 {
     if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_LinkList))
         return 0;
@@ -238,15 +218,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetByteArray
     Java_io_realm_internal_UncheckedRow_nativeSetByteArray(env, obj, nativeRowPtr, columnIndex, value);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetMixed
-  (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jobject jMixedValue)
-{
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_Mixed))
-        return;
-
-    Java_io_realm_internal_UncheckedRow_nativeSetMixed(env, obj, nativeRowPtr, columnIndex, jMixedValue);
-}
-
 JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetLink
   (JNIEnv* env, jobject obj, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
diff --git a/realm/realm-jni/src/io_realm_internal_LinkView.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_LinkView.cpp
similarity index 85%
rename from realm/realm-jni/src/io_realm_internal_LinkView.cpp
rename to realm/realm-library/src/main/cpp/io_realm_internal_LinkView.cpp
index 0eef715113..d1c4b5c580 100644
--- a/realm/realm-jni/src/io_realm_internal_LinkView.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_LinkView.cpp
@@ -15,7 +15,6 @@
  */
 
 #include "io_realm_internal_LinkView.h"
-#include "tablequery.hpp"
 #include "util.hpp"
 
 using namespace realm;
@@ -30,7 +29,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeClose
 JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetRow
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos)
 {
-    TR_ENTER_PTR(nativeLinkViewPtr)
+    TR_ENTER_PTR(env, nativeLinkViewPtr)
     LinkViewRef *lv = LV(nativeLinkViewPtr);
     if (!ROW_INDEX_VALID(env, *lv, pos)) {
         return -1;
@@ -45,25 +44,25 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetRow
 
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetRowIndex
-  (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos)
+  (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong linkViewIndex)
 {
-    TR_ENTER_PTR(nativeLinkViewPtr)
+    TR_ENTER_PTR(env, nativeLinkViewPtr)
     LinkViewRef *lv = LV(nativeLinkViewPtr);
-    if (!ROW_INDEX_VALID(env, *lv, pos)) {
+    if (!ROW_INDEX_VALID(env, *lv, linkViewIndex)) {
         return -1;
     }
     try {
         LinkViewRef lvr = *lv;
-        return lvr->get( S(pos) ).get_index();
+        return lvr->get(S(linkViewIndex)).get_index();
     } CATCH_STD()
     return 0;
 }
 
 
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeAdd
-  (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong rowIndex)
+  (JNIEnv* env, jclass, jlong nativeLinkViewPtr, jlong rowIndex)
 {
-    TR_ENTER_PTR(nativeLinkViewPtr)
+    TR_ENTER_PTR(env, nativeLinkViewPtr)
     LinkViewRef *lv = LV(nativeLinkViewPtr);
     try {
         LinkViewRef lvr = *lv;
@@ -75,7 +74,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeAdd
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeInsert
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos, jlong rowIndex)
 {
-    TR_ENTER_PTR(nativeLinkViewPtr)
+    TR_ENTER_PTR(env, nativeLinkViewPtr)
     LinkViewRef *lv = LV(nativeLinkViewPtr);
     try {
         LinkViewRef lvr = *lv;
@@ -87,7 +86,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeInsert
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeSet
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos, jlong rowIndex)
 {
-    TR_ENTER_PTR(nativeLinkViewPtr)
+    TR_ENTER_PTR(env, nativeLinkViewPtr)
     LinkViewRef *lv = LV(nativeLinkViewPtr);
     if (!ROW_INDEX_VALID(env, *lv, pos)) {
         return;
@@ -102,7 +101,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeSet
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeMove
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong old_pos, jlong new_pos)
 {
-    TR_ENTER_PTR(nativeLinkViewPtr)
+    TR_ENTER_PTR(env, nativeLinkViewPtr)
     try {
         LinkViewRef *lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
@@ -121,7 +120,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeMove
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemove
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos)
 {
-    TR_ENTER_PTR(nativeLinkViewPtr)
+    TR_ENTER_PTR(env, nativeLinkViewPtr)
     LinkViewRef *lv = LV(nativeLinkViewPtr);
     if (!ROW_INDEX_VALID(env, *lv, pos)) {
         return;
@@ -134,9 +133,9 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemove
 
 
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeClear
-  (JNIEnv* env, jobject, jlong nativeLinkViewPtr)
+  (JNIEnv* env, jclass, jlong nativeLinkViewPtr)
 {
-    TR_ENTER_PTR(nativeLinkViewPtr)
+    TR_ENTER_PTR(env, nativeLinkViewPtr)
     try {
         LinkViewRef *lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
@@ -149,7 +148,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeSize
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr)
 {
     
-    TR_ENTER_PTR(nativeLinkViewPtr)
+    TR_ENTER_PTR(env, nativeLinkViewPtr)
     try {
         LinkViewRef *lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
@@ -162,7 +161,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeSize
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsEmpty
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr)
 {
-    TR_ENTER_PTR(nativeLinkViewPtr)
+    TR_ENTER_PTR(env, nativeLinkViewPtr)
     try {
         LinkViewRef *lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
@@ -174,12 +173,11 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsEmpty
 JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeWhere
   (JNIEnv *env, jobject, jlong nativeLinkViewPtr)
 {
-    TR_ENTER_PTR(nativeLinkViewPtr)
+    TR_ENTER_PTR(env, nativeLinkViewPtr)
     try {
         LinkViewRef *lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
-        Query query = lvr->get_target_table().where(LinkViewRef(lvr));
-        TableQuery* queryPtr = new TableQuery(query);
+        Query *queryPtr = new Query(lvr->get_target_table().where(LinkViewRef(lvr)));
         return reinterpret_cast<jlong>(queryPtr);
     } CATCH_STD()
     return 0;
@@ -188,7 +186,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeWhere
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsAttached
   (JNIEnv *env, jobject, jlong nativeLinkViewPtr)
 {
-    TR_ENTER_PTR(nativeLinkViewPtr)
+    TR_ENTER_PTR(env, nativeLinkViewPtr)
     try {
         LinkViewRef *lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
@@ -200,7 +198,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsAttached
 JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeFind
   (JNIEnv *env, jobject, jlong nativeLinkViewPtr, jlong targetRowIndex)
 {
-    TR_ENTER_PTR(nativeLinkViewPtr)
+    TR_ENTER_PTR(env, nativeLinkViewPtr)
     try {
         LinkViewRef *lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
@@ -216,7 +214,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeFind
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveAllTargetRows
   (JNIEnv *env, jobject, jlong nativeLinkViewPtr)
 {
-    TR_ENTER_PTR(nativeLinkViewPtr)
+    TR_ENTER_PTR(env, nativeLinkViewPtr)
     try {
         LinkViewRef* lv = LV(nativeLinkViewPtr);
         LinkViewRef lvr = *lv;
@@ -225,9 +223,9 @@ JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveAllTargetRows
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetTable
-  (JNIEnv*, jobject, jlong nativeLinkViewPtr)
+  (JNIEnv* env, jobject, jlong nativeLinkViewPtr)
 {
-    TR_ENTER_PTR(nativeLinkViewPtr)
+    TR_ENTER_PTR(env, nativeLinkViewPtr)
 
     LinkViewRef* lv = LV(nativeLinkViewPtr);
     LinkViewRef lvr = *lv;
@@ -240,7 +238,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetTable
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveTargetRow
   (JNIEnv* env, jobject, jlong nativeLinkViewPtr, jlong pos)
 {
-    TR_ENTER_PTR(nativeLinkViewPtr)
+    TR_ENTER_PTR(env, nativeLinkViewPtr)
     LinkViewRef* lv = LV(nativeLinkViewPtr);
     if (!ROW_INDEX_VALID(env, *lv, pos)) {
         return;
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
new file mode 100644
index 0000000000..90d9b6b0eb
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
@@ -0,0 +1,394 @@
+#include "io_realm_internal_SharedRealm.h"
+
+#include "object_store.hpp"
+#include "shared_realm.hpp"
+
+#include "java_binding_context.hpp"
+#include "util.hpp"
+
+using namespace realm;
+using namespace realm::_impl;
+
+static_assert(SchemaMode::Automatic ==
+                      static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_AUTOMATIC), "");
+static_assert(SchemaMode::ReadOnly ==
+                      static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_READONLY), "");
+static_assert(SchemaMode::ResetFile ==
+                      static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_RESET_FILE), "");
+static_assert(SchemaMode::Additive ==
+                      static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_ADDITIVE), "");
+static_assert(SchemaMode::Manual ==
+              static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_MANUAL), "");
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_SharedRealm_nativeCreateConfig(JNIEnv *env, jclass, jstring realm_path, jbyteArray key,
+        jbyte schema_mode, jboolean in_memory, jboolean cache, jboolean disable_format_upgrade,
+        jboolean auto_change_notification)
+{
+    TR_ENTER(env)
+
+    try {
+        JStringAccessor path(env, realm_path); // throws
+        JniByteArray key_array(env, key);
+        Realm::Config *config = new Realm::Config();
+        config->path = path;
+        config->encryption_key = key_array;
+        config->schema_mode = static_cast<SchemaMode>(schema_mode);
+        config->in_memory = in_memory;
+        config->cache = cache;
+        config->disable_format_upgrade = disable_format_upgrade;
+        config->automatic_change_notifications = auto_change_notification;
+        return reinterpret_cast<jlong>(config);
+    } CATCH_STD()
+
+    return static_cast<jlong>(NULL);
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeCloseConfig(JNIEnv* env, jclass, jlong config_ptr)
+{
+    TR_ENTER_PTR(env, config_ptr)
+
+    auto config = reinterpret_cast<realm::Realm::Config*>(config_ptr);
+    delete config;
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_SharedRealm_nativeGetSharedRealm(JNIEnv *env, jclass, jlong config_ptr, jobject notifier)
+{
+    TR_ENTER_PTR(env, config_ptr)
+
+    auto config = reinterpret_cast<realm::Realm::Config*>(config_ptr);
+    try {
+        auto shared_realm = Realm::get_shared_realm(*config);
+        shared_realm->m_binding_context = JavaBindingContext::create(env, notifier);
+        // advance_read needs to be handled by Java because of async query.
+        shared_realm->set_auto_refresh(false);
+        return reinterpret_cast<jlong>(new SharedRealm(std::move(shared_realm)));
+    } CATCH_STD()
+    return static_cast<jlong>(NULL);
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeCloseSharedRealm(JNIEnv* env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr)
+
+    auto ptr = reinterpret_cast<SharedRealm*>(shared_realm_ptr);
+    delete ptr;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeBeginTransaction(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        shared_realm->begin_transaction();
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeCommitTransaction(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        shared_realm->commit_transaction();
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeCancelTransaction(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        shared_realm->cancel_transaction();
+    } CATCH_STD()
+}
+
+
+JNIEXPORT jboolean JNICALL
+Java_io_realm_internal_SharedRealm_nativeIsInTransaction(JNIEnv* env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    return static_cast<jboolean>(shared_realm->is_in_transaction());
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_SharedRealm_nativeReadGroup(JNIEnv *env, jclass , jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        return reinterpret_cast<jlong>(&shared_realm->read_group());
+    } CATCH_STD()
+
+    return static_cast<jlong>(NULL);
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_SharedRealm_nativeGetVersion(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        return static_cast<jlong>(ObjectStore::get_schema_version(shared_realm->read_group()));
+    } CATCH_STD()
+
+    // FIXME: Use constant value
+    return -1;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeSetVersion(JNIEnv *env, jclass, jlong shared_realm_ptr, jlong version)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        if (!shared_realm->is_in_transaction()) {
+            std::ostringstream ss;
+            ss << "Cannot set schema version when the realm is not in transaction.";
+            ThrowException(env, IllegalState, ss.str());
+            return;
+        }
+
+        ObjectStore::set_schema_version(shared_realm->read_group(), static_cast<uint64_t>(version));
+    } CATCH_STD()
+}
+
+JNIEXPORT jboolean JNICALL
+Java_io_realm_internal_SharedRealm_nativeIsEmpty(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        return static_cast<jboolean>(ObjectStore::is_empty(shared_realm->read_group()));
+    } CATCH_STD()
+    return JNI_FALSE;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeRefresh__J(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        shared_realm->refresh();
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeRefresh__JJJ(JNIEnv *env, jclass, jlong shared_realm_ptr, jlong version,
+        jlong index)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    SharedGroup::VersionID version_id(static_cast<SharedGroup::version_type>(version),
+                                     static_cast<uint32_t>(index));
+    try {
+        using rf = realm::_impl::RealmFriend;
+        auto& shared_group = rf::get_shared_group(*shared_realm);
+        LangBindHelper::advance_read(shared_group, version_id);
+    } CATCH_STD()
+}
+
+JNIEXPORT jlongArray JNICALL
+Java_io_realm_internal_SharedRealm_nativeGetVersionID(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        using rf = realm::_impl::RealmFriend;
+        SharedGroup::VersionID version_id = rf::get_shared_group(*shared_realm).get_version_of_current_transaction();
+
+        jlong version_array[2];
+        version_array[0] = static_cast<jlong>(version_id.version);
+        version_array[1] = static_cast<jlong>(version_id.index);
+
+        jlongArray version_data = env->NewLongArray(2);
+        if (version_data == NULL) {
+            ThrowException(env, OutOfMemory, "Could not allocate memory to return versionID.");
+            return NULL;
+        }
+        env->SetLongArrayRegion(version_data, 0, 2, version_array);
+
+        return version_data;
+    } CATCH_STD ()
+
+    return NULL;
+}
+
+JNIEXPORT jboolean JNICALL
+Java_io_realm_internal_SharedRealm_nativeIsClosed(JNIEnv* env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    return static_cast<jboolean>(shared_realm->is_closed());
+}
+
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_SharedRealm_nativeGetTable(JNIEnv *env, jclass, jlong shared_realm_ptr, jstring table_name)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr)
+
+    try {
+        JStringAccessor name(env, table_name); // throws
+        auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        if (!shared_realm->read_group().has_table(name) && !shared_realm->is_in_transaction()) {
+            std::ostringstream ss;
+            ss << "Class " << name << " doesn't exist and the shared Realm is not in transaction.";
+            ThrowException(env, IllegalState, ss.str());
+            return static_cast<jlong>(NULL);
+        }
+        Table* pTable = LangBindHelper::get_or_add_table(shared_realm->read_group(), name);
+        return reinterpret_cast<jlong>(pTable);
+    } CATCH_STD()
+
+    return static_cast<jlong>(NULL);
+}
+
+JNIEXPORT jstring JNICALL
+Java_io_realm_internal_SharedRealm_nativeGetTableName(JNIEnv *env, jclass, jlong shared_realm_ptr, jint index)
+{
+
+    TR_ENTER_PTR(env, shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        return to_jstring(env, shared_realm->read_group().get_table_name(static_cast<size_t>(index)));
+    } CATCH_STD()
+    return NULL;
+}
+
+JNIEXPORT jboolean JNICALL
+Java_io_realm_internal_SharedRealm_nativeHasTable(JNIEnv *env, jclass, jlong shared_realm_ptr, jstring table_name)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        JStringAccessor name(env, table_name);
+        return static_cast<jboolean>(shared_realm->read_group().has_table(name));
+    } CATCH_STD()
+    return JNI_FALSE;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeRenameTable(JNIEnv *env, jclass, jlong shared_realm_ptr,
+        jstring old_table_name, jstring new_table_name)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        JStringAccessor old_name(env, old_table_name);
+        if (!shared_realm->is_in_transaction()) {
+            std::ostringstream ss;
+            ss << "Class " << old_name << " cannot be removed when the realm is not in transaction.";
+            ThrowException(env, IllegalState, ss.str());
+            return;
+        }
+        JStringAccessor new_name(env, new_table_name);
+        shared_realm->read_group().rename_table(old_name, new_name);
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeRemoveTable(JNIEnv *env, jclass, jlong shared_realm_ptr, jstring table_name)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        JStringAccessor name(env, table_name);
+        if (!shared_realm->is_in_transaction()) {
+            std::ostringstream ss;
+            ss << "Class " << name << " cannot be removed when the realm is not in transaction.";
+            ThrowException(env, IllegalState, ss.str());
+            return;
+        }
+        shared_realm->read_group().remove_table(name);
+    } CATCH_STD()
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_SharedRealm_nativeSize(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr)
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        return static_cast<jlong>(shared_realm->read_group().size());
+    } CATCH_STD()
+
+    return 0;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeWriteCopy(JNIEnv *env, jclass, jlong shared_realm_ptr, jstring path,
+        jbyteArray key)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr);
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        JStringAccessor path_str(env, path);
+        JniByteArray key_buffer(env, key);
+        shared_realm->write_copy(path_str, key_buffer);
+    } CATCH_STD()
+}
+
+JNIEXPORT jboolean JNICALL
+Java_io_realm_internal_SharedRealm_nativeWaitForChange(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr);
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        using rf = realm::_impl::RealmFriend;
+        return static_cast<jboolean>(rf::get_shared_group(*shared_realm).wait_for_change());
+    } CATCH_STD()
+
+    return JNI_FALSE;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_SharedRealm_nativeStopWaitForChange(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr);
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        using rf = realm::_impl::RealmFriend;
+        rf::get_shared_group(*shared_realm).wait_for_change_release();
+    } CATCH_STD()
+}
+
+JNIEXPORT jboolean JNICALL
+Java_io_realm_internal_SharedRealm_nativeCompact(JNIEnv *env, jclass, jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(env, shared_realm_ptr);
+
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        return static_cast<jboolean>(shared_realm->compact());
+    } CATCH_STD()
+
+    return JNI_FALSE;
+}
diff --git a/realm/realm-jni/src/io_realm_internal_table.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
similarity index 85%
rename from realm/realm-jni/src/io_realm_internal_table.cpp
rename to realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
index b5680bb491..0f1eb70bed 100644
--- a/realm/realm-jni/src/io_realm_internal_table.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
@@ -17,14 +17,8 @@
 #include <sstream>
 
 #include "util.hpp"
-#include "mixedutil.hpp"
 #include "io_realm_internal_Table.h"
-#include "columntypeutil.hpp"
-#include "TableSpecUtil.hpp"
-#include "java_lang_List_Util.hpp"
-#include "mixedutil.hpp"
 #include "tablebase_tpl.hpp"
-#include "tablequery.hpp"
 
 using namespace std;
 using namespace realm;
@@ -398,56 +392,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNull
     } CATCH_STD()
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsRootTable
-  (JNIEnv *, jobject, jlong nativeTablePtr)
-{
-    //If the spec is shared, it is a subtable, and this method will return false
-    return !TBL(nativeTablePtr)->has_shared_type();
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeUpdateFromSpec(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jobject jTableSpec)
-{
-    Table* pTable = TBL(nativeTablePtr);
-    TR("nativeUpdateFromSpec(tblPtr %p, spec %p)", VOID_PTR(pTable), VOID_PTR(jTableSpec))
-    if (!TABLE_VALID(env, pTable))
-        return;
-    if (pTable->has_shared_type()) {
-        ThrowException(env, UnsupportedOperation, "It is not allowed to update a subtable from spec.");
-        return;
-    }
-    try {
-        DescriptorRef desc = pTable->get_descriptor(); // Throws
-        set_descriptor(env, *desc, jTableSpec);
-    }
-    CATCH_STD()
-}
-
-JNIEXPORT jobject JNICALL Java_io_realm_internal_Table_nativeGetTableSpec(
-    JNIEnv* env, jobject, jlong nativeTablePtr)
-{
-    if (!TABLE_VALID(env, TBL(nativeTablePtr)))
-        return 0;
-
-    TR_ENTER_PTR(nativeTablePtr)
-    static jmethodID jTableSpecConsId = GetTableSpecMethodID(env, "<init>", "()V");
-    if (jTableSpecConsId) {
-        try {
-            // Create a new TableSpec object in Java
-            const Table* pTable = TBL(nativeTablePtr);
-            ConstDescriptorRef desc = pTable->get_descriptor(); // noexcept
-            jobject jTableSpec = env->NewObject(GetClassTableSpec(env), jTableSpecConsId);
-            if (jTableSpec) {
-                get_descriptor(env, *desc, jTableSpec); // Throws
-                return jTableSpec;
-            }
-        }
-        CATCH_STD()
-    }
-    return 0;
-}
-
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSize(
     JNIEnv* env, jobject, jlong nativeTablePtr)
 {
@@ -514,7 +458,7 @@ JNIEXPORT jint JNICALL Java_io_realm_internal_Table_nativeGetColumnType(
 // ---------------- Row handling
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddEmptyRow(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong rows)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong rows)
 {
     Table* pTable = TBL(nativeTablePtr);
     if (!TABLE_VALID(env, pTable))
@@ -559,16 +503,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMoveLastOver
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetMixed(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jobject jMixedValue)
-{
-    if (!TBL_AND_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex))
-        return;
-    try {
-        tbl_nativeDoMixed(&Table::set_mixed, TBL(nativeTablePtr), env, columnIndex, rowIndex, jMixedValue);
-    } CATCH_STD()
-}
-
 // ----------------- Get cell
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLong(
@@ -650,29 +584,6 @@ JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Table_nativeGetByteArray(
     return tbl_GetByteArray<Table>(env, nativeTablePtr, columnIndex, rowIndex);  // noexcept
 }
 
-JNIEXPORT jint JNICALL Java_io_realm_internal_Table_nativeGetMixedType(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
-{
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Mixed))
-        return 0;
-
-    DataType mixedType = TBL(nativeTablePtr)->get_mixed_type( S(columnIndex), S(rowIndex));  // noexcept
-    return static_cast<jint>(mixedType);
-}
-
-JNIEXPORT jobject JNICALL Java_io_realm_internal_Table_nativeGetMixed(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
-{
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Mixed))
-        return NULL;
-
-    Mixed value = TBL(nativeTablePtr)->get_mixed( S(columnIndex), S(rowIndex));  // noexcept
-    try {
-        return CreateJMixedFromMixed(env, value);
-    } CATCH_STD();
-    return NULL;
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLink
   (JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
 {
@@ -681,61 +592,34 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLink
     return TBL(nativeTablePtr)->get_link( S(columnIndex), S(rowIndex));  // noexcept
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLinkTarget
-  (JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLinkView
+        (JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
 {
-    try {
-        Table* pTable = &(*TBL(nativeTablePtr)->get_link_target( S(columnIndex) ));
-        LangBindHelper::bind_table_ptr(pTable);
-        return (jlong)pTable;
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSubtable(
-    JNIEnv* env, jobject jTableBase, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
-{
-    if (!TBL_AND_INDEX_AND_TYPE_VALID_MIXED(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Table))
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_LinkList))
         return 0;
     try {
-        Table* pSubtable = static_cast<Table*>(LangBindHelper::get_subtable_ptr(TBL(nativeTablePtr),
-            S(columnIndex), S(rowIndex)));
-        TR("nativeGetSubtable(jTableBase:%p, nativeTablePtr: %p, colIdx: %" PRId64 ", rowIdx: %" PRId64 ") : %p",
-            VOID_PTR(jTableBase), VOID_PTR(nativeTablePtr), S64(columnIndex), S64(rowIndex), VOID_PTR(pSubtable))
-        return (jlong)pSubtable;
+        LinkViewRef* link_view_ptr = new LinkViewRef(TBL(nativeTablePtr)->get_linklist( S(columnIndex), S(rowIndex)));
+        return reinterpret_cast<jlong>(link_view_ptr);
     } CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSubtableDuringInsert(
-    JNIEnv* env, jobject jTableBase, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLinkTarget
+  (JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
 {
-    if (!TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Table))
-        return 0;
     try {
-        Table* pSubtable = static_cast<Table*>(LangBindHelper::get_subtable_ptr_during_insert(
-            TBL(nativeTablePtr), S(columnIndex), S(rowIndex)));
-        TR("nativeGetSubtableDuringInsert(jTableBase:%p, nativeTablePtr: %p, colIdx: %" PRId64 ", rowIdx: %" PRId64 ") : %p",
-           VOID_PTR(jTableBase), VOID_PTR(nativeTablePtr), S64(columnIndex), S64(rowIndex), VOID_PTR(pSubtable))
-        return (jlong)pSubtable;
+        Table* pTable = &(*TBL(nativeTablePtr)->get_link_target( S(columnIndex) ));
+        LangBindHelper::bind_table_ptr(pTable);
+        return (jlong)pTable;
     } CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSubtableSize(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
-{
-    if (!TBL_AND_INDEX_AND_TYPE_VALID_MIXED(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Table))
-        return 0;
-
-    return TBL(nativeTablePtr)->get_subtable_size( S(columnIndex), S(rowIndex)); // noexcept
-}
-
 
 // ----------------- Set cell
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLink
-  (JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong targetRowIndex)
+  (JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong targetRowIndex)
 {
     if (!TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Link))
         return;
@@ -745,7 +629,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLink
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLong(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong value)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Int))
         return;
@@ -754,8 +638,19 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLong(
     } CATCH_STD()
 }
 
+JNIEXPORT void JNICALL
+Java_io_realm_internal_Table_nativeSetLongUnique(JNIEnv *env, jclass, jlong nativeTablePtr, jlong columnIndex,
+                                                 jlong rowIndex, jlong value)
+{
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Int))
+        return;
+    try {
+        TBL(nativeTablePtr)->set_int_unique( S(columnIndex), S(rowIndex), value);
+    } CATCH_STD()
+}
+
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetBoolean(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jboolean value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jboolean value)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Bool))
         return;
@@ -765,7 +660,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetBoolean(
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetFloat(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jfloat value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jfloat value)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Float))
         return;
@@ -775,7 +670,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetFloat(
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetDouble(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jdouble value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jdouble value)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Double))
         return;
@@ -785,7 +680,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetDouble(
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetString(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jstring value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jstring value)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_String))
         return;
@@ -800,8 +695,26 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetString(
     } CATCH_STD()
 }
 
+JNIEXPORT void JNICALL
+Java_io_realm_internal_Table_nativeSetStringUnique(JNIEnv *env, jclass, jlong nativeTablePtr, jlong columnIndex,
+                                                   jlong rowIndex, jstring value)
+{
+    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_String))
+        return;
+    try {
+        if (value == NULL) {
+            if (!TBL_AND_COL_NULLABLE(env, TBL(nativeTablePtr), columnIndex)) {
+                return;
+            }
+        }
+        JStringAccessor value2(env, value); // throws
+        // FIXME: Check if we need to call set_null_unique when core support it.
+        TBL(nativeTablePtr)->set_string_unique(S(columnIndex), S(rowIndex), value2);
+    } CATCH_STD()
+}
+
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetTimestamp(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong timestampValue)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jlong timestampValue)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Timestamp))
         return;
@@ -823,25 +736,22 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteBuffer(
 */
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteArray(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jbyteArray dataArray)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex, jbyteArray dataArray)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Binary))
         return;
     try {
-        if (dataArray == NULL) {
-            if (!TBL_AND_COL_NULLABLE(env, TBL(nativeTablePtr), columnIndex)) {
+        if (dataArray == NULL && !TBL_AND_COL_NULLABLE(env, TBL(nativeTablePtr), columnIndex)) {
                 return;
-            }
-            TBL(nativeTablePtr)->set_binary(S(columnIndex), S(rowIndex), BinaryData());
-        }
-        else {
-            tbl_nativeDoByteArray(&Table::set_binary, TBL(nativeTablePtr), env, columnIndex, rowIndex, dataArray);
         }
+
+        JniByteArray byteAccessor(env, dataArray);
+        TBL(nativeTablePtr)->set_binary(S(columnIndex), S(rowIndex), byteAccessor);
     } CATCH_STD()
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetNull(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
 {
     Table* pTable = TBL(nativeTablePtr);
     if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
@@ -855,16 +765,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetNull(
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeClearSubtable(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
-{
-    if (!TBL_AND_INDEX_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex))
-        return;
-    try {
-        TBL(nativeTablePtr)->clear_subtable( S(columnIndex), S(rowIndex));
-    } CATCH_STD()
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetRowPtr
   (JNIEnv* env, jobject, jlong nativeTablePtr, jlong index)
 {
@@ -931,7 +831,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsNullLink
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeNullifyLink
-  (JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+  (JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Link))
         return;
@@ -1159,8 +1059,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeWhere(
     if (!TABLE_VALID(env, TBL(nativeTablePtr)))
         return 0;
     try {
-        Query query = TBL(nativeTablePtr)->where();
-        TableQuery* queryPtr = new TableQuery(query);
+        Query *queryPtr = new Query(TBL(nativeTablePtr)->where());
         return reinterpret_cast<jlong>(queryPtr);
     } CATCH_STD()
     return 0;
@@ -1169,7 +1068,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeWhere(
 //----------------------- FindFirst
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstInt(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jlong value)
 {
     if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int))
         return 0;
@@ -1225,7 +1124,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstTimestamp(
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstString(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jstring value)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex, jstring value)
 {
     if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_String))
         return 0;
@@ -1238,7 +1137,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstString(
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstNull(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
+    JNIEnv* env, jclass, jlong nativeTablePtr, jlong columnIndex)
 {
     Table* pTable = TBL(nativeTablePtr);
     if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
@@ -1391,31 +1290,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetDistinctView(
 }
 
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedView(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jboolean ascending)
-{
-    Table* pTable = TBL(nativeTablePtr);
-    if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
-        return 0;
-    int colType = pTable->get_column_type( S(columnIndex) );
-    switch (colType) {
-        case type_Int:
-        case type_Bool:
-        case type_String:
-        case type_Double:
-        case type_Float:
-        case type_Timestamp:
-            try {
-                TableView* pTableView = new TableView( pTable->get_sorted_view(S(columnIndex), ascending != 0 ? true : false) );
-                return reinterpret_cast<jlong>(pTableView);
-            } CATCH_STD()
-        default:
-            ThrowException(env, IllegalArgument, "Sort is only support on String, Date, boolean, byte, short, int, long and their boxed variants.");
-            return 0;
-    }
-    return 0;
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti(
    JNIEnv *env, jobject, jlong nativeTablePtr, jlongArray columnIndices, jbooleanArray ascending)
 {
@@ -1439,7 +1313,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti(
         return 0;
     }
 
-    std::vector<size_t> indices(S(arr_len));
+    std::vector<std::vector<size_t>> indices(S(arr_len));
     std::vector<bool> ascendings(S(arr_len));
 
     for (int i = 0; i < arr_len; ++i) {
@@ -1454,7 +1328,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti(
             case type_Double:
             case type_Float:
             case type_Timestamp:
-                indices[i] = S(long_arr[i]);
+                indices[i] = std::vector<size_t> { S(long_arr[i]) };
                 ascendings[i] = S(bool_arr[i]);
                 break;
             default:
@@ -1464,22 +1338,12 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti(
     }
 
     try {
-        TableView* pTableView = new TableView(pTable->get_sorted_view(indices, ascendings));
+        TableView* pTableView = new TableView(pTable->get_sorted_view(SortDescriptor(*pTable, indices, ascendings)));
         return reinterpret_cast<jlong>(pTableView);
     } CATCH_STD()
     return 0;
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeOptimize(
-    JNIEnv* env, jobject, jlong nativeTablePtr)
-{
-    if (!TABLE_VALID(env, TBL(nativeTablePtr)))
-        return;
-    try {
-        TBL(nativeTablePtr)->optimize();
-    } CATCH_STD()
-}
-
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetName(
     JNIEnv *env, jobject, jlong nativeTablePtr)
 {
@@ -1487,8 +1351,7 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetName(
         Table* table = TBL(nativeTablePtr);
         if (!TABLE_VALID(env, table))
             return NULL;
-        const string str = table->get_name();
-        return to_jstring(env, str);
+        return to_jstring(env, table->get_name());
     } CATCH_STD()
     return NULL;
 }
@@ -1512,47 +1375,6 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToJson(
     return NULL;
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToString(
-    JNIEnv *env, jobject, jlong nativeTablePtr, jlong maxRows)
-{
-    Table* table = TBL(nativeTablePtr);
-    if (!TABLE_VALID(env, table))
-        return NULL;
-    try {
-        ostringstream ss;
-        table->to_string(ss, S(maxRows));
-        const string str = ss.str();
-        return to_jstring(env, str);
-    } CATCH_STD()
-    return NULL;
-}
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeRowToString(
-    JNIEnv *env, jobject, jlong nativeTablePtr, jlong rowIndex)
-{
-    Table* table = TBL(nativeTablePtr);
-    if (!TBL_AND_ROW_INDEX_VALID(env, table, rowIndex))
-        return NULL;
-    try {
-        ostringstream ss;
-        table->row_to_string(S(rowIndex), ss);
-        const string str = ss.str();
-        return to_jstring(env, str);
-    } CATCH_STD()
-    return NULL;
-}
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeEquals(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong nativeTableToComparePtr)
-{
-    Table* tbl = TBL(nativeTablePtr);
-    Table* tblToCompare = TBL(nativeTableToComparePtr);
-    try {
-        return (*tbl == *tblToCompare);
-    } CATCH_STD()
-    return false;
-}
-
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsValid(
     JNIEnv*, jobject, jlong nativeTablePtr)
 {
@@ -1560,25 +1382,24 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsValid(
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeClose(
-    JNIEnv*, jclass, jlong nativeTablePtr)
+    JNIEnv* env, jclass, jlong nativeTablePtr)
 {
-    TR_ENTER_PTR(nativeTablePtr)
+    TR_ENTER_PTR(env, nativeTablePtr)
     LangBindHelper::unbind_table_ptr(TBL(nativeTablePtr));
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_createNative(JNIEnv *env, jobject)
 {
-    TR_ENTER()
+    TR_ENTER(env)
     try {
         return reinterpret_cast<jlong>(LangBindHelper::new_table());
     } CATCH_STD()
     return 0;
 }
 
-
 // Checks if the primary key column contains any duplicate values, making it ineligible as a
 // primary key.
-bool check_valid_primary_key_column(JNIEnv* env, Table* table, StringData column_name) // throws
+static bool check_valid_primary_key_column(JNIEnv* env, Table* table, StringData column_name) // throws
 {
     size_t column_index = table->get_column_index(column_name);
     if (column_index == realm::not_found) {
@@ -1699,7 +1520,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTable
     const size_t CLASS_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX;
     const size_t FIELD_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX;
 
-    Group* group = G(groupNativePtr);
+    auto group = reinterpret_cast<Group*>(groupNativePtr);
     Table* pk_table = TBL(privateKeyTableNativePtr);
 
     // Fix wrong types (string, int) -> (string, string)
@@ -1737,7 +1558,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTable
 }
 
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSameSchema
-  (JNIEnv *, jobject, jlong thisTablePtr, jlong otherTablePtr)
+  (JNIEnv*, jobject, jlong thisTablePtr, jlong otherTablePtr)
 {
     return *TBL(thisTablePtr)->get_descriptor() == *TBL(otherTablePtr)->get_descriptor();
 }
@@ -1749,7 +1570,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeVersion(
     bool valid = (TBL(nativeTablePtr) != NULL);
     if (valid) {
         if (!TBL(nativeTablePtr)->is_attached()) {
-            ThrowException(env, TableInvalid, "The Realm has been closed and is no longer accessible.");
+            ThrowException(env, IllegalState, "The Realm has been closed and is no longer accessible.");
             return 0;
         }
     }
diff --git a/realm/realm-jni/src/io_realm_internal_TableQuery.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
similarity index 86%
rename from realm/realm-jni/src/io_realm_internal_TableQuery.cpp
rename to realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
index 8f1f779bda..2f038e1d69 100644
--- a/realm/realm-jni/src/io_realm_internal_TableQuery.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
@@ -16,10 +16,10 @@
 
 #include <realm.hpp>
 #include <realm/group_shared.hpp>
-#include <realm/commit_log.hpp>
+#include <shared_realm.hpp>
+#include <object_store.hpp>
 #include "util.hpp"
 #include "io_realm_internal_TableQuery.h"
-#include "tablequery.hpp"
 
 using namespace realm;
 
@@ -38,7 +38,7 @@ inline bool query_valid(JNIEnv* env, Query* pQuery)
 
 inline bool query_col_type_valid(JNIEnv* env, jlong nativeQueryPtr, jlong colIndex, DataType type)
 {
-    return TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TQ(nativeQueryPtr)->get_current_table().get(), colIndex, type);
+    return TBL_AND_COL_INDEX_AND_TYPE_VALID(env, Q(nativeQueryPtr)->get_table().get(), colIndex, type);
 }
 
 
@@ -46,8 +46,8 @@ const char* ERR_IMPORT_CLOSED_REALM = "Can not import results from a closed Real
 const char* ERR_SORT_NOT_SUPPORTED = "Sort is not supported on binary data, object references and RealmList";
 //-------------------------------------------------------
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeClose(JNIEnv *, jclass, jlong nativeQueryPtr) {
-    TR_ENTER_PTR(nativeQueryPtr)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeClose(JNIEnv* env, jclass, jlong nativeQueryPtr) {
+    TR_ENTER_PTR(env, nativeQueryPtr)
     delete Q(nativeQueryPtr);
 }
 
@@ -85,9 +85,9 @@ static TableRef getTableByArray(jlong nativeQueryPtr, JniLongArray& indicesArray
     return table_ref;
 }
 
-static jlong findAllWithHandover(JNIEnv* env, jlong bgSharedGroupPtr, std::unique_ptr<Query> query, jlong start, jlong end, jlong limit)
+static jlong findAllWithHandover(JNIEnv* env, jlong bgSharedRealmPtr, std::unique_ptr<Query> query, jlong start, jlong end, jlong limit)
 {
-    TR_ENTER()
+    TR_ENTER(env)
     TableRef table = query.get()->get_table();
     if (!QUERY_VALID(env, query.get()) ||
         !ROW_INDEXES_VALID(env, table.get(), start, end, limit)) {
@@ -97,13 +97,14 @@ static jlong findAllWithHandover(JNIEnv* env, jlong bgSharedGroupPtr, std::uniqu
     TableView tableView(query->find_all(S(start), S(end), S(limit)));
 
     // handover the result
-    std::unique_ptr<SharedGroup::Handover<TableView>> handover = SG(
-            bgSharedGroupPtr)->export_for_handover(tableView, MutableSourcePayload::Move);
+    auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
+    using rf = realm::_impl::RealmFriend;
+    auto handover = rf::get_shared_group(*sharedRealm).export_for_handover(tableView, MutableSourcePayload::Move);
     return reinterpret_cast<jlong>(handover.release());
 }
 
 static jlong getDistinctViewWithHandover
-        (JNIEnv *env, jlong bgSharedGroupPtr, std::unique_ptr<Query> query, jlong columnIndex)
+        (JNIEnv *env, jlong bgSharedRealmPtr, std::unique_ptr<Query> query, jlong columnIndex)
 {
         TableRef table = query->get_table();
         if (!QUERY_VALID(env, query.get()) ||
@@ -118,8 +119,10 @@ static jlong getDistinctViewWithHandover
                 TableView tableView(table->get_distinct_view(S(columnIndex)) );
 
                 // handover the result
-                std::unique_ptr<SharedGroup::Handover<TableView>> handover = SG(
-                        bgSharedGroupPtr)->export_for_handover(tableView, MutableSourcePayload::Move);
+                auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
+                using rf = realm::_impl::RealmFriend;
+                auto handover = rf::get_shared_group(*sharedRealm).export_for_handover(
+                        tableView, MutableSourcePayload::Move);
                 return reinterpret_cast<jlong>(handover.release());
             }
             default:
@@ -130,7 +133,7 @@ static jlong getDistinctViewWithHandover
 }
 
 static jlong findAllSortedWithHandover
-        (JNIEnv *env, jlong bgSharedGroupPtr, std::unique_ptr<Query> query, jlong start, jlong end, jlong limit, jlong columnIndex, jboolean ascending)
+        (JNIEnv *env, jlong bgSharedRealmPtr, std::unique_ptr<Query> query, jlong start, jlong end, jlong limit, jlong columnIndex, jboolean ascending)
 {
         TableRef table =  query->get_table();
 
@@ -162,73 +165,75 @@ static jlong findAllSortedWithHandover
         }
 
         // handover the result
-        std::unique_ptr<SharedGroup::Handover<TableView> > handover = SG(bgSharedGroupPtr)->export_for_handover(tableView, MutableSourcePayload::Move);
+        auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
+        using rf = realm::_impl::RealmFriend;
+        auto handover = rf::get_shared_group(*sharedRealm).export_for_handover(tableView, MutableSourcePayload::Move);
         return reinterpret_cast<jlong>(handover.release());
 }
 
 static jlong findAllMultiSortedWithHandover
-        (JNIEnv *env, jlong bgSharedGroupPtr, std::unique_ptr<Query> query, jlong start, jlong end, jlong limit, jlongArray columnIndices, jbooleanArray ascending)
+        (JNIEnv *env, jlong bgSharedRealmPtr, std::unique_ptr<Query> query, jlong start, jlong end, jlong limit, jlongArray columnIndices, jbooleanArray ascending)
 {
-        JniLongArray long_arr(env, columnIndices);
-        JniBooleanArray bool_arr(env, ascending);
-        jsize arr_len = long_arr.len();
-        jsize asc_len = bool_arr.len();
+    JniLongArray long_arr(env, columnIndices);
+    JniBooleanArray bool_arr(env, ascending);
+    jsize arr_len = long_arr.len();
+    jsize asc_len = bool_arr.len();
 
-        if (arr_len == 0) {
-            ThrowException(env, IllegalArgument, "You must provide at least one field name.");
-            return 0;
-        }
-        if (asc_len == 0) {
-            ThrowException(env, IllegalArgument, "You must provide at least one sort order.");
-            return 0;
-        }
-        if (arr_len != asc_len) {
-            ThrowException(env, IllegalArgument, "Number of fields and sort orders do not match.");
-            return 0;
-        }
-
-        TableRef table = query->get_table();
+    if (arr_len == 0) {
+        ThrowException(env, IllegalArgument, "You must provide at least one field name.");
+        return 0;
+    }
+    if (asc_len == 0) {
+        ThrowException(env, IllegalArgument, "You must provide at least one sort order.");
+        return 0;
+    }
+    if (arr_len != asc_len) {
+        ThrowException(env, IllegalArgument, "Number of fields and sort orders do not match.");
+        return 0;
+    }
 
-        if (!QUERY_VALID(env, query.get()) || !ROW_INDEXES_VALID(env, table.get(), start, end, limit)) {
-            return 0;
-        }
+    TableRef table = query->get_table();
 
-        // run the query
-        TableView tableView( query->find_all(S(start), S(end), S(limit)) );
+    if (!QUERY_VALID(env, query.get()) || !ROW_INDEXES_VALID(env, table.get(), start, end, limit)) {
+        return 0;
+    }
 
-        // sorting the results
-        std::vector<size_t> indices;
-        std::vector<bool> ascendings;
+    // run the query
+    TableView tableView( query->find_all(S(start), S(end), S(limit)) );
 
-        for (int i = 0; i < arr_len; ++i) {
-            if (!COL_INDEX_VALID(env, &tableView, long_arr[i])) {
-                return -1;
-            }
-            int colType = tableView.get_column_type( S(long_arr[i]) );
-            switch (colType) {
-                case type_Bool:
-                case type_Int:
-                case type_Float:
-                case type_Double:
-                case type_String:
-                case type_Timestamp:
-                    indices.push_back( S(long_arr[i]) );
-                    ascendings.push_back( B(bool_arr[i]) );
-                    break;
-                default:
-                    ThrowException(env, IllegalArgument, ERR_SORT_NOT_SUPPORTED);
-                    return 0;
-            }
+    // sorting the results
+    std::vector<std::vector<size_t>> indices;
+    std::vector<bool> ascendings;
+    for (int i = 0; i < arr_len; ++i) {
+        if (!COL_INDEX_VALID(env, &tableView, long_arr[i])) {
+            return -1;
         }
+        int colType = tableView.get_column_type( S(long_arr[i]) );
+        switch (colType) {
+            case type_Bool:
+            case type_Int:
+            case type_Float:
+            case type_Double:
+            case type_String:
+            case type_Timestamp:
+                indices.push_back(std::vector<size_t> { S(long_arr[i]) });
+                ascendings.push_back( B(bool_arr[i]) );
+                break;
+            default:
+                ThrowException(env, IllegalArgument, ERR_SORT_NOT_SUPPORTED);
+                return 0;
+        }
+    }
 
-        tableView.sort(indices, ascendings);
+    tableView.sort(SortDescriptor(*table, indices, ascendings));
 
-        // handover the result
-        std::unique_ptr<SharedGroup::Handover<TableView> > handover = SG(bgSharedGroupPtr)->export_for_handover(tableView, MutableSourcePayload::Move);
-        return reinterpret_cast<jlong>(handover.release());
+    // handover the result
+    auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
+    using rf = realm::_impl::RealmFriend;
+    auto handover = rf::get_shared_group(*sharedRealm).export_for_handover(tableView, MutableSourcePayload::Move);
+    return reinterpret_cast<jlong>(handover.release());
 }
 
-
 template <typename coretype, typename cpptype, typename javatype>
 Query numeric_link_equal(TableRef tbl, jlong columnIndex, javatype value) {
     return tbl->column<coretype>(size_t(columnIndex)) == cpptype(value);
@@ -830,7 +835,7 @@ enum StringPredicate {
 };
 
 
-void TableQuery_StringPredicate(JNIEnv *env, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive, StringPredicate predicate) {
+static void TableQuery_StringPredicate(JNIEnv *env, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive, StringPredicate predicate) {
     JniLongArray arr(env, columnIndexes);
     jsize arr_len = arr.len();
     try {
@@ -916,6 +921,71 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeContains(
     TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringContains);
 }
 
+// Binary
+
+enum BinaryPredicate {
+    BinaryEqual,
+    BinaryNotEqual
+};
+
+static void TableQuery_BinaryPredicate(JNIEnv *env, jlong nativeQueryPtr, jlongArray columnIndices, jbyteArray value, BinaryPredicate predicate) {
+    JniLongArray arr(env, columnIndices);
+    jsize arr_len = arr.len();
+    try {
+        JniByteArray bytes(env, value);
+        BinaryData value2;
+        if (value == NULL) {
+            if (!TBL_AND_COL_NULLABLE(env, getTableByArray(nativeQueryPtr, arr).get(), arr[arr_len-1])) {
+                return;
+            }
+            value2 = BinaryData();
+        }
+        else {
+            if (!bytes.ptr()) {
+                ThrowException(env, IllegalArgument, "binaryPredicate");
+                return;
+            }
+            value2 = BinaryData(reinterpret_cast<char*>(bytes.ptr()), S(bytes.len()));
+        }
+
+        if (arr_len == 1) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Binary)) {
+                return;
+            }
+            switch (predicate) {
+            case BinaryEqual:
+                Q(nativeQueryPtr)->equal(S(arr[0]), value2);
+                break;
+            case BinaryNotEqual:
+                Q(nativeQueryPtr)->not_equal(S(arr[0]), value2);
+                break;
+            }
+        }
+        else {
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            switch (predicate) {
+            case BinaryEqual:
+                Q(nativeQueryPtr)->and_query(table_ref->column<Binary>(size_t(arr[arr_len-1])) == value2);
+                break;
+            case BinaryNotEqual:
+                Q(nativeQueryPtr)->and_query(table_ref->column<Binary>(size_t(arr[arr_len-1])) != value2);
+                break;
+            }
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3J_3B
+  (JNIEnv *env, jobject, jlong nativeQueryPtr, jlongArray columnIndices, jbyteArray value)
+{
+    TableQuery_BinaryPredicate(env, nativeQueryPtr, columnIndices, value, BinaryEqual);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3J_3B
+  (JNIEnv *env, jobject, jlong nativeQueryPtr, jlongArray columnIndices, jbyteArray value)
+{
+    TableQuery_BinaryPredicate(env, nativeQueryPtr, columnIndices, value, BinaryNotEqual);
+}
 
 // General ----------------------------------------------------
 // TODO:
@@ -979,40 +1049,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNot(
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeSubtable(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlong columnIndex)
-{
-    TableQuery* pTQuery = TQ(nativeQueryPtr);
-    if (!QUERY_VALID(env, pTQuery))
-        return;
-
-    try {
-        Table* pTable = pTQuery->get_current_table().get();
-        pTQuery->push_subtable(S(columnIndex));
-        if (!COL_INDEX_AND_TYPE_VALID(env, pTable, columnIndex, type_Table))
-            return;
-
-        pTQuery->subtable(S(columnIndex));
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeParent(
-    JNIEnv* env, jobject, jlong nativeQueryPtr)
-{
-    TableQuery* pTQuery = TQ(nativeQueryPtr);
-    if (!QUERY_VALID(env, pTQuery))
-        return;
-    try {
-        if (pTQuery->pop_subtable()) {
-            pTQuery->end_subtable();
-        }
-        else {
-            ThrowException(env, UnsupportedOperation, "No matching subtable().");
-        }
-    } CATCH_STD()
-}
-
-
 // Find --------------------------------------
 
 
@@ -1037,9 +1073,9 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFind(
     return -1;
 }
 
-// Returns a pointer to query on the worker SharedGroup or throw a BadVersion if the SharedGroup version required
+// Returns a pointer to query on the worker SharedRealm or throw a BadVersion if the SharedRealm version required
 // for the handover is no longer available.
-std::unique_ptr<Query> handoverQueryToWorker(jlong bgSharedGroupPtr, jlong queryPtr, bool advanceToLatestVersion)
+static std::unique_ptr<Query> handoverQueryToWorker(jlong bgSharedRealmPtr, jlong queryPtr, bool advanceToLatestVersion)
 {
     SharedGroup::Handover<Query> *handoverQueryPtr = HO(Query, queryPtr);
     std::unique_ptr<SharedGroup::Handover<Query>> handoverQuery(handoverQueryPtr);
@@ -1047,19 +1083,13 @@ std::unique_ptr<Query> handoverQueryToWorker(jlong bgSharedGroupPtr, jlong query
     // The Handover object doesn't prevent a SharedGroup version from no longer being accessible. In rare
     // cases this means that the version in the Handover object is invalid and Realm Core will throw a
     // BadVersion as result.
-    realm::SharedGroup* sg = SG(bgSharedGroupPtr);
-    if (sg->get_transact_stage() != SharedGroup::transact_Reading) {
-        // if the SharedGroup is not in Read Transaction, we position it at the same version as the handover
-        sg->begin_read(handoverQuery->version);
-    } else if (sg->get_version_of_current_transaction() != handoverQuery->version) {
-        sg->end_read();
-        sg->begin_read(handoverQuery->version);
-    }
-
-    std::unique_ptr<Query> query = sg->import_from_handover(std::move(handoverQuery));
+    auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
+    using rf = realm::_impl::RealmFriend;
+    rf::read_group_to(*sharedRealm, handoverQuery->version);
+    auto query = rf::get_shared_group(*sharedRealm).import_from_handover(std::move(handoverQuery));
 
     if (advanceToLatestVersion) {
-        LangBindHelper::advance_read(*sg);
+        sharedRealm->refresh();
     }
 
     return query;
@@ -1067,11 +1097,11 @@ std::unique_ptr<Query> handoverQueryToWorker(jlong bgSharedGroupPtr, jlong query
 
 // queryPtr would be owned and released by this function
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindWithHandover(
-    JNIEnv* env, jobject, jlong bgSharedGroupPtr, jlong queryPtr, jlong fromTableRow)
+    JNIEnv* env, jclass, jlong bgSharedRealmPtr, jlong queryPtr, jlong fromTableRow)
 {
-    TR_ENTER()
+    TR_ENTER(env)
     try {
-        std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedGroupPtr, queryPtr, false); // throws
+        std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedRealmPtr, queryPtr, false); // throws
         TableRef table = query->get_table();
 
         if (!QUERY_VALID(env, query.get())) {
@@ -1091,8 +1121,9 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindWithHandover
         } else {
             // handover the result
             Row row = (*table)[r];
-            std::unique_ptr<SharedGroup::Handover<Row>> handover = SG(
-                    bgSharedGroupPtr)->export_for_handover(row);
+            auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
+            using rf = realm::_impl::RealmFriend;
+            auto handover = rf::get_shared_group(*sharedRealm).export_for_handover(row);
             return reinterpret_cast<jlong>(handover.release());
         }
 
@@ -1104,7 +1135,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindWithHandover
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAll(
     JNIEnv* env, jobject, jlong nativeQueryPtr, jlong start, jlong end, jlong limit)
 {
-    TR_ENTER()
+    TR_ENTER(env)
     Query* query = Q(nativeQueryPtr);
     TableRef table =  query->get_table();
     if (!QUERY_VALID(env, query) ||
@@ -1119,12 +1150,12 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAll(
 
 // queryPtr would be owned and released by this function
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllWithHandover
-  (JNIEnv* env, jobject, jlong bgSharedGroupPtr, jlong queryPtr, jlong start, jlong end, jlong limit)
+  (JNIEnv* env, jclass, jlong bgSharedRealmPtr, jlong queryPtr, jlong start, jlong end, jlong limit)
   {
-      TR_ENTER()
+      TR_ENTER(env)
       try {
-          std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedGroupPtr, queryPtr, true); // throws
-          return findAllWithHandover(env, bgSharedGroupPtr, std::move(query), start, end, limit);
+          std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedRealmPtr, queryPtr, true); // throws
+          return findAllWithHandover(env, bgSharedRealmPtr, std::move(query), start, end, limit);
       } CATCH_STD()
       return 0;
   }
@@ -1136,13 +1167,13 @@ enum query_type {QUERY_TYPE_FIND_ALL = 0, QUERY_TYPE_DISTINCT = 4, QUERY_TYPE_FI
 
 // batch update of async queries
 JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdateQueries
-        (JNIEnv *env, jobject, jlong bgSharedGroupPtr,
+        (JNIEnv *env, jclass, jlong bgSharedRealmPtr,
          jlongArray  handover_queries_array /*list of handover queries*/,
          jobjectArray  query_param_matrix /*type & params of the query to be updated*/,
          jobjectArray  multi_sorted_indices_matrix,
          jobjectArray  multi_sorted_order_matrix)
 {
-    TR_ENTER()
+    TR_ENTER(env)
     try {
         JniLongArray handover_queries_pointer_array(env, handover_queries_array);
 
@@ -1159,37 +1190,37 @@ JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdate
         // The Handover object doesn't prevent a SharedGroup version from no longer being accessible. In rare
         // cases this means that the version in the Handover object is invalid and Realm Core will throw a
         // BadVersion as result.
-        realm::SharedGroup* sg = SG(bgSharedGroupPtr);
-        if (sg->get_transact_stage() != SharedGroup::transact_Reading) {
-            sg->begin_read(handoverQuery->version);
-        } else if (sg->get_version_of_current_transaction() != handoverQuery->version) {
-            sg->end_read();
-            sg->begin_read(handoverQuery->version);
-        }
+        auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
+        using rf = realm::_impl::RealmFriend;
+        rf::read_group_to(*sharedRealm, handoverQuery->version);
 
         std::vector<std::unique_ptr<Query>> queries(number_of_queries);
 
         // import the first query
-        queries[0] = std::move(sg->import_from_handover(std::move(handoverQuery)));
+        queries[0] = rf::get_shared_group(*sharedRealm).import_from_handover(std::move(handoverQuery));
 
         // import the rest of the queries
         for (size_t i = 1; i < number_of_queries; ++i) {
             std::unique_ptr<SharedGroup::Handover<Query>> handoverQuery(HO(Query, handover_queries_pointer_array[i]));
-            queries[i] = std::move(sg->import_from_handover(std::move(handoverQuery)));
+            using rf = realm::_impl::RealmFriend;
+            queries[i] = rf::get_shared_group(*sharedRealm).import_from_handover(std::move(handoverQuery));
         }
 
         // Step2: Bring the queries into the latest shared group version
-        LangBindHelper::advance_read(*sg);
+        sharedRealm->refresh();
 
         // Step3: Run & export the queries against the latest shared group
         for (size_t i = 0; i < number_of_queries; ++i) {
-            JniLongArray query_param_array(env, (jlongArray) env->GetObjectArrayElement(query_param_matrix, i));
+            // Delete the local ref since we might have a long loop
+            JniLocalRef<jlongArray> local_ref(env, (jlongArray) env->GetObjectArrayElement(query_param_matrix, i));
+            JniLongArray query_param_array(env, local_ref);
+
             switch (query_param_array[0]) { // 0, index of the type of query, the next indicies are parameters
                 case QUERY_TYPE_FIND_ALL: {// nativeFindAllWithHandover
                     exported_handover_tableview_array[i] =
                             findAllWithHandover
                                     (env,
-                                     bgSharedGroupPtr,
+                                     bgSharedRealmPtr,
                                      std::move(queries[i]),
                                      query_param_array[1]/*start*/,
                                      query_param_array[2]/*end*/,
@@ -1200,7 +1231,7 @@ JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdate
                     exported_handover_tableview_array[i] =
                             getDistinctViewWithHandover
                                     (env,
-                                     bgSharedGroupPtr,
+                                     bgSharedRealmPtr,
                                      std::move(queries[i]),
                                      query_param_array[1]/*columnIndex*/);
                     break;
@@ -1209,7 +1240,7 @@ JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdate
                     exported_handover_tableview_array[i] =
                             findAllSortedWithHandover
                                     (env,
-                                     bgSharedGroupPtr,
+                                     bgSharedRealmPtr,
                                      std::move(queries[i]),
                                      query_param_array[1]/*start*/,
                                      query_param_array[2]/*end*/,
@@ -1226,7 +1257,7 @@ JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdate
                     exported_handover_tableview_array[i] =
                             findAllMultiSortedWithHandover
                                     (env,
-                                     bgSharedGroupPtr,
+                                     bgSharedRealmPtr,
                                      std::move(queries[i]),
                                      query_param_array[1]/*start*/,
                                      query_param_array[2]/*end*/,
@@ -1256,35 +1287,35 @@ JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdate
 
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeGetDistinctViewWithHandover
-        (JNIEnv *env, jobject, jlong bgSharedGroupPtr, jlong queryPtr, jlong columnIndex)
+        (JNIEnv *env, jclass, jlong bgSharedRealmPtr, jlong queryPtr, jlong columnIndex)
 {
-    TR_ENTER()
+    TR_ENTER(env)
     try {
-        std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedGroupPtr, queryPtr, true); // throws
-        return getDistinctViewWithHandover(env, bgSharedGroupPtr, std::move(query), columnIndex);
+        std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedRealmPtr, queryPtr, true); // throws
+        return getDistinctViewWithHandover(env, bgSharedRealmPtr, std::move(query), columnIndex);
     } CATCH_STD()
     return 0;
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllSortedWithHandover
-  (JNIEnv *env, jobject, jlong bgSharedGroupPtr, jlong queryPtr, jlong start, jlong end, jlong limit, jlong columnIndex, jboolean ascending)
+  (JNIEnv *env, jclass, jlong bgSharedRealmPtr, jlong queryPtr, jlong start, jlong end, jlong limit, jlong columnIndex, jboolean ascending)
   {
-      TR_ENTER()
+      TR_ENTER(env)
       try {
-          std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedGroupPtr, queryPtr, true); // throws
-          return findAllSortedWithHandover(env, bgSharedGroupPtr, std::move(query), start, end, limit, columnIndex, ascending);
+          std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedRealmPtr, queryPtr, true); // throws
+          return findAllSortedWithHandover(env, bgSharedRealmPtr, std::move(query), start, end, limit, columnIndex, ascending);
       } CATCH_STD()
       return 0;
   }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllMultiSortedWithHandover
-  (JNIEnv *env, jobject, jlong bgSharedGroupPtr, jlong queryPtr, jlong start, jlong end, jlong limit, jlongArray columnIndices, jbooleanArray ascending)
+  (JNIEnv *env, jclass, jlong bgSharedRealmPtr, jlong queryPtr, jlong start, jlong end, jlong limit, jlongArray columnIndices, jbooleanArray ascending)
   {
-      TR_ENTER()
+      TR_ENTER(env)
       try {
-          // import the handover query pointer using the background SharedGroup
-          std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedGroupPtr, queryPtr, true); // throws
-          return findAllMultiSortedWithHandover(env, bgSharedGroupPtr, std::move(query), start, end, limit,columnIndices, ascending);
+          // import the handover query pointer using the background SharedRealm
+          std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedRealmPtr, queryPtr, true); // throws
+          return findAllMultiSortedWithHandover(env, bgSharedRealmPtr, std::move(query), start, end, limit,columnIndices, ascending);
       } CATCH_STD()
       return 0;
   }
@@ -1581,15 +1612,13 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeCount(
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeRemove(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlong start, jlong end, jlong limit)
+    JNIEnv* env, jobject, jlong nativeQueryPtr)
 {
     Query* pQuery = Q(nativeQueryPtr);
-    Table* pTable = pQuery->get_table().get();
-    if (!QUERY_VALID(env, pQuery) ||
-        !ROW_INDEXES_VALID(env, pTable, start, end, limit))
+    if (!QUERY_VALID(env, pQuery))
         return 0;
     try {
-        return pQuery->remove(S(start), S(end), S(limit));
+        return pQuery->remove();
     } CATCH_STD()
     return 0;
 }
@@ -1680,14 +1709,15 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverTableViewIntoSharedGroup
   (JNIEnv *env, jobject, jlong handoverPtr, jlong callerSharedGrpPtr)
   {
-    TR_ENTER_PTR(handoverPtr)
+    TR_ENTER_PTR(env, handoverPtr)
     SharedGroup::Handover<TableView> *handoverTableViewPtr = HO(TableView, handoverPtr);
     std::unique_ptr<SharedGroup::Handover<TableView>> handoverTableView(handoverTableViewPtr);
     try {
         // import_from_handover will free (delete) the handover
-        if (SG(callerSharedGrpPtr)->is_attached()) {
-            std::unique_ptr<TableView> tableView = SG(callerSharedGrpPtr)->import_from_handover(
-                    std::move(handoverTableView));
+        auto sharedRealm = *(reinterpret_cast<SharedRealm*>(callerSharedGrpPtr));
+        if (!sharedRealm->is_closed()) {
+            using rf = realm::_impl::RealmFriend;
+            auto tableView = rf::get_shared_group(*sharedRealm).import_from_handover(std::move(handoverTableView));
             return reinterpret_cast<jlong>(tableView.release());
         } else {
             ThrowException(env, RuntimeError, ERR_IMPORT_CLOSED_REALM);
@@ -1697,17 +1727,18 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverTa
   }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverRowIntoSharedGroup
-  (JNIEnv *env, jobject, jlong handoverPtr, jlong callerSharedGrpPtr)
+  (JNIEnv *env, jclass, jlong handoverPtr, jlong callerSharedGrpPtr)
   {
-      TR_ENTER_PTR(handoverPtr)
+      TR_ENTER_PTR(env, handoverPtr)
       SharedGroup::Handover<Row> *handoverRowPtr = HO(Row, handoverPtr);
       std::unique_ptr<SharedGroup::Handover<Row>> handoverRow(handoverRowPtr);
 
       try {
           // import_from_handover will free (delete) the handover
-          if (SG(callerSharedGrpPtr)->is_attached()) {
-              std::unique_ptr<Row> row = SG(callerSharedGrpPtr)->import_from_handover(
-                      std::move(handoverRow));
+          auto sharedRealm = *(reinterpret_cast<SharedRealm*>(callerSharedGrpPtr));
+          if (!sharedRealm->is_closed()) {
+              using rf = realm::_impl::RealmFriend;
+              auto row = rf::get_shared_group(*sharedRealm).import_from_handover(std::move(handoverRow));
               return reinterpret_cast<jlong>(row.release());
           } else {
               ThrowException(env, RuntimeError, ERR_IMPORT_CLOSED_REALM);
@@ -1717,24 +1748,26 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverRo
   }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeHandoverQuery
-   (JNIEnv* env, jobject, jlong bgSharedGroupPtr, jlong nativeQueryPtr)
+   (JNIEnv* env, jobject, jlong bgSharedRealmPtr, jlong nativeQueryPtr)
 {
-    TR_ENTER_PTR(nativeQueryPtr)
+    TR_ENTER_PTR(env, nativeQueryPtr)
     Query* pQuery = Q(nativeQueryPtr);
     if (!QUERY_VALID(env, pQuery))
         return 0;
     try {
-        std::unique_ptr<SharedGroup::Handover<Query> > handoverQueryPtr = SG(bgSharedGroupPtr)->export_for_handover(*pQuery, ConstSourcePayload::Copy);
-        return reinterpret_cast<jlong>(handoverQueryPtr.release());
+        auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
+        using rf = realm::_impl::RealmFriend;
+        auto handover = rf::get_shared_group(*sharedRealm).export_for_handover(*pQuery, ConstSourcePayload::Copy);
+        return reinterpret_cast<jlong>(handover.release());
     } CATCH_STD()
     return 0;
 }
 
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeCloseQueryHandover
-  (JNIEnv *, jobject, jlong nativeHandoverQuery)
+  (JNIEnv* env, jclass, jlong nativeHandoverQuery)
   {
-    TR_ENTER_PTR(nativeHandoverQuery)
+    TR_ENTER_PTR(env, nativeHandoverQuery)
     delete HO(Query, nativeHandoverQuery);
   }
 
diff --git a/realm/realm-jni/src/io_realm_internal_tableview.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_TableView.cpp
similarity index 84%
rename from realm/realm-jni/src/io_realm_internal_tableview.cpp
rename to realm/realm-library/src/main/cpp/io_realm_internal_TableView.cpp
index 7d5d6451af..b4d561be94 100644
--- a/realm/realm-jni/src/io_realm_internal_tableview.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_TableView.cpp
@@ -15,10 +15,8 @@
  */
 
 #include "util.hpp"
-#include "io_realm_internal_TableView.h"
-#include "mixedutil.hpp"
 #include "tablebase_tpl.hpp"
-#include "tablequery.hpp"
+#include "io_realm_internal_TableView.h"
 #include "realm/array.hpp"
 #include <ostream>
 
@@ -31,7 +29,7 @@ inline bool view_valid_and_in_sync(JNIEnv* env, jlong nativeViewPtr) {
     bool valid = (TV(nativeViewPtr) != NULL);
     if (valid) {
         if (!TV(nativeViewPtr)->is_attached()) {
-            ThrowException(env, TableInvalid, "The Realm has been closed and is no longer accessible.");
+            ThrowException(env, IllegalState, "The Realm has been closed and is no longer accessible.");
             return false;
         }
         // depends_on_deleted_linklist() will return true if and only if the current TableView was created from a
@@ -87,30 +85,33 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeDistinctMulti(
     if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
         return;
     try {
+        TableView* tv = TV(nativeViewPtr);
         JniLongArray indexes(env, columnIndexes);
         jsize indexes_len = indexes.len();
-        std::vector<size_t> columns;
+        std::vector<std::vector<size_t>> columns;
+        std::vector<bool> ascending;
         for (int i = 0; i < indexes_len; ++i) {
-            if (!COL_INDEX_VALID(env, TV(nativeViewPtr), indexes[i])) {
+            if (!COL_INDEX_VALID(env, tv, indexes[i])) {
                 return;
             }
-            if (!TV(nativeViewPtr)->get_parent().has_search_index(S(indexes[i]))) {
+            if (!tv->get_parent().has_search_index(S(indexes[i]))) {
                 ThrowException(env, IllegalArgument, "The field must be indexed before distinct(...) can be used.");
                 return;
             }
-            switch (TV(nativeViewPtr)->get_column_type(S(indexes[i]))) {
+            switch (tv->get_column_type(S(indexes[i]))) {
                 case type_Bool:
                 case type_Int:
                 case type_String:
                 case type_Timestamp:
-                    columns.push_back(S(indexes[i]));
+                    columns.push_back(std::vector<size_t> { S(indexes[i]) });
+                    ascending.push_back(true);
                     break;
                 default:
                     ThrowException(env, IllegalArgument, "Invalid type - Only String, Date, boolean, byte, short, int, long and their boxed variants are supported.");
                     return;
             }
         }
-        TV(nativeViewPtr)->distinct(columns);
+        tv->distinct(SortDescriptor(tv->get_parent(), columns, ascending));
     } CATCH_STD()
 }
 
@@ -293,19 +294,6 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeGetString(
     return NULL;
 }
 
-/*
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeGetBinary(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    if (!VIEW_VALID(env, nativeViewPtr) ||
-        !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Binary))
-        return NULL;
-    // TODO: Does the native binary get freed?
-    BinaryData bin = TV(nativeViewPtr)->get_binary( S(columnIndex), S(rowIndex));  // noexcept
-    return env->NewDirectByteBuffer(const_cast<char*>(bin.data()),  static_cast<jlong>(bin.size()));
-}
-*/
-
 JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_TableView_nativeGetByteArray(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
 {
@@ -318,31 +306,6 @@ JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_TableView_nativeGetByteArray
     return NULL;
 }
 
-JNIEXPORT jint JNICALL Java_io_realm_internal_TableView_nativeGetMixedType(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Mixed))
-            return 0;
-    } CATCH_STD()
-    DataType mixedType = TV(nativeViewPtr)->get_mixed_type( S(columnIndex), S(rowIndex));  // noexcept
-    return static_cast<jint>(mixedType);
-}
-
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeGetMixed(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Mixed))
-            return NULL;
-        Mixed value = TV(nativeViewPtr)->get_mixed( S(columnIndex), S(rowIndex));   // noexcept
-        return CreateJMixedFromMixed(env, value);
-    } CATCH_STD()
-    return NULL;
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetLink
   (JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
 {
@@ -354,41 +317,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetLink
     return TV(nativeViewPtr)->get_link( S(columnIndex), S(rowIndex));  // noexcept
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetSubtableSize(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Table))
-            return 0;
-    } CATCH_STD()
-    return TV(nativeViewPtr)->get_subtable_size( S(columnIndex), S(rowIndex));  // noexcept
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetSubtable(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID_MIXED(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Table))
-            return 0;
-        Table* pSubtable = LangBindHelper::get_subtable_ptr(TV(nativeViewPtr), S(columnIndex), S(rowIndex));
-        return reinterpret_cast<jlong>(pSubtable);
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeClearSubtable(
-   JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Table))
-            return;
-    } CATCH_STD()
-    TV(nativeViewPtr)->clear_subtable(S(columnIndex), S(rowIndex));  // noexcept
-}
-
 // Setters
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetLong(
@@ -435,7 +363,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetDouble(
     } CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetTimestamp(
+JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetTimestampValue(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex, jlong timestampValue)
 {
     try {
@@ -462,19 +390,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetString(
     } CATCH_STD()
 }
 
-/*
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetBinary(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex, jobject byteBuffer)
-{
-    if (!VIEW_VALID(env, nativeViewPtr) ||
-        !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Binary))
-        return;
-    try {
-        tbl_nativeDoBinary(&TableView::set_binary, TV(nativeViewPtr), env, columnIndex, rowIndex, byteBuffer);
-    } CATCH_STD()
-}
-*/
-
 JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetByteArray(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex, jbyteArray byteArray)
 {
@@ -482,18 +397,9 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetByteArray(
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
             !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Binary))
             return;
-        tbl_nativeDoByteArray(&TableView::set_binary, TV(nativeViewPtr), env, columnIndex, rowIndex, byteArray);
-    } CATCH_STD()
-}
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetMixed(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex, jobject jMixedValue)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex))
-            return;
-        tbl_nativeDoMixed(&TableView::set_mixed, TV(nativeViewPtr), env, columnIndex, rowIndex, jMixedValue);
+        JniByteArray bytesAccessor(env, byteArray);
+        TV(nativeViewPtr)->set_binary(S(columnIndex), S(rowIndex), bytesAccessor);
     } CATCH_STD()
 }
 
@@ -712,9 +618,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllString(
             !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_String))
             return 0;
         JStringAccessor value2(env, value); // throws
-        TR("nativeFindAllString(col %" PRId64 ", string '%s') ", S64(columnIndex), StringData(value2).data())
         TableView* pResultView = new TableView( TV(nativeViewPtr)->find_all_string( S(columnIndex), value2) );
-        TR("-- resultview size=%" PRId64 ".", S64(pResultView->size()))
         return reinterpret_cast<jlong>(pResultView);
     } CATCH_STD()
     return 0;
@@ -932,7 +836,6 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumTimestam
 }
 
 // sort
-
 JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSort(
     JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jboolean ascending)
 {
@@ -983,14 +886,15 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSortMulti(
             return;
         }
 
-        std::vector<size_t> indices;
+        TableView* tv = TV(nativeViewPtr);
+        std::vector<std::vector<size_t>> indices;
         std::vector<bool> ascendings;
 
         for (int i = 0; i < arr_len; ++i) {
-            if (!COL_INDEX_VALID(env, TV(nativeViewPtr), long_arr[i])) {
+            if (!COL_INDEX_VALID(env, tv, long_arr[i])) {
                 return;
             }
-            int colType = TV(nativeViewPtr)->get_column_type( S(long_arr[i]) );
+            int colType = tv->get_column_type( S(long_arr[i]) );
             switch (colType) {
                 case type_Bool:
                 case type_Int:
@@ -998,7 +902,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSortMulti(
                 case type_Double:
                 case type_String:
                 case type_Timestamp:
-                    indices.push_back( S(long_arr[i]) );
+                    indices.push_back(std::vector<size_t> { S(long_arr[i]) });
                     ascendings.push_back( B(bool_arr[i]) );
                     break;
                 default:
@@ -1006,7 +910,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSortMulti(
                     return;
             }
         }
-        TV(nativeViewPtr)->sort(indices, ascendings);
+        tv->sort(SortDescriptor(tv->get_parent(), indices, ascendings));
     } CATCH_STD()
 }
 
@@ -1027,47 +931,15 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeToJson(
     return NULL;
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeToString(
-    JNIEnv *env, jobject, jlong nativeViewPtr, jlong maxRows)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
-            return NULL;
-
-        std::ostringstream ss;
-        ss.sync_with_stdio(false); // for performance
-        TV(nativeViewPtr)->to_string(ss, S(maxRows));
-        const std::string str = ss.str();
-        return to_jstring(env, str);
-    } CATCH_STD()
-    return NULL;
-}
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeRowToString(
-    JNIEnv *env, jobject, jlong nativeViewPtr, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) || !ROW_INDEX_VALID(env, TV(nativeViewPtr), rowIndex))
-            return NULL;
-
-        std::ostringstream ss;
-        TV(nativeViewPtr)->row_to_string(S(rowIndex), ss);
-        const std::string str = ss.str();
-        return to_jstring(env, str);
-    } CATCH_STD()
-    return NULL;
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeWhere(
     JNIEnv *env, jobject, jlong nativeViewPtr)
 {
-    TR_ENTER_PTR(nativeViewPtr)
+    TR_ENTER_PTR(env, nativeViewPtr)
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
             return 0;
 
-        Query query = TV(nativeViewPtr)->get_parent().where(TV(nativeViewPtr));
-        TableQuery* queryPtr = new TableQuery(query);
+        Query *queryPtr = new Query(TV(nativeViewPtr)->get_parent().where(TV(nativeViewPtr)));
         return reinterpret_cast<jlong>(queryPtr);
     } CATCH_STD()
     return 0;
@@ -1079,7 +951,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSyncIfNeeded(
     bool valid = (TV(nativeViewPtr) != NULL);
     if (valid) {
         if (!TV(nativeViewPtr)->is_attached()) {
-            ThrowException(env, TableInvalid, "The Realm has been closed and is no longer accessible.");
+            ThrowException(env, IllegalState, "The Realm has been closed and is no longer accessible.");
             return 0;
         }
     }
@@ -1092,7 +964,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSyncIfNeeded(
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindBySourceNdx
         (JNIEnv *env, jobject, jlong nativeViewPtr, jlong sourceIndex)
 {
-    TR_ENTER_PTR(nativeViewPtr);
+    TR_ENTER_PTR(env, nativeViewPtr);
     try {
         if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) || !ROW_INDEX_VALID(env, &(TV(nativeViewPtr)->get_parent()), sourceIndex))
             return -1;
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_TestUtil.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_TestUtil.cpp
new file mode 100644
index 0000000000..a5b34275c4
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_TestUtil.cpp
@@ -0,0 +1,85 @@
+#include "io_realm_internal_TestUtil.h"
+#include "util.hpp"
+
+static jstring throwOrGetExpectedMessage(JNIEnv *env, jlong testcase, bool should_throw);
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_TestUtil_getMaxExceptionNumber(JNIEnv*, jclass)
+{
+    return ExceptionKindMax;
+}
+
+JNIEXPORT jstring JNICALL
+Java_io_realm_internal_TestUtil_getExpectedMessage(JNIEnv *env, jclass, jlong exception_kind)
+{
+    return throwOrGetExpectedMessage(env, exception_kind, false);
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_TestUtil_testThrowExceptions(JNIEnv *env, jclass, jlong exception_kind)
+{
+    throwOrGetExpectedMessage(env, exception_kind, true);
+}
+
+static jstring
+throwOrGetExpectedMessage(JNIEnv *env, jlong testcase, bool should_throw)
+{
+    std::string expect;
+
+    switch (ExceptionKind(testcase)) {
+        case ClassNotFound:
+            expect = "java.lang.ClassNotFoundException: Class 'parm1' could not be located.";
+            if (should_throw)
+                ThrowException(env, ClassNotFound, "parm1", "parm2");
+            break;
+        case IllegalArgument:
+            expect = "java.lang.IllegalArgumentException: Illegal Argument: parm1";
+            if (should_throw)
+                ThrowException(env, IllegalArgument, "parm1", "parm2");
+            break;
+        case IndexOutOfBounds:
+            expect = "java.lang.ArrayIndexOutOfBoundsException: parm1";
+            if (should_throw)
+                ThrowException(env, IndexOutOfBounds, "parm1", "parm2");
+            break;
+        case UnsupportedOperation:
+            expect = "java.lang.UnsupportedOperationException: parm1";
+            if (should_throw)
+                ThrowException(env, UnsupportedOperation, "parm1", "parm2");
+            break;
+        case OutOfMemory:
+            expect = "io.realm.internal.OutOfMemoryError: parm1 parm2";
+            if (should_throw)
+                ThrowException(env, OutOfMemory, "parm1", "parm2");
+            break;
+        case FatalError:
+            expect = "io.realm.exceptions.RealmError: Unrecoverable error. parm1";
+            if (should_throw)
+                ThrowException(env, FatalError, "parm1", "parm2");
+            break;
+        case RuntimeError:
+            expect = "java.lang.RuntimeException: parm1";
+            if (should_throw)
+                ThrowException(env, RuntimeError, "parm1", "parm2");
+            break;
+        case BadVersion:
+            expect = "io.realm.internal.async.BadVersionException: parm1";
+            if (should_throw)
+                ThrowException(env, BadVersion, "parm1", "parm2");
+            break;
+        case IllegalState:
+            expect = "java.lang.IllegalStateException: parm1";
+            if (should_throw)
+                ThrowException(env, IllegalState, "parm1");
+            break;
+        // FIXME: This is difficult to test right now. Need to refactor the test.
+        // See https://github.com/realm/realm-java/issues/3348
+        // case RealmFileError:
+        default:
+            break;
+    }
+    if (should_throw) {
+        return NULL;
+    }
+    return to_jstring(env, expect);
+}
diff --git a/realm/realm-jni/src/io_realm_internal_UncheckedRow.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
similarity index 81%
rename from realm/realm-jni/src/io_realm_internal_UncheckedRow.cpp
rename to realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
index b78ed27aa6..5f2fc6c1d7 100644
--- a/realm/realm-jni/src/io_realm_internal_UncheckedRow.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
@@ -16,15 +16,13 @@
 
 #include "io_realm_internal_UncheckedRow.h"
 #include "util.hpp"
-#include "mixedutil.hpp"
-#include "tablebase_tpl.hpp"
 
 using namespace realm;
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnCount
-  (JNIEnv *, jobject, jlong nativeRowPtr)
+  (JNIEnv *env, jobject, jlong nativeRowPtr)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW(nativeRowPtr)->is_attached())
         return 0;
 
@@ -34,7 +32,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnCount
 JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnName
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -47,7 +45,7 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnNam
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnIndex
   (JNIEnv* env, jobject, jlong nativeRowPtr, jstring columnName)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW(nativeRowPtr)->is_attached())
         return 0;
 
@@ -59,16 +57,16 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnIndex
 }
 
 JNIEXPORT jint JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnType
-  (JNIEnv*, jobject, jlong nativeRowPtr, jlong columnIndex)
+  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     return static_cast<jint>( ROW(nativeRowPtr)->get_column_type( S(columnIndex)) ); // noexcept
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetIndex
   (JNIEnv* env, jobject, jlong nativeRowPtr)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -78,7 +76,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetIndex
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLong
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -88,7 +86,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLong
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeGetBoolean
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -98,7 +96,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeGetBoolean
 JNIEXPORT jfloat JNICALL Java_io_realm_internal_UncheckedRow_nativeGetFloat
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -108,7 +106,7 @@ JNIEXPORT jfloat JNICALL Java_io_realm_internal_UncheckedRow_nativeGetFloat
 JNIEXPORT jdouble JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDouble
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -118,7 +116,7 @@ JNIEXPORT jdouble JNICALL Java_io_realm_internal_UncheckedRow_nativeGetDouble
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetTimestamp
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -128,7 +126,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetTimestamp
 JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetString
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -142,7 +140,7 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_UncheckedRow_nativeGetString
 JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_UncheckedRow_nativeGetByteArray
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -162,35 +160,10 @@ JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_UncheckedRow_nativeGetByteAr
     }
 }
 
-JNIEXPORT jint JNICALL Java_io_realm_internal_UncheckedRow_nativeGetMixedType
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
-{
-    TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
-        return 0;
-
-    DataType mixedType = ROW(nativeRowPtr)->get_mixed_type( S(columnIndex) );  // noexcept
-    return static_cast<jint>(mixedType);
-}
-
-JNIEXPORT jobject JNICALL Java_io_realm_internal_UncheckedRow_nativeGetMixed
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
-{
-    TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
-        return 0;
-
-    Mixed value = ROW(nativeRowPtr)->get_mixed( S(columnIndex) );  // noexcept
-    try {
-        return CreateJMixedFromMixed(env, value);
-    } CATCH_STD();
-    return NULL;
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLink
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -203,7 +176,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLink
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNullLink
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -211,9 +184,9 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNullLink
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLinkView
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
+  (JNIEnv* env, jclass, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return 0;
 
@@ -224,7 +197,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLinkView
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLong
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
@@ -236,7 +209,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLong
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetBoolean
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jboolean value)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
@@ -248,7 +221,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetBoolean
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetFloat
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jfloat value)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
@@ -260,7 +233,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetFloat
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDouble
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jdouble value)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
@@ -272,7 +245,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetDouble
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetTimestamp
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
@@ -284,7 +257,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetTimestamp
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetString
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jstring value)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
@@ -301,7 +274,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetString
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetByteArray
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jbyteArray value)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
 
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
@@ -331,22 +304,10 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetByteArray
     }
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetMixed
-  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jobject jMixedValue)
-{
-    TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr)))
-        return;
-
-    try {
-        row_nativeSetMixed(ROW(nativeRowPtr), env, columnIndex, jMixedValue);
-    } CATCH_STD()
-}
-
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLink
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex, jlong value)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
@@ -358,7 +319,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLink
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeNullifyLink
   (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
 
@@ -368,16 +329,16 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeNullifyLink
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeClose
-  (JNIEnv *, jclass, jlong nativeRowPtr)
+  (JNIEnv* env, jclass, jlong nativeRowPtr)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     delete ROW(nativeRowPtr);
 }
 
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsAttached
-  (JNIEnv *, jobject, jlong nativeRowPtr)
+  (JNIEnv* env, jobject, jlong nativeRowPtr)
 {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     return ROW(nativeRowPtr)->is_attached();
 }
 
@@ -389,14 +350,14 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeHasColumn
 }
 
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNull
-  (JNIEnv *, jobject, jlong nativeRowPtr, jlong columnIndex) {
-    TR_ENTER_PTR(nativeRowPtr)
+  (JNIEnv* env, jobject, jlong nativeRowPtr, jlong columnIndex) {
+    TR_ENTER_PTR(env, nativeRowPtr)
     return ROW(nativeRowPtr)->is_null(columnIndex);
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetNull
   (JNIEnv *env, jobject, jlong nativeRowPtr, jlong columnIndex) {
-    TR_ENTER_PTR(nativeRowPtr)
+    TR_ENTER_PTR(env, nativeRowPtr)
     if (!ROW_VALID(env, ROW(nativeRowPtr)))
         return;
     if (!TBL_AND_COL_NULLABLE(env, ROW(nativeRowPtr)->get_table(), columnIndex))
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
new file mode 100644
index 0000000000..2641cc5ca5
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <jni.h>
+
+#include <realm/string_data.hpp>
+#include <realm/unicode.hpp>
+
+#include "io_realm_log_LogLevel.h"
+#include "mem_usage.hpp"
+#include "util.hpp"
+
+using std::string;
+
+//#define USE_VLD
+#if defined(_MSC_VER) && defined(_DEBUG) && defined(USE_VLD)
+    #include "C:\\Program Files (x86)\\Visual Leak Detector\\include\\vld.h"
+#endif
+
+// used by logging
+int trace_level = 0;
+jclass realmlog_class;
+jmethodID log_trace;
+jmethodID log_debug;
+jmethodID log_info;
+jmethodID log_warn;
+jmethodID log_error;
+jmethodID log_fatal;
+
+const string TABLE_PREFIX("class_");
+
+
+JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*)
+{
+    JNIEnv* env;
+    if (vm->GetEnv((void **) &env, JNI_VERSION_1_6) != JNI_OK) {
+        return JNI_ERR;
+    }
+    else {
+        // Loading classes and constructors for later use - used by box typed fields and a few methods' return value
+        java_lang_long        = GetClass(env, "java/lang/Long");
+        java_lang_long_init   = env->GetMethodID(java_lang_long, "<init>", "(J)V");
+        java_lang_float       = GetClass(env, "java/lang/Float");
+        java_lang_float_init  = env->GetMethodID(java_lang_float, "<init>", "(F)V");
+        java_lang_double      = GetClass(env, "java/lang/Double");
+        java_lang_double_init = env->GetMethodID(java_lang_double, "<init>", "(D)V");
+        realmlog_class        = GetClass(env, "io/realm/log/RealmLog");
+        log_trace             = env->GetStaticMethodID(realmlog_class, "trace", "(Ljava/lang/String;[Ljava/lang/Object;)V");
+        log_debug             = env->GetStaticMethodID(realmlog_class, "debug", "(Ljava/lang/String;[Ljava/lang/Object;)V");
+        log_info              = env->GetStaticMethodID(realmlog_class, "info", "(Ljava/lang/String;[Ljava/lang/Object;)V");
+        log_warn              = env->GetStaticMethodID(realmlog_class, "warn", "(Ljava/lang/String;[Ljava/lang/Object;)V");
+        log_error             = env->GetStaticMethodID(realmlog_class, "error", "(Ljava/lang/String;[Ljava/lang/Object;)V");
+        log_fatal             = env->GetStaticMethodID(realmlog_class, "fatal", "(Ljava/lang/String;[Ljava/lang/Object;)V");
+    }
+
+    return JNI_VERSION_1_6;
+}
+
+JNIEXPORT void JNI_OnUnload(JavaVM* vm, void*)
+{
+    JNIEnv* env;
+    if (vm->GetEnv((void **) &env, JNI_VERSION_1_6) != JNI_OK) {
+        return;
+    }
+    else {
+        env->DeleteGlobalRef(java_lang_long);
+        env->DeleteGlobalRef(java_lang_float);
+        env->DeleteGlobalRef(java_lang_double);
+    }
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_Util_nativeSetDebugLevel(JNIEnv*, jclass, jint level)
+{
+    /**
+     * level should match one of the levels defined in LogLevel.java
+     * ALL = 1
+     * TRACE = 2
+     * DEBUG = 3
+     * INFO = 4
+     * WARN = 5
+     * ERROR = 6
+     * FATAL = 7
+     * OFF = 8
+     */
+    trace_level = level;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Util_nativeGetMemUsage(JNIEnv*, jclass)
+{
+    return GetMemUsage();
+}
+
+JNIEXPORT jstring JNICALL Java_io_realm_internal_Util_nativeGetTablePrefix(
+    JNIEnv* env, jclass)
+{
+    realm::StringData sd(TABLE_PREFIX);
+    return to_jstring(env, sd);
+}
diff --git a/realm/realm-library/src/main/cpp/java_binding_context.cpp b/realm/realm-library/src/main/cpp/java_binding_context.cpp
new file mode 100644
index 0000000000..b8954caeb6
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/java_binding_context.cpp
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "java_binding_context.hpp"
+
+#include "util/format.hpp"
+
+using namespace realm;
+using namespace realm::_impl;
+
+JavaBindingContext::JavaBindingContext(const ConcreteJavaBindContext& concrete_context)
+    : m_local_jni_env(concrete_context.jni_env)
+{
+    jint ret = m_local_jni_env->GetJavaVM(&m_jvm);
+    if (ret != 0) {
+        throw std::runtime_error(util::format("Failed to get Java vm. Error: %d", ret));
+    }
+    if (concrete_context.java_notifier) {
+        m_java_notifier = m_local_jni_env->NewWeakGlobalRef(concrete_context.java_notifier);
+        jclass cls = m_local_jni_env->GetObjectClass(m_java_notifier);
+        m_notify_by_other_method = m_local_jni_env->GetMethodID(cls, "notifyCommitByOtherThread", "()V");
+    } else {
+        m_java_notifier = nullptr;
+    }
+}
+
+JavaBindingContext::~JavaBindingContext()
+{
+    if (m_java_notifier) {
+        // Always try to attach here since this may be called in the finalizer/phantom thread where m_local_jni_env
+        // should not be used on. No need to call DetachCurrentThread since this thread should always be created by
+        // JVM.
+        JNIEnv *env;
+        m_jvm->AttachCurrentThread(&env, nullptr);
+        env->DeleteWeakGlobalRef(m_java_notifier);
+    }
+}
+
+void JavaBindingContext::changes_available()
+{
+    jobject notifier = m_local_jni_env->NewLocalRef(m_java_notifier);
+    if (notifier) {
+        m_local_jni_env->CallVoidMethod(m_java_notifier, m_notify_by_other_method);
+        m_local_jni_env->DeleteLocalRef(notifier);
+    }
+}
+
diff --git a/realm/realm-library/src/main/cpp/java_binding_context.hpp b/realm/realm-library/src/main/cpp/java_binding_context.hpp
new file mode 100644
index 0000000000..ee96a000a5
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/java_binding_context.hpp
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef JAVA_BINDING_CONTEXT_HPP
+#define JAVA_BINDING_CONTEXT_HPP
+
+#include <jni.h>
+#include <memory>
+
+#include "binding_context.hpp"
+
+namespace realm {
+
+namespace _impl {
+
+// Binding context which will be called from OS.
+class JavaBindingContext final : public BindingContext {
+private:
+    struct ConcreteJavaBindContext {
+        JNIEnv* jni_env;
+        jobject java_notifier;
+        explicit ConcreteJavaBindContext(JNIEnv* env, jobject notifier)
+            :jni_env(env), java_notifier(notifier) { }
+    };
+
+    // The JNIEnv for the thread which creates the Realm. This should only be used on the current thread.
+    JNIEnv* m_local_jni_env;
+    // All methods should be called from the thread which creates the realm except the destructor which might be
+    // called from finalizer/phantom daemon. So we need a jvm pointer to create JNIEnv there if needed.
+    JavaVM* m_jvm;
+    // A weak global ref to the implementation of RealmNotifier
+    // Java should hold a strong ref to it as long as the SharedRealm lives
+    jobject m_java_notifier;
+    // Method IDs from RealmNotifier implementation. Cache them as member vars.
+    jmethodID m_notify_by_other_method;
+
+public:
+    virtual ~JavaBindingContext();
+    virtual void changes_available();
+
+    JavaBindingContext(const ConcreteJavaBindContext&);
+    static inline std::unique_ptr<JavaBindingContext> create(JNIEnv* env, jobject notifier)
+    {
+        return std::make_unique<JavaBindingContext>(ConcreteJavaBindContext{env, notifier});
+    };
+};
+
+} // namespace _impl
+
+} // namespace realm
+
+#endif
+
diff --git a/realm/realm-jni/src/mem_usage.cpp b/realm/realm-library/src/main/cpp/mem_usage.cpp
similarity index 100%
rename from realm/realm-jni/src/mem_usage.cpp
rename to realm/realm-library/src/main/cpp/mem_usage.cpp
diff --git a/realm/realm-jni/src/mem_usage.hpp b/realm/realm-library/src/main/cpp/mem_usage.hpp
similarity index 100%
rename from realm/realm-jni/src/mem_usage.hpp
rename to realm/realm-library/src/main/cpp/mem_usage.hpp
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
new file mode 160000
index 0000000000..4100b8fc40
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -0,0 +1 @@
+Subproject commit 4100b8fc407176cdf09e6f394bd111595a6412aa
diff --git a/realm/realm-library/src/main/cpp/tablebase_tpl.hpp b/realm/realm-library/src/main/cpp/tablebase_tpl.hpp
new file mode 100644
index 0000000000..bf7ea21178
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/tablebase_tpl.hpp
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef REALM_JNI_TABLEBASE_TPL_HPP
+#define REALM_JNI_TABLEBASE_TPL_HPP
+
+#include <realm.hpp>
+
+template <class T>
+jbyteArray tbl_GetByteArray(JNIEnv* env, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
+{
+    if (!TBL_AND_INDEX_VALID(env, reinterpret_cast<T*>(nativeTablePtr), columnIndex, rowIndex))
+        return NULL;
+
+    realm::BinaryData bin = reinterpret_cast<T*>(nativeTablePtr)->get_binary( S(columnIndex), S(rowIndex));
+    if (bin.is_null()) {
+        return NULL;
+    }
+    if (bin.size() <= MAX_JSIZE) {
+        jbyteArray jresult = env->NewByteArray(static_cast<jsize>(bin.size()));
+        if (jresult)
+            env->SetByteArrayRegion(jresult, 0, static_cast<jsize>(bin.size()), reinterpret_cast<const jbyte*>(bin.data()));  // throws
+        return jresult;
+    }
+    else {
+        ThrowException(env, IllegalArgument, "Length of ByteArray is larger than an Int.");
+        return NULL;
+    }
+}
+
+#endif // REALM_JNI_TABLEBASE_TPL_HPP
diff --git a/realm/realm-jni/src/utf8.hpp b/realm/realm-library/src/main/cpp/utf8.hpp
similarity index 100%
rename from realm/realm-jni/src/utf8.hpp
rename to realm/realm-library/src/main/cpp/utf8.hpp
diff --git a/realm/realm-jni/src/util.cpp b/realm/realm-library/src/main/cpp/util.cpp
similarity index 81%
rename from realm/realm-jni/src/util.cpp
rename to realm/realm-library/src/main/cpp/util.cpp
index df5762c93c..f1bba74329 100644
--- a/realm/realm-jni/src/util.cpp
+++ b/realm/realm-library/src/main/cpp/util.cpp
@@ -18,10 +18,13 @@
 #include <stdexcept>
 
 #include <realm/util/assert.hpp>
+#include <realm/unicode.hpp>
 #include "utf8.hpp"
 
 #include "util.hpp"
 #include "io_realm_internal_Util.h"
+#include "io_realm_internal_SharedRealm.h"
+#include "shared_realm.hpp"
 
 using namespace std;
 using namespace realm;
@@ -35,6 +38,8 @@ jmethodID java_lang_float_init;
 jclass java_lang_double;
 jmethodID java_lang_double_init;
 
+void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::RealmFileException::Kind kind);
+
 void ConvertException(JNIEnv* env, const char *file, int line)
 {
     ostringstream ss;
@@ -47,7 +52,7 @@ void ConvertException(JNIEnv* env, const char *file, int line)
     }
     catch (CrossTableLinkTarget& e) {
         ss << e.what() << " in " << file << " line " << line;
-        ThrowException(env, CrossTableLink, ss.str());
+        ThrowException(env, IllegalState, ss.str());
     }
     catch (SharedGroup::BadVersion& e) {
         ss << e.what() << " in " << file << " line " << line;
@@ -57,8 +62,16 @@ void ConvertException(JNIEnv* env, const char *file, int line)
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, IllegalArgument, ss.str());
     }
-    catch (File::AccessError& e) {
-        ss << e.what() << " path: " << e.get_path() << " in " << file << " line " << line;
+    catch (RealmFileException& e) {
+        ss << e.what() << " in " << file << " line " << line;
+        ThrowRealmFileException(env, ss.str(), e.kind());
+    }
+    catch (InvalidTransactionException& e) {
+        ss << e.what() << " in " << file << " line " << line;
+        ThrowException(env, IllegalState, ss.str());
+    }
+    catch (InvalidEncryptionKeyException& e) {
+        ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, IllegalArgument, ss.str());
     }
     catch (exception& e) {
@@ -78,7 +91,7 @@ void ThrowException(JNIEnv* env, ExceptionKind exception, const std::string& cla
     string message;
     jclass jExceptionClass = NULL;
 
-    TR_ERR("jni: ThrowingException %d, %s, %s.", exception, classStr.c_str(), itemStr.c_str())
+    TR_ERR(env, "jni: ThrowingException %d, %s, %s.", exception, classStr.c_str(), itemStr.c_str())
 
     switch (exception) {
         case ClassNotFound:
@@ -86,41 +99,11 @@ void ThrowException(JNIEnv* env, ExceptionKind exception, const std::string& cla
             message = "Class '" + classStr + "' could not be located.";
             break;
 
-        case NoSuchField:
-            jExceptionClass = env->FindClass("java/lang/NoSuchFieldException");
-            message = "Field '" + itemStr + "' could not be located in class io.realm." + classStr;
-            break;
-
-        case NoSuchMethod:
-            jExceptionClass = env->FindClass("java/lang/NoSuchMethodException");
-            message = "Method '" + itemStr + "' could not be located in class io.realm." + classStr;
-            break;
-
         case IllegalArgument:
             jExceptionClass = env->FindClass("java/lang/IllegalArgumentException");
             message = "Illegal Argument: " + classStr;
             break;
 
-        case TableInvalid:
-            jExceptionClass = env->FindClass("java/lang/IllegalStateException");
-            message = "Illegal State: " + classStr;
-            break;
-
-        case IOFailed:
-            jExceptionClass = env->FindClass("io/realm/exceptions/RealmIOException");
-            message = "Failed to open " + classStr + ". " + itemStr;
-            break;
-
-        case FileNotFound:
-            jExceptionClass = env->FindClass("io/realm/exceptions/RealmIOException");
-            message = "File not found: " + classStr + ".";
-            break;
-
-        case FileAccessError:
-            jExceptionClass = env->FindClass("io/realm/exceptions/RealmIOException");
-            message = "Failed to access: " + classStr + ". " + itemStr;
-            break;
-
         case IndexOutOfBounds:
             jExceptionClass = env->FindClass("java/lang/ArrayIndexOutOfBoundsException");
             message = classStr;
@@ -146,32 +129,65 @@ void ThrowException(JNIEnv* env, ExceptionKind exception, const std::string& cla
             message = classStr;
             break;
 
-        case RowInvalid:
-            jExceptionClass = env->FindClass("java/lang/IllegalStateException");
-            message = "Illegal State: " + classStr;
+        case BadVersion:
+            jExceptionClass = env->FindClass("io/realm/internal/async/BadVersionException");
+            message = classStr;
             break;
 
-        case CrossTableLink:
+        case IllegalState:
             jExceptionClass = env->FindClass("java/lang/IllegalStateException");
-            message = "This class is referenced by other classes. Remove those fields first before removing this class.";
+            message = classStr;
             break;
 
-        case BadVersion:
-            jExceptionClass = env->FindClass("io/realm/internal/async/BadVersionException");
-            message = classStr;
+        // Should never get here.
+        case ExceptionKindMax:
+        default:
             break;
     }
     if (jExceptionClass != NULL) {
         env->ThrowNew(jExceptionClass, message.c_str());
-        TR_ERR("Exception has been throw: %s", message.c_str())
+        TR_ERR(env, "Exception has been throw: %s", message.c_str())
     }
     else {
-        TR_ERR("ERROR: Couldn't throw exception.")
+        TR_ERR(env, "ERROR: Couldn't throw exception.", NULL)
     }
 
     env->DeleteLocalRef(jExceptionClass);
 }
 
+void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::RealmFileException::Kind kind)
+{
+    jclass cls = env->FindClass("io/realm/exceptions/RealmFileException");
+
+    jmethodID constructor = env->GetMethodID(cls, "<init>", "(BLjava/lang/String;)V");
+    jbyte kind_code;
+    switch (kind) {
+        case realm::RealmFileException::Kind::AccessError:
+            kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_ACCESS_ERROR;
+            break;
+        case realm::RealmFileException::Kind::PermissionDenied:
+            kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_PERMISSION_DENIED;
+            break;
+        case realm::RealmFileException::Kind::Exists:
+            kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_EXISTS;
+            break;
+        case realm::RealmFileException::Kind::NotFound:
+            kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_NOT_FOUND;
+            break;
+        case realm::RealmFileException::Kind::IncompatibleLockFile:
+            kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_IMCOMPATIBLE_LOCK_FILE;
+            break;
+        case realm::RealmFileException::Kind::FormatUpgradeRequired:
+            kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_FORMAT_UPGRADE_REQUIRED;
+            break;
+    }
+    jstring jstr = env->NewStringUTF(message.c_str());
+    jobject exception = env->NewObject(cls, constructor, kind_code, jstr);
+    env->Throw(reinterpret_cast<jthrowable>(exception));
+    env->DeleteLocalRef(cls);
+    env->DeleteLocalRef(exception);
+}
+
 jclass GetClass(JNIEnv* env, const char* classStr)
 {
     jclass localRefClass = env->FindClass(classStr);
@@ -185,21 +201,6 @@ jclass GetClass(JNIEnv* env, const char* classStr)
     return myClass;
 }
 
-void jprint(JNIEnv *env, char *txt)
-{
-#if 1
-    static_cast<void>(env);
-    fprintf(stderr, " -- JNI: %s", txt);  fflush(stderr);
-#else
-    static jclass myClass = GetClass(env, "io/realm/internal/Util");
-    static jmethodID myMethod = env->GetStaticMethodID(myClass, "javaPrint", "(Ljava/lang/String;)V");
-    if (myMethod)
-        env->CallStaticVoidMethod(myClass, myMethod, to_jstring(env, txt));
-    else
-        ThrowException(env, NoSuchMethod, "Util", "javaPrint");
-#endif
-}
-
 void ThrowNullValueException(JNIEnv* env, Table* table, size_t col_ndx) {
     std::ostringstream ss;
     ss << "Trying to set a non-nullable field '"
@@ -210,17 +211,6 @@ void ThrowNullValueException(JNIEnv* env, Table* table, size_t col_ndx) {
     ThrowException(env, IllegalArgument, ss.str());
 }
 
-void jprintf(JNIEnv *env, const char *format, ...)
-{
-    va_list argptr;
-    char buf[200];
-    va_start(argptr, format);
-    //vfprintf(stderr, format, argptr);
-    vsnprintf(buf, 200, format, argptr);
-    jprint(env, buf);
-    va_end(argptr);
-}
-
 bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, realm::BinaryData& bin)
 {
     const char* data = static_cast<char*>(env->GetDirectBufferAddress(jByteBuffer));
@@ -279,7 +269,7 @@ struct JStringCharsAccessor {
 
 } // anonymous namespace
 
-string string_to_hex(const string& message, StringData& str, const char* in_begin, const char* in_end,
+static string string_to_hex(const string& message, StringData& str, const char* in_begin, const char* in_end,
                      jchar* out_curr, jchar* out_end, size_t retcode, size_t error_code) {
     ostringstream ret;
 
@@ -300,7 +290,7 @@ string string_to_hex(const string& message, StringData& str, const char* in_begi
     return ret.str();
 }
 
-string string_to_hex(const string& message, const jchar *str, size_t size, size_t error_code) {
+static string string_to_hex(const string& message, const jchar *str, size_t size, size_t error_code) {
     ostringstream ret;
 
     ret << message << "; ";
@@ -425,3 +415,4 @@ JStringAccessor::JStringAccessor(JNIEnv* env, jstring str)
         m_size = out_begin - m_data.get();
     }
 }
+
diff --git a/realm/realm-jni/src/util.hpp b/realm/realm-library/src/main/cpp/util.hpp
similarity index 69%
rename from realm/realm-jni/src/util.hpp
rename to realm/realm-library/src/main/cpp/util.hpp
index 702b14be01..9bdad05fa4 100644
--- a/realm/realm-jni/src/util.hpp
+++ b/realm/realm-library/src/main/cpp/util.hpp
@@ -28,13 +28,15 @@
 #include <inttypes.h>
 
 #include <realm.hpp>
-#include <realm/util/meta.hpp>
-#include <realm/util/safe_int_ops.hpp>
 #include <realm/lang_bind_helper.hpp>
 #include <realm/timestamp.hpp>
+#include <realm/util/meta.hpp>
+#include <realm/util/safe_int_ops.hpp>
 
-#include "io_realm_internal_Util.h"
+#include <util/format.hpp>
 
+#include "io_realm_internal_Util.h"
+#include "io_realm_log_LogLevel.h"
 
 #define TRACE               1       // disable for performance
 #define CHECK_PARAMETERS    1       // Check all parameters in API and throw exceptions in java if invalid
@@ -56,24 +58,6 @@ JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved);
 #define STRINGIZE(x) STRINGIZE_DETAIL(x)
 
 // Exception handling
-
-#define CATCH_FILE(fileName) \
-    catch (InvalidDatabase&) { \
-        ThrowException(env, IllegalArgument, "Invalid format of Realm file."); \
-    } \
-    catch (util::File::PermissionDenied& e) { \
-        ThrowException(env, IOFailed, string(fileName), \
-                std::string(e.what()) + " path: " + e.get_path()); \
-    } \
-    catch (util::File::NotFound& e) { \
-        ThrowException(env, FileNotFound, string(fileName), \
-                std::string(e.what()) + " path: " + e.get_path());    \
-    } \
-    catch (util::File::AccessError& e) { \
-        ThrowException(env, FileAccessError, string(fileName), \
-                std::string(e.what()) + " path: " + e.get_path()); \
-    }
-
 #define CATCH_STD() \
     catch (...) { \
         ConvertException(env, __FILE__, __LINE__); \
@@ -88,8 +72,6 @@ std::string num_to_string(T pNumber)
 }
 
 
-#define MAX_JLONG  0x7FFFFFFFFFFFFFFFLL
-#define MIN_JLONG -0x8000000000000000LL
 #define MAX_JINT   0x7FFFFFFFL
 #define MAX_JSIZE  MAX_JINT
 
@@ -102,31 +84,26 @@ std::string num_to_string(T pNumber)
 #define TV(x)   reinterpret_cast<realm::TableView*>(x)
 #define LV(x)   reinterpret_cast<realm::LinkViewRef*>(x)
 #define Q(x)    reinterpret_cast<realm::Query*>(x)
-#define G(x)    reinterpret_cast<realm::Group*>(x)
 #define ROW(x)  reinterpret_cast<realm::Row*>(x)
-#define SG(ptr) reinterpret_cast<realm::SharedGroup*>(ptr)
-#define CH(ptr) reinterpret_cast<realm::Replication*>(ptr)
 #define HO(T, ptr) reinterpret_cast<realm::SharedGroup::Handover <T>* >(ptr)
 
 // Exception handling
 enum ExceptionKind {
+    // FIXME: This is not something should be exposed to java, ClassNotFound is something we should
+    // crash hard in native code and fix it.
     ClassNotFound = 0,
-    NoSuchField = 1,
-    NoSuchMethod = 2,
-    IllegalArgument = 3,
-    IOFailed = 4,
-    FileNotFound = 5,
-    FileAccessError = 6,
-    IndexOutOfBounds = 7,
-    TableInvalid = 8,
-    UnsupportedOperation = 9,
-    OutOfMemory = 10,
-    FatalError = 11,
-    RuntimeError = 12,
-    RowInvalid = 13,
-    CrossTableLink = 15,
-    BadVersion = 16
-// NOTE!!!!: Please also add test cases to Util.java when introducing a new exception kind.
+    IllegalArgument,
+    IndexOutOfBounds,
+    UnsupportedOperation,
+    OutOfMemory,
+    FatalError,
+    RuntimeError,
+    BadVersion,
+    IllegalState,
+    RealmFileError,
+    // NOTE!!!!: Please also add test cases to io_realm_internal_TestUtil when introducing a
+    // new exception kind.
+    ExceptionKindMax // Always keep this as the last one!
 };
 
 void ConvertException(JNIEnv* env, const char *file, int line);
@@ -139,33 +116,49 @@ jclass GetClass(JNIEnv* env, const char* classStr);
 
 // Debug trace
 extern int trace_level;
-extern const char* log_tag;
+extern jclass realmlog_class;
+extern jmethodID log_trace;
+extern jmethodID log_debug;
+extern jmethodID log_info;
+extern jmethodID log_warn;
+extern jmethodID log_error;
+extern jmethodID log_fatal;
+
+
+// Inspired by From http://www.netmite.com/android/mydroid/system/core/liblog/logd_write.c
+inline void log_message(JNIEnv *env, jmethodID log_method, const char *msg, ...)
+{
+    // Check if a exception has already bee cast. In that case trying to log anything will crash.
+    if (env->ExceptionCheck()) {
+        return;
+    }
+
+    va_list ap;
+    char buf[1024]; // Max logcat line length
+    va_start(ap, msg);
+    // Do formatting in C++. I gave up trying to send C++ variadic arguments back as Java var args.
+    vsnprintf(buf, 1024, msg, ap);
+    va_end(ap);
+
+    jstring log_message = env->NewStringUTF(buf);
+    env->CallStaticVoidMethod(realmlog_class, log_method, log_message, NULL);
+    env->DeleteLocalRef(log_message);
+}
 
 #if TRACE
-  #if defined(ANDROID)
-    #include <android/log.h>
-    #define LOG_DEBUG ANDROID_LOG_DEBUG
-    #define TR_ENTER() if (trace_level >= 1) { __android_log_print(ANDROID_LOG_DEBUG, log_tag, " --> %s", __FUNCTION__); } else {}
-    #define TR_ENTER_PTR(ptr) if (trace_level >= 1) { __android_log_print(ANDROID_LOG_DEBUG, log_tag, " --> %s %" PRId64, __FUNCTION__, static_cast<int64_t>(ptr)); } else {}
-    #define TR(...) if (trace_level >= 2) { __android_log_print(ANDROID_LOG_DEBUG, log_tag, __VA_ARGS__); } else {}
-    #define TR_ERR(...) if (trace_level >= 0) { __android_log_print(ANDROID_LOG_DEBUG, log_tag, __VA_ARGS__); } else {}
-    #define TR_LEAVE() if (trace_level >= 3) { __android_log_print(ANDROID_LOG_DEBUG, log_tag, " <-- %s", __FUNCTION__); } else {}
-  #else // ANDROID
-    #define TR_ENTER()
-    #define TR_ENTER_PTR(ptr)
-    #define TR(...)
-    #define TR_ERR(...)
-    #define TR_LEAVE()
-  #endif
+    #define TR_ENTER(env) if (trace_level <= io_realm_log_LogLevel_TRACE) { log_message(env, log_trace, " --> %s", __FUNCTION__); } else {}
+    #define TR_ENTER_PTR(env, ptr) if (trace_level <= io_realm_log_LogLevel_TRACE) { log_message(env, log_trace, " --> %s %" PRId64, __FUNCTION__, static_cast<int64_t>(ptr)); } else {}
+    #define TR(env, msg, ...) if (trace_level <= io_realm_log_LogLevel_TRACE) { log_message(env, log_trace, msg, __VA_ARGS__)); } else {}
+    #define TR_ERR(env, msg, ...) if (trace_level <= io_realm_log_LogLevel_ERROR) { log_message(env, log_error, msg, __VA_ARGS__); } else {}
+    #define TR_LEAVE(env) if (trace_level <= io_realm_log_LogLevel_TRACE) { log_message(env, log_trace, " <-- %s", __FUNCTION__); } else {}
 #else // TRACE - these macros must be empty
-  #define TR_ENTER()
-  #define TR_ENTER_PTR(ptr)
-  #define TR(...)
-  #define TR_ERR(...)
-  #define TR_LEAVE()
+    #define TR_ENTER(env)
+    #define TR_ENTER_PTR(env, ptr)
+    #define TR(env, msg, ...)
+    #define TR_ERR(env, msg, ...)
+    #define TR_LEAVE(env)
 #endif
 
-
 // Check parameters
 
 #define TABLE_VALID(env,ptr)    TableIsValid(env, ptr)
@@ -187,13 +180,11 @@ extern const char* log_tag;
 #define INDEX_VALID(env,ptr,col,row)                            IndexValid(env, ptr, col, row)
 #define TBL_AND_INDEX_VALID(env,ptr,col,row)                    TblIndexValid(env, ptr, col, row)
 #define TBL_AND_INDEX_INSERT_VALID(env,ptr,col,row)             TblIndexInsertValid(env, ptr, col, row)
-#define INDEX_AND_TYPE_VALID(env,ptr,col,row,type)              IndexAndTypeValid(env, ptr, col, row, type, false)
-#define TBL_AND_INDEX_AND_TYPE_VALID(env,ptr,col,row,type)      TblIndexAndTypeValid(env, ptr, col, row, type, false)
-#define INDEX_AND_TYPE_VALID_MIXED(env,ptr,col,row,type)        IndexAndTypeValid(env, ptr, col, row, type, true)
-#define TBL_AND_INDEX_AND_TYPE_VALID_MIXED(env,ptr,col,row,type) TblIndexAndTypeValid(env, ptr, col, row, type, true)
+#define INDEX_AND_TYPE_VALID(env,ptr,col,row,type)              IndexAndTypeValid(env, ptr, col, row, type)
+#define TBL_AND_INDEX_AND_TYPE_VALID(env,ptr,col,row,type)      TblIndexAndTypeValid(env, ptr, col, row, type)
 #define TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env,ptr,col,row,type) TblIndexAndTypeInsertValid(env, ptr, col, row, type)
 
-#define ROW_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col, type)     RowColIndexAndTypeValid(env, ptr, col, type)
+#define ROW_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col,type)     RowColIndexAndTypeValid(env, ptr, col, type)
 #define ROW_AND_COL_INDEX_VALID(env,ptr,col)                    RowColIndexValid(env, ptr, col)
 
 #else
@@ -214,8 +205,6 @@ extern const char* log_tag;
 #define TBL_AND_INDEX_INSERT_VALID(env,ptr,col,row)             (true)
 #define INDEX_AND_TYPE_VALID(env,ptr,col,row,type)              (true)
 #define TBL_AND_INDEX_AND_TYPE_VALID(env,ptr,col,row,type)      (true)
-#define INDEX_AND_TYPE_VALID_MIXED(env,ptr,col,row,type)        (true)
-#define TBL_AND_INDEX_AND_TYPE_VALID_MIXED(env,ptr,col,row,type) (true)
 #define TBL_AND_INDEX_AND_TYPE_INSERT_VALID(env,ptr,col,row,type) (true)
 
 #define ROW_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col, type)     (true)
@@ -241,8 +230,8 @@ inline bool TableIsValid(JNIEnv* env, T* objPtr)
 
     }
     if (!valid) {
-        TR_ERR("Table %p is no longer attached!", VOID_PTR(objPtr))
-        ThrowException(env, TableInvalid, "Table is no longer valid to operate on.");
+        TR_ERR(env, "Table %p is no longer attached!", VOID_PTR(objPtr))
+        ThrowException(env, IllegalState, "Table is no longer valid to operate on.");
     }
     return valid;
 }
@@ -251,8 +240,8 @@ inline bool RowIsValid(JNIEnv* env, realm::Row* rowPtr)
 {
     bool valid = (rowPtr != NULL && rowPtr->is_attached());
     if (!valid) {
-        TR_ERR("Row %p is no longer attached!", VOID_PTR(rowPtr))
-        ThrowException(env, RowInvalid, "Object is no longer valid to operate on. Was it deleted by another thread?");
+        TR_ERR(env, "Row %p is no longer attached!", VOID_PTR(rowPtr))
+        ThrowException(env, IllegalState, "Object is no longer valid to operate on. Was it deleted by another thread?");
     }
     return valid;
 }
@@ -265,29 +254,29 @@ bool RowIndexesValid(JNIEnv* env, T* pTable, jlong startIndex, jlong endIndex, j
     if (endIndex == -1)
         endIndex = maxIndex;
     if (startIndex < 0) {
-        TR_ERR("startIndex %" PRId64 " < 0 - invalid!", S64(startIndex))
+        TR_ERR(env, "startIndex %" PRId64 " < 0 - invalid!", S64(startIndex))
         ThrowException(env, IndexOutOfBounds, "startIndex < 0.");
         return false;
     }
     if (realm::util::int_greater_than(startIndex, maxIndex)) {
-        TR_ERR("startIndex %" PRId64 " > %" PRId64 " - invalid!", S64(startIndex), S64(maxIndex))
+        TR_ERR(env, "startIndex %" PRId64 " > %" PRId64 " - invalid!", S64(startIndex), S64(maxIndex))
         ThrowException(env, IndexOutOfBounds, "startIndex > available rows.");
         return false;
     }
 
     if (realm::util::int_greater_than(endIndex, maxIndex)) {
-        TR_ERR("endIndex %" PRId64 " > %" PRId64 " - invalid!", S64(endIndex), S64(maxIndex))
+        TR_ERR(env, "endIndex %" PRId64 " > %" PRId64 " - invalid!", S64(endIndex), S64(maxIndex))
         ThrowException(env, IndexOutOfBounds, "endIndex > available rows.");
         return false;
     }
     if (startIndex > endIndex) {
-        TR_ERR("startIndex %" PRId64 " > endIndex %" PRId64 " - invalid!", S64(startIndex), S64(endIndex))
+        TR_ERR(env, "startIndex %" PRId64 " > endIndex %" PRId64 " - invalid!", S64(startIndex), S64(endIndex))
         ThrowException(env, IndexOutOfBounds, "startIndex > endIndex.");
         return false;
     }
 
     if (range != -1 && range < 0) {
-        TR_ERR("range %" PRId64 " < 0 - invalid!", S64(range))
+        TR_ERR(env, "range %" PRId64 " < 0 - invalid!", S64(range))
         ThrowException(env, IndexOutOfBounds, "range < 0.");
         return false;
     }
@@ -307,7 +296,7 @@ inline bool RowIndexValid(JNIEnv* env, T pTable, jlong rowIndex, bool offset=fal
         size -= 1;
     bool rowErr = realm::util::int_greater_than_or_equal(rowIndex, size);
     if (rowErr) {
-        TR_ERR("rowIndex %" PRId64 " > %" PRId64 " - invalid!", S64(rowIndex), S64(size))
+        TR_ERR(env, "rowIndex %" PRId64 " > %" PRId64 " - invalid!", S64(rowIndex), S64(size))
         ThrowException(env, IndexOutOfBounds,
             "rowIndex > available rows: " +
             num_to_string(rowIndex) + " > " + num_to_string(size));
@@ -334,7 +323,7 @@ inline bool ColIndexValid(JNIEnv* env, T* pTable, jlong columnIndex)
     }
     bool colErr = realm::util::int_greater_than_or_equal(columnIndex, pTable->get_column_count());
     if (colErr) {
-        TR_ERR("columnIndex %" PRId64 " > %" PRId64 " - invalid!", S64(columnIndex), S64(pTable->get_column_count()))
+        TR_ERR(env, "columnIndex %" PRId64 " > %" PRId64 " - invalid!", S64(columnIndex), S64(pTable->get_column_count()))
         ThrowException(env, IndexOutOfBounds, "columnIndex > available columns.");
     }
     return !colErr;
@@ -376,7 +365,7 @@ inline bool TblIndexInsertValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong
         return false;
     bool rowErr = realm::util::int_greater_than(rowIndex, pTable->size()+1);
     if (rowErr) {
-        TR_ERR("rowIndex %" PRId64 " > %" PRId64 " - invalid!", S64(rowIndex), S64(pTable->size()))
+        TR_ERR(env, "rowIndex %" PRId64 " > %" PRId64 " - invalid!", S64(rowIndex), S64(pTable->size()))
         ThrowException(env, IndexOutOfBounds,
             "rowIndex " + num_to_string(rowIndex) +
             " > available rows " + num_to_string(pTable->size()) + ".");
@@ -385,18 +374,12 @@ inline bool TblIndexInsertValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong
 }
 
 template <class T>
-inline bool TypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType, bool allowMixed)
+inline bool TypeValid(JNIEnv* env, T* pTable, jlong columnIndex, int expectColType)
 {
     size_t col = static_cast<size_t>(columnIndex);
     int colType = pTable->get_column_type(col);
-    if (allowMixed) {
-        if (colType == realm::type_Mixed) {
-            size_t row = static_cast<size_t>(rowIndex);
-            colType = pTable->get_mixed_type(col, row);
-        }
-    }
     if (colType != expectColType) {
-        TR_ERR("Expected columnType %d, but got %d.", expectColType, pTable->get_column_type(col))
+        TR_ERR(env, "Expected columnType %d, but got %d.", expectColType, pTable->get_column_type(col))
         ThrowException(env, IllegalArgument, "ColumnType invalid.");
         return false;
     }
@@ -412,7 +395,7 @@ inline bool TypeIsLinkLike(JNIEnv* env, T* pTable, jlong columnIndex)
         return true;
     }
 
-    TR_ERR("Expected columnType %d or %d, but got %d", realm::type_Link, realm::type_LinkList, colType)
+    TR_ERR(env, "Expected columnType %d or %d, but got %d", realm::type_Link, realm::type_LinkList, colType)
     ThrowException(env, IllegalArgument, "ColumnType invalid: expected type_Link or type_LinkList");
     return false;
 }
@@ -435,7 +418,7 @@ inline bool ColIsNullable(JNIEnv* env, T* pTable, jlong columnIndex)
         return true;
     }
 
-    TR_ERR("Expected nullable column type")
+    TR_ERR(env, "Expected nullable column type", NULL)
     ThrowException(env, IllegalArgument, "This field is not nullable.");
     return false;
 }
@@ -444,7 +427,7 @@ template <class T>
 inline bool ColIndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, int expectColType)
 {
     return ColIndexValid(env, pTable, columnIndex)
-        && TypeValid(env, pTable, columnIndex, 0, expectColType, false);
+        && TypeValid(env, pTable, columnIndex, expectColType);
 }
 template <class T>
 inline bool TblColIndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, int expectColType)
@@ -459,6 +442,8 @@ inline bool TblColIndexAndLinkOrLinkList(JNIEnv* env, T* pTable, jlong columnInd
         && TypeIsLinkLike(env, pTable, columnIndex);
 }
 
+// FIXME Usually this is called after TBL_AND_INDEX_AND_TYPE_VALID which will validate Table as well.
+// Try to avoid duplicated checks to improve performance.
 template <class T>
 inline bool TblColIndexAndNullable(JNIEnv* env, T* pTable, jlong columnIndex) {
     return TableIsValid(env, pTable)
@@ -472,22 +457,22 @@ inline bool RowColIndexAndTypeValid(JNIEnv* env, realm::Row* pRow, jlong columnI
 }
 
 template <class T>
-inline bool IndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType, bool allowMixed)
+inline bool IndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType)
 {
     return IndexValid(env, pTable, columnIndex, rowIndex)
-        && TypeValid(env, pTable, columnIndex, rowIndex, expectColType, allowMixed);
+        && TypeValid(env, pTable, columnIndex, expectColType);
 }
 template <class T>
-inline bool TblIndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType, bool allowMixed)
+inline bool TblIndexAndTypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType)
 {
-    return TableIsValid(env, pTable) && IndexAndTypeValid(env, pTable, columnIndex, rowIndex, expectColType, allowMixed);
+    return TableIsValid(env, pTable) && IndexAndTypeValid(env, pTable, columnIndex, rowIndex, expectColType);
 }
 
 template <class T>
 inline bool TblIndexAndTypeInsertValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex, int expectColType)
 {
     return TblIndexInsertValid(env, pTable, columnIndex, rowIndex)
-        && TypeValid(env, pTable, columnIndex, rowIndex, expectColType, false);
+        && TypeValid(env, pTable, columnIndex, expectColType);
 }
 
 bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, realm::BinaryData& data);
@@ -524,60 +509,84 @@ class JStringAccessor {
         }
     }
 
+    operator std::string() const noexcept
+    {
+        if (m_is_null) {
+            return std::string();
+        }
+        return std::string(m_data.get(), m_size);
+    }
+
 private:
     bool m_is_null;
     std::unique_ptr<char[]> m_data;
     std::size_t m_size;
 };
 
-class KeyBuffer {
+class JniLongArray {
 public:
-    KeyBuffer(JNIEnv* env, jbyteArray arr)
-    : m_env(env)
-    , m_array(arr)
-    , m_ptr(0)
+    JniLongArray(JNIEnv* env, jlongArray javaArray)
+        : m_env(env)
+        , m_javaArray(javaArray)
+        , m_arrayLength(javaArray == NULL ? 0 : env->GetArrayLength(javaArray))
+        , m_array(javaArray == NULL ? NULL : env->GetLongArrayElements(javaArray, NULL))
+        , m_releaseMode(JNI_ABORT) {
+    }
+
+    ~JniLongArray()
     {
-#ifdef REALM_ENABLE_ENCRYPTION
-        if (arr) {
-            if (env->GetArrayLength(m_array) != 64)
-                ThrowException(env, UnsupportedOperation, "Encryption key must be exactly 64 bytes.");
-            m_ptr = env->GetByteArrayElements(m_array, NULL);
+        if (m_array) {
+            m_env->ReleaseLongArrayElements(m_javaArray, m_array, m_releaseMode);
         }
-#else
-        if (arr)
-            ThrowException(env, UnsupportedOperation,
-                           "Encryption was disabled in the native library at compile time.");
-#endif
     }
 
-    const char *data() const {
-        return reinterpret_cast<const char *>(m_ptr);
+    inline jsize len() const noexcept
+    {
+        return m_arrayLength;
+    }
+
+    inline jlong* ptr() const noexcept
+    {
+        return m_array;
+    }
+
+    inline jlong& operator[](const int index) noexcept
+    {
+        return m_array[index];
     }
 
-    ~KeyBuffer() {
-        if (m_ptr)
-            m_env->ReleaseByteArrayElements(m_array, m_ptr, JNI_ABORT);
+    inline void updateOnRelease() noexcept
+    {
+        m_releaseMode = 0;
     }
 
 private:
-    JNIEnv* m_env;
-    jbyteArray m_array;
-    jbyte* m_ptr;
+    JNIEnv*    const m_env;
+    jlongArray const m_javaArray;
+    jsize      const m_arrayLength;
+    jlong*     const m_array;
+    jint             m_releaseMode;
 };
 
-class JniLongArray {
+class JniByteArray {
 public:
-    JniLongArray(JNIEnv* env, jlongArray javaArray)
+    JniByteArray(JNIEnv* env, jbyteArray javaArray)
         : m_env(env)
         , m_javaArray(javaArray)
-        , m_arrayLength(env->GetArrayLength(javaArray))
-        , m_array(env->GetLongArrayElements(javaArray, NULL))
+        , m_arrayLength(javaArray == NULL ? 0 : env->GetArrayLength(javaArray))
+        , m_array(javaArray == NULL ? NULL : env->GetByteArrayElements(javaArray, NULL))
         , m_releaseMode(JNI_ABORT) {
+        if (m_javaArray != nullptr && m_array == nullptr) {
+            // javaArray is not null but GetByteArrayElements returns null, something is really wrong.
+            throw std::runtime_error(realm::util::format("GetByteArrayElements failed on byte array %x", m_javaArray));
+        }
     }
 
-    ~JniLongArray()
+    ~JniByteArray()
     {
-        m_env->ReleaseLongArrayElements(m_javaArray, m_array, m_releaseMode);
+        if (m_array) {
+            m_env->ReleaseByteArrayElements(m_javaArray, m_array, m_releaseMode);
+        }
     }
 
     inline jsize len() const noexcept
@@ -585,16 +594,30 @@ class JniLongArray {
         return m_arrayLength;
     }
 
-    inline jlong* ptr() const noexcept
+    inline jbyte* ptr() const noexcept
     {
         return m_array;
     }
 
-    inline jlong& operator[](const int index) noexcept
+    inline jbyte& operator[](const int index) noexcept
     {
         return m_array[index];
     }
 
+    inline operator realm::BinaryData() const noexcept {
+        return realm::BinaryData(reinterpret_cast<const char *>(m_array), m_arrayLength);
+    }
+
+    inline operator std::vector<char>() const noexcept {
+        if (m_array == nullptr) {
+            return {};
+        }
+
+        std::vector<char> v(m_arrayLength);
+        std::copy_n(m_array, v.size(), v.begin());
+        return v;
+    }
+
     inline void updateOnRelease() noexcept
     {
         m_releaseMode = 0;
@@ -602,9 +625,9 @@ class JniLongArray {
 
 private:
     JNIEnv*    const m_env;
-    jlongArray const m_javaArray;
+    jbyteArray const m_javaArray;
     jsize      const m_arrayLength;
-    jlong*     const m_array;
+    jbyte*     const m_array;
     jint             m_releaseMode;
 };
 
@@ -613,14 +636,16 @@ class JniBooleanArray {
     JniBooleanArray(JNIEnv* env, jbooleanArray javaArray)
         : m_env(env)
         , m_javaArray(javaArray)
-        , m_arrayLength(env->GetArrayLength(javaArray))
-        , m_array(env->GetBooleanArrayElements(javaArray, NULL))
+        , m_arrayLength(javaArray == NULL ? 0 : env->GetArrayLength(javaArray))
+        , m_array(javaArray == NULL ? NULL : env->GetBooleanArrayElements(javaArray, NULL))
         , m_releaseMode(JNI_ABORT) {
     }
 
     ~JniBooleanArray()
     {
-        m_env->ReleaseBooleanArrayElements(m_javaArray, m_array, m_releaseMode);
+        if (m_array) {
+            m_env->ReleaseBooleanArrayElements(m_javaArray, m_array, m_releaseMode);
+        }
     }
 
     inline jsize len() const noexcept
@@ -651,6 +676,29 @@ class JniBooleanArray {
     jint                m_releaseMode;
 };
 
+// Wraps jobject and automatically calls DeleteLocalRef when this object is destroyed.
+// DeleteLocalRef is not necessary to be called in most cases since all local references will be cleaned up when the
+// program returns to Java from native. But if the LocaRef is created in a loop, consider to use this class to wrap it
+// because the size of local reference table is relative small (512 on Android).
+template <typename T>
+class JniLocalRef {
+public:
+    JniLocalRef(JNIEnv* env, T obj) : m_jobject(obj), m_env(env) {};
+    ~JniLocalRef()
+    {
+        m_env->DeleteLocalRef(m_jobject);
+    }
+
+    inline operator T() const noexcept
+    {
+            return m_jobject;
+    }
+
+private:
+    T m_jobject;
+    JNIEnv* m_env;
+};
+
 extern jclass java_lang_long;
 extern jmethodID java_lang_long_init;
 extern jclass java_lang_float;
diff --git a/realm/realm-library/src/main/java/io/realm/AndroidNotifier.java b/realm/realm-library/src/main/java/io/realm/AndroidNotifier.java
new file mode 100644
index 0000000000..b3f881bfa4
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/AndroidNotifier.java
@@ -0,0 +1,169 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+
+import io.realm.internal.HandlerControllerConstants;
+import io.realm.internal.RealmNotifier;
+import io.realm.internal.async.QueryUpdateTask;
+import io.realm.log.RealmLog;
+
+/**
+ * Implementation of {@link RealmNotifier} for Android based on {@link Handler}.
+ */
+// FIXME: Please move me to the io.realm.internal when HandlerController is there.
+class AndroidNotifier implements RealmNotifier {
+    private Handler handler;
+
+    public AndroidNotifier(HandlerController handlerController) {
+        if (isAutoRefreshAvailable()) {
+            handler = new Handler(handlerController);
+        }
+    }
+
+    // Called by Java when transaction committed to send LOCAL_COMMIT to current thread's handler.
+    @Override
+    public void notifyCommitByLocalThread() {
+        if (handler == null) {
+            return;
+        }
+
+        // Force any updates on the current thread to the front the queue. Doing this is mostly
+        // relevant on the UI thread where it could otherwise process a motion event before the
+        // REALM_CHANGED event. This could in turn cause a UI component like ListView to crash. See
+        // https://github.com/realm/realm-android-adapters/issues/11 for such a case.
+        // Other Looper threads could process similar events. For that reason all looper threads will
+        // prioritize local commits.
+        //
+        // If a user is doing commits inside a RealmChangeListener this can cause the Looper thread to get
+        // event starved as it only starts handling Realm events instead. This is an acceptable risk as
+        // that behaviour indicate a user bug. Previously this would be hidden as the UI would still
+        // be responsive.
+        Message msg = Message.obtain();
+        msg.what = HandlerControllerConstants.LOCAL_COMMIT;
+        if (!handler.hasMessages(HandlerControllerConstants.LOCAL_COMMIT)) {
+            handler.removeMessages(HandlerControllerConstants.REALM_CHANGED);
+            handler.sendMessageAtFrontOfQueue(msg);
+        }
+    }
+
+    // This is called by OS when other thread/process changes the Realm.
+    // This is getting called on the same thread which created the Realm.
+    // FIXME: The whole calling routine is twisted and needs to be rewritten in the near future.
+    // |---------------------------------------------------------------+--------------+------------------------------------------------|
+    // | Thread A                                                      | Thread B     | Daemon Thread                                  |
+    // |---------------------------------------------------------------+--------------+------------------------------------------------|
+    // |                                                               | Make changes |                                                |
+    // |                                                               |              | Detect and notify thread A through JNI ALooper |
+    // | Call OS's Realm::notify() from OS's ALooper callback          |              |                                                |
+    // | Realm::notify() calls JavaBindingContext:change_available()   |              |                                                |
+    // | change_available calls into this method to send REALM_CHANGED |              |                                                |
+    // |---------------------------------------------------------------+--------------+------------------------------------------------|
+    @Override
+    public void notifyCommitByOtherThread() {
+        if (handler == null) {
+            return;
+        }
+
+        // Note there is a race condition with handler.hasMessages() and handler.sendEmptyMessage()
+        // as the target thread consumes messages at the same time. In this case it is not a problem as worst
+        // case we end up with two REALM_CHANGED messages in the queue.
+        boolean messageHandled = true;
+        if (!handler.hasMessages(HandlerControllerConstants.REALM_CHANGED) &&
+                !handler.hasMessages(HandlerControllerConstants.LOCAL_COMMIT)) {
+            messageHandled = handler.sendEmptyMessage(HandlerControllerConstants.REALM_CHANGED);
+        }
+        if (!messageHandled) {
+            RealmLog.warn("Cannot update Looper threads when the Looper has quit. Use realm.setAutoRefresh(false) " +
+                    "to prevent this.");
+        }
+    }
+
+    @Override
+    public void post(Runnable runnable) {
+        Looper looper = handler.getLooper();
+        if (looper.getThread().isAlive()) {     // The receiving thread is alive
+            handler.post(runnable);
+        }
+    }
+
+    @Override
+    public boolean isValid() {
+        return handler != null;
+    }
+
+    @Override
+    public void close() {
+        if (handler != null) {
+            handler.removeCallbacksAndMessages(null);
+            handler = null;
+        }
+    }
+
+    @Override
+    public void completeAsyncResults(QueryUpdateTask.Result result) {
+        Looper looper = handler.getLooper();
+        if (looper.getThread().isAlive()) {     // The receiving thread is alive
+            handler.obtainMessage(HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS, result).sendToTarget();
+        }
+    }
+
+    @Override
+    public void completeAsyncObject(QueryUpdateTask.Result result) {
+        Looper looper = handler.getLooper();
+        if (looper.getThread().isAlive()) {     // The receiving thread is alive
+            handler.obtainMessage(HandlerControllerConstants.COMPLETED_ASYNC_REALM_OBJECT, result).sendToTarget();
+        }
+    }
+
+    @Override
+    public void throwBackgroundException(Throwable throwable) {
+        Looper looper = handler.getLooper();
+        if (looper.getThread().isAlive()) {     // The receiving thread is alive
+            handler.obtainMessage(
+                    HandlerControllerConstants.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(throwable)).sendToTarget();
+        }
+    }
+
+    @Override
+    public void completeUpdateAsyncQueries(QueryUpdateTask.Result result) {
+        Looper looper = handler.getLooper();
+        if (looper.getThread().isAlive()) {     // The receiving thread is alive
+            handler.obtainMessage(HandlerControllerConstants.COMPLETED_UPDATE_ASYNC_QUERIES, result).sendToTarget();
+        }
+    }
+
+    private static boolean isAutoRefreshAvailable() {
+        return (Looper.myLooper() != null && !isIntentServiceThread());
+    }
+
+    private static boolean isIntentServiceThread() {
+        // Tries to determine if a thread is an IntentService thread. No public API can detect this,
+        // so use the thread name as a heuristic:
+        // https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/IntentService.java#108
+        String threadName = Thread.currentThread().getName();
+        return threadName != null && threadName.startsWith("IntentService[");
+    }
+
+    // For testing purpose only. Should be removed ideally.
+    public void setHandler(Handler handler) {
+        this.handler = handler;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index 07afb45826..4e5e35272a 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -18,29 +18,28 @@
 
 import android.os.Handler;
 import android.os.Looper;
-
-import com.getkeepsafe.relinker.BuildConfig;
+import android.util.Log;
 
 import java.io.Closeable;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.InvalidRow;
 import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.SharedGroupManager;
+import io.realm.internal.SharedRealm;
+import io.realm.internal.ColumnInfo;
+import io.realm.internal.Row;
 import io.realm.internal.Table;
-import io.realm.internal.TableView;
 import io.realm.internal.UncheckedRow;
-import io.realm.internal.android.DebugAndroidLogger;
-import io.realm.internal.android.ReleaseAndroidLogger;
 import io.realm.internal.async.RealmThreadPoolExecutor;
-import io.realm.internal.log.RealmLog;
+import io.realm.log.AndroidLogger;
+import io.realm.log.RealmLog;
 import rx.Observable;
 
 /**
@@ -49,42 +48,50 @@
  * @see io.realm.Realm
  * @see io.realm.DynamicRealm
  */
+@SuppressWarnings("WeakerAccess")
 abstract class BaseRealm implements Closeable {
     protected static final long UNVERSIONED = -1;
-    private static final String INCORRECT_THREAD_CLOSE_MESSAGE = "Realm access from incorrect thread. Realm instance can only be closed on the thread it was created.";
-    private static final String INCORRECT_THREAD_MESSAGE = "Realm access from incorrect thread. Realm objects can only be accessed on the thread they were created.";
-    private static final String CLOSED_REALM_MESSAGE = "This Realm instance has already been closed, making it unusable.";
-    private static final String CANNOT_REFRESH_INSIDE_OF_TRANSACTION_MESSAGE = "Cannot refresh inside of a transaction.";
-
-    // Map between a Handler and the canonical path to a Realm file
-    protected static final Map<Handler, String> handlers = new ConcurrentHashMap<Handler, String>();
+    private static final String INCORRECT_THREAD_CLOSE_MESSAGE =
+            "Realm access from incorrect thread. Realm instance can only be closed on the thread it was created.";
+    private static final String INCORRECT_THREAD_MESSAGE =
+            "Realm access from incorrect thread. Realm objects can only be accessed on the thread they were created.";
+    private static final String CLOSED_REALM_MESSAGE =
+            "This Realm instance has already been closed, making it unusable.";
+    private static final String NOT_IN_TRANSACTION_MESSAGE =
+            "Changing Realm data can only be done from inside a transaction.";
 
     // Thread pool for all async operations (Query & transaction)
     static final RealmThreadPoolExecutor asyncTaskExecutor = RealmThreadPoolExecutor.newDefaultExecutor();
 
     final long threadId;
     protected RealmConfiguration configuration;
-    protected SharedGroupManager sharedGroupManager;
+    protected SharedRealm sharedRealm;
+
     RealmSchema schema;
-    Handler handler;
     HandlerController handlerController;
 
     static {
-        RealmLog.add(BuildConfig.DEBUG ? new DebugAndroidLogger() : new ReleaseAndroidLogger());
+        //noinspection ConstantConditions
+        RealmLog.add(BuildConfig.DEBUG ? new AndroidLogger(Log.DEBUG) : new AndroidLogger(Log.WARN));
     }
 
-    protected BaseRealm(RealmConfiguration configuration, boolean autoRefresh) {
+    protected BaseRealm(RealmConfiguration configuration) {
         this.threadId = Thread.currentThread().getId();
         this.configuration = configuration;
-        this.sharedGroupManager = new SharedGroupManager(configuration);
-        this.schema = new RealmSchema(this, sharedGroupManager.getTransaction());
+
         this.handlerController = new HandlerController(this);
-        if (Looper.myLooper() == null) {
-            if (autoRefresh) {
-                throw new IllegalStateException("Cannot set auto-refresh in a Thread without a Looper");
-            }
-        } else {
-            setAutoRefresh(autoRefresh);
+        this.sharedRealm = SharedRealm.getInstance(configuration, new AndroidNotifier(this.handlerController),
+                !(this instanceof Realm) ? null :
+                new SharedRealm.SchemaVersionListener() {
+                    @Override
+                    public void onSchemaVersionChanged(long currentVersion) {
+                        RealmCache.updateSchemaCache((Realm) BaseRealm.this);
+                    }
+                });
+        this.schema = new RealmSchema(this);
+
+        if (handlerController.isAutoRefreshAvailable()) {
+            setAutoRefresh(true);
         }
     }
 
@@ -101,16 +108,7 @@ protected BaseRealm(RealmConfiguration configuration, boolean autoRefresh) {
      */
     public void setAutoRefresh(boolean autoRefresh) {
         checkIfValid();
-        if (Looper.myLooper() == null) {
-            throw new IllegalStateException("Cannot set auto-refresh in a Thread without a Looper");
-        }
-
-        if (autoRefresh && !handlerController.isAutoRefreshEnabled()) { // Switch it on
-            handler = new Handler(handlerController);
-            handlers.put(handler, configuration.getPath());
-        } else if (!autoRefresh && handlerController.isAutoRefreshEnabled() && handler != null) { // Switch it off
-            removeHandler();
-        }
+        handlerController.checkCanBeAutoRefreshed();
         handlerController.setAutoRefresh(autoRefresh);
     }
 
@@ -130,7 +128,7 @@ public boolean isAutoRefresh() {
      */
     public boolean isInTransaction() {
         checkIfValid();
-        return !sharedGroupManager.isImmutable();
+        return sharedRealm.isInTransaction();
     }
 
     protected void addListener(RealmChangeListener<? extends BaseRealm> listener) {
@@ -139,7 +137,7 @@ protected void addListener(RealmChangeListener<? extends BaseRealm> listener) {
         }
         checkIfValid();
         if (!handlerController.isAutoRefreshEnabled()) {
-            throw new IllegalStateException("You can't register a listener from a non-Looper thread ");
+            throw new IllegalStateException("You can't register a listener from a non-Looper or IntentService thread.");
         }
         handlerController.addChangeListener(listener);
     }
@@ -200,21 +198,9 @@ public void removeAllChangeListeners() {
     // WARNING: If this method is used after calling any async method, the old handler will still be used.
     //          package private, for test purpose only
     void setHandler(Handler handler) {
-        // remove the old one
-        handlers.remove(this.handler);
-        handlers.put(handler, configuration.getPath());
-        this.handler = handler;
+        ((AndroidNotifier)sharedRealm.realmNotifier).setHandler(handler);
     }
 
-    /**
-     * Removes and stops the current thread handler as gracefully as possible.
-     */
-    protected void removeHandler() {
-        handlers.remove(handler);
-        // Warning: This only clears the Looper queue. Handler.Callback is not removed.
-        handler.removeCallbacksAndMessages(null);
-        this.handler = null;
-    }
 
     /**
      * Writes a compacted copy of the Realm to the given destination File.
@@ -225,9 +211,10 @@ protected void removeHandler() {
      * the last transaction was committed.
      *
      * @param destination file to save the Realm to.
-     * @throws java.io.IOException if any write operation fails.
+     * @throws RealmFileException if an error happened when accessing the underlying Realm file or writing to the
+     * destination file.
      */
-    public void writeCopyTo(File destination) throws java.io.IOException {
+    public void writeCopyTo(File destination) {
         writeEncryptedCopyTo(destination, null);
     }
 
@@ -242,15 +229,16 @@ public void writeCopyTo(File destination) throws java.io.IOException {
      *
      * @param destination file to save the Realm to.
      * @param key a 64-byte encryption key.
-     * @throws java.io.IOException if any write operation fails.
      * @throws IllegalArgumentException if destination argument is null.
+     * @throws RealmFileException if an error happened when accessing the underlying Realm file or writing to the
+     * destination file.
      */
-    public void writeEncryptedCopyTo(File destination, byte[] key) throws java.io.IOException {
+    public void writeEncryptedCopyTo(File destination, byte[] key) {
         if (destination == null) {
             throw new IllegalArgumentException("The destination argument cannot be null");
         }
         checkIfValid();
-        sharedGroupManager.copyToFile(destination, key);
+        sharedRealm.writeCopy(destination, key);
     }
 
     /**
@@ -261,6 +249,8 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws java.io.IO
      * @return {@code true} if the Realm was updated to the latest version, {@code false} if it was
      * cancelled by calling stopWaitForChange.
      * @throws IllegalStateException if calling this from within a transaction or from a Looper thread.
+     * @throws RealmMigrationNeededException on typed {@link Realm} if the latest version contains
+     * incompatible schema changes.
      */
     public boolean waitForChange() {
         checkIfValid();
@@ -270,10 +260,10 @@ public boolean waitForChange() {
         if (Looper.myLooper() != null) {
             throw new IllegalStateException("Cannot wait for changes inside a Looper thread. Use RealmChangeListeners instead.");
         }
-        boolean hasChanged = sharedGroupManager.getSharedGroup().waitForChange();
+        boolean hasChanged = sharedRealm.waitForChange();
         if (hasChanged) {
             // Since this Realm instance has been waiting for change, advance realm & refresh realm.
-            sharedGroupManager.advanceRead();
+            sharedRealm.refresh();
             handlerController.refreshSynchronousTableViews();
         }
         return hasChanged;
@@ -293,10 +283,10 @@ public void stopWaitForChange() {
             @Override
             public void onCall() {
                 // Check if the Realm instance has been closed
-                if (sharedGroupManager == null || !sharedGroupManager.isOpen() || sharedGroupManager.getSharedGroup().isClosed()) {
+                if (sharedRealm == null || sharedRealm.isClosed()) {
                     throw new IllegalStateException(BaseRealm.CLOSED_REALM_MESSAGE);
                 }
-                sharedGroupManager.getSharedGroup().stopWaitForChange();
+                sharedRealm.stopWaitForChange();
             }
         });
     }
@@ -306,15 +296,37 @@ public void onCall() {
      * {@link io.realm.Realm#cancelTransaction()}. Transactions are used to atomically create, update and delete objects
      * within a Realm.
      * <p>
-     * Before beginning the transaction, {@link io.realm.Realm#beginTransaction()} updates the Realm in the case of
-     * pending updates from other threads.
+     * Before beginning a transaction, the Realm instance is updated to the latest version in order to include all
+     * changes from other threads. This update does not trigger any registered {@link RealmChangeListener}.
+     * <p>
+     * It is therefore recommended to query for the items that should be modified from inside the transaction. Otherwise
+     * there is a risk that some of the results have been deleted or modified when the transaction begins.
+     * <p>
+     * <pre>
+     * {@code
+     * // Don't do this
+     * RealmResults<Person> persons = realm.where(Person.class).findAll();
+     * realm.beginTransaction();
+     * persons.first().setName("John");
+     * realm.commitTransaction();
+     *
+     * // Do this instead
+     * realm.beginTransaction();
+     * RealmResults<Person> persons = realm.where(Person.class).findAll();
+     * persons.first().setName("John");
+     * realm.commitTransaction();
+     * }
+     * </pre>
      * <p>
      * Notice: it is not possible to nest transactions. If you start a transaction within a transaction an exception is
      * thrown.
+     *
+     * @throws RealmMigrationNeededException on typed {@link Realm} if the latest version contains
+     * incompatible schema changes.
      */
     public void beginTransaction() {
         checkIfValid();
-        sharedGroupManager.promoteToWrite();
+        sharedRealm.beginTransaction();
     }
 
     /**
@@ -324,47 +336,23 @@ public void beginTransaction() {
      * changes from this commit.
      */
     public void commitTransaction() {
-        commitTransaction(true, null);
+        commitTransaction(true);
     }
 
     /**
-     * Commits transaction, runs the given runnable and then sends notifications. The runnable is useful to meet some
-     * timing conditions like the async transaction. In async transaction, the background Realm has to be closed before
-     * other threads see the changes to majoyly avoid the flaky tests.
+     * Commits transaction and sends notifications to local thread.
      *
-     * @param notifyLocalThread set to {@code false} to prevent this commit from triggering thread local change listeners.
-     * @param runAfterCommit runnable will run after transaction committed but before notification sent.
+     * @param notifyLocalThread set to {@code false} to prevent this commit from triggering thread local change
+     *                          listeners.
      */
-    void commitTransaction(boolean notifyLocalThread, Runnable runAfterCommit) {
+    void commitTransaction(boolean notifyLocalThread) {
         checkIfValid();
-        sharedGroupManager.commitAndContinueAsRead();
-
-        if (runAfterCommit != null)  {
-            runAfterCommit.run();
-        }
-
-        for (Map.Entry<Handler, String> handlerIntegerEntry : handlers.entrySet()) {
-            Handler handler = handlerIntegerEntry.getKey();
-            String realmPath = handlerIntegerEntry.getValue();
-
-            // Sometimes we don't want to notify the local thread about commits, e.g. creating a completely new Realm
-            // file will make a commit in order to create the schema. Users should not be notified about that.
-            if (!notifyLocalThread && handler.equals(this.handler)) {
-                continue;
-            }
+        sharedRealm.commitTransaction();
 
-            // For all other threads, use the Handler
-            // Note there is a race condition with handler.hasMessages() and handler.sendEmptyMessage()
-            // as the target thread consumes messages at the same time. In this case it is not a problem as worst
-            // case we end up with two REALM_CHANGED messages in the queue.
-            if (
-                    realmPath.equals(configuration.getPath())                           // It's the right realm
-                            && !handler.hasMessages(HandlerController.REALM_CHANGED)    // The right message
-                            && handler.getLooper().getThread().isAlive()                // The receiving thread is alive
-                            && !handler.sendEmptyMessage(HandlerController.REALM_CHANGED)) {
-                RealmLog.w("Cannot update Looper threads when the Looper has quit. Use realm.setAutoRefresh(false) " +
-                        "to prevent this.");
-            }
+        // Sometimes we don't want to notify the local thread about commits, e.g. creating a completely new Realm
+        // file will make a commit in order to create the schema. Users should not be notified about that.
+        if (notifyLocalThread) {
+            sharedRealm.realmNotifier.notifyCommitByLocalThread();
         }
     }
 
@@ -378,15 +366,14 @@ void commitTransaction(boolean notifyLocalThread, Runnable runAfterCommit) {
      */
     public void cancelTransaction() {
         checkIfValid();
-        sharedGroupManager.rollbackAndContinueAsRead();
+        sharedRealm.cancelTransaction();
     }
 
     /**
      * Checks if a Realm's underlying resources are still available or not getting accessed from the wrong thread.
      */
     protected void checkIfValid() {
-        // Check if the Realm instance has been closed
-        if (sharedGroupManager == null || !sharedGroupManager.isOpen()) {
+        if (sharedRealm == null || sharedRealm.isClosed()) {
             throw new IllegalStateException(BaseRealm.CLOSED_REALM_MESSAGE);
         }
 
@@ -396,6 +383,21 @@ protected void checkIfValid() {
         }
     }
 
+    protected void checkIfInTransaction() {
+        if (!sharedRealm.isInTransaction()) {
+            throw new IllegalStateException("Changing Realm data can only be done from inside a transaction.");
+        }
+    }
+
+    /**
+     * Check if the Realm is valid and in a transaction.
+     */
+    protected void checkIfValidAndInTransaction() {
+        if (!isInTransaction()) {
+            throw new IllegalStateException(NOT_IN_TRANSACTION_MESSAGE);
+        }
+    }
+
     /**
      * Returns the canonical path to where this Realm is persisted on disk.
      *
@@ -421,11 +423,7 @@ public RealmConfiguration getConfiguration() {
      * @return the schema version for the Realm file backing this Realm.
      */
     public long getVersion() {
-        if (!sharedGroupManager.hasTable(Table.METADATA_TABLE_NAME)) {
-            return UNVERSIONED;
-        }
-        Table metadataTable = sharedGroupManager.getTable(Table.METADATA_TABLE_NAME);
-        return metadataTable.getLong(0, 0);
+        return sharedRealm.getSchemaVersion();
     }
 
     /**
@@ -449,12 +447,9 @@ public void close() {
      * Closes the Realm instances and all its resources without checking the {@link RealmCache}.
      */
     void doClose() {
-        if (sharedGroupManager != null) {
-            sharedGroupManager.close();
-            sharedGroupManager = null;
-        }
-        if (handler != null) {
-            removeHandler();
+        if (sharedRealm != null) {
+            sharedRealm.close();
+            sharedRealm = null;
         }
     }
 
@@ -469,7 +464,7 @@ public boolean isClosed() {
             throw new IllegalStateException(INCORRECT_THREAD_MESSAGE);
         }
 
-        return sharedGroupManager == null || !sharedGroupManager.isOpen();
+        return sharedRealm == null || sharedRealm.isClosed();
     }
 
     /**
@@ -479,52 +474,12 @@ public boolean isClosed() {
      */
     public boolean isEmpty() {
         checkIfValid();
-        return sharedGroupManager.getTransaction().isObjectTablesEmpty();
-    }
-
-    boolean hasChanged() {
-        return sharedGroupManager.hasChanged();
+        return sharedRealm.isEmpty();
     }
 
     // package protected so unit tests can access it
     void setVersion(long version) {
-        Table metadataTable = sharedGroupManager.getTable(Table.METADATA_TABLE_NAME);
-        if (metadataTable.getColumnCount() == 0) {
-            metadataTable.addColumn(RealmFieldType.INTEGER, "version");
-            metadataTable.addEmptyRow();
-        }
-        metadataTable.setLong(0, 0, version);
-    }
-
-    /**
-     * Sort a table using the given field names and sorting directions. If a field name does not
-     * exist in the table an {@link IllegalArgumentException} will be thrown.
-     */
-    protected TableView doMultiFieldSort(String[] fieldNames, Sort sortOrders[], Table table) {
-        long columnIndices[] = new long[fieldNames.length];
-        for (int i = 0; i < fieldNames.length; i++) {
-            String fieldName = fieldNames[i];
-            long columnIndex = table.getColumnIndex(fieldName);
-            if (columnIndex == -1) {
-                throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
-            }
-            columnIndices[i] = columnIndex;
-        }
-
-        return table.getSortedView(columnIndices, sortOrders);
-    }
-
-    protected void checkAllObjectsSortedParameters(String[] fieldNames, Sort[] sortOrders) {
-        if (fieldNames == null) {
-            throw new IllegalArgumentException("fieldNames must be provided.");
-        } else if (sortOrders == null) {
-            throw new IllegalArgumentException("sortOrders must be provided.");
-        }
-    }
-
-    // Return all handlers registered for this Realm
-    static Map<Handler, String> getHandlers() {
-        return handlers;
+        sharedRealm.setSchemaVersion(version);
     }
 
     /**
@@ -536,40 +491,37 @@ public RealmSchema getSchema() {
         return schema;
     }
 
-    <E extends RealmModel> E get(Class<E> clazz, long rowIndex) {
+    <E extends RealmModel> E get(Class<E> clazz, long rowIndex, boolean acceptDefaultValue, List<String> excludeFields) {
         Table table = schema.getTable(clazz);
         UncheckedRow row = table.getUncheckedRow(rowIndex);
-        E result = configuration.getSchemaMediator().newInstance(clazz, schema.getColumnInfo(clazz));
+        E result = configuration.getSchemaMediator().newInstance(clazz, this, row, schema.getColumnInfo(clazz),
+                acceptDefaultValue, excludeFields);
         RealmObjectProxy proxy = (RealmObjectProxy) result;
-        proxy.realmGet$proxyState().setRow$realm(row);
-        proxy.realmGet$proxyState().setRealm$realm(this);
         proxy.realmGet$proxyState().setTableVersion$realm();
-
         return result;
     }
 
     // Used by RealmList/RealmResults
     // Invariant: if dynamicClassName != null -> clazz == DynamicRealmObject
     <E extends RealmModel> E get(Class<E> clazz, String dynamicClassName, long rowIndex) {
-        Table table;
+        final Table table = (dynamicClassName != null) ? schema.getTable(dynamicClassName) : schema.getTable(clazz);
+
         E result;
         if (dynamicClassName != null) {
-            table = schema.getTable(dynamicClassName);
             @SuppressWarnings("unchecked")
-            E dynamicObj = (E) new DynamicRealmObject();
+            E dynamicObj = (E) new DynamicRealmObject(this,
+                    (rowIndex != Table.NO_MATCH) ? table.getUncheckedRow(rowIndex) : InvalidRow.INSTANCE,
+                    false);
             result = dynamicObj;
         } else {
-            table = schema.getTable(clazz);
-            result = configuration.getSchemaMediator().newInstance(clazz, schema.getColumnInfo(clazz));
+            result = configuration.getSchemaMediator().newInstance(clazz, this,
+                    (rowIndex != Table.NO_MATCH) ? table.getUncheckedRow(rowIndex) : InvalidRow.INSTANCE,
+                    schema.getColumnInfo(clazz), false, Collections.<String> emptyList());
         }
 
         RealmObjectProxy proxy = (RealmObjectProxy) result;
-        proxy.realmGet$proxyState().setRealm$realm(this);
         if (rowIndex != Table.NO_MATCH) {
-            proxy.realmGet$proxyState().setRow$realm(table.getUncheckedRow(rowIndex));
             proxy.realmGet$proxyState().setTableVersion$realm();
-        } else {
-            proxy.realmGet$proxyState().setRow$realm(InvalidRow.INSTANCE);
         }
 
         return result;
@@ -603,7 +555,7 @@ static private boolean deletes(String canonicalPath, File rootFolder, String rea
                 boolean deleteResult = fileToDelete.delete();
                 if (!deleteResult) {
                     realmDeleted.set(false);
-                    RealmLog.w("Could not delete the file " + fileToDelete);
+                    RealmLog.warn("Could not delete the file %s", fileToDelete);
                 }
             }
         }
@@ -626,12 +578,12 @@ public void onResult(int count) {
                 }
 
                 String canonicalPath = configuration.getPath();
-                File realmFolder = configuration.getRealmFolder();
+                File realmFolder = configuration.getRealmDirectory();
                 String realmFileName = configuration.getRealmFileName();
                 File managementFolder = new File(realmFolder, realmFileName + management);
 
-                // delete files in management folder and the folder
-                // there is no subfolders in the management folder
+                // delete files in management directory and the directory
+                // there is no subfolders in the management directory
                 File[] files = managementFolder.listFiles();
                 if (files != null) {
                     for (File file : files) {
@@ -640,7 +592,7 @@ public void onResult(int count) {
                 }
                 realmDeleted.set(realmDeleted.get() && managementFolder.delete());
 
-                // delete specific files in root folder
+                // delete specific files in root directory
                 realmDeleted.set(realmDeleted.get() && deletes(canonicalPath, realmFolder, realmFileName));
             }
         });
@@ -652,15 +604,18 @@ public void onResult(int count) {
      * Compacts the Realm file defined by the given configuration.
      *
      * @param configuration configuration for the Realm to compact.
-     * @throw IllegalArgumentException if Realm is encrypted.
+     * @throws IllegalArgumentException if Realm is encrypted.
      * @return {@code true} if compaction succeeded, {@code false} otherwise.
      */
     static boolean compactRealm(final RealmConfiguration configuration) {
+        // FIXME: Move this check to OS?
         if (configuration.getEncryptionKey() != null) {
             throw new IllegalArgumentException("Cannot currently compact an encrypted Realm.");
         }
-
-        return SharedGroupManager.compact(configuration);
+        SharedRealm sharedRealm = SharedRealm.getInstance(configuration);
+        Boolean result = sharedRealm.compact();
+        sharedRealm.close();
+        return result;
     }
 
     /**
@@ -725,9 +680,77 @@ public void onResult(int count) {
         }
     }
 
+    // Return true if this Realm can receive notifications.
+    boolean hasValidNotifier() {
+        return sharedRealm.realmNotifier != null && sharedRealm.realmNotifier.isValid();
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        if (sharedRealm != null && !sharedRealm.isClosed()) {
+            RealmLog.warn("Remember to call close() on all Realm instances. " +
+                    "Realm %s is being finalized without being closed, " +
+                    "this can lead to running out of native memory.", configuration.getPath()
+            );
+        }
+        super.finalize();
+    }
+
     // Internal delegate for migrations
     protected interface MigrationCallback {
         void migrationComplete();
     }
 
+    public static final class RealmObjectContext {
+        private BaseRealm realm;
+        private Row row;
+        private ColumnInfo columnInfo;
+        private boolean acceptDefaultValue;
+        private List<String> excludeFields;
+
+        public void set(BaseRealm realm, Row row, ColumnInfo columnInfo,
+                        boolean acceptDefaultValue, List<String> excludeFields) {
+            this.realm = realm;
+            this.row = row;
+            this.columnInfo = columnInfo;
+            this.acceptDefaultValue = acceptDefaultValue;
+            this.excludeFields = excludeFields;
+        }
+
+        public BaseRealm getRealm() {
+            return realm;
+        }
+
+        public Row getRow() {
+            return row;
+        }
+
+        public ColumnInfo getColumnInfo() {
+            return columnInfo;
+        }
+
+        public boolean getAcceptDefaultValue() {
+            return acceptDefaultValue;
+        }
+
+        public List<String> getExcludeFields() {
+            return excludeFields;
+        }
+
+        public void clear() {
+            realm = null;
+            row = null;
+            columnInfo = null;
+            acceptDefaultValue = false;
+            excludeFields = null;
+        }
+    }
+    static final class ThreadLocalRealmObjectContext extends ThreadLocal<RealmObjectContext> {
+        @Override
+        protected RealmObjectContext initialValue() {
+            return new RealmObjectContext();
+        }
+    }
+
+    public static final ThreadLocalRealmObjectContext objectContext = new ThreadLocalRealmObjectContext();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
index ffd4bf796f..4af7ad524b 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
@@ -16,12 +16,12 @@
 
 package io.realm;
 
-import android.os.Looper;
+import android.app.IntentService;
 
 import io.realm.exceptions.RealmException;
-import io.realm.exceptions.RealmIOException;
+import io.realm.exceptions.RealmFileException;
 import io.realm.internal.Table;
-import io.realm.internal.log.RealmLog;
+import io.realm.log.RealmLog;
 import rx.Observable;
 
 /**
@@ -46,8 +46,8 @@
  */
 public final class DynamicRealm extends BaseRealm {
 
-    private DynamicRealm(RealmConfiguration configuration, boolean autoRefresh) {
-        super(configuration, autoRefresh);
+    private DynamicRealm(RealmConfiguration configuration) {
+        super(configuration);
     }
 
     /**
@@ -57,7 +57,7 @@ private DynamicRealm(RealmConfiguration configuration, boolean autoRefresh) {
      *
      * @return the DynamicRealm defined by the configuration.
      * @see RealmConfiguration for details on how to configure a Realm.
-     * @throws RealmIOException if an error happened when accessing the underlying Realm file.
+     * @throws RealmFileException if an error happened when accessing the underlying Realm file.
      * @throws IllegalArgumentException if {@code configuration} argument is {@code null}.
      */
     public static DynamicRealm getInstance(RealmConfiguration configuration) {
@@ -77,6 +77,11 @@ public static DynamicRealm getInstance(RealmConfiguration configuration) {
     public DynamicRealmObject createObject(String className) {
         checkIfValid();
         Table table = schema.getTable(className);
+        // Check and throw the exception earlier for a better exception message.
+        if (table.hasPrimaryKey()) {
+            throw new RealmException(String.format("'%s' has a primary key, use" +
+                    " 'createObject(String, Object)' instead.", className));
+        }
         long rowIndex = table.addEmptyRow();
         return get(DynamicRealmObject.class, className, rowIndex);
     }
@@ -95,8 +100,7 @@ public DynamicRealmObject createObject(String className) {
     public DynamicRealmObject createObject(String className, Object primaryKeyValue) {
         Table table = schema.getTable(className);
         long index = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
-        DynamicRealmObject dynamicRealmObject = new DynamicRealmObject(this, table.getCheckedRow(index));
-        return dynamicRealmObject;
+        return new DynamicRealmObject(this, table.getCheckedRow(index), false);
     }
 
     /**
@@ -109,7 +113,7 @@ public DynamicRealmObject createObject(String className, Object primaryKeyValue)
      */
     public RealmQuery<DynamicRealmObject> where(String className) {
         checkIfValid();
-        if (!sharedGroupManager.hasTable(Table.TABLE_PREFIX + className)) {
+        if (!sharedRealm.hasTable(Table.TABLE_PREFIX + className)) {
             throw new IllegalArgumentException("Class does not exist in the Realm and cannot be queried: " + className);
         }
         return RealmQuery.createDynamicQuery(this, className);
@@ -128,7 +132,7 @@ public DynamicRealmObject createObject(String className, Object primaryKeyValue)
      *
      * @param listener the change listener.
      * @throws IllegalArgumentException if the change listener is {@code null}.
-     * @throws IllegalStateException if you try to register a listener from a non-Looper Thread.
+     * @throws IllegalStateException if you try to register a listener from a non-Looper or {@link IntentService} thread.
      * @see io.realm.RealmChangeListener
      * @see #removeChangeListener(RealmChangeListener)
      * @see #removeAllChangeListeners()
@@ -144,6 +148,7 @@ public void addChangeListener(RealmChangeListener<DynamicRealm> listener) {
      */
     public void delete(String className) {
         checkIfValid();
+        checkIfInTransaction();
         schema.getTable(className).clear();
     }
 
@@ -168,7 +173,7 @@ public void executeTransaction(Transaction transaction) {
             if (isInTransaction()) {
                 cancelTransaction();
             } else {
-                RealmLog.w("Could not cancel transaction, not currently in a transaction.");
+                RealmLog.warn("Could not cancel transaction, not currently in a transaction.");
             }
             throw e;
         }
@@ -180,8 +185,7 @@ public void executeTransaction(Transaction transaction) {
      * @return a {@link DynamicRealm} instance.
      */
     static DynamicRealm createInstance(RealmConfiguration configuration) {
-        boolean autoRefresh = Looper.myLooper() != null;
-        return new DynamicRealm(configuration, autoRefresh);
+        return new DynamicRealm(configuration);
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
index 773ad0894f..88ec5cd14e 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
@@ -19,6 +19,7 @@
 import java.util.Date;
 import java.util.Locale;
 
+import io.realm.exceptions.RealmException;
 import io.realm.internal.CheckedRow;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
@@ -32,7 +33,9 @@
  * Using a DynamicRealmObject is slower than using the regular RealmObject class.
  */
 public final class DynamicRealmObject extends RealmObject implements RealmObjectProxy {
+
     private final ProxyState proxyState = new ProxyState(this);
+
     /**
      * Creates a dynamic Realm object based on an existing object.
      *
@@ -47,29 +50,42 @@ public DynamicRealmObject(RealmModel obj) {
             throw new IllegalArgumentException("The object is already a DynamicRealmObject: " + obj);
         }
 
-        if (!RealmObject.isValid(obj)) {
+        if (!RealmObject.isManaged(obj)) {
             throw new IllegalArgumentException("An object managed by Realm must be provided. This " +
-                    "is an unmanaged object or it was deleted.");
+                    "is an unmanaged object.");
+        }
+
+        if (!RealmObject.isValid(obj)) {
+            throw new IllegalArgumentException("A valid object managed by Realm must be provided. " +
+                    "This object was deleted.");
         }
 
         RealmObjectProxy proxy = (RealmObjectProxy) obj;
         Row row = proxy.realmGet$proxyState().getRow$realm();
         proxyState.setRealm$realm(proxy.realmGet$proxyState().getRealm$realm());
         proxyState.setRow$realm(((UncheckedRow) row).convertToChecked());
+        proxyState.setConstructionFinished();
     }
 
-    // Create a dynamic object. Only used internally
-    DynamicRealmObject() {
-
-    }
-
-    DynamicRealmObject(BaseRealm realm, Row row) {
+    DynamicRealmObject(BaseRealm realm, Row row, boolean convertTocheckedRow) {
         proxyState.setRealm$realm(realm);
-        proxyState.setRow$realm((row instanceof CheckedRow) ? (CheckedRow) row : ((UncheckedRow) row).convertToChecked());
+        if (convertTocheckedRow) {
+            proxyState.setRow$realm((row instanceof CheckedRow) ? (CheckedRow) row : ((UncheckedRow) row).convertToChecked());
+        } else {
+            proxyState.setRow$realm(row);
+        }
+        proxyState.setConstructionFinished();
     }
 
-    DynamicRealmObject(String className) {
+    DynamicRealmObject(String className, BaseRealm realm, Row row, boolean convertTocheckedRow) {
         proxyState.setClassName(className);
+        proxyState.setRealm$realm(realm);
+        if (convertTocheckedRow) {
+            proxyState.setRow$realm((row instanceof CheckedRow) ? (CheckedRow) row : ((UncheckedRow) row).convertToChecked());
+        } else {
+            proxyState.setRow$realm(row);
+        }
+        proxyState.setConstructionFinished();
     }
 
     /**
@@ -113,6 +129,7 @@ public DynamicRealmObject(RealmModel obj) {
      */
     public boolean getBoolean(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        checkFieldType(fieldName, columnIndex, RealmFieldType.BOOLEAN);
         return proxyState.getRow$realm().getBoolean(columnIndex);
     }
 
@@ -159,6 +176,7 @@ public short getShort(String fieldName) {
      */
     public long getLong(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        checkFieldType(fieldName, columnIndex, RealmFieldType.INTEGER);
         return proxyState.getRow$realm().getLong(columnIndex);
     }
 
@@ -174,8 +192,7 @@ public long getLong(String fieldName) {
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public byte getByte(String fieldName) {
-        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
-        return (byte) proxyState.getRow$realm().getLong(columnIndex);
+        return (byte) getLong(fieldName);
     }
 
     /**
@@ -191,6 +208,7 @@ public byte getByte(String fieldName) {
      */
     public float getFloat(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        checkFieldType(fieldName, columnIndex, RealmFieldType.FLOAT);
         return proxyState.getRow$realm().getFloat(columnIndex);
     }
 
@@ -207,6 +225,7 @@ public float getFloat(String fieldName) {
      */
     public double getDouble(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        checkFieldType(fieldName, columnIndex, RealmFieldType.DOUBLE);
         return proxyState.getRow$realm().getDouble(columnIndex);
     }
 
@@ -219,6 +238,7 @@ public double getDouble(String fieldName) {
      */
     public byte[] getBlob(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        checkFieldType(fieldName, columnIndex, RealmFieldType.BINARY);
         return proxyState.getRow$realm().getBinaryByteArray(columnIndex);
     }
 
@@ -231,6 +251,7 @@ public double getDouble(String fieldName) {
      */
     public String getString(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        checkFieldType(fieldName, columnIndex, RealmFieldType.STRING);
         return proxyState.getRow$realm().getString(columnIndex);
     }
 
@@ -243,6 +264,7 @@ public String getString(String fieldName) {
      */
     public Date getDate(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        checkFieldType(fieldName, columnIndex, RealmFieldType.DATE);
         if (proxyState.getRow$realm().isNull(columnIndex)) {
             return null;
         } else {
@@ -259,12 +281,13 @@ public Date getDate(String fieldName) {
      */
     public DynamicRealmObject getObject(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        checkFieldType(fieldName, columnIndex, RealmFieldType.OBJECT);
         if (proxyState.getRow$realm().isNullLink(columnIndex)) {
             return null;
         } else {
             long linkRowIndex = proxyState.getRow$realm().getLink(columnIndex);
             CheckedRow linkRow = proxyState.getRow$realm().getTable().getLinkTarget(columnIndex).getCheckedRow(linkRowIndex);
-            return new DynamicRealmObject(proxyState.getRealm$realm(), linkRow);
+            return new DynamicRealmObject(proxyState.getRealm$realm(), linkRow, false);
         }
     }
 
@@ -277,6 +300,7 @@ public DynamicRealmObject getObject(String fieldName) {
      */
     public RealmList<DynamicRealmObject> getList(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        checkFieldType(fieldName, columnIndex, RealmFieldType.LIST);
         LinkView linkView = proxyState.getRow$realm().getLinkList(columnIndex);
         String className = RealmSchema.getSchemaForTable(linkView.getTargetTable());
         return new RealmList<DynamicRealmObject>(className, linkView, proxyState.getRealm$realm());
@@ -348,6 +372,7 @@ public boolean hasField(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist or if the input value cannot be converted
      * to the appropriate input type.
      * @throws NumberFormatException if a String based number cannot be converted properly.
+     * @throws RealmException if the field is a {@link io.realm.annotations.PrimaryKey} field.
      */
     @SuppressWarnings("unchecked")
     public void set(String fieldName, Object value) {
@@ -405,7 +430,7 @@ private void setValue(String fieldName, Object value) {
             setObject(fieldName, (DynamicRealmObject) value);
         } else if (valueClass == RealmList.class) {
             @SuppressWarnings("unchecked")
-            RealmList<RealmObject> list = (RealmList<RealmObject>) value;
+            RealmList<DynamicRealmObject> list = (RealmList<DynamicRealmObject>) value;
             setList(fieldName, list);
         } else {
             throw new IllegalArgumentException("Value is of an type not supported: " + value.getClass());
@@ -430,8 +455,10 @@ public void setBoolean(String fieldName, boolean value) {
      * @param fieldName field name.
      * @param value value to insert.
      * @throws IllegalArgumentException if field name doesn't exist or field isn't an integer field.
+     * @throws RealmException if the field is a {@link io.realm.annotations.PrimaryKey} field.
      */
     public void setShort(String fieldName, short value) {
+        checkIsPrimaryKey(fieldName);
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         proxyState.getRow$realm().setLong(columnIndex, value);
     }
@@ -442,8 +469,10 @@ public void setShort(String fieldName, short value) {
      * @param fieldName field name to update.
      * @param value value to insert.
      * @throws IllegalArgumentException if field name doesn't exist or field isn't an integer field.
+     * @throws RealmException if the field is a {@link io.realm.annotations.PrimaryKey} field.
      */
     public void setInt(String fieldName, int value) {
+        checkIsPrimaryKey(fieldName);
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         proxyState.getRow$realm().setLong(columnIndex, value);
     }
@@ -454,8 +483,10 @@ public void setInt(String fieldName, int value) {
      * @param fieldName field name.
      * @param value value to insert.
      * @throws IllegalArgumentException if field name doesn't exist or field isn't an integer field.
+     * @throws RealmException if the field is a {@link io.realm.annotations.PrimaryKey} field.
      */
     public void setLong(String fieldName, long value) {
+        checkIsPrimaryKey(fieldName);
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         proxyState.getRow$realm().setLong(columnIndex, value);
     }
@@ -466,8 +497,10 @@ public void setLong(String fieldName, long value) {
      * @param fieldName field name.
      * @param value value to insert.
      * @throws IllegalArgumentException if field name doesn't exist or field isn't an integer field.
+     * @throws RealmException if the field is a {@link io.realm.annotations.PrimaryKey} field.
      */
     public void setByte(String fieldName, byte value) {
+        checkIsPrimaryKey(fieldName);
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         proxyState.getRow$realm().setLong(columnIndex, value);
     }
@@ -502,8 +535,10 @@ public void setDouble(String fieldName, double value) {
      * @param fieldName field name.
      * @param value value to insert.
      * @throws IllegalArgumentException if field name doesn't exist or field isn't a String field.
+     * @throws RealmException if the field is a {@link io.realm.annotations.PrimaryKey} field.
      */
     public void setString(String fieldName, String value) {
+        checkIsPrimaryKey(fieldName);
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         proxyState.getRow$realm().setString(columnIndex, value);
     }
@@ -574,7 +609,7 @@ public void setObject(String fieldName, DynamicRealmObject value) {
      * of the object represented by the DynamicRealmObject doesn't match or any element in the list belongs to a
      * different Realm.
      */
-    public void setList(String fieldName, RealmList<? extends RealmModel> list) {
+    public void setList(String fieldName, RealmList<DynamicRealmObject> list) {
         if (list == null) {
             throw new IllegalArgumentException("Null values not allowed for lists");
         }
@@ -599,7 +634,7 @@ public void setList(String fieldName, RealmList<? extends RealmModel> list) {
         links.clear();
         Table linkTargetTable = links.getTargetTable();
         for (int i = 0; i < list.size(); i++) {
-            RealmObjectProxy obj = (RealmObjectProxy) list.get(i);
+            RealmObjectProxy obj = list.get(i);
             if (obj.realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
                 throw new IllegalArgumentException("Each element in 'list' must belong to the same Realm instance.");
             }
@@ -617,6 +652,7 @@ public void setList(String fieldName, RealmList<? extends RealmModel> list) {
      *
      * @param fieldName field name.
      * @throws IllegalArgumentException if field name doesn't exist, or the field isn't nullable.
+     * @throws RealmException if the field is a {@link io.realm.annotations.PrimaryKey} field.
      */
     public void setNull(String fieldName) {
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -624,6 +660,7 @@ public void setNull(String fieldName) {
         if (type == RealmFieldType.OBJECT) {
             proxyState.getRow$realm().nullifyLink(columnIndex);
         } else {
+            checkIsPrimaryKey(fieldName);
             proxyState.getRow$realm().setNull(columnIndex);
         }
     }
@@ -648,6 +685,22 @@ public RealmFieldType getFieldType(String fieldName) {
         return proxyState.getRow$realm().getColumnType(columnIndex);
     }
 
+    private void checkFieldType(String fieldName, long columnIndex, RealmFieldType expectedType) {
+        RealmFieldType columnType = proxyState.getRow$realm().getColumnType(columnIndex);
+        if (columnType != expectedType) {
+            String expectedIndefiniteVowel = "";
+            if (expectedType == RealmFieldType.INTEGER || expectedType == RealmFieldType.OBJECT) {
+                expectedIndefiniteVowel = "n";
+            }
+            String columnTypeIndefiniteVowel = "";
+            if (expectedType == RealmFieldType.INTEGER || expectedType == RealmFieldType.OBJECT) {
+                columnTypeIndefiniteVowel = "n";
+            }
+            throw new IllegalArgumentException(String.format("'%s' is not a%s '%s', but a%s '%s'.",
+                    fieldName, expectedIndefiniteVowel, expectedType, columnTypeIndefiniteVowel, columnType));
+        }
+    }
+
     /**
      * Returns a hash code value for the {@link DynamicRealmObject} object.
      * <p>
@@ -763,4 +816,13 @@ public String toString() {
     public ProxyState realmGet$proxyState() {
         return proxyState;
     }
+
+    // Checks if the given field is primary key field. Throws if it is a PK field.
+    private void checkIsPrimaryKey(String fieldName) {
+        RealmObjectSchema objectSchema = proxyState.getRealm$realm().getSchema().getSchemaForClass(getType());
+        if (objectSchema.hasPrimaryKey() && objectSchema.getPrimaryKey().equals(fieldName)) {
+            throw new IllegalArgumentException(String.format(
+                    "Primary key field '%s' cannot be changed after object was created.", fieldName));
+        }
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/HandlerController.java b/realm/realm-library/src/main/java/io/realm/HandlerController.java
index d202599e34..3a04ddff21 100644
--- a/realm/realm-library/src/main/java/io/realm/HandlerController.java
+++ b/realm/realm-library/src/main/java/io/realm/HandlerController.java
@@ -33,24 +33,24 @@
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Future;
 
+import io.realm.internal.HandlerControllerConstants;
 import io.realm.internal.IdentitySet;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
-import io.realm.internal.SharedGroup;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.async.BadVersionException;
 import io.realm.internal.async.QueryUpdateTask;
-import io.realm.internal.log.RealmLog;
+import io.realm.log.RealmLog;
+
+import static android.R.attr.version;
+import static io.realm.internal.HandlerControllerConstants.LOCAL_COMMIT;
+import static io.realm.internal.HandlerControllerConstants.REALM_CHANGED;
 
 /**
  * Centralises all Handler callbacks, including updating async queries and refreshing the Realm.
  */
 final class HandlerController implements Handler.Callback {
 
-    static final int REALM_CHANGED = 14930352; // Hopefully it won't clash with other message IDs.
-    static final int COMPLETED_UPDATE_ASYNC_QUERIES = 24157817;
-    static final int COMPLETED_ASYNC_REALM_RESULTS = 39088169;
-    static final int COMPLETED_ASYNC_REALM_OBJECT = 63245986;
-    static final int REALM_ASYNC_BACKGROUND_EXCEPTION = 102334155;
     private final static Boolean NO_REALM_QUERY = Boolean.TRUE;
 
     // Keep a strong reference to the registered RealmChangeListener
@@ -97,6 +97,11 @@
     final ConcurrentHashMap<WeakReference<RealmObjectProxy>, Object> realmObjects =
             new ConcurrentHashMap<WeakReference<RealmObjectProxy>, Object>();
 
+    // List of onSuccess callbacks from async transactions. We need to track all callbacks as notifying listeners might
+    // be delayed due to the presence of async queries. This can mean that multiple async transactions can complete
+    // before we are ready to notify all of them.
+    private final List<Runnable> pendingOnSuccessAsyncTransactionCallbacks = new ArrayList<Runnable>();
+
     public HandlerController(BaseRealm realm) {
         this.realm = realm;
     }
@@ -107,32 +112,33 @@ public boolean handleMessage(Message message) {
         // aware when this threads handler is removed before they send messages to it. We don't wish to synchronize
         // access to the handlers as they are the prime mean of notifying about updates. Instead we make sure
         // that if a message does slip though (however unlikely), it will not try to update a SharedGroup that no
-        // longer exists. `sharedGroupManager` will only be null if a Realm is really closed.
-        if (realm.sharedGroupManager != null) {
+        // longer exists. `sharedRealm` will only be null if a Realm is really closed.
+        if (realm.sharedRealm != null) {
             QueryUpdateTask.Result result;
             switch (message.what) {
 
+                case LOCAL_COMMIT:
                 case REALM_CHANGED:
-                    realmChanged();
+                    realmChanged(message.what == LOCAL_COMMIT);
                     break;
 
-                case COMPLETED_ASYNC_REALM_RESULTS:
+                case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS:
                     result = (QueryUpdateTask.Result) message.obj;
                     completedAsyncRealmResults(result);
                     break;
 
-                case COMPLETED_ASYNC_REALM_OBJECT:
+                case HandlerControllerConstants.COMPLETED_ASYNC_REALM_OBJECT:
                     result = (QueryUpdateTask.Result) message.obj;
                     completedAsyncRealmObject(result);
                     break;
 
-                case COMPLETED_UPDATE_ASYNC_QUERIES:
+                case HandlerControllerConstants.COMPLETED_UPDATE_ASYNC_QUERIES:
                     // this is called once the background thread completed the update of the async queries
                     result = (QueryUpdateTask.Result) message.obj;
                     completedAsyncQueriesUpdate(result);
                     break;
 
-                case REALM_ASYNC_BACKGROUND_EXCEPTION:
+                case HandlerControllerConstants.REALM_ASYNC_BACKGROUND_EXCEPTION:
                     // Don't fail silently in the background in case of Core exception
                     throw (Error) message.obj;
 
@@ -143,6 +149,26 @@ public boolean handleMessage(Message message) {
         return true;
     }
 
+    /**
+     * Properly handles when an async transaction completes. This will be treated as a REALM_CHANGED event when
+     * determining which queries to re-run and when to notify listeners.
+     * <p>
+     * NOTE: This is needed as it is not possible to combine a `Message.what` value and a callback runnable. So instead
+     * of posting two messages, we post a runnable that runs this method. This means it is possible to interpret
+     * `REALM_CHANGED + Runnable` as one atomic message.
+     *
+     * @param onSuccess onSuccess callback to run for the async transaction that completed.
+     */
+    public void handleAsyncTransactionCompleted(Runnable onSuccess) {
+        // Same reason as handleMessage()
+        if (realm.sharedRealm != null) {
+            if (onSuccess != null) {
+                pendingOnSuccessAsyncTransactionCallbacks.add(onSuccess);
+            }
+            realmChanged(false);
+        }
+    }
+
     void addChangeListener(RealmChangeListener<? extends BaseRealm> listener) {
         changeListeners.addIfAbsent(listener);
     }
@@ -184,6 +210,7 @@ void addChangeListenerAsWeakReference(RealmChangeListener<? extends BaseRealm> l
         }
     }
 
+    @SuppressWarnings("unused")
     void removeWeakChangeListener(RealmChangeListener<? extends BaseRealm> listener) {
         List<WeakReference<RealmChangeListener<? extends BaseRealm>>> toRemoveList = null;
         for (int i = 0; i < weakChangeListeners.size(); i++) {
@@ -210,17 +237,20 @@ void removeAllChangeListeners() {
         changeListeners.clear();
     }
 
+    /**
+     * NOTE: Should only be called from {@link #notifyAllListeners(List)}.
+     */
     private void notifyGlobalListeners() {
         // notify strong reference listener
         Iterator<RealmChangeListener<? extends BaseRealm>> iteratorStrongListeners = changeListeners.iterator();
-        while (iteratorStrongListeners.hasNext() && !realm.isClosed()) { // every callback could close the realm
+        while (!realm.isClosed() && iteratorStrongListeners.hasNext()) { // every callback could close the realm
             RealmChangeListener listener = iteratorStrongListeners.next();
             listener.onChange(realm);
         }
         // notify weak reference listener (internals)
         Iterator<WeakReference<RealmChangeListener<? extends BaseRealm>>> iteratorWeakListeners = weakChangeListeners.iterator();
         List<WeakReference<RealmChangeListener<? extends BaseRealm>>> toRemoveList = null;
-        while (iteratorWeakListeners.hasNext() && !realm.isClosed()) {
+        while (!realm.isClosed() && iteratorWeakListeners.hasNext()) {
             WeakReference<RealmChangeListener<? extends BaseRealm>> weakRef = iteratorWeakListeners.next();
             RealmChangeListener listener = weakRef.get();
             if (listener == null) {
@@ -243,12 +273,13 @@ private void updateAsyncEmptyRealmObject() {
             Map.Entry<WeakReference<RealmObjectProxy>, RealmQuery<?>> next = iterator.next();
             if (next.getKey().get() != null) {
                 Realm.asyncTaskExecutor
-                        .submit(QueryUpdateTask.newBuilder()
+                        .submitQueryUpdate(QueryUpdateTask.newBuilder()
                                 .realmConfiguration(realm.getConfiguration())
                                 .addObject(next.getKey(),
                                         next.getValue().handoverQueryPointer(),
                                         next.getValue().getArgument())
-                                .sendToHandler(realm.handler, COMPLETED_ASYNC_REALM_OBJECT)
+                                .sendToNotifier(realm.sharedRealm.realmNotifier,
+                                        QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_OBJECT)
                                 .build());
 
             } else {
@@ -257,53 +288,74 @@ private void updateAsyncEmptyRealmObject() {
         }
     }
 
-    void notifyAllListeners() {
-        notifyGlobalListeners();
-        notifyTypeBasedListeners();
+    /**
+     * This method calls all registered listeners for Realm, RealmResults and RealmObjects, and callbacks for async
+     * transactions.
+     *
+     * PREREQUISITE: Only call this method after all objects are up to date. This means:
+     * - `advance_read` was called on the Realm.
+     * - `RealmResults.syncIfNeeded()` was called when collecting RealmResults listeners.
+     *
+     * @param realmResultsToBeNotified list of all RealmResults listeners that can be notified.
+     */
+    void notifyAllListeners(List<RealmResults<? extends RealmModel>> realmResultsToBeNotified) {
+
+        // Notify all RealmResults (async and synchronous).
+        for (Iterator<RealmResults<? extends RealmModel>> it = realmResultsToBeNotified.iterator(); !realm.isClosed() && it.hasNext(); ) {
+            RealmResults<? extends RealmModel> realmResults = it.next();
+            realmResults.notifyChangeListeners(false);
+        }
+
+        // Notify all loaded RealmObjects
+        notifyRealmObjectCallbacks();
 
-        // empty async RealmObject shouldn't block the realm to advance
-        // they're empty so no risk for running into a corrupt state
-        // where the pointer (Row) is using one version of a Realm, whereas the
-        // current Realm is advancing to a newer version (they're empty anyway)
+        // Re-run any async single objects that are still not loaded.
+        // TODO: Why is this here? This was not called in `completedAsyncQueriesUpdate()`. Problem?
         if (!realm.isClosed() && threadContainsAsyncEmptyRealmObject()) {
             updateAsyncEmptyRealmObject();
         }
-    }
 
-    private void notifyTypeBasedListeners() {
-        notifyAsyncRealmResultsCallbacks();
-        notifySyncRealmResultsCallbacks();
-        notifyRealmObjectCallbacks();
+        // Notify any completed async transactions
+        notifyAsyncTransactionCallbacks();
+
+        // Trigger global listeners last.
+        // Note that NotificationTest.callingOrdersOfListeners will fail if orders change.
+        notifyGlobalListeners();
     }
 
-    private void notifyAsyncRealmResultsCallbacks() {
-        notifyRealmResultsCallbacks(asyncRealmResults.keySet().iterator());
+    private void collectAsyncRealmResultsCallbacks(List<RealmResults<? extends RealmModel>> resultsToBeNotified) {
+        collectRealmResultsCallbacks(asyncRealmResults.keySet().iterator(), resultsToBeNotified);
     }
 
-    private void notifySyncRealmResultsCallbacks() {
-        notifyRealmResultsCallbacks(syncRealmResults.keySet().iterator());
+    private void collectSyncRealmResultsCallbacks(List<RealmResults<? extends RealmModel>> resultsToBeNotified) {
+        collectRealmResultsCallbacks(syncRealmResults.keySet().iterator(), resultsToBeNotified);
     }
 
-    private void notifyRealmResultsCallbacks(Iterator<WeakReference<RealmResults<? extends RealmModel>>> iterator) {
-        List<RealmResults<? extends RealmModel>> resultsToBeNotified =
-                new ArrayList<RealmResults<? extends RealmModel>>();
+
+    private void collectRealmResultsCallbacks(Iterator<WeakReference<RealmResults<? extends RealmModel>>> iterator,
+                                              List<RealmResults<? extends RealmModel>> resultsToBeNotified) {
         while (iterator.hasNext()) {
             WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = iterator.next();
             RealmResults<? extends RealmModel> realmResults = weakRealmResults.get();
             if (realmResults == null) {
                 iterator.remove();
             } else {
-                // It should be legal to modify asyncRealmResults and syncRealmResults in the listener
-                resultsToBeNotified.add(realmResults);
+                // Sync the RealmResult so it is completely up to date.
+                // This is a prerequisite to calling the listener, so when the listener is finally triggered, all
+                // RealmResults will be up to date.
+                // Local commits can accidentially cause async RealmResults to be notified, so we only want to
+                // include those that are actually done loading.
+                if (realmResults.isLoaded()) {
+                    realmResults.syncIfNeeded();
+                    resultsToBeNotified.add(realmResults);
+                }
             }
         }
-
-        for (Iterator<RealmResults<? extends RealmModel>> it = resultsToBeNotified.iterator(); it.hasNext() && !realm.isClosed(); ) {
-            RealmResults<? extends RealmModel> realmResults = it.next();
-            realmResults.notifyChangeListeners();
-        }
     }
 
+    /**
+     * NOTE: Should only be called from {@link #notifyAllListeners(List)}.
+     */
     private void notifyRealmObjectCallbacks() {
         List<RealmObjectProxy> objectsToBeNotified = new ArrayList<RealmObjectProxy>();
         Iterator<WeakReference<RealmObjectProxy>> iterator = realmObjects.keySet().iterator();
@@ -323,7 +375,7 @@ private void notifyRealmObjectCallbacks() {
             }
         }
 
-        for (Iterator<RealmObjectProxy> it = objectsToBeNotified.iterator(); it.hasNext() && !realm.isClosed(); ) {
+        for (Iterator<RealmObjectProxy> it = objectsToBeNotified.iterator(); !realm.isClosed() && it.hasNext(); ) {
             RealmObjectProxy realmObject = it.next();
             realmObject.realmGet$proxyState().notifyChangeListeners$realm();
         }
@@ -334,9 +386,9 @@ private void updateAsyncQueries() {
             // try to cancel any pending update since we're submitting a new one anyway
             updateAsyncQueriesTask.cancel(true);
             Realm.asyncTaskExecutor.getQueue().remove(updateAsyncQueriesTask);
-            RealmLog.d("REALM_CHANGED realm:" + HandlerController.this + " cancelling pending COMPLETED_UPDATE_ASYNC_QUERIES updates");
+            RealmLog.trace("REALM_CHANGED realm: %s cancelling pending COMPLETED_UPDATE_ASYNC_QUERIES updates", HandlerController.this);
         }
-        RealmLog.d("REALM_CHANGED realm:"+ HandlerController.this + " updating async queries, total: " + asyncRealmResults.size());
+        RealmLog.trace("REALM_CHANGED realm: %s updating async queries, total: %d", HandlerController.this, asyncRealmResults.size());
         // prepare a QueryUpdateTask to current async queries in this thread
         QueryUpdateTask.Builder.UpdateQueryStep updateQueryStep = QueryUpdateTask.newBuilder()
                 .realmConfiguration(realm.getConfiguration());
@@ -368,21 +420,40 @@ private void updateAsyncQueries() {
         }
         if (realmResultsQueryStep != null) {
             QueryUpdateTask queryUpdateTask = realmResultsQueryStep
-                    .sendToHandler(realm.handler, COMPLETED_UPDATE_ASYNC_QUERIES)
+                    .sendToNotifier(realm.sharedRealm.realmNotifier,
+                            QueryUpdateTask.NotifyEvent.COMPLETE_UPDATE_ASYNC_QUERIES)
                     .build();
-            updateAsyncQueriesTask = Realm.asyncTaskExecutor.submit(queryUpdateTask);
+            updateAsyncQueriesTask = Realm.asyncTaskExecutor.submitQueryUpdate(queryUpdateTask);
         }
     }
 
-    private void realmChanged() {
+    private void realmChanged(boolean localCommit) {
+        RealmLog.debug("%s : %s", (localCommit ? "LOCAL_COMMIT" : "REALM_CHANGED"), HandlerController.this);
         deleteWeakReferences();
-        if (threadContainsAsyncQueries()) {
-            updateAsyncQueries();
+        boolean threadContainsAsyncQueries = threadContainsAsyncQueries();
+
+        // Mixing local transactions and async queries has unavoidable race conditions
+        if (localCommit && threadContainsAsyncQueries) {
+            RealmLog.warn("Mixing asynchronous queries with local writes should be avoided. " +
+                    "Realm will convert any async queries to synchronous in order to remain consistent. Use " +
+                    "asynchronous writes instead. You can read more here: " +
+                    "https://realm.io/docs/java/latest/#asynchronous-transactions");
+        }
 
+        if (!localCommit && threadContainsAsyncQueries) {
+            // For changes from other threads, swallow the change and re-run async queries first.
+            updateAsyncQueries();
         } else {
-            RealmLog.d("REALM_CHANGED realm:" + HandlerController.this + " no async queries, advance_read");
-            realm.sharedGroupManager.advanceRead();
-            notifyAllListeners();
+            // Following cases handled by this:
+            // localCommit && threadContainsAsyncQueries (this is the case the warning above is about)
+            // localCommit && !threadContainsAsyncQueries
+            // !localCommit && !threadContainsAsyncQueries
+            realm.sharedRealm.refresh();
+
+            List<RealmResults<? extends RealmModel>> resultsToBeNotified = new ArrayList<RealmResults<? extends RealmModel>>();
+            collectAsyncRealmResultsCallbacks(resultsToBeNotified);
+            collectSyncRealmResultsCallbacks(resultsToBeNotified);
+            notifyAllListeners(resultsToBeNotified);
         }
     }
 
@@ -394,22 +465,25 @@ private void completedAsyncRealmResults(QueryUpdateTask.Result result) {
             RealmResults<? extends RealmModel> realmResults = weakRealmResults.get();
             if (realmResults == null) {
                 asyncRealmResults.remove(weakRealmResults);
-                RealmLog.d("[COMPLETED_ASYNC_REALM_RESULTS "+ weakRealmResults + "] realm:"+ HandlerController.this + " RealmResults GC'd ignore results");
-
+                RealmLog.trace("[COMPLETED_ASYNC_REALM_RESULTS %s] realm: %s RealmResults GC'd ignore results",
+                        weakRealmResults, HandlerController.this);
             } else {
-                SharedGroup.VersionID callerVersionID = realm.sharedGroupManager.getVersion();
+                SharedRealm.VersionID callerVersionID = realm.sharedRealm.getVersionID();
                 int compare = callerVersionID.compareTo(result.versionID);
                 if (compare == 0) {
                     // if the RealmResults is empty (has not completed yet) then use the value
                     // otherwise a task (grouped update) has already updated this RealmResults
                     if (!realmResults.isLoaded()) {
-                        RealmLog.d("[COMPLETED_ASYNC_REALM_RESULTS "+ weakRealmResults + "] , realm:"+ HandlerController.this + " same versions, using results (RealmResults is not loaded)");
+                        RealmLog.trace("[COMPLETED_ASYNC_REALM_RESULTS %s] , realm: %s same versions, using results (RealmResults is not loaded)",
+                                weakRealmResults, HandlerController.this);
                         // swap pointer
                         realmResults.swapTableViewPointer(result.updatedTableViews.get(weakRealmResults));
                         // notify callbacks
-                        realmResults.notifyChangeListeners();
+                        realmResults.syncIfNeeded();
+                        realmResults.notifyChangeListeners(false);
                     } else {
-                        RealmLog.d("[COMPLETED_ASYNC_REALM_RESULTS "+ weakRealmResults + "] , realm:"+ HandlerController.this + " ignoring result the RealmResults (is already loaded)");
+                        RealmLog.trace("[COMPLETED_ASYNC_REALM_RESULTS %s] , realm: %s ignoring result the RealmResults (is already loaded)",
+                                weakRealmResults, HandlerController.this);
                     }
 
                 } else if (compare > 0) {
@@ -424,7 +498,7 @@ private void completedAsyncRealmResults(QueryUpdateTask.Result result) {
 
                     if (!realmResults.isLoaded()) { // UC2
                         // UC covered by this test: RealmAsyncQueryTests#testFindAllAsyncRetry
-                        RealmLog.d("[COMPLETED_ASYNC_REALM_RESULTS " + weakRealmResults + "] , realm:"+ HandlerController.this + " caller is more advanced & RealmResults is not loaded, rerunning the query against the latest version");
+                        RealmLog.trace("[COMPLETED_ASYNC_REALM_RESULTS %s ] , %s caller is more advanced & RealmResults is not loaded, rerunning the query against the latest version", weakRealmResults, HandlerController.this);
 
                         RealmQuery<?> query = asyncRealmResults.get(weakRealmResults);
                         QueryUpdateTask queryUpdateTask = QueryUpdateTask.newBuilder()
@@ -432,14 +506,15 @@ private void completedAsyncRealmResults(QueryUpdateTask.Result result) {
                                 .add(weakRealmResults,
                                         query.handoverQueryPointer(),
                                         query.getArgument())
-                                .sendToHandler(realm.handler, COMPLETED_ASYNC_REALM_RESULTS)
+                                .sendToNotifier(realm.sharedRealm.realmNotifier,
+                                        QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_RESULTS)
                                 .build();
 
-                        Realm.asyncTaskExecutor.submit(queryUpdateTask);
+                        Realm.asyncTaskExecutor.submitQueryUpdate(queryUpdateTask);
 
                     } else {
                         // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerIsAdvanced
-                        RealmLog.d("[COMPLETED_ASYNC_REALM_RESULTS "+ weakRealmResults + "] , realm:"+ HandlerController.this + " caller is more advanced & RealmResults is loaded ignore the outdated result");
+                        RealmLog.trace("[COMPLETED_ASYNC_REALM_RESULTS %s] , %s caller is more advanced & RealmResults is loaded ignore the outdated result", weakRealmResults, HandlerController.this);
                     }
 
                 } else {
@@ -447,18 +522,20 @@ private void completedAsyncRealmResults(QueryUpdateTask.Result result) {
                     // no need to rerun the query, since we're going to receive the update signal
                     // & batch update all async queries including this one
                     // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerThreadBehind
-                    RealmLog.d("[COMPLETED_ASYNC_REALM_RESULTS "+ weakRealmResults + "] , realm:"+ HandlerController.this + " caller thread behind worker thread, ignore results (a batch update will update everything including this query)");
+                    RealmLog.trace("[COMPLETED_ASYNC_REALM_RESULTS %s] , %s caller thread behind worker thread, ignore results (a batch update will update everything including this query)", weakRealmResults, HandlerController.this);
                 }
             }
         }
     }
 
     private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
-        SharedGroup.VersionID callerVersionID = realm.sharedGroupManager.getVersion();
+        SharedRealm.VersionID callerVersionID = realm.sharedRealm.getVersionID();
         int compare = callerVersionID.compareTo(result.versionID);
         if (compare > 0) {
-            // if the caller thread is advanced i.e it already sent a REALM_CHANGE that will update the queries
-            RealmLog.d("COMPLETED_UPDATE_ASYNC_QUERIES realm:" + HandlerController.this + " caller is more advanced, Looper will updates queries");
+            // if the caller thread is more advanced than the worker thread, it means it did a local commit.
+            // This should also have put a REALM_CHANGED event on the Looper queue, so ignoring this result should
+            // be safe as all async queries will be rerun when processing the REALM_CHANGED event.
+            RealmLog.trace("COMPLETED_UPDATE_ASYNC_QUERIES %s caller is more advanced, Looper will updates queries", HandlerController.this);
 
         } else {
             // We're behind or on the same version as the worker thread
@@ -469,12 +546,12 @@ private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
                 // imperative TV, they will not rerun if the SharedGroup advance
 
                 // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerThreadBehind
-                RealmLog.d("COMPLETED_UPDATE_ASYNC_QUERIES realm:"+ HandlerController.this + " caller is behind  advance_read");
+                RealmLog.trace("COMPLETED_UPDATE_ASYNC_QUERIES %s caller is behind advance_read", HandlerController.this);
                 // refresh the Realm to the version provided by the worker thread
                 // (advanceRead to the latest version may cause a version mismatch error) preventing us
                 // from importing correctly the handover table view
                 try {
-                    realm.sharedGroupManager.advanceRead(result.versionID);
+                    realm.sharedRealm.refresh(result.versionID);
                 } catch (BadVersionException e) {
                     // The version comparison above should have ensured that that the Caller version is less than the
                     // Worker version. In that case it should always be safe to advance_read.
@@ -482,8 +559,10 @@ private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
                 }
             }
 
-            ArrayList<RealmResults<? extends RealmModel>> callbacksToNotify = new ArrayList<RealmResults<? extends RealmModel>>(result.updatedTableViews.size());
-            // use updated TableViews pointers for the existing async RealmResults
+            // It's dangerous to notify the callback about new results before updating
+            // the pointers, because the callback may use another RealmResults not updated yet
+            // this is why we defer the notification until we're done updating all pointers.
+            ArrayList<RealmResults<? extends RealmModel>> resultsToBeNotified = new ArrayList<RealmResults<? extends RealmModel>>(result.updatedTableViews.size());
             for (Map.Entry<WeakReference<RealmResults<? extends RealmModel>>, Long> query : result.updatedTableViews.entrySet()) {
                 WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = query.getKey();
                 RealmResults<? extends RealmModel> realmResults = weakRealmResults.get();
@@ -494,30 +573,36 @@ private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
                 } else {
                     // update the instance with the new pointer
                     realmResults.swapTableViewPointer(query.getValue());
+                    realmResults.syncIfNeeded();
+                    resultsToBeNotified.add(realmResults);
 
-                    // it's dangerous to notify the callback about new results before updating
-                    // the pointers, because the callback may use another RealmResults not updated yet
-                    // this is why we defer the notification until we're done updating all pointers
-                    callbacksToNotify.add(realmResults);
-
-                    RealmLog.d("COMPLETED_UPDATE_ASYNC_QUERIES realm:"+ HandlerController.this + " updating RealmResults " + weakRealmResults);
+                    RealmLog.trace("COMPLETED_UPDATE_ASYNC_QUERIES updating RealmResults %s", HandlerController.this, weakRealmResults);
                 }
             }
+            collectSyncRealmResultsCallbacks(resultsToBeNotified);
 
-            for (RealmResults<? extends RealmModel> query : callbacksToNotify) {
-                query.notifyChangeListeners();
-            }
-
-            // We need to notify the rest of listeners, since the original REALM_CHANGE
-            // was delayed/swallowed in order to be able to update async queries
-            notifyGlobalListeners();
-            notifySyncRealmResultsCallbacks();
-            notifyRealmObjectCallbacks();
+            // We need to notify all listeners, since the original REALM_CHANGE
+            // was delayed/swallowed in order to be able to update the async queries.
+            notifyAllListeners(resultsToBeNotified);
 
             updateAsyncQueriesTask = null;
         }
     }
 
+    /**
+     * Trigger onSuccess for all completed async transaction.
+     * <p>
+     * NOTE: Should only be called from {@link #notifyAllListeners(List)}.
+     */
+    private void notifyAsyncTransactionCallbacks() {
+        if (!pendingOnSuccessAsyncTransactionCallbacks.isEmpty()) {
+            for (Runnable callback : pendingOnSuccessAsyncTransactionCallbacks) {
+                callback.run();
+            }
+            pendingOnSuccessAsyncTransactionCallbacks.clear();
+        }
+    }
+
     private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
         Set<WeakReference<RealmObjectProxy>> updatedRowKey = result.updatedRow.keySet();
         if (updatedRowKey.size() > 0) {
@@ -525,7 +610,7 @@ private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
             RealmObjectProxy proxy = realmObjectWeakReference.get();
 
             if (proxy != null) {
-                SharedGroup.VersionID callerVersionID = realm.sharedGroupManager.getVersion();
+                SharedRealm.VersionID callerVersionID = realm.sharedRealm.getVersionID();
                 int compare = callerVersionID.compareTo(result.versionID);
                 // we always query on the same version
                 // only two use cases could happen 1. we're on the same version or 2. the caller has advanced in the meanwhile
@@ -543,13 +628,15 @@ private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
                     // the caller has advanced we need to
                     // retry against the current version of the caller if it's still empty
                     if (RealmObject.isValid(proxy)) { // already completed & has a valid pointer no need to re-run
-                        RealmLog.d("[COMPLETED_ASYNC_REALM_OBJECT "+ proxy + "] , realm:" + HandlerController.this
-                                + " RealmObject is already loaded, just notify it.");
+                        RealmLog.trace("[COMPLETED_ASYNC_REALM_OBJECT %s], realm: %s. " +
+                                "RealmObject is already loaded, just notify it",
+                                realm, HandlerController.this);
                         proxy.realmGet$proxyState().notifyChangeListeners$realm();
 
                     } else {
-                        RealmLog.d("[COMPLETED_ASYNC_REALM_OBJECT " + proxy + "] , realm:" + HandlerController.this
-                                + " RealmObject is not loaded yet. Rerun the query.");
+                        RealmLog.trace("[COMPLETED_ASYNC_REALM_OBJECT %s, realm: %s. " +
+                                "RealmObject is not loaded yet. Rerun the query.",
+                                proxy, HandlerController.this);
                         Object value = realmObjects.get(realmObjectWeakReference);
                         RealmQuery<? extends RealmModel> realmQuery;
                         if (value == null || value == NO_REALM_QUERY) { // this is a retry of an empty RealmObject
@@ -564,10 +651,11 @@ private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
                                 .addObject(realmObjectWeakReference,
                                         realmQuery.handoverQueryPointer(),
                                         realmQuery.getArgument())
-                                .sendToHandler(realm.handler, COMPLETED_ASYNC_REALM_OBJECT)
+                                .sendToNotifier(realm.sharedRealm.realmNotifier,
+                                        QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_OBJECT)
                                 .build();
 
-                        Realm.asyncTaskExecutor.submit(queryUpdateTask);
+                        Realm.asyncTaskExecutor.submitQueryUpdate(queryUpdateTask);
                     }
                 } else {
                     // should not happen, since the the background thread position itself against the provided version
@@ -696,10 +784,11 @@ public void refreshSynchronousTableViews() {
         }
     }
 
+    /**
+     * Toggles the auto refresh flag. Will throw an {@link IllegalStateException} if auto-refresh is not available.
+     */
     public void setAutoRefresh(boolean autoRefresh) {
-        if (autoRefresh && Looper.myLooper() == null) {
-            throw new IllegalStateException("Cannot enabled autorefresh on a non-looper thread.");
-        }
+        checkCanBeAutoRefreshed();
         this.autoRefresh = autoRefresh;
     }
 
@@ -708,11 +797,35 @@ public boolean isAutoRefreshEnabled() {
     }
 
     /**
-     * Notifies the current thread that the Realm has changed. This will also trigger change listener asynchronously.
+     * Validates that the current thread can enable auto refresh. An {@link IllegalStateException} will be thrown if that
+     * is not the case.
      */
-    public void notifyCurrentThreadRealmChanged() {
-        if (realm != null) {
-            realm.handler.sendEmptyMessage(HandlerController.REALM_CHANGED);
+    public void checkCanBeAutoRefreshed() {
+        if (Looper.myLooper() == null) {
+            throw new IllegalStateException("Cannot set auto-refresh in a Thread without a Looper");
+        }
+        if (isIntentServiceThread()) {
+            throw new IllegalStateException("Cannot set auto-refresh in an IntentService thread.");
         }
     }
+
+    /**
+     * Checks if the auto-refresh feature is available on this thread. Calling {@link #setAutoRefresh(boolean)}
+     * will throw if this method return {@code false}.
+     */
+    public boolean isAutoRefreshAvailable() {
+        if (Looper.myLooper() == null || isIntentServiceThread()) {
+            return false;
+        }
+
+        return true;
+    }
+
+    private static boolean isIntentServiceThread() {
+        // Tries to determine if a thread is an IntentService thread. No public API can detect this,
+        // so use the thread name as a heuristic:
+        // https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/IntentService.java#108
+        String threadName = Thread.currentThread().getName();
+        return threadName != null && threadName.startsWith("IntentService[");
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/ProxyState.java b/realm/realm-library/src/main/java/io/realm/ProxyState.java
index 96049817d8..af3d807c7a 100644
--- a/realm/realm-library/src/main/java/io/realm/ProxyState.java
+++ b/realm/realm-library/src/main/java/io/realm/ProxyState.java
@@ -20,11 +20,10 @@
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Future;
 
-import io.realm.internal.InvalidRow;
 import io.realm.internal.Row;
 import io.realm.internal.Table;
 import io.realm.internal.TableQuery;
-import io.realm.internal.log.RealmLog;
+import io.realm.log.RealmLog;
 
 /**
  * This implements {@code RealmObjectProxy} interface, to eliminate copying logic between
@@ -35,8 +34,13 @@
     private String className;
     private Class<? extends RealmModel> clazzName;
 
+    // true only while executing the constructor of the enclosing proxy object
+    private boolean underConstruction = true;
+
     private Row row;
     private BaseRealm realm;
+    private boolean acceptDefaultValue;
+    private List<String> excludeFields;
 
     private final List<RealmChangeListener<E>> listeners = new CopyOnWriteArrayList<RealmChangeListener<E>>();
     private Future<Long> pendingQuery;
@@ -87,6 +91,22 @@ public ProxyState(Class<? extends RealmModel> clazzName, E model) {
         this.row = row;
     }
 
+    public boolean getAcceptDefaultValue$realm() {
+        return acceptDefaultValue;
+    }
+
+    public void setAcceptDefaultValue$realm(boolean acceptDefaultValue) {
+        this.acceptDefaultValue = acceptDefaultValue;
+    }
+
+    public List<String> getExcludeFields$realm() {
+        return excludeFields;
+    }
+
+    public void setExcludeFields$realm(List<String> excludeFields) {
+        this.excludeFields = excludeFields;
+    }
+
     public Object getPendingQuery$realm() {
         return pendingQuery;
     }
@@ -114,7 +134,7 @@ public ProxyState(Class<? extends RealmModel> clazzName, E model) {
                 isCompleted = true;
             }
         } catch (Exception e) {
-            RealmLog.d(e.getMessage());
+            RealmLog.debug(e);
             return false;
         }
         return true;
@@ -132,7 +152,7 @@ public ProxyState(Class<? extends RealmModel> clazzName, E model) {
 
         } else if (!isCompleted || row == Row.EMPTY_ROW) {
             isCompleted = true;
-            long nativeRowPointer = TableQuery.nativeImportHandoverRowIntoSharedGroup(handoverRowPointer, realm.sharedGroupManager.getNativePointer());
+            long nativeRowPointer = TableQuery.importHandoverRow(handoverRowPointer, realm.sharedRealm);
             Table table = getTable();
             this.row = table.getUncheckedRowByPointer(nativeRowPointer);
         }// else: already loaded query no need to import again the pointer
@@ -178,6 +198,16 @@ public void setClassName(String className) {
         this.className = className;
     }
 
+    public boolean isUnderConstruction() {
+        return underConstruction;
+    }
+
+    public void setConstructionFinished() {
+        underConstruction = false;
+        // only used while construction.
+        excludeFields = null;
+    }
+
     private Table getTable () {
         if (className != null) {
             return getRealm$realm().schema.getTable(className);
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index fd62a7a6f7..7fe7d4aed7 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -17,9 +17,8 @@
 package io.realm;
 
 import android.annotation.TargetApi;
-import android.content.Context;
+import android.app.IntentService;
 import android.os.Build;
-import android.os.Looper;
 import android.util.JsonReader;
 
 import org.json.JSONArray;
@@ -34,7 +33,10 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
 import java.util.HashMap;
+import java.util.IdentityHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Scanner;
@@ -42,16 +44,14 @@
 import java.util.concurrent.Future;
 
 import io.realm.exceptions.RealmException;
-import io.realm.exceptions.RealmIOException;
+import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnIndices;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Table;
-import io.realm.internal.TableView;
-import io.realm.internal.Util;
-import io.realm.internal.log.RealmLog;
+import io.realm.log.RealmLog;
 import rx.Observable;
 
 /**
@@ -121,21 +121,16 @@
 
     public static final String DEFAULT_REALM_NAME = RealmConfiguration.DEFAULT_REALM_NAME;
 
-    // Caches Class objects (both model classes and proxy classes) to Realm Tables
-    private final Map<Class<? extends RealmModel>, Table> classToTable =
-            new HashMap<Class<? extends RealmModel>, Table>();
-
     private static RealmConfiguration defaultConfiguration;
 
     /**
      * The constructor is private to enforce the use of the static one.
      *
      * @param configuration the {@link RealmConfiguration} used to open the Realm.
-     * @param autoRefresh {@code true} if Realm should auto-refresh. {@code false} otherwise.
      * @throws IllegalArgumentException if trying to open an encrypted Realm with the wrong key.
      */
-    Realm(RealmConfiguration configuration, boolean autoRefresh) {
-        super(configuration, autoRefresh);
+    Realm(RealmConfiguration configuration) {
+        super(configuration);
     }
 
     /**
@@ -146,17 +141,6 @@
         return configuration.getRxFactory().from(this);
     }
 
-    @Override
-    protected void finalize() throws Throwable {
-        if (sharedGroupManager != null && sharedGroupManager.isOpen()) {
-            RealmLog.w("Remember to call close() on all Realm instances. " +
-                            "Realm " + configuration.getPath() + " is being finalized without being closed, " +
-                            "this can lead to running out of native memory."
-            );
-        }
-        super.finalize();
-    }
-
     /**
      * Realm static constructor that returns the Realm instance defined by the {@link io.realm.RealmConfiguration} set
      * by {@link #setDefaultConfiguration(RealmConfiguration)}
@@ -165,7 +149,7 @@ protected void finalize() throws Throwable {
      * @throws java.lang.NullPointerException if no default configuration has been defined.
      * @throws RealmMigrationNeededException if no migration has been provided by the default configuration and the
      *         RealmObject classes or version has has changed so a migration is required.
-     * @throws RealmIOException if an error happened when accessing the underlying Realm file.
+     * @throws RealmFileException if an error happened when accessing the underlying Realm file.
      */
     public static Realm getDefaultInstance() {
         if (defaultConfiguration == null) {
@@ -181,7 +165,7 @@ public static Realm getDefaultInstance() {
      * @return an instance of the Realm class
      * @throws RealmMigrationNeededException if no migration has been provided by the configuration and the RealmObject
      *         classes or version has has changed so a migration is required.
-     * @throws RealmIOException if an error happened when accessing the underlying Realm file.
+     * @throws RealmFileException if an error happened when accessing the underlying Realm file.
      * @throws IllegalArgumentException if a null {@link RealmConfiguration} is provided.
      * @see RealmConfiguration for details on how to configure a Realm.
      */
@@ -218,14 +202,15 @@ public static void removeDefaultConfiguration() {
      * Creates a {@link Realm} instance without checking the existence in the {@link RealmCache}.
      *
      * @param configuration {@link RealmConfiguration} used to create the Realm.
-     * @param columnIndices if this is not  {@code null}, the {@link BaseRealm#schema#columnIndices} will be
-     *                      initialized to it. Otherwise, {@link BaseRealm#schema#columnIndices} will be populated from
-     *                      the Realm file.
+     * @param globalCacheArray if this is not {@code null} and contains an entry for current schema version,
+     *                         the {@link BaseRealm#schema#columnIndices} will be initialized with the copy of
+     *                         the entry. Otherwise, {@link BaseRealm#schema#columnIndices} will be populated
+     *                         from the Realm file.
      * @return a {@link Realm} instance.
      */
-    static Realm createInstance(RealmConfiguration configuration, ColumnIndices columnIndices) {
+    static Realm createInstance(RealmConfiguration configuration, ColumnIndices[] globalCacheArray) {
         try {
-            return createAndValidate(configuration, columnIndices);
+            return createAndValidate(configuration, globalCacheArray);
 
         } catch (RealmMigrationNeededException e) {
             if (configuration.shouldDeleteRealmIfMigrationNeeded()) {
@@ -235,19 +220,19 @@ static Realm createInstance(RealmConfiguration configuration, ColumnIndices colu
                     migrateRealm(configuration);
                 } catch (FileNotFoundException fileNotFoundException) {
                     // Should never happen
-                    throw new RealmIOException(fileNotFoundException);
+                    throw new RealmFileException(RealmFileException.Kind.NOT_FOUND, fileNotFoundException);
                 }
             }
 
-            return createAndValidate(configuration, columnIndices);
+            return createAndValidate(configuration, globalCacheArray);
         }
     }
 
-    static Realm createAndValidate(RealmConfiguration configuration, ColumnIndices columnIndices) {
-        boolean autoRefresh = Looper.myLooper() != null;
-        Realm realm = new Realm(configuration, autoRefresh);
+    static Realm createAndValidate(RealmConfiguration configuration, ColumnIndices[] globalCacheArray) {
+        Realm realm = new Realm(configuration);
         long currentVersion = realm.getVersion();
         long requiredVersion = configuration.getSchemaVersion();
+        final ColumnIndices columnIndices = RealmCache.findColumnIndices(globalCacheArray, requiredVersion);
         if (currentVersion != UNVERSIONED && currentVersion < requiredVersion && columnIndices == null) {
             realm.doClose();
             throw new RealmMigrationNeededException(configuration.getPath(), String.format("Realm on disk need to migrate from v%s to v%s", currentVersion, requiredVersion));
@@ -266,7 +251,8 @@ static Realm createAndValidate(RealmConfiguration configuration, ColumnIndices c
                 throw e;
             }
         } else {
-            realm.schema.columnIndices = columnIndices;
+            // copy global cache as a Realm local indices cache
+            realm.schema.columnIndices = columnIndices.clone();
         }
 
         return realm;
@@ -290,11 +276,13 @@ private static void initializeRealm(Realm realm) {
             for (Class<? extends RealmModel> modelClass : modelClasses) {
                 // Create and validate table
                 if (version == UNVERSIONED) {
-                    mediator.createTable(modelClass, realm.sharedGroupManager.getTransaction());
+                    mediator.createTable(modelClass, realm.sharedRealm);
                 }
-                columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedGroupManager.getTransaction()));
+                columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
             }
-            realm.schema.columnIndices = new ColumnIndices(columnInfoMap);
+            realm.schema.columnIndices = new ColumnIndices(
+                    (version == UNVERSIONED) ? realm.configuration.getSchemaVersion() : version,
+                    columnInfoMap);
 
             if (version == UNVERSIONED) {
                 final Transaction transaction = realm.getConfiguration().getInitialDataTransaction();
@@ -304,7 +292,7 @@ private static void initializeRealm(Realm realm) {
             }
         } finally {
             if (commitNeeded) {
-                realm.commitTransaction(false, null);
+                realm.commitTransaction(false);
             } else {
                 realm.cancelTransaction();
             }
@@ -314,13 +302,14 @@ private static void initializeRealm(Realm realm) {
     /**
      * Creates a Realm object for each object in a JSON array. This must be done within a transaction.
      * <p>
-     * JSON properties with {@code null} values will map to the default value for the data type in Realm and unknown properties
-     * will be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject}
-     * field will be set to the default value for that type.
+     * JSON properties with unknown properties will be ignored. If a {@link RealmObject} field is not present in the
+     * JSON object the {@link RealmObject} field will be set to the default value for that type.
      *
      * @param clazz type of Realm objects to create.
      * @param json an array where each JSONObject must map to the specified class.
      * @throws RealmException if mapping from JSON fails.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      */
     public <E extends RealmModel> void createAllFromJson(Class<E> clazz, JSONArray json) {
         if (clazz == null || json == null) {
@@ -345,8 +334,9 @@ private static void initializeRealm(Realm realm) {
      *
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param json array with object data.
-     * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     *         {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if trying to update a class without a {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      * @throws RealmException if unable to map JSON.
      * @see #createAllFromJson(Class, org.json.JSONArray)
      */
@@ -366,13 +356,14 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object for each object in a JSON array. This must be done within a transaction.
-     * JSON properties with {@code null} values will map to the default value for the data type in Realm and unknown properties
-     * will be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field
-     * will be set to the default value for that type.
+     * JSON properties with unknown properties will be ignored. If a {@link RealmObject} field is not present in the
+     * JSON object the {@link RealmObject} field will be set to the default value for that type.
      *
      * @param clazz type of Realm objects to create.
      * @param json the JSON array as a String where each object can map to the specified class.
      * @throws RealmException if mapping from JSON fails.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      */
     public <E extends RealmModel> void createAllFromJson(Class<E> clazz, String json) {
         if (clazz == null || json == null || json.length() == 0) {
@@ -398,9 +389,10 @@ private static void initializeRealm(Realm realm) {
      *
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param json string with an array of JSON objects.
-     * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     *         {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if trying to update a class without a {@link io.realm.annotations.PrimaryKey}.
      * @throws RealmException if unable to create a JSON array from the json string.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      * @see #createAllFromJson(Class, String)
      */
     public <E extends RealmModel> void createOrUpdateAllFromJson(Class<E> clazz, String json) {
@@ -421,13 +413,16 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object for each object in a JSON array. This must be done within a transaction.
-     * JSON properties with {@code null} value will map to the default value for the data type in Realm and unknown properties
-     * will be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field
-     * will be set to the default value for that type.
+     * JSON properties with unknown properties will be ignored. If a {@link RealmObject} field is not present in the
+     * JSON object the {@link RealmObject} field will be set to the default value for that type.
+     * <p>
+     * This API is only available in API level 11 or later.
      *
      * @param clazz type of Realm objects created.
      * @param inputStream the JSON array as a InputStream. All objects in the array must be of the specified class.
      * @throws RealmException if mapping from JSON fails.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      * @throws IOException if something was wrong with the input stream.
      */
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
@@ -454,11 +449,14 @@ private static void initializeRealm(Realm realm) {
      * If updating a {@link RealmObject} and a field is not found in the JSON object, that field will not be updated.
      * If a new {@link RealmObject} is created and a field is not found in the JSON object, that field will be assigned
      * the default value for the field type.
+     * <p>
+     * This API is only available in API level 11 or later.
      *
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param in the InputStream with a list of object data in JSON format.
-     * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     *         {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if trying to update a class without a {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      * @throws RealmException if unable to read JSON.
      * @see #createOrUpdateAllFromJson(Class, java.io.InputStream)
      */
@@ -489,14 +487,15 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object pre-filled with data from a JSON object. This must be done inside a transaction. JSON
-     * properties with {@code null} values will map to the default value for the data type in Realm and unknown properties will
-     * be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field will
-     * be set to the default value for that type.
+     * properties with unknown properties will be ignored. If a {@link RealmObject} field is not present in the JSON
+     * object the {@link RealmObject} field will be set to the default value for that type.
      *
      * @param clazz type of Realm object to create.
      * @param json the JSONObject with object data.
      * @return created object or {@code null} if no JSON data was provided.
      * @throws RealmException if the mapping from JSON fails.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      * @see #createOrUpdateObjectFromJson(Class, org.json.JSONObject)
      */
     public <E extends RealmModel> E createObjectFromJson(Class<E> clazz, JSONObject json) {
@@ -520,8 +519,9 @@ private static void initializeRealm(Realm realm) {
      * @param clazz Type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param json {@link org.json.JSONObject} with object data.
      * @return created or updated {@link io.realm.RealmObject}.
-     * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     *         {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if trying to update a class without a {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      * @throws RealmException if JSON data cannot be mapped.
      * @see #createObjectFromJson(Class, org.json.JSONObject)
      */
@@ -540,14 +540,15 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object pre-filled with data from a JSON object. This must be done inside a transaction. JSON
-     * properties with {@code null} values will map to the default value for the data type in Realm and unknown properties will
-     * be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field will
-     * be set to the default value for that type.
+     * properties with unknown properties will be ignored. If a {@link RealmObject} field is not present in the JSON
+     * object the {@link RealmObject} field will be set to the default value for that type.
      *
      * @param clazz type of Realm object to create.
      * @param json the JSON string with object data.
      * @return created object or {@code null} if JSON string was empty or null.
      * @throws RealmException if mapping to json failed.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      */
     public <E extends RealmModel> E createObjectFromJson(Class<E> clazz, String json) {
         if (clazz == null || json == null || json.length() == 0) {
@@ -574,8 +575,9 @@ private static void initializeRealm(Realm realm) {
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param json string with object data in JSON format.
      * @return created or updated {@link io.realm.RealmObject}.
-     * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     *         {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if trying to update a class without a {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      * @throws RealmException if JSON object cannot be mapped from the string parameter.
      * @see #createObjectFromJson(Class, String)
      */
@@ -597,14 +599,17 @@ private static void initializeRealm(Realm realm) {
 
     /**
      * Creates a Realm object pre-filled with data from a JSON object. This must be done inside a transaction. JSON
-     * properties with {@code null} value will map to the default value for the data type in Realm and unknown properties will
-     * be ignored. If a {@link RealmObject} field is not present in the JSON object the {@link RealmObject} field will
-     * be set to the default value for that type.
+     * properties with unknown properties will be ignored. If a {@link RealmObject} field is not present in the JSON
+     * object the {@link RealmObject} field will be set to the default value for that type.
+     * <p>
+     * This API is only available in API level 11 or later.
      *
      * @param clazz type of Realm object to create.
      * @param inputStream the JSON object data as a InputStream.
      * @return created object or {@code null} if JSON string was empty or null.
      * @throws RealmException if the mapping from JSON failed.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      * @throws IOException if something went wrong with the input stream.
      */
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
@@ -613,7 +618,7 @@ private static void initializeRealm(Realm realm) {
             return null;
         }
         E realmObject;
-        Table table = getTable(clazz);
+        Table table = schema.getTable(clazz);
         if (table.hasPrimaryKey()) {
             // As we need the primary key value we have to first parse the entire input stream as in the general
             // case that value might be the last property :(
@@ -647,12 +652,15 @@ private static void initializeRealm(Realm realm) {
      * {@link RealmObject} and a field is not found in the JSON object, that field will not be updated. If a new
      * {@link RealmObject} is created and a field is not found in the JSON object, that field will be assigned the
      * default value for the field type.
+     * <p>
+     * This API is only available in API level 11 or later.
      *
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param in the {@link InputStream} with object data in JSON format.
      * @return created or updated {@link io.realm.RealmObject}.
-     * @throws java.lang.IllegalArgumentException if trying to update a class without a
-     *         {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if trying to update a class without a {@link io.realm.annotations.PrimaryKey}.
+     * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
+     * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      * @throws RealmException if failure to read JSON.
      * @see #createObjectFromJson(Class, java.io.InputStream)
      */
@@ -685,16 +693,42 @@ private Scanner getFullStringScanner(InputStream in) {
 
     /**
      * Instantiates and adds a new object to the Realm.
+     * <p>
+     * This method is only available for model classes with no @PrimaryKey annotation.
+     * If you like to create an object that has a primary key, use {@link #createObject(Class, Object)}
+     * or {@link #copyToRealm(RealmModel)} instead.
      *
      * @param clazz the Class of the object to create.
      * @return the new object.
-     * @throws RealmException if an object cannot be created.
+     * @throws RealmException if the primary key is defined in the model class or an object cannot be created.
+     * @see #createObject(Class, Object)
      */
     public <E extends RealmModel> E createObject(Class<E> clazz) {
         checkIfValid();
-        Table table = getTable(clazz);
+        return createObjectInternal(clazz, true, Collections.<String> emptyList());
+    }
+
+    /**
+     * Same as {@link #createObject(Class)} but this does not check the thread.
+     *
+     * @param clazz the Class of the object to create.
+     * @param acceptDefaultValue if {@code true}, default value of the object will be applied and
+     *                           if {@code false}, it will be ignored.
+     * @return the new object.
+     * @throws RealmException if the primary key is defined in the model class or an object cannot be created.
+     */
+    // called from proxy classes
+    <E extends RealmModel> E createObjectInternal(Class<E> clazz,
+                                                            boolean acceptDefaultValue,
+                                                            List<String> excludeFields) {
+        Table table = schema.getTable(clazz);
+        // Check and throw the exception earlier for a better exception message.
+        if (table.hasPrimaryKey()) {
+            throw new RealmException(String.format("'%s' has a primary key, use" +
+                    " 'createObject(Class<E>, Object)' instead.", Table.tableNameToClassName(table.getName())));
+        }
         long rowIndex = table.addEmptyRow();
-        return get(clazz, rowIndex);
+        return get(clazz, rowIndex, acceptDefaultValue, excludeFields);
     }
 
     /**
@@ -702,19 +736,40 @@ private Scanner getFullStringScanner(InputStream in) {
      * <p>
      * If the value violates the primary key constraint, no object will be added and a {@link RealmException} will be
      * thrown.
+     * The default value for primary key provided by the model class will be ignored.
      *
      * @param clazz the Class of the object to create.
      * @param primaryKeyValue value for the primary key field.
      * @return the new object.
      * @throws RealmException if object could not be created due to the primary key being invalid.
-     * @throws IllegalStateException if the model clazz does not have an primary key defined.
+     * @throws IllegalStateException if the model class does not have an primary key defined.
      * @throws IllegalArgumentException if the {@code primaryKeyValue} doesn't have a value that can be converted to the
      *                                  expected value.
      */
     public <E extends RealmModel> E createObject(Class<E> clazz, Object primaryKeyValue) {
-        Table table = getTable(clazz);
+        checkIfValid();
+        return createObjectInternal(clazz, primaryKeyValue, true, Collections.<String> emptyList());
+    }
+
+    /**
+     * Same as {@link #createObject(Class, Object)} but this does not check the thread.
+     *
+     * @param clazz the Class of the object to create.
+     * @param primaryKeyValue value for the primary key field.
+     * @param acceptDefaultValue if {@code true}, default value of the object will be applied and
+     *                           if {@code false}, it will be ignored.
+     * @return the new object.
+     * @throws RealmException if object could not be created due to the primary key being invalid.
+     * @throws IllegalStateException if the model class does not have an primary key defined.
+     * @throws IllegalArgumentException if the {@code primaryKeyValue} doesn't have a value that can be converted to the
+     */
+    // called from proxy classes
+    <E extends RealmModel> E createObjectInternal(Class<E> clazz, Object primaryKeyValue,
+                                                            boolean acceptDefaultValue,
+                                                            List<String> excludeFields) {
+        Table table = schema.getTable(clazz);
         long rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
-        return get(clazz, rowIndex);
+        return get(clazz, rowIndex, acceptDefaultValue, excludeFields);
     }
 
     /**
@@ -732,7 +787,7 @@ private Scanner getFullStringScanner(InputStream in) {
      */
     public <E extends RealmModel> E copyToRealm(E object) {
         checkNotNullObject(object);
-        return copyOrUpdate(object, false);
+        return copyOrUpdate(object, false, new HashMap<RealmModel, RealmObjectProxy>());
     }
 
     /**
@@ -752,7 +807,7 @@ private Scanner getFullStringScanner(InputStream in) {
     public <E extends RealmModel> E copyToRealmOrUpdate(E object) {
         checkNotNullObject(object);
         checkHasPrimaryKey(object.getClass());
-        return copyOrUpdate(object, true);
+        return copyOrUpdate(object, true, new HashMap<RealmModel, RealmObjectProxy>());
     }
 
     /**
@@ -772,15 +827,153 @@ private Scanner getFullStringScanner(InputStream in) {
         if (objects == null) {
             return new ArrayList<E>();
         }
-
+        Map<RealmModel, RealmObjectProxy> cache = new HashMap<RealmModel, RealmObjectProxy>();
         ArrayList<E> realmObjects = new ArrayList<E>();
         for (E object : objects) {
-            realmObjects.add(copyToRealm(object));
+            checkNotNullObject(object);
+            realmObjects.add(copyOrUpdate(object, false, cache));
         }
 
         return realmObjects;
     }
 
+    /**
+     * Insert a list of an unmanaged RealmObjects. This is generally faster than {@link #copyToRealm(Iterable)} since it
+     * doesn't return the inserted elements, and performs minimum allocations and checks.
+     * After being inserted any changes to the original objects will not be persisted.
+     * <p>
+     * Please note:
+     * <ul>
+     * <li>
+     *     We don't check if the provided objects are already managed or not, so inserting a managed object might duplicate it.
+     *     Duplication will only happen if the object doesn't have a primary key. Objects with primary keys will never get duplicated.
+     * </li>
+     * <li>We don't create (nor return) a managed {@link RealmObject} for each element</li>
+     * <li>Copying an object will copy all field values. Any unset field in the object and child objects will be set to their default value if not provided</li>
+     * </ul>
+     * <p>
+     * If you want the managed {@link RealmObject} returned, use {@link #copyToRealm(Iterable)}, otherwise if
+     * you have a large number of object this method is generally faster.
+     *
+     * @param objects RealmObjects to insert.
+     * @throws IllegalStateException if the corresponding Realm is closed, called from an incorrect thread or not in a
+     * transaction.
+     * @see #copyToRealm(Iterable)
+     */
+    public void insert(Collection<? extends RealmModel> objects) {
+        checkIfValidAndInTransaction();
+        if (objects == null) {
+            throw new IllegalArgumentException("Null objects cannot be inserted into Realm.");
+        }
+        if (objects.isEmpty()) {
+            return;
+        }
+        configuration.getSchemaMediator().insert(this, objects);
+    }
+
+    /**
+     * Insert an unmanaged RealmObject. This is generally faster than {@link #copyToRealm(RealmModel)} since it
+     * doesn't return the inserted elements, and performs minimum allocations and checks.
+     * After being inserted any changes to the original object will not be persisted.
+     * <p>
+     * Please note:
+     * <ul>
+     * <li>
+     *     We don't check if the provided objects are already managed or not, so inserting a managed object might duplicate it.
+     *     Duplication will only happen if the object doesn't have a primary key. Objects with primary keys will never get duplicated.
+     * </li>
+     * <li>We don't create (nor return) a managed {@link RealmObject} for each element</li>
+     * <li>Copying an object will copy all field values. Any unset field in the object and child objects will be set to their default value if not provided</li>
+     * </ul>
+     * <p>
+     * If you want the managed {@link RealmObject} returned, use {@link #copyToRealm(RealmModel)}, otherwise if
+     * you have a large number of object this method is generally faster.
+     *
+     * @param object RealmObjects to insert.
+     * @throws IllegalStateException if the corresponding Realm is closed, called from an incorrect thread or not in a
+     * transaction.
+     * @throws io.realm.exceptions.RealmPrimaryKeyConstraintException if two objects with the same primary key is
+     * inserted or if a primary key value already exists in the Realm.
+     * @see #copyToRealm(RealmModel)
+     */
+    public void insert(RealmModel object) {
+        checkIfValidAndInTransaction();
+        if (object == null) {
+            throw new IllegalArgumentException("Null object cannot be inserted into Realm.");
+        }
+        Map<RealmModel, Long> cache = new IdentityHashMap<RealmModel, Long>();
+        configuration.getSchemaMediator().insert(this, object, cache);
+    }
+
+    /**
+     * Insert or update a list of unmanaged RealmObjects. This is generally faster than {@link #copyToRealmOrUpdate(Iterable)} since it
+     * doesn't return the inserted elements, and performs minimum allocations and checks.
+     * After being inserted any changes to the original objects will not be persisted.
+     * <p>
+     * Please note:
+     * <ul>
+     * <li>
+     *     We don't check if the provided objects are already managed or not, so inserting a managed object might duplicate it.
+     *     Duplication will only happen if the object doesn't have a primary key. Objects with primary keys will never get duplicated.
+     * </li>
+     * <li>We don't create (nor return) a managed {@link RealmObject} for each element</li>
+     * <li>Copying an object will copy all field values. Any unset field in the object and child objects will be set to their default value if not provided</li>
+     * </ul>
+     * <p>
+     * If you want the managed {@link RealmObject} returned, use {@link #copyToRealm(Iterable)}, otherwise if
+     * you have a large number of object this method is generally faster.
+     *
+     * @param objects RealmObjects to insert.
+     * @throws IllegalStateException if the corresponding Realm is closed, called from an incorrect thread or not in a
+     * transaction.
+     * @throws io.realm.exceptions.RealmPrimaryKeyConstraintException if two objects with the same primary key is
+     * inserted or if a primary key value already exists in the Realm.
+     *
+     * @see #copyToRealmOrUpdate(Iterable)
+     */
+    public void insertOrUpdate(Collection<? extends RealmModel> objects) {
+        checkIfValidAndInTransaction();
+        if (objects == null) {
+            throw new IllegalArgumentException("Null objects cannot be inserted into Realm.");
+        }
+        if (objects.isEmpty()) {
+            return;
+        }
+        configuration.getSchemaMediator().insertOrUpdate(this, objects);
+    }
+
+    /**
+     * Insert or update an unmanaged RealmObject. This is generally faster than {@link #copyToRealmOrUpdate(RealmModel)} since it
+     * doesn't return the inserted elements, and performs minimum allocations and checks.
+     * After being inserted any changes to the original object will not be persisted.
+     * <p>
+     * Please note:
+     * <ul>
+     * <li>
+     *     We don't check if the provided objects are already managed or not, so inserting a managed object might duplicate it.
+     *     Duplication will only happen if the object doesn't have a primary key. Objects with primary keys will never get duplicated.
+     * </li>
+     * <li>We don't create (nor return) a managed {@link RealmObject} for each element</li>
+     * <li>Copying an object will copy all field values. Any unset field in the object and child objects will be set to their default value if not provided</li>
+     * </ul>
+     * <p>
+     * If you want the managed {@link RealmObject} returned, use {@link #copyToRealm(RealmModel)}, otherwise if
+     * you have a large number of object this method is generally faster.
+     *
+     * @param object RealmObjects to insert.
+     * @throws IllegalStateException if the corresponding Realm is closed, called from an incorrect thread or not in a
+     * transaction.
+     * @see #copyToRealmOrUpdate(RealmModel)
+     */
+    public void insertOrUpdate(RealmModel object) {
+        checkIfValidAndInTransaction();
+        if (object == null) {
+            throw new IllegalArgumentException("Null object cannot be inserted into Realm.");
+        }
+        Map<RealmModel, Long> cache = new IdentityHashMap<RealmModel, Long>();
+        configuration.getSchemaMediator().insertOrUpdate(this, object, cache);
+    }
+
     /**
      * Updates a list of existing RealmObjects that is identified by their {@link io.realm.annotations.PrimaryKey} or
      * creates a new copy if no existing object could be found. This is a deep copy or update i.e., all referenced objects
@@ -799,9 +992,11 @@ private Scanner getFullStringScanner(InputStream in) {
             return new ArrayList<E>(0);
         }
 
+        Map<RealmModel, RealmObjectProxy> cache = new HashMap<RealmModel, RealmObjectProxy>();
         ArrayList<E> realmObjects = new ArrayList<E>();
         for (E object : objects) {
-            realmObjects.add(copyToRealmOrUpdate(object));
+            checkNotNullObject(object);
+            realmObjects.add(copyOrUpdate(object, true, cache));
         }
 
         return realmObjects;
@@ -937,7 +1132,7 @@ private Scanner getFullStringScanner(InputStream in) {
      *
      * @param listener the change listener.
      * @throws IllegalArgumentException if the change listener is {@code null}.
-     * @throws IllegalStateException if you try to register a listener from a non-Looper Thread.
+     * @throws IllegalStateException if you try to register a listener from a non-Looper or {@link IntentService} thread.
      * @see io.realm.RealmChangeListener
      * @see #removeChangeListener(RealmChangeListener)
      * @see #removeAllChangeListeners()
@@ -953,6 +1148,7 @@ public void addChangeListener(RealmChangeListener<Realm> listener) {
      *
      * @param transaction the {@link io.realm.Realm.Transaction} to execute.
      * @throws IllegalArgumentException if the {@code transaction} is {@code null}.
+     * @throws RealmMigrationNeededException if the latest version contains incompatible schema changes.
      */
     public void executeTransaction(Transaction transaction) {
         if (transaction == null) {
@@ -967,7 +1163,7 @@ public void executeTransaction(Transaction transaction) {
             if (isInTransaction()) {
                 cancelTransaction();
             } else {
-                RealmLog.w("Could not cancel transaction, not currently in a transaction.");
+                RealmLog.warn("Could not cancel transaction, not currently in a transaction.");
             }
             throw e;
         }
@@ -1038,16 +1234,16 @@ public RealmAsyncTask executeTransactionAsync(final Transaction transaction, fin
 
         // If the user provided a Callback then we make sure, the current Realm has a Handler
         // we can use to deliver the result
-        if ((onSuccess != null || onError != null)  && handler == null) {
+        if ((onSuccess != null || onError != null)  && !hasValidNotifier()) {
             throw new IllegalStateException("Your Realm is opened from a thread without a Looper" +
                     " and you provided a callback, we need a Handler to invoke your callback");
         }
 
-        // We need to use the same configuration to open a background SharedGroup (i.e Realm)
+        // We need to use the same configuration to open a background SharedRealm (i.e Realm)
         // to perform the transaction
         final RealmConfiguration realmConfiguration = getConfiguration();
 
-        final Future<?> pendingTransaction= asyncTaskExecutor.submit(new Runnable() {
+        final Future<?> pendingTransaction = asyncTaskExecutor.submitTransaction(new Runnable() {
             @Override
             public void run() {
                 if (Thread.currentThread().isInterrupted()) {
@@ -1062,15 +1258,11 @@ public void run() {
                     transaction.execute(bgRealm);
 
                     if (!Thread.currentThread().isInterrupted()) {
-                        bgRealm.commitTransaction(false, new Runnable() {
-                            @Override
-                            public void run() {
-                                // The bgRealm needs to be closed before post event to caller's handler to avoid
-                                // concurrency problem. eg.: User wants to delete Realm in the callbacks.
-                                // This will close Realm before sending REALM_CHANGED.
-                                bgRealm.close();
-                            }
-                        });
+                        // No need to send change notification to the work thread.
+                        bgRealm.commitTransaction(false);
+                        // The bgRealm needs to be closed before post event to caller's handler to avoid concurrency
+                        // problem. This is currently guaranteed by posting handleAsyncTransactionCompleted below.
+                        bgRealm.close();
                         transactionCommitted = true;
                     }
                 } catch (final Throwable e) {
@@ -1080,35 +1272,41 @@ public void run() {
                         if (bgRealm.isInTransaction()) {
                             bgRealm.cancelTransaction();
                         } else if (exception[0] != null) {
-                            RealmLog.w("Could not cancel transaction, not currently in a transaction.");
+                            RealmLog.warn("Could not cancel transaction, not currently in a transaction.");
                         }
                         bgRealm.close();
                     }
 
                     final Throwable backgroundException = exception[0];
                     // Send response as the final step to ensure the bg thread quit before others get the response!
-                    if (handler != null
-                            && !Thread.currentThread().isInterrupted()
-                            && handler.getLooper().getThread().isAlive()) {
-                        if (onSuccess != null && transactionCommitted) {
-                            handler.post(new Runnable() {
+                    if (hasValidNotifier() && !Thread.currentThread().isInterrupted()) {
+
+                        if (transactionCommitted) {
+                            // This will be treated like a special REALM_CHANGED event
+                            sharedRealm.realmNotifier.post(new Runnable() {
                                 @Override
                                 public void run() {
-                                    onSuccess.onSuccess();
+                                    handlerController.handleAsyncTransactionCompleted(onSuccess != null ? new Runnable() {
+                                        @Override
+                                        public void run() {
+                                            onSuccess.onSuccess();
+                                        }
+                                    } : null);
                                 }
                             });
                         }
 
+                        // Send errors directly to the looper, so they don't get intercepted by the HandlerController.
                         if (backgroundException != null) {
                             if (onError != null) {
-                                handler.post(new Runnable() {
+                                sharedRealm.realmNotifier.post(new Runnable() {
                                     @Override
                                     public void run() {
                                         onError.onError(backgroundException);
                                     }
                                 });
                             } else {
-                                handler.post(new Runnable() {
+                                sharedRealm.realmNotifier.post(new Runnable() {
                                     @Override
                                     public void run() {
                                         if (backgroundException instanceof RuntimeException) {
@@ -1122,6 +1320,7 @@ public void run() {
                                 });
                             }
                         }
+
                     } else {
                         // Throw exception in the worker thread if the caller thread terminated
                         if (backgroundException != null) {
@@ -1152,14 +1351,14 @@ public void run() {
      */
     public void delete(Class<? extends RealmModel> clazz) {
         checkIfValid();
-        getTable(clazz).clear();
+        schema.getTable(clazz).clear();
     }
 
 
     @SuppressWarnings("unchecked")
-    private <E extends RealmModel> E copyOrUpdate(E object, boolean update) {
+    private <E extends RealmModel> E copyOrUpdate(E object, boolean update, Map<RealmModel, RealmObjectProxy> cache) {
         checkIfValid();
-        return configuration.getSchemaMediator().copyOrUpdate(this, object, update, new HashMap<RealmModel, RealmObjectProxy>());
+        return configuration.getSchemaMediator().copyOrUpdate(this, object, update, cache);
     }
 
     private <E extends RealmModel> E createDetachedCopy(E object, int maxDepth, Map<RealmModel, RealmObjectProxy.CacheData<RealmModel>> cache) {
@@ -1174,7 +1373,7 @@ public void delete(Class<? extends RealmModel> clazz) {
     }
 
     private void checkHasPrimaryKey(Class<? extends RealmModel> clazz) {
-        if (!getTable(clazz).hasPrimaryKey()) {
+        if (!schema.getTable(clazz).hasPrimaryKey()) {
             throw new IllegalArgumentException("A RealmObject with no @PrimaryKey cannot be updated: " + clazz.toString());
         }
     }
@@ -1189,8 +1388,8 @@ private void checkMaxDepth(int maxDepth) {
         if (realmObject == null) {
             throw new IllegalArgumentException("Null objects cannot be copied from Realm.");
         }
-        if (!RealmObject.isValid(realmObject)) {
-            throw new IllegalArgumentException("RealmObject is not valid, so it cannot be copied.");
+        if (!(RealmObject.isManaged(realmObject) && RealmObject.isValid(realmObject))) {
+            throw new IllegalArgumentException("Only valid managed objects can be copied from Realm.");
         }
         if (realmObject instanceof DynamicRealmObject) {
             throw new IllegalArgumentException("DynamicRealmObject cannot be copied from Realm.");
@@ -1259,18 +1458,53 @@ static String getCanonicalPath(File realmFile) {
         try {
             return realmFile.getCanonicalPath();
         } catch (IOException e) {
-            throw new RealmIOException("Could not resolve the canonical path to the Realm file: " + realmFile.getAbsolutePath());
+            throw new RealmFileException(RealmFileException.Kind.ACCESS_ERROR,
+                    "Could not resolve the canonical path to the Realm file: " + realmFile.getAbsolutePath(),
+                    e);
         }
     }
 
     Table getTable(Class<? extends RealmModel> clazz) {
-        Table table = classToTable.get(clazz);
-        if (table == null) {
-            clazz = Util.getOriginalModelClass(clazz);
-            table = sharedGroupManager.getTable(configuration.getSchemaMediator().getTableName(clazz));
-            classToTable.put(clazz, table);
+        return schema.getTable(clazz);
+    }
+
+    /**
+     * Updates own schema cache.
+     *
+     * @param globalCacheArray global cache of column indices. If it contains an entry for current
+     *                         schema version, this method only copies the indices information in the entry.
+     * @return newly created indices information for current schema version. Or {@code null} if
+     *          {@code globalCacheArray} already contains the entry for current schema version.
+     */
+    ColumnIndices updateSchemaCache(ColumnIndices[] globalCacheArray) {
+        final long currentSchemaVersion = sharedRealm.getSchemaVersion();
+        final long cacheSchemaVersion = schema.columnIndices.getSchemaVersion();
+        if (currentSchemaVersion == cacheSchemaVersion) {
+            return null;
+        }
+
+        ColumnIndices createdGlobalCache = null;
+        final RealmProxyMediator mediator = getConfiguration().getSchemaMediator();
+        ColumnIndices cacheForCurrentVersion = RealmCache.findColumnIndices(globalCacheArray,
+                currentSchemaVersion);
+        if (cacheForCurrentVersion == null) {
+            // not found in global cache. create it.
+            final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
+            final Map<Class<? extends RealmModel>, ColumnInfo> map;
+            map = new HashMap<Class<? extends RealmModel>, ColumnInfo>(modelClasses.size());
+            try {
+                for (Class<? extends RealmModel> clazz : modelClasses) {
+                    final ColumnInfo columnInfo = mediator.validateTable(clazz, sharedRealm, true);
+                    map.put(clazz, columnInfo);
+                }
+            } catch (RealmMigrationNeededException e) {
+                throw e;
+            }
+
+            cacheForCurrentVersion = createdGlobalCache = new ColumnIndices(currentSchemaVersion, map);
         }
-        return table;
+        schema.columnIndices.copyFrom(cacheForCurrentVersion, mediator);
+        return createdGlobalCache;
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index 824f7fb7ed..dd7cd65632 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -24,9 +24,9 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import io.realm.exceptions.RealmIOException;
+import io.realm.exceptions.RealmFileException;
 import io.realm.internal.ColumnIndices;
-import io.realm.internal.log.RealmLog;
+import io.realm.log.RealmLog;
 
 /**
  * To cache {@link Realm}, {@link DynamicRealm} instances and related resources.
@@ -74,7 +74,8 @@ static RealmCacheType valueOf(Class<? extends BaseRealm> clazz) {
 
     // Column indices are cached to speed up opening typed Realm. If a Realm instance is created in one thread, creating
     // Realm instances in other threads doesn't have to initialize the column indices again.
-    private ColumnIndices typedColumnIndices;
+    private static final int MAX_ENTRIES_IN_TYPED_COLUMN_INDICES_ARRAY = 4;
+    private final ColumnIndices[] typedColumnIndicesArray = new ColumnIndices[MAX_ENTRIES_IN_TYPED_COLUMN_INDICES_ARRAY];
 
     // Realm path will be used as the key to store different RealmCaches. Different Realm configurations with same path
     // are not allowed and an exception will be thrown when trying to add it to the cache map.
@@ -123,7 +124,7 @@ private RealmCache(RealmConfiguration config) {
 
             if (realmClass == Realm.class) {
                 // RealmMigrationNeededException might be thrown here.
-                realm = Realm.createInstance(configuration, cache.typedColumnIndices);
+                realm = Realm.createInstance(configuration, cache.typedColumnIndicesArray);
             } else if (realmClass == DynamicRealm.class) {
                 realm = DynamicRealm.createInstance(configuration);
             } else {
@@ -143,7 +144,9 @@ private RealmCache(RealmConfiguration config) {
         Integer refCount = refAndCount.localCount.get();
         if (refCount == 0) {
             if (realmClass == Realm.class && refAndCount.globalCount == 0) {
-                cache.typedColumnIndices = refAndCount.localRealm.get().schema.columnIndices;
+                final BaseRealm realm = refAndCount.localRealm.get();
+                // store a copy of local ColumnIndices as a global cache.
+                RealmCache.storeColumnIndices(cache.typedColumnIndicesArray, realm.schema.columnIndices.clone());
             }
             // This is the first instance in current thread, increase the global count.
             refAndCount.globalCount++;
@@ -176,7 +179,7 @@ static synchronized void release(BaseRealm realm) {
         }
 
         if (refCount <= 0) {
-            RealmLog.w("Realm " + canonicalPath + " has been closed already.");
+            RealmLog.warn("%s has been closed already.", canonicalPath);
             return;
         }
 
@@ -200,7 +203,7 @@ static synchronized void release(BaseRealm realm) {
             // Clear the column indices cache if needed
             if (realm instanceof Realm && refAndCount.globalCount == 0) {
                 // All typed Realm instances of this file are cleared from cache
-                cache.typedColumnIndices = null;
+                Arrays.fill(cache.typedColumnIndicesArray, null);
             }
 
             int totalRefCount = 0;
@@ -274,8 +277,32 @@ static synchronized void invokeWithGlobalRefCount(RealmConfiguration configurati
         callback.onResult(totalRefCount);
     }
 
+    /**
+     * Updates the schema cache in the typed Realm for {@code pathOfRealm}.
+     *
+     * @param realm the instance that contains the schema cache to be updated.
+     */
+    static synchronized void updateSchemaCache(Realm realm) {
+        final RealmCache cache = cachesMap.get(realm.getPath());
+        if (cache == null) {
+            // Called during initialization. just skip it.
+            return;
+        }
+        final RefAndCount refAndCount = cache.refAndCountMap.get(RealmCacheType.TYPED_REALM);
+        if (refAndCount.localRealm.get() == null) {
+            // Called during initialization. just skip it.
+            // We can reach here if the DynamicRealm instance is initialized first.
+            return;
+        }
+        final ColumnIndices[] globalCacheArray = cache.typedColumnIndicesArray;
+        final ColumnIndices createdCacheEntry = realm.updateSchemaCache(globalCacheArray);
+        if (createdCacheEntry != null) {
+            RealmCache.storeColumnIndices(globalCacheArray, createdCacheEntry);
+        }
+    }
+
    /**
-     * Runs the callback function with synchronization on {@class RealmCache}.
+     * Runs the callback function with synchronization on {@link RealmCache}.
      *
      * @param callback the callback will be executed.
      */
@@ -288,11 +315,12 @@ static synchronized void invokeWithLock(Callback0 callback) {
      * Copy is performed only at the first time when there is no Realm database file.
      *
      * @param configuration configuration object for Realm instance.
-     * @throws IOException if copying the file fails.
+     * @throws RealmFileException if copying the file fails.
      */
     private static void copyAssetFileIfNeeded(RealmConfiguration configuration) {
+        IOException exceptionWhenClose = null;
         if (configuration.hasAssetFile()) {
-            File realmFile = new File(configuration.getRealmFolder(), configuration.getRealmFileName());
+            File realmFile = new File(configuration.getRealmDirectory(), configuration.getRealmFileName());
             if (realmFile.exists()) {
                 return;
             }
@@ -302,7 +330,8 @@ private static void copyAssetFileIfNeeded(RealmConfiguration configuration) {
             try {
                 inputStream = configuration.getAssetFile();
                 if (inputStream == null) {
-                    throw new RealmIOException("Invalid input stream to asset file.");
+                    throw new RealmFileException(RealmFileException.Kind.ACCESS_ERROR,
+                            "Invalid input stream to asset file.");
                 }
 
                 outputStream = new FileOutputStream(realmFile);
@@ -312,23 +341,79 @@ private static void copyAssetFileIfNeeded(RealmConfiguration configuration) {
                     outputStream.write(buf, 0, bytesRead);
                 }
             } catch (IOException e) {
-                throw new RealmIOException("Could not resolve the path to the Realm asset file.", e);
+                throw new RealmFileException(RealmFileException.Kind.ACCESS_ERROR,
+                        "Could not resolve the path to the Realm asset file.", e);
             } finally {
                 if (inputStream != null) {
                     try {
                         inputStream.close();
                     } catch (IOException e) {
-                        // Ignore this exception because any significant errors should already have been handled
+                        exceptionWhenClose = e;
                     }
                 }
                 if (outputStream != null) {
                     try {
                         outputStream.close();
                     } catch (IOException e) {
-                        throw new RealmIOException("Invalid output stream to " + realmFile.getPath(), e);
+                        // Ignore this one if there was an exception when close inputStream.
+                        if (exceptionWhenClose == null) {
+                            exceptionWhenClose = e;
+                        }
                     }
                 }
             }
+
+            // No other exception has been thrown, only the exception when close. So, throw it.
+            if (exceptionWhenClose != null) {
+                throw new RealmFileException(RealmFileException.Kind.ACCESS_ERROR, exceptionWhenClose);
+            }
+        }
+    }
+
+    /**
+     * Finds an entry for specified schema version in the array.
+     *
+     * @param array target array of schema cache.
+     * @param schemaVersion requested version of the schema.
+     * @return {@link ColumnIndices} instance for specified schema version. {@code null} if not found.
+     */
+    public static ColumnIndices findColumnIndices(ColumnIndices[] array, long schemaVersion) {
+        for (int i = array.length - 1; 0 <= i; i--) {
+            final ColumnIndices candidate = array[i];
+            if (candidate != null && candidate.getSchemaVersion() == schemaVersion) {
+                return candidate;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Stores the schema cache to the array.
+     * <p>
+     * If the {@code array} has an empty slot ({@code == null}), this method stores
+     * the {@code columnIndices} to it. Otherwise, the entry of the oldest schema version is
+     * replaced.
+     *
+     * @param array target array.
+     * @param columnIndices the item to be stored into the {@code array}.
+     * @return the index in the {@code array} where the {@code columnIndices} was stored.
+     */
+    private static int storeColumnIndices(ColumnIndices[] array, ColumnIndices columnIndices) {
+        long oldestSchemaVersion = Long.MAX_VALUE;
+        int candidateIndex = -1;
+        for (int i = array.length - 1; 0 <= i; i--) {
+            if (array[i] == null) {
+                array[i] = columnIndices;
+                return i;
+            }
+
+            ColumnIndices target = array[i];
+            if (target.getSchemaVersion() <= oldestSchemaVersion) {
+                oldestSchemaVersion = target.getSchemaVersion();
+                candidateIndex = i;
+            }
         }
+        array[candidateIndex] = columnIndices;
+        return candidateIndex;
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCollection.java b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
index 6278272dc2..722d1253d3 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCollection.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
@@ -139,13 +139,28 @@
     boolean load();
 
     /**
-     * Checks if the collection is still valid to use e.g. the {@link io.realm.Realm} instance hasn't
-     * been closed.
+     * Checks if the collection is still valid to use, i.e., the {@link io.realm.Realm} instance hasn't been closed. It
+     * will always return {@code true} for an unmanaged collection.
      *
-     * @return {@code true} if still valid to use, {@code false} otherwise.
+     * @return {@code true} if it is still valid to use or an unmanaged collection, {@code false} otherwise.
      */
     boolean isValid();
 
+    /**
+     * Checks if the collection is managed by Realm. A managed collection is just a wrapper around the data in the
+     * underlying Realm file. On Looper threads, a managed collection will be live-updated so it always points to the
+     * latest data. Managed collections are thread confined so that they cannot be accessed from other threads than the
+     * one that created them.
+     * <p>
+     *
+     * If this method returns {@code false}, the collection is unmanaged. An unmanaged collection is just a normal java
+     * collection, so it will not be live updated.
+     * <p>
+     *
+     * @return {@code true} if this is a managed {@link RealmCollection}, {@code false} otherwise.
+     */
+    boolean isManaged();
+
     /**
      * Tests whether this {@code Collection} contains the specified object. Returns
      * {@code true} if and only if at least one element {@code elem} in this
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index a398f90992..2be71eb4ad 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -30,11 +30,12 @@
 import java.util.HashSet;
 import java.util.Set;
 
+import io.realm.annotations.PrimaryKey;
 import io.realm.annotations.RealmModule;
 import io.realm.exceptions.RealmException;
 import io.realm.internal.RealmCore;
 import io.realm.internal.RealmProxyMediator;
-import io.realm.internal.SharedGroup;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.modules.CompositeMediator;
 import io.realm.internal.modules.FilterableMediator;
 import io.realm.rx.RealmObservableFactory;
@@ -84,7 +85,7 @@
         }
     }
 
-    private final File realmFolder;
+    private final File realmDirectory;
     private final String realmFileName;
     private final String canonicalPath;
     private final String assetFilePath;
@@ -92,16 +93,16 @@
     private final long schemaVersion;
     private final RealmMigration migration;
     private final boolean deleteRealmIfMigrationNeeded;
-    private final SharedGroup.Durability durability;
+    private final SharedRealm.Durability durability;
     private final RealmProxyMediator schemaMediator;
     private final RxObservableFactory rxObservableFactory;
     private final Realm.Transaction initialDataTransaction;
     private final WeakReference<Context> contextWeakRef;
 
     private RealmConfiguration(Builder builder) {
-        this.realmFolder = builder.folder;
+        this.realmDirectory = builder.directory;
         this.realmFileName = builder.fileName;
-        this.canonicalPath = Realm.getCanonicalPath(new File(realmFolder, realmFileName));
+        this.canonicalPath = Realm.getCanonicalPath(new File(realmDirectory, realmFileName));
         this.assetFilePath = builder.assetFilePath;
         this.key = builder.key;
         this.schemaVersion = builder.schemaVersion;
@@ -114,8 +115,8 @@ private RealmConfiguration(Builder builder) {
         this.contextWeakRef = builder.contextWeakRef;
     }
 
-    public File getRealmFolder() {
-        return realmFolder;
+    public File getRealmDirectory() {
+        return realmDirectory;
     }
 
     public String getRealmFileName() {
@@ -138,7 +139,7 @@ public boolean shouldDeleteRealmIfMigrationNeeded() {
         return deleteRealmIfMigrationNeeded;
     }
 
-    public SharedGroup.Durability getDurability() {
+    public SharedRealm.Durability getDurability() {
         return durability;
     }
 
@@ -222,7 +223,7 @@ public boolean equals(Object obj) {
 
         if (schemaVersion != that.schemaVersion) return false;
         if (deleteRealmIfMigrationNeeded != that.deleteRealmIfMigrationNeeded) return false;
-        if (!realmFolder.equals(that.realmFolder)) return false;
+        if (!realmDirectory.equals(that.realmDirectory)) return false;
         if (!realmFileName.equals(that.realmFileName)) return false;
         if (!canonicalPath.equals(that.canonicalPath)) return false;
         if (!Arrays.equals(key, that.key)) return false;
@@ -236,7 +237,7 @@ public boolean equals(Object obj) {
 
     @Override
     public int hashCode() {
-        int result = realmFolder.hashCode();
+        int result = realmDirectory.hashCode();
         result = 31 * result + realmFileName.hashCode();
         result = 31 * result + canonicalPath.hashCode();
         result = 31 * result + (key != null ? Arrays.hashCode(key) : 0);
@@ -304,7 +305,7 @@ private static RealmProxyMediator getModuleMediator(String fullyQualifiedModuleC
     public String toString() {
         //noinspection StringBufferReplaceableByString
         StringBuilder stringBuilder = new StringBuilder();
-        stringBuilder.append("realmFolder: ").append(realmFolder.toString());
+        stringBuilder.append("realmDirectory: ").append(realmDirectory.toString());
         stringBuilder.append("\n");
         stringBuilder.append("realmFileName : ").append(realmFileName);
         stringBuilder.append("\n");
@@ -346,32 +347,20 @@ private static synchronized boolean isRxJavaAvailable() {
      * RealmConfiguration.Builder used to construct instances of a RealmConfiguration in a fluent manner.
      */
     public static final class Builder {
-        private File folder;
+        private File directory;
         private String fileName;
         private String assetFilePath;
         private byte[] key;
         private long schemaVersion;
         private RealmMigration migration;
         private boolean deleteRealmIfMigrationNeeded;
-        private SharedGroup.Durability durability;
+        private SharedRealm.Durability durability;
         private HashSet<Object> modules = new HashSet<Object>();
         private HashSet<Class<? extends RealmModel>> debugSchema = new HashSet<Class<? extends RealmModel>>();
         private WeakReference<Context> contextWeakRef;
         private RxObservableFactory rxFactory;
         private Realm.Transaction initialDataTransaction;
 
-        /**
-         * Creates an instance of the Builder for the RealmConfiguration.
-         * The Realm file will be saved in the provided folder.
-         *
-         * @param folder the folder to save Realm file in. Folder must be writable.
-         * @throws IllegalArgumentException if folder doesn't exist or isn't writable.
-         */
-        public Builder(File folder) {
-            RealmCore.loadLibrary();
-            initializeBuilder(folder);
-        }
-
         /**
          * Creates an instance of the Builder for the RealmConfiguration.
          * <p>
@@ -379,40 +368,33 @@ public Builder(File folder) {
          * additional permissions. The default location is {@code /data/data/<packagename>/files}, but can
          * change depending on vendor implementations of Android.
          *
-         * @param context an Android context.
+         * @param context the Android application context.
          */
         public Builder(Context context) {
             if (context == null) {
                 throw new IllegalArgumentException("A non-null Context must be provided");
             }
             RealmCore.loadLibrary(context);
-            initializeBuilder(context.getFilesDir());
+            initializeBuilder(context);
         }
 
         // Setup builder in its initial state
-        private void initializeBuilder(File folder) {
-            if (folder == null || !folder.isDirectory()) {
-                throw new IllegalArgumentException(("An existing folder must be provided. " +
-                        "Yours was " + (folder != null ? folder.getAbsolutePath() : "null")));
-            }
-            if (!folder.canWrite()) {
-                throw new IllegalArgumentException("Folder is not writable: " + folder.getAbsolutePath());
-            }
-
-            this.folder = folder;
+        private void initializeBuilder(Context context) {
+            this.contextWeakRef = new WeakReference<Context>(context);
+            this.directory = context.getFilesDir();
             this.fileName = Realm.DEFAULT_REALM_NAME;
             this.key = null;
             this.schemaVersion = 0;
             this.migration = null;
             this.deleteRealmIfMigrationNeeded = false;
-            this.durability = SharedGroup.Durability.FULL;
+            this.durability = SharedRealm.Durability.FULL;
             if (DEFAULT_MODULE != null) {
                 this.modules.add(DEFAULT_MODULE);
             }
         }
 
         /**
-         * Sets the filename for the Realm.
+         * Sets the filename for the Realm file.
          */
         public Builder name(String filename) {
             if (filename == null || filename.isEmpty()) {
@@ -423,8 +405,33 @@ public Builder name(String filename) {
             return this;
         }
 
+        /**
+         * Specify the directory where the Realm file will be saved. The default value is {@code context.getFiles()}.
+         * If the directory does not exist, it will be created.
+         *
+         * @param directory the directory to save the Realm file in. Directory must be writable.
+         * @throws IllegalArgumentException if {@code directory} is null, not writable or a file.
+         */
+        public Builder directory(File directory) {
+            if (directory == null) {
+                throw new IllegalArgumentException("Non-null 'dir' required.");
+            }
+            if (directory.isFile()) {
+                throw new IllegalArgumentException("'dir' is a file, not a directory: " + directory.getAbsolutePath() + ".");
+            }
+            if (!directory.exists() && !directory.mkdirs()) {
+                throw new IllegalArgumentException("Could not create the specified directory: " + directory.getAbsolutePath() + ".");
+            }
+            if (!directory.canWrite()) {
+                throw new IllegalArgumentException("Realm directory is not writable: " + directory.getAbsolutePath() + ".");
+            }
+            this.directory = directory;
+            return this;
+        }
+
         /**
          * Sets the 64 bit key used to encrypt and decrypt the Realm file.
+         * Sets the {@value io.realm.RealmConfiguration#KEY_LENGTH} bytes key used to encrypt and decrypt the Realm file.
          */
         public Builder encryptionKey(byte[] key) {
             if (key == null) {
@@ -473,9 +480,18 @@ public Builder migration(RealmMigration migration) {
          * {@link io.realm.exceptions.RealmMigrationNeededException} the on-disc Realm will be cleared and recreated
          * with the new Realm schema.
          *
-         * <b>WARNING!</b> This will result in loss of data.
+         * <p>This cannot be configured to have an asset file at the same time by calling
+         * {@link #assetFile(String)} as the provided asset file will be deleted in migrations.
+         *
+         * <p><b>WARNING!</b> This will result in loss of data.
+         *
+         * @throws IllegalStateException if configured to use an asset file by calling {@link #assetFile(String)} previously.
          */
         public Builder deleteRealmIfMigrationNeeded() {
+            if (this.assetFilePath != null && this.assetFilePath.length() != 0) {
+                throw new IllegalStateException("Realm cannot clear its schema when previously configured to use an asset file by calling assetFile().");
+            }
+
             this.deleteRealmIfMigrationNeeded = true;
             return this;
         }
@@ -493,7 +509,7 @@ public Builder inMemory() {
                 throw new RealmException("Realm can not use in-memory configuration if asset file is present.");
             }
 
-            this.durability = SharedGroup.Durability.MEM_ONLY;
+            this.durability = SharedRealm.Durability.MEM_ONLY;
 
             return this;
         }
@@ -551,25 +567,28 @@ public Builder initialData(Realm.Transaction transaction) {
          * Copies the Realm file from the given asset file path.
          * <p>
          * When opening the Realm for the first time, instead of creating an empty file,
-         * the Realm file will be copied from the provided assets file and used instead.
+         * the Realm file will be copied from the provided asset file and used instead.
+         *
+         * <p>This cannot be configured to clear and recreate schema by calling {@link #deleteRealmIfMigrationNeeded()}
+         * at the same time as doing so will delete the copied asset schema.
+         *
          * <p>
          * WARNING: This could potentially be a lengthy operation and should ideally be done on a background thread.
          *
-         * @param context Android application context.
          * @param assetFile path to the asset database file.
+         * @throws IllegalStateException if this is configured to clear its schema by calling {@link #deleteRealmIfMigrationNeeded()}.
          */
-        public Builder assetFile(Context context, final String assetFile) {
-            if (context == null) {
-                throw new IllegalArgumentException("A non-null Context must be provided");
-            }
+        public Builder assetFile(final String assetFile) {
             if (TextUtils.isEmpty(assetFile)) {
                 throw new IllegalArgumentException("A non-empty asset file path must be provided");
             }
-            if (durability == SharedGroup.Durability.MEM_ONLY) {
+            if (durability == SharedRealm.Durability.MEM_ONLY) {
                 throw new RealmException("Realm can not use in-memory configuration if asset file is present.");
             }
+            if (this.deleteRealmIfMigrationNeeded) {
+                throw new IllegalStateException("Realm cannot use an asset file when previously configured to clear its schema in migration by calling deleteRealmIfMigrationNeeded().");
+            }
 
-            this.contextWeakRef = new WeakReference<>(context);
             this.assetFilePath = assetFile;
 
             return this;
diff --git a/realm/realm-library/src/main/java/io/realm/RealmFieldType.java b/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
index 7bff1ed043..df514821ef 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
@@ -19,7 +19,6 @@
 import java.nio.ByteBuffer;
 
 import io.realm.internal.Keep;
-import io.realm.internal.Mixed;
 
 /**
  * List of the types used by Realm's underlying storage engine.
@@ -82,14 +81,6 @@ public boolean isValid(Object obj) {
             case 2: return (obj instanceof String);
             case 4: return (obj instanceof byte[] || obj instanceof ByteBuffer);
             case 5: return (obj == null || obj instanceof Object[][]);
-            case 6: return (obj instanceof Mixed ||
-                    obj instanceof Long || obj instanceof Integer ||
-                    obj instanceof Short || obj instanceof Byte || obj instanceof Boolean ||
-                    obj instanceof Float || obj instanceof Double ||
-                    obj instanceof String ||
-                    obj instanceof byte[] || obj instanceof ByteBuffer ||
-                    obj == null || obj instanceof Object[][] ||
-                    obj instanceof java.util.Date);
             case 7: return (obj instanceof java.util.Date); // the unused DateTime
             case 8: return (obj instanceof java.util.Date);
             case 9: return (obj instanceof Float);
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index ee9e96291a..9ba427a4c4 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -33,13 +33,13 @@
 
 /**
  * RealmList is used to model one-to-many relationships in a {@link io.realm.RealmObject}.
- * RealmList has two modes: A managed and non-managed mode. In managed mode all objects are persisted inside a Realm, in
- * non-managed mode it works as a normal ArrayList.
+ * RealmList has two modes: A managed and unmanaged mode. In managed mode all objects are persisted inside a Realm, in
+ * unmanaged mode it works as a normal ArrayList.
  * <p>
  * Only Realm can create managed RealmLists. Managed RealmLists will automatically update the content whenever the
  * underlying Realm is updated, and can only be accessed using the getter of a {@link io.realm.RealmObject}.
  * <p>
- * Unmanaged RealmLists can be created by the user and can contain both managed and non-managed RealmObjects. This is
+ * Unmanaged RealmLists can be created by the user and can contain both managed and unmanaged RealmObjects. This is
  * useful when dealing with JSON deserializers like GSON or other frameworks that inject values into a class.
  * Unmanaged elements in this list can be added to a Realm using the {@link Realm#copyToRealm(Iterable)} method.
  * <p>
@@ -63,7 +63,7 @@
     private List<E> unmanagedList;
 
     /**
-     * Creates a RealmList in non-managed mode, where the elements are not controlled by a Realm.
+     * Creates a RealmList in unmanaged mode, where the elements are not controlled by a Realm.
      * This effectively makes the RealmList function as a {@link java.util.ArrayList} and it is not possible to query
      * the objects in this state.
      * <p>
@@ -75,11 +75,11 @@ public RealmList() {
     }
 
     /**
-     * Creates a RealmList in non-managed mode with an initial list of elements.
-     * A RealmList in non-managed mode function as a {@link java.util.ArrayList} and it is not possible to query the
+     * Creates a RealmList in unmanaged mode with an initial list of elements.
+     * A RealmList in unmanaged mode function as a {@link java.util.ArrayList} and it is not possible to query the
      * objects in this state.
      * <p>
-     * Use {@link io.realm.Realm#copyToRealm(Iterable)} to properly persist all non-managed elements in Realm.
+     * Use {@link io.realm.Realm#copyToRealm(Iterable)} to properly persist all unmanaged elements in Realm.
      *
      * @param objects initial objects in the list.
      */
@@ -114,19 +114,26 @@ public RealmList(E... objects) {
     }
 
     /**
-     * Checks if the {@link RealmList} is managed by Realm and contains valid data i.e., the {@link io.realm.Realm}
-     * instance hasn't been closed.
-     *
-     * @return {@code true} if still valid to use, {@code false} otherwise or if it's an unmanaged list.
+     * {@inheritDoc}
      */
     public boolean isValid() {
+        if (realm == null) {
+            return true;
+        }
         //noinspection SimplifiableIfStatement
-        if (realm == null || realm.isClosed()) {
+        if (realm.isClosed()) {
             return false;
         }
         return isAttached();
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    public boolean isManaged() {
+        return realm != null;
+    }
+
     private boolean isAttached() {
         return view != null && view.isAttached();
     }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObject.java b/realm/realm-library/src/main/java/io/realm/RealmObject.java
index 8a91e74e77..ed03ec6e4b 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObject.java
@@ -16,6 +16,8 @@
 
 package io.realm;
 
+import android.app.IntentService;
+
 import java.util.List;
 
 import io.realm.annotations.RealmClass;
@@ -112,7 +114,7 @@ public final void deleteFromRealm() {
 
     /**
      * Checks if the RealmObject is still valid to use i.e., the RealmObject hasn't been deleted nor has the
-     * {@link io.realm.Realm} been closed. It will always return {@code false} for unmanaged objects.
+     * {@link io.realm.Realm} been closed. It will always return {@code true} for unmanaged objects.
      * <p>
      * Note that this can be used to check the validity of certain conditions such as being {@code null}
      * when observed.
@@ -124,7 +126,7 @@ public final void deleteFromRealm() {
      * }
      * </pre>
      *
-     * @return {@code true} if the object is still accessible, {@code false} otherwise or if it is an unmanaged object.
+     * @return {@code true} if the object is still accessible or an unmanaged object, {@code false} otherwise.
      * @see <a href="https://github.com/realm/realm-java/tree/master/examples/rxJavaExample">Examples using Realm with RxJava</a>
      */
     public final boolean isValid() {
@@ -133,10 +135,10 @@ public final boolean isValid() {
 
     /**
      * Checks if the RealmObject is still valid to use i.e., the RealmObject hasn't been deleted nor has the
-     * {@link io.realm.Realm} been closed. It will always return {@code false} for unmanaged objects.
+     * {@link io.realm.Realm} been closed. It will always return {@code true} for unmanaged objects.
      *
      * @param object RealmObject to check validity for.
-     * @return {@code true} if the object is still accessible, {@code false} otherwise or if it is an unmanaged object.
+     * @return {@code true} if the object is still accessible or an unmanaged object, {@code false} otherwise.
      */
     public static <E extends RealmModel> boolean isValid(E object) {
         if (object instanceof RealmObjectProxy) {
@@ -144,30 +146,90 @@ public final boolean isValid() {
             Row row = proxy.realmGet$proxyState().getRow$realm();
             return row != null && row.isAttached();
         } else {
-            return false;
+            return true;
         }
     }
 
     /**
-     * Determines if the current RealmObject is obtained synchronously or asynchronously (from a worker thread).
+     * Checks if the query used to find this RealmObject has completed.
+     *
+     * Async methods like {@link RealmQuery#findFirstAsync()} return an {@link RealmObject} that represents the future result
+     * of the {@link RealmQuery}. It can be considered similar to a {@link java.util.concurrent.Future} in this regard.
+     *
+     * Once {@code isLoaded()} returns {@code true}, the object represents the query result even if the query
+     * didn't find any object matching the query parameters. In this case the {@link RealmObject} will
+     * become a "null" object.
+     *
+     * "Null" objects represents {@code null}.  An exception is throw if any accessor is called, so it is important to also
+     * check {@link #isValid()} before calling any methods. A common pattern is:
+     *
+     * <pre>
+     * {@code
+     * Person person = realm.where(Person.class).findFirstAsync();
+     * person.isLoaded(); // == false
+     * person.addChangeListener(new RealmChangeListener() {
+     *      \@Override
+     *      public void onChange(Person person) {
+     *          person.isLoaded(); // Always true here
+     *          if (person.isValid()) {
+     *              // It is safe to access the person.
+     *          }
+     *      }
+     * });
+     * }
+     * </pre>
+     *
      * Synchronous RealmObjects are by definition blocking hence this method will always return {@code true} for them.
-     * This will return {@code true} if called for an unmanaged object (created outside of Realm).
+     * This method will return {@code true} if called on an unmanaged object (created outside of Realm).
      *
-     * @return {@code true} if the query has completed and the data is available {@code false} if the query is in
+     * @return {@code true} if the query has completed, {@code false} if the query is in
      * progress.
+     *
+     * @see #isValid()
      */
     public final boolean isLoaded() {
         return RealmObject.isLoaded(this);
     }
 
+
     /**
-     * Determines if the RealmObject is obtained synchronously or asynchronously (from a worker thread).
+     * Checks if the query used to find this RealmObject has completed.
+     *
+     * Async methods like {@link RealmQuery#findFirstAsync()} return an {@link RealmObject} that represents the future result
+     * of the {@link RealmQuery}. It can be considered similar to a {@link java.util.concurrent.Future} in this regard.
+     *
+     * Once {@code isLoaded()} returns {@code true}, the object represents the query result even if the query
+     * didn't find any object matching the query parameters. In this case the {@link RealmObject} will
+     * become a "null" object.
+     *
+     * "Null" objects represents {@code null}.  An exception is throw if any accessor is called, so it is important to also
+     * check {@link #isValid()} before calling any methods. A common pattern is:
+     *
+     * <pre>
+     * {@code
+     * Person person = realm.where(Person.class).findFirstAsync();
+     * RealmObject.isLoaded(person); // == false
+     * RealmObject.addChangeListener(person, new RealmChangeListener() {
+     *      \@Override
+     *      public void onChange(Person person) {
+     *          RealmObject.isLoaded(person); // always true here
+     *          if (RealmObject.isValid(person)) {
+     *              // It is safe to access the person.
+     *          }
+     *      }
+     * });
+     * }
+     * </pre>
+     *
      * Synchronous RealmObjects are by definition blocking hence this method will always return {@code true} for them.
-     * This will return {@code true} if called for an unmanaged object (created outside of Realm).
+     * This method will return {@code true} if called on an unmanaged object (created outside of Realm).
+     *
      *
      * @param object RealmObject to check.
-     * @return {@code true} if the query has completed and the data is available {@code false} if the query is in
+     * @return {@code true} if the query has completed, {@code false} if the query is in
      * progress.
+     *
+     * @see #isValid(RealmModel)
      */
     public static <E extends RealmModel> boolean isLoaded(E object) {
         if (object instanceof RealmObjectProxy) {
@@ -179,6 +241,52 @@ public final boolean isLoaded() {
         }
     }
 
+    /**
+     * Checks if this object is managed by Realm. A managed object is just a wrapper around the data in the underlying
+     * Realm file. On Looper threads, a managed object will be live-updated so it always points to the latest data. It
+     * is possible to register a change listener using {@link #addChangeListener(RealmChangeListener)} to be notified
+     * when changes happen. Managed objects are thread confined so that they cannot be accessed from other threads than
+     * the one that created them.
+     * <p>
+     *
+     * If this method returns {@code false}, the object is unmanaged. An unmanaged object is just a normal Java object,
+     * so it can be parsed freely across threads, but the data in the object is not connected to the underlying Realm,
+     * so it will not be live updated.
+     * <p>
+     *
+     * It is possible to create a managed object from an unmanaged object by using
+     * {@link Realm#copyToRealm(RealmModel)}. An unmanaged object can be created from a managed object by using
+     * {@link Realm#copyFromRealm(RealmModel)}.
+     *
+     * @return {@code true} if the object is managed, {@code false} if it is unmanaged.
+     */
+    public boolean isManaged() {
+        return isManaged(this);
+    }
+
+    /**
+     * Checks if this object is managed by Realm. A managed object is just a wrapper around the data in the underlying
+     * Realm file. On Looper threads, a managed object will be live-updated so it always points to the latest data. It
+     * is possible to register a change listener using {@link #addChangeListener(RealmModel, RealmChangeListener)} to be
+     * notified when changes happen. Managed objects are thread confined so that they cannot be accessed from other threads
+     * than the one that created them.
+     * <p>
+     *
+     * If this method returns {@code false}, the object is unmanaged. An unmanaged object is just a normal Java object,
+     * so it can be parsed freely across threads, but the data in the object is not connected to the underlying Realm,
+     * so it will not be live updated.
+     * <p>
+     *
+     * It is possible to create a managed object from an unmanaged object by using
+     * {@link Realm#copyToRealm(RealmModel)}. An unmanaged object can be created from a managed object by using
+     * {@link Realm#copyFromRealm(RealmModel)}.
+     *
+     * @return {@code true} if the object is managed, {@code false} if it is unmanaged.
+     */
+    public static <E extends RealmModel> boolean isManaged(E object) {
+        return object instanceof RealmObjectProxy;
+    }
+
     /**
      * Makes an asynchronous query blocking. This will also trigger any registered listeners.
      * <p>
@@ -218,6 +326,7 @@ public final boolean load() {
      * @param listener the change listener to be notified.
      * @throws IllegalArgumentException if the change listener is {@code null} or the object is an unmanaged object.
      * @throws IllegalArgumentException if object is an unmanaged RealmObject.
+     * @throws IllegalStateException if you try to add a listener from a non-Looper or {@link IntentService} thread.
      */
     public final <E extends RealmModel> void addChangeListener(RealmChangeListener<E> listener) {
         RealmObject.addChangeListener((E) this, listener);
@@ -230,7 +339,7 @@ public final boolean load() {
      * @param listener the change listener to be notified.
      * @throws IllegalArgumentException if the {@code object} or the change listener is {@code null}.
      * @throws IllegalArgumentException if object is an unmanaged RealmObject.
-     * @throws IllegalStateException if you try to add a listener from a non-Looper Thread.
+     * @throws IllegalStateException if you try to add a listener from a non-Looper or {@link IntentService} thread.
      */
     public static <E extends RealmModel> void addChangeListener(E object, RealmChangeListener<E> listener) {
         if (object == null) {
@@ -243,8 +352,8 @@ public final boolean load() {
             RealmObjectProxy proxy = (RealmObjectProxy) object;
             BaseRealm realm = proxy.realmGet$proxyState().getRealm$realm();
             realm.checkIfValid();
-            if (realm.handler == null) {
-                throw new IllegalStateException("You can't register a listener from a non-Looper thread ");
+            if (!realm.handlerController.isAutoRefreshEnabled()) {
+                throw new IllegalStateException("You can't register a listener from a non-Looper thread or IntentService thread.");
             }
             List<RealmChangeListener> listeners = proxy.realmGet$proxyState().getListeners$realm();
             if (!listeners.contains(listener)) {
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index 17870df854..cd41670a83 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -17,7 +17,6 @@
 package io.realm;
 
 import io.realm.annotations.Required;
-import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 
@@ -68,7 +67,6 @@
 
     private final BaseRealm realm;
     final Table table;
-    private final ImplicitTransaction transaction;
     private final Map<String, Long> columnIndices;
 
     /**
@@ -80,7 +78,6 @@
      */
     RealmObjectSchema(BaseRealm realm, Table table, Map<String, Long> columnIndices) {
         this.realm = realm;
-        this.transaction = realm.sharedGroupManager.getTransaction();
         this.table = table;
         this.columnIndices = columnIndices;
     }
@@ -100,18 +97,41 @@ public String getClassName() {
     }
 
     /**
-     * Sets a new name for this RealmObject class. This is equivalent to renaming it.
+     * Sets a new name for this RealmObject class. This is equivalent to renaming it. When {@link RealmObjectSchema#table}
+     * has a primary key, this will transfer the primary key for the new class name.
      *
      * @param className the new name for this class.
+     * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56 characters.
      * @see RealmSchema#rename(String, String)
      */
     public RealmObjectSchema setClassName(String className) {
         checkEmpty(className);
         String internalTableName = Table.TABLE_PREFIX + className;
-        if (transaction.hasTable(internalTableName)) {
+        //FIXME : when core implements class name length check, please remove.
+        if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
+            throw new IllegalArgumentException("Class name is to long. Limit is 56 characters: \'" + className + "\' (" + Integer.toString(className.length()) + ")");
+        }
+        if (realm.sharedRealm.hasTable(internalTableName)) {
             throw new IllegalArgumentException("Class already exists: " + className);
         }
-        transaction.renameTable(table.getName(), internalTableName);
+        // in case this table has a primary key, we need to transfer it after renaming the table.
+        String oldTableName = null;
+        String pkField = null;
+        if (table.hasPrimaryKey()) {
+            oldTableName = table.getName();
+            pkField = getPrimaryKey();
+            table.setPrimaryKey(null);
+        }
+        realm.sharedRealm.renameTable(table.getName(), internalTableName);
+        if (pkField != null && !pkField.isEmpty()) {
+            try {
+                table.setPrimaryKey(pkField);
+            } catch (Exception e) {
+                // revert the table name back when something goes wrong
+                realm.sharedRealm.renameTable(table.getName(), oldTableName);
+                throw e;
+            }
+        }
         return this;
     }
 
@@ -169,7 +189,7 @@ public RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAtt
     public RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema) {
         checkLegalName(fieldName);
         checkFieldNameIsAvailable(fieldName);
-        table.addColumnLink(RealmFieldType.OBJECT, fieldName, transaction.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
+        table.addColumnLink(RealmFieldType.OBJECT, fieldName, realm.sharedRealm.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
         return this;
     }
 
@@ -184,7 +204,7 @@ public RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema
     public RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema) {
         checkLegalName(fieldName);
         checkFieldNameIsAvailable(fieldName);
-        table.addColumnLink(RealmFieldType.LIST, fieldName, transaction.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
+        table.addColumnLink(RealmFieldType.LIST, fieldName, realm.sharedRealm.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
         return this;
     }
 
@@ -472,7 +492,7 @@ public RealmObjectSchema transform(Function function) {
         if (function != null) {
             long size = table.size();
             for (long i = 0; i < size; i++) {
-                function.apply(new DynamicRealmObject(realm, table.getCheckedRow(i)));
+                function.apply(new DynamicRealmObject(realm, table.getCheckedRow(i), false));
             }
         }
 
@@ -490,9 +510,9 @@ private void addModifiers(String fieldName, FieldAttribute[] attributes) {
                 }
 
                 if (containsAttribute(attributes, FieldAttribute.PRIMARY_KEY)) {
-                    addIndex(fieldName);
-                    indexAdded = true;
+                    // Note : adding primary key implies application of FieldAttribute.INDEXED attribute.
                     addPrimaryKey(fieldName);
+                    indexAdded = true;
                 }
 
                 // REQUIRED is being handled when adding the column using addField through the nullable parameter.
@@ -610,15 +630,16 @@ private void checkEmpty(String str) {
             }
             return columnIndices;
         } else {
-            if (getFieldIndex(fieldDescription) == null) {
+            Long fieldIndex = getFieldIndex(fieldDescription);
+            if (fieldIndex == null) {
                 throw new IllegalArgumentException(String.format("Field '%s' does not exist.", fieldDescription));
             }
-            RealmFieldType tableColumnType = table.getColumnType(getFieldIndex(fieldDescription));
+            RealmFieldType tableColumnType = table.getColumnType(fieldIndex);
             if (checkColumnType && !isValidType(tableColumnType, validColumnTypes)) {
                 throw new IllegalArgumentException(String.format("Field '%s': type mismatch. Was %s, expected %s.",
                         fieldDescription, tableColumnType, Arrays.toString(validColumnTypes)));
             }
-            return new long[] {getFieldIndex(fieldDescription)};
+            return new long[] {fieldIndex};
         }
     }
 
@@ -695,7 +716,8 @@ public DynamicColumnMap(Table table) {
 
         @Override
         public Long get(Object key) {
-            return table.getColumnIndex((String) key);
+            long ret = table.getColumnIndex((String) key);
+            return ret < 0 ? null : ret;
         }
 
         @Override
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index da083799ed..d50cad7172 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -17,10 +17,9 @@
 package io.realm;
 
 
-import android.os.Handler;
-
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.Date;
 import java.util.List;
 import java.util.Locale;
@@ -29,9 +28,10 @@
 
 import io.realm.annotations.Required;
 import io.realm.internal.LinkView;
+import io.realm.internal.RealmNotifier;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
-import io.realm.internal.SharedGroup;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.TableOrView;
 import io.realm.internal.TableQuery;
@@ -39,7 +39,7 @@
 import io.realm.internal.async.ArgumentsHolder;
 import io.realm.internal.async.BadVersionException;
 import io.realm.internal.async.QueryUpdateTask;
-import io.realm.internal.log.RealmLog;
+import io.realm.log.RealmLog;
 
 /**
  * A RealmQuery encapsulates a query on a {@link io.realm.Realm} or a {@link io.realm.RealmResults} using the Builder
@@ -66,9 +66,11 @@
     private String className;
     private TableOrView table;
     private RealmObjectSchema schema;
-    private LinkView view;
+    private LinkView linkView;
     private TableQuery query;
     private static final String TYPE_MISMATCH = "Field '%s': type mismatch - %s expected.";
+    private static final String EMPTY_VALUES = "Non-empty 'values' must be provided.";
+
 
     private final static Long INVALID_NATIVE_POINTER = 0L;
     private ArgumentsHolder argumentsHolder;
@@ -135,7 +137,7 @@ private RealmQuery(Realm realm, Class<E> clazz) {
         this.clazz = clazz;
         this.schema = realm.schema.getSchemaForClass(clazz);
         this.table = schema.table;
-        this.view = null;
+        this.linkView = null;
         this.query = table.where();
     }
 
@@ -143,18 +145,18 @@ private RealmQuery(RealmResults<E> queryResults, Class<E> clazz) {
         this.realm = queryResults.realm;
         this.clazz = clazz;
         this.schema = realm.schema.getSchemaForClass(clazz);
-        this.table = queryResults.getTable();
-        this.view = null;
-        this.query = queryResults.getTable().where();
+        this.table = queryResults.getTableOrView();
+        this.linkView = null;
+        this.query = this.table.where();
     }
 
-    private RealmQuery(BaseRealm realm, LinkView view, Class<E> clazz) {
+    private RealmQuery(BaseRealm realm, LinkView linkView, Class<E> clazz) {
         this.realm = realm;
         this.clazz = clazz;
-        this.query = view.where();
-        this.view = view;
         this.schema = realm.schema.getSchemaForClass(clazz);
         this.table = schema.table;
+        this.linkView = linkView;
+        this.query = linkView.where();
     }
 
     private RealmQuery(BaseRealm realm, String className) {
@@ -170,16 +172,16 @@ private RealmQuery(RealmResults<DynamicRealmObject> queryResults, String classNa
         this.className = className;
         this.schema = realm.schema.getSchemaForClass(className);
         this.table = schema.table;
-        this.query = queryResults.getTable().where();
+        this.query = queryResults.getTableOrView().where();
     }
 
-    private RealmQuery(BaseRealm realm, LinkView view, String className) {
+    private RealmQuery(BaseRealm realm, LinkView linkView, String className) {
         this.realm = realm;
         this.className = className;
-        this.query = view.where();
-        this.view = view;
         this.schema = realm.schema.getSchemaForClass(className);
         this.table = schema.table;
+        this.linkView = linkView;
+        this.query = linkView.where();
     }
 
     /**
@@ -193,8 +195,8 @@ public boolean isValid() {
             return false;
         }
 
-        if (view != null) {
-            return view.isAttached();
+        if (linkView != null) {
+            return linkView.isAttached();
         }
         return table != null && table.getTable().isValid();
     }
@@ -282,6 +284,24 @@ public boolean isValid() {
         return this;
     }
 
+    /**
+     * Equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> equalTo(String fieldName, byte[] value) {
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.BINARY);
+        if (value == null) {
+            this.query.isNull(columnIndices);
+        } else {
+            this.query.equalTo(columnIndices, value);
+        }
+        return this;
+    }
+
     /**
      * Equal-to comparison.
      *
@@ -403,6 +423,192 @@ public boolean isValid() {
         return this;
     }
 
+    // In
+
+    /**
+     * In comparison. This allows you to test if objects match any value in an array of values.
+     *
+     * @param fieldName the field to compare.
+     * @param values array of values to compare with and it cannot be null or empty.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field isn't a String field or {@code values} is {@code null} or empty.
+     */
+    public RealmQuery<E> in(String fieldName, String[] values) {
+        return in(fieldName, values, Case.SENSITIVE);
+    }
+
+    /**
+     * In comparison. This allows you to test if objects match any value in an array of values.
+     *
+     * @param fieldName the field to compare.
+     * @param values array of values to compare with and it cannot be null or empty.
+     * @param casing how casing is handled. {@link Case#INSENSITIVE} works only for the Latin-1 characters.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field isn't a String field or {@code values} is {@code null} or empty.
+     */
+    public RealmQuery<E> in(String fieldName, String[] values, Case casing) {
+        if (values == null || values.length == 0) {
+            throw new IllegalArgumentException(EMPTY_VALUES);
+        }
+        beginGroup().equalTo(fieldName, values[0], casing);
+        for (int i = 1; i < values.length; i++) {
+            or().equalTo(fieldName, values[i], casing);
+        }
+        return endGroup();
+    }
+
+    /**
+     * In comparison. This allows you to test if objects match any value in an array of values.
+     *
+     * @param fieldName the field to compare.
+     * @param values array of values to compare with and it cannot be null or empty.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Byte field or {@code values} is {@code null} or empty.
+     */
+    public RealmQuery<E> in(String fieldName, Byte[] values) {
+        if (values == null || values.length == 0) {
+            throw new IllegalArgumentException(EMPTY_VALUES);
+        }
+        beginGroup().equalTo(fieldName, values[0]);
+        for (int i = 1; i < values.length; i++) {
+            or().equalTo(fieldName, values[i]);
+        }
+        return endGroup();
+    }
+
+    /**
+     * In comparison. This allows you to test if objects match any value in an array of values.
+     *
+     * @param fieldName the field to compare.
+     * @param values array of values to compare with and it cannot be null or empty.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Short field or {@code values} is {@code null} or empty.
+     */
+    public RealmQuery<E> in(String fieldName, Short[] values) {
+        if (values == null || values.length == 0) {
+            throw new IllegalArgumentException(EMPTY_VALUES);
+        }
+        beginGroup().equalTo(fieldName, values[0]);
+        for (int i = 1; i < values.length; i++) {
+            or().equalTo(fieldName, values[i]);
+        }
+        return endGroup();
+    }
+
+    /**
+     * In comparison. This allows you to test if objects match any value in an array of values.
+     *
+     * @param fieldName the field to compare.
+     * @param values array of values to compare with and it cannot be null or empty.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Integer field or {@code values} is {@code null} or empty.
+     */
+    public RealmQuery<E> in(String fieldName, Integer[] values) {
+        if (values == null || values.length == 0) {
+            throw new IllegalArgumentException(EMPTY_VALUES);
+        }
+        beginGroup().equalTo(fieldName, values[0]);
+        for (int i = 1; i < values.length; i++) {
+            or().equalTo(fieldName, values[i]);
+        }
+        return endGroup();
+    }
+
+    /**
+     * In comparison. This allows you to test if objects match any value in an array of values.
+     *
+     * @param fieldName the field to compare.
+     * @param values array of values to compare with and it cannot be null or empty.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Long field or {@code values} is {@code null} or empty.
+     */
+    public RealmQuery<E> in(String fieldName, Long[] values) {
+        if (values == null || values.length == 0) {
+            throw new IllegalArgumentException(EMPTY_VALUES);
+        }
+        beginGroup().equalTo(fieldName, values[0]);
+        for (int i = 1; i < values.length; i++) {
+            or().equalTo(fieldName, values[i]);
+        }
+        return endGroup();
+    }
+
+    /**
+     * In comparison. This allows you to test if objects match any value in an array of values.
+     *
+     * @param fieldName the field to compare.
+     * @param values array of values to compare with and it cannot be null or empty.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Double field or {@code values} is {@code null} or empty.
+     */
+    public RealmQuery<E> in(String fieldName, Double[] values) {
+        if (values == null || values.length == 0) {
+            throw new IllegalArgumentException(EMPTY_VALUES);
+        }
+        beginGroup().equalTo(fieldName, values[0]);
+        for (int i = 1; i < values.length; i++) {
+            or().equalTo(fieldName, values[i]);
+        }
+        return endGroup();
+    }
+
+    /**
+     * In comparison. This allows you to test if objects match any value in an array of values.
+     *
+     * @param fieldName the field to compare.
+     * @param values array of values to compare with and it cannot be null or empty.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Float field or {@code values} is {@code null} or empty.
+     */
+    public RealmQuery<E> in(String fieldName, Float[] values) {
+        if (values == null || values.length == 0) {
+            throw new IllegalArgumentException(EMPTY_VALUES);
+        }
+        beginGroup().equalTo(fieldName, values[0]);
+        for (int i = 1; i < values.length; i++) {
+            or().equalTo(fieldName, values[i]);
+        }
+        return endGroup();
+    }
+
+    /**
+     * In comparison. This allows you to test if objects match any value in an array of values.
+     *
+     * @param fieldName the field to compare.
+     * @param values array of values to compare with and it cannot be null or empty.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Boolean field or {@code values} is {@code null} or empty.
+     */
+    public RealmQuery<E> in(String fieldName, Boolean[] values) {
+        if (values == null || values.length == 0) {
+            throw new IllegalArgumentException(EMPTY_VALUES);
+        }
+        beginGroup().equalTo(fieldName, values[0]);
+        for (int i = 1; i < values.length; i++) {
+            or().equalTo(fieldName, values[i]);
+        }
+        return endGroup();
+    }
+
+    /**
+     * In comparison. This allows you to test if objects match any value in an array of values.
+     *
+     * @param fieldName the field to compare.
+     * @param values array of values to compare with and it cannot be null or empty.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if the field isn't a Date field or {@code values} is {@code null} or empty.
+     */
+    public RealmQuery<E> in(String fieldName, Date[] values) {
+        if (values == null || values.length == 0) {
+            throw new IllegalArgumentException(EMPTY_VALUES);
+        }
+        beginGroup().equalTo(fieldName, values[0]);
+        for (int i = 1; i < values.length; i++) {
+            or().equalTo(fieldName, values[i]);
+        }
+        return endGroup();
+    }
+
     // Not Equal
 
     /**
@@ -453,6 +659,24 @@ public boolean isValid() {
         return this;
     }
 
+    /**
+     * Not-equal-to comparison.
+     *
+     * @param fieldName the field to compare.
+     * @param value the value to compare with.
+     * @return the query object.
+     * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
+     */
+    public RealmQuery<E> notEqualTo(String fieldName, byte[] value) {
+        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.BINARY);
+        if (value == null) {
+            this.query.isNotNull(columnIndices);
+        } else {
+            this.query.notEqualTo(columnIndices, value);
+        }
+        return this;
+    }
+
     /**
      * Not-equal-to comparison.
      *
@@ -1137,16 +1361,16 @@ public boolean isValid() {
     public RealmResults<E> distinctAsync(String fieldName) {
         checkQueryIsNotReused();
         final long columnIndex = getAndValidateDistinctColumnIndex(fieldName, this.table.getTable());
-        final WeakReference<Handler> weakHandler = getWeakReferenceHandler();
+        final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();
 
         // handover the query (to be used by a worker thread)
-        final long handoverQueryPointer = query.handoverQuery(realm.sharedGroupManager.getNativePointer());
+        final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);
 
         // save query arguments (for future update)
         argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_DISTINCT);
         argumentsHolder.columnIndex = columnIndex;
 
-        // we need to use the same configuration to open a background SharedGroup (i.e Realm)
+        // we need to use the same configuration to open a background SharedRealm (i.e Realm)
         // to perform the query
         final RealmConfiguration realmConfiguration = realm.getConfiguration();
 
@@ -1162,39 +1386,34 @@ public boolean isValid() {
 
         final WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = realm.handlerController.addToAsyncRealmResults(realmResults, this);
 
-        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submit(new Callable<Long>() {
+        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submitQuery(new Callable<Long>() {
             @Override
             public Long call() throws Exception {
                 if (!Thread.currentThread().isInterrupted()) {
-                    SharedGroup sharedGroup = null;
+                    SharedRealm sharedRealm = null;
 
                     try {
-                        sharedGroup = new SharedGroup(realmConfiguration.getPath(),
-                                SharedGroup.IMPLICIT_TRANSACTION,
-                                realmConfiguration.getDurability(),
-                                realmConfiguration.getEncryptionKey());
-
-                        long handoverTableViewPointer = query.
-                                findDistinctWithHandover(sharedGroup.getNativePointer(),
-                                        sharedGroup.getNativeReplicationPointer(),
+                        sharedRealm = SharedRealm.getInstance(realmConfiguration);
+
+                        long handoverTableViewPointer = TableQuery.
+                                findDistinctWithHandover(sharedRealm,
                                         handoverQueryPointer,
                                         columnIndex);
 
                         QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmResultsResponse();
                         result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
-                        result.versionID = sharedGroup.getVersion();
-                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerController.COMPLETED_ASYNC_REALM_RESULTS, result);
+                        result.versionID = sharedRealm.getVersionID();
+                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
+                                weakNotifier, QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_RESULTS, result);
 
                         return handoverTableViewPointer;
-                    } catch (Exception e) {
-                        RealmLog.e(e.getMessage(), e);
-                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerController.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
-
+                    } catch (Throwable e) {
+                        RealmLog.error(e);
+                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
+                                weakNotifier, QueryUpdateTask.NotifyEvent.THROW_BACKGROUND_EXCEPTION, e);
                     } finally {
-                        if (sharedGroup != null && !sharedGroup.isClosed()) {
-                            sharedGroup.close();
+                        if (sharedRealm != null && !sharedRealm.isClosed()) {
+                            sharedRealm.close();
                         }
                     }
                 } else {
@@ -1446,15 +1665,15 @@ public long count() {
      */
     public RealmResults<E> findAllAsync() {
         checkQueryIsNotReused();
-        final WeakReference<Handler> weakHandler = getWeakReferenceHandler();
+        final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();
 
         // handover the query (to be used by a worker thread)
-        final long handoverQueryPointer = query.handoverQuery(realm.sharedGroupManager.getNativePointer());
+        final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);
 
         // save query arguments (for future update)
         argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_FIND_ALL);
 
-        // we need to use the same configuration to open a background SharedGroup (i.e Realm)
+        // we need to use the same configuration to open a background SharedRealm (i.e Realm)
         // to perform the query
         final RealmConfiguration realmConfiguration = realm.getConfiguration();
 
@@ -1470,44 +1689,41 @@ public long count() {
 
         final WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = realm.handlerController.addToAsyncRealmResults(realmResults, this);
 
-        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submit(new Callable<Long>() {
+        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submitQuery(new Callable<Long>() {
             @Override
             public Long call() throws Exception {
                 if (!Thread.currentThread().isInterrupted()) {
-                    SharedGroup sharedGroup = null;
+                    SharedRealm sharedRealm = null;
 
                     try {
-                        sharedGroup = new SharedGroup(realmConfiguration.getPath(),
-                                SharedGroup.IMPLICIT_TRANSACTION,
-                                realmConfiguration.getDurability(),
-                                realmConfiguration.getEncryptionKey());
+                        sharedRealm = SharedRealm.getInstance(realmConfiguration);
 
                         // Run the query & handover the table view for the caller thread
                         // Note: the handoverQueryPointer contains the versionID needed by the SG in order
                         // to import it.
-                        long handoverTableViewPointer = query.findAllWithHandover(sharedGroup.getNativePointer(), sharedGroup.getNativeReplicationPointer(), handoverQueryPointer);
+                        long handoverTableViewPointer = TableQuery.findAllWithHandover(sharedRealm,
+                                handoverQueryPointer);
 
                         QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmResultsResponse();
                         result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
-                        result.versionID = sharedGroup.getVersion();
-                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerController.COMPLETED_ASYNC_REALM_RESULTS, result);
+                        result.versionID = sharedRealm.getVersionID();
+                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
+                                weakNotifier, QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_RESULTS, result);
 
                         return handoverTableViewPointer;
 
                     } catch (BadVersionException e) {
                         // In some rare race conditions, this can happen. In that case, just ignore the error.
-                        RealmLog.d("findAllAsync handover could not complete due to a BadVersionException. " +
+                        RealmLog.debug("findAllAsync handover could not complete due to a BadVersionException. " +
                                 "Retry is scheduled by a REALM_CHANGED event.");
 
-                    } catch (Exception e) {
-                        RealmLog.e(e.getMessage(), e);
-                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerController.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
-
+                    } catch (Throwable e) {
+                        RealmLog.error(e);
+                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
+                                weakNotifier, QueryUpdateTask.NotifyEvent.THROW_BACKGROUND_EXCEPTION, e);
                     } finally {
-                        if (sharedGroup != null && !sharedGroup.isClosed()) {
-                            sharedGroup.close();
+                        if (sharedRealm != null && !sharedRealm.isClosed()) {
+                            sharedRealm.close();
                         }
                     }
                 } else {
@@ -1569,12 +1785,12 @@ public Long call() throws Exception {
         argumentsHolder.sortOrder = sortOrder;
         argumentsHolder.columnIndex = columnIndex;
 
-        final WeakReference<Handler> weakHandler = getWeakReferenceHandler();
+        final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();
 
         // handover the query (to be used by a worker thread)
-        final long handoverQueryPointer = query.handoverQuery(realm.sharedGroupManager.getNativePointer());
+        final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);
 
-        // we need to use the same configuration to open a background SharedGroup to perform the query
+        // we need to use the same configuration to open a background SharedRealm to perform the query
         final RealmConfiguration realmConfiguration = realm.getConfiguration();
 
         RealmResults<E> realmResults;
@@ -1588,44 +1804,41 @@ public Long call() throws Exception {
         final WeakReference<RealmResults<? extends RealmModel>> weakRealmResults =
                 realm.handlerController.addToAsyncRealmResults(realmResults, this);
 
-        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submit(new Callable<Long>() {
+        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submitQuery(new Callable<Long>() {
             @Override
             public Long call() throws Exception {
                 if (!Thread.currentThread().isInterrupted()) {
-                    SharedGroup sharedGroup = null;
+                    SharedRealm sharedRealm = null;
 
                     try {
-                        sharedGroup = new SharedGroup(realmConfiguration.getPath(),
-                                SharedGroup.IMPLICIT_TRANSACTION,
-                                realmConfiguration.getDurability(),
-                                realmConfiguration.getEncryptionKey());
+                        sharedRealm = SharedRealm.getInstance(realmConfiguration);
 
                         long columnIndex = getColumnIndexForSort(fieldName);
 
                         // run the query & handover the table view for the caller thread
-                        long handoverTableViewPointer = query.findAllSortedWithHandover(sharedGroup.getNativePointer(),
-                                sharedGroup.getNativeReplicationPointer(), handoverQueryPointer, columnIndex, sortOrder);
+                        long handoverTableViewPointer = TableQuery.findAllSortedWithHandover(sharedRealm,
+                                 handoverQueryPointer, columnIndex, sortOrder);
 
                         QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmResultsResponse();
                         result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
-                        result.versionID = sharedGroup.getVersion();
-                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerController.COMPLETED_ASYNC_REALM_RESULTS, result);
+                        result.versionID = sharedRealm.getVersionID();
+                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
+                                weakNotifier, QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_RESULTS, result);
 
                         return handoverTableViewPointer;
                     } catch (BadVersionException e) {
                         // In some rare race conditions, this can happen. In that case, just ignore the error.
-                        RealmLog.d("findAllSortedAsync handover could not complete due to a BadVersionException. " +
+                        RealmLog.debug("findAllSortedAsync handover could not complete due to a BadVersionException. " +
                                 "Retry is scheduled by a REALM_CHANGED event.");
 
-                    } catch (Exception e) {
-                        RealmLog.e(e.getMessage(), e);
-                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerController.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
+                    } catch (Throwable e) {
+                        RealmLog.error(e);
+                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
+                                weakNotifier, QueryUpdateTask.NotifyEvent.THROW_BACKGROUND_EXCEPTION, e);
 
                     } finally {
-                        if (sharedGroup != null && !sharedGroup.isClosed()) {
-                            sharedGroup.close();
+                        if (sharedRealm!= null && !sharedRealm.isClosed()) {
+                            sharedRealm.close();
                         }
                     }
                 } else {
@@ -1732,12 +1945,12 @@ private boolean isDynamicQuery() {
             return findAllSortedAsync(fieldNames[0], sortOrders[0]);
 
         } else {
-            final WeakReference<Handler> weakHandler = getWeakReferenceHandler();
+            final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();
 
             // Handover the query (to be used by a worker thread)
-            final long handoverQueryPointer = query.handoverQuery(realm.sharedGroupManager.getNativePointer());
+            final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);
 
-            // We need to use the same configuration to open a background SharedGroup to perform the query
+            // We need to use the same configuration to open a background SharedRealm to perform the query
             final RealmConfiguration realmConfiguration = realm.getConfiguration();
 
             final long indices[] = new long[fieldNames.length];
@@ -1763,42 +1976,38 @@ private boolean isDynamicQuery() {
 
             final WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = realm.handlerController.addToAsyncRealmResults(realmResults, this);
 
-            final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submit(new Callable<Long>() {
+            final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submitQuery(new Callable<Long>() {
                 @Override
                 public Long call() throws Exception {
                     if (!Thread.currentThread().isInterrupted()) {
-                        SharedGroup sharedGroup = null;
+                        SharedRealm sharedRealm = null;
 
                         try {
-                            sharedGroup = new SharedGroup(realmConfiguration.getPath(),
-                                    SharedGroup.IMPLICIT_TRANSACTION,
-                                    realmConfiguration.getDurability(),
-                                    realmConfiguration.getEncryptionKey());
+                            sharedRealm = SharedRealm.getInstance(realmConfiguration);
 
                             // run the query & handover the table view for the caller thread
-                            long handoverTableViewPointer = query.findAllMultiSortedWithHandover(sharedGroup.getNativePointer(),
-                                    sharedGroup.getNativeReplicationPointer(), handoverQueryPointer, indices, sortOrders);
+                            long handoverTableViewPointer = TableQuery.findAllMultiSortedWithHandover(sharedRealm,
+                                    handoverQueryPointer, indices, sortOrders);
 
                             QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmResultsResponse();
                             result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
-                            result.versionID = sharedGroup.getVersion();
-                            closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                    weakHandler, HandlerController.COMPLETED_ASYNC_REALM_RESULTS, result);
+                            result.versionID = sharedRealm.getVersionID();
+                            closeSharedRealmAndSendEventToNotifier(sharedRealm,
+                                    weakNotifier, QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_RESULTS, result);
 
                             return handoverTableViewPointer;
                         } catch (BadVersionException e) {
                             // In some rare race conditions, this can happen. In that case, just ignore the error.
-                            RealmLog.d("findAllSortedAsync handover could not complete due to a BadVersionException. " +
+                            RealmLog.debug("findAllSortedAsync handover could not complete due to a BadVersionException. " +
                                     "Retry is scheduled by a REALM_CHANGED event.");
 
-                        } catch (Exception e) {
-                            RealmLog.e(e.getMessage(), e);
-                            closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                    weakHandler, HandlerController.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
-
+                        } catch (Throwable e) {
+                            RealmLog.error(e);
+                            closeSharedRealmAndSendEventToNotifier(sharedRealm,
+                                    weakNotifier, QueryUpdateTask.NotifyEvent.THROW_BACKGROUND_EXCEPTION, e);
                         } finally {
-                            if (sharedGroup != null && !sharedGroup.isClosed()) {
-                                sharedGroup.close();
+                            if (sharedRealm != null && !sharedRealm.isClosed()) {
+                                sharedRealm.close();
                             }
                         }
                     } else {
@@ -1856,9 +2065,9 @@ public Long call() throws Exception {
      */
     public E findFirst() {
         checkQueryIsNotReused();
-        long sourceRowIndex = getSourceRowIndexForFirstObject();
-        if (sourceRowIndex >= 0) {
-            E realmObject = realm.get(clazz, className, sourceRowIndex);
+        long tableRowIndex = getSourceRowIndexForFirstObject();
+        if (tableRowIndex >= 0) {
+            E realmObject = realm.get(clazz, className, tableRowIndex);
             return realmObject;
         } else {
             return null;
@@ -1878,10 +2087,10 @@ public E findFirst() {
      */
     public E findFirstAsync() {
         checkQueryIsNotReused();
-        final WeakReference<Handler> weakHandler = getWeakReferenceHandler();
+        final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();
 
         // handover the query (to be used by a worker thread)
-        final long handoverQueryPointer = query.handoverQuery(realm.sharedGroupManager.getNativePointer());
+        final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);
 
         // save query arguments (for future update)
         argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_FIND_FIRST);
@@ -1893,30 +2102,26 @@ public E findFirstAsync() {
         final E result;
         if (isDynamicQuery()) {
             //noinspection unchecked
-            result = (E) new DynamicRealmObject(className);
+            result = (E) new DynamicRealmObject(className, realm, Row.EMPTY_ROW, false);
         } else {
-            result = realm.getConfiguration().getSchemaMediator().newInstance(clazz, realm.getSchema().getColumnInfo(clazz));
+            result = realm.getConfiguration().getSchemaMediator().newInstance(
+                    clazz, realm, Row.EMPTY_ROW, realm.getSchema().getColumnInfo(clazz),
+                    false, Collections.<String>emptyList());
         }
 
-        RealmObjectProxy proxy = (RealmObjectProxy) result;
+        final RealmObjectProxy proxy = (RealmObjectProxy) result;
         final WeakReference<RealmObjectProxy> realmObjectWeakReference = realm.handlerController.addToAsyncRealmObject(proxy, this);
-        proxy.realmGet$proxyState().setRealm$realm(realm);
-        proxy.realmGet$proxyState().setRow$realm(Row.EMPTY_ROW);
 
-        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submit(new Callable<Long>() {
+        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submitQuery(new Callable<Long>() {
             @Override
             public Long call() throws Exception {
                 if (!Thread.currentThread().isInterrupted()) {
-                    SharedGroup sharedGroup = null;
+                    SharedRealm sharedRealm = null;
 
                     try {
-                        sharedGroup = new SharedGroup(realmConfiguration.getPath(),
-                                SharedGroup.IMPLICIT_TRANSACTION,
-                                realmConfiguration.getDurability(),
-                                realmConfiguration.getEncryptionKey());
+                        sharedRealm = SharedRealm.getInstance(realmConfiguration);
 
-                        long handoverRowPointer = query.findWithHandover(sharedGroup.getNativePointer(),
-                                sharedGroup.getNativeReplicationPointer(), handoverQueryPointer);
+                        long handoverRowPointer = TableQuery.findWithHandover(sharedRealm, handoverQueryPointer);
                         if (handoverRowPointer == 0) { // empty row
                             realm.handlerController.addToEmptyAsyncRealmObject(realmObjectWeakReference, RealmQuery.this);
                             realm.handlerController.removeFromAsyncRealmObject(realmObjectWeakReference);
@@ -1924,21 +2129,20 @@ public Long call() throws Exception {
 
                         QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmObjectResponse();
                         result.updatedRow.put(realmObjectWeakReference, handoverRowPointer);
-                        result.versionID = sharedGroup.getVersion();
-                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerController.COMPLETED_ASYNC_REALM_OBJECT, result);
+                        result.versionID = sharedRealm.getVersionID();
+                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
+                                weakNotifier, QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_OBJECT, result);
 
                         return handoverRowPointer;
 
-                    } catch (Exception e) {
-                        RealmLog.e(e.getMessage(), e);
+                    } catch (Throwable e) {
+                        RealmLog.error(e);
                         // handler can't throw a checked exception need to wrap it into unchecked Exception
-                        closeSharedGroupAndSendMessageToHandler(sharedGroup,
-                                weakHandler, HandlerController.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(e));
-
+                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
+                                weakNotifier, QueryUpdateTask.NotifyEvent.THROW_BACKGROUND_EXCEPTION, e);
                     } finally {
-                        if (sharedGroup != null && !sharedGroup.isClosed()) {
-                            sharedGroup.close();
+                        if (sharedRealm != null && !sharedRealm.isClosed()) {
+                            sharedRealm.close();
                         }
                     }
                 } else {
@@ -1967,23 +2171,39 @@ private void checkSortParameters(String fieldNames[], final Sort[] sortOrders) {
         }
     }
 
-    private WeakReference<Handler> getWeakReferenceHandler() {
-        if (realm.handler == null) {
+    private WeakReference<RealmNotifier> getWeakReferenceNotifier() {
+        if (realm.sharedRealm.realmNotifier == null || !realm.sharedRealm.realmNotifier.isValid()) {
             throw new IllegalStateException("Your Realm is opened from a thread without a Looper." +
                     " Async queries need a Handler to send results of your query");
         }
-        return new WeakReference<Handler>(realm.handler); // use caller Realm's Looper
+        return new WeakReference<RealmNotifier>(realm.sharedRealm.realmNotifier); // use caller Realm's Looper
     }
 
     // The shared group needs to be closed before sending the message to other threads to avoid timing problems.
     // eg.: The other thread wants to delete Realm when getting notified.
-    private void closeSharedGroupAndSendMessageToHandler(SharedGroup sharedGroup, WeakReference<Handler> weakHandler, int what, Object obj) {
-        if (sharedGroup != null) {
-            sharedGroup.close();
+    private void closeSharedRealmAndSendEventToNotifier(SharedRealm sharedRealm,
+                                                         WeakReference<RealmNotifier> weakNotifier,
+                                                        QueryUpdateTask.NotifyEvent event, Object obj) {
+        if (sharedRealm != null) {
+            sharedRealm.close();
         }
-        Handler handler = weakHandler.get();
-        if (handler != null && handler.getLooper().getThread().isAlive()) {
-            handler.obtainMessage(what, obj).sendToTarget();
+
+        RealmNotifier notifier = weakNotifier.get();
+        if (notifier!= null) {
+            switch (event) {
+                case COMPLETE_ASYNC_RESULTS:
+                    notifier.completeAsyncResults((QueryUpdateTask.Result)obj);
+                    break;
+                case COMPLETE_ASYNC_OBJECT:
+                    notifier.completeAsyncObject((QueryUpdateTask.Result)obj);
+                    break;
+                case THROW_BACKGROUND_EXCEPTION:
+                    notifier.throwBackgroundException((Throwable)obj);
+                    break;
+                default:
+                    // Should not get here.
+                    throw new IllegalStateException(String.format("%s is not handled here.", event));
+            }
         }
     }
 
@@ -1998,19 +2218,9 @@ private void checkQueryIsNotReused() {
     }
 
     private long getSourceRowIndexForFirstObject() {
-        long rowIndex = this.query.find();
-        if (rowIndex < 0) {
-            return rowIndex;
-        }
-        if (this.view != null) {
-            return view.getTargetRowIndex(rowIndex);
-        } else if (table instanceof TableView){
-            return ((TableView) table).getSourceRowIndex(rowIndex);
-        } else {
-            return rowIndex;
-        }
+        long tableRowIndex = this.query.find();
+        return tableRowIndex;
     }
-
     // Get the column index for sorting related functions. A proper exception will be thrown if the field doesn't exist
     // or it belongs to the child object.
     private long getColumnIndexForSort(String fieldName) {
@@ -2022,7 +2232,7 @@ private long getColumnIndexForSort(String fieldName) {
         }
 
         Long columnIndex = schema.getFieldIndex(fieldName);
-        if (columnIndex == null || columnIndex < 0) {
+        if (columnIndex == null) {
             throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
         }
 
@@ -2039,6 +2249,6 @@ public ArgumentsHolder getArgument() {
      * @return the exported handover pointer for this RealmQuery.
      */
     long handoverQueryPointer() {
-        return query.handoverQuery(realm.sharedGroupManager.getNativePointer());
+        return query.handoverQuery(realm.sharedRealm);
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index 4063f589ce..ea37900e37 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -17,6 +17,8 @@
 package io.realm;
 
 
+import android.app.IntentService;
+
 import java.util.AbstractList;
 import java.util.Collection;
 import java.util.Collections;
@@ -36,7 +38,7 @@
 import io.realm.internal.TableQuery;
 import io.realm.internal.TableView;
 import io.realm.internal.async.BadVersionException;
-import io.realm.internal.log.RealmLog;
+import io.realm.log.RealmLog;
 import rx.Observable;
 
 /**
@@ -70,7 +72,7 @@
 
     private final static String NOT_SUPPORTED_MESSAGE = "This method is not supported by RealmResults.";
 
-    BaseRealm realm;
+    final BaseRealm realm;
     Class<E> classSpec;   // Return type
     String className;     // Class name used by DynamicRealmObjects
     private TableOrView table = null;
@@ -144,7 +146,7 @@ private RealmResults(BaseRealm realm, TableOrView table, String className) {
         this.currentTableViewVersion = table.syncIfNeeded();
     }
 
-    TableOrView getTable() {
+    TableOrView getTableOrView() {
         if (table == null) {
             return realm.schema.getTable(classSpec);
         } else {
@@ -156,7 +158,17 @@ TableOrView getTable() {
      * {@inheritDoc}
      */
     public boolean isValid() {
-        return realm != null && !realm.isClosed();
+        return !realm.isClosed();
+    }
+
+    /**
+     * A {@link RealmResults} is always a managed collection.
+     *
+     * @return {@code true}.
+     * @see RealmCollection#isManaged()
+     */
+    public boolean isManaged() {
+        return true;
     }
 
     /**
@@ -165,7 +177,6 @@ public boolean isValid() {
     @Override
     public RealmQuery<E> where() {
         realm.checkIfValid();
-
         return RealmQuery.createQueryFromResult(this);
     }
 
@@ -199,7 +210,7 @@ public boolean contains(Object object) {
     public E get(int location) {
         E obj;
         realm.checkIfValid();
-        TableOrView table = getTable();
+        TableOrView table = getTableOrView();
         if (table instanceof TableView) {
             obj = realm.get(classSpec, className, ((TableView) table).getSourceRowIndex(location));
         } else {
@@ -240,7 +251,7 @@ public E last() {
     @Override
     public void deleteFromRealm(int location) {
         realm.checkIfValid();
-        TableOrView table = getTable();
+        TableOrView table = getTableOrView();
         table.remove(location);
     }
 
@@ -251,7 +262,7 @@ public void deleteFromRealm(int location) {
     public boolean deleteAllFromRealm() {
         realm.checkIfValid();
         if (size() > 0) {
-            TableOrView table = getTable();
+            TableOrView table = getTableOrView();
             table.clear();
             return true;
         } else {
@@ -370,7 +381,7 @@ public int size() {
         if (!isLoaded()) {
             return 0;
         } else {
-            long size = getTable().size();
+            long size = getTableOrView().size();
             return (size > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) size;
         }
     }
@@ -497,7 +508,7 @@ public double average(String fieldName) {
         realm.checkIfValid();
         long columnIndex = RealmQuery.getAndValidateDistinctColumnIndex(fieldName, this.table.getTable());
 
-        TableOrView tableOrView = getTable();
+        TableOrView tableOrView = getTableOrView();
         if (tableOrView instanceof Table) {
             this.table = ((Table) tableOrView).getDistinctView(columnIndex);
         } else {
@@ -606,7 +617,7 @@ public boolean retainAll(Collection<?> collection) {
     public boolean deleteLastFromRealm() {
         realm.checkIfValid();
         if (size() > 0) {
-            TableOrView table = getTable();
+            TableOrView table = getTableOrView();
             table.removeLast();
             return true;
         } else {
@@ -614,6 +625,14 @@ public boolean deleteLastFromRealm() {
         }
     }
 
+    /**
+     * Syncs this RealmResults, so it is up to date after `advance_read` has been called.
+     * Not doing so can leave detached accessors in the table view.
+     *
+     * By design, we should only call this on looper events.
+     *
+     * NOTE: Calling this is a prerequisite to calling {@link #notifyChangeListeners(boolean)}.
+     */
     void syncIfNeeded() {
         long newVersion = table.syncIfNeeded();
         viewUpdated = newVersion != currentTableViewVersion;
@@ -628,7 +647,7 @@ void syncIfNeeded() {
     @Override
     public boolean deleteFirstFromRealm() {
         if (size() > 0) {
-            TableOrView table = getTable();
+            TableOrView table = getTableOrView();
             table.removeFirst();
             return true;
         } else {
@@ -827,7 +846,7 @@ public void set(E object) {
      */
     void swapTableViewPointer(long handoverTableViewPointer) {
         try {
-            table = query.importHandoverTableView(handoverTableViewPointer, realm.sharedGroupManager.getNativePointer());
+            table = query.importHandoverTableView(handoverTableViewPointer, realm.sharedRealm);
             asyncQueryCompleted = true;
         } catch (BadVersionException e) {
             throw new IllegalStateException("Caller and Worker Realm should have been at the same version");
@@ -851,12 +870,11 @@ void setPendingQuery(Future<Long> pendingQuery) {
     }
 
     /**
-     * Returns {@code true} if the results are not yet loaded, {@code false} if they are still loading. Synchronous
+     * Returns {@code false} if the results are not yet loaded, {@code true} if they are loaded. Synchronous
      * query methods like findAll() will always return {@code true}, while asynchronous query methods like
      * findAllAsync() will return {@code false} until the results are available.
-     * This will return {@code true} if called for an unmanaged object (created outside of Realm).
      *
-     * @return {@code true} if the query has completed and the data is available {@code false} if the query is still
+     * @return {@code true} if the query has completed and the data is available, {@code false} if the query is still
      * running.
      */
     public boolean isLoaded() {
@@ -894,11 +912,11 @@ private boolean onAsyncQueryCompleted() {
             // this may fail with BadVersionException if the caller and/or the worker thread
             // are not in sync. COMPLETED_ASYNC_REALM_RESULTS will be fired by the worker thread
             // this should handle more complex use cases like retry, ignore etc
-            table = query.importHandoverTableView(tvHandover, realm.sharedGroupManager.getNativePointer());
+            table = query.importHandoverTableView(tvHandover, realm.sharedRealm);
             asyncQueryCompleted = true;
-            notifyChangeListeners(false, true);
+            notifyChangeListeners(true);
         } catch (Exception e) {
-            RealmLog.d(e.getMessage());
+            RealmLog.debug(e.getMessage());
             return false;
         }
         return true;
@@ -909,15 +927,15 @@ private boolean onAsyncQueryCompleted() {
      *
      * @param listener the change listener to be notified.
      * @throws IllegalArgumentException if the change listener is {@code null}.
-     * @throws IllegalStateException if you try to add a listener from a non-Looper Thread.
+     * @throws IllegalStateException if you try to add a listener from a non-Looper or {@link IntentService} thread.
      */
     public void addChangeListener(RealmChangeListener<RealmResults<E>> listener) {
         if (listener == null) {
             throw new IllegalArgumentException("Listener should not be null");
         }
         realm.checkIfValid();
-        if (realm.handler == null) {
-            throw new IllegalStateException("You can't register a listener from a non-Looper thread ");
+        if (!realm.handlerController.isAutoRefreshEnabled()) {
+            throw new IllegalStateException("You can't register a listener from a non-Looper thread or IntentService thread. ");
         }
         if (!listeners.contains(listener)) {
             listeners.add(listener);
@@ -991,15 +1009,10 @@ public void removeChangeListeners() {
 
     /**
      * Notifies all registered listeners.
+     *
+     * NOTE: Remember to call `syncIfNeeded` before calling this method.
      */
-    void notifyChangeListeners() {
-        notifyChangeListeners(true, false);
-    }
-
-    private void notifyChangeListeners(boolean syncBeforeNotifying, boolean forceNotify) {
-        if (syncBeforeNotifying) {
-            syncIfNeeded();
-        }
+    void notifyChangeListeners(boolean forceNotify) {
         if (!listeners.isEmpty()) {
             // table might be null (if the async query didn't complete
             // but we have already registered listeners for it)
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index d7624d66f0..0780595495 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -23,7 +23,6 @@
 
 import io.realm.internal.ColumnIndices;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.Table;
 import io.realm.internal.Util;
 
@@ -40,25 +39,23 @@
     private static final String TABLE_PREFIX = Table.TABLE_PREFIX;
     private static final String EMPTY_STRING_MSG = "Null or empty class names are not allowed";
 
-    // Caches Dynamic Class objects given as Strings (both model classes and proxy classes) to Realm Tables
+    // Caches Dynamic Class objects given as Strings to Realm Tables
     private final Map<String, Table> dynamicClassToTable = new HashMap<String, Table>();
     // Caches Class objects (both model classes and proxy classes) to Realm Tables
     private final Map<Class<? extends RealmModel>, Table> classToTable = new HashMap<Class<? extends RealmModel>, Table>();
     // Caches Class objects (both model classes and proxy classes) to their Schema object
     private final Map<Class<? extends RealmModel>, RealmObjectSchema> classToSchema = new HashMap<Class<? extends RealmModel>, RealmObjectSchema>();
-    // Caches Class Strings (both model classes and proxy classes) to their Schema object
+    // Caches Class Strings to their Schema object
     private final Map<String, RealmObjectSchema> dynamicClassToSchema = new HashMap<String, RealmObjectSchema>();
 
-    private final ImplicitTransaction transaction;
     private final BaseRealm realm;
     ColumnIndices columnIndices; // Cached field look up
 
     /**
      * Creates a wrapper to easily manipulate the current schema of a Realm.
      */
-    RealmSchema(BaseRealm realm, ImplicitTransaction transaction) {
+    RealmSchema(BaseRealm realm) {
         this.realm = realm;
-        this.transaction = transaction;
     }
 
     /**
@@ -71,8 +68,8 @@
     public RealmObjectSchema get(String className) {
         checkEmpty(className, EMPTY_STRING_MSG);
         String internalClassName = TABLE_PREFIX + className;
-        if (transaction.hasTable(internalClassName)) {
-            Table table = transaction.getTable(internalClassName);
+        if (realm.sharedRealm.hasTable(internalClassName)) {
+            Table table = realm.sharedRealm.getTable(internalClassName);
             RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
             return new RealmObjectSchema(realm, table, columnIndices);
         } else {
@@ -86,14 +83,14 @@ public RealmObjectSchema get(String className) {
      * @return the set of all classes in this Realm or no RealmObject classes can be saved in the Realm.
      */
     public Set<RealmObjectSchema> getAll() {
-        int tableCount = (int) transaction.size();
+        int tableCount = (int) realm.sharedRealm.size();
         Set<RealmObjectSchema> schemas = new LinkedHashSet<>(tableCount);
         for (int i = 0; i < tableCount; i++) {
-            String tableName = transaction.getTableName(i);
-            if (Table.isMetaTable(tableName)) {
+            String tableName = realm.sharedRealm.getTableName(i);
+            if (!Table.isModelTable(tableName)) {
                 continue;
             }
-            Table table = transaction.getTable(tableName);
+            Table table = realm.sharedRealm.getTable(tableName);
             RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
             schemas.add(new RealmObjectSchema(realm, table, columnIndices));
         }
@@ -112,10 +109,10 @@ public RealmObjectSchema create(String className) {
         if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
             throw new IllegalArgumentException("Class name is to long. Limit is 57 characters: " + className.length());
         }
-        if (transaction.hasTable(internalTableName)) {
+        if (realm.sharedRealm.hasTable(internalTableName)) {
             throw new IllegalArgumentException("Class already exists: " + className);
         }
-        Table table = transaction.getTable(internalTableName);
+        Table table = realm.sharedRealm.getTable(internalTableName);
         RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
         return new RealmObjectSchema(realm, table, columnIndices);
     }
@@ -134,7 +131,7 @@ public void remove(String className) {
         if (table.hasPrimaryKey()) {
             table.setPrimaryKey(null);
         }
-        transaction.removeTable(internalTableName);
+        realm.sharedRealm.removeTable(internalTableName);
     }
 
     /**
@@ -150,7 +147,7 @@ public RealmObjectSchema rename(String oldClassName, String newClassName) {
         String oldInternalName = TABLE_PREFIX + oldClassName;
         String newInternalName = TABLE_PREFIX + newClassName;
         checkHasTable(oldClassName, "Cannot rename class because it doesn't exist in this Realm: " + oldClassName);
-        if (transaction.hasTable(newInternalName)) {
+        if (realm.sharedRealm.hasTable(newInternalName)) {
             throw new IllegalArgumentException(oldClassName + " cannot be renamed because the new class already exists: " + newClassName);
         }
 
@@ -162,8 +159,8 @@ public RealmObjectSchema rename(String oldClassName, String newClassName) {
             oldTable.setPrimaryKey(null);
         }
 
-        transaction.renameTable(oldInternalName, newInternalName);
-        Table table = transaction.getTable(newInternalName);
+        realm.sharedRealm.renameTable(oldInternalName, newInternalName);
+        Table table = realm.sharedRealm.getTable(newInternalName);
 
         // Set the primary key for the new class if necessary
         if (pkField != null) {
@@ -181,7 +178,7 @@ public RealmObjectSchema rename(String oldClassName, String newClassName) {
      * @return {@code true} if the class already exists. {@code false} otherwise.
      */
     public boolean contains(String className) {
-        return transaction.hasTable(Table.TABLE_PREFIX + className);
+        return realm.sharedRealm.hasTable(Table.TABLE_PREFIX + className);
     }
 
     private void checkEmpty(String str, String error) {
@@ -192,7 +189,7 @@ private void checkEmpty(String str, String error) {
 
     private void checkHasTable(String className, String errorMsg) {
         String internalTableName = TABLE_PREFIX + className;
-        if (!transaction.hasTable(internalTableName)) {
+        if (!realm.sharedRealm.hasTable(internalTableName)) {
             throw new IllegalArgumentException(errorMsg);
         }
     }
@@ -209,10 +206,10 @@ Table getTable(String className) {
         className = Table.TABLE_PREFIX + className;
         Table table = dynamicClassToTable.get(className);
         if (table == null) {
-            if (!transaction.hasTable(className)) {
+            if (!realm.sharedRealm.hasTable(className)) {
                 throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
             }
-            table = transaction.getTable(className);
+            table = realm.sharedRealm.getTable(className);
             dynamicClassToTable.put(className, table);
         }
         return table;
@@ -221,9 +218,19 @@ Table getTable(String className) {
     Table getTable(Class<? extends RealmModel> clazz) {
         Table table = classToTable.get(clazz);
         if (table == null) {
-            clazz = Util.getOriginalModelClass(clazz);
-            table = transaction.getTable(realm.configuration.getSchemaMediator().getTableName(clazz));
-            classToTable.put(clazz, table);
+            Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
+            if (isProxyClass(originalClass, clazz)) {
+                // if passed 'clazz' is the proxy, try again with model class
+                table = classToTable.get(originalClass);
+            }
+            if (table == null) {
+                table = realm.sharedRealm.getTable(realm.configuration.getSchemaMediator().getTableName(originalClass));
+                classToTable.put(originalClass, table);
+            }
+            if (isProxyClass(originalClass, clazz)) {
+                // 'clazz' is the proxy class for 'originalClass'
+                classToTable.put(clazz, table);
+            }
         }
         return table;
     }
@@ -231,22 +238,37 @@ Table getTable(Class<? extends RealmModel> clazz) {
     RealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
         RealmObjectSchema classSchema = classToSchema.get(clazz);
         if (classSchema == null) {
-            clazz = Util.getOriginalModelClass(clazz);
-            Table table = transaction.getTable(realm.configuration.getSchemaMediator().getTableName(clazz));
-            classSchema = new RealmObjectSchema(realm, table, columnIndices.getColumnInfo(clazz).getIndicesMap());
-            classToSchema.put(clazz, classSchema);
+            Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
+            if (isProxyClass(originalClass, clazz)) {
+                // if passed 'clazz' is the proxy, try again with model class
+                classSchema = classToSchema.get(originalClass);
+            }
+            if (classSchema == null) {
+                Table table = getTable(clazz);
+                classSchema = new RealmObjectSchema(realm, table, columnIndices.getColumnInfo(originalClass).getIndicesMap());
+                classToSchema.put(originalClass, classSchema);
+            }
+            if (isProxyClass(originalClass, clazz)) {
+                // 'clazz' is the proxy class for 'originalClass'
+                classToSchema.put(clazz, classSchema);
+            }
         }
         return classSchema;
     }
 
+    private static boolean isProxyClass(Class<? extends RealmModel> modelClass,
+                                        Class<? extends RealmModel> testee) {
+        return modelClass != testee;
+    }
+
     RealmObjectSchema getSchemaForClass(String className) {
         className = Table.TABLE_PREFIX + className;
         RealmObjectSchema dynamicSchema = dynamicClassToSchema.get(className);
         if (dynamicSchema == null) {
-            if (!transaction.hasTable(className)) {
+            if (!realm.sharedRealm.hasTable(className)) {
                 throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
             }
-            Table table = transaction.getTable(className);
+            Table table = realm.sharedRealm.getTable(className);
             RealmObjectSchema.DynamicColumnMap columnIndices = new RealmObjectSchema.DynamicColumnMap(table);
             dynamicSchema = new RealmObjectSchema(realm, table, columnIndices);
             dynamicClassToSchema.put(className, dynamicSchema);
@@ -254,10 +276,6 @@ RealmObjectSchema getSchemaForClass(String className) {
         return dynamicSchema;
     }
 
-    void setColumnIndices(ColumnIndices columnIndices) {
-        this.columnIndices = columnIndices;
-    }
-
     static String getSchemaForTable(Table table) {
         return table.getName().substring(Table.TABLE_PREFIX.length());
     }
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java
new file mode 100644
index 0000000000..a12f94368a
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.exceptions;
+
+import io.realm.internal.Keep;
+import io.realm.internal.SharedRealm;
+
+/**
+ * Class for reporting problems when accessing the Realm related files.
+ */
+@Keep
+public class RealmFileException extends RuntimeException {
+    /**
+     * The specific kind of this {@link RealmFileException}.
+     */
+    public enum Kind {
+        /**
+         * Thrown for any I/O related exception scenarios when a Realm is opened.
+         */
+        ACCESS_ERROR,
+        /**
+         * Thrown if the user does not have permission to open or create the specified file in the specified access
+         * mode when the Realm is opened.
+         */
+        PERMISSION_DENIED,
+        /**
+         * Thrown if the destination file exists but it is not supposed to.
+         */
+        EXISTS,
+        /**
+         * Thrown if the relevant file cannot be found.
+         */
+        NOT_FOUND,
+        /**
+         * Thrown if the database file is currently open in another process which cannot share with the current process
+         * due to an architecture mismatch.
+         */
+        INCOMPATIBLE_LOCK_FILE,
+        /**
+         * Thrown if the file needs to be upgraded to a new format, but upgrades have been explicitly disabled.
+         */
+        FORMAT_UPGRADE_REQUIRED;
+
+        // Created from byte values by JNI.
+        static Kind getKind(byte value) {
+            switch (value) {
+                case SharedRealm.FILE_EXCEPTION_KIND_ACCESS_ERROR:
+                    return ACCESS_ERROR;
+                case SharedRealm.FILE_EXCEPTION_KIND_PERMISSION_DENIED:
+                    return PERMISSION_DENIED;
+                case SharedRealm.FILE_EXCEPTION_KIND_EXISTS:
+                    return EXISTS;
+                case SharedRealm.FILE_EXCEPTION_KIND_NOT_FOUND:
+                    return NOT_FOUND;
+                case SharedRealm.FILE_EXCEPTION_KIND_IMCOMPATIBLE_LOCK_FILE:
+                    return INCOMPATIBLE_LOCK_FILE;
+                case SharedRealm.FILE_EXCEPTION_KIND_FORMAT_UPGRADE_REQUIRED:
+                    return FORMAT_UPGRADE_REQUIRED;
+                default:
+                    throw new RuntimeException("Unknown value for RealmFileException kind.");
+            }
+        }
+    }
+
+    private final Kind kind;
+
+    // Called by JNI
+    @SuppressWarnings("unused")
+    public RealmFileException(byte value, String message) {
+        super(message);
+        kind = Kind.getKind(value);
+    }
+
+    public RealmFileException(Kind kind, String message) {
+        super(message);
+        this.kind = kind;
+    }
+
+    public RealmFileException(Kind kind, Throwable cause) {
+        super(cause);
+        this.kind = kind;
+    }
+
+    public RealmFileException(Kind kind, String message, Throwable cause) {
+        super(message, cause);
+        this.kind = kind;
+    }
+
+    /**
+     * Gets the {@link #kind} of this exception.
+     *
+     * @return the {@link #kind} of this exception.
+     */
+    public Kind getKind() {
+        return kind;
+    }
+
+    @Override
+    public String toString() {
+        return String.format("%s Kind: %s.", super.toString(), kind);
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmIOException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmIOException.java
deleted file mode 100644
index 845093fbc7..0000000000
--- a/realm/realm-library/src/main/java/io/realm/exceptions/RealmIOException.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.exceptions;
-
-import io.realm.internal.Keep;
-
-/**
- * Class for reporting problems with Realm files.
- */
-@Keep
-public final class RealmIOException extends RuntimeException {
-
-    public RealmIOException(Throwable cause) {
-        super(cause);
-    }
-
-    public RealmIOException() {
-    }
-
-    public RealmIOException(String message) {
-        super(message);
-    }
-
-    public RealmIOException(String message, Throwable cause) {
-        super(message, cause);
-    }
-
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
index ae052e69fb..42c89a20c1 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
@@ -124,9 +124,7 @@ public void setNull(long columnIndex) {
     protected native String nativeGetString(long nativePtr, long columnIndex);
     protected native boolean nativeIsNullLink(long nativeRowPtr, long columnIndex);
     protected native byte[] nativeGetByteArray(long nativePtr, long columnIndex);
-    protected native int nativeGetMixedType(long nativePtr, long columnIndex);
-    protected native Mixed nativeGetMixed(long nativeRowPtr, long columnIndex);
-    protected native long nativeGetLinkView(long nativePtr, long columnIndex);
+    public static native long nativeGetLinkView(long nativePtr, long columnIndex);
     protected native void nativeSetLong(long nativeRowPtr, long columnIndex, long value);
     protected native void nativeSetBoolean(long nativeRowPtr, long columnIndex, boolean value);
     protected native void nativeSetFloat(long nativeRowPtr, long columnIndex, float value);
@@ -135,7 +133,6 @@ public void setNull(long columnIndex) {
     protected native void nativeSetTimestamp(long nativeRowPtr, long columnIndex, long dateTimeValue);
     protected native void nativeSetString(long nativeRowPtr, long columnIndex, String value);
     protected native void nativeSetByteArray(long nativePtr, long columnIndex, byte[] data);
-    protected native void nativeSetMixed(long nativeRowPtr, long columnIndex, Mixed data);
     protected native void nativeSetLink(long nativeRowPtr, long columnIndex, long value);
     protected native void nativeNullifyLink(long nativeRowPtr, long columnIndex);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
index 97e2934c3c..0e89e649ed 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
@@ -16,6 +16,7 @@
 
 package io.realm.internal;
 
+import java.util.HashMap;
 import java.util.Map;
 
 import io.realm.RealmModel;
@@ -23,14 +24,19 @@
 /**
  * Utility class used to cache the mapping between object field names and their column indices.
  */
-public class ColumnIndices {
+public final class ColumnIndices implements Cloneable {
+    private long schemaVersion;
+    private Map<Class<? extends RealmModel>, ColumnInfo> classes;
 
-    private final Map<Class<? extends RealmModel>, ColumnInfo> classes;
-
-    public ColumnIndices(Map<Class<? extends RealmModel>, ColumnInfo> classes) {
+    public ColumnIndices(long schemaVersion, Map<Class<? extends RealmModel>, ColumnInfo> classes) {
+        this.schemaVersion = schemaVersion;
         this.classes = classes;
     }
 
+    public long getSchemaVersion() {
+        return schemaVersion;
+    }
+
     /**
      * Returns {@link ColumnInfo} for the given class or {@code null} if no mapping exists.
      */
@@ -50,4 +56,35 @@ public long getColumnIndex(Class<? extends RealmModel> clazz, String fieldName)
             return -1;
         }
     }
+
+    @Override
+    public ColumnIndices clone() {
+        try {
+            final ColumnIndices clone = (ColumnIndices) super.clone();
+            clone.classes = duplicateColumnInfoMap();
+            return clone;
+        } catch (CloneNotSupportedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private Map<Class<? extends RealmModel>, ColumnInfo> duplicateColumnInfoMap() {
+        final Map<Class<? extends RealmModel>, ColumnInfo> copy = new HashMap<>();
+        for (Map.Entry<Class<? extends RealmModel>, ColumnInfo> entry : classes.entrySet()) {
+            copy.put(entry.getKey(), entry.getValue().clone());
+        }
+        return copy;
+    }
+
+    public void copyFrom(ColumnIndices other, RealmProxyMediator mediator) {
+        for (Map.Entry<Class<? extends RealmModel>, ColumnInfo> entry : classes.entrySet()) {
+            final ColumnInfo otherColumnInfo = other.getColumnInfo(entry.getKey());
+            if (otherColumnInfo == null) {
+                throw new IllegalStateException("Failed to copy ColumnIndices cache: "
+                        + Table.tableNameToClassName(mediator.getTableName(entry.getKey())));
+            }
+            entry.getValue().copyColumnInfoFrom(otherColumnInfo);
+        }
+        this.schemaVersion = other.schemaVersion;
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
index 1bd57372f8..3846930296 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
@@ -16,12 +16,11 @@
 
 package io.realm.internal;
 
-import java.util.Collections;
 import java.util.Map;
 
 import io.realm.exceptions.RealmMigrationNeededException;
 
-public class ColumnInfo {
+public abstract class ColumnInfo implements Cloneable {
     private Map<String, Long> indicesMap;
 
     protected final long getValidColumnIndex(String realmPath, Table table,
@@ -34,11 +33,40 @@ protected final long getValidColumnIndex(String realmPath, Table table,
         return columnIndex;
     }
 
-    protected final void setIndicesMap(Map<String, Long> indicesMap) {
-        this.indicesMap = Collections.unmodifiableMap(indicesMap);
-    }
-
+    /**
+     * Returns a map from column name to column index.
+     *
+     * @return a map from column name to column index. Do not modify returned map because it may be
+     * shared among other {@link ColumnInfo} instances.
+     */
     public Map<String, Long> getIndicesMap() {
         return indicesMap;
     }
+
+    protected final void setIndicesMap(Map<String, Long> indicesMap) {
+        this.indicesMap = indicesMap;
+    }
+
+    /**
+     * Copies the column index value from other {@link ColumnInfo} object.
+     *
+     * @param other The class of {@code other} must be exactly the same as this instance.
+     *              It must not be {@code null}.
+     * @throws IllegalArgumentException if {@code other} has different class than this.
+     */
+    public abstract void copyColumnInfoFrom(ColumnInfo other);
+
+    /**
+     * Returns a shallow copy of this instance.
+     *
+     * @return shallow copy.
+     */
+    @Override
+    public ColumnInfo clone() {
+        try {
+            return (ColumnInfo) super.clone();
+        } catch (CloneNotSupportedException e) {
+            throw new RuntimeException(e);
+        }
+    };
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Context.java b/realm/realm-library/src/main/java/io/realm/internal/Context.java
index 8d241d0043..66b236a786 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Context.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Context.java
@@ -133,14 +133,6 @@ public void asyncDisposeQuery(long nativePointer) {
         }
     }
 
-    public void asyncDisposeGroup(long nativePointer) {
-        Group.nativeClose(nativePointer);
-    }
-
-    public void asyncDisposeSharedGroup(long nativePointer) {
-        SharedGroup.nativeClose(nativePointer);
-    }
-
     protected void finalize() throws Throwable {
         synchronized (this) {
             isFinalized = true;
diff --git a/realm/realm-library/src/main/java/io/realm/internal/DefineTable.java b/realm/realm-library/src/main/java/io/realm/internal/DefineTable.java
deleted file mode 100644
index c4ed8e4632..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/DefineTable.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
- * This annotation is used to mark the classes that serve as entity description.
- * For each such class, e.g. Xyz, the classes XyzTable, XyzView, XyzRow and XyzQuery will be generated.
- */
-@Retention(RetentionPolicy.SOURCE)
-@Target(ElementType.TYPE)
-public @interface DefineTable {
-
-    String row() default "";
-
-    String table() default "";
-
-    String view() default "";
-
-    String query() default "";
-
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Group.java b/realm/realm-library/src/main/java/io/realm/internal/Group.java
deleted file mode 100644
index 3b5cc85ef2..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/Group.java
+++ /dev/null
@@ -1,290 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import java.io.Closeable;
-import java.io.File;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-
-/**
- * This class is used to serialize tables to either disk or memory. It consists of a collection of tables.
- */
-public class Group implements Closeable {
-
-    // Below values must match the values in realm::group::OpenMode in C++
-    public static final int MODE_READONLY = 0; // Open in read-only mode. Fail if the file does not already exist.
-    public static final int MODE_READWRITE = 1; // Open in read/write mode. Create the file if it doesn't exist.
-    public static final int MODE_READWRITE_NOCREATE = 2; // Open in read/write mode. Fail if the file does not already exist.
-
-    protected long nativePtr;
-    protected boolean immutable;
-    private final Context context;
-
-    private void checkNativePtrNotZero() {
-        if (this.nativePtr == 0)
-            // FIXME: It is wrong to assume that a null pointer means 'out
-            // of memory'. An out of memory condition in
-            // createNative() must be handled by having createNative()
-            // throw OutOfMemoryError.
-            throw new OutOfMemoryError("Out of native memory.");
-    }
-
-    public Group() {
-        this.immutable = false;
-        this.context = new Context();
-        this.nativePtr = createNative();
-        checkNativePtrNotZero();
-    }
-
-    public Group(String filepath, int mode) {
-        this.immutable = (mode == MODE_READONLY);
-        this.context = new Context();
-        this.nativePtr = createNative(filepath, mode);
-        checkNativePtrNotZero();
-    }
-
-    public Group(String filepath) {
-        this(filepath, MODE_READONLY);
-    }
-
-    public Group(File file) {
-        this(file.getAbsolutePath(), file.canWrite() ? MODE_READWRITE : MODE_READONLY);
-    }
-
-    public Group(byte[] data) {
-        this.immutable = false;
-        this.context = new Context();
-        if (data != null) {
-            this.nativePtr = createNative(data);
-            checkNativePtrNotZero();
-        } else {
-            throw new IllegalArgumentException();
-        }
-    }
-
-    public Group(ByteBuffer buffer) {
-        this.immutable = false;
-        this.context = new Context();
-        if (buffer != null) {
-            this.nativePtr = createNative(buffer);
-            checkNativePtrNotZero();
-        } else {
-            throw new IllegalArgumentException();
-        }
-    }
-
-    Group(Context context, long nativePointer, boolean immutable) {
-        this.context = context;
-        this.nativePtr = nativePointer;
-        this.immutable = immutable;
-    }
-
-    // If close() is called, no penalty is paid for delayed disposal
-    // via the context
-    public void close() {
-        synchronized (context) {
-            if (nativePtr != 0) {
-                nativeClose(nativePtr);
-                nativePtr = 0;
-            }
-        }
-    }
-
-    /**
-     * Checks if a group has been closed and can no longer be used.
-     *
-     * @return {@code true} if closed, {@code false} otherwise.
-     */
-    boolean isClosed() {
-        return nativePtr == 0;
-    }
-
-    protected void finalize() {
-        synchronized (context) {
-            if (nativePtr != 0) {
-                context.asyncDisposeGroup(nativePtr);
-                nativePtr = 0; // Set to 0 if finalize is called before close() for some reason
-            }
-        }
-    }
-
-    private void verifyGroupIsValid() {
-        if (nativePtr == 0) {
-            throw new IllegalStateException("Illegal to call methods on a closed Group.");
-        }
-    }
-
-    public long size() {
-        verifyGroupIsValid();
-        return nativeSize(nativePtr);
-    }
-
-    public boolean isEmpty(){
-        return size() == 0;
-    }
-
-    /**
-     * Checks whether {@link Table} exists in the Group.
-     *
-     * @param name the name of the {@link Table}.
-     * @return {@code true} if the table exists, otherwise {@code false}.
-     */
-    public boolean hasTable(String name) {
-        verifyGroupIsValid();
-        return name != null && nativeHasTable(nativePtr, name);
-    }
-
-    public String getTableName(int index) {
-        verifyGroupIsValid();
-        long cnt = size();
-        if (index < 0 || index >= cnt) {
-            throw new IndexOutOfBoundsException(
-                    "Table index argument is out of range. possible range is [0, "
-                    + (cnt - 1) + "]");
-        }
-        return nativeGetTableName(nativePtr, index);
-    }
-
-    /**
-     * Removes a table from the group and delete all data.
-     */
-    public void removeTable(String name) {
-        nativeRemoveTable(nativePtr, name);
-    }
-
-    native void nativeRemoveTable(long nativeGroupPtr, String tableName);
-
-    /**
-     * Renames a table
-     */
-    public void renameTable(String oldName, String newName) {
-        nativeRenameTable(nativePtr, oldName, newName);
-    }
-
-    native void nativeRenameTable(long nativeGroupPtr, String oldName, String newName);
-
-    /**
-     * Returns a table with the specified name.
-     *
-     * @param name the name of the {@link Table}.
-     * @return the {@link Table} if it exists, otherwise create it.
-     */
-    public Table getTable(String name) {
-        verifyGroupIsValid();
-        if (name == null || name.isEmpty()) {
-            throw new IllegalArgumentException("Invalid name. Name must be a non-empty String.");
-        }
-        if (immutable && !hasTable(name)) {
-            throw new IllegalStateException("Requested table is not in this Realm. " +
-                    "Creating it requires a transaction: " + name);
-        }
-
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        long nativeTablePointer = nativeGetTableNativePtr(nativePtr, name);
-        try {
-            // Copy context reference from parent
-            return new Table(context, this, nativeTablePointer);
-        } catch (RuntimeException e) {
-            Table.nativeClose(nativeTablePointer);
-            throw e;
-        }
-    }
-
-    /**
-     * Serializes the group to the specific file on the disk using encryption.
-     *
-     * @param file a File object representing the file.
-     * @param key A 64 bytes long byte array containing the key to the encrypted Realm file. Can be null if encryption
-     *            is not required.
-     * @throws IOException.
-     */
-    public void writeToFile(File file, byte[] key) throws IOException {
-        verifyGroupIsValid();
-        if (file.isFile() && file.exists()) {
-            throw new IllegalArgumentException("The destination file must not exist");
-        }
-        if (key != null && key.length != 64) {
-            throw new IllegalArgumentException("Realm AES keys must be 64 bytes long");
-        }
-
-        nativeWriteToFile(nativePtr, file.getAbsolutePath(), key);
-    }
-
-    /**
-     * Serializes the group to a memory buffer. The byte[] is owned by the JVM.
-     *
-     * @return the binary array of the serialized group.
-     */
-    public byte[] writeToMem() {
-        verifyGroupIsValid();
-        return nativeWriteToMem(nativePtr);
-    }
-
-    /*
-     * Checks if the Group contains any objects. It only checks for "class_" tables or non-metadata tables, e.g. this
-     * return true if the "pk" table contained information.
-     *
-     * @return {@code true} if empty, @{code false} otherwise.
-     */
-    public boolean isObjectTablesEmpty() {
-        return nativeIsEmpty(nativePtr);
-    }
-
-/*
- * TODO: Find a way to release the malloc'ed native memory automatically
-
-    public ByteBuffer writeToByteBuffer() {
-        verifyGroupIsValid();
-        return nativeWriteToByteBuffer(nativePtr);
-    }
-
-    protected native ByteBuffer nativeWriteToByteBuffer(long nativeGroupPtr);
-*/
-
-    public void commit() {
-        verifyGroupIsValid();
-        nativeCommit(nativePtr);
-    }
-
-    public String toJson() {
-        return nativeToJson(nativePtr);
-    }
-
-    public String toString() {
-        return nativeToString(nativePtr);
-    }
-
-
-    protected native long createNative();
-    protected native long createNative(String filepath, int value);
-    protected native long createNative(byte[] data);
-    protected native long createNative(ByteBuffer buffer);
-    protected static native void nativeClose(long nativeGroupPtr);
-    protected native long nativeSize(long nativeGroupPtr);
-    protected native String nativeGetTableName(long nativeGroupPtr, int index);
-    protected native boolean nativeHasTable(long nativeGroupPtr, String name);
-    protected native void nativeWriteToFile(long nativeGroupPtr, String fileName, byte[] keyArray) throws IOException;
-    protected native long nativeGetTableNativePtr(long nativeGroupPtr, String name);
-    protected native long nativeLoadFromMem(byte[] buffer);
-    protected native byte[] nativeWriteToMem(long nativeGroupPtr);
-    protected native String nativeToJson(long nativeGroupPtr);
-    protected native void nativeCommit(long nativeGroupPtr);
-    protected native String nativeToString(long nativeGroupPtr);
-    protected native boolean nativeIsEmpty(long nativeGroupPtr);
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/HandlerControllerConstants.java b/realm/realm-library/src/main/java/io/realm/internal/HandlerControllerConstants.java
new file mode 100644
index 0000000000..029c91bc02
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/HandlerControllerConstants.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+/**
+ * This class is to share some Android handler related constants between package {@link io.realm} and
+ * {@link io.realm.internal.async}.
+ */
+public final class HandlerControllerConstants {
+    public static final int REALM_CHANGED = 14930352; // Hopefully it won't clash with other message IDs.
+    public static final int COMPLETED_UPDATE_ASYNC_QUERIES = 24157817;
+    public static final int COMPLETED_ASYNC_REALM_RESULTS = 39088169;
+    public static final int COMPLETED_ASYNC_REALM_OBJECT = 63245986;
+    public static final int REALM_ASYNC_BACKGROUND_EXCEPTION = 102334155;
+    public static final int LOCAL_COMMIT = 165580141;
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ImplicitTransaction.java b/realm/realm-library/src/main/java/io/realm/internal/ImplicitTransaction.java
deleted file mode 100644
index cd6a3c62eb..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/ImplicitTransaction.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import io.realm.internal.async.BadVersionException;
-
-public class ImplicitTransaction extends Group {
-
-    private final SharedGroup parent;
-
-    public ImplicitTransaction(Context context, SharedGroup sharedGroup, long nativePtr) {
-        super(context, nativePtr, true);
-        parent = sharedGroup;
-    }
-
-    /**
-     * Positions the shared group to the latest version.
-     */
-    public void advanceRead() {
-        assertNotClosed();
-        parent.advanceRead();
-    }
-
-    /**
-     * Positions the shared group at the specified version.
-     *
-     * @param versionID version of the shared group.
-     */
-    public void advanceRead(SharedGroup.VersionID versionID) throws BadVersionException {
-        assertNotClosed();
-        parent.advanceRead(versionID);
-    }
-
-    public void promoteToWrite() {
-        assertNotClosed();
-        if (!immutable) {
-            throw new IllegalStateException("Nested transactions are not allowed. Use commitTransaction() after each beginTransaction().");
-        }
-        immutable = false;
-        parent.promoteToWrite();
-    }
-
-    public void commitAndContinueAsRead() {
-        assertNotClosed();
-        if (immutable) {
-            throw new IllegalStateException("Not inside a transaction.");
-        }
-        parent.commitAndContinueAsRead();
-        immutable = true;
-    }
-
-    public void endRead() {
-        assertNotClosed();
-        parent.endRead();
-    }
-
-    public void rollbackAndContinueAsRead() {
-        assertNotClosed();
-        if (immutable) {
-            throw new IllegalStateException("Not inside a transaction.");
-        }
-        parent.rollbackAndContinueAsRead();
-        immutable = true;
-    }
-
-    private void assertNotClosed() {
-        if (isClosed() || parent.isClosed()) {
-            throw new IllegalStateException("Cannot use ImplicitTransaction after it or its parent has been closed.");
-        }
-    }
-
-    /**
-     * Returns the absolute path to the Realm file backing this transaction.
-     */
-    public String getPath() {
-        return parent.getPath();
-    }
-
-    protected void finalize() {} // Nullify the actions of Group.finalize()
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java b/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java
index cb708bf4ac..eab9406359 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java
@@ -93,16 +93,6 @@ public String getString(long columnIndex) {
         throw getStubException();
     }
 
-    @Override
-    public Mixed getMixed(long columnIndex) {
-        throw getStubException();
-    }
-
-    @Override
-    public RealmFieldType getMixedType(long columnIndex) {
-        throw getStubException();
-    }
-
     @Override
     public long getLink(long columnIndex) {
         throw getStubException();
@@ -153,11 +143,6 @@ public void setBinaryByteArray(long columnIndex, byte[] data) {
         throw getStubException();
     }
 
-    @Override
-    public void setMixed(long columnIndex, Mixed data) {
-        throw getStubException();
-    }
-
     @Override
     public void setLink(long columnIndex, long value) {
         throw getStubException();
diff --git a/realm/realm-library/src/main/java/io/realm/internal/LinkView.java b/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
index 3e6869ffeb..6ba77cc800 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
@@ -62,8 +62,11 @@ public CheckedRow getCheckedRow(long index) {
         return CheckedRow.get(context, this, index);
     }
 
-    public long getTargetRowIndex(long pos) {
-        return nativeGetTargetRowIndex(nativePointer, pos);
+    /**
+     * Returns the row index in the underlying table.
+     */
+    public long getTargetRowIndex(long linkViewIndex) {
+        return nativeGetTargetRowIndex(nativePointer, linkViewIndex);
     }
 
     public void add(long rowIndex) {
@@ -154,7 +157,7 @@ public Table getTargetTable() {
         long nativeTablePointer = nativeGetTargetTable(nativePointer);
         try {
             // Copy context reference from parent
-            return new Table(context, this.parent, nativeTablePointer);
+            return new Table(this.parent, nativeTablePointer);
         } catch (RuntimeException e) {
             Table.nativeClose(nativeTablePointer);
             throw e;
@@ -167,15 +170,15 @@ private void checkImmutable() {
         }
     }
 
-    static native void nativeClose(long nativeLinkViewPtr);
+    public static native void nativeClose(long nativeLinkViewPtr);
     native long nativeGetRow(long nativeLinkViewPtr, long pos);
-    private native long nativeGetTargetRowIndex(long nativeLinkViewPtr, long pos);
-    private native void nativeAdd(long nativeLinkViewPtr, long rowIndex);
+    private native long nativeGetTargetRowIndex(long nativeLinkViewPtr, long linkViewIndex);
+    public static native void nativeAdd(long nativeLinkViewPtr, long rowIndex);
     private native void nativeInsert(long nativeLinkViewPtr, long pos, long rowIndex);
     private native void nativeSet(long nativeLinkViewPtr, long pos, long rowIndex);
     private native void nativeMove(long nativeLinkViewPtr, long oldPos, long newPos);
     private native void nativeRemove(long nativeLinkViewPtr, long pos);
-    private native void nativeClear(long nativeLinkViewPtr);
+    public static native void nativeClear(long nativeLinkViewPtr);
     private native long nativeSize(long nativeLinkViewPtr);
     private native boolean nativeIsEmpty(long nativeLinkViewPtr);
     protected native long nativeWhere(long nativeLinkViewPtr);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Mixed.java b/realm/realm-library/src/main/java/io/realm/internal/Mixed.java
deleted file mode 100644
index af103c077b..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/Mixed.java
+++ /dev/null
@@ -1,255 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import java.nio.ByteBuffer;
-import java.util.Arrays;
-import java.util.Date;
-
-import io.realm.RealmFieldType;
-
-public class Mixed {
-
-    public static final int BINARY_TYPE_BYTE_ARRAY = 0;
-    public static final int BINARY_TYPE_BYTE_BUFFER = 1;
-
-    private Object value;
-
-    public Mixed(long value) {
-        this.value = value;
-    }
-
-    public Mixed(float value) {
-        this.value = value;
-    }
-
-    public Mixed(double value) {
-        this.value = value;
-    }
-
-    public Mixed(RealmFieldType columnType) {
-        // It's actually ok to call with any columnType - it will however be assumed to be a ColumnTypeTable.
-        if (columnType == null  || columnType == RealmFieldType.UNSUPPORTED_TABLE) {
-            throw new AssertionError();
-        }
-        this.value = null;
-    }
-
-    public Mixed(boolean value) {
-        this.value = value ? Boolean.TRUE : Boolean.FALSE;
-    }
-
-    public Mixed(Date value) {
-        assert (value != null);
-        this.value = value;
-    }
-
-    public Mixed(String value) {
-        assert (value != null);
-        this.value = value;
-    }
-
-    public Mixed(ByteBuffer value) {
-        assert (value != null);
-        this.value = value;
-    }
-
-    public Mixed(byte[] value) {
-        assert (value != null);
-        this.value = value;
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (this == obj) {
-            return true;
-        }
-        if (obj == null || getClass() != obj.getClass()) {
-            return false;
-        }
-
-        Mixed mixed = (Mixed) obj;
-
-        if (value.getClass() != mixed.value.getClass()) {
-            return false;
-        }
-
-        if (value instanceof byte[]) {
-            return Arrays.equals((byte[]) value, (byte[]) mixed.value);
-        }
-        if (value instanceof ByteBuffer) {
-            return ((ByteBuffer) value).compareTo((ByteBuffer) mixed.value) == 0;
-        }
-        return value.equals(mixed.value);
-    }
-
-    @Override
-    public int hashCode() {
-        if (value instanceof byte[]) {
-            return Arrays.hashCode((byte[]) value);
-        }
-        return value.hashCode();
-    }
-
-    public RealmFieldType getType() {
-        if (value == null) {
-            return RealmFieldType.UNSUPPORTED_TABLE;
-        }
-        if (value instanceof String)
-            return RealmFieldType.STRING;
-        else if (value instanceof Long)
-            return RealmFieldType.INTEGER;
-        else if (value instanceof Float)
-            return RealmFieldType.FLOAT;
-        else if (value instanceof Double)
-            return RealmFieldType.DOUBLE;
-        else if (value instanceof Date)
-            return RealmFieldType.DATE;
-        else if (value instanceof Boolean)
-            return RealmFieldType.BOOLEAN;
-        else if (value instanceof ByteBuffer || (value instanceof byte[])) {
-            return RealmFieldType.BINARY;
-        }
-
-        throw new IllegalStateException("Unknown column type!");
-    }
-
-    public static Mixed mixedValue(Object value) {
-        // TODO: Isn't it a slow way to convert? Can it be done faster?
-        if (value instanceof String) {
-            return new Mixed((String) value);
-        } else if (value instanceof Long) {
-            return new Mixed((Long) value);
-        } else if (value instanceof Integer) {
-            return new Mixed(((Integer)value).longValue());
-        } else if (value instanceof Boolean) {
-            return new Mixed((Boolean) value);
-        } else if (value instanceof Float) {
-            return new Mixed((Float) value);
-        } else if (value instanceof Double) {
-            return new Mixed((Double) value);
-        } else if (value instanceof Date) {
-            return new Mixed((Date) value);
-        } else if (value instanceof ByteBuffer) {
-            return new Mixed((ByteBuffer) value);
-        } else if (value instanceof byte[]) {
-            return new Mixed((byte[]) value);
-        } else if (value instanceof Mixed) {
-            return ((Mixed)(value));
-        } else {
-            throw new IllegalArgumentException("The value is of unsupported type: " + value.getClass());
-        }
-    }
-
-    public long getLongValue() {
-        if (!(value instanceof Long)) {
-            throw new IllegalMixedTypeException("Can't get a long from a Mixed containing a " + getType());
-        }
-        return (Long) value;
-    }
-
-    public boolean getBooleanValue() {
-        if (!(value instanceof Boolean))
-            throw new IllegalMixedTypeException("Can't get a boolean from a Mixed containing a " + getType());
-        return (Boolean) value;
-    }
-
-    public float getFloatValue() {
-        if (!(value instanceof Float))
-            throw new IllegalMixedTypeException("Can't get a float from a Mixed containing a " + getType());
-        return (Float) value;
-    }
-
-    public double getDoubleValue() {
-        if (!(value instanceof Double))
-            throw new IllegalMixedTypeException("Can't get a double from a Mixed containing a " + getType());
-        return (Double) value;
-    }
-
-    public String getStringValue() {
-        if (!(value instanceof String))
-            throw new IllegalMixedTypeException("Can't get a String from a Mixed containing a " + getType());
-        return (String) value;
-    }
-
-    public Date getDateValue() {
-        if (!(value instanceof Date)) {
-            throw new IllegalMixedTypeException("Can't get a Date from a Mixed containing a " + getType());
-        }
-        return (Date) value;
-    }
-
-    protected long getDateTimeValue() {
-        return getDateValue().getTime();
-    }
-
-    public ByteBuffer getBinaryValue() {
-        if (!(value instanceof ByteBuffer)) {
-            throw new IllegalMixedTypeException("Can't get a ByteBuffer from a Mixed containing a " + getType());
-        }
-        return (ByteBuffer) value;
-    }
-
-    public byte[] getBinaryByteArray() {
-        if (!(value instanceof byte[])) {
-            throw new IllegalMixedTypeException("Can't get a byte[] from a Mixed containing a " + getType());
-        }
-        return (byte[]) value;
-    }
-
-    public int getBinaryType() {
-        if (value instanceof byte[]) {
-            return BINARY_TYPE_BYTE_ARRAY;
-        }
-        if (value instanceof ByteBuffer) {
-            return BINARY_TYPE_BYTE_BUFFER;
-        }
-        return -1;
-    }
-
-    public Object getValue() {
-        return value;
-    }
-
-    public String getReadableValue() {
-        RealmFieldType type = getType();
-        try {
-            switch (type) {
-            case BINARY:
-                return "Binary";
-            case BOOLEAN:
-                return String.valueOf(getBooleanValue());
-            case DATE:
-                return String.valueOf(getDateValue());
-            case DOUBLE:
-                return String.valueOf(getDoubleValue());
-            case FLOAT:
-                return String.valueOf(getFloatValue());
-            case INTEGER:
-                return String.valueOf(getLongValue());
-            case STRING:
-                return String.valueOf(getStringValue());
-            case UNSUPPORTED_TABLE:
-                return "Subtable";
-            case UNSUPPORTED_MIXED:
-                break; // error
-            }
-        } catch (Exception ignored) {
-        }
-        return "ERROR";
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ReadTransaction.java b/realm/realm-library/src/main/java/io/realm/internal/ReadTransaction.java
deleted file mode 100644
index dac99bc040..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/ReadTransaction.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-public class ReadTransaction extends Group {
-
-    private final SharedGroup db;
-
-    ReadTransaction(Context context, SharedGroup db, long nativePointer) {
-        super(context, nativePointer, true); // make Group immutable
-        this.db = db;
-    }
-
-    public void endRead() {
-        db.endRead();
-    }
-
-    @Override
-    public void close() {
-        db.endRead();
-    }
-
-    protected void finalize() {} // Nullify the actions of Group.finalize()
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmCore.java b/realm/realm-library/src/main/java/io/realm/internal/RealmCore.java
index 78deddf9b5..b89e49e9d3 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmCore.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmCore.java
@@ -69,8 +69,6 @@ public static synchronized void loadLibrary() {
             System.loadLibrary(jnilib);
         }
         libraryIsLoaded = true;
-
-        Version.coreLibVersionCompatible(true);
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java b/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
new file mode 100644
index 0000000000..d3464b2027
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import io.realm.internal.async.QueryUpdateTask;
+
+/**
+ * This interface needs to be implemented by Java and pass to Realm Object Store in order to get notifications when
+ * other thread/process changes the Realm file.
+ */
+@Keep
+public interface RealmNotifier {
+    /**
+     * This is called from Java when the changes have been made on the same thread.
+     */
+    void notifyCommitByLocalThread();
+
+    /**
+     * This is called in Realm Object Store's JavaBindingContext::changes_available.
+     * This is getting called on the same thread which created this Realm when the same Realm file has been changed by
+     * other thread. The changes on the same thread should not trigger this call.
+     */
+    @SuppressWarnings("unused")
+    void notifyCommitByOtherThread();
+
+    /**
+     * Post a runnable to be run in the next event loop on the thread which creates the corresponding Realm.
+     *
+     * @param runnable to be posted.
+     */
+    void post(Runnable runnable);
+
+    /**
+     * Is the current notifier valid? eg. Notifier created on non-looper thread cannot be notified.
+     *
+     * @return {@code true} if the thread which owns this notifier can be notified. Otherwise {@code false}
+     */
+    boolean isValid();
+
+    /**
+     * Called when close SharedRealm to clean up any event left in to queue.
+     */
+    void close();
+
+    // FIXME: These are for decoupling handler from async query. Async query needs refactor to either adapt the OS or
+    //        abstract the logic from Android handlers.
+    void completeAsyncResults(QueryUpdateTask.Result result);
+    void completeAsyncObject(QueryUpdateTask.Result result);
+    void throwBackgroundException(Throwable throwable);
+    void completeUpdateAsyncQueries(QueryUpdateTask.Result result);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
index a3e0778864..b0ec6a9bfa 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
@@ -21,6 +21,7 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 
+import java.util.Collection;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -45,18 +46,22 @@
      * Creates the backing table in Realm for the given RealmObject class.
      *
      * @param clazz the {@link RealmObject} model class to create backing table for.
-     * @param transaction the read transaction for the Realm to create table in.
+     * @param sharedRealm the wrapper object of underlying native database.
      */
-    public abstract Table createTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction);
+    public abstract Table createTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm);
 
     /**
      * Validates the backing table in Realm for the given RealmObject class.
      *
      * @param clazz the {@link RealmObject} model class to validate.
-     * @param transaction the read transaction for the Realm to validate against.
+     * @param sharedRealm the wrapper object of underlying native database to validate against.
+     * @param allowExtraColumns if {@code} false, {@link io.realm.exceptions.RealmMigrationNeededException}
+     *                          is thrown when the column count it more than expected.
      * @return the field indices map.
      */
-    public abstract ColumnInfo validateTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction);
+    public abstract ColumnInfo validateTable(Class<? extends RealmModel> clazz,
+                                             SharedRealm sharedRealm,
+                                             boolean allowExtraColumns);
 
     /**
      * Returns a map of non-obfuscated object field names to their internal Realm name.
@@ -80,10 +85,19 @@
      * Creates a new instance of an {@link RealmObjectProxy} for the given RealmObject class.
      *
      * @param clazz the {@link RealmObject} to create {@link RealmObjectProxy} for.
-     * @param columnInfo the {@link ColumnInfo} object for the RealmObject class of {@code E}.
+     * @param acceptDefaultValue {@code true} to accept the values set in the constructor, {@code false} otherwise.
+     * @param excludeFields the column names whose default value will be ignored if the {@code acceptDefaultValue}
+     *                       is {@code true}. Only {@link io.realm.RealmModel} and {@link io.realm.RealmList}
+     *                       column will respect this.
+     *                       No effects if the {@code acceptDefaultValue} is {@code false}.
      * @return created {@link RealmObjectProxy} object.
      */
-    public abstract <E extends RealmModel> E newInstance(Class<E> clazz, ColumnInfo columnInfo);
+    public abstract <E extends RealmModel> E newInstance(Class<E> clazz,
+                                                         Object baseRealm,
+                                                         Row row,
+                                                         ColumnInfo columnInfo,
+                                                         boolean acceptDefaultValue,
+                                                         List<String> excludeFields);
 
     /**
      * Returns the list of RealmObject classes that can be saved in this Realm.
@@ -93,9 +107,10 @@
     public abstract Set<Class<? extends RealmModel>> getModelClasses();
 
     /**
-     * Copies a non-managed {@link RealmObject} or a RealmObject from another Realm to this Realm. After being copied
+     * Copies an unmanaged {@link RealmObject} or a RealmObject from another Realm to this Realm. After being copied
      * any changes to the original object will not be persisted.
      *
+     * @param realm reference to the {@link Realm} where the object will be copied.
      * @param object the object to copy properties from.
      * @param update {@code true} if object has a primary key and should try to update already existing data,
      * {@code false} otherwise.
@@ -104,6 +119,47 @@
      */
     public abstract <E extends RealmModel> E copyOrUpdate(Realm realm, E object, boolean update, Map<RealmModel, RealmObjectProxy> cache);
 
+    /**
+     * Insert an unmanaged RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map)} since it
+     * doesn't return the inserted elements, and performs minimum allocations and checks.
+     * After being inserted any changes to the original object will not be persisted.
+     *
+     * @param realm reference to the {@link Realm} where the object will be inserted.
+     * @param object {@link RealmObject} to insert.
+     * @param cache the cache for mapping between unmanaged objects and their table row index for eventual reuse.
+     */
+    public abstract void insert(Realm realm, RealmModel object, Map<RealmModel, Long> cache);
+
+    /**
+     * Insert or update a RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map)} since it
+     * doesn't return the inserted elements, and performs minimum allocations and checks.
+     * After being inserted any changes to the original object will not be persisted.
+     *
+     * @param realm reference to the {@link Realm} where the objecs will be inserted.
+     * @param object {@link RealmObject} to insert.
+     * @param cache the cache for mapping between unmanaged objects and their table row index for eventual reuse.
+     */
+    public abstract void insertOrUpdate(Realm realm, RealmModel object, Map<RealmModel, Long> cache);
+
+    /**
+     * Insert or update a RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map)} since it
+     * doesn't return the inserted elements, and performs minimum allocations and checks.
+     * After being inserted any changes to the original objects will not be persisted.
+     *
+     * @param realm reference to the {@link Realm} where the objects will be inserted.
+     * @param objects Collection of {@link RealmObject} to insert or update. This must not be empty.
+     */
+    public abstract void insertOrUpdate(Realm realm, Collection<? extends RealmModel> objects);
+
+    /**
+     * Insert a RealmObject. This is generally faster than {@link #copyOrUpdate(Realm, RealmModel, boolean, Map)} since it
+     * doesn't return the inserted elements, and performs minimum allocations and checks. After being inserted any changes to the original objects will not be persisted.
+     *
+     * @param realm reference to the {@link Realm} where the objects will be inserted.
+     * @param objects Collection of {@link RealmObject} to insert or update. This must not be empty.
+     */
+    public abstract void insert(Realm realm, Collection<? extends RealmModel> objects);
+
     /**
      * Creates or updates a {@link RealmObject} using the provided JSON data.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Row.java b/realm/realm-library/src/main/java/io/realm/internal/Row.java
index d61a0bc531..b63f85fd34 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Row.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Row.java
@@ -69,10 +69,6 @@
 
     byte[] getBinaryByteArray(long columnIndex);
 
-    Mixed getMixed(long columnIndex);
-
-    RealmFieldType getMixedType(long columnIndex);
-
     long getLink(long columnIndex);
 
     boolean isNullLink(long columnIndex);
@@ -93,8 +89,6 @@
 
     void setBinaryByteArray(long columnIndex, byte[] data);
 
-    void setMixed(long columnIndex, Mixed data);
-
     void setLink(long columnIndex, long value);
 
     void nullifyLink(long columnIndex);
@@ -119,8 +113,8 @@
     boolean hasColumn(String fieldName);
 
     Row EMPTY_ROW = new Row() {
-        private final static String UNLOADED_ROW_MESSAGE = "Can't access a row that hasn't been loaded, make sure the instance" +
-                " is loaded by calling RealmObject.isLoaded().";
+        private final static String UNLOADED_ROW_MESSAGE = "Can't access a row that hasn't been loaded or represents 'null', " +
+                "make sure the instance is loaded and is valid by calling 'RealmObject.isLoaded() && RealmObject.isValid()'.";
 
         @Override
         public long getColumnCount() {
@@ -187,16 +181,6 @@ public String getString(long columnIndex) {
             throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
         }
 
-        @Override
-        public Mixed getMixed(long columnIndex) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public RealmFieldType getMixedType(long columnIndex) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
         @Override
         public long getLink(long columnIndex) {
             throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
@@ -257,11 +241,6 @@ public void setBinaryByteArray(long columnIndex, byte[] data) {
             throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
         }
 
-        @Override
-        public void setMixed(long columnIndex, Mixed data) {
-            throw new IllegalStateException();
-        }
-
         @Override
         public void setLink(long columnIndex, long value) {
             throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedGroup.java b/realm/realm-library/src/main/java/io/realm/internal/SharedGroup.java
deleted file mode 100644
index 9b640619ee..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedGroup.java
+++ /dev/null
@@ -1,341 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import java.io.Closeable;
-import java.io.IOError;
-
-import io.realm.exceptions.RealmIOException;
-import io.realm.internal.async.BadVersionException;
-
-public class SharedGroup implements Closeable {
-
-    public static final boolean IMPLICIT_TRANSACTION = true;
-    public static final boolean EXPLICIT_TRANSACTION = false;
-
-    private static final boolean CREATE_FILE_YES = false;
-    private static final boolean CREATE_FILE_NO = true;
-    private static final boolean ENABLE_REPLICATION = true;
-    private static final boolean DISABLE_REPLICATION = false;
-
-    private final String path;
-    private long nativePtr;
-    private long nativeReplicationPtr;
-    private boolean implicitTransactionsEnabled = false;
-    private boolean activeTransaction;
-    private final Context context;
-
-    public enum Durability {
-        FULL(0),
-        MEM_ONLY(1);
-        //ASYNC(2); // TODO: re-enable when possible
-
-        final int value;
-
-        Durability(int value) {
-            this.value = value;
-        }
-    }
-
-    public SharedGroup(String databaseFile) {
-        context = new Context();
-        path = databaseFile;
-        nativePtr = nativeCreate(databaseFile, Durability.FULL.value, CREATE_FILE_YES, DISABLE_REPLICATION, null);
-        checkNativePtrNotZero();
-    }
-
-    public SharedGroup(String canonicalPath, boolean enableImplicitTransactions, Durability durability, byte[] key) {
-        if (enableImplicitTransactions) {
-            nativeReplicationPtr = nativeCreateReplication(canonicalPath, key);
-            nativePtr = createNativeWithImplicitTransactions(nativeReplicationPtr,
-                    durability.value, key);
-            implicitTransactionsEnabled = true;
-        } else {
-            nativePtr = nativeCreate(canonicalPath, Durability.FULL.value, CREATE_FILE_YES, DISABLE_REPLICATION, key);
-        }
-        context = new Context();
-        path = canonicalPath;
-        checkNativePtrNotZero();
-    }
-
-    public SharedGroup(String canonicalPath, Durability durability, byte[] key) {
-        path = canonicalPath;
-        context = new Context();
-        nativePtr = nativeCreate(canonicalPath, durability.value, false, false, key);
-        checkNativePtrNotZero();
-    }
-
-    void advanceRead() {
-        nativeAdvanceRead(nativePtr);
-    }
-
-    void advanceRead(VersionID versionID) throws BadVersionException {
-        nativeAdvanceReadToVersion(nativePtr, versionID.version, versionID.index);
-    }
-
-    void promoteToWrite() {
-        nativePromoteToWrite(nativePtr);
-    }
-
-    void commitAndContinueAsRead() {
-        nativeCommitAndContinueAsRead(nativePtr);
-    }
-
-    void rollbackAndContinueAsRead() {
-        nativeRollbackAndContinueAsRead(nativePtr);
-    }
-
-    public ImplicitTransaction beginImplicitTransaction() {
-        if (activeTransaction) {
-            throw new IllegalStateException(
-                    "Can't beginImplicitTransaction() during another active transaction");
-        }
-        long nativeGroupPtr = nativeBeginImplicit(nativePtr);
-        ImplicitTransaction transaction = new ImplicitTransaction(context, this, nativeGroupPtr);
-        activeTransaction = true;
-        return transaction;
-    }
-
-    public WriteTransaction beginWrite() {
-        if (activeTransaction)
-            throw new IllegalStateException(
-                    "Can't beginWrite() during another active transaction");
-        // FIXME: throw from nativeMethod in case of error
-
-        long nativeWritePtr = nativeBeginWrite(nativePtr);
-        try {
-            // Copy context reference from parent
-            WriteTransaction t = new WriteTransaction(context, this, nativeWritePtr);
-            activeTransaction = true;
-            return t;
-        } catch (RuntimeException e) {
-            Group.nativeClose(nativeWritePtr);
-            throw e;
-        }
-    }
-
-    public ReadTransaction beginRead() {
-        if (activeTransaction)
-            throw new IllegalStateException("Can't beginRead() during another active transaction");
-        // FIXME: throw from nativeMethod in case of error
-
-        long nativeReadPtr = nativeBeginRead(nativePtr);
-        try {
-            // Copy context reference from parent
-            ReadTransaction t = new ReadTransaction(context, this, nativeReadPtr);
-            activeTransaction = true;
-            return t;
-        } catch (RuntimeException e) {
-            Group.nativeClose(nativeReadPtr);
-            throw e;
-        }
-    }
-
-    void endRead() {
-        if (isClosed())
-            throw new IllegalStateException("Can't endRead() on closed group. " +
-                    "ReadTransaction is invalid.");
-        nativeEndRead(nativePtr);
-        activeTransaction = false;
-    }
-
-    public void close() {
-        synchronized (context) {
-            if (nativePtr != 0) {
-                nativeClose(nativePtr);
-                nativePtr = 0;
-                if (implicitTransactionsEnabled && nativeReplicationPtr != 0) {
-                    nativeCloseReplication(nativeReplicationPtr);
-                    nativeReplicationPtr = 0;
-                }
-            }
-        }
-    }
-
-    protected void finalize() {
-        synchronized (context) {
-            if (nativePtr != 0) {
-                context.asyncDisposeSharedGroup(nativePtr);
-                nativePtr = 0; // Set to 0 if finalize is called before close() for some reason
-                if (implicitTransactionsEnabled && nativeReplicationPtr != 0) {
-                    nativeCloseReplication(nativeReplicationPtr);
-                    nativeReplicationPtr = 0;
-                }
-            }
-        }
-    }
-
-    void commit() {
-        if (isClosed())
-            throw new IllegalStateException(
-                    "Can't commit() on closed group. WriteTransaction is invalid.");
-        nativeCommit(nativePtr);
-        activeTransaction = false;
-    }
-
-    void rollback() {
-        if (isClosed())
-            throw new IllegalStateException(
-                    "Can't rollback() on closed group. WriteTransaction is invalid.");
-        nativeRollback(nativePtr);
-        activeTransaction = false;
-    }
-
-    public boolean isClosed() {
-        return nativePtr == 0;
-    }
-
-    public boolean hasChanged() {
-        return nativeHasChanged(nativePtr);
-    }
-
-    public void reserve(long bytes) {
-        nativeReserve(nativePtr, bytes);
-    }
-
-    /**
-     * Compacts a shared group. This will block access to the shared group until done.
-     *
-     * @return {@code true} if compaction succeeded, {@code false} otherwise.
-     * @throws RuntimeException if using this within either a read or or write transaction.
-     */
-    public boolean compact() {
-        return nativeCompact(nativePtr);
-    }
-
-    /**
-     * Returns the absolute path to the file backing this SharedGroup.
-     *
-     * @return the canonical path to the Realm file.
-     */
-    public String getPath() {
-        return path;
-    }
-
-    private void checkNativePtrNotZero() {
-        if (this.nativePtr == 0) {
-            throw new IOError(new RealmIOException("Realm could not be opened"));
-        }
-    }
-
-    public long getNativePointer () {
-        return nativePtr;
-    }
-
-    public long getNativeReplicationPointer () {
-        return nativeReplicationPtr;
-    }
-
-    public VersionID getVersion () {
-        long[] versionId = nativeGetVersionID (nativePtr);
-        return new VersionID (versionId[0], versionId[1]);
-
-    }
-
-    public static class VersionID implements Comparable<VersionID> {
-        final long version;
-        final long index;
-
-        VersionID(long version, long index) {
-            this.version = version;
-            this.index = index;
-        }
-
-        @Override
-        public int compareTo(VersionID another) {
-            if (version > another.version) {
-                return 1;
-            } else if (version < another.version) {
-                return -1;
-            } else {
-                return 0;
-            }
-        }
-
-        @Override
-        public String toString() {
-            return "VersionID{" +
-                    "version=" + version +
-                    ", index=" + index +
-                    '}';
-        }
-
-        @Override
-        public boolean equals(Object object) {
-            if (this == object) return true;
-            if (object == null || getClass() != object.getClass()) return false;
-            if (!super.equals(object)) return false;
-
-            VersionID versionID = (VersionID) object;
-            return (version == versionID.version && index == versionID.index);
-        }
-
-        @Override
-        public int hashCode() {
-            int result = super.hashCode();
-            result = 31 * result + (int) (version ^ (version >>> 32));
-            result = 31 * result + (int) (index ^ (index >>> 32));
-            return result;
-        }
-    }
-
-    /**
-     * Waits for change committed by {@link SharedGroup} in other Thread.
-     *
-     * @return {@code true} if successfully detects change, {@code false} no change has been detected otherwise.
-     */
-    public boolean waitForChange() {
-        return nativeWaitForChange(nativePtr);
-    }
-
-    /**
-     * Stops waiting for change.
-     */
-    public void stopWaitForChange() {
-        nativeStopWaitForChange(nativePtr);
-    }
-
-    private native long createNativeWithImplicitTransactions(long nativeReplicationPtr,
-                                                             int durability, byte[] key);
-    private native long nativeCreateReplication(String databaseFile, byte[] key);
-    private native void nativeCommitAndContinueAsRead(long nativePtr);
-    private native long nativeBeginImplicit(long nativePtr);
-    private native String nativeGetDefaultReplicationDatabaseFileName();
-
-    private native void nativeReserve(long nativePtr, long bytes);
-    private native boolean nativeHasChanged(long nativePtr);
-    private native long nativeBeginRead(long nativePtr);
-    private native void nativeEndRead(long nativePtr);
-    private native long nativeBeginWrite(long nativePtr);
-    private native void nativeCommit(long nativePtr);
-    private native void nativeRollback(long nativePtr);
-    private native long nativeCreate(String databaseFile,
-                                     int durabilityValue,
-                                     boolean dontCreateFile,
-                                     boolean enableReplication,
-                                     byte[] key);
-    private native boolean nativeCompact(long nativePtr);
-    protected static native void nativeClose(long nativePtr);
-    private native void nativeCloseReplication(long nativeReplicationPtr);
-    private native void nativeRollbackAndContinueAsRead(long nativePtr);
-    private native long[] nativeGetVersionID (long nativePtr);
-    private native boolean nativeWaitForChange(long nativePtr);
-    private native void nativeStopWaitForChange(long nativePtr);
-    private native void nativeAdvanceRead(long nativePtr);
-    private native void nativeAdvanceReadToVersion(long nativePtr, long version, long index) throws BadVersionException;
-    private native void nativePromoteToWrite(long nativePtr);
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedGroupManager.java b/realm/realm-library/src/main/java/io/realm/internal/SharedGroupManager.java
deleted file mode 100644
index 7eac1c3ef1..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedGroupManager.java
+++ /dev/null
@@ -1,193 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import java.io.Closeable;
-import java.io.File;
-import java.io.IOException;
-
-import io.realm.RealmConfiguration;
-import io.realm.internal.async.BadVersionException;
-import io.realm.internal.log.RealmLog;
-
-/**
- * This class wraps access to a given Realm file on a single thread including its {@link SharedGroup} and
- * {@link ImplicitTransaction}. By nature this means that this class is not thread safe and should only be used from the
- * thread that created it.
- *
- * Realm is a MVCC database (Multiversion concurrency control), which means that multiple versions of the data might
- * exist in the same file. By default the file is always opened on the latest version and it is possible to advance to
- * the latest version by calling {@link #advanceRead()}.
- */
-public class SharedGroupManager implements Closeable {
-
-    private SharedGroup sharedGroup;
-    private ImplicitTransaction transaction;
-
-    /**
-     * Creates a new instance of the FileWrapper for the given configuration on this thread.
-     */
-    public SharedGroupManager(RealmConfiguration configuration) {
-        this.sharedGroup = new SharedGroup(
-                configuration.getPath(),
-                SharedGroup.IMPLICIT_TRANSACTION,
-                configuration.getDurability(),
-                configuration.getEncryptionKey());
-        this.transaction = sharedGroup.beginImplicitTransaction();
-    }
-
-    /**
-     * Closes the underlying {@link SharedGroup} and free any native resources.
-     */
-    @Override
-    public void close() {
-        sharedGroup.close();
-        sharedGroup = null;
-        transaction = null;
-    }
-
-    /**
-     * Checks if the Realm file is accessible.
-     *
-     * @return {@code true} if the file is open and data can be accessed, {@code false} otherwise.
-     */
-    public boolean isOpen() {
-        return sharedGroup != null;
-    }
-
-    /**
-     * Advances the Realm file to the latest version.
-     */
-    public void advanceRead() {
-        transaction.advanceRead();
-    }
-
-    /**
-     * Advances the Realm file to the given version.
-     */
-    public void advanceRead(SharedGroup.VersionID version) throws BadVersionException {
-        transaction.advanceRead(version);
-    }
-
-
-    // Public because of migrations. Gets the full table name. Prefix will not be added.
-    // TODO Remove when new Migration API is introduced.
-    public Table getTable(String tableName) {
-        return transaction.getTable(tableName);
-    }
-
-    /**
-     * Checks if a Realm file can be advanced to a newer version.
-     */
-    public boolean hasChanged() {
-        return sharedGroup.hasChanged();
-    }
-
-    /**
-     * Returns the version for the SharedGroup.
-     */
-    public SharedGroup.VersionID getVersion() {
-        return sharedGroup.getVersion();
-    }
-
-    /**
-     * Makes the file writable. This will block all other threads and processes from making it writable as well.
-     */
-    public void promoteToWrite() {
-        transaction.promoteToWrite();
-    }
-
-    /**
-     * Commits any pending changes to the file and return to read-only mode.
-     */
-    public void commitAndContinueAsRead() {
-        transaction.commitAndContinueAsRead();
-    }
-
-    /**
-     * Rollbacks any changes to the file since it was made writable and continue in read-only mode.
-     */
-    public void rollbackAndContinueAsRead() {
-        transaction.rollbackAndContinueAsRead();
-    }
-
-    /**
-     * Checks if a given table exists.
-     *
-     * @return {code true} if the table exists. {@code false} otherwise.
-     */
-    public boolean hasTable(String tableName) {
-        return transaction.hasTable(tableName);
-    }
-
-    /**
-     * Writes a copy of this Realm file to another location.
-     */
-    public void copyToFile(File destination, byte[] key) throws IOException {
-        transaction.writeToFile(destination, key);
-    }
-
-    /**
-     * Returns a reference to current {@link SharedGroup}.
-     */
-    public SharedGroup getSharedGroup() {
-        return sharedGroup;
-    }
-
-    /**
-     * Returns a reference to the current {@link ImplicitTransaction}.
-     */
-    public ImplicitTransaction getTransaction() {
-        return transaction;
-    }
-
-    /**
-     * Returns if the Realm is currently not in a transaction.
-     */
-    public boolean isImmutable() {
-        return transaction.immutable;
-    }
-
-    /**
-     * Compacts a Realm file. It cannot be open when calling this method.
-     * Returns true if compaction succeeded, false otherwise.
-     */
-    public static boolean compact(RealmConfiguration configuration) {
-        SharedGroup sharedGroup = null;
-        boolean result = false;
-        try {
-            sharedGroup = new SharedGroup(
-                    configuration.getPath(),
-                    SharedGroup.IMPLICIT_TRANSACTION,
-                    SharedGroup.Durability.FULL,
-                    configuration.getEncryptionKey());
-            result = sharedGroup.compact();
-        } catch (Exception e) {
-            RealmLog.i(e.getMessage());
-            return false;
-        } finally {
-            if (sharedGroup != null) {
-                sharedGroup.close();
-            }
-        }
-        return result;
-    }
-
-    public long getNativePointer() {
-        return sharedGroup.getNativePointer();
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
new file mode 100644
index 0000000000..8fa0cf6f22
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -0,0 +1,349 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import java.io.Closeable;
+import java.io.File;
+
+import io.realm.RealmConfiguration;
+import io.realm.RealmFieldType;
+import io.realm.internal.async.BadVersionException;
+
+public final class SharedRealm implements Closeable {
+
+    // Const value for RealmFileException conversion
+    public static final byte FILE_EXCEPTION_KIND_ACCESS_ERROR = 0;
+    public static final byte FILE_EXCEPTION_KIND_PERMISSION_DENIED = 1;
+    public static final byte FILE_EXCEPTION_KIND_EXISTS = 2;
+    public static final byte FILE_EXCEPTION_KIND_NOT_FOUND = 3;
+    public static final byte FILE_EXCEPTION_KIND_IMCOMPATIBLE_LOCK_FILE = 4;
+    public static final byte FILE_EXCEPTION_KIND_FORMAT_UPGRADE_REQUIRED = 5;
+
+    public enum Durability {
+        FULL(0),
+        MEM_ONLY(1);
+
+        final int value;
+
+        Durability(int value) {
+            this.value = value;
+        }
+    }
+
+    // Public for static checking in JNI
+    @SuppressWarnings("WeakerAccess")
+    public static final byte SCHEMA_MODE_VALUE_AUTOMATIC = 0;
+    @SuppressWarnings("WeakerAccess")
+    public static final byte SCHEMA_MODE_VALUE_READONLY = 1;
+    @SuppressWarnings("WeakerAccess")
+    public static final byte SCHEMA_MODE_VALUE_RESET_FILE = 2;
+    @SuppressWarnings("WeakerAccess")
+    public static final byte SCHEMA_MODE_VALUE_ADDITIVE = 3;
+    @SuppressWarnings("WeakerAccess")
+    public static final byte SCHEMA_MODE_VALUE_MANUAL = 4;
+    @SuppressWarnings("WeakerAccess")
+    public enum SchemaMode {
+        SCHEMA_MODE_AUTOMATIC(SCHEMA_MODE_VALUE_AUTOMATIC),
+        SCHEMA_MODE_READONLY(SCHEMA_MODE_VALUE_READONLY),
+        SCHEMA_MODE_RESET_FILE(SCHEMA_MODE_VALUE_RESET_FILE),
+        SCHEMA_MODE_ADDITIVE(SCHEMA_MODE_VALUE_ADDITIVE),
+        SCHEMA_MODE_MANUAL(SCHEMA_MODE_VALUE_MANUAL);
+
+        final byte value;
+        SchemaMode(byte value) {
+            this .value = value;
+        }
+    }
+
+    // JNI will only hold a weak global ref to this.
+    public final RealmNotifier realmNotifier;
+
+    public static class VersionID implements Comparable<VersionID> {
+        final long version;
+        final long index;
+
+        VersionID(long version, long index) {
+            this.version = version;
+            this.index = index;
+        }
+
+        @Override
+        public int compareTo(@SuppressWarnings("NullableProblems") VersionID another) {
+            if (another == null) {
+                throw new IllegalArgumentException("Version cannot be compared to a null value.");
+            }
+            if (version > another.version) {
+                return 1;
+            } else if (version < another.version) {
+                return -1;
+            } else {
+                return 0;
+            }
+        }
+
+        @Override
+        public String toString() {
+            return "VersionID{" +
+                    "version=" + version +
+                    ", index=" + index +
+                    '}';
+        }
+
+        @Override
+        public boolean equals(Object object) {
+            if (this == object) {
+                return true;
+            }
+            if (object == null || getClass() != object.getClass()) {
+                return false;
+            }
+
+            VersionID versionID = (VersionID) object;
+            return (version == versionID.version && index == versionID.index);
+        }
+
+        @Override
+        public int hashCode() {
+            int result = super.hashCode();
+            result = 31 * result + (int) (version ^ (version >>> 32));
+            result = 31 * result + (int) (index ^ (index >>> 32));
+            return result;
+        }
+    }
+
+    public interface SchemaVersionListener {
+        void onSchemaVersionChanged(long currentVersion);
+    }
+
+    private long nativePtr;
+    private RealmConfiguration configuration;
+    final Context context;
+    private long lastSchemaVersion;
+    private final SchemaVersionListener schemaChangeListener;
+
+    private SharedRealm(long nativePtr, RealmConfiguration configuration, RealmNotifier notifier,
+                        SchemaVersionListener schemaVersionListener) {
+        this.nativePtr = nativePtr;
+        this.configuration = configuration;
+        this.realmNotifier = notifier;
+        this.schemaChangeListener = schemaVersionListener;
+        context = new Context();
+        this.lastSchemaVersion = schemaVersionListener == null ? -1L : getSchemaVersion();
+    }
+
+    public static SharedRealm getInstance(RealmConfiguration config) {
+        return getInstance(config, null, null);
+    }
+
+    public static SharedRealm getInstance(RealmConfiguration config, RealmNotifier realmNotifier,
+                                          SchemaVersionListener schemaVersionListener) {
+        long nativeConfigPtr = nativeCreateConfig(
+                config.getPath(),
+                config.getEncryptionKey(),
+                SchemaMode.SCHEMA_MODE_MANUAL.value,
+                config.getDurability() == Durability.MEM_ONLY,
+                false,
+                false,
+                true);
+        try {
+            return new SharedRealm(
+                    nativeGetSharedRealm(nativeConfigPtr, realmNotifier),
+                    config,
+                    realmNotifier,
+                    schemaVersionListener);
+        } finally {
+            nativeCloseConfig(nativeConfigPtr);
+        }
+    }
+
+    long getNativePtr() {
+        return nativePtr;
+    }
+
+    public void beginTransaction() {
+        nativeBeginTransaction(nativePtr);
+        invokeSchemaChangeListenerIfSchemaChanged();
+    }
+
+    public void commitTransaction() {
+        nativeCommitTransaction(nativePtr);
+    }
+
+    public void cancelTransaction() {
+        nativeCancelTransaction(nativePtr);
+    }
+
+    public boolean isInTransaction() {
+        return nativeIsInTransaction(nativePtr);
+    }
+
+    public void setSchemaVersion(long schemaVersion) {
+        nativeSetVersion(nativePtr, schemaVersion);
+    }
+
+    public long getSchemaVersion() {
+        return nativeGetVersion(nativePtr);
+    }
+
+    // FIXME: This should be removed, migratePrimaryKeyTableIfNeeded is using it which should be in Object Store instead?
+    long getGroupNative() {
+        return nativeReadGroup(nativePtr);
+    }
+
+    public boolean hasTable(String name) {
+        return nativeHasTable(nativePtr, name);
+    }
+
+    public Table getTable(String name) {
+        return new Table(this, nativeGetTable(nativePtr, name));
+    }
+
+    public void renameTable(String oldName, String newName) {
+        nativeRenameTable(nativePtr, oldName, newName);
+    }
+
+    public void removeTable(String name) {
+        nativeRemoveTable(nativePtr, name);
+    }
+
+    public String getTableName(int index) {
+        return nativeGetTableName(nativePtr, index);
+    }
+
+    public long size() {
+        return nativeSize(nativePtr);
+    }
+
+    public String getPath() {
+        return configuration.getPath();
+    }
+
+    public boolean isEmpty() {
+        return nativeIsEmpty(nativePtr);
+    }
+
+    public void refresh() {
+        nativeRefresh(nativePtr);
+        invokeSchemaChangeListenerIfSchemaChanged();
+    }
+
+    public void refresh(SharedRealm.VersionID version) throws BadVersionException {
+        // FIXME: This will have a different behaviour compared to refresh to the latest version.
+        // In the JNI this will just advance read the corresponding SharedGroup to the specific version without notifier
+        // or transact log observer involved. Before we use notification & fine grained notification from OS, it is not
+        // a problem.
+        nativeRefresh(nativePtr, version.version, version.index);
+        invokeSchemaChangeListenerIfSchemaChanged();
+    }
+
+    public SharedRealm.VersionID getVersionID() {
+        long[] versionId = nativeGetVersionID (nativePtr);
+        return new SharedRealm.VersionID(versionId[0], versionId[1]);
+    }
+
+    public boolean isClosed() {
+        return nativePtr == 0 || nativeIsClosed(nativePtr);
+    }
+
+    public void writeCopy(File file, byte[] key) {
+        if (file.isFile() && file.exists()) {
+            throw new IllegalArgumentException("The destination file must not exist");
+        }
+        nativeWriteCopy(nativePtr, file.getAbsolutePath(), key);
+    }
+
+    public boolean waitForChange() {
+        return nativeWaitForChange(nativePtr);
+    }
+
+    public void stopWaitForChange() {
+        nativeStopWaitForChange(nativePtr);
+    }
+
+    public boolean compact() {
+        return nativeCompact(nativePtr);
+    }
+
+    @Override
+    public void close() {
+        if (realmNotifier != null) {
+            realmNotifier.close();
+        }
+        synchronized (context) {
+            if (nativePtr != 0) {
+                nativeCloseSharedRealm(nativePtr);
+                nativePtr = 0;
+            }
+        }
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        synchronized (context) {
+            close();
+            // FIXME: Below is the original implementation of SharedGroup.finalize().
+            // And actually Context.asyncDisposeSharedGroup will simply call nativeClose which is not asyc at all.
+            // IMO since this implemented Closeable already, it makes no sense to implement finalize.
+            // Just keep the logic the same for now and make nativeClose private. Rethink about this when cleaning
+            // up finalizers.
+            //context.asyncDisposeSharedRealm(nativePtr);
+        }
+        super.finalize();
+    }
+
+    public void invokeSchemaChangeListenerIfSchemaChanged() {
+        if (schemaChangeListener == null) {
+            return;
+        }
+
+        final long before = lastSchemaVersion;
+        final long current = getSchemaVersion();
+        if (current != before) {
+            lastSchemaVersion = current;
+            schemaChangeListener.onSchemaVersionChanged(current);
+        }
+    }
+
+    private static native long nativeCreateConfig(String realmPath, byte[] key, byte schemaMode, boolean inMemory,
+                                                  boolean cache, boolean disableFormatUpgrade,
+                                                  boolean autoChangeNotification);
+    private static native void nativeCloseConfig(long nativeConfigPtr);
+    private static native long nativeGetSharedRealm(long nativeConfigPtr, RealmNotifier notifier);
+    private static native void nativeCloseSharedRealm(long nativeSharedRealmPtr);
+    private static native boolean nativeIsClosed(long nativeSharedRealmPtr);
+    private static native void nativeBeginTransaction(long nativeSharedRealmPtr);
+    private static native void nativeCommitTransaction(long nativeSharedRealmPtr);
+    private static native void nativeCancelTransaction(long nativeSharedRealmPtr);
+    private static native boolean nativeIsInTransaction(long nativeSharedRealmPtr);
+    private static native long nativeGetVersion(long nativeSharedRealmPtr);
+    private static native void nativeSetVersion(long nativeSharedRealmPtr, long version);
+    private static native long nativeReadGroup(long nativeSharedRealmPtr);
+    private static native boolean nativeIsEmpty(long nativeSharedRealmPtr);
+    private static native void nativeRefresh(long nativeSharedRealmPtr);
+    private static native void nativeRefresh(long nativeSharedRealmPtr, long version, long index);
+    private static native long[]  nativeGetVersionID(long nativeSharedRealmPtr);
+    private static native long nativeGetTable(long nativeSharedRealmPtr, String tableName);
+    private static native String nativeGetTableName(long nativeSharedRealmPtr, int index);
+    private static native boolean nativeHasTable(long nativeSharedRealmPtr, String tableName);
+    private static native void nativeRenameTable(long nativeSharedRealmPtr, String oldTableName, String newTableName);
+    private static native void nativeRemoveTable(long nativeSharedRealmPtr, String tableName);
+    private static native long nativeSize(long nativeSharedRealmPtr);
+    private static native void nativeWriteCopy(long nativeSharedRealmPtr, String path, byte[] key);
+    private static native boolean nativeWaitForChange(long nativeSharedRealmPtr);
+    private static native void nativeStopWaitForChange(long nativeSharedRealmPtr);
+    private static native boolean nativeCompact(long nativeSharedRealmPtr);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SubtableSchema.java b/realm/realm-library/src/main/java/io/realm/internal/SubtableSchema.java
deleted file mode 100644
index dda38d3e5a..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/SubtableSchema.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import io.realm.RealmFieldType;
-
-public class SubtableSchema implements TableSchema {
-
-    private long[] path;
-    private long parentNativePtr;
-
-    SubtableSchema(long parentNativePtr, long[] path) {
-        this.parentNativePtr = parentNativePtr;
-        this.path = path;
-    }
-
-    @Override
-    public SubtableSchema getSubtableSchema(long columnIndex) {
-        long[] newPath = new long[path.length + 1];
-        System.arraycopy(path, 0, newPath, 0, path.length);
-        newPath[path.length] = columnIndex;
-        return new SubtableSchema(this.parentNativePtr, newPath);
-    }
-
-    private void verifyColumnName(String name) {
-        if (name.length() > 63) {
-            throw new IllegalArgumentException("Column names are currently limited to max 63 characters.");
-        }
-    }
-
-    @Override
-    public long addColumn(RealmFieldType type, String name) {
-        verifyColumnName(name);
-        return nativeAddColumn(parentNativePtr, path, type.getNativeValue(), name);
-    }
-
-    protected native long nativeAddColumn(long nativeTablePtr, long[] path, int type, String name);
-
-    /**
-     * Removes a column in the table dynamically.
-     */
-    @Override
-    public void removeColumn(long columnIndex) {
-        nativeRemoveColumn(parentNativePtr, path, columnIndex);
-    }
-
-    protected native void nativeRemoveColumn(long nativeTablePtr, long[] path, long columnIndex);
-
-    /**
-     * Renames a column in the table.
-     */
-    @Override
-    public void renameColumn(long columnIndex, String newName) {
-        verifyColumnName(newName);
-        nativeRenameColumn(parentNativePtr, path, columnIndex, newName);
-    }
-
-    protected native void nativeRenameColumn(long nativeTablePtr, long[] path, long columnIndex, String name);
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index e5b32ae2df..db2ba7db16 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -16,15 +16,11 @@
 
 package io.realm.internal;
 
-import java.io.Closeable;
 import java.util.Date;
-import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.RealmFieldType;
-import io.realm.Sort;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmPrimaryKeyConstraintException;
-import io.realm.internal.log.RealmLog;
 
 
 /**
@@ -32,14 +28,15 @@
  * (define/insert/delete/update) a table has. All the native communications to the Realm C++ library are also handled by
  * this class.
  */
-public class Table implements TableOrView, TableSchema, Closeable {
+public class Table implements TableOrView, TableSchema {
 
     public static final int TABLE_MAX_LENGTH = 56; // Max length of class names without prefix
     public static final String TABLE_PREFIX = Util.getTablePrefix();
     public static final long INFINITE = -1;
+    @SuppressWarnings("WeakerAccess")
     public static final String STRING_DEFAULT_VALUE = "";
+    @SuppressWarnings("WeakerAccess")
     public static final long INTEGER_DEFAULT_VALUE = 0;
-    public static final String METADATA_TABLE_NAME = "metadata";
     public static final boolean NULLABLE = true;
     public static final boolean NOT_NULLABLE = false;
 
@@ -50,16 +47,11 @@
     private static final long PRIMARY_KEY_FIELD_COLUMN_INDEX = 1;
     private static final long NO_PRIMARY_KEY = -2;
 
-    protected long nativePtr;
-    protected final Object parent;
+    long nativePtr;
     private final Context context;
+    private final SharedRealm sharedRealm;
     private long cachedPrimaryKeyColumnIndex = NO_MATCH;
 
-    // test:
-    protected int tableNo;
-    private static final boolean DEBUG = false;
-    static AtomicInteger tableCount = new AtomicInteger(0);
-
     static {
         RealmCore.loadLibrary();
     }
@@ -69,7 +61,6 @@
      * allowed only for empty tables. It creates a native reference of the object and keeps a reference to it.
      */
     public Table() {
-        this.parent = null; // No parent in free-standing table
         this.context = new Context();
         // Native methods work will be initialized here. Generated classes will
         // have nothing to do with the native functions. Generated Java Table
@@ -78,20 +69,17 @@ public Table() {
         if (nativePtr == 0) {
             throw new java.lang.OutOfMemoryError("Out of native memory.");
         }
-        if (DEBUG) {
-            tableNo = tableCount.incrementAndGet();
-            RealmLog.d("====== New Tablebase " + tableNo + " : ptr = " + nativePtr);
-        }
+        sharedRealm = null;
+    }
+
+    Table(Table parent, long nativePointer) {
+        this(parent.sharedRealm, nativePointer);
     }
 
-    Table(Context context, Object parent, long nativePointer) {
-        this.context = context;
-        this.parent  = parent;
+    Table(SharedRealm sharedRealm, long nativePointer) {
+        this.context = sharedRealm.context;
+        this.sharedRealm = sharedRealm;
         this.nativePtr = nativePointer;
-        if (DEBUG) {
-            tableNo = tableCount.incrementAndGet();
-            RealmLog.d("===== New Tablebase(ptr) " + tableNo + " : ptr = " + nativePtr);
-        }
     }
 
     @Override
@@ -99,34 +87,20 @@ public Table getTable() {
         return this;
     }
 
-    // If close() is called, no penalty is paid for delayed disposal
-    // via the context
-    @Override
-    public void close() {
-        synchronized (context) {
-            if (nativePtr != 0) {
-                nativeClose(nativePtr);
-                if (DEBUG) {
-                    tableCount.decrementAndGet();
-                    RealmLog.d("==== CLOSE " + tableNo + " ptr= " + nativePtr + " remaining " + tableCount.get());
-                }
-                nativePtr = 0;
-            }
-        }
+    public long getNativeTablePointer() {
+        return nativePtr;
     }
 
     @Override
-    protected void finalize() {
+    protected void finalize() throws Throwable {
         synchronized (context) {
             if (nativePtr != 0) {
-                boolean isRoot = (parent == null);
-                context.asyncDisposeTable(nativePtr, isRoot);
+                // Don't dispose the table immediately if it is created from a SharedRealm to avoid long run finalizer.
+                context.asyncDisposeTable(nativePtr, sharedRealm == null);
                 nativePtr = 0; // Set to 0 if finalize is called before close() for some reason
             }
         }
-        if (DEBUG) {
-            RealmLog.d("==== FINALIZE " + tableNo + "...");
-        }
+        super.finalize();
     }
 
     /*
@@ -135,7 +109,6 @@ protected void finalize() {
      * You can no longer perform any actions on the table, and if done anyway, an exception is thrown.
      * The only method you can call is 'isValid()'.
      */
-
     public boolean isValid() {
         return nativePtr != 0 && nativeIsValid(nativePtr);
     }
@@ -146,17 +119,6 @@ private void verifyColumnName(String name) {
         }
     }
 
-    @Override
-    public TableSchema getSubtableSchema(long columnIndex) {
-        if (!nativeIsRootTable(nativePtr)) {
-            throw new UnsupportedOperationException("This is a subtable. Can only be called on root table.");
-        }
-
-        long[] newPath = new long[1];
-        newPath[0] = columnIndex;
-        return new SubtableSchema(nativePtr, newPath);
-    }
-
     /**
      * Adds a column to the table dynamically.
      *
@@ -191,20 +153,86 @@ public long addColumnLink (RealmFieldType type, String name, Table table) {
     }
 
     /**
-     * Removes a column in the table dynamically.
+     * Removes a column in the table dynamically. if {@code columnIndex} is smaller than the primary
+     * key column index, {@link #invalidateCachedPrimaryKeyIndex()} will be called to recalculate the
+     * primary key column index.
+     *
+     * <p>It should be noted if {@code columnIndex} is the same as the primary key column index,
+     * the primary key column is removed from the meta table.
+     *
+     * @param columnIndex the column index to be removed.
      */
     @Override
     public void removeColumn(long columnIndex) {
+        // Check the PK column index before removing a column. We don't know if we're hitting a PK col,
+        // but it should be noted that once a column is removed, there is no way we can find whether
+        // a PK exists or not.
+        final long oldPkColumnIndex = getPrimaryKey();
+
+        // firstly remove a column. If there is no error, we can proceed. Otherwise, it will stop here.
         nativeRemoveColumn(nativePtr, columnIndex);
+
+        // Check if a PK exists and take actions if there is. This is same as hasPrimaryKey(), but
+        // this relies on the local cache.
+        if (oldPkColumnIndex >= 0) {
+
+            // In case we're hitting PK column, we should remove the PK as it is either 1) a user has
+            // forgotten to remove PK or 2) removeColumn gets called before setPrimaryKey(null) is called.
+            // Since there is no danger in removing PK twice, we'll do it here to be on safe side.
+            if (oldPkColumnIndex == columnIndex) {
+                setPrimaryKey(null);
+
+            // But if you remove a column with a smaller index than that of PK column, you need to
+            // recalculate the PK column index as core could have changed its column index.
+            } else if (oldPkColumnIndex > columnIndex) {
+                invalidateCachedPrimaryKeyIndex();
+            }
+        }
     }
 
     /**
-     * Renames a column in the table.
+     * Renames a column in the table. If the column is a primary key column, the corresponding entry
+     * in PrimaryKeyTable will be renamed accordingly.
+     *
+     * @param columnIndex the column index to be renamed.
+     * @param newName a new name replacing the old column name.
+     * @throws IllegalArgumentException if {@code newFieldName} is an empty string, or exceeds field name length limit.
+     * @throws IllegalStateException if a PrimaryKey column name could not be found in the meta table, but {@link #getPrimaryKey()} returns an index.
      */
     @Override
     public void renameColumn(long columnIndex, String newName) {
         verifyColumnName(newName);
+        // get the old column name. We'll assume that the old column name is *NOT* an empty string.
+        final String oldName = nativeGetColumnName(nativePtr, columnIndex);
+        // also old pk index. Once a column name changes, there is no way you can find the column name
+        // by old name.
+        final long oldPkColumnIndex = getPrimaryKey();
+
+        // then let's try to rename a column. If an error occurs for some reasons, we'll throw.
         nativeRenameColumn(nativePtr, columnIndex, newName);
+
+        // Rename a primary key. At this point, renaming the column name should have been fine.
+        if (oldPkColumnIndex == columnIndex) {
+            try {
+                String className = tableNameToClassName(getName());
+                Table pkTable = getPrimaryKeyTable();
+                if (pkTable == null) {
+                    throw new IllegalStateException(
+                            "Table is not created from a SharedRealm, primary key is not available");
+                }
+                long pkRowIndex = pkTable.findFirstString(PRIMARY_KEY_CLASS_COLUMN_INDEX, className);
+                if (pkRowIndex != NO_MATCH) {
+                    pkTable.setString(PRIMARY_KEY_FIELD_COLUMN_INDEX, pkRowIndex, newName);
+                } else {
+                    throw new IllegalStateException("Non-existent PrimaryKey column cannot be renamed");
+                }
+            } catch (Exception e) {
+                // we failed to rename the pk meta table. roll back the column name, not pk meta table
+                // then rethrow.
+                nativeRenameColumn(nativePtr, columnIndex, oldName);
+                throw e;
+            }
+        }
     }
 
     /**
@@ -235,14 +263,6 @@ public void convertColumnToNotNullable(long columnIndex) {
         nativeConvertColumnToNotNullable(nativePtr, columnIndex);
     }
 
-    /**
-     * Updates a table specification from a Table specification structure.
-     */
-    public void updateFromSpec(TableSpec tableSpec) {
-        checkImmutable();
-        nativeUpdateFromSpec(nativePtr, tableSpec);
-    }
-
     // Table Size and deletion. AutoGenerated subclasses are nothing to do with this
     // class.
     /**
@@ -285,10 +305,6 @@ public long getColumnCount() {
         return nativeGetColumnCount(nativePtr);
     }
 
-    public TableSpec getTableSpec(){
-        return nativeGetTableSpec(nativePtr);
-    }
-
     /**
      * Returns the name of a column identified by columnIndex. Notice that the index is zero based.
      *
@@ -355,33 +371,43 @@ public void moveLastOver(long rowIndex) {
         nativeMoveLastOver(nativePtr, rowIndex);
     }
 
+    /**
+     * Add an empty row to the table which doesn't have a primary key defined.
+     * <p>
+     * NOTE: To add a table with a primary key defined, use {@link #addEmptyRowWithPrimaryKey(Object)} instead. This
+     * won't check if this table has a primary key.
+     *
+     * @return row index.
+     */
     public long addEmptyRow() {
         checkImmutable();
-        if (hasPrimaryKey()) {
-            long primaryKeyColumnIndex = getPrimaryKey();
-            RealmFieldType type = getColumnType(primaryKeyColumnIndex);
-            switch (type) {
-                case STRING:
-                    if (findFirstString(primaryKeyColumnIndex, STRING_DEFAULT_VALUE) != NO_MATCH) {
-                        throwDuplicatePrimaryKeyException(STRING_DEFAULT_VALUE);
-                    }
-                    break;
-                case INTEGER:
-                    if (findFirstLong(primaryKeyColumnIndex, INTEGER_DEFAULT_VALUE) != NO_MATCH) {
-                        throwDuplicatePrimaryKeyException(INTEGER_DEFAULT_VALUE);
-                    }
-                    break;
-                default:
-                    throw new RealmException("Cannot check for duplicate rows for unsupported primary key type: " + type);
-            }
-        }
-
         return nativeAddEmptyRow(nativePtr, 1);
     }
 
+    /**
+     * Add an empty row to the table and set the primary key with the given value. Equivalent to call
+     * {@link #addEmptyRowWithPrimaryKey(Object, boolean)} with {@code validation = true}.
+     *
+     * @param primaryKeyValue the primary key value
+     * @return the row index.
+     */
     public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
-        checkImmutable();
-        checkHasPrimaryKey();
+        return addEmptyRowWithPrimaryKey(primaryKeyValue, true);
+    }
+
+    /**
+     * Add an empty row to the table and set the primary key with the given value.
+     *
+     * @param primaryKeyValue the primary key value.
+     * @param validation set to {@code false} to skip all validations. This is currently used by bulk insert which
+     *                     has its own validations.
+     * @return the row index.
+     */
+    public long addEmptyRowWithPrimaryKey(Object primaryKeyValue, boolean validation) {
+        if (validation) {
+            checkImmutable();
+            checkHasPrimaryKey();
+        }
 
         long primaryKeyColumnIndex = getPrimaryKey();
         RealmFieldType type = getColumnType(primaryKeyColumnIndex);
@@ -393,11 +419,12 @@ public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
             switch (type) {
                 case STRING:
                 case INTEGER:
-                    if (findFirstNull(primaryKeyColumnIndex) != NO_MATCH) {
+                    if (validation && findFirstNull(primaryKeyColumnIndex) != NO_MATCH) {
                         throwDuplicatePrimaryKeyException("null");
                     }
                     rowIndex = nativeAddEmptyRow(nativePtr, 1);
                     row = getUncheckedRow(rowIndex);
+                    // FIXME: Use core's set_null_unique when core supports it.
                     row.setNull(primaryKeyColumnIndex);
                     break;
 
@@ -411,12 +438,11 @@ public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
                     if (!(primaryKeyValue instanceof String)) {
                         throw new IllegalArgumentException("Primary key value is not a String: " + primaryKeyValue);
                     }
-                    if (findFirstString(primaryKeyColumnIndex, (String) primaryKeyValue) != NO_MATCH) {
+                    if (validation && findFirstString(primaryKeyColumnIndex, (String) primaryKeyValue) != NO_MATCH) {
                         throwDuplicatePrimaryKeyException(primaryKeyValue);
                     }
                     rowIndex = nativeAddEmptyRow(nativePtr, 1);
-                    row = getUncheckedRow(rowIndex);
-                    row.setString(primaryKeyColumnIndex, (String) primaryKeyValue);
+                    nativeSetStringUnique(nativePtr, primaryKeyColumnIndex, rowIndex, (String) primaryKeyValue);
                     break;
 
                 case INTEGER:
@@ -426,12 +452,11 @@ public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
                     } catch (RuntimeException e) {
                         throw new IllegalArgumentException("Primary key value is not a long: " + primaryKeyValue);
                     }
-                    if (findFirstLong(primaryKeyColumnIndex, pkValue) != NO_MATCH) {
+                    if (validation && findFirstLong(primaryKeyColumnIndex, pkValue) != NO_MATCH) {
                         throwDuplicatePrimaryKeyException(pkValue);
                     }
                     rowIndex = nativeAddEmptyRow(nativePtr, 1);
-                    row = getUncheckedRow(rowIndex);
-                    row.setLong(primaryKeyColumnIndex, pkValue);
+                    nativeSetLongUnique(nativePtr, primaryKeyColumnIndex, rowIndex, pkValue);
                     break;
 
                 default:
@@ -441,6 +466,7 @@ public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
         return rowIndex;
     }
 
+    @SuppressWarnings("WeakerAccess")
     public long addEmptyRows(long rows) {
         checkImmutable();
         if (rows < 1) {
@@ -460,6 +486,9 @@ public long addEmptyRows(long rows) {
      *
      * @param values values.
      * @return the row index of the appended row.
+     * @deprecated Remove this functions since it doesn't seem to be useful. And this function does deal with tables
+     * withprimary key defined well. Primary key has to be set with `setXxxUnique` as the first thing to do after row
+     * added.
      */
     protected long add(Object... values) {
         long rowIndex = addEmptyRow();
@@ -531,19 +560,13 @@ protected long add(Object... values) {
                     throw new IllegalArgumentException("Null Date is not allowed.");
                 nativeSetTimestamp(nativePtr, columnIndex, rowIndex, ((Date) value).getTime());
                 break;
-            case UNSUPPORTED_MIXED:
-                if (value == null)
-                    throw new IllegalArgumentException("Null Mixed data is not allowed");
-                nativeSetMixed(nativePtr, columnIndex, rowIndex, Mixed.mixedValue(value));
-                break;
             case BINARY:
                 if (value == null)
                     throw new IllegalArgumentException("Null Array is not allowed");
                 nativeSetByteArray(nativePtr, columnIndex, rowIndex, (byte[])value);
                 break;
+            case UNSUPPORTED_MIXED:
             case UNSUPPORTED_TABLE:
-                insertSubTable(columnIndex, rowIndex, value);
-                break;
             default:
                 throw new RuntimeException("Unexpected columnType: " + String.valueOf(colTypes[(int)columnIndex]));
             }
@@ -555,48 +578,6 @@ private boolean isPrimaryKeyColumn(long columnIndex) {
         return columnIndex == getPrimaryKey();
     }
 
-    /**
-     * Returns a view sorted by the specified column and order.
-     *
-     * @param columnIndex the column index.
-     * @param sortOrder the sort order.
-     * @return a sorted view.
-     */
-    public TableView getSortedView(long columnIndex, Sort sortOrder){
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        long nativeViewPtr = nativeGetSortedView(nativePtr, columnIndex, sortOrder.getValue());
-        try {
-            return new TableView(this.context, this, nativeViewPtr);
-        } catch (RuntimeException e) {
-            TableView.nativeClose(nativeViewPtr);
-            throw e;
-        }
-    }
-
-    /**
-     * Returns a view sorted by the specified column by the default order.
-     *
-     * @param columnIndex the column index.
-     * @return a sorted view.
-     */
-    public TableView getSortedView(long columnIndex) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        long nativeViewPtr = nativeGetSortedView(nativePtr, columnIndex, true);
-        return new TableView(this.context, this, nativeViewPtr);
-    }
-
-    public TableView getSortedView(long columnIndices[], Sort sortOrders[]) {
-        context.executeDelayedDisposal();
-        boolean[] nativeSortOrder = new boolean[sortOrders.length];
-        for (int i = 0; i < sortOrders.length; i++) {
-            nativeSortOrder[i] = sortOrders[i].getValue();
-        }
-        long nativeViewPtr = nativeGetSortedViewMulti(nativePtr, columnIndices, nativeSortOrder);
-        return new TableView(this.context, this, nativeViewPtr);
-    }
-
     /**
      * Returns the column index for the primary key.
      *
@@ -630,7 +611,7 @@ public long getPrimaryKey() {
      * @param columnIndex the index of column in the table.
      * @return {@code true} if column is a primary key, {@code false} otherwise.
      */
-    public boolean isPrimaryKey(long columnIndex) {
+    private boolean isPrimaryKey(long columnIndex) {
         return columnIndex >= 0 && columnIndex == getPrimaryKey();
     }
 
@@ -674,13 +655,19 @@ void checkDuplicatedNullForPrimaryKeyValue(long columnIndex, long rowToUpdate) {
                     }
                     break;
                 default:
-                    // Since it is sufficient to check the existance of duplicated null values
+                    // Since it is sufficient to check the existence of duplicated null values
                     // on PrimaryKey in supported types only, this part is left empty.
             }
         }
     }
 
-    private void throwDuplicatePrimaryKeyException(Object value) {
+    /**
+     * Throws a properly formatted exception when multiple objects with the same primary key
+     * value is detected.
+     *
+     * @param value the primary key value.
+     */
+    public static void throwDuplicatePrimaryKeyException(Object value) {
         throw new RealmPrimaryKeyConstraintException("Value already exists: " + value);
     }
 
@@ -725,37 +712,11 @@ public String getString(long columnIndex, long rowIndex) {
         return nativeGetString(nativePtr, columnIndex, rowIndex);
     }
 
-    /**
-     * Gets the value of a (binary) cell.
-     *
-     * @param columnIndex 0 based index value of the cell column.
-     * @param rowIndex 0 based index value of the cell row.
-     * @return value of the particular cell.
-     */
-    /*
-    @Override
-    public ByteBuffer getBinaryByteBuffer(long columnIndex, long rowIndex) {
-        return nativeGetByteBuffer(nativePtr, columnIndex, rowIndex);
-    }
-
-    protected native ByteBuffer nativeGetByteBuffer(long nativeTablePtr, long columnIndex, long rowIndex);
-     */
-
     @Override
     public byte[] getBinaryByteArray(long columnIndex, long rowIndex) {
         return nativeGetByteArray(nativePtr, columnIndex, rowIndex);
     }
 
-    @Override
-    public Mixed getMixed(long columnIndex, long rowIndex) {
-        return nativeGetMixed(nativePtr, columnIndex, rowIndex);
-    }
-
-    @Override
-    public RealmFieldType getMixedType(long columnIndex, long rowIndex) {
-        return RealmFieldType.fromNativeValue(nativeGetMixedType(nativePtr, columnIndex, rowIndex));
-    }
-
     public long getLink(long columnIndex, long rowIndex) {
         return nativeGetLink(nativePtr, columnIndex, rowIndex);
     }
@@ -766,7 +727,7 @@ public Table getLinkTarget(long columnIndex) {
         long nativeTablePointer = nativeGetLinkTarget(nativePtr, columnIndex);
         try {
             // Copy context reference from parent
-            return new Table(context, this.parent, nativeTablePointer);
+            return new Table(this.sharedRealm, nativeTablePointer);
         }
         catch (RuntimeException e) {
             Table.nativeClose(nativeTablePointer);
@@ -774,55 +735,6 @@ public Table getLinkTarget(long columnIndex) {
         }
     }
 
-    /**
-     *
-     * Note: The subtable returned will have to be closed again after use.
-     * You can let javas garbage collector handle that or better yet call close() after use.
-     *
-     * @param columnIndex column index of the cell.
-     * @param rowIndex row index of the cell.
-     * @return the TableBase the subtable at the requested.
-     */
-    @Override
-    public Table getSubtable(long columnIndex, long rowIndex) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        long nativeSubtablePtr = nativeGetSubtable(nativePtr, columnIndex, rowIndex);
-        try {
-            // Copy context reference from parent
-            return new Table(context, this, nativeSubtablePtr);
-        }
-        catch (RuntimeException e) {
-            nativeClose(nativeSubtablePtr);
-            throw e;
-        }
-    }
-
-    // Below version will allow to getSubtable when number of available rows are not updated yet -
-    // which happens before an insertDone().
-
-    private Table getSubtableDuringInsert(long columnIndex, long rowIndex) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        long nativeSubtablePtr =  nativeGetSubtableDuringInsert(nativePtr, columnIndex, rowIndex);
-        try {
-            return new Table(context, this, nativeSubtablePtr);
-        }
-        catch (RuntimeException e) {
-            nativeClose(nativeSubtablePtr);
-            throw e;
-        }
-    }
-
-    public long getSubtableSize(long columnIndex, long rowIndex) {
-        return nativeGetSubtableSize(nativePtr, columnIndex, rowIndex);
-    }
-
-    public void clearSubtable(long columnIndex, long rowIndex) {
-        checkImmutable();
-        nativeClearSubtable(nativePtr, columnIndex, rowIndex);
-    }
-
     /**
      * Returns a non-checking Row. Incorrect use of this Row will cause a hard core crash.
      * If error checking is required, use {@link #getCheckedRow(long)} instead.
@@ -914,70 +826,17 @@ public void setString(long columnIndex, long rowIndex, String value) {
         }
     }
 
-    /**
-     * Sets the value for a (binary) cell.
-     *
-     * @param columnIndex column index of the cell.
-     * @param rowIndex row index of the cell.
-     * @param data the ByteBuffer must be allocated with {@code ByteBuffer.allocateDirect(len)}.
-     */
-
-    /*
-    @Override
-    public void setBinaryByteBuffer(long columnIndex, long rowIndex, ByteBuffer data) {
-        if (immutable) throwImmutable();
-        if (data == null)
-            throw new IllegalArgumentException("Null array");
-        if (data.isDirect())
-            nativeSetByteBuffer(nativePtr, columnIndex, rowIndex, data);
-        else
-            throw new RuntimeException("Currently ByteBuffer must be allocateDirect()."); // FIXME: support other than allocateDirect
-    }
-
-    protected native void nativeSetByteBuffer(long nativeTablePtr, long columnIndex, long rowIndex, ByteBuffer data);
-     */
-
-
     @Override
     public void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data) {
         checkImmutable();
         nativeSetByteArray(nativePtr, columnIndex, rowIndex, data);
     }
 
-    /**
-     * Sets the value for a (mixed typed) cell.
-     *
-     * @param columnIndex column index of the cell.
-     * @param rowIndex row index of the cell.
-     * @param data the value.
-     */
-    @Override
-    public void setMixed(long columnIndex, long rowIndex, Mixed data) {
-        checkImmutable();
-        if (data == null)
-            throw new IllegalArgumentException();
-        nativeSetMixed(nativePtr, columnIndex, rowIndex, data);
-    }
-
     public void setLink(long columnIndex, long rowIndex, long value) {
         checkImmutable();
         nativeSetLink(nativePtr, columnIndex, rowIndex, value);
     }
 
-    //TODO: Clean up this function
-    private void insertSubTable(long columnIndex, long rowIndex, Object value) {
-        checkImmutable();
-        if (value != null) {
-            // insert rows in subtable recursively
-            Table subtable = getSubtableDuringInsert(columnIndex, rowIndex);
-            int rows = ((Object[])value).length;
-            for (int i=0; i<rows; ++i) {
-                Object rowArr = ((Object[])value)[i];
-                subtable.add((Object[])rowArr);
-            }
-        }
-    }
-
     public void addSearchIndex(long columnIndex) {
         checkImmutable();
         nativeAddSearchIndex(nativePtr, columnIndex);
@@ -993,7 +852,7 @@ public void removeSearchIndex(long columnIndex) {
      *
      * @param columnName the name of the field that will function primary key. "" or {@code null} will remove any
      *                   previous set magic key.
-     * @throws {@link io.realm.exceptions.RealmException} if it is not possible to set the primary key due to the column
+     * @throws io.realm.exceptions.RealmException if it is not possible to set the primary key due to the column
      * not having distinct values (i.e. violating the primary key constraint).
      */
     public void setPrimaryKey(String columnName) {
@@ -1009,22 +868,27 @@ public void setPrimaryKey(long columnIndex) {
     }
 
     private Table getPrimaryKeyTable() {
-        Group group = getTableGroup();
-        if (group == null) {
+        if (sharedRealm == null) {
             return null;
         }
-
-        Table pkTable = group.getTable(PRIMARY_KEY_TABLE_NAME);
+        Table pkTable = sharedRealm.getTable(PRIMARY_KEY_TABLE_NAME);
         if (pkTable.getColumnCount() == 0) {
             pkTable.addColumn(RealmFieldType.STRING, PRIMARY_KEY_CLASS_COLUMN_NAME);
             pkTable.addColumn(RealmFieldType.STRING, PRIMARY_KEY_FIELD_COLUMN_NAME);
         } else {
-            migratePrimaryKeyTableIfNeeded(group, pkTable);
+            migratePrimaryKeyTableIfNeeded(sharedRealm.getGroupNative(), pkTable);
         }
 
         return pkTable;
     }
 
+    /**
+     * Invalidating a cached primary key column index for the table.
+     */
+    private void invalidateCachedPrimaryKeyIndex() {
+        cachedPrimaryKeyColumnIndex = NO_MATCH;
+    }
+
     /*
      * 1) Migration required to fix https://github.com/realm/realm-java/issues/1059
      * This will convert INTEGER column to the corresponding STRING column if needed.
@@ -1034,19 +898,8 @@ private Table getPrimaryKeyTable() {
      * This will remove the prefix "class_" from all table names in the pk_column
      * Any database created on Realm-Java 0.84.1 and below will have this error.
      */
-    private void migratePrimaryKeyTableIfNeeded(Group group, Table pkTable) {
-        nativeMigratePrimaryKeyTableIfNeeded(group.nativePtr, pkTable.nativePtr);
-    }
-
-    // Recursively look at parents until either a Group or null is found
-    Group getTableGroup() {
-        if (parent instanceof Group)  {
-            return (Group) parent;
-        } else if (parent instanceof Table) {
-            return ((Table) parent).getTableGroup();
-        } else {
-            return null; // Free table
-        }
+    private void migratePrimaryKeyTableIfNeeded(long groupNativePtr, Table pkTable) {
+        nativeMigratePrimaryKeyTableIfNeeded(groupNativePtr, pkTable.nativePtr);
     }
 
     public boolean hasSearchIndex(long columnIndex) {
@@ -1062,13 +915,10 @@ public void nullifyLink(long columnIndex, long rowIndex) {
     }
 
     boolean isImmutable() {
-        if (!(parent instanceof Table)) {
-            return parent != null && ((Group) parent).immutable;
-        } else {
-            return ((Table)parent).isImmutable();
-        }
+        return sharedRealm != null && !sharedRealm.isInTransaction();
     }
 
+    // This checking should be moved to SharedRealm level
     void checkImmutable() {
         if (isImmutable()) {
             throwImmutable();
@@ -1366,13 +1216,6 @@ public String getName() {
         return nativeGetName(nativePtr);
     }
 
-
-    // Optimize
-    public void optimize() {
-        checkImmutable();
-        nativeOptimize(nativePtr);
-    }
-
     @Override
     public String toJson() {
         return nativeToJson(nativePtr);
@@ -1380,17 +1223,34 @@ public String toJson() {
 
     @Override
     public String toString() {
-        return nativeToString(nativePtr, INFINITE);
-    }
+        long columnCount = getColumnCount();
+        String name = getName();
+        StringBuilder stringBuilder = new StringBuilder("The Table ");
+        if (name != null && !name.isEmpty()) {
+            stringBuilder.append(getName());
+            stringBuilder.append(" ");
+        }
+        if (hasPrimaryKey()) {
+            String pkFieldName = getColumnName(getPrimaryKey());
+            stringBuilder.append("has \'").append(pkFieldName).append("\' field as a PrimaryKey, and ");
+        }
+        stringBuilder.append("contains ");
+        stringBuilder.append(columnCount);
+        stringBuilder.append(" columns: ");
 
-    @Override
-    public String toString(long maxRows) {
-        return nativeToString(nativePtr, maxRows);
-    }
+        for (int i = 0; i < columnCount; i++) {
+            if (i != 0) {
+                stringBuilder.append(", ");
+            }
+            stringBuilder.append(getColumnName(i));
+        }
+        stringBuilder.append(".");
 
-    @Override
-    public String rowToString(long rowIndex) {
-        return nativeRowToString(nativePtr, rowIndex);
+        stringBuilder.append(" And ");
+        stringBuilder.append(size());
+        stringBuilder.append(" rows.");
+
+        return stringBuilder.toString();
     }
 
     @Override
@@ -1416,10 +1276,10 @@ public boolean hasSameSchema(Table table) {
     }
 
     /**
-     * Checks if a given table name is a meta-table, i.e. a table used by Realm to track its internal state.
+     * Checks if a given table name is a name for a model table.
      */
-    public static boolean isMetaTable(String tableName) {
-        return (tableName.equals(METADATA_TABLE_NAME) || tableName.equals(PRIMARY_KEY_TABLE_NAME));
+    public static boolean isModelTable(String tableName) {
+        return tableName.startsWith(TABLE_PREFIX);
     }
 
     /**
@@ -1441,9 +1301,9 @@ public static String tableNameToClassName(String tableName) {
     }
 
     protected native long createNative();
+    // Free the underlying table ref. It is important that the nativeTablePtr become a invalid pointer after return.
     static native void nativeClose(long nativeTablePtr);
     private native boolean nativeIsValid(long nativeTablePtr);
-    private native boolean nativeIsRootTable(long nativeTablePtr);
     private native long nativeAddColumn(long nativeTablePtr, int type, String name, boolean isNullable);
     private native long nativeAddColumnLink(long nativeTablePtr, int type, String name, long targetTablePtr);
     private native void nativeRenameColumn(long nativeTablePtr, long columnIndex, String name);
@@ -1451,19 +1311,16 @@ public static String tableNameToClassName(String tableName) {
     private native boolean nativeIsColumnNullable(long nativePtr, long columnIndex);
     private native void nativeConvertColumnToNullable(long nativeTablePtr, long columnIndex);
     private native void nativeConvertColumnToNotNullable(long nativePtr, long columnIndex);
-    private native void nativeUpdateFromSpec(long nativeTablePtr, TableSpec tableSpec);
     private native long nativeSize(long nativeTablePtr);
     private native void nativeClear(long nativeTablePtr);
     private native long nativeGetColumnCount(long nativeTablePtr);
-    private native TableSpec nativeGetTableSpec(long nativeTablePtr);
     private native String nativeGetColumnName(long nativeTablePtr, long columnIndex);
     private native long nativeGetColumnIndex(long nativeTablePtr, String columnName);
     private native int nativeGetColumnType(long nativeTablePtr, long columnIndex);
     private native void nativeRemove(long nativeTablePtr, long rowIndex);
     private native void nativeRemoveLast(long nativeTablePtr);
     private native void nativeMoveLastOver(long nativeTablePtr, long rowIndex);
-    private native long nativeAddEmptyRow(long nativeTablePtr, long rows);
-    private native long nativeGetSortedView(long nativeTableViewPtr, long columnIndex, boolean ascending);
+    public static native long nativeAddEmptyRow(long nativeTablePtr, long rows);
     private native long nativeGetSortedViewMulti(long nativeTableViewPtr, long[] columnIndices, boolean[] ascending);
     private native long nativeGetLong(long nativeTablePtr, long columnIndex, long rowIndex);
     private native boolean nativeGetBoolean(long nativeTablePtr, long columnIndex, long rowIndex);
@@ -1472,32 +1329,28 @@ public static String tableNameToClassName(String tableName) {
     private native long nativeGetTimestamp(long nativeTablePtr, long columnIndex, long rowIndex);
     private native String nativeGetString(long nativePtr, long columnIndex, long rowIndex);
     private native byte[] nativeGetByteArray(long nativePtr, long columnIndex, long rowIndex);
-    private native int nativeGetMixedType(long nativePtr, long columnIndex, long rowIndex);
-    private native Mixed nativeGetMixed(long nativeTablePtr, long columnIndex, long rowIndex);
     private native long nativeGetLink(long nativePtr, long columnIndex, long rowIndex);
+    public static native long nativeGetLinkView(long nativePtr, long columnIndex, long rowIndex);
     private native long nativeGetLinkTarget(long nativePtr, long columnIndex);
-    private native long nativeGetSubtable(long nativeTablePtr, long columnIndex, long rowIndex);
-    private native long nativeGetSubtableDuringInsert(long nativeTablePtr, long columnIndex, long rowIndex);
-    private native long nativeGetSubtableSize(long nativeTablePtr, long columnIndex, long rowIndex);
-    private native void nativeClearSubtable(long nativeTablePtr, long columnIndex, long rowIndex);
     native long nativeGetRowPtr(long nativePtr, long index);
-    private native void nativeSetLong(long nativeTablePtr, long columnIndex, long rowIndex, long value);
-    private native void nativeSetBoolean(long nativeTablePtr, long columnIndex, long rowIndex, boolean value);
-    private native void nativeSetFloat(long nativeTablePtr, long columnIndex, long rowIndex, float value);
-    private native void nativeSetDouble(long nativeTablePtr, long columnIndex, long rowIndex, double value);
-    private native void nativeSetTimestamp(long nativeTablePtr, long columnIndex, long rowIndex, long dateTimeValue);
-    private native void nativeSetString(long nativeTablePtr, long columnIndex, long rowIndex, String value);
-    private native void nativeSetNull(long nativeTablePtr, long columnIndex, long rowIndex);
-    private native void nativeSetByteArray(long nativePtr, long columnIndex, long rowIndex, byte[] data);
-    private native void nativeSetMixed(long nativeTablePtr, long columnIndex, long rowIndex, Mixed data);
-    private native void nativeSetLink(long nativeTablePtr, long columnIndex, long rowIndex, long value);
+    public static native void nativeSetLong(long nativeTablePtr, long columnIndex, long rowIndex, long value);
+    public static native void nativeSetLongUnique(long nativeTablePtr, long columnIndex, long rowIndex, long value);
+    public static native void nativeSetBoolean(long nativeTablePtr, long columnIndex, long rowIndex, boolean value);
+    public static native void nativeSetFloat(long nativeTablePtr, long columnIndex, long rowIndex, float value);
+    public static native void nativeSetDouble(long nativeTablePtr, long columnIndex, long rowIndex, double value);
+    public static native void nativeSetTimestamp(long nativeTablePtr, long columnIndex, long rowIndex, long dateTimeValue);
+    public static native void nativeSetString(long nativeTablePtr, long columnIndex, long rowIndex, String value);
+    public static native void nativeSetStringUnique(long nativeTablePtr, long columnIndex, long rowIndex, String value);
+    public static native void nativeSetNull(long nativeTablePtr, long columnIndex, long rowIndex);
+    public static native void nativeSetByteArray(long nativePtr, long columnIndex, long rowIndex, byte[] data);
+    public static native void nativeSetLink(long nativeTablePtr, long columnIndex, long rowIndex, long value);
     private native long nativeSetPrimaryKey(long privateKeyTableNativePtr, long nativePtr, String columnName);
     private native void nativeMigratePrimaryKeyTableIfNeeded(long groupNativePtr, long primaryKeyTableNativePtr);
     private native void nativeAddSearchIndex(long nativePtr, long columnIndex);
     private native void nativeRemoveSearchIndex(long nativePtr, long columnIndex);
     private native boolean nativeHasSearchIndex(long nativePtr, long columnIndex);
     private native boolean nativeIsNullLink(long nativePtr, long columnIndex, long rowIndex);
-    private native void nativeNullifyLink(long nativePtr, long columnIndex, long rowIndex);
+    public static native void nativeNullifyLink(long nativePtr, long columnIndex, long rowIndex);
     private native long nativeSumInt(long nativePtr, long columnIndex);
     private native long nativeMaximumInt(long nativePtr, long columnIndex);
     private native long nativeMinimumInt(long nativePtr, long columnIndex);
@@ -1517,28 +1370,26 @@ public static String tableNameToClassName(String tableName) {
     private native long nativeCountDouble(long nativePtr, long columnIndex, double value);
     private native long nativeCountString(long nativePtr, long columnIndex, String value);
     private native long nativeWhere(long nativeTablePtr);
-    private native long nativeFindFirstInt(long nativeTablePtr, long columnIndex, long value);
+    public static native long nativeFindFirstInt(long nativeTablePtr, long columnIndex, long value);
     private native long nativeFindFirstBool(long nativePtr, long columnIndex, boolean value);
     private native long nativeFindFirstFloat(long nativePtr, long columnIndex, float value);
     private native long nativeFindFirstDouble(long nativePtr, long columnIndex, double value);
     private native long nativeFindFirstTimestamp(long nativeTablePtr, long columnIndex, long dateTimeValue);
-    private native long nativeFindFirstString(long nativeTablePtr, long columnIndex, String value);
-    private native long nativeFindFirstNull(long nativePtr, long columnIndex);
+    public static native long nativeFindFirstString(long nativeTablePtr, long columnIndex, String value);
+    public static native long nativeFindFirstNull(long nativeTablePtr, long columnIndex);
     private native long nativeFindAllInt(long nativePtr, long columnIndex, long value);
     private native long nativeFindAllBool(long nativePtr, long columnIndex, boolean value);
     private native long nativeFindAllFloat(long nativePtr, long columnIndex, float value);
     private native long nativeFindAllDouble(long nativePtr, long columnIndex, double value);
-    private native long nativeFindAllTimestamp(long nativePtr, long columnIndex, long dateTimeValue);
+    // FIXME: Disabled in cpp code, see comments there
+    // private native long nativeFindAllTimestamp(long nativePtr, long columnIndex, long dateTimeValue);
     private native long nativeFindAllString(long nativePtr, long columnIndex, String value);
     private native long nativeLowerBoundInt(long nativePtr, long columnIndex, long value);
     private native long nativeUpperBoundInt(long nativePtr, long columnIndex, long value);
     private native void nativePivot(long nativeTablePtr, long stringCol, long intCol, int pivotType, long resultPtr);
     private native long nativeGetDistinctView(long nativePtr, long columnIndex);
     private native String nativeGetName(long nativeTablePtr);
-    private native void nativeOptimize(long nativeTablePtr);
     private native String nativeToJson(long nativeTablePtr);
-    private native String nativeToString(long nativeTablePtr, long maxRows);
     private native boolean nativeHasSameSchema(long thisTable, long otherTable);
     private native long nativeVersion(long nativeTablePtr);
-    private native String nativeRowToString(long nativeTablePtr, long rowIndex);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java b/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
index 32ebc23ed3..ff39eb50ef 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
@@ -37,8 +37,6 @@
      */
     Table getTable();
 
-    void close();
-
     /**
      * Returns the number of entries of the table/view.
      *
@@ -137,8 +135,6 @@
 
     byte[] getBinaryByteArray(long columnIndex, long rowIndex);
 
-    Mixed getMixed(long columnIndex, long rowIndex);
-
     /**
      * Gets the link index of a cell of the table/view identified by the columnIndex and rowIndex.
      *
@@ -148,14 +144,6 @@
      */
     long getLink(long columnIndex, long rowIndex);
 
-    RealmFieldType getMixedType(long columnIndex, long rowIndex);
-
-    Table getSubtable(long columnIndex, long rowIndex);
-
-    void clearSubtable(long columnIndex, long rowIndex);
-
-    long getSubtableSize(long columnIndex, long rowIndex);
-
     /**
      * Sets the long value for a particular cell identified by columnIndex and rowIndex of that cell.
      *
@@ -215,8 +203,6 @@
 
     void setDate(long columnIndex, long rowIndex, Date date);
 
-    void setMixed(long columnIndex, long rowIndex, Mixed data);
-
     boolean isNullLink(long columnIndex, long rowIndex);
 
     void nullifyLink(long columnIndex, long rowIndex);
@@ -334,10 +320,6 @@
 
     String toString();
 
-    String toString(long maxRows);
-
-    String rowToString(long rowIndex);
-
     TableQuery where();
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
index 0b304f86c5..5060ad4e23 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
@@ -115,18 +115,6 @@ public TableQuery endGroup() {
         return this;
     }
 
-    public TableQuery subtable(long columnIndex) {
-        nativeSubtable(nativePtr, columnIndex);
-        queryValidated = false;
-        return this;
-    }
-
-    public TableQuery endSubtable() {
-        nativeParent(nativePtr);
-        queryValidated = false;
-        return this;
-    }
-
     public TableQuery or() {
         nativeOr(nativePtr);
         queryValidated = false;
@@ -341,6 +329,20 @@ public TableQuery between(long columnIndex[], Date value1, Date value2){
         return this;
     }
 
+    // Query for Binary values.
+
+    public TableQuery equalTo(long[] columnIndices, byte[] value) {
+        nativeEqual(nativePtr, columnIndices, value);
+        queryValidated = false;
+        return this;
+    }
+
+    public TableQuery notEqualTo(long[] columnIndices, byte[] value) {
+        nativeNotEqual(nativePtr, columnIndices, value);
+        queryValidated = false;
+        return this;
+    }
+
     // Query for String values.
 
     private final static String STRING_NULL_ERROR_MESSAGE = "String value in query criteria must not be null.";
@@ -418,11 +420,15 @@ public TableQuery isNotEmpty(long[] columnIndices) {
 
     // Searching methods.
 
+    @Deprecated // Doesn't seem to be used
     public long find(long fromTableRow) {
         validateQuery();
         return nativeFind(nativePtr, fromTableRow);
     }
 
+    /**
+     * Returns the table row index for the first element matching the query.
+     */
     public long find() {
         validateQuery();
         return nativeFind(nativePtr, 0);
@@ -431,16 +437,13 @@ public long find() {
     /**
      * Performs a find query then handover the resulted Row (ready to be imported by another thread/shared_group).
      *
-     * @param bgSharedGroupPtr current shared_group from which to operate the query.
-     * @param nativeReplicationPtr replication pointer associated with the shared_group.
+     * @param sharedRealm current {@link SharedRealm }from which to operate the query.
      * @param ptrQuery query to run the the find against.
      * @return pointer to the handover result (table_view).
      */
-    public long findWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr, long ptrQuery) {
-        validateQuery();
+    public static long findWithHandover(SharedRealm sharedRealm, long ptrQuery) {
         // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        return nativeFindWithHandover(bgSharedGroupPtr, ptrQuery, 0);
+        return nativeFindWithHandover(sharedRealm.getNativePtr(), ptrQuery, 0);
     }
 
     public TableView findAll(long start, long end, long limit) {
@@ -474,45 +477,39 @@ public TableView findAll() {
     // handover find* methods
     // this will use a background SharedGroup to import the query (using the handover object)
     // run the query, and return the table view to the caller SharedGroup using the handover object.
-    public long findAllWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr,  long ptrQuery) throws BadVersionException {
-        validateQuery();
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        return nativeFindAllWithHandover(bgSharedGroupPtr, ptrQuery, 0, Table.INFINITE, Table.INFINITE);
+    public static long findAllWithHandover(SharedRealm sharedRealm, long ptrQuery) throws BadVersionException {
+        return nativeFindAllWithHandover(sharedRealm.getNativePtr(), ptrQuery, 0, Table.INFINITE, Table.INFINITE);
     }
 
-    public long findDistinctWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr,  long ptrQuery, long columnIndex) throws BadVersionException {
-        validateQuery();
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        return nativeGetDistinctViewWithHandover(bgSharedGroupPtr, ptrQuery, columnIndex);
+    public static long findDistinctWithHandover(SharedRealm sharedRealm, long ptrQuery, long columnIndex) throws BadVersionException {
+        return nativeGetDistinctViewWithHandover(sharedRealm.getNativePtr(), ptrQuery, columnIndex);
     }
 
-    public long findAllSortedWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr, long ptrQuery, long columnIndex, Sort sortOrder) throws BadVersionException {
-        validateQuery();
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        return nativeFindAllSortedWithHandover(bgSharedGroupPtr, ptrQuery, 0, Table.INFINITE, Table.INFINITE, columnIndex, sortOrder.getValue());
+    public static long findAllSortedWithHandover(SharedRealm sharedRealm, long ptrQuery, long columnIndex, Sort sortOrder) throws BadVersionException {
+        return nativeFindAllSortedWithHandover(sharedRealm.getNativePtr(), ptrQuery, 0, Table.INFINITE, Table.INFINITE, columnIndex, sortOrder.getValue());
     }
 
-    public long findAllMultiSortedWithHandover(long bgSharedGroupPtr, long nativeReplicationPtr, long ptrQuery, long[] columnIndices, Sort[] sortOrders) throws BadVersionException {
-        validateQuery();
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
+    public static long findAllMultiSortedWithHandover(SharedRealm sharedRealm, long ptrQuery, long[] columnIndices, Sort[] sortOrders) throws BadVersionException {
         boolean[] ascendings = getNativeSortOrderValues(sortOrders);
-        return nativeFindAllMultiSortedWithHandover(bgSharedGroupPtr, ptrQuery, 0, Table.INFINITE, Table.INFINITE, columnIndices, ascendings);
+        return nativeFindAllMultiSortedWithHandover(sharedRealm.getNativePtr(), ptrQuery, 0, Table.INFINITE, Table.INFINITE, columnIndices, ascendings);
     }
 
+    public static long[] batchUpdateQueries(SharedRealm sharedRealm, long[] handoverQueries, long[][] parameters,
+                                            long[][] queriesParameters, boolean[][] multiSortOrder)
+            throws BadVersionException {
+        return nativeBatchUpdateQueries(sharedRealm.getNativePtr(), handoverQueries, parameters, queriesParameters,
+                multiSortOrder);
+    }
     /**
      * Imports a TableView from a worker thread to the caller thread.
      *
      * @param handoverPtr pointer to the handover object
-     * @param callerSharedGroupPtr pointer to the SharedGroup on the caller thread.
+     * @param sharedRealm the SharedRealm on the caller thread.
      * @return the TableView on the caller thread.
      * @throws BadVersionException if the worker thread and caller thread are not at the same version.
      */
-    public TableView importHandoverTableView(long handoverPtr, long callerSharedGroupPtr) throws BadVersionException {
-        long nativeTvPtr = nativeImportHandoverTableViewIntoSharedGroup(handoverPtr, callerSharedGroupPtr);
+    public TableView importHandoverTableView(long handoverPtr, SharedRealm sharedRealm) throws BadVersionException {
+        long nativeTvPtr = nativeImportHandoverTableViewIntoSharedGroup(handoverPtr, sharedRealm.getNativePtr());
         try {
             return new TableView(this.context, this.table, nativeTvPtr);
         } catch (RuntimeException e) {
@@ -523,14 +520,25 @@ public TableView importHandoverTableView(long handoverPtr, long callerSharedGrou
         }
     }
 
+    /**
+     * Imports a row from a worker thread to the caller thread.
+     *
+     * @param handoverRowPtr pointer to the handover row object
+     * @param sharedRealm the SharedRealm on the caller thread.
+     * @return the row pointer on the caller thread.
+     */
+    public static long importHandoverRow(long handoverRowPtr, SharedRealm sharedRealm) {
+        return nativeImportHandoverRowIntoSharedGroup(handoverRowPtr, sharedRealm.getNativePtr());
+    }
+
     /**
      * Handovers the query, so it can be used by other SharedGroup (in different thread)
      *
-     * @param callerSharedGroupPtr native pointer to the SharedGroup holding the query
+     * @param sharedRealm the SharedGroup holding the query
      * @return native pointer to the handover query
      */
-    public long handoverQuery(long callerSharedGroupPtr) {
-        return nativeHandoverQuery(callerSharedGroupPtr, nativePtr);
+    public long handoverQuery(SharedRealm sharedRealm) {
+        return nativeHandoverQuery(sharedRealm.getNativePtr(), nativePtr);
     }
 
     //
@@ -713,17 +721,10 @@ public long count() {
         return nativeCount(nativePtr, 0, Table.INFINITE, Table.INFINITE);
     }
 
-    // Deletion.
-    public long remove(long start, long end) {
-        validateQuery();
-        if (table.isImmutable()) throwImmutable();
-        return nativeRemove(nativePtr, start, end, Table.INFINITE);
-    }
-
     public long remove() {
         validateQuery();
         if (table.isImmutable()) throwImmutable();
-        return nativeRemove(nativePtr, 0, Table.INFINITE, Table.INFINITE);
+        return nativeRemove(nativePtr);
     }
 
     /**
@@ -746,8 +747,6 @@ private void throwImmutable() {
     private native void nativeTableview(long nativeQueryPtr, long nativeTableViewPtr);
     private native void nativeGroup(long nativeQueryPtr);
     private native void nativeEndGroup(long nativeQueryPtr);
-    private native void nativeSubtable(long nativeQueryPtr, long columnIndex);
-    private native void nativeParent(long nativeQueryPtr);
     private native void nativeOr(long nativeQueryPtr);
     private native void nativeNot(long nativeQueryPtr);
     private native void nativeEqual(long nativeQueryPtr, long columnIndex[], long value);
@@ -779,6 +778,8 @@ private void throwImmutable() {
     private native void nativeLessTimestamp(long nativeQueryPtr, long columnIndex[], long value);
     private native void nativeLessEqualTimestamp(long nativeQueryPtr, long columnIndex[], long value);
     private native void nativeBetweenTimestamp(long nativeQueryPtr, long columnIndex[], long value1, long value2);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndices, byte[] value);
+    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndices, byte[] value);
     private native void nativeEqual(long nativeQueryPtr, long[] columnIndexes, String value, boolean caseSensitive);
     private native void nativeNotEqual(long nativeQueryPtr, long columnIndex[], String value, boolean caseSensitive);
     private native void nativeBeginsWith(long nativeQueryPtr, long columnIndices[], String value, boolean caseSensitive);
@@ -804,15 +805,15 @@ private void throwImmutable() {
     private native void nativeIsNull(long nativePtr, long columnIndices[]);
     private native void nativeIsNotNull(long nativePtr, long columnIndices[]);
     private native long nativeCount(long nativeQueryPtr, long start, long end, long limit);
-    private native long nativeRemove(long nativeQueryPtr, long start, long end, long limit);
-    private native long nativeImportHandoverTableViewIntoSharedGroup(long handoverTableViewPtr, long callerSharedGroupPtr) throws BadVersionException;
-    private native long nativeHandoverQuery(long callerSharedGroupPtr, long nativeQueryPtr);
-    public static native long nativeFindAllSortedWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long start, long end, long limit, long columnIndex, boolean ascending) throws BadVersionException;
-    public static native long nativeFindAllWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long start, long end, long limit) throws BadVersionException;
-    public static native long nativeGetDistinctViewWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long columnIndex) throws BadVersionException;
-    public static native long nativeFindWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long fromTableRow);
-    public static native long nativeFindAllMultiSortedWithHandover(long bgSharedGroupPtr, long nativeQueryPtr, long start, long end, long limit, long[] columnIndices, boolean[] ascending) throws BadVersionException;
-    public static native long nativeImportHandoverRowIntoSharedGroup(long handoverRowPtr, long callerSharedGroupPtr);
+    private native long nativeRemove(long nativeQueryPtr);
+    private native long nativeImportHandoverTableViewIntoSharedGroup(long handoverTableViewPtr, long callerSharedRealmPtr) throws BadVersionException;
+    private native long nativeHandoverQuery(long callerSharedRealmPtr, long nativeQueryPtr);
+    private static native long nativeFindAllSortedWithHandover(long bgSharedRealmPtr, long nativeQueryPtr, long start, long end, long limit, long columnIndex, boolean ascending) throws BadVersionException;
+    private static native long nativeFindAllWithHandover(long bgSharedRealmPtr, long nativeQueryPtr, long start, long end, long limit) throws BadVersionException;
+    private  static native long nativeGetDistinctViewWithHandover(long bgSharedRealmPtr, long nativeQueryPtr, long columnIndex) throws BadVersionException;
+    private static native long nativeFindWithHandover(long bgSharedRealmPtr, long nativeQueryPtr, long fromTableRow);
+    private static native long nativeFindAllMultiSortedWithHandover(long bgSharedRealmPtr, long nativeQueryPtr, long start, long end, long limit, long[] columnIndices, boolean[] ascending) throws BadVersionException;
+    private static native long nativeImportHandoverRowIntoSharedGroup(long handoverRowPtr, long callerSharedRealmPtr);
     public static native void nativeCloseQueryHandover(long nativePtr);
-    public static native long[] nativeBatchUpdateQueries(long bgSharedGroupPtr, long[] handoverQueries, long[][] parameters, long[][] queriesParameters, boolean[][] multiSortOrder) throws BadVersionException;
+    private static native long[] nativeBatchUpdateQueries(long bgSharedRealmPtr, long[] handoverQueries, long[][] parameters, long[][] queriesParameters, boolean[][] multiSortOrder) throws BadVersionException;
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableSchema.java b/realm/realm-library/src/main/java/io/realm/internal/TableSchema.java
index 0b7f8dfbe4..1a0f2528ae 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableSchema.java
@@ -21,8 +21,6 @@
 
 public interface TableSchema {
 
-    TableSchema getSubtableSchema(long columnIndex);
-
     long addColumn(RealmFieldType type, String name);
 
     void removeColumn(long columnIndex);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableSpec.java b/realm/realm-library/src/main/java/io/realm/internal/TableSpec.java
deleted file mode 100644
index b3a7cfbcf6..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/TableSpec.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import io.realm.RealmFieldType;
-
-@Keep
-public class TableSpec {
-
-    public static class ColumnInfo {
-
-        protected final RealmFieldType type;
-        protected final String name;
-        protected final TableSpec tableSpec;
-
-        public ColumnInfo(RealmFieldType type, String name) {
-            this.name = name;
-            this.type = type;
-            this.tableSpec = (type == RealmFieldType.UNSUPPORTED_TABLE) ? new TableSpec() : null;
-        }
-
-        @Override
-        public int hashCode() {
-            final int prime = 31;
-            int result = 1;
-            result = prime * result + ((name == null) ? 0 : name.hashCode());
-            result = prime * result + ((tableSpec == null) ? 0 : tableSpec.hashCode());
-            result = prime * result + ((type == null) ? 0 : type.hashCode());
-            return result;
-        }
-
-        @Override
-        public boolean equals(Object obj) {
-            if (this == obj)
-                return true;
-            if (obj == null)
-                return false;
-            if (getClass() != obj.getClass())
-                return false;
-            ColumnInfo other = (ColumnInfo) obj;
-            if (name == null) {
-                if (other.name != null)
-                    return false;
-            } else if (!name.equals(other.name))
-                return false;
-            if (tableSpec == null) {
-                if (other.tableSpec != null)
-                    return false;
-            } else if (!tableSpec.equals(other.tableSpec))
-                return false;
-            if (type != other.type)
-                return false;
-            return true;
-        }
-    }
-
-    private List<ColumnInfo> columnInfos;
-
-    public TableSpec() {
-        columnInfos = new ArrayList<ColumnInfo>();
-    }
-
-    public void addColumn(RealmFieldType type, String name) {
-        if (name.length() > 63) {
-            throw new IllegalArgumentException("Column names are currently limited to max 63 characters.");
-        }
-        columnInfos.add(new ColumnInfo(type, name));
-    }
-
-    protected void addColumn(int colTypeIndex, String name) {
-        addColumn(RealmFieldType.fromNativeValue(colTypeIndex), name);
-    }
-
-    public TableSpec addSubtableColumn(String name) {
-        if (name.length() > 63) {
-            throw new IllegalArgumentException("Column names are currently limited to max 63 characters.");
-        }
-        ColumnInfo columnInfo = new ColumnInfo(RealmFieldType.UNSUPPORTED_TABLE, name);
-        columnInfos.add(columnInfo);
-        return columnInfo.tableSpec;
-    }
-
-    public TableSpec getSubtableSpec(long columnIndex) {
-        return columnInfos.get((int) columnIndex).tableSpec;
-    }
-
-    public long getColumnCount() {
-        return columnInfos.size();
-    }
-
-    public RealmFieldType getColumnType(long columnIndex) {
-        return columnInfos.get((int) columnIndex).type;
-    }
-
-    public String getColumnName(long columnIndex) {
-        return columnInfos.get((int) columnIndex).name;
-    }
-
-    public long getColumnIndex(String name) {
-        for (int i = 0; i < columnInfos.size(); i++) {
-            ColumnInfo columnInfo = columnInfos.get(i);
-            if (columnInfo.name.equals(name)) {
-                return i;
-            }
-        }
-        return -1;
-    }
-
-    @Override
-    public int hashCode() {
-        final int prime = 31;
-        int result = 1;
-        result = prime * result + ((columnInfos == null) ? 0 : columnInfos.hashCode());
-        return result;
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (this == obj)
-            return true;
-        if (obj == null)
-            return false;
-        if (getClass() != obj.getClass())
-            return false;
-        TableSpec other = (TableSpec) obj;
-        if (columnInfos == null) {
-            if (other.columnInfos != null)
-                return false;
-        } else if (!columnInfos.equals(other.columnInfos))
-            return false;
-        return true;
-    }
-
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableView.java b/realm/realm-library/src/main/java/io/realm/internal/TableView.java
index 6928abda3a..fa3ce44194 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableView.java
@@ -16,13 +16,11 @@
 
 package io.realm.internal;
 
-import java.io.Closeable;
 import java.util.Date;
 import java.util.List;
 
 import io.realm.RealmFieldType;
 import io.realm.Sort;
-import io.realm.internal.log.RealmLog;
 
 /**
  * This class represents a view of a particular table. We can think of a tableview as a subset of a table. It contains
@@ -31,8 +29,7 @@
  * The view doesn't copy data from the table, but contains merely a list of row-references into the original table
  * with the real data.
  */
-public class TableView implements TableOrView, Closeable {
-    private static final boolean DEBUG = false; //true;
+public class TableView implements TableOrView {
     // Don't convert this into local variable and don't remove this.
     // Core requests TableView to hold the Query reference.
     @SuppressWarnings({"unused"})
@@ -74,20 +71,6 @@ public Table getTable() {
         return parent;
     }
 
-    @Override
-    public void close() {
-        synchronized (context) {
-            if (nativePtr != 0) {
-                nativeClose(nativePtr);
-
-                if (DEBUG) {
-                    RealmLog.d("==== TableView CLOSE, ptr= " + nativePtr);
-                }
-                nativePtr = 0;
-            }
-        }
-    }
-
     @Override
     protected void finalize() {
         synchronized (context) {
@@ -266,46 +249,10 @@ public ByteBuffer getBinaryByteBuffer(long columnIndex, long rowIndex){
         return nativeGetByteArray(nativePtr, columnIndex, rowIndex);
     }
 
-    @Override
-    public RealmFieldType getMixedType(long columnIndex, long rowIndex) {
-        return RealmFieldType.fromNativeValue(nativeGetMixedType(nativePtr, columnIndex, rowIndex));
-    }
-
-    @Override
-    public Mixed getMixed(long columnIndex, long rowIndex){
-        return nativeGetMixed(nativePtr, columnIndex, rowIndex);
-    }
-
     public long getLink(long columnIndex, long rowIndex){
         return nativeGetLink(nativePtr, columnIndex, rowIndex);
     }
 
-    @Override
-    public Table getSubtable(long columnIndex, long rowIndex) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        context.executeDelayedDisposal();
-        long nativeSubtablePtr = nativeGetSubtable(nativePtr, columnIndex, rowIndex);
-        try {
-            // Copy context reference from parent
-            return new Table(context, this.parent, nativeSubtablePtr);
-        }
-        catch (RuntimeException e) {
-            Table.nativeClose(nativeSubtablePtr);
-            throw e;
-        }
-    }
-
-    @Override
-    public long getSubtableSize(long columnIndex, long rowIndex) {
-        return nativeGetSubtableSize(nativePtr, columnIndex, rowIndex);
-    }
-
-    @Override
-    public void clearSubtable(long columnIndex, long rowIndex) {
-        if (parent.isImmutable()) throwImmutable();
-        nativeClearSubtable(nativePtr, columnIndex, rowIndex);
-    }
-
     // Methods for setting values.
 
     /**
@@ -409,19 +356,6 @@ public void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data){
         nativeSetByteArray(nativePtr, columnIndex, rowIndex, data);
     }
 
-    /**
-     * Sets the value for a particular (mixed typed) cell.
-     *
-     * @param columnIndex column index of the cell.
-     * @param rowIndex row index of the cell.
-     * @param data the value.
-     */
-    @Override
-    public void setMixed(long columnIndex, long rowIndex, Mixed data){
-        if (parent.isImmutable()) throwImmutable();
-        nativeSetMixed(nativePtr, columnIndex, rowIndex, data);
-    }
-
     public void setLink(long columnIndex, long rowIndex, long value){
         if (parent.isImmutable()) throwImmutable();
         nativeSetLink(nativePtr, columnIndex, rowIndex, value);
@@ -724,17 +658,24 @@ public String toJson() {
 
     @Override
     public String toString() {
-        return nativeToString(nativePtr, 500);
-    }
+        long columnCount = getColumnCount();
+        StringBuilder stringBuilder = new StringBuilder("The TableView contains ");
+        stringBuilder.append(columnCount);
+        stringBuilder.append(" columns: ");
+
+        for (int i = 0; i < columnCount; i++) {
+            if (i != 0) {
+                stringBuilder.append(", ");
+            }
+            stringBuilder.append(getColumnName(i));
+        }
+        stringBuilder.append(".");
 
-    @Override
-    public String toString(long maxRows) {
-        return nativeToString(nativePtr, maxRows);
-    }
+        stringBuilder.append(" And ");
+        stringBuilder.append(size());
+        stringBuilder.append(" rows.");
 
-    @Override
-    public String rowToString(long rowIndex) {
-        return nativeRowToString(nativePtr, rowIndex);
+        return stringBuilder.toString();
     }
 
     @Override
@@ -846,12 +787,7 @@ public long syncIfNeeded() {
     private native long nativeGetTimestamp(long nativeViewPtr, long columnIndex, long rowIndex);
     private native String nativeGetString(long nativeViewPtr, long columnIndex, long rowIndex);
     private native byte[] nativeGetByteArray(long nativePtr, long columnIndex, long rowIndex);
-    private native int nativeGetMixedType(long nativeViewPtr, long columnIndex, long rowIndex);
-    private native Mixed nativeGetMixed(long nativeViewPtr, long columnIndex, long rowIndex);
     private native long nativeGetLink(long nativeViewPtr, long columnIndex, long rowIndex);
-    private native long nativeGetSubtable(long nativeViewPtr, long columnIndex, long rowIndex);
-    private native long nativeGetSubtableSize(long nativeTablePtr, long columnIndex, long rowIndex);
-    private native void nativeClearSubtable(long nativeTablePtr, long columnIndex, long rowIndex);
     private native void nativeSetLong(long nativeViewPtr, long columnIndex, long rowIndex, long value);
     private native void nativeSetBoolean(long nativeViewPtr, long columnIndex, long rowIndex, boolean value);
     private native void nativeSetFloat(long nativeViewPtr, long columnIndex, long rowIndex, float value);
@@ -859,7 +795,6 @@ public long syncIfNeeded() {
     private native void nativeSetTimestampValue(long nativePtr, long columnIndex, long rowIndex, long dateTimeValue);
     private native void nativeSetString(long nativeViewPtr, long columnIndex, long rowIndex, String value);
     private native void nativeSetByteArray(long nativePtr, long columnIndex, long rowIndex, byte[] data);
-    private native void nativeSetMixed(long nativeViewPtr, long columnIndex, long rowIndex, Mixed value);
     private native void nativeSetLink(long nativeViewPtr, long columnIndex, long rowIndex, long value);
     private native boolean nativeIsNullLink(long nativePtr, long columnIndex, long rowIndex);
     private native void nativeNullifyLink(long nativePtr, long columnIndex, long rowIndex);
@@ -896,12 +831,10 @@ public long syncIfNeeded() {
     private native void nativeSortMulti(long nativeTableViewPtr, long columnIndices[], boolean ascending[]);
     private native long createNativeTableView(Table table, long nativeTablePtr);
     private native String nativeToJson(long nativeViewPtr);
-    private native String nativeToString(long nativeTablePtr, long maxRows);
-    private native String nativeRowToString(long nativeTablePtr, long rowIndex);
     private native long nativeWhere(long nativeViewPtr);
     private native void nativePivot(long nativeTablePtr, long stringCol, long intCol, int pivotType, long result);
-    private native long nativeDistinct(long nativeViewPtr, long columnIndex);
+    private native void nativeDistinct(long nativeViewPtr, long columnIndex);
     private native long nativeSyncIfNeeded(long nativeTablePtr);
-    private native long nativeDistinctMulti(long nativeViewPtr, long[] columnIndexes);
+    private native void nativeDistinctMulti(long nativeViewPtr, long[] columnIndexes);
     private native long nativeSync(long nativeTablePtr);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/IllegalMixedTypeException.java b/realm/realm-library/src/main/java/io/realm/internal/TestUtil.java
similarity index 56%
rename from realm/realm-library/src/main/java/io/realm/internal/IllegalMixedTypeException.java
rename to realm/realm-library/src/main/java/io/realm/internal/TestUtil.java
index 5dcb1a61a0..4af5a15360 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/IllegalMixedTypeException.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TestUtil.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014 Realm Inc.
+ * Copyright 2016 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,22 +16,15 @@
 
 package io.realm.internal;
 
-@SuppressWarnings("serial")
-public class IllegalMixedTypeException extends RuntimeException {
+class TestUtil {
 
-    public IllegalMixedTypeException(Throwable cause) {
-        super(cause);
-    }
-
-    public IllegalMixedTypeException() {
-    }
-
-    public IllegalMixedTypeException(String message) {
-        super(message);
-    }
-
-    public IllegalMixedTypeException(String message, Throwable cause) {
-        super(message, cause);
+    static {
+        // Any internal class with static native methods that uses Realm Core must load the Realm Core library
+        // themselves as it otherwise might not have been loaded.
+        RealmCore.loadLibrary();
     }
 
+    public native static long getMaxExceptionNumber();
+    public native static String getExpectedMessage(long exceptionKind);
+    public native static void testThrowExceptions(long exceptionKind);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
index d7eda8092f..b867d42d6b 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
@@ -24,7 +24,7 @@
  * Wrapper around a Row in Realm Core.
  *
  * IMPORTANT: All access to methods using this class are non-checking. Safety guarantees are given by the annotation
- * processor and {@link RealmProxyMediator#validateTable(Class, ImplicitTransaction)} which is called before the typed
+ * processor and {@link RealmProxyMediator#validateTable(Class, SharedRealm)} which is called before the typed
  * API can be used.
  *
  * For low-level access to Row data where error checking is required, use {@link CheckedRow}.
@@ -158,16 +158,6 @@ public String getString(long columnIndex) {
         return nativeGetByteArray(nativePointer, columnIndex);
     }
 
-    @Override
-    public Mixed getMixed(long columnIndex) {
-        return nativeGetMixed(nativePointer, columnIndex);
-    }
-
-    @Override
-    public RealmFieldType getMixedType(long columnIndex) {
-        return RealmFieldType.fromNativeValue(nativeGetMixedType(nativePointer, columnIndex));
-    }
-
     @Override
     public long getLink(long columnIndex) {
         return nativeGetLink(nativePointer, columnIndex);
@@ -245,15 +235,6 @@ public void setBinaryByteArray(long columnIndex, byte[] data) {
         nativeSetByteArray(nativePointer, columnIndex, data);
     }
 
-    @Override
-    public void setMixed(long columnIndex, Mixed data) {
-        parent.checkImmutable();
-        if (data == null) {
-            throw new IllegalArgumentException("Null data is not allowed");
-        }
-        nativeSetMixed(nativePointer, columnIndex, data);
-    }
-
     @Override
     public void setLink(long columnIndex, long value) {
         parent.checkImmutable();
@@ -315,9 +296,7 @@ public boolean hasColumn(String fieldName) {
     protected native String nativeGetString(long nativePtr, long columnIndex);
     protected native boolean nativeIsNullLink(long nativeRowPtr, long columnIndex);
     protected native byte[] nativeGetByteArray(long nativePtr, long columnIndex);
-    protected native int nativeGetMixedType(long nativePtr, long columnIndex);
-    protected native Mixed nativeGetMixed(long nativeRowPtr, long columnIndex);
-    protected native long nativeGetLinkView(long nativePtr, long columnIndex);
+    public static native long nativeGetLinkView(long nativePtr, long columnIndex);
     protected native void nativeSetLong(long nativeRowPtr, long columnIndex, long value);
     protected native void nativeSetBoolean(long nativeRowPtr, long columnIndex, boolean value);
     protected native void nativeSetFloat(long nativeRowPtr, long columnIndex, float value);
@@ -326,7 +305,6 @@ public boolean hasColumn(String fieldName) {
     protected native void nativeSetTimestamp(long nativeRowPtr, long columnIndex, long dateTimeValue);
     protected native void nativeSetString(long nativeRowPtr, long columnIndex, String value);
     protected native void nativeSetByteArray(long nativePtr, long columnIndex, byte[] data);
-    protected native void nativeSetMixed(long nativeRowPtr, long columnIndex, Mixed data);
     protected native void nativeSetLink(long nativeRowPtr, long columnIndex, long value);
     protected native void nativeNullifyLink(long nativeRowPtr, long columnIndex);
     static native void nativeClose(long nativeRowPtr);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Util.java b/realm/realm-library/src/main/java/io/realm/internal/Util.java
index 1f075b5110..f6eb85b851 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Util.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Util.java
@@ -48,42 +48,6 @@ public static String getTablePrefix() {
     }
     static native String nativeGetTablePrefix();
 
-
-    // Testcases run in nativeCode
-    public enum Testcase {
-        Exception_ClassNotFound(0),
-        Exception_NoSuchField(1),
-        Exception_NoSuchMethod(2),
-        Exception_IllegalArgument(3),
-        Exception_IOFailed(4),
-        Exception_FileNotFound(5),
-        Exception_FileAccessError(6),
-        Exception_IndexOutOfBounds(7),
-        Exception_TableInvalid(8),
-        Exception_UnsupportedOperation(9),
-        Exception_OutOfMemory(10),
-        Exception_FatalError(11),
-        Exception_RuntimeError(12),
-        Exception_RowInvalid(13),
-        Exception_EncryptionNotSupported(14),
-        Exception_CrossTableLink(15),
-        Exception_BadVersion(16);
-
-        private final int nativeTestcase;
-        Testcase(int nativeValue) {
-            this.nativeTestcase = nativeValue;
-        }
-
-        public String expectedResult(long parm1) {
-            return nativeTestcase(nativeTestcase, false, parm1);
-        }
-        public String execute(long parm1) {
-            return nativeTestcase(nativeTestcase, true, parm1);
-        }
-    }
-
-    static native String nativeTestcase(int testcase, boolean dotest, long parm1);
-
     /**
      * Normalizes a input class to it's original RealmObject class so it is transparent whether or not the input class
      * was a RealmProxy class.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Version.java b/realm/realm-library/src/main/java/io/realm/internal/Version.java
deleted file mode 100644
index fa47bb34d9..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/Version.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-public class Version {
-
-    static final int CORE_MIN_MAJOR = 0;
-    static final int CORE_MIN_MINOR = 1;
-    static final int CORE_MIN_PATCH = 6;
-    static final int REQUIRED_JNI_VERSION = 23;
-
-    public enum Feature {
-        Feature_Debug(0),
-        Feature_Replication(1);
-
-        Feature(int nativeValue) {
-            this.nativeFeature = nativeValue;
-        }
-
-        @SuppressWarnings("unused")
-        private final int nativeFeature;
-    }
-
-    public static String getCoreVersion() {
-        return nativeGetVersion();
-    }
-
-    public static String getVersion() {
-        // Currently Core version and Java version is the same
-        return getCoreVersion();
-    }
-
-    public static boolean hasFeature(Feature feature) {
-        return nativeHasFeature(feature.ordinal());
-    }
-
-    public static boolean coreLibVersionCompatible(boolean throwIfNot) {
-        String errTxt;
-        boolean compatible = nativeIsAtLeast(CORE_MIN_MAJOR, CORE_MIN_MINOR, CORE_MIN_PATCH);
-        if (!compatible) {
-            errTxt = "Version mismatch between realm.jar ("
-                    + CORE_MIN_MAJOR + "." + CORE_MIN_MINOR + "." + CORE_MIN_PATCH
-                    + ") and native core library (" + getCoreVersion() + ")";
-            if (throwIfNot)
-                throw new RuntimeException(errTxt);
-            System.err.println(errTxt);
-            return false;
-        }
-
-        compatible = (nativeGetAPIVersion() == REQUIRED_JNI_VERSION);
-        if (!compatible) {
-            errTxt = "Native lib API is version " + nativeGetAPIVersion()
-                     + " != " +  REQUIRED_JNI_VERSION + " which is expected by the jar.";
-            if (throwIfNot)
-                throw new RuntimeException(errTxt);
-            System.err.println(errTxt);                    
-        }
-        return compatible;
-    }
-
-    static native String nativeGetVersion();
-    static native boolean nativeHasFeature(int feature);    
-    static native boolean nativeIsAtLeast(int major, int minor, int patch);    
-    static native int nativeGetAPIVersion();
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/WriteTransaction.java b/realm/realm-library/src/main/java/io/realm/internal/WriteTransaction.java
deleted file mode 100644
index af3fae4a20..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/WriteTransaction.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-public class WriteTransaction extends Group {
-
-    private final SharedGroup db;
-    private boolean committed;
-
-    public void commit() {
-        if (!committed) {
-            db.commit();
-            committed = true;
-        }
-        else {
-            throw new IllegalStateException("You can only commit once after a WriteTransaction has been made.");
-        }
-    }
-
-    public void rollback() {
-        db.rollback();
-    }
-
-    @Override
-    public void close() {
-        if (!committed) {
-            rollback();
-        }
-    }
-
-    WriteTransaction(Context context,SharedGroup db, long nativePtr) {
-        super(context, nativePtr, false);    // Group is mutable
-        this.db = db;
-        committed = false;
-    }
-
-    protected void finalize() {} // Nullify the actions of Group.finalize()
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/android/AndroidLogger.java b/realm/realm-library/src/main/java/io/realm/internal/android/AndroidLogger.java
deleted file mode 100644
index 196b0450b3..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/android/AndroidLogger.java
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.android;
-
-import android.util.Log;
-
-import io.realm.internal.log.Logger;
-import io.realm.internal.log.RealmLog;
-
-public class AndroidLogger implements Logger {
-
-    private static final int LOG_ENTRY_MAX_LENGTH = 4000;
-    private int minimumLogLevel = RealmLog.VERBOSE;
-    private String logTag = "REALM";
-
-    /**
-     * Manually sets a logging tag.
-     *
-     * @param tag Logging tag to use for all subsequent logging calls.
-     */
-    public void setTag(String tag) {
-        logTag = tag;
-    }
-
-    /**
-     * Overrides the provided logger behavior and only log if log entry has a level equal or higher.
-     *
-     * @param logLevel the minimum log level to report.
-     */
-    public void setMinimumLogLevel(int logLevel) {
-        minimumLogLevel = logLevel;
-    }
-
-    // Inspired by https://github.com/JakeWharton/timber/blob/master/timber/src/main/java/timber/log/Timber.java
-    private void log(int logLevel, String message, Throwable t) {
-        if (logLevel < minimumLogLevel) {
-            return;
-        }
-        if (message == null || message.length() == 0) {
-            if (t != null) {
-                message = Log.getStackTraceString(t);
-            } else {
-                return; // Don't log if message is null and there is no throwable
-            }
-        } else if (t != null) {
-            message += "\n" + Log.getStackTraceString(t);
-        }
-
-       if (message.length() < 4000) {
-            Log.println(logLevel, logTag, message);
-        } else {
-           logMessageIgnoringLimit(logLevel, logTag, message);
-        }
-    }
-
-    /**
-     * Inspired by:
-     * http://stackoverflow.com/questions/8888654/android-set-max-length-of-logcat-messages
-     * https://github.com/jakubkrolewski/timber/blob/feature/logging_long_messages/timber/src/main/java/timber/log/Timber.java
-     */
-    private void logMessageIgnoringLimit(int logLevel, String tag, String message) {
-        while (message.length() != 0) {
-            int nextNewLineIndex = message.indexOf('\n');
-            int chunkLength = nextNewLineIndex != -1 ? nextNewLineIndex : message.length();
-            chunkLength = Math.min(chunkLength, LOG_ENTRY_MAX_LENGTH);
-            String messageChunk = message.substring(0, chunkLength);
-            Log.println(logLevel, tag, messageChunk);
-
-            if (nextNewLineIndex != -1 && nextNewLineIndex == chunkLength) {
-                // Don't print out the \n twice.
-                message = message.substring(chunkLength + 1);
-            } else {
-                message = message.substring(chunkLength);
-            }
-        }
-    }
-
-    @Override
-    public void v(String message) {
-        log(RealmLog.VERBOSE, message, null);
-    }
-
-    @Override
-    public void v(String message, Throwable t) {
-        log(RealmLog.VERBOSE, message, t);
-    }
-
-    @Override
-    public void d(String message) {
-        log(RealmLog.DEBUG, message, null);
-    }
-
-    @Override
-    public void d(String message, Throwable t) {
-        log(RealmLog.DEBUG, message, t);
-    }
-
-    @Override
-    public void i(String message) {
-        log(RealmLog.INFO, message, null);
-    }
-
-    @Override
-    public void i(String message, Throwable t) {
-        log(RealmLog.INFO, message, t);
-    }
-
-    @Override
-    public void w(String message) {
-        log(RealmLog.WARN, message, null);
-    }
-
-    @Override
-    public void w(String message, Throwable t) {
-        log(RealmLog.WARN, message, t);
-    }
-
-    @Override
-    public void e(String message) {
-        log(RealmLog.ERROR, message, null);
-    }
-
-    @Override
-    public void e(String message, Throwable t) {
-        log(RealmLog.ERROR, message, t);
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/android/DebugAndroidLogger.java b/realm/realm-library/src/main/java/io/realm/internal/android/DebugAndroidLogger.java
deleted file mode 100644
index bf2de63996..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/android/DebugAndroidLogger.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.android;
-
-import io.realm.internal.log.RealmLog;
-
-/**
- * RealmLogger for Android debug builds. This logs everything as default.
- */
-public class DebugAndroidLogger extends AndroidLogger {
-
-    public DebugAndroidLogger() {
-        setMinimumLogLevel(RealmLog.VERBOSE);
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/android/ReleaseAndroidLogger.java b/realm/realm-library/src/main/java/io/realm/internal/android/ReleaseAndroidLogger.java
deleted file mode 100644
index ce7e28966f..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/android/ReleaseAndroidLogger.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.android;
-
-import io.realm.internal.log.RealmLog;
-
-/**
- * This is the RealmLogger used by Realm in Release builds. It only logs warnings and errors by default.
- */
-public class ReleaseAndroidLogger extends AndroidLogger {
-
-    public ReleaseAndroidLogger() {
-        setMinimumLogLevel(RealmLog.WARN);
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java b/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
index 179a839f1f..b711d45de9 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
@@ -16,8 +16,6 @@
 
 package io.realm.internal.async;
 
-import android.os.Handler;
-
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.IdentityHashMap;
@@ -26,16 +24,25 @@
 import io.realm.RealmConfiguration;
 import io.realm.RealmModel;
 import io.realm.RealmResults;
+import io.realm.internal.RealmNotifier;
 import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.SharedGroup;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.TableQuery;
-import io.realm.internal.log.RealmLog;
+import io.realm.log.RealmLog;
 
 /**
  * Manages the update of async queries.
  */
 public class QueryUpdateTask implements Runnable {
+
+    public enum NotifyEvent {
+        COMPLETE_ASYNC_RESULTS,
+        COMPLETE_ASYNC_OBJECT,
+        COMPLETE_UPDATE_ASYNC_QUERIES,
+        THROW_BACKGROUND_EXCEPTION,
+    }
+
     // true if updating RealmResults, false if updating RealmObject, can't mix both
     // the builder pattern will prevent this.
     private final static int MODE_UPDATE_REALM_RESULTS = 0;
@@ -45,21 +52,21 @@
     private RealmConfiguration realmConfiguration;
     private List<Builder.QueryEntry> realmResultsEntries;
     private Builder.QueryEntry realmObjectEntry;
-    private WeakReference<Handler> callerHandler;
-    private int message;
+    private WeakReference<RealmNotifier> callerNotifier;
+    private NotifyEvent event;
 
     private QueryUpdateTask (int mode,
                              RealmConfiguration realmConfiguration,
                              List<Builder.QueryEntry> listOfRealmResults,
                              Builder.QueryEntry realmObject,
-                             WeakReference<Handler> handler,
-                             int message) {
+                             WeakReference<RealmNotifier> notifier,
+                             NotifyEvent event) {
         this.updateMode = mode;
         this.realmConfiguration = realmConfiguration;
         this.realmResultsEntries = listOfRealmResults;
         this.realmObjectEntry = realmObject;
-        this.callerHandler = handler;
-        this.message = message;
+        this.callerNotifier = notifier;
+        this.event = event;
     }
 
     public static Builder.RealmConfigurationStep newBuilder() {
@@ -68,44 +75,62 @@ private QueryUpdateTask (int mode,
 
     @Override
     public void run() {
-        SharedGroup sharedGroup = null;
+        SharedRealm sharedRealm = null;
         try {
-            sharedGroup = new SharedGroup(realmConfiguration.getPath(),
-                    SharedGroup.IMPLICIT_TRANSACTION,
-                    realmConfiguration.getDurability(),
-                    realmConfiguration.getEncryptionKey());
+            sharedRealm = SharedRealm.getInstance(realmConfiguration);
 
             Result result;
             boolean updateSuccessful;
             if (updateMode == MODE_UPDATE_REALM_RESULTS) {
                 result = Result.newRealmResultsResponse();
                 AlignedQueriesParameters alignedParameters = prepareQueriesParameters();
-                long[] handoverTableViewPointer = TableQuery.nativeBatchUpdateQueries(sharedGroup.getNativePointer(),
+                long[] handoverTableViewPointer = TableQuery.batchUpdateQueries(sharedRealm,
                         alignedParameters.handoverQueries,
                         alignedParameters.queriesParameters,
                         alignedParameters.multiSortColumnIndices,
                         alignedParameters.multiSortOrder);
                 swapPointers(result, handoverTableViewPointer);
                 updateSuccessful = true;
-                result.versionID = sharedGroup.getVersion();
+                result.versionID = sharedRealm.getVersionID();
 
             } else {
                 result = Result.newRealmObjectResponse();
-                updateSuccessful = updateRealmObjectQuery(sharedGroup, result);
-                result.versionID = sharedGroup.getVersion();
+                updateSuccessful = updateRealmObjectQuery(sharedRealm, result);
+                result.versionID = sharedRealm.getVersionID();
             }
 
-            Handler handler = callerHandler.get();
-            if (updateSuccessful && !isTaskCancelled() && isAliveHandler(handler)) {
-                handler.obtainMessage(message, result).sendToTarget();
+            RealmNotifier notifier = callerNotifier.get();
+            if (updateSuccessful && !isTaskCancelled() && notifier != null) {
+                switch (event) {
+                    case COMPLETE_ASYNC_RESULTS:
+                        notifier.completeAsyncResults(result);
+                        break;
+                    case COMPLETE_ASYNC_OBJECT:
+                        notifier.completeAsyncObject(result);
+                        break;
+                    case COMPLETE_UPDATE_ASYNC_QUERIES:
+                        notifier.completeUpdateAsyncQueries(result);
+                        break;
+                    default:
+                        throw new IllegalStateException(String.format("%s is not handled here.", event));
+                }
             }
 
-        } catch (Exception e) {
-            RealmLog.e(e.getMessage(), e);
+        } catch (BadVersionException e) {
+            // In some rare race conditions, this can happen. In that case, just ignore the error.
+            RealmLog.debug("Query update task could not complete due to a BadVersionException. " +
+                    "Retry is scheduled by a REALM_CHANGED event.");
+
+        } catch (Throwable e) {
+            RealmLog.error(e);
+            RealmNotifier notifier = callerNotifier.get();
+            if (notifier!= null) {
+                notifier.throwBackgroundException(e);
+            }
 
         } finally {
-            if (sharedGroup != null) {
-                sharedGroup.close();
+            if (sharedRealm != null) {
+                sharedRealm.close();
             }
         }
     }
@@ -174,13 +199,12 @@ private void swapPointers(Result result, long[] handoverTableViewPointer) {
         }
     }
 
-    private boolean updateRealmObjectQuery(SharedGroup sharedGroup, Result result) {
+    private boolean updateRealmObjectQuery(SharedRealm sharedRealm, Result result) {
         if (!isTaskCancelled()) {
             switch (realmObjectEntry.queryArguments.type) {
                 case ArgumentsHolder.TYPE_FIND_FIRST: {
-                    long handoverRowPointer = TableQuery.
-                            nativeFindWithHandover(sharedGroup.getNativePointer(),
-                                    realmObjectEntry.handoverQueryPointer, 0);
+                    long handoverRowPointer = TableQuery.findWithHandover(sharedRealm,
+                                    realmObjectEntry.handoverQueryPointer);
                     result.updatedRow.put(realmObjectEntry.element, handoverRowPointer);
                     break;
                 }
@@ -199,15 +223,11 @@ private boolean isTaskCancelled() {
         return Thread.currentThread().isInterrupted();
     }
 
-    private boolean isAliveHandler(Handler handler) {
-        return handler != null && handler.getLooper().getThread().isAlive();
-    }
-
     // result of the async query
     public static class Result {
         public IdentityHashMap<WeakReference<RealmResults<? extends RealmModel>>, Long> updatedTableViews;
         public IdentityHashMap<WeakReference<RealmObjectProxy>, Long> updatedRow;
-        public SharedGroup.VersionID versionID;
+        public SharedRealm.VersionID versionID;
 
         public static Result newRealmResultsResponse() {
             Result result = new Result();
@@ -235,13 +255,13 @@ public static Result newRealmObjectResponse() {
          .realmConfiguration(null, null)
          .add(null, 0, null)
          .add(null, 0, null)
-         .sendToHandler(null, 0)
+         .sendToNotifier(null, 0)
          .build();
 
      QueryUpdateTask task2 = QueryUpdateTask.newBuilder()
          .realmConfiguration(null, null)
          .addObject(null, 0, null)
-         .sendToHandler(null, 0)
+         .sendToNotifier(null, 0)
          .build();
      */
     public static class Builder {
@@ -262,11 +282,11 @@ HandlerStep addObject(WeakReference<? extends RealmModel> weakReference,
             RealmResultsQueryStep add(WeakReference<RealmResults<? extends RealmModel>> weakReference,
                                           long handoverQueryPointer,
                                           ArgumentsHolder queryArguments);
-            BuilderStep sendToHandler(Handler handler, int message);
+            BuilderStep sendToNotifier(RealmNotifier notifier, NotifyEvent event);
         }
 
         public interface HandlerStep {
-            BuilderStep sendToHandler (Handler handler, int message);
+            BuilderStep sendToNotifier(RealmNotifier notifier, NotifyEvent event);
         }
 
         public interface BuilderStep {
@@ -277,8 +297,8 @@ RealmResultsQueryStep add(WeakReference<RealmResults<? extends RealmModel>> weak
             private RealmConfiguration realmConfiguration;
             private List<QueryEntry> realmResultsEntries;
             private QueryEntry realmObjectEntry;
-            private WeakReference<Handler> callerHandler;
-            private int message;
+            private WeakReference<RealmNotifier> callerNotifier;
+            private NotifyEvent event;
 
             @Override
             public UpdateQueryStep realmConfiguration(RealmConfiguration realmConfiguration) {
@@ -307,9 +327,9 @@ public HandlerStep addObject(WeakReference<? extends RealmModel> weakReference,
             }
 
             @Override
-            public BuilderStep sendToHandler(Handler handler, int message) {
-                this.callerHandler = new WeakReference<Handler>(handler);
-                this.message = message;
+            public BuilderStep sendToNotifier(RealmNotifier notifier, NotifyEvent event) {
+                this.callerNotifier = new WeakReference<RealmNotifier>(notifier);
+                this.event = event;
                 return this;
             }
 
@@ -320,8 +340,8 @@ public QueryUpdateTask build() {
                         realmConfiguration,
                         realmResultsEntries,
                         realmObjectEntry,
-                        callerHandler,
-                        message);
+                        callerNotifier,
+                        event);
             }
         }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java b/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
index 24246f1526..482cbdc1b6 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
@@ -24,6 +24,8 @@
 import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.ReentrantLock;
 
+import io.realm.Realm;
+
 /**
  * Custom thread pool settings, instances of this executor can be paused, and resumed, this will also set
  * appropriate number of Threads & wrap submitted tasks to set the thread priority according to
@@ -59,19 +61,46 @@ private RealmThreadPoolExecutor(int corePoolSize, int maxPoolSize) {
                 new ArrayBlockingQueue<Runnable>(QUEUE_SIZE));
     }
 
-    @Override
-    public Future<?> submit(Runnable task) {
+    /**
+     * Submits a runnable for executing a transaction.
+     *
+     * @param task the task to submit
+     * @return a future representing pending completion of the task
+     */
+    public Future<?> submitTransaction(Runnable task) {
+        Future<?> future = super.submit(new BgPriorityRunnable(task));
+        return future;
+    }
+
+    /**
+     * Submits a runnable for updating a query.
+     *
+     * @param task the task to submit
+     * @return a future representing pending completion of the task
+     */
+    public Future<?> submitQueryUpdate(Runnable task) {
         return super.submit(new BgPriorityRunnable(task));
     }
 
-    @Override
-    public <T> Future<T> submit(Callable<T> task) {
+    /**
+     * Submits a runnable for executing a query.
+     *
+     * @param task the task to submit
+     * @return a future representing pending completion of the task
+     */
+    public <T> Future<T> submitQuery(Callable<T> task) {
         return super.submit(new BgPriorityCallable<T>(task));
     }
 
+    /**
+     * Method invoked prior to executing the given Runnable to pause execution of the thread.
+     *
+     * @param t the thread that will run task r
+     * @param r the task that will be executed
+     */
     @Override
     protected void beforeExecute(Thread t, Runnable r) {
-            super.beforeExecute(t, r);
+        super.beforeExecute(t, r);
         pauseLock.lock();
         try {
             while (isPaused) unpaused.await();
@@ -94,6 +123,9 @@ public void pause() {
         }
     }
 
+    /**
+     * Resume executing any scheduled tasks.
+     */
     public void resume() {
         pauseLock.lock();
         try {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/log/Logger.java b/realm/realm-library/src/main/java/io/realm/internal/log/Logger.java
deleted file mode 100644
index 50eba1905c..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/log/Logger.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.log;
-
-/**
- * Interface for Realm logger implementations.
- */
-public interface Logger {
-    void v(String message);
-    void v(String message, Throwable t);
-    void d(String message);
-    void d(String message, Throwable t);
-    void i(String message);
-    void i(String message, Throwable t);
-    void w(String message);
-    void w(String message, Throwable t);
-    void e(String message);
-    void e(String message, Throwable t);
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/log/RealmLog.java b/realm/realm-library/src/main/java/io/realm/internal/log/RealmLog.java
deleted file mode 100644
index 5c1ef9f3d4..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/log/RealmLog.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.log;
-
-import java.util.List;
-import java.util.concurrent.CopyOnWriteArrayList;
-
-/**
- * Logger implementation for Realm. This can be used to transparently change logging behavior between Android and Java.
- *
- * This class supports adding multiple logger implementations.
- */
-public final class RealmLog {
-
-    // Log levels
-    public static final int VERBOSE = 2;
-    public static final int DEBUG = 3;
-    public static final int INFO = 4;
-    public static final int WARN = 5;
-    public static final int ERROR = 6;
-    public static final int ASSERT = 7;
-    public static final int NONE = 8;
-
-    private static final List<Logger> LOGGERS = new CopyOnWriteArrayList<Logger>();
-
-    /**
-     * Adds a logger implementation.
-     *
-     * @param logger the reference to a {@link Logger} implementation.
-     */
-    public static void add(Logger logger) {
-        if (logger == null) {
-            throw new IllegalArgumentException("A non-null logger has to be provided");
-        }
-        LOGGERS.add(logger);
-    }
-
-    /**
-     * Removes a current logger implementation.
-     *
-     * @param logger.
-     */
-    public static void remove(Logger logger) {
-        if (logger == null) {
-            throw new IllegalArgumentException("A non-null logger has to be provided");
-        }
-        LOGGERS.remove(logger);
-    }
-
-    public static void v(String message) {
-        for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(i).v(message);
-        }
-    }
-
-    public static void v(String message, Throwable t) {
-        for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(i).v(message, t);
-        }
-    }
-
-    public static void d(String message) {
-        for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(i).d(message);
-        }
-    }
-
-    public static void d(String message, Throwable t) {
-        for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(i).d(message, t);
-        }
-    }
-
-    public static void i(String message) {
-        for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(i).i(message);
-        }
-    }
-
-    public static void i(String message, Throwable t) {
-        for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(i).i(message, t);
-        }
-    }
-
-    public static void w(String message) {
-        for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(i).w(message);
-        }
-    }
-
-    public static void w(String message, Throwable t) {
-        for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(i).w(message, null);
-        }
-    }
-
-    public static void e(String message)  {
-        for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(i).e(message);
-        }
-    }
-
-    public static void e(String message, Throwable t) {
-        for (int i = 0; i < LOGGERS.size(); i++) {
-            LOGGERS.get(i).v(message, t);
-        }
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
index cfe7ba1198..4b94846c22 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
@@ -22,6 +22,7 @@
 import org.json.JSONObject;
 
 import java.io.IOException;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
@@ -31,9 +32,10 @@
 import io.realm.Realm;
 import io.realm.RealmModel;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.Row;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.Util;
 
@@ -57,15 +59,16 @@ public CompositeMediator(RealmProxyMediator... mediators) {
     }
 
     @Override
-    public Table createTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction) {
+    public Table createTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm) {
         RealmProxyMediator mediator = getMediator(clazz);
-        return mediator.createTable(clazz, transaction);
+        return mediator.createTable(clazz, sharedRealm);
     }
 
     @Override
-    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction) {
+    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm,
+                                    boolean allowExtraColumns) {
         RealmProxyMediator mediator = getMediator(clazz);
-        return mediator.validateTable(clazz, transaction);
+        return mediator.validateTable(clazz, sharedRealm, allowExtraColumns);
     }
 
     @Override
@@ -81,9 +84,14 @@ public String getTableName(Class<? extends RealmModel> clazz) {
     }
 
     @Override
-    public <E extends RealmModel> E newInstance(Class<E> clazz, ColumnInfo columnInfo) {
+    public <E extends RealmModel> E newInstance(Class<E> clazz,
+                                                Object baseRealm,
+                                                Row row,
+                                                ColumnInfo columnInfo,
+                                                boolean acceptDefaultValue,
+                                                List<String> excludeFields) {
         RealmProxyMediator mediator = getMediator(clazz);
-        return mediator.newInstance(clazz, columnInfo);
+        return mediator.newInstance(clazz, baseRealm, row, columnInfo, acceptDefaultValue, excludeFields);
     }
 
     @Override
@@ -97,6 +105,30 @@ public String getTableName(Class<? extends RealmModel> clazz) {
         return mediator.copyOrUpdate(realm, object, update, cache);
     }
 
+    @Override
+    public void insert(Realm realm, RealmModel object, Map<RealmModel, Long> cache) {
+        RealmProxyMediator mediator = getMediator(Util.getOriginalModelClass(object.getClass()));
+        mediator.insert(realm, object, cache);
+    }
+
+    @Override
+    public void insert(Realm realm, Collection<? extends RealmModel> objects) {
+        RealmProxyMediator mediator = getMediator(Util.getOriginalModelClass(Util.getOriginalModelClass(objects.iterator().next().getClass())));
+        mediator.insert(realm, objects);
+    }
+
+    @Override
+    public void insertOrUpdate(Realm realm, RealmModel object, Map<RealmModel, Long> cache) {
+        RealmProxyMediator mediator = getMediator(Util.getOriginalModelClass(object.getClass()));
+        mediator.insertOrUpdate(realm, object, cache);
+    }
+
+    @Override
+    public void insertOrUpdate(Realm realm, Collection<? extends RealmModel> objects) {
+        RealmProxyMediator mediator = getMediator(Util.getOriginalModelClass(Util.getOriginalModelClass(objects.iterator().next().getClass())));
+        mediator.insertOrUpdate(realm, objects);
+    }
+
     @Override
     public <E extends RealmModel> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update) throws JSONException {
         RealmProxyMediator mediator = getMediator(clazz);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
index ed5122e3e9..af48ac87da 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
@@ -32,9 +32,10 @@
 import io.realm.Realm;
 import io.realm.RealmModel;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
+import io.realm.internal.Row;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.Util;
 
@@ -73,15 +74,16 @@ public RealmProxyMediator getOriginalMediator() {
     }
 
     @Override
-    public Table createTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction) {
+    public Table createTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm) {
         checkSchemaHasClass(clazz);
-        return originalMediator.createTable(clazz, transaction);
+        return originalMediator.createTable(clazz, sharedRealm);
     }
 
     @Override
-    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, ImplicitTransaction transaction) {
+    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm,
+                                    boolean allowExtraColumns) {
         checkSchemaHasClass(clazz);
-        return originalMediator.validateTable(clazz, transaction);
+        return originalMediator.validateTable(clazz, sharedRealm, allowExtraColumns);
     }
 
     @Override
@@ -97,9 +99,14 @@ public String getTableName(Class<? extends RealmModel> clazz) {
     }
 
     @Override
-    public <E extends RealmModel> E newInstance(Class<E> clazz, ColumnInfo columnInfo) {
+    public <E extends RealmModel> E newInstance(Class<E> clazz,
+                                                Object baseRealm,
+                                                Row row,
+                                                ColumnInfo columnInfo,
+                                                boolean acceptDefaultValue,
+                                                List<String> excludeFields) {
         checkSchemaHasClass(clazz);
-        return originalMediator.newInstance(clazz, columnInfo);
+        return originalMediator.newInstance(clazz, baseRealm, row, columnInfo, acceptDefaultValue, excludeFields);
     }
 
     @Override
@@ -113,6 +120,30 @@ public String getTableName(Class<? extends RealmModel> clazz) {
         return originalMediator.copyOrUpdate(realm, object, update, cache);
     }
 
+    @Override
+    public void insert(Realm realm, RealmModel object, Map<RealmModel, Long> cache) {
+        checkSchemaHasClass(Util.getOriginalModelClass(object.getClass()));
+        originalMediator.insert(realm, object, cache);
+    }
+
+    @Override
+    public void insert(Realm realm, Collection<? extends RealmModel> objects) {
+        checkSchemaHasClass(Util.getOriginalModelClass(objects.iterator().next().getClass()));
+        originalMediator.insert(realm, objects);
+    }
+
+    @Override
+    public void insertOrUpdate(Realm realm, RealmModel object, Map<RealmModel, Long> cache) {
+        checkSchemaHasClass(Util.getOriginalModelClass(object.getClass()));
+        originalMediator.insertOrUpdate(realm, object, cache);
+    }
+
+    @Override
+    public void insertOrUpdate(Realm realm, Collection<? extends RealmModel> objects) {
+        checkSchemaHasClass(Util.getOriginalModelClass(objects.iterator().next().getClass()));
+        originalMediator.insertOrUpdate(realm, objects);
+    }
+
     @Override
     public <E extends RealmModel> E createOrUpdateUsingJsonObject(Class<E> clazz, Realm realm, JSONObject json, boolean update) throws JSONException {
         checkSchemaHasClass(clazz);
diff --git a/realm/realm-library/src/main/java/io/realm/log/AndroidLogger.java b/realm/realm-library/src/main/java/io/realm/log/AndroidLogger.java
new file mode 100644
index 0000000000..9f460aeeed
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/log/AndroidLogger.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.log;
+
+import android.util.Log;
+
+import static android.util.Log.getStackTraceString;
+
+/**
+ * Logger implementation outputting to Android LogCat.
+ * Androids {@link Log}levels are mapped to Realm {@link LogLevel}s using the following table:
+ *
+ * <table summary="Comparison of Realm and Android log levels">
+ * <tr>
+ *     <td>{@link LogLevel#ALL}</td><td>{@link Log#VERBOSE}</td>
+ *     <td>{@link LogLevel#TRACE}</td><td>{@link Log#VERBOSE}</td>
+ *     <td>{@link LogLevel#DEBUG}</td><td>{@link Log#DEBUG}</td>
+ *     <td>{@link LogLevel#INFO}</td><td>{@link Log#INFO}</td>
+ *     <td>{@link LogLevel#WARN}</td><td>{@link Log#WARN}</td>
+ *     <td>{@link LogLevel#ERROR}</td><td>{@link Log#ERROR}</td>
+ *     <td>{@link LogLevel#FATAL}</td><td>{@link Log#ERROR}</td>
+ *     <td>{@link LogLevel#OFF}</td><td>Not supported. Remove the logger instead.</td>
+ * </tr>
+ * </table>
+ */
+public class AndroidLogger implements Logger {
+
+    private static final int LOG_ENTRY_MAX_LENGTH = 4000;
+    private final int minimumLogLevel;
+    private volatile String logTag = "REALM";
+
+    /**
+     * Creates an logger that outputs to logcat.
+     *
+     * @param androidLogLevel Android log level
+     */
+    public AndroidLogger(int androidLogLevel) {
+        if (androidLogLevel < Log.VERBOSE || androidLogLevel > Log.ASSERT) {
+            throw new IllegalArgumentException("Unknown android log level: " + androidLogLevel);
+        }
+        minimumLogLevel = androidLogLevel;
+    }
+
+    /**
+     * Sets the logging tag used when outputting to LogCat. The default value is "REALM".
+     *
+     * @param tag Logging tag to use for all subsequent logging calls.
+     */
+    public void setTag(String tag) {
+        logTag = tag;
+    }
+
+    @Override
+    public int getMinimumNativeDebugLevel() {
+        // Map Android log level to Realms log levels
+        switch (minimumLogLevel) {
+            case Log.VERBOSE:   return LogLevel.TRACE;
+            case Log.DEBUG:     return LogLevel.DEBUG;
+            case Log.INFO:      return LogLevel.INFO;
+            case Log.WARN:      return LogLevel.WARN;
+            case Log.ERROR:     return LogLevel.ERROR;
+            case Log.ASSERT:    return LogLevel.FATAL;
+            default:
+                throw new IllegalStateException("Unknown log level: " + minimumLogLevel);
+        }
+    }
+
+    // Inspired by https://github.com/JakeWharton/timber/blob/master/timber/src/main/java/timber/log/Timber.java
+    private void log(int androidLogLevel, Throwable t, String message, Object... args) {
+        if (androidLogLevel < minimumLogLevel) {
+            return;
+        }
+        if (message == null) {
+            if (t == null) {
+                return; // Ignore event if message is null and there's no throwable.
+            }
+            message = getStackTraceString(t);
+        } else {
+            if (args != null && args.length > 0) {
+                message = String.format(message, args);
+            }
+            if (t != null) {
+                message += "\n" + getStackTraceString(t);
+            }
+        }
+
+        // Message fit one line. Just print and exit
+        if (message.length() < LOG_ENTRY_MAX_LENGTH) {
+            Log.println(androidLogLevel, logTag, message);
+            return;
+        }
+
+        // Message does not fit one line.
+        // Split by line, then ensure each line can fit into Log's maximum length.
+        for (int i = 0, length = message.length(); i < length; i++) {
+            int newline = message.indexOf('\n', i);
+            newline = newline != -1 ? newline : length;
+            do {
+                int end = Math.min(newline, i + LOG_ENTRY_MAX_LENGTH);
+                String part = message.substring(i, end);
+                Log.println(androidLogLevel, logTag, part);
+                i = end;
+            } while (i < newline);
+        }
+    }
+
+    @Override
+    public void trace(Throwable throwable, String message, Object... args) {
+        log(Log.VERBOSE, throwable, message, args);
+    }
+
+    @Override
+    public void debug(Throwable throwable, String message, Object... args) {
+        log(Log.DEBUG, throwable, message, args);
+    }
+
+    @Override
+    public void info(Throwable throwable, String message, Object... args) {
+        log(Log.INFO, throwable, message, args);
+    }
+
+    @Override
+    public void warn(Throwable throwable, String message, Object... args) {
+        log(Log.WARN, throwable, message, args);
+    }
+
+    @Override
+    public void error(Throwable throwable, String message, Object... args) {
+        log(Log.ERROR, throwable, message, args);
+    }
+
+    @Override
+    public void fatal(Throwable throwable, String message, Object... args) {
+        log(Log.ASSERT, throwable, message, args);
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/log/LogLevel.java b/realm/realm-library/src/main/java/io/realm/log/LogLevel.java
new file mode 100644
index 0000000000..8333656322
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/log/LogLevel.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.log;
+
+/**
+ * The Log levels defined and used by Realm when logging events in the API.
+ *
+ * Realm uses the log levels defined by Log4J:
+ * https://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/Level.html
+ *
+ * @see RealmLog#add(Logger)
+ */
+public class LogLevel {
+
+    /**
+     * The ALL has the lowest possible rank and is intended to turn on all logging.
+     */
+    public static final int ALL = 1;
+
+    /**
+     * The TRACE level designates finer-grained informational events than DEBUG.
+     */
+    public static final int TRACE = 2;
+
+    /**
+     * The DEBUG level designates fine-grained informational events that are mostly useful to debug an application.
+     */
+    public static final int DEBUG = 3;
+
+    /**
+     * The INFO level designates informational messages that highlight the progress of the application at
+     * coarse-grained level.
+     */
+    public static final int INFO = 4;
+
+    /**
+     * The WARN level designates potentially harmful situations.
+     */
+    public static final int WARN = 5;
+
+    /**
+     * The ERROR level designates error events that might still allow the application to continue running.
+     */
+    public static final int ERROR = 6;
+
+    /**
+     * The FATAL level designates very severe error events that will presumably lead the application to abort.
+     */
+    public static final int FATAL = 7;
+
+    /**
+     * The OFF has the highest possible rank and is intended to turn off logging.
+     */
+    public static final int OFF = 8;
+}
+
+
diff --git a/realm/realm-library/src/main/java/io/realm/log/Logger.java b/realm/realm-library/src/main/java/io/realm/log/Logger.java
new file mode 100644
index 0000000000..7da472b4a8
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/log/Logger.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.log;
+
+/**
+ * Interface for custom loggers that can be registered at {@link RealmLog#add(Logger)}.
+ * The different log levels are described in {@link LogLevel}.
+ */
+public interface Logger {
+
+    /**
+     * Defines which {@link LogLevel} events this logger cares about from the native components.
+     * <p>
+     * If multiple loggers are registered, the minimum value among all loggers is used.
+     * <p>
+     * Note that sending log events from the native layer is relatively expensive, so only set this value to events
+     * that are truly useful.
+     *
+     * @return the minimum {@link LogLevel} native events this logger cares about.
+     */
+    int getMinimumNativeDebugLevel();
+
+    /**
+     * Handles a {@link LogLevel#TRACE} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional additional message.
+     * @param args optional arguments used to format the message using {@link String#format(String, Object...)}.
+     */
+    void trace(Throwable throwable, String message, Object... args);
+
+    /**
+     * Handles a {@link LogLevel#DEBUG} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional additional message.
+     * @param args optional arguments used to format the message using {@link String#format(String, Object...)}.
+     */
+    void debug(Throwable throwable, String message, Object... args);
+
+    /**
+     * Handles an {@link LogLevel#INFO} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional additional message.
+     * @param args optional arguments used to format the message using {@link String#format(String, Object...)}.
+     */
+    void info(Throwable throwable, String message, Object... args);
+
+    /**
+     * Handles a {@link LogLevel#WARN} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional additional message.
+     * @param args optional arguments used to format the message using {@link String#format(String, Object...)}.
+     */
+    void warn(Throwable throwable, String message, Object... args);
+
+    /**
+     * Handles an {@link LogLevel#ERROR} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional additional message.
+     * @param args optional arguments used to format the message using {@link String#format(String, Object...)}.
+     */
+    void error(Throwable throwable, String message, Object... args);
+
+    /**
+     * Handles a {@link LogLevel#FATAL} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional additional message.
+     * @param args optional arguments used to format the message using {@link String#format(String, Object...)}.
+     */
+    void fatal(Throwable throwable, String message, Object... args);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/log/RealmLog.java b/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
new file mode 100644
index 0000000000..f83173214a
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
@@ -0,0 +1,301 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.log;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import io.realm.internal.Keep;
+import io.realm.internal.Util;
+
+/**
+ * Global logger used by all Realm components.
+ * Custom loggers can be added by registering classes implementing {@link Logger}.
+ */
+@Keep
+public final class RealmLog {
+
+    private static final Logger[] NO_LOGGERS = new Logger[0];
+
+    // All of the below should be modified together under under a lock on LOGGERS.
+    private static final List<Logger> LOGGERS = new ArrayList<>();
+    private static volatile Logger[] loggersAsArray = NO_LOGGERS;
+    private static int minimumNativeLogLevel = Integer.MAX_VALUE;
+
+    /**
+     * Adds a logger implementation that will be notified on log events.
+     *
+     * @param logger the reference to a {@link Logger} implementation.
+     */
+    public static void add(Logger logger) {
+        if (logger == null) {
+            throw new IllegalArgumentException("A non-null logger has to be provided");
+        }
+        synchronized (LOGGERS) {
+            LOGGERS.add(logger);
+            int minimumLogLevel = logger.getMinimumNativeDebugLevel();
+            if (minimumLogLevel < minimumNativeLogLevel) {
+                setMinimumNativeDebugLevel(minimumLogLevel);
+            }
+            loggersAsArray = LOGGERS.toArray(new Logger[LOGGERS.size()]);
+        }
+    }
+
+    private static void setMinimumNativeDebugLevel(int nativeDebugLevel) {
+        minimumNativeLogLevel = nativeDebugLevel;
+        Util.setDebugLevel(nativeDebugLevel); // Log level for Realm Core
+    }
+
+    /**
+     * Removes the given logger if it is currently added.
+     *
+     * @return {@code true} if the logger was removed, {@code false} otherwise.
+     */
+    public static boolean remove(Logger logger) {
+        if (logger == null) {
+            throw new IllegalArgumentException("A non-null logger has to be provided");
+        }
+        synchronized (LOGGERS) {
+            LOGGERS.remove(logger);
+            int newMinLevel = Integer.MAX_VALUE;
+            for (int i = 0; i < LOGGERS.size(); i++) {
+                int logMin = LOGGERS.get(i).getMinimumNativeDebugLevel();
+                if (logMin < newMinLevel) {
+                    newMinLevel = logMin;
+                }
+            }
+            setMinimumNativeDebugLevel(newMinLevel);
+            loggersAsArray = LOGGERS.toArray(new Logger[LOGGERS.size()]);
+        }
+        return true;
+    }
+
+    /**
+     * Remove all loggers.
+     */
+    public static void clear() {
+        synchronized (LOGGERS) {
+            LOGGERS.clear();
+            setMinimumNativeDebugLevel(Integer.MAX_VALUE);
+            loggersAsArray = NO_LOGGERS;
+        }
+    }
+
+    /**
+     * Logs a {@link LogLevel#TRACE} exception.
+     *
+     * @param throwable exception to log.
+     */
+    public static void trace(Throwable throwable) {
+        trace(throwable, null);
+    }
+
+    /**
+     * Logs a {@link LogLevel#TRACE} event.
+     *
+     * @param message message to log.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void trace(String message, Object... args) {
+        trace(null, message, args);
+    }
+
+    /**
+     * Logs a {@link LogLevel#TRACE} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional message.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void trace(Throwable throwable, String message, Object... args) {
+        Logger[] loggers = loggersAsArray;
+        //noinspection ForLoopReplaceableByForEach
+        for (int i = 0; i < loggers.length; i++) {
+            loggers[i].trace(throwable, message, args);
+        }
+    }
+
+    /**
+     * Logs a {@link LogLevel#DEBUG} exception.
+     *
+     * @param throwable exception to log.
+     */
+    public static void debug(Throwable throwable) {
+        debug(throwable, null);
+    }
+
+    /**
+     * Logs a {@link LogLevel#DEBUG} event.
+     *
+     * @param message message to log.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void debug(String message, Object... args) {
+        debug(null, message, args);
+    }
+
+    /**
+     * Logs a {@link LogLevel#DEBUG} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional message.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void debug(Throwable throwable, String message, Object... args) {
+        Logger[] loggers = loggersAsArray;
+        //noinspection ForLoopReplaceableByForEach
+        for (int i = 0; i < loggers.length; i++) {
+            loggers[i].debug(throwable, message, args);
+        }
+    }
+
+    /**
+     * Logs an {@link LogLevel#INFO} exception.
+     *
+     * @param throwable exception to log.
+     */
+    public static void info(Throwable throwable) {
+        info(throwable, null);
+    }
+
+    /**
+     * Logs an {@link LogLevel#INFO} event.
+     *
+     * @param message message to log.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void info(String message, Object... args) {
+        info(null, message, args);
+    }
+
+    /**
+     * Logs an {@link LogLevel#INFO} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional message.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void info(Throwable throwable, String message, Object... args) {
+        Logger[] loggers = loggersAsArray;
+        //noinspection ForLoopReplaceableByForEach
+        for (int i = 0; i < loggers.length; i++) {
+            loggers[i].info(throwable, message, args);
+        }
+    }
+
+    /**
+     * Logs a {@link LogLevel#WARN} exception.
+     *
+     * @param throwable exception to log.
+     */
+    public static void warn(Throwable throwable) {
+        warn(throwable, null);
+    }
+
+    /**
+     * Logs a {@link LogLevel#WARN} event.
+     *
+     * @param message message to log.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void warn(String message, Object... args) {
+        warn(null, message, args);
+    }
+
+    /**
+     * Logs a {@link LogLevel#WARN} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional message.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void warn(Throwable throwable, String message, Object... args) {
+        Logger[] loggers = loggersAsArray;
+        //noinspection ForLoopReplaceableByForEach
+        for (int i = 0; i < loggers.length; i++) {
+            loggers[i].warn(throwable, message, args);
+        }
+    }
+
+    /**
+     * Logs an {@link LogLevel#ERROR} exception.
+     *
+     * @param throwable exception to log.
+     */
+    public static void error(Throwable throwable) {
+        error(throwable, null);
+    }
+
+    /**
+     * Logs an {@link LogLevel#ERROR} event.
+     *
+     * @param message message to log.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void error(String message, Object... args) {
+        error(null, message, args);
+    }
+
+    /**
+     * Logs an {@link LogLevel#ERROR} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional message.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void error(Throwable throwable, String message, Object... args) {
+        Logger[] loggers = loggersAsArray;
+        //noinspection ForLoopReplaceableByForEach
+        for (int i = 0; i < loggers.length; i++) {
+            loggers[i].error(throwable, message, args);
+        }
+    }
+
+    /**
+     * Logs a {@link LogLevel#FATAL} exception.
+     *
+     * @param throwable exception to log.
+     */
+    public static void fatal(Throwable throwable) {
+        fatal(throwable, null);
+    }
+
+    /**
+     * Logs an {@link LogLevel#FATAL} event.
+     *
+     * @param message message to log.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void fatal(String message, Object... args) {
+        fatal(null, message, args);
+    }
+
+    /**
+     * Logs a {@link LogLevel#FATAL} event.
+     *
+     * @param throwable optional exception to log.
+     * @param message optional message.
+     * @param args optional args used to format the message using {@link String#format(String, Object...)}.
+     */
+    public static void fatal(Throwable throwable, String message, Object... args) {
+        Logger[] loggers = loggersAsArray;
+        //noinspection ForLoopReplaceableByForEach
+        for (int i = 0; i < loggers.length; i++) {
+            loggers[i].fatal(throwable, message, args);
+        }
+    }
+}
diff --git a/realm/settings.gradle b/realm/settings.gradle
index 82a197b850..4540b8669d 100644
--- a/realm/settings.gradle
+++ b/realm/settings.gradle
@@ -1,4 +1,3 @@
 // Realm projects
 include 'realm-library'
 include 'realm-annotations-processor'
-include 'realm-jni'
diff --git a/version.txt b/version.txt
index 5902d52cce..6753471d56 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-1.1.0-SNAPSHOT
+2.0.0-SNAPSHOT
