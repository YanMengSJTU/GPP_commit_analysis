diff --git a/CHANGELOG.md b/CHANGELOG.md
index cbb017878e..3924864ea4 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,36 +1,53 @@
+## 5.11.0(YYYY-MM-DD)
+
+### Enhancements 
+* Added support for incremental annotation processing added in Gradle 4.7. (Issue [#5906](https://github.com/realm/realm-java/issues/5906)).
+
+### Fixed
+* None.
+
+### Compatibility
+* Realm Object Server: 3.11.0 or later.
+* File format: Generates Realms with format v9 (Reads and upgrades all previous formats).
+* APIs are backwards compatible with all previous release of realm-java in the 5.x.y series.
+
+### Internal
+* None.
+
+
 ## 5.10.1(YYYY-MM-DD)
 
-## Enhancements 
-* None
+###Enhancements 
+*  None.
 
-## Fixed
+### Fixed
 *  Native crash happening if bulk updating a field in a `RealmResult` would cause the object to no longer be part of the query result. (Issue [#6478](https://github.com/realm/realm-java/issues/6478), since 5.8.0).
 
-## Compatibility
+### Compatibility
 * Realm Object Server: 3.11.0 or later.
 * File format: Generates Realms with format v9 (Reads and upgrades all previous formats).
 * APIs are backwards compatible with all previous release of realm-java in the 5.x.y series.
 
-## Internal
+### Internal
 * Updated to Object Store commit: cc3db611b1c10d2b890a92fa0f4b8291bc0f3ba2
 
 
 ## 5.10.0(2019-03-22)
 
-## Enhancements
+### Enhancements
 * [ObjectServer] Added 4 new fields to query-based Subscriptions: `createdAt`, `updatedAt`, `expiresAt` and `timeToLive`. These make it possible to better reason about and control current subscriptions. (Issue [#6453](https://github.com/realm/realm-java/issues/6453))
 * [ObjectServer] Added the option of updating the query controlled by a Subscription using either `RealmQuery.findAllAsync(String name, boolean update)`,  `RealmQuery.subscribe(String name, boolean update)` or `Subscription.setQuery(RealmQuery query)`. (Issue [#6453](https://github.com/realm/realm-java/issues/6453))
 * [ObjectServer] Added the option of setting a time-to-live for subscriptions. Setting this will automatically delete the subscription after the provided TTL has expired and the subscription hasn't been used. (Issue [#6453](https://github.com/realm/realm-java/issues/6453))
 
-## Fixed
+### Fixed
 * Dates returned from the Realm file no longer overflow or underflow if they exceed `Long.MAX_VALUE` or `Long.MIN_VALUE` but instead clamp to their respective value. (Issue [#2722](https://github.com/realm/realm-java/issues/2722)) 
 
-## Compatibility
+### Compatibility
 * Realm Object Server: 3.11.0 or later.
 * File format: Generates Realms with format v9 (Reads and upgrades all previous formats).
 * APIs are backwards compatible with all previous release of realm-java in the 5.x.y series.
 
-## Internal
+### Internal
 * Updated to Object Store commit: e9819ed9c77ed87b5d7bed416a76cd5bcf255802
 
 
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index 4eba7a258d..5f8d53ab60 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -19,7 +19,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Locale;
@@ -400,7 +399,7 @@ private boolean checkCollectionTypes() {
     private boolean checkRealmListType(VariableElement field) {
         // Check for missing generic (default back to Object)
         if (Utils.getGenericTypeQualifiedName(field) == null) {
-            Utils.error("No generic type supplied for field", field);
+            Utils.error(getFieldErrorSuffix(field) + "No generic type supplied for field", field);
             return false;
         }
 
@@ -411,7 +410,7 @@ private boolean checkRealmListType(VariableElement field) {
             TypeElement elementTypeElement = (TypeElement) ((DeclaredType) elementTypeMirror).asElement();
             if (elementTypeElement.getSuperclass().getKind() == TypeKind.NONE) {
                 Utils.error(
-                        "Only concrete Realm classes are allowed in RealmLists. "
+                        getFieldErrorSuffix(field) + "Only concrete Realm classes are allowed in RealmLists. "
                                 + "Neither interfaces nor abstract classes are allowed.",
                         field);
                 return false;
@@ -419,9 +418,9 @@ private boolean checkRealmListType(VariableElement field) {
         }
 
         // Check if the actual value class is acceptable
-        if (!validListValueTypes.contains(elementTypeMirror) && !Utils.isRealmModel(elementTypeMirror)) {
+        if (!containsType(validListValueTypes, elementTypeMirror) && !Utils.isRealmModel(elementTypeMirror)) {
             final StringBuilder messageBuilder = new StringBuilder(
-                    "Element type of RealmList must be a class implementing 'RealmModel' or one of the ");
+                    getFieldErrorSuffix(field) + "Element type of RealmList must be a class implementing 'RealmModel' or one of ");
             final String separator = ", ";
             for (TypeMirror type : validListValueTypes) {
                 messageBuilder.append('\'').append(type.toString()).append('\'').append(separator);
@@ -440,7 +439,7 @@ private boolean checkRealmResultsType(VariableElement field) {
 
         // Check for missing generic (default back to Object)
         if (Utils.getGenericTypeQualifiedName(field) == null) {
-            Utils.error("No generic type supplied for field", field);
+            Utils.error(getFieldErrorSuffix(field) + "No generic type supplied for field", field);
             return false;
         }
 
@@ -459,13 +458,17 @@ private boolean checkRealmResultsType(VariableElement field) {
 
         // Check if the actual value class is acceptable
         if (!Utils.isRealmModel(elementTypeMirror)) {
-            Utils.error("Element type of RealmResults must be a class implementing 'RealmModel'.", field);
+            Utils.error(getFieldErrorSuffix(field) + "Element type of RealmResults must be a class implementing 'RealmModel'.", field);
             return false;
         }
 
         return true;
     }
 
+    private String getFieldErrorSuffix(VariableElement field) {
+        return javaClassName + "." + field.getSimpleName() + ": ";
+    }
+
     private boolean checkReferenceTypes() {
         for (VariableElement field : fields) {
             if (Utils.isRealmModel(field)) {
@@ -776,6 +779,16 @@ private boolean isValidPrimaryKeyType(TypeMirror type) {
         return false;
     }
 
+    private boolean containsType(List<TypeMirror> listOfTypes, TypeMirror type) {
+        for (int i = 0; i < listOfTypes.size(); i++) {
+            // Comparing TypeMirror's using `equals()` breaks when using incremental annotation processing.
+            if (typeUtils.isSameType(listOfTypes.get(i), type)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
     public Element getClassElement() {
         return classType;
     }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 9e3aca471e..8e6304e741 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -622,26 +622,30 @@ private String getStatementForAppendingValueToOsList(
             @SuppressWarnings("SameParameterValue") String osListVariableName,
             @SuppressWarnings("SameParameterValue") String valueVariableName,
             TypeMirror elementTypeMirror) {
-        if (elementTypeMirror == typeMirrors.STRING_MIRROR) {
+
+        Types typeUtils = processingEnvironment.getTypeUtils();
+        if (typeUtils.isSameType(elementTypeMirror, typeMirrors.STRING_MIRROR)) {
             return osListVariableName + ".addString(" + valueVariableName + ")";
         }
-        if (elementTypeMirror == typeMirrors.LONG_MIRROR || elementTypeMirror == typeMirrors.INTEGER_MIRROR
-                || elementTypeMirror == typeMirrors.SHORT_MIRROR || elementTypeMirror == typeMirrors.BYTE_MIRROR) {
+        if (typeUtils.isSameType(elementTypeMirror, typeMirrors.LONG_MIRROR)
+                || typeUtils.isSameType(elementTypeMirror, typeMirrors.INTEGER_MIRROR)
+                || typeUtils.isSameType(elementTypeMirror, typeMirrors.SHORT_MIRROR)
+                || typeUtils.isSameType(elementTypeMirror, typeMirrors.BYTE_MIRROR)) {
             return osListVariableName + ".addLong(" + valueVariableName + ".longValue())";
         }
-        if (elementTypeMirror.equals(typeMirrors.BINARY_MIRROR)) {
+        if (typeUtils.isSameType(elementTypeMirror, typeMirrors.BINARY_MIRROR)) {
             return osListVariableName + ".addBinary(" + valueVariableName + ")";
         }
-        if (elementTypeMirror == typeMirrors.DATE_MIRROR) {
+        if (typeUtils.isSameType(elementTypeMirror, typeMirrors.DATE_MIRROR)) {
             return osListVariableName + ".addDate(" + valueVariableName + ")";
         }
-        if (elementTypeMirror == typeMirrors.BOOLEAN_MIRROR) {
+        if (typeUtils.isSameType(elementTypeMirror, typeMirrors.BOOLEAN_MIRROR)) {
             return osListVariableName + ".addBoolean(" + valueVariableName + ")";
         }
-        if (elementTypeMirror == typeMirrors.DOUBLE_MIRROR) {
+        if (typeUtils.isSameType(elementTypeMirror, typeMirrors.DOUBLE_MIRROR)) {
             return osListVariableName + ".addDouble(" + valueVariableName + ".doubleValue())";
         }
-        if (elementTypeMirror == typeMirrors.FLOAT_MIRROR) {
+        if (typeUtils.isSameType(elementTypeMirror, typeMirrors.FLOAT_MIRROR)) {
             return osListVariableName + ".addFloat(" + valueVariableName + ".floatValue())";
         }
         throw new RuntimeException("unexpected element type: " + elementTypeMirror.toString());
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/TypeMirrors.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/TypeMirrors.java
index 8182828853..d6a0c84c69 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/TypeMirrors.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/TypeMirrors.java
@@ -30,6 +30,9 @@
 
 /**
  * This class provides {@link TypeMirror} instances used in annotation processor.
+ *
+ * WARNING: Comparing type mirrors using either `==` or `equal()` can break when using incremental
+ * annotation processing. Always use `Types.isSameType()` instead when comparing them.
  */
 class TypeMirrors {
     final TypeMirror STRING_MIRROR;
diff --git a/realm/realm-annotations-processor/src/main/resources/META-INF/gradle/incremental.annotation.processors b/realm/realm-annotations-processor/src/main/resources/META-INF/gradle/incremental.annotation.processors
new file mode 100644
index 0000000000..78b92db5bd
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/resources/META-INF/gradle/incremental.annotation.processors
@@ -0,0 +1 @@
+io.realm.processor.RealmProcessor,aggregating
\ No newline at end of file
