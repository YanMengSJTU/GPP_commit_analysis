diff --git a/LICENSE b/LICENSE
index 72ae44683f..48be149531 100644
--- a/LICENSE
+++ b/LICENSE
@@ -215,11 +215,11 @@ This software contains components with separate copyright and license terms.
 Your use of these components is subject to the terms and conditions of the
 following licenses.
 
-For the Realm Core (TightDB) component
+For the Realm Core component
 
-  Realm Core (TightDB) Binary License
+  Realm Core Binary License
 
-  Copyright (c) 2011-2014 Realm Inc All rights reserved
+  Copyright (c) 2011-2015 Realm Inc All rights reserved
 
   Redistribution and use in binary form, with or without modification, is
   permitted provided that the following conditions are met:
@@ -266,4 +266,4 @@ authorize the transfer of, directly or indirectly, the Software to any prohibite
 country, including Cuba, Iran, North Korea, Sudan, or Syria, or to any person or
 organization on or affiliated with the Department of Commerce lists of Denied
 Persons, Unverified Parties or Restricted Entities, or otherwise in violation of any
-such restrictions or regulations.
\ No newline at end of file
+such restrictions or regulations.
diff --git a/README.md b/README.md
index a54600baf1..9935aaeff7 100644
--- a/README.md
+++ b/README.md
@@ -21,11 +21,11 @@ The API reference is located at [realm.io/docs/java/api](http://realm.io/docs/ja
 
 ## Getting Help
 
-- Attend our monthly [**Online Office Hours**](http://j.mp/realm-office-hours) to ask questions or show us your app.
 - **Reproducible Bugs & Feature Requests** should be filed directly against our [Github Issues](https://github.com/realm/realm-java/issues).
 - **Discussions & Support**: [realm-java@googlegroups.com](https://groups.google.com/d/forum/realm-java).
 - **StackOverflow**: look for previous questions under the tag [#realm](https://stackoverflow.com/questions/tagged/realm?sort=newest) â€” or [open a new one](http://stackoverflow.com/questions/ask?tags=realm).
 - Sign up for our [**Community Newsletter**](http://eepurl.com/VEKCn) to get regular tips, learn about other use-cases and get alerted of blogposts and tutorials about Realm.
+- Attend our monthly [**Online Office Hours**](https://attendee.gotowebinar.com/rt/1182038037080364033) to ask questions directly to the team.
 
 ## Building Realm
 
diff --git a/changelog.txt b/changelog.txt
index c77564ac14..cc05a18b94 100644
--- a/changelog.txt
+++ b/changelog.txt
@@ -1,9 +1,21 @@
+0.81
+ * Realm.copyToRealm() now correctly handles referenced child objects that are already in the Realm.
+ * The ARM64 binary is now properly a part of the Eclipse distribution package.
+ * A RealmMigrationExceptionNeeded is now properly thrown if @Index and @PrimaryKey are not set correctly during a migration.
+ * Fixed bug causing Realms to be cached even though they failed to open correctly.
+ * Added Realm.deleteRealmFile(File) method.
+ * Fixed bug causing queries to fail if multiple Realms has different field ordering.
+ * Fixed bug when using Realm.copyToRealm() with a primary key could crash if default value was already used in the Realm.
+
 0.80
 * Queries on relationships can be case sensitive.
 * Fixed bug when importing JSONObjects containing NULL values.
-* Fixed crash when trying to remove last element of a RealmList.s
+* Fixed crash when trying to remove last element of a RealmList.
 * Fixed bug crashing annotation processor when using "name" in model classes for RealmObject references
 * Fixed problem occurring when opening an encrypted Realm with two different instances of the same key.
+* Version checker no longer reports that updates are available when latest version is used.
+* Added support for static fields in RealmObjects.
+* Realm.writeEncryptedCopyTo() has been reenabled.
 
 0.79.1
  * copyToRealm() no longer crashes on cyclic data structures.
diff --git a/realm-annotations-processor/build.gradle b/realm-annotations-processor/build.gradle
index 855ddab9a2..1fa45c1104 100644
--- a/realm-annotations-processor/build.gradle
+++ b/realm-annotations-processor/build.gradle
@@ -1,4 +1,14 @@
+buildscript {
+    repositories {
+        jcenter()
+    }
+    dependencies {
+        classpath 'com.github.jengelman.gradle.plugins:shadow:1.2.1'
+    }
+}
+
 apply plugin: 'java'
+apply plugin: 'com.github.johnrengelman.shadow'
 
 version = new File("${projectDir}/../version.txt").text
 sourceCompatibility = '1.6'
@@ -28,6 +38,12 @@ jar {
     from configurations.compile.findAll {it.name.contains('javawriter')}.collect { zipTree(it) }
 }
 
+shadowJar {
+    relocate 'com.squareup.javawriter', 'io.realm.processor.javawriter'
+    exclude 'io/realm/annotations/**'
+    classifier = ''
+}
+
 //for Ant filter
 import org.apache.tools.ant.filters.ReplaceTokens
 
@@ -35,6 +51,7 @@ task generateVersionClass(type: Copy) {
     from 'src/main/templates/Version.java'
     into 'build/generated-src/main/java/io/realm/processor'
     filter(ReplaceTokens, tokens: [version: version])
+    outputs.upToDateWhen { false }
 }
 
 compileJava.dependsOn generateVersionClass
@@ -57,10 +74,10 @@ task assembleRealm(type: GradleBuild) {
     tasks = ['assemble']
 }
 
-tasks.assemble {
+tasks.compileJava {
     dependsOn compileAnnotations
 }
 
 tasks.check {
     dependsOn assembleRealm
-}
\ No newline at end of file
+}
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
new file mode 100644
index 0000000000..545013b592
--- /dev/null
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -0,0 +1,398 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Types;
+
+import io.realm.annotations.Ignore;
+import io.realm.annotations.Index;
+import io.realm.annotations.PrimaryKey;
+
+/**
+ * Utility class for holding metadata for RealmProxy classes.
+ */
+public class ClassMetaData {
+
+    private final TypeElement classType; // Reference to model class.
+    private String className; // Model class simple name.
+    private String packageName; // package name for model class.
+    private boolean hasDefaultConstructor; // True if model has a public no-arg constructor.
+    private VariableElement primaryKey; // Reference to field used as primary key, if any.
+    private List<VariableElement> fields = new ArrayList<VariableElement>(); // List of all fields in the class except those @Ignored.
+    private List<String> fieldNames = new ArrayList<String>();
+    private List<String> ignoreFieldNames = new ArrayList<String>();
+    private List<VariableElement> indexedFields = new ArrayList<VariableElement>(); // list of all fields marked @Index.
+    private Set<String> expectedGetters = new HashSet<String>(); // Set of fieldnames that are expected to have a getter
+    private Set<String> expectedSetters = new HashSet<String>(); // Set of fieldnames that are expected to have a setter
+    private Set<ExecutableElement> methods = new HashSet<ExecutableElement>(); // List of all methods in the model class
+    private Map<String, String> getters = new HashMap<String, String>(); // Map between fieldnames and their getters
+    private Map<String, String> setters = new HashMap<String, String>(); // Map between fieldname and their setters
+
+    private final List<TypeMirror> validPrimaryKeyTypes;
+    private final Types typeUtils;
+
+    public ClassMetaData(ProcessingEnvironment env, TypeElement clazz) {
+        this.classType = clazz;
+        this.className = clazz.getSimpleName().toString();
+        typeUtils = env.getTypeUtils();
+        TypeMirror stringType = env.getElementUtils().getTypeElement("java.lang.String").asType();
+        validPrimaryKeyTypes = Arrays.asList(
+                stringType,
+                typeUtils.getPrimitiveType(TypeKind.SHORT),
+                typeUtils.getPrimitiveType(TypeKind.INT),
+                typeUtils.getPrimitiveType(TypeKind.LONG)
+        );
+    }
+
+    /**
+     * Build the meta data structures for this class. Any errors or messages will be
+     * posted on the provided Messager.
+     *
+     * @return True if meta data was correctly created and processing can continue, false otherwise.
+     */
+    public boolean generateMetaData(Messager messager) {
+
+        // Get the package of the class
+        Element enclosingElement = classType.getEnclosingElement();
+        if (!enclosingElement.getKind().equals(ElementKind.PACKAGE)) {
+            Utils.error("The RealmClass annotation does not support nested classes", classType);
+            return false;
+        }
+
+        TypeElement parentElement = (TypeElement) Utils.getSuperClass(classType);
+        if (!parentElement.toString().endsWith(".RealmObject")) {
+            Utils.error("A RealmClass annotated object must be derived from RealmObject", classType);
+            return false;
+        }
+
+        PackageElement packageElement = (PackageElement) enclosingElement;
+        packageName = packageElement.getQualifiedName().toString();
+
+        if (!categorizeClassElements()) return false;
+        if (!checkMethods()) return false;
+        if (!checkDefaultConstructor()) return false;
+        if (!checkRequiredGetters()) return false;
+        if (!checkRequireSetters()) return false;
+
+        return true; // Meta data was successfully generated
+    }
+
+    // Check that only allowed methods are present in the model class
+    private boolean checkMethods() {
+        for (ExecutableElement executableElement : methods) {
+            String methodName = executableElement.getSimpleName().toString();
+
+            // Check the modifiers of the method
+            Set<Modifier> modifiers = executableElement.getModifiers();
+            if (modifiers.contains(Modifier.STATIC)) {
+                continue; // We're cool with static methods. Move along!
+            } else if (!modifiers.contains(Modifier.PUBLIC)) {
+                Utils.error("The methods of the model must be public", executableElement);
+                return false;
+            }
+
+            // Check that getters and setters are valid
+            if (methodName.startsWith("get") || methodName.startsWith("is")) {
+                if (!checkGetterMethod(methodName)) {
+                    Utils.error(String.format("Getter %s is not associated to any field", methodName), executableElement);
+                    return false;
+                }
+            } else if (methodName.startsWith("set")) {
+                if (!checkSetterMethod(methodName)) {
+                    Utils.error(String.format("Setter %s is not associated to any field", methodName), executableElement);
+                    return false;
+                }
+            } else {
+                Utils.error("Only getters and setters should be defined in model classes", executableElement);
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    // Verify that a setter is used to set a field in the model class.
+    // Note: This is done heuristically by comparing the name of setter with the name of the field.
+    // Annotation processors does not allow us to inspect individual statements.
+    private boolean checkSetterMethod(String methodName) {
+        boolean found = false;
+
+        String methodMinusSet = methodName.substring(3);
+        String methodMinusSetCapitalised = Utils.lowerFirstChar(methodMinusSet);
+        String methodMenusSetPlusIs = "is" + methodMinusSet;
+
+        if (fieldNames.contains(methodMinusSet)) { // mPerson -> setmPerson
+            expectedSetters.remove(methodMinusSet);
+            if (!ignoreFieldNames.contains(methodMinusSet)) {
+                setters.put(methodMinusSet, methodName);
+            }
+            found = true;
+        } else if (fieldNames.contains(methodMinusSetCapitalised)) { // person -> setPerson
+            expectedSetters.remove(methodMinusSetCapitalised);
+            if (!ignoreFieldNames.contains(methodMinusSetCapitalised)) {
+                setters.put(methodMinusSetCapitalised, methodName);
+            }
+            found = true;
+        } else if (fieldNames.contains(methodMenusSetPlusIs)) { // isReady -> setReady
+            expectedSetters.remove(methodMenusSetPlusIs);
+            if (!ignoreFieldNames.contains(methodMenusSetPlusIs)) {
+                setters.put(methodMenusSetPlusIs, methodName);
+            }
+            found = true;
+        }
+
+        return found;
+    }
+
+    // Verify that a getter is used to get a field in the model class.
+    // Note: This is done heuristically by comparing the name of getter with the name of the field.
+    // Annotation processors does not allow us to inspect individual statements.
+    private boolean checkGetterMethod(String methodName) {
+        boolean found = false;
+
+        if (methodName.startsWith("is")) {
+            String methodMinusIs = methodName.substring(2);
+            String methodMinusIsCapitalised = Utils.lowerFirstChar(methodMinusIs);
+            if (fieldNames.contains(methodName)) { // isDone -> isDone
+                expectedGetters.remove(methodName);
+                if (!ignoreFieldNames.contains(methodName)) {
+                    getters.put(methodName, methodName);
+                }
+                found = true;
+            } else if (fieldNames.contains(methodMinusIs)) {  // mDone -> ismDone
+                expectedGetters.remove(methodMinusIs);
+                if (!ignoreFieldNames.contains(methodMinusIs)) {
+                    getters.put(methodMinusIs, methodName);
+                }
+                found = true;
+            } else if (fieldNames.contains(methodMinusIsCapitalised)) { // done -> isDone
+                expectedGetters.remove(methodMinusIsCapitalised);
+                if (!ignoreFieldNames.contains(methodMinusIsCapitalised)) {
+                    getters.put(methodMinusIsCapitalised, methodName);
+                }
+                found = true;
+            }
+        }
+
+        if (!found && methodName.startsWith("get")) {
+            String methodMinusGet = methodName.substring(3);
+            String methodMinusGetCapitalised = Utils.lowerFirstChar(methodMinusGet);
+            if (fieldNames.contains(methodMinusGet)) { // mPerson -> getmPerson
+                expectedGetters.remove(methodMinusGet);
+                if (!ignoreFieldNames.contains(methodMinusGet)) {
+                    getters.put(methodMinusGet, methodName);
+                }
+                found = true;
+            } else if (fieldNames.contains(methodMinusGetCapitalised)) { // person -> getPerson
+                expectedGetters.remove(methodMinusGetCapitalised);
+                if (!ignoreFieldNames.contains(methodMinusGetCapitalised)) {
+                    getters.put(methodMinusGetCapitalised, methodName);
+                }
+                found = true;
+            }
+        }
+
+        return found;
+    }
+
+    // Report any setters that are missing
+    private boolean checkRequireSetters() {
+        for (String expectedSetter : expectedSetters) {
+            Utils.error("No setter found for field " + expectedSetter);
+        }
+        return expectedSetters.size() == 0;
+    }
+
+    // Report any getters that are missing
+    private boolean checkRequiredGetters() {
+        for (String expectedGetter : expectedGetters) {
+            Utils.error("No getter found for field " + expectedGetter);
+        }
+        return expectedGetters.size() == 0;
+    }
+
+    // Report if the default constructor is missing
+    private boolean checkDefaultConstructor() {
+        if (!hasDefaultConstructor) {
+            Utils.error("A default public constructor with no argument must be declared if a custom constructor is declared.");
+            return false;
+        } else {
+            return true;
+        }
+    }
+
+    // Iterate through all class elements and add them to the appropriate internal data structures.
+    // Returns true if all elements could be false if elements could not be categorized,
+    private boolean categorizeClassElements() {
+        for (Element element : classType.getEnclosedElements()) {
+            ElementKind elementKind = element.getKind();
+
+            if (elementKind.equals(ElementKind.FIELD)) {
+                VariableElement variableElement = (VariableElement) element;
+                String fieldName = variableElement.getSimpleName().toString();
+
+                Set<Modifier> modifiers = variableElement.getModifiers();
+                if (modifiers.contains(Modifier.STATIC)) {
+                    continue; // completely ignore any static fields
+                }
+
+                if (variableElement.getAnnotation(Ignore.class) != null) {
+                    // The field has the @Ignore annotation. No need to go any further.
+                    String ignoredFieldName = variableElement.getSimpleName().toString();
+                    fieldNames.add(ignoredFieldName);
+                    ignoreFieldNames.add(ignoredFieldName);
+                    continue;
+                }
+
+                if (variableElement.getAnnotation(Index.class) != null) {
+                    // The field has the @Index annotation. It's only valid for:
+                    // * String
+                    String elementTypeCanonicalName = variableElement.asType().toString();
+                    if (elementTypeCanonicalName.equals("java.lang.String")) {
+                        indexedFields.add(variableElement);
+                    } else {
+                        Utils.error("@Index is only applicable to String fields - got " + element);
+                        return false;
+                    }
+                }
+
+                if (variableElement.getAnnotation(PrimaryKey.class) != null) {
+                    // The field has the @PrimaryKey annotation. It is only valid for
+                    // String, short, int, long and must only be present one time
+                    if (primaryKey != null) {
+                        Utils.error(String.format("@PrimaryKey cannot be defined more than once. It was found here \"%s\" and here \"%s\"",
+                                primaryKey.getSimpleName().toString(),
+                                variableElement.getSimpleName().toString()));
+                        return false;
+                    }
+
+                    TypeMirror fieldType = variableElement.asType();
+                    if (!isValidPrimaryKeyType(fieldType)) {
+                        Utils.error("\"" + variableElement.getSimpleName().toString() + "\" is not allowed as primary key. See @PrimaryKey for allowed types.");
+                        return false;
+                    }
+
+                    primaryKey = variableElement;
+
+                    // Also add as index if the primary key is a string
+                    if (Utils.isString(variableElement) && !indexedFields.contains(variableElement)) {
+                        indexedFields.add(variableElement);
+                    }
+                }
+
+                if (!variableElement.getModifiers().contains(Modifier.PRIVATE)) {
+                    Utils.error("The fields of the model must be private", variableElement);
+                    return false;
+                }
+
+                fields.add(variableElement);
+                expectedGetters.add(fieldName);
+                expectedSetters.add(fieldName);
+            } else if (elementKind.equals(ElementKind.CONSTRUCTOR)) {
+                hasDefaultConstructor =  hasDefaultConstructor || Utils.isDefaultConstructor(element);
+
+            } else if (elementKind.equals(ElementKind.METHOD)) {
+                ExecutableElement executableElement = (ExecutableElement) element;
+                methods.add(executableElement);
+            }
+        }
+
+        for (VariableElement field : fields) {
+            fieldNames.add(field.getSimpleName().toString());
+        }
+
+        if (fields.size() == 0) {
+            Utils.error(className + " must contain at least 1 persistable field");
+        }
+
+        return true;
+    }
+
+    public String getSimpleClassName() {
+        return className;
+    }
+
+    /**
+     * Returns true if the model class is considered to be a true model class.
+     * RealmObject and Proxy classes also has the the @RealmClass annotation but is not considered true
+     * model classes.
+     */
+    public boolean isModelClass() {
+        return (!classType.toString().endsWith(".RealmObject") && !classType.toString().endsWith("RealmProxy"));
+    }
+
+    public String getFullyQualifiedClassName() {
+        return packageName + "." + className;
+    }
+
+    public List<VariableElement> getFields() {
+        return fields;
+    }
+
+    public String getGetter(String fieldName) {
+        return getters.get(fieldName);
+    }
+
+    public String getSetter(String fieldName) {
+        return setters.get(fieldName);
+    }
+
+    public List<VariableElement> getIndexedFields() {
+        return indexedFields;
+    }
+
+    public boolean hasPrimaryKey() {
+        return primaryKey != null;
+    }
+
+    public VariableElement getPrimaryKey() {
+        return primaryKey;
+    }
+
+    public String getPrimaryKeyGetter() {
+        return getters.get(primaryKey.getSimpleName().toString());
+    }
+
+    private boolean isValidPrimaryKeyType(TypeMirror type) {
+        for (TypeMirror validType : validPrimaryKeyTypes) {
+            if (typeUtils.isAssignable(type, validType)) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
+
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java b/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
new file mode 100644
index 0000000000..ae37a0e4f3
--- /dev/null
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor;
+
+public class Constants {
+    public static final String REALM_PACKAGE_NAME = "io.realm";
+    public static final String PROXY_SUFFIX = "RealmProxy";
+    public static final String TABLE_PREFIX = "class_";
+}
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmJSonImplGenerator.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmJSonImplGenerator.java
index 0e0a47fec5..74b6f452cd 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmJSonImplGenerator.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmJSonImplGenerator.java
@@ -30,13 +30,12 @@
     private static final String CLASS_NAME = "RealmJsonImpl";
     private static final String EXCEPTION_MSG = "\"Could not find the generated proxy class for \" + classQualifiedName";
 
-    public RealmJSonImplGenerator(ProcessingEnvironment processingEnv, Set<String> classesToValidate) {
+    public RealmJSonImplGenerator(ProcessingEnvironment processingEnv, Set<ClassMetaData> classesToValidate) {
         this.processingEnvironment = processingEnv;
-        for (String clazz : classesToValidate) {
-            String simpleName = Utils.stripPackage(clazz);
-            qualifiedModelClasses.add(clazz);
-            simpleModelClasses.add(simpleName);
-            proxyClasses.add(Utils.getProxyClassName(simpleName));
+        for (ClassMetaData metadata: classesToValidate) {
+            qualifiedModelClasses.add(metadata.getFullyQualifiedClassName());
+            simpleModelClasses.add(metadata.getSimpleClassName());
+            proxyClasses.add(Utils.getProxyClassName(metadata.getSimpleClassName()));
         }
     }
 
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
index ec51e6c479..1221d83168 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
@@ -16,24 +16,19 @@
 
 package io.realm.processor;
 
-
-import io.realm.annotations.Ignore;
-import io.realm.annotations.Index;
-import io.realm.annotations.PrimaryKey;
-import io.realm.annotations.RealmClass;
+import java.io.IOException;
+import java.util.HashSet;
+import java.util.Set;
 
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
 import javax.lang.model.SourceVersion;
-import javax.lang.model.element.*;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
-import javax.tools.Diagnostic;
-import java.io.IOException;
-import java.util.*;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.TypeElement;
 
+import io.realm.annotations.RealmClass;
 
 @SupportedAnnotationTypes({
         "io.realm.annotations.RealmClass",
@@ -42,7 +37,7 @@
         "io.realm.annotations.PrimaryKey"
 })
 public class RealmProcessor extends AbstractProcessor {
-    Set<String> classesToValidate = new HashSet<String>();
+    Set<ClassMetaData> classesToValidate = new HashSet<ClassMetaData>();
     boolean done = false;
 
     @Override public SourceVersion getSupportedSourceVersion() {
@@ -55,249 +50,31 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
         updateChecker.executeRealmVersionUpdate();
         Utils.initialize(processingEnv);
 
-        Types typeUtils = processingEnv.getTypeUtils();
-        TypeMirror stringType = processingEnv.getElementUtils().getTypeElement("java.lang.String").asType();
-        List<TypeMirror> validPrimaryKeyTypes = Arrays.asList(
-                stringType,
-                typeUtils.getPrimitiveType(TypeKind.SHORT),
-                typeUtils.getPrimitiveType(TypeKind.INT),
-                typeUtils.getPrimitiveType(TypeKind.LONG)
-        );
-
         for (Element classElement : roundEnv.getElementsAnnotatedWith(RealmClass.class)) {
-            String className;
-            String packageName;
-            boolean hasDefaultConstructor = false;
-            List<VariableElement> fields = new ArrayList<VariableElement>();
-            List<VariableElement> indexedFields = new ArrayList<VariableElement>();
-            Set<VariableElement> ignoredFields = new HashSet<VariableElement>();
-            Set<String> expectedGetters = new HashSet<String>();
-            Set<String> expectedSetters = new HashSet<String>();
-            Set<ExecutableElement> methods = new HashSet<ExecutableElement>();
-            Map<String, String> getters = new HashMap<String, String>();
-            Map<String, String> setters = new HashMap<String, String>();
 
             // Check the annotation was applied to a Class
             if (!classElement.getKind().equals(ElementKind.CLASS)) {
-                error("The RealmClass annotation can only be applied to classes", classElement);
+                Utils.error("The RealmClass annotation can only be applied to classes", classElement);
             }
-            TypeElement typeElement = (TypeElement) classElement;
-            className = typeElement.getSimpleName().toString();
-
-            if (typeElement.toString().endsWith(".RealmObject") || typeElement.toString().endsWith("RealmProxy")) {
+            ClassMetaData metadata = new ClassMetaData(processingEnv, (TypeElement) classElement);
+            if (!metadata.isModelClass()) {
                 continue;
             }
-
-            note("Processing class " + className);
-
-            classesToValidate.add(typeElement.toString());
-
-            // Get the package of the class
-            Element enclosingElement = typeElement.getEnclosingElement();
-            if (!enclosingElement.getKind().equals(ElementKind.PACKAGE)) {
-                error("The RealmClass annotation does not support nested classes", classElement);
-            }
-
-            TypeElement parentElement = (TypeElement) processingEnv.getTypeUtils().asElement(typeElement.getSuperclass());
-            if (!parentElement.toString().endsWith(".RealmObject")) {
-                error("A RealmClass annotated object must be derived from RealmObject", classElement);
-            }
-
-            PackageElement packageElement = (PackageElement) enclosingElement;
-            packageName = packageElement.getQualifiedName().toString();
-            VariableElement primaryKey = null;
-
-            for (Element element : typeElement.getEnclosedElements()) {
-                ElementKind elementKind = element.getKind();
-
-                if (elementKind.equals(ElementKind.FIELD)) {
-                    VariableElement variableElement = (VariableElement) element;
-                    String fieldName = variableElement.getSimpleName().toString();
-                    if (variableElement.getAnnotation(Ignore.class) != null) {
-                        // The field has the @Ignore annotation. No need to go any further.
-                        ignoredFields.add(variableElement);
-                        continue;
-                    }
-
-                    if (variableElement.getAnnotation(Index.class) != null) {
-                        // The field has the @Index annotation. It's only valid for:
-                        // * String
-                        String elementTypeCanonicalName = variableElement.asType().toString();
-                        if (elementTypeCanonicalName.equals("java.lang.String")) {
-                            indexedFields.add(variableElement);
-                        } else {
-                            error("@Index is only applicable to String fields - got " + element);
-                            return true;
-                        }
-                    }
-
-                    if (variableElement.getAnnotation(PrimaryKey.class) != null) {
-                        // The field has the @PrimaryKey annotation. It is only valid for
-                        // String, short, int, long and must only be present one time
-                        if (primaryKey != null) {
-                            error(String.format("@PrimaryKey cannot be defined more than once. It was found here \"%s\" and here \"%s\"",
-                                    primaryKey.getSimpleName().toString(),
-                                    variableElement.getSimpleName().toString()));
-                            return true;
-                        }
-
-                        TypeMirror fieldType = variableElement.asType();
-                        if (!Utils.isValidType(typeUtils, fieldType, validPrimaryKeyTypes)) {
-                            error("\"" + variableElement.getSimpleName().toString() + "\" is not allowed as primary key. See @PrimaryKey for allowed types.");
-                            return true;
-                        }
-
-                        primaryKey = variableElement;
-
-                        // Also add as index if the primary key is a string
-                        if (Utils.isString(variableElement) && !indexedFields.contains(variableElement)) {
-                            indexedFields.add(variableElement);
-                        }
-                    }
-
-                    if (!variableElement.getModifiers().contains(Modifier.PRIVATE)) {
-                        error("The fields of the model must be private", variableElement);
-                    }
-
-                    fields.add(variableElement);
-                    expectedGetters.add(fieldName);
-                    expectedSetters.add(fieldName);
-                } else if (elementKind.equals(ElementKind.CONSTRUCTOR)) {
-                    hasDefaultConstructor = hasDefaultConstructor || Utils.isDefaultConstructor(element);
-
-                } else if (elementKind.equals(ElementKind.METHOD)) {
-                    ExecutableElement executableElement = (ExecutableElement) element;
-                    methods.add(executableElement);
-                }
-            }
-
-            List<String> fieldNames = new ArrayList<String>();
-            List<String> ignoreFieldNames = new ArrayList<String>();
-            for (VariableElement field : fields) {
-                fieldNames.add(field.getSimpleName().toString());
-            }
-            for (VariableElement ignoredField : ignoredFields) {
-                fieldNames.add(ignoredField.getSimpleName().toString());
-                ignoreFieldNames.add(ignoredField.getSimpleName().toString());
-            }
-
-            for (ExecutableElement executableElement : methods) {
-
-                String methodName = executableElement.getSimpleName().toString();
-
-                // Check the modifiers of the method
-                Set<Modifier> modifiers = executableElement.getModifiers();
-                if (modifiers.contains(Modifier.STATIC)) {
-                    continue; // We're cool with static methods. Move along!
-                } else if (!modifiers.contains(Modifier.PUBLIC)) {
-                    error("The methods of the model must be public", executableElement);
-                }
-
-                if (methodName.startsWith("get") || methodName.startsWith("is")) {
-                    boolean found = false;
-
-                    if (methodName.startsWith("is")) {
-                        String methodMinusIs = methodName.substring(2);
-                        String methodMinusIsCapitalised = Utils.lowerFirstChar(methodMinusIs);
-                        if (fieldNames.contains(methodName)) { // isDone -> isDone
-                            expectedGetters.remove(methodName);
-                            if (!ignoreFieldNames.contains(methodName)) {
-                                getters.put(methodName, methodName);
-                            }
-                            found = true;
-                        } else if (fieldNames.contains(methodMinusIs)) {  // mDone -> ismDone
-                            expectedGetters.remove(methodMinusIs);
-                            if (!ignoreFieldNames.contains(methodMinusIs)) {
-                                getters.put(methodMinusIs, methodName);
-                            }
-                            found = true;
-                        } else if (fieldNames.contains(methodMinusIsCapitalised)) { // done -> isDone
-                            expectedGetters.remove(methodMinusIsCapitalised);
-                            if (!ignoreFieldNames.contains(methodMinusIsCapitalised)) {
-                                getters.put(methodMinusIsCapitalised, methodName);
-                            }
-                            found = true;
-                        }
-                    }
-
-                    if (!found && methodName.startsWith("get")) {
-                        String methodMinusGet = methodName.substring(3);
-                        String methodMinusGetCapitalised = Utils.lowerFirstChar(methodMinusGet);
-                        if (fieldNames.contains(methodMinusGet)) { // mPerson -> getmPerson
-                            expectedGetters.remove(methodMinusGet);
-                            if (!ignoreFieldNames.contains(methodMinusGet)) {
-                                getters.put(methodMinusGet, methodName);
-                            }
-                            found = true;
-                        } else if (fieldNames.contains(methodMinusGetCapitalised)) { // person -> getPerson
-                            expectedGetters.remove(methodMinusGetCapitalised);
-                            if (!ignoreFieldNames.contains(methodMinusGetCapitalised)) {
-                                getters.put(methodMinusGetCapitalised, methodName);
-                            }
-                            found = true;
-                        }
-                    }
-
-                    if (!found) {
-                        note(String.format("Getter %s is not associated to any field", methodName));
-                    }
-                } else if (methodName.startsWith("set")) {
-                    boolean found = false;
-
-                    String methodMinusSet = methodName.substring(3);
-                    String methodMinusSetCapitalised = Utils.lowerFirstChar(methodMinusSet);
-                    String methodMenusSetPlusIs = "is" + methodMinusSet;
-
-                    if (fieldNames.contains(methodMinusSet)) { // mPerson -> setmPerson
-                        expectedSetters.remove(methodMinusSet);
-                        if (!ignoreFieldNames.contains(methodMinusSet)) {
-                            setters.put(methodMinusSet, methodName);
-                        }
-                        found = true;
-                    } else if (fieldNames.contains(methodMinusSetCapitalised)) { // person -> setPerson
-                        expectedSetters.remove(methodMinusSetCapitalised);
-                        if (!ignoreFieldNames.contains(methodMinusSetCapitalised)) {
-                            setters.put(methodMinusSetCapitalised, methodName);
-                        }
-                        found = true;
-                    } else if (fieldNames.contains(methodMenusSetPlusIs)) { // isReady -> setReady
-                        expectedSetters.remove(methodMenusSetPlusIs);
-                        if (!ignoreFieldNames.contains(methodMenusSetPlusIs)) {
-                            setters.put(methodMenusSetPlusIs, methodName);
-                        }
-                        found = true;
-                    }
-
-                    if (!found) {
-                        note(String.format("Setter %s is not associated to any field", methodName));
-                    }
-                } else {
-                    error("Only getters and setters should be defined in model classes", executableElement);
-                }
-            }
-
-            if (!hasDefaultConstructor) {
-                error("A default public constructor with no argument must be declared if a custom constructor is declared.");
-            }
-
-            for (String expectedGetter : expectedGetters) {
-                error("No getter found for field " + expectedGetter);
-                getters.put(expectedGetter, "");
-            }
-
-            for (String expectedSetter : expectedSetters) {
-                error("No setter found for field " + expectedSetter);
-                setters.put(expectedSetter, "");
+            Utils.note("Processing class " + metadata.getSimpleClassName());
+            boolean success = metadata.generateMetaData(processingEnv.getMessager());
+            if (!success) {
+                done = true;
+                return true; // Abort processing by claiming all annotations
             }
+            classesToValidate.add(metadata);
 
-            RealmProxyClassGenerator sourceCodeGenerator =
-                    new RealmProxyClassGenerator(processingEnv, className, packageName, fields, getters, setters, indexedFields, primaryKey);
+            RealmProxyClassGenerator sourceCodeGenerator = new RealmProxyClassGenerator(processingEnv, metadata);
             try {
                 sourceCodeGenerator.generate();
             } catch (IOException e) {
-                error(e.getMessage(), classElement);
+                Utils.error(e.getMessage(), classElement);
             } catch (UnsupportedOperationException e) {
-                error(e.getMessage(), classElement);
+                Utils.error(e.getMessage(), classElement);
             }
         }
 
@@ -309,22 +86,10 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
                 jsonGenerator.generate();
                 done = true;
             } catch (IOException e) {
-                error(e.getMessage());
+                Utils.error(e.getMessage());
             }
         }
 
         return true;
     }
-
-    private void error(String message, Element element) {
-        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message, element);
-    }
-
-    private void error(String message) {
-        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message);
-    }
-
-    private void note(String message) {
-        processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, message);
-    }
 }
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index c7dfb7553e..dcdef8da83 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -32,16 +32,8 @@
 
 public class RealmProxyClassGenerator {
     private ProcessingEnvironment processingEnvironment;
-    private String className;
-    private String packageName;
-    private List<VariableElement> fields = new ArrayList<VariableElement>();
-    private Map<String, String> getters = new HashMap<String, String>();
-    private Map<String, String> setters = new HashMap<String, String>();
-    private List<VariableElement> fieldsToIndex;
-    private VariableElement primaryKey;
-    private static final String REALM_PACKAGE_NAME = "io.realm";
-    private static final String TABLE_PREFIX = "class_";
-    public static final String PROXY_SUFFIX = "RealmProxy";
+    private ClassMetaData metadata;
+    private final String className;
 
     // Class metadata for generating proxy classes
     private Elements elementUtils;
@@ -49,24 +41,13 @@
     private TypeMirror realmObject;
     private DeclaredType realmList;
 
-    public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment,
-                                    String className, String packageName,
-                                    List<VariableElement> fields,
-                                    Map<String, String> getters, Map<String, String> setters,
-                                    List<VariableElement> fieldsToIndex,
-                                    VariableElement primaryKey) {
+    public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment, ClassMetaData metadata) {
         this.processingEnvironment = processingEnvironment;
-        this.className = className;
-        this.packageName = packageName;
-        this.fields = fields;
-        this.getters = getters;
-        this.setters = setters;
-        this.fieldsToIndex = fieldsToIndex;
-        this.primaryKey = primaryKey;
+        this.metadata = metadata;
+        this.className = metadata.getSimpleClassName();
     }
 
     private static final Map<String, String> JAVA_TO_REALM_TYPES;
-
     static {
         JAVA_TO_REALM_TYPES = new HashMap<String, String>();
         JAVA_TO_REALM_TYPES.put("byte", "Long");
@@ -91,7 +72,6 @@ public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment,
 
     // Types in this array are guarded by if != null and use default value if trying to insert null
     private static final Map<String, String> NULLABLE_JAVA_TYPES;
-
     static {
         NULLABLE_JAVA_TYPES = new HashMap<String, String>();
         NULLABLE_JAVA_TYPES.put("java.util.Date", "new Date(0)");
@@ -100,7 +80,6 @@ public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment,
     }
 
     private static final Map<String, String> JAVA_TO_COLUMN_TYPES;
-
     static {
         JAVA_TO_COLUMN_TYPES = new HashMap<String, String>();
         JAVA_TO_COLUMN_TYPES.put("byte", "ColumnType.INTEGER");
@@ -123,7 +102,6 @@ public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment,
     }
 
     private static final Map<String, String> CASTING_TYPES;
-
     static {
         CASTING_TYPES = new HashMap<String, String>();
         CASTING_TYPES.put("byte", "long");
@@ -151,14 +129,14 @@ public void generate() throws IOException, UnsupportedOperationException {
         realmObject = elementUtils.getTypeElement("io.realm.RealmObject").asType();
         realmList = typeUtils.getDeclaredType(elementUtils.getTypeElement("io.realm.RealmList"), typeUtils.getWildcardType(null, null));
 
-        String qualifiedGeneratedClassName = String.format("%s.%s", REALM_PACKAGE_NAME, Utils.getProxyClassName(className));
+        String qualifiedGeneratedClassName = String.format("%s.%s", Constants.REALM_PACKAGE_NAME, Utils.getProxyClassName(className));
         JavaFileObject sourceFile = processingEnvironment.getFiler().createSourceFile(qualifiedGeneratedClassName);
         JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));
 
         // Set source code indent to 4 spaces
         writer.setIndent("    ");
 
-        writer.emitPackage(REALM_PACKAGE_NAME)
+        writer.emitPackage(Constants.REALM_PACKAGE_NAME)
                 .emitEmptyLine();
 
         ArrayList<String> imports = new ArrayList<String>();
@@ -166,6 +144,7 @@ public void generate() throws IOException, UnsupportedOperationException {
         imports.add("android.util.JsonToken");
         imports.add("io.realm.RealmObject");
         imports.add("io.realm.exceptions.RealmException");
+        imports.add("io.realm.exceptions.RealmMigrationNeededException");
         imports.add("io.realm.internal.ColumnType");
         imports.add("io.realm.internal.Table");
         imports.add("io.realm.internal.TableOrView");
@@ -173,6 +152,8 @@ public void generate() throws IOException, UnsupportedOperationException {
         imports.add("io.realm.internal.LinkView");
         imports.add("io.realm.internal.android.JsonUtils");
         imports.add("java.io.IOException");
+        imports.add("java.util.ArrayList");
+        imports.add("java.util.Collections");
         imports.add("java.util.List");
         imports.add("java.util.Arrays");
         imports.add("java.util.Date");
@@ -181,16 +162,16 @@ public void generate() throws IOException, UnsupportedOperationException {
         imports.add("org.json.JSONObject");
         imports.add("org.json.JSONException");
         imports.add("org.json.JSONArray");
-        imports.add(String.format("%s.%s", packageName, className));
+        imports.add(metadata.getFullyQualifiedClassName());
 
-        for (VariableElement field : fields) {
+        for (VariableElement field : metadata.getFields()) {
             String fieldTypeName = "";
             if (typeUtils.isAssignable(field.asType(), realmObject)) { // Links
                 fieldTypeName = field.asType().toString();
             } else if (typeUtils.isAssignable(field.asType(), realmList)) { // LinkLists
                 fieldTypeName = ((DeclaredType) field.asType()).getTypeArguments().get(0).toString();
             }
-            if (fieldTypeName != "" && !imports.contains(fieldTypeName)) {
+            if (!fieldTypeName.isEmpty() && !imports.contains(fieldTypeName)) {
                 imports.add(fieldTypeName);
             }
         }
@@ -206,10 +187,12 @@ public void generate() throws IOException, UnsupportedOperationException {
                 className)                   // class to extend
                 .emitEmptyLine();
 
+        emitClassFields(writer);
         emitAccessors(writer);
         emitInitTableMethod(writer);
         emitValidateTableMethod(writer);
         emitGetFieldNamesMethod(writer);
+        emitGetColumnIndicesMethod(writer);
         emitPopulateUsingJsonObjectMethod(writer);
         emitPopulateUsingJsonStreamMethod(writer);
         emitCopyOrUpdateMethod(writer);
@@ -224,8 +207,24 @@ public void generate() throws IOException, UnsupportedOperationException {
         writer.close();
     }
 
+    private void emitClassFields(JavaWriter writer) throws IOException {
+        for (VariableElement variableElement : metadata.getFields()) {
+            writer.emitField("long", staticFieldIndexVarName(variableElement), EnumSet.of(Modifier.PRIVATE, Modifier.STATIC));
+        }
+        writer.emitField("Map<String, Long>", "columnIndices", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC));
+        writer.emitField("List<String>", "FIELD_NAMES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL));
+        writer.beginInitializer(true);
+        writer.emitStatement("List<String> fieldNames = new ArrayList<String>()");
+        for (VariableElement field : metadata.getFields()) {
+            writer.emitStatement("fieldNames.add(\"%s\")", field.getSimpleName().toString());
+        }
+        writer.emitStatement("FIELD_NAMES = Collections.unmodifiableList(fieldNames)");
+        writer.endInitializer();
+        writer.emitEmptyLine();
+    }
+
     private void emitAccessors(JavaWriter writer) throws IOException {
-        for (VariableElement field : fields) {
+        for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String fieldTypeCanonicalName = field.asType().toString();
 
@@ -238,25 +237,25 @@ private void emitAccessors(JavaWriter writer) throws IOException {
 
                 // Getter
                 writer.emitAnnotation("Override");
-                writer.beginMethod(fieldTypeCanonicalName, getters.get(fieldName), EnumSet.of(Modifier.PUBLIC));
+                writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
                 writer.emitStatement(
                         "realm.checkIfValid()"
                 );
                 writer.emitStatement(
-                        "return (%s) row.get%s(Realm.columnIndices.get(\"%s\").get(\"%s\"))",
-                        fieldTypeCanonicalName, realmType, className, fieldName);
+                        "return (%s) row.get%s(%s)",
+                        fieldTypeCanonicalName, realmType, staticFieldIndexVarName(field));
                 writer.endMethod();
                 writer.emitEmptyLine();
 
                 // Setter
                 writer.emitAnnotation("Override");
-                writer.beginMethod("void", setters.get(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
+                writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                 writer.emitStatement(
                         "realm.checkIfValid()"
                 );
                 writer.emitStatement(
-                        "row.set%s(Realm.columnIndices.get(\"%s\").get(\"%s\"), (%s) value)",
-                        realmType, className, fieldName, castingType);
+                        "row.set%s(%s, (%s) value)",
+                        realmType, staticFieldIndexVarName(field), castingType);
                 writer.endMethod();
             } else if (typeUtils.isAssignable(field.asType(), realmObject)) {
                 /**
@@ -265,24 +264,24 @@ private void emitAccessors(JavaWriter writer) throws IOException {
 
                 // Getter
                 writer.emitAnnotation("Override");
-                writer.beginMethod(fieldTypeCanonicalName, getters.get(fieldName), EnumSet.of(Modifier.PUBLIC));
-                writer.beginControlFlow("if (row.isNullLink(Realm.columnIndices.get(\"%s\").get(\"%s\")))", className, fieldName);
+                writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
+                writer.beginControlFlow("if (row.isNullLink(%s))", staticFieldIndexVarName(field));
                 writer.emitStatement("return null");
                 writer.endControlFlow();
                 writer.emitStatement(
-                        "return realm.get(%s.class, row.getLink(Realm.columnIndices.get(\"%s\").get(\"%s\")))",
-                        fieldTypeCanonicalName, className, fieldName);
+                        "return realm.get(%s.class, row.getLink(%s))",
+                        fieldTypeCanonicalName, staticFieldIndexVarName(field));
                 writer.endMethod();
                 writer.emitEmptyLine();
 
                 // Setter
                 writer.emitAnnotation("Override");
-                writer.beginMethod("void", setters.get(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
+                writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
                 writer.beginControlFlow("if (value == null)");
-                writer.emitStatement("row.nullifyLink(Realm.columnIndices.get(\"%s\").get(\"%s\"))", className, fieldName);
+                writer.emitStatement("row.nullifyLink(%s)", staticFieldIndexVarName(field));
                 writer.emitStatement("return");
                 writer.endControlFlow();
-                writer.emitStatement("row.setLink(Realm.columnIndices.get(\"%s\").get(\"%s\"), value.row.getIndex())", className, fieldName);
+                writer.emitStatement("row.setLink(%s, value.row.getIndex())", staticFieldIndexVarName(field));
                 writer.endMethod();
             } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                 /**
@@ -292,17 +291,17 @@ private void emitAccessors(JavaWriter writer) throws IOException {
 
                 // Getter
                 writer.emitAnnotation("Override");
-                writer.beginMethod(fieldTypeCanonicalName, getters.get(fieldName), EnumSet.of(Modifier.PUBLIC));
+                writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
                 writer.emitStatement(
-                        "return new RealmList<%s>(%s.class, row.getLinkList(Realm.columnIndices.get(\"%s\").get(\"%s\")), realm)",
-                        genericType, genericType, className, fieldName);
+                        "return new RealmList<%s>(%s.class, row.getLinkList(%s), realm)",
+                        genericType, genericType, staticFieldIndexVarName(field));
                 writer.endMethod();
                 writer.emitEmptyLine();
 
                 // Setter
                 writer.emitAnnotation("Override");
-                writer.beginMethod("void", setters.get(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
-                writer.emitStatement("LinkView links = row.getLinkList(Realm.columnIndices.get(\"%s\").get(\"%s\"))", className, fieldName);
+                writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
+                writer.emitStatement("LinkView links = row.getLinkList(%s)", staticFieldIndexVarName(field));
                 writer.beginControlFlow("if (value == null)");
                 writer.emitStatement("return"); // TODO: delete all the links instead
                 writer.endControlFlow();
@@ -325,11 +324,11 @@ private void emitInitTableMethod(JavaWriter writer) throws IOException {
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                 "ImplicitTransaction", "transaction"); // Argument type & argument name
 
-        writer.beginControlFlow("if(!transaction.hasTable(\"" + TABLE_PREFIX + this.className + "\"))");
-        writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", TABLE_PREFIX, this.className);
+        writer.beginControlFlow("if(!transaction.hasTable(\"" + Constants.TABLE_PREFIX + this.className + "\"))");
+        writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.className);
 
         // For each field generate corresponding table index constant
-        for (VariableElement field : fields) {
+        for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String fieldTypeCanonicalName = field.asType().toString();
             String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
@@ -339,28 +338,28 @@ private void emitInitTableMethod(JavaWriter writer) throws IOException {
                         JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
                         fieldName);
             } else if (typeUtils.isAssignable(field.asType(), realmObject)) {
-                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, fieldTypeSimpleName);
-                writer.emitStatement("%s%s.initTable(transaction)", fieldTypeSimpleName, PROXY_SUFFIX);
+                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
+                writer.emitStatement("%s%s.initTable(transaction)", fieldTypeSimpleName, Constants.PROXY_SUFFIX);
                 writer.endControlFlow();
                 writer.emitStatement("table.addColumnLink(ColumnType.LINK, \"%s\", transaction.getTable(\"%s%s\"))",
-                        fieldName, TABLE_PREFIX, fieldTypeSimpleName);
+                        fieldName, Constants.TABLE_PREFIX, fieldTypeSimpleName);
             } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                 String genericType = Utils.getGenericType(field);
-                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, genericType);
-                writer.emitStatement("%s%s.initTable(transaction)", genericType, PROXY_SUFFIX);
+                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericType);
+                writer.emitStatement("%s%s.initTable(transaction)", genericType, Constants.PROXY_SUFFIX);
                 writer.endControlFlow();
                 writer.emitStatement("table.addColumnLink(ColumnType.LINK_LIST, \"%s\", transaction.getTable(\"%s%s\"))",
-                        fieldName, TABLE_PREFIX, genericType);
+                        fieldName, Constants.TABLE_PREFIX, genericType);
             }
         }
 
-        for (VariableElement field : fieldsToIndex) {
+        for (VariableElement field : metadata.getIndexedFields()) {
             String fieldName = field.getSimpleName().toString();
             writer.emitStatement("table.setIndex(table.getColumnIndex(\"%s\"))", fieldName);
         }
 
-        if (primaryKey != null) {
-            String fieldName = primaryKey.getSimpleName().toString();
+        if (metadata.hasPrimaryKey()) {
+            String fieldName = metadata.getPrimaryKey().getSimpleName().toString();
             writer.emitStatement("table.setPrimaryKey(\"%s\")", fieldName);
         } else {
             writer.emitStatement("table.setPrimaryKey(\"\")");
@@ -368,7 +367,7 @@ private void emitInitTableMethod(JavaWriter writer) throws IOException {
 
         writer.emitStatement("return table");
         writer.endControlFlow();
-        writer.emitStatement("return transaction.getTable(\"%s%s\")", TABLE_PREFIX, this.className);
+        writer.emitStatement("return transaction.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.className);
         writer.endMethod();
         writer.emitEmptyLine();
     }
@@ -380,22 +379,22 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                 "ImplicitTransaction", "transaction"); // Argument type & argument name
 
-        writer.beginControlFlow("if(transaction.hasTable(\"" + TABLE_PREFIX + this.className + "\"))");
-        writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", TABLE_PREFIX, this.className);
+        writer.beginControlFlow("if(transaction.hasTable(\"" + Constants.TABLE_PREFIX + this.className + "\"))");
+        writer.emitStatement("Table table = transaction.getTable(\"%s%s\")", Constants.TABLE_PREFIX, this.className);
 
         // verify number of columns
-        writer.beginControlFlow("if(table.getColumnCount() != " + fields.size() + ")");
+        writer.beginControlFlow("if(table.getColumnCount() != " + metadata.getFields().size() + ")");
         writer.emitStatement("throw new IllegalStateException(\"Column count does not match\")");
         writer.endControlFlow();
 
         // create type dictionary for lookup
         writer.emitStatement("Map<String, ColumnType> columnTypes = new HashMap<String, ColumnType>()");
-        writer.beginControlFlow("for(long i = 0; i < " + fields.size() + "; i++)");
+        writer.beginControlFlow("for(long i = 0; i < " + metadata.getFields().size() + "; i++)");
         writer.emitStatement("columnTypes.put(table.getColumnName(i), table.getColumnType(i))");
         writer.endControlFlow();
 
         // For each field verify there is a corresponding column
-        for (VariableElement field : fields) {
+        for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String fieldTypeCanonicalName = field.asType().toString();
             String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
@@ -409,6 +408,21 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                 writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
                         fieldTypeSimpleName, fieldName);
                 writer.endControlFlow();
+
+                // Validate @PrimaryKey
+                if (field.equals(metadata.getPrimaryKey())) {
+                    writer.beginControlFlow("if (table.getPrimaryKey() != table.getColumnIndex(\"%s\"))", fieldName);
+                    writer.emitStatement("throw new IllegalStateException(\"Primary key not defined for field '%s'\")", fieldName);
+                    writer.endControlFlow();
+                }
+
+                // Validate @Index
+                if (metadata.getIndexedFields().contains(field)) {
+                    writer.beginControlFlow("if (!table.hasIndex(table.getColumnIndex(\"%s\")))", fieldName);
+                    writer.emitStatement("throw new IllegalStateException(\"Index not defined for field '%s'\")", fieldName);
+                    writer.endControlFlow();
+                }
+
             } else if (typeUtils.isAssignable(field.asType(), realmObject)) { // Links
                 writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
                 writer.emitStatement("throw new IllegalStateException(\"Missing column '%s'\")", fieldName);
@@ -417,9 +431,9 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                 writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
                         fieldTypeSimpleName, fieldName);
                 writer.endControlFlow();
-                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, fieldTypeSimpleName);
+                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
                 writer.emitStatement("throw new IllegalStateException(\"Missing table '%s%s' for column '%s'\")",
-                        TABLE_PREFIX, fieldTypeSimpleName, fieldName);
+                        Constants.TABLE_PREFIX, fieldTypeSimpleName, fieldName);
                 writer.endControlFlow();
                 // TODO: Replace with a proper comparison
 //                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", columnNumber, TABLE_PREFIX, fieldTypeName);
@@ -436,9 +450,9 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                 writer.emitStatement("throw new IllegalStateException(\"Invalid type '%s' for column '%s'\")",
                         genericType, fieldName);
                 writer.endControlFlow();
-                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", TABLE_PREFIX, genericType);
+                writer.beginControlFlow("if (!transaction.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericType);
                 writer.emitStatement("throw new IllegalStateException(\"Missing table '%s%s' for column '%s'\")",
-                        TABLE_PREFIX, genericType, fieldName);
+                        Constants.TABLE_PREFIX, genericType, fieldName);
                 writer.endControlFlow();
                 // TODO: Replace with a proper comparison
 //                writer.emitStatement("Table table_%d = transaction.getTable(\"%s%s\")", columnNumber, TABLE_PREFIX, genericType);
@@ -448,6 +462,23 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
 //                writer.endControlFlow();
             }
         }
+
+        // Populate column indices
+        writer.emitEmptyLine();
+        writer.emitStatement("columnIndices = new HashMap<String, Long>()");
+        writer
+            .beginControlFlow("for (String fieldName : getFieldNames())")
+                .emitStatement("long index = table.getColumnIndex(fieldName)")
+                .beginControlFlow("if (index == -1)")
+                    .emitStatement("throw new RealmMigrationNeededException(\"Field '\" + fieldName + \"' not found for type %s\")", metadata.getSimpleClassName())
+                .endControlFlow()
+                .emitStatement("columnIndices.put(fieldName, index)")
+            .endControlFlow();
+        for (VariableElement field : metadata.getFields()) {
+            writer.emitStatement("%s = table.getColumnIndex(\"%s\")", staticFieldIndexVarName(field), field.getSimpleName().toString());
+        }
+        writer.nextControlFlow("else");
+        writer.emitStatement("throw new RealmMigrationNeededException(\"The %s class is missing from the schema for this Realm.\")", metadata.getSimpleClassName());
         writer.endControlFlow();
         writer.endMethod();
         writer.emitEmptyLine();
@@ -455,19 +486,14 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
 
     private void emitGetFieldNamesMethod(JavaWriter writer) throws IOException {
         writer.beginMethod("List<String>", "getFieldNames", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC));
-        StringBuilder stringBuilder = new StringBuilder();
-        Iterator<VariableElement> iterator = fields.iterator();
-        while (iterator.hasNext()) {
-            String fieldName = iterator.next().getSimpleName().toString();
-            stringBuilder.append("\"");
-            stringBuilder.append(fieldName);
-            stringBuilder.append("\"");
-            if (iterator.hasNext()) {
-                stringBuilder.append(", ");
-            }
-        }
-        String statementSection = stringBuilder.toString();
-        writer.emitStatement("return Arrays.asList(%s)", statementSection);
+        writer.emitStatement("return FIELD_NAMES");
+        writer.endMethod();
+        writer.emitEmptyLine();
+    }
+
+    private void emitGetColumnIndicesMethod(JavaWriter writer) throws IOException {
+        writer.beginMethod("Map<String,Long>", "getColumnIndices", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC));
+        writer.emitStatement("return columnIndices");
         writer.endMethod();
         writer.emitEmptyLine();
     }
@@ -480,7 +506,13 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                 "Realm", "realm", className, "object", "boolean", "update", "Map<RealmObject,RealmObject>", "cache" // Argument type & argument name
         );
 
-        if (primaryKey == null) {
+        // If object is already in the Realm there is nothing to update
+        writer
+            .beginControlFlow("if (object.realm != null && object.realm.getId() == realm.getId())")
+                .emitStatement("return object")
+            .endControlFlow();
+
+        if (!metadata.hasPrimaryKey()) {
             writer.emitStatement("return copy(realm, object, update, cache)");
         } else {
             writer
@@ -490,12 +522,10 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                     .emitStatement("Table table = realm.getTable(%s.class)", className)
                     .emitStatement("long pkColumnIndex = table.getPrimaryKey()");
 
-            if (primaryKey == null) {
-                writer.emitStatement("long rowIndex = TableOrView.NO_MATCH");
-            } else if (Utils.isString(primaryKey)) {
-                writer.emitStatement("long rowIndex = table.findFirstString(pkColumnIndex, object.%s())", getters.get(primaryKey.getSimpleName().toString()));
+            if (Utils.isString(metadata.getPrimaryKey())) {
+                writer.emitStatement("long rowIndex = table.findFirstString(pkColumnIndex, object.%s())", metadata.getPrimaryKeyGetter());
             } else {
-                writer.emitStatement("long rowIndex = table.findFirstLong(pkColumnIndex, object.%s())", getters.get(primaryKey.getSimpleName().toString()));
+                writer.emitStatement("long rowIndex = table.findFirstLong(pkColumnIndex, object.%s())", metadata.getPrimaryKeyGetter());
             }
 
             writer
@@ -530,22 +560,26 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                 "Realm", "realm", className, "newObject", "boolean", "update", "Map<RealmObject,RealmObject>", "cache"); // Argument type & argument name
 
-        writer.emitStatement("%s realmObject = realm.createObject(%s.class)", className, className);
+        if (metadata.hasPrimaryKey()) {
+            writer.emitStatement("%s realmObject = realm.createObject(%s.class, newObject.%s())", className, className, metadata.getPrimaryKeyGetter());
+        } else {
+            writer.emitStatement("%s realmObject = realm.createObject(%s.class)", className, className);
+        }
         writer.emitStatement("cache.put(newObject, realmObject)");
-        for (VariableElement field : fields) {
+        for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String fieldType = field.asType().toString();
             if (typeUtils.isAssignable(field.asType(), realmObject)) {
                 writer
                     .emitEmptyLine()
-                    .emitStatement("%s %sObj = newObject.%s()", fieldType, fieldName, getters.get(fieldName))
+                    .emitStatement("%s %sObj = newObject.%s()", fieldType, fieldName, metadata.getGetter(fieldName))
                     .beginControlFlow("if (%sObj != null)", fieldName)
                         .emitStatement("%s cache%s = (%s) cache.get(%sObj)", fieldType, fieldName, fieldType, fieldName)
                         .beginControlFlow("if (cache%s != null)", fieldName)
-                            .emitStatement("realmObject.%s(cache%s)", setters.get(fieldName), fieldName)
+                            .emitStatement("realmObject.%s(cache%s)", metadata.getSetter(fieldName), fieldName)
                         .nextControlFlow("else")
                             .emitStatement("realmObject.%s(%s.copyOrUpdate(realm, %sObj, update, cache))",
-                                    setters.get(fieldName),
+                                    metadata.getSetter(fieldName),
                                     Utils.getProxyClassSimpleName(field),
                                     fieldName)
                         .endControlFlow()
@@ -553,9 +587,9 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
             } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                 writer
                     .emitEmptyLine()
-                    .emitStatement("RealmList<%s> %sList = newObject.%s()", Utils.getGenericType(field), fieldName, getters.get(fieldName))
+                    .emitStatement("RealmList<%s> %sList = newObject.%s()", Utils.getGenericType(field), fieldName, metadata.getGetter(fieldName))
                     .beginControlFlow("if (%sList != null)", fieldName)
-                        .emitStatement("RealmList<%s> %sRealmList = realmObject.%s()", Utils.getGenericType(field), fieldName, getters.get(fieldName))
+                        .emitStatement("RealmList<%s> %sRealmList = realmObject.%s()", Utils.getGenericType(field), fieldName, metadata.getGetter(fieldName))
                         .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
                                 .emitStatement("%s %sItem = %sList.get(i)", Utils.getGenericType(field), fieldName, fieldName)
                                 .emitStatement("%s cache%s = (%s) cache.get(%sItem)", Utils.getGenericType(field), fieldName, Utils.getGenericType(field), fieldName)
@@ -571,12 +605,12 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
             } else {
                 if (NULLABLE_JAVA_TYPES.containsKey(fieldType)) {
                     writer.emitStatement("realmObject.%s(newObject.%s() != null ? newObject.%s() : %s)",
-                            setters.get(fieldName),
-                            getters.get(fieldName),
-                            getters.get(fieldName),
+                            metadata.getSetter(fieldName),
+                            metadata.getGetter(fieldName),
+                            metadata.getGetter(fieldName),
                             NULLABLE_JAVA_TYPES.get(fieldType));
                 } else {
-                    writer.emitStatement("realmObject.%s(newObject.%s())", setters.get(fieldName), getters.get(fieldName));
+                    writer.emitStatement("realmObject.%s(newObject.%s())", metadata.getSetter(fieldName), metadata.getGetter(fieldName));
                 }
             }
         }
@@ -594,30 +628,30 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
                 EnumSet.of(Modifier.STATIC), // Modifiers
                 "Realm", "realm", className, "realmObject", className, "newObject", "Map<RealmObject, RealmObject>", "cache"); // Argument type & argument name
 
-        for (VariableElement field : fields) {
+        for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             if (typeUtils.isAssignable(field.asType(), realmObject)) {
                 writer
-                    .emitStatement("%s %sObj = newObject.%s()", Utils.getFieldTypeSimpleName(field), fieldName, getters.get(fieldName))
+                    .emitStatement("%s %sObj = newObject.%s()", Utils.getFieldTypeSimpleName(field), fieldName, metadata.getGetter(fieldName))
                     .beginControlFlow("if (%sObj != null)", fieldName)
                         .emitStatement("%s cache%s = (%s) cache.get(%sObj)", Utils.getFieldTypeSimpleName(field), fieldName, Utils.getFieldTypeSimpleName(field), fieldName)
                         .beginControlFlow("if (cache%s != null)", fieldName)
-                            .emitStatement("realmObject.%s(cache%s)", setters.get(fieldName), fieldName)
+                            .emitStatement("realmObject.%s(cache%s)", metadata.getSetter(fieldName), fieldName)
                         .nextControlFlow("else")
                             .emitStatement("realmObject.%s(%s.copyOrUpdate(realm, %sObj, true, cache))",
-                                    setters.get(fieldName),
+                                    metadata.getSetter(fieldName),
                                     Utils.getProxyClassSimpleName(field),
                                     fieldName,
                                     Utils.getFieldTypeSimpleName(field)
                             )
                         .endControlFlow()
                     .nextControlFlow("else")
-                        .emitStatement("realmObject.%s(null)", setters.get(fieldName))
+                        .emitStatement("realmObject.%s(null)", metadata.getSetter(fieldName))
                     .endControlFlow();
             } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                 writer
-                    .emitStatement("RealmList<%s> %sList = newObject.%s()", Utils.getGenericType(field), fieldName, getters.get(fieldName))
-                    .emitStatement("RealmList<%s> %sRealmList = realmObject.%s()", Utils.getGenericType(field), fieldName, getters.get(fieldName))
+                    .emitStatement("RealmList<%s> %sList = newObject.%s()", Utils.getGenericType(field), fieldName, metadata.getGetter(fieldName))
+                    .emitStatement("RealmList<%s> %sRealmList = realmObject.%s()", Utils.getGenericType(field), fieldName, metadata.getGetter(fieldName))
                     .emitStatement("%sRealmList.clear()", fieldName)
                     .beginControlFlow("if (%sList != null)", fieldName)
                         .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
@@ -632,19 +666,19 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
                     .endControlFlow();
 
             } else {
-                if (field == primaryKey) {
+                if (field == metadata.getPrimaryKey()) {
                     continue;
                 }
 
                 String fieldType = field.asType().toString();
                 if (NULLABLE_JAVA_TYPES.containsKey(fieldType)) {
                     writer.emitStatement("realmObject.%s(newObject.%s() != null ? newObject.%s() : %s)",
-                            setters.get(fieldName),
-                            getters.get(fieldName),
-                            getters.get(fieldName),
+                            metadata.getSetter(fieldName),
+                            metadata.getGetter(fieldName),
+                            metadata.getGetter(fieldName),
                             NULLABLE_JAVA_TYPES.get(fieldType));
                 } else {
-                    writer.emitStatement("realmObject.%s(newObject.%s())", setters.get(fieldName), getters.get(fieldName));
+                    writer.emitStatement("realmObject.%s(newObject.%s())", metadata.getSetter(fieldName), metadata.getGetter(fieldName));
                 }
             }
         }
@@ -661,6 +695,7 @@ private void emitToStringMethod(JavaWriter writer) throws IOException {
         writer.emitStatement("return \"Invalid object\"");
         writer.endControlFlow();
         writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = [\")", className);
+        List<VariableElement> fields = metadata.getFields();
         for (int i = 0; i < fields.size(); i++) {
             VariableElement field = fields.get(i);
             String fieldName = field.getSimpleName().toString();
@@ -670,16 +705,16 @@ private void emitToStringMethod(JavaWriter writer) throws IOException {
                 String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
                 writer.emitStatement(
                         "stringBuilder.append(%s() != null ? \"%s\" : \"null\")",
-                        getters.get(fieldName),
+                        metadata.getGetter(fieldName),
                         fieldTypeSimpleName
                 );
             } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                 String genericType = Utils.getGenericType(field);
                 writer.emitStatement("stringBuilder.append(\"RealmList<%s>[\").append(%s().size()).append(\"]\")",
                         genericType,
-                        getters.get(fieldName));
+                        metadata.getGetter(fieldName));
             } else {
-                writer.emitStatement("stringBuilder.append(%s())", getters.get(fieldName));
+                writer.emitStatement("stringBuilder.append(%s())", metadata.getGetter(fieldName));
             }
             writer.emitStatement("stringBuilder.append(\"}\")");
 
@@ -711,7 +746,7 @@ private void emitHashcodeMethod(JavaWriter writer) throws IOException {
     }
 
     private void emitEqualsMethod(JavaWriter writer) throws IOException {
-        String proxyClassName = className + PROXY_SUFFIX;
+        String proxyClassName = className + Constants.PROXY_SUFFIX;
         writer.emitAnnotation("Override");
         writer.beginMethod("boolean", "equals", EnumSet.of(Modifier.PUBLIC), "Object", "o");
         writer.emitStatement("if (this == o) return true");
@@ -742,12 +777,12 @@ private void emitPopulateUsingJsonObjectMethod(JavaWriter writer) throws IOExcep
                 Arrays.asList("JSONException"));
 
         writer.emitStatement("boolean standalone = obj.realm == null");
-        for (VariableElement field : fields) {
+        for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String qualifiedFieldType = field.asType().toString();
             if (typeUtils.isAssignable(field.asType(), realmObject)) {
                 RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(
-                        setters.get(fieldName),
+                        metadata.getSetter(fieldName),
                         fieldName,
                         qualifiedFieldType,
                         Utils.getProxyClassSimpleName(field),
@@ -755,8 +790,8 @@ private void emitPopulateUsingJsonObjectMethod(JavaWriter writer) throws IOExcep
 
             } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                 RealmJsonTypeHelper.emitFillRealmListWithJsonValue(
-                        getters.get(fieldName),
-                        setters.get(fieldName),
+                        metadata.getGetter(fieldName),
+                        metadata.getSetter(fieldName),
                         fieldName,
                         ((DeclaredType) field.asType()).getTypeArguments().get(0).toString(),
                         Utils.getProxyClassSimpleName(field),
@@ -764,7 +799,7 @@ private void emitPopulateUsingJsonObjectMethod(JavaWriter writer) throws IOExcep
 
             } else {
                 RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(
-                        setters.get(fieldName),
+                        metadata.getSetter(fieldName),
                         fieldName,
                         qualifiedFieldType,
                         writer);
@@ -788,6 +823,7 @@ private void emitPopulateUsingJsonStreamMethod(JavaWriter writer) throws IOExcep
         writer.beginControlFlow("while (reader.hasNext())");
         writer.emitStatement("String name = reader.nextName()");
 
+        List<VariableElement> fields = metadata.getFields();
         for (int i = 0; i < fields.size(); i++) {
             VariableElement field = fields.get(i);
             String fieldName = field.getSimpleName().toString();
@@ -800,7 +836,7 @@ private void emitPopulateUsingJsonStreamMethod(JavaWriter writer) throws IOExcep
             }
             if (typeUtils.isAssignable(field.asType(), realmObject)) {
                 RealmJsonTypeHelper.emitFillRealmObjectFromStream(
-                        setters.get(fieldName),
+                        metadata.getSetter(fieldName),
                         fieldName,
                         qualifiedFieldType,
                         Utils.getProxyClassSimpleName(field),
@@ -808,15 +844,15 @@ private void emitPopulateUsingJsonStreamMethod(JavaWriter writer) throws IOExcep
 
             } else if (typeUtils.isAssignable(field.asType(), realmList)) {
                 RealmJsonTypeHelper.emitFillRealmListFromStream(
-                        getters.get(fieldName),
-                        setters.get(fieldName),
+                        metadata.getGetter(fieldName),
+                        metadata.getSetter(fieldName),
                         ((DeclaredType) field.asType()).getTypeArguments().get(0).toString(),
                         Utils.getProxyClassSimpleName(field),
                         writer);
 
             } else {
                 RealmJsonTypeHelper.emitFillJavaTypeFromStream(
-                        setters.get(fieldName),
+                        metadata.getSetter(fieldName),
                         fieldName,
                         qualifiedFieldType,
                         writer);
@@ -833,4 +869,8 @@ private void emitPopulateUsingJsonStreamMethod(JavaWriter writer) throws IOExcep
         writer.endMethod();
         writer.emitEmptyLine();
     }
+
+    private String staticFieldIndexVarName(VariableElement variableElement) {
+        return "INDEX_" + variableElement.getSimpleName().toString().toUpperCase();
+    }
 }
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/RealmValidationListGenerator.java b/realm-annotations-processor/src/main/java/io/realm/processor/RealmValidationListGenerator.java
index e660a0dfa6..651f73a082 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/RealmValidationListGenerator.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/RealmValidationListGenerator.java
@@ -27,25 +27,22 @@
 
 public class RealmValidationListGenerator {
     private ProcessingEnvironment processingEnvironment;
-    private Set<String> classesToValidate = new HashSet<String>();
+    private Set<ClassMetaData> classesToValidate = new HashSet<ClassMetaData>();
 
-    private static final String REALM_PACKAGE_NAME = "io.realm";
     private static final String CLASS_NAME = "ValidationList";
-    private static final String PROXY_CLASS_SUFFIX = "RealmProxy";
 
-
-    public RealmValidationListGenerator(ProcessingEnvironment processingEnvironment, Set<String> classesToValidate) {
+    public RealmValidationListGenerator(ProcessingEnvironment processingEnvironment, Set<ClassMetaData> classesToValidate) {
         this.processingEnvironment = processingEnvironment;
         this.classesToValidate = classesToValidate;
     }
 
     public void generate() throws IOException {
-        String qualifiedGeneratedClassName = String.format("%s.%s", REALM_PACKAGE_NAME, CLASS_NAME);
+        String qualifiedGeneratedClassName = String.format("%s.%s", Constants.REALM_PACKAGE_NAME, CLASS_NAME);
         JavaFileObject sourceFile = processingEnvironment.getFiler().createSourceFile(qualifiedGeneratedClassName);
         JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));
         writer.setIndent("    ");
 
-        writer.emitPackage(REALM_PACKAGE_NAME);
+        writer.emitPackage(Constants.REALM_PACKAGE_NAME);
         writer.emitEmptyLine();
 
         writer.emitImports("java.util.Arrays", "java.util.List");
@@ -61,8 +58,8 @@ public void generate() throws IOException {
 
         writer.beginMethod("List<String>", "getProxyClasses", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC));
         List<String> entries = new ArrayList<String>();
-        for (String classToValidate : classesToValidate) {
-            entries.add(String.format("\"%s\"", classToValidate));
+        for (ClassMetaData classToValidate : classesToValidate) {
+            entries.add(String.format("\"%s\"", classToValidate.getSimpleClassName()));
         }
         String statementSection = joinStringList(entries, ", ");
         writer.emitStatement("return Arrays.asList(%s)", statementSection);
diff --git a/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java b/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
index d37574f11e..d9a0d5cdcd 100644
--- a/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
+++ b/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
@@ -1,16 +1,15 @@
 package io.realm.processor;
 
-import java.util.List;
-import java.util.ListIterator;
-
+import javax.annotation.processing.Messager;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
 
 /**
  * Utility methods working with the Realm processor.
@@ -18,25 +17,15 @@
 public class Utils {
 
     public static Types typeUtils;
+    private static Messager messager;
     private static DeclaredType realmList;
 
     public static void initialize(ProcessingEnvironment env) {
         typeUtils = env.getTypeUtils();
+        messager = env.getMessager();
         realmList = typeUtils.getDeclaredType(env.getElementUtils().getTypeElement("io.realm.RealmList"), typeUtils.getWildcardType(null, null));
     }
 
-    /**
-     * Checks if a given type is either on a list of valid types or is a subclass of such a type
-     */
-    public static boolean isValidType(Types typeUtils, TypeMirror type, List<TypeMirror> validTypes) {
-        for (TypeMirror validType : validTypes) {
-            if (typeUtils.isAssignable(type, validType)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
     /**
      * Returns true if the given element is the default public no arg constructor for a class.
      */
@@ -63,19 +52,7 @@ public static String getProxyClassSimpleName(VariableElement field) {
      * Return the proxy class name for a given clazz
      */
     public static String getProxyClassName(String clazz) {
-        return clazz + RealmProxyClassGenerator.PROXY_SUFFIX;
-    }
-
-    /**
-     * Returns the simple name of a class by stripping its package name.
-     */
-    public static String stripPackage(String clazz) {
-        String[] parts = clazz.split("\\.");
-        if (parts.length > 0) {
-            return parts[parts.length - 1];
-        } else {
-            return clazz;
-        }
+        return clazz + Constants.PROXY_SUFFIX;
     }
 
     /**
@@ -115,4 +92,21 @@ public static String getGenericType(VariableElement field) {
         }
         return genericType;
     }
+
+
+    public static void error(String message, Element element) {
+        messager.printMessage(Diagnostic.Kind.ERROR, message, element);
+    }
+
+    public static void error(String message) {
+        messager.printMessage(Diagnostic.Kind.ERROR, message);
+    }
+
+    public static void note(String message) {
+        messager.printMessage(Diagnostic.Kind.NOTE, message);
+    }
+
+    public static Element getSuperClass(TypeElement classType) {
+        return typeUtils.asElement(classType.getSuperclass());
+    }
 }
diff --git a/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java b/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
index ce9a258570..988eb05639 100644
--- a/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
+++ b/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
@@ -35,6 +35,7 @@
     private JavaFileObject emptyModel = JavaFileObjects.forResource("some/test/Empty.java");
     private JavaFileObject noAccessorsModel = JavaFileObjects.forResource("some/test/NoAccessors.java");
     private JavaFileObject fieldNamesModel = JavaFileObjects.forResource("some/test/FieldNames.java");
+    private JavaFileObject customAccessorModel = JavaFileObjects.forResource("some/test/CustomAccessor.java");
 
     @Test
     public void compileSimpleFile() {
@@ -51,19 +52,12 @@ public void compileProcessedSimpleFile() throws Exception {
                 .compilesWithoutError();
     }
 
-    @Test
-    public void compileEmptyFile() {
-        ASSERT.about(javaSource())
-                .that(emptyModel)
-                .compilesWithoutError();
-    }
-
     @Test
     public void compileProcessedEmptyFile() throws Exception {
         ASSERT.about(javaSource())
                 .that(emptyModel)
                 .processedWith(new RealmProcessor())
-                .compilesWithoutError();
+                .failsToCompile();
     }
 
     @Test
@@ -162,4 +156,12 @@ public void compileFieldNamesFiles() {
                 .processedWith(new RealmProcessor())
                 .compilesWithoutError();
     }
+
+    @Test
+    public void compileCustomAccessor() {
+        ASSERT.about(javaSource())
+                .that(customAccessorModel)
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
 }
diff --git a/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index e8a7e8fd6a..2b4d80f86f 100644
--- a/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -5,6 +5,7 @@
 import android.util.JsonToken;
 import io.realm.RealmObject;
 import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnType;
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
@@ -12,7 +13,9 @@
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.List;
@@ -24,115 +27,140 @@
 
 public class AllTypesRealmProxy extends AllTypes {
 
+    private static long INDEX_COLUMNSTRING;
+    private static long INDEX_COLUMNLONG;
+    private static long INDEX_COLUMNFLOAT;
+    private static long INDEX_COLUMNDOUBLE;
+    private static long INDEX_COLUMNBOOLEAN;
+    private static long INDEX_COLUMNDATE;
+    private static long INDEX_COLUMNBINARY;
+    private static long INDEX_COLUMNOBJECT;
+    private static long INDEX_COLUMNREALMLIST;
+    private static Map<String, Long> columnIndices;
+    private static final List<String> FIELD_NAMES;
+    static {
+        List<String> fieldNames = new ArrayList<String>();
+        fieldNames.add("columnString");
+        fieldNames.add("columnLong");
+        fieldNames.add("columnFloat");
+        fieldNames.add("columnDouble");
+        fieldNames.add("columnBoolean");
+        fieldNames.add("columnDate");
+        fieldNames.add("columnBinary");
+        fieldNames.add("columnObject");
+        fieldNames.add("columnRealmList");
+        FIELD_NAMES = Collections.unmodifiableList(fieldNames);
+    }
+
     @Override
     public String getColumnString() {
         realm.checkIfValid();
-        return (java.lang.String) row.getString(Realm.columnIndices.get("AllTypes").get("columnString"));
+        return (java.lang.String) row.getString(INDEX_COLUMNSTRING);
     }
 
     @Override
     public void setColumnString(String value) {
         realm.checkIfValid();
-        row.setString(Realm.columnIndices.get("AllTypes").get("columnString"), (String) value);
+        row.setString(INDEX_COLUMNSTRING, (String) value);
     }
 
     @Override
     public long getColumnLong() {
         realm.checkIfValid();
-        return (long) row.getLong(Realm.columnIndices.get("AllTypes").get("columnLong"));
+        return (long) row.getLong(INDEX_COLUMNLONG);
     }
 
     @Override
     public void setColumnLong(long value) {
         realm.checkIfValid();
-        row.setLong(Realm.columnIndices.get("AllTypes").get("columnLong"), (long) value);
+        row.setLong(INDEX_COLUMNLONG, (long) value);
     }
 
     @Override
     public float getColumnFloat() {
         realm.checkIfValid();
-        return (float) row.getFloat(Realm.columnIndices.get("AllTypes").get("columnFloat"));
+        return (float) row.getFloat(INDEX_COLUMNFLOAT);
     }
 
     @Override
     public void setColumnFloat(float value) {
         realm.checkIfValid();
-        row.setFloat(Realm.columnIndices.get("AllTypes").get("columnFloat"), (float) value);
+        row.setFloat(INDEX_COLUMNFLOAT, (float) value);
     }
 
     @Override
     public double getColumnDouble() {
         realm.checkIfValid();
-        return (double) row.getDouble(Realm.columnIndices.get("AllTypes").get("columnDouble"));
+        return (double) row.getDouble(INDEX_COLUMNDOUBLE);
     }
 
     @Override
     public void setColumnDouble(double value) {
         realm.checkIfValid();
-        row.setDouble(Realm.columnIndices.get("AllTypes").get("columnDouble"), (double) value);
+        row.setDouble(INDEX_COLUMNDOUBLE, (double) value);
     }
 
     @Override
     public boolean isColumnBoolean() {
         realm.checkIfValid();
-        return (boolean) row.getBoolean(Realm.columnIndices.get("AllTypes").get("columnBoolean"));
+        return (boolean) row.getBoolean(INDEX_COLUMNBOOLEAN);
     }
 
     @Override
     public void setColumnBoolean(boolean value) {
         realm.checkIfValid();
-        row.setBoolean(Realm.columnIndices.get("AllTypes").get("columnBoolean"), (boolean) value);
+        row.setBoolean(INDEX_COLUMNBOOLEAN, (boolean) value);
     }
 
     @Override
     public Date getColumnDate() {
         realm.checkIfValid();
-        return (java.util.Date) row.getDate(Realm.columnIndices.get("AllTypes").get("columnDate"));
+        return (java.util.Date) row.getDate(INDEX_COLUMNDATE);
     }
 
     @Override
     public void setColumnDate(Date value) {
         realm.checkIfValid();
-        row.setDate(Realm.columnIndices.get("AllTypes").get("columnDate"), (Date) value);
+        row.setDate(INDEX_COLUMNDATE, (Date) value);
     }
 
     @Override
     public byte[] getColumnBinary() {
         realm.checkIfValid();
-        return (byte[]) row.getBinaryByteArray(Realm.columnIndices.get("AllTypes").get("columnBinary"));
+        return (byte[]) row.getBinaryByteArray(INDEX_COLUMNBINARY);
     }
 
     @Override
     public void setColumnBinary(byte[] value) {
         realm.checkIfValid();
-        row.setBinaryByteArray(Realm.columnIndices.get("AllTypes").get("columnBinary"), (byte[]) value);
+        row.setBinaryByteArray(INDEX_COLUMNBINARY, (byte[]) value);
     }
 
     @Override
     public AllTypes getColumnObject() {
-        if (row.isNullLink(Realm.columnIndices.get("AllTypes").get("columnObject"))) {
+        if (row.isNullLink(INDEX_COLUMNOBJECT)) {
             return null;
         }
-        return realm.get(some.test.AllTypes.class, row.getLink(Realm.columnIndices.get("AllTypes").get("columnObject")));
+        return realm.get(some.test.AllTypes.class, row.getLink(INDEX_COLUMNOBJECT));
     }
 
     @Override
     public void setColumnObject(AllTypes value) {
         if (value == null) {
-            row.nullifyLink(Realm.columnIndices.get("AllTypes").get("columnObject"));
+            row.nullifyLink(INDEX_COLUMNOBJECT);
             return;
         }
-        row.setLink(Realm.columnIndices.get("AllTypes").get("columnObject"), value.row.getIndex());
+        row.setLink(INDEX_COLUMNOBJECT, value.row.getIndex());
     }
 
     @Override
     public RealmList<AllTypes> getColumnRealmList() {
-        return new RealmList<AllTypes>(AllTypes.class, row.getLinkList(Realm.columnIndices.get("AllTypes").get("columnRealmList")), realm);
+        return new RealmList<AllTypes>(AllTypes.class, row.getLinkList(INDEX_COLUMNREALMLIST), realm);
     }
 
     @Override
     public void setColumnRealmList(RealmList<AllTypes> value) {
-        LinkView links = row.getLinkList(Realm.columnIndices.get("AllTypes").get("columnRealmList"));
+        LinkView links = row.getLinkList(INDEX_COLUMNREALMLIST);
         if (value == null) {
             return;
         }
@@ -182,6 +210,12 @@ public static void validateTable(ImplicitTransaction transaction) {
             if (columnTypes.get("columnString") != ColumnType.STRING) {
                 throw new IllegalStateException("Invalid type 'String' for column 'columnString'");
             }
+            if (table.getPrimaryKey() != table.getColumnIndex("columnString")) {
+                throw new IllegalStateException("Primary key not defined for field 'columnString'");
+            }
+            if (!table.hasIndex(table.getColumnIndex("columnString"))) {
+                throw new IllegalStateException("Index not defined for field 'columnString'");
+            }
             if (!columnTypes.containsKey("columnLong")) {
                 throw new IllegalStateException("Missing column 'columnLong'");
             }
@@ -236,11 +270,35 @@ public static void validateTable(ImplicitTransaction transaction) {
             if (!transaction.hasTable("class_AllTypes")) {
                 throw new IllegalStateException("Missing table 'class_AllTypes' for column 'columnRealmList'");
             }
+
+            columnIndices = new HashMap<String, Long>();
+            for (String fieldName : getFieldNames()) {
+                long index = table.getColumnIndex(fieldName);
+                if (index == -1) {
+                    throw new RealmMigrationNeededException("Field '" + fieldName + "' not found for type AllTypes");
+                }
+                columnIndices.put(fieldName, index);
+            }
+            INDEX_COLUMNSTRING = table.getColumnIndex("columnString");
+            INDEX_COLUMNLONG = table.getColumnIndex("columnLong");
+            INDEX_COLUMNFLOAT = table.getColumnIndex("columnFloat");
+            INDEX_COLUMNDOUBLE = table.getColumnIndex("columnDouble");
+            INDEX_COLUMNBOOLEAN = table.getColumnIndex("columnBoolean");
+            INDEX_COLUMNDATE = table.getColumnIndex("columnDate");
+            INDEX_COLUMNBINARY = table.getColumnIndex("columnBinary");
+            INDEX_COLUMNOBJECT = table.getColumnIndex("columnObject");
+            INDEX_COLUMNREALMLIST = table.getColumnIndex("columnRealmList");
+        } else {
+            throw new RealmMigrationNeededException("The AllTypes class is missing from the schema for this Realm.");
         }
     }
 
     public static List<String> getFieldNames() {
-        return Arrays.asList("columnString", "columnLong", "columnFloat", "columnDouble", "columnBoolean", "columnDate", "columnBinary", "columnObject", "columnRealmList");
+        return FIELD_NAMES;
+    }
+
+    public static Map<String,Long> getColumnIndices() {
+        return columnIndices;
     }
 
     public static void populateUsingJsonObject(AllTypes obj, JSONObject json)
@@ -340,6 +398,9 @@ public static void populateUsingJsonStream(AllTypes obj, JsonReader reader)
     }
 
     public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update, Map<RealmObject,RealmObject> cache) {
+        if (object.realm != null && object.realm.getId() == realm.getId()) {
+            return object;
+        }
         AllTypes realmObject = null;
         boolean canUpdate = update;
         if (canUpdate) {
@@ -364,7 +425,7 @@ public static AllTypes copyOrUpdate(Realm realm, AllTypes object, boolean update
     }
 
     public static AllTypes copy(Realm realm, AllTypes newObject, boolean update, Map<RealmObject,RealmObject> cache) {
-        AllTypes realmObject = realm.createObject(AllTypes.class);
+        AllTypes realmObject = realm.createObject(AllTypes.class, newObject.getColumnString());
         cache.put(newObject, realmObject);
         realmObject.setColumnString(newObject.getColumnString() != null ? newObject.getColumnString() : "");
         realmObject.setColumnLong(newObject.getColumnLong());
diff --git a/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index 5b29bd0b48..207d0e81fa 100644
--- a/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -5,6 +5,7 @@
 import android.util.JsonToken;
 import io.realm.RealmObject;
 import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnType;
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
@@ -12,7 +13,9 @@
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.List;
@@ -24,40 +27,53 @@
 
 public class BooleansRealmProxy extends Booleans {
 
+    private static long INDEX_DONE;
+    private static long INDEX_ISREADY;
+    private static long INDEX_MCOMPLETED;
+    private static Map<String, Long> columnIndices;
+    private static final List<String> FIELD_NAMES;
+    static {
+        List<String> fieldNames = new ArrayList<String>();
+        fieldNames.add("done");
+        fieldNames.add("isReady");
+        fieldNames.add("mCompleted");
+        FIELD_NAMES = Collections.unmodifiableList(fieldNames);
+    }
+
     @Override
     public boolean isDone() {
         realm.checkIfValid();
-        return (boolean) row.getBoolean(Realm.columnIndices.get("Booleans").get("done"));
+        return (boolean) row.getBoolean(INDEX_DONE);
     }
 
     @Override
     public void setDone(boolean value) {
         realm.checkIfValid();
-        row.setBoolean(Realm.columnIndices.get("Booleans").get("done"), (boolean) value);
+        row.setBoolean(INDEX_DONE, (boolean) value);
     }
 
     @Override
     public boolean isReady() {
         realm.checkIfValid();
-        return (boolean) row.getBoolean(Realm.columnIndices.get("Booleans").get("isReady"));
+        return (boolean) row.getBoolean(INDEX_ISREADY);
     }
 
     @Override
     public void setReady(boolean value) {
         realm.checkIfValid();
-        row.setBoolean(Realm.columnIndices.get("Booleans").get("isReady"), (boolean) value);
+        row.setBoolean(INDEX_ISREADY, (boolean) value);
     }
 
     @Override
     public boolean ismCompleted() {
         realm.checkIfValid();
-        return (boolean) row.getBoolean(Realm.columnIndices.get("Booleans").get("mCompleted"));
+        return (boolean) row.getBoolean(INDEX_MCOMPLETED);
     }
 
     @Override
     public void setmCompleted(boolean value) {
         realm.checkIfValid();
-        row.setBoolean(Realm.columnIndices.get("Booleans").get("mCompleted"), (boolean) value);
+        row.setBoolean(INDEX_MCOMPLETED, (boolean) value);
     }
 
     public static Table initTable(ImplicitTransaction transaction) {
@@ -100,11 +116,29 @@ public static void validateTable(ImplicitTransaction transaction) {
             if (columnTypes.get("mCompleted") != ColumnType.BOOLEAN) {
                 throw new IllegalStateException("Invalid type 'boolean' for column 'mCompleted'");
             }
+
+            columnIndices = new HashMap<String, Long>();
+            for (String fieldName : getFieldNames()) {
+                long index = table.getColumnIndex(fieldName);
+                if (index == -1) {
+                    throw new RealmMigrationNeededException("Field '" + fieldName + "' not found for type Booleans");
+                }
+                columnIndices.put(fieldName, index);
+            }
+            INDEX_DONE = table.getColumnIndex("done");
+            INDEX_ISREADY = table.getColumnIndex("isReady");
+            INDEX_MCOMPLETED = table.getColumnIndex("mCompleted");
+        } else {
+            throw new RealmMigrationNeededException("The Booleans class is missing from the schema for this Realm.");
         }
     }
 
     public static List<String> getFieldNames() {
-        return Arrays.asList("done", "isReady", "mCompleted");
+        return FIELD_NAMES;
+    }
+
+    public static Map<String,Long> getColumnIndices() {
+        return columnIndices;
     }
 
     public static void populateUsingJsonObject(Booleans obj, JSONObject json)
@@ -140,11 +174,14 @@ public static void populateUsingJsonStream(Booleans obj, JsonReader reader)
         reader.endObject();
     }
 
-    public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmObject, RealmObject> cache) {
+    public static Booleans copyOrUpdate(Realm realm, Booleans object, boolean update, Map<RealmObject,RealmObject> cache) {
+        if (object.realm != null && object.realm.getId() == realm.getId()) {
+            return object;
+        }
         return copy(realm, object, update, cache);
     }
 
-    public static Booleans copy(Realm realm, Booleans newObject, boolean update, Map<RealmObject, RealmObject> cache) {
+    public static Booleans copy(Realm realm, Booleans newObject, boolean update, Map<RealmObject,RealmObject> cache) {
         Booleans realmObject = realm.createObject(Booleans.class);
         cache.put(newObject, realmObject);
         realmObject.setDone(newObject.isDone());
diff --git a/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index 76d5963963..3c675c2eec 100644
--- a/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -5,6 +5,7 @@
 import android.util.JsonToken;
 import io.realm.RealmObject;
 import io.realm.exceptions.RealmException;
+import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnType;
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.LinkView;
@@ -12,7 +13,9 @@
 import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.List;
@@ -24,28 +27,39 @@
 
 public class SimpleRealmProxy extends Simple {
 
+    private static long INDEX_NAME;
+    private static long INDEX_AGE;
+    private static Map<String, Long> columnIndices;
+    private static final List<String> FIELD_NAMES;
+    static {
+        List<String> fieldNames = new ArrayList<String>();
+        fieldNames.add("name");
+        fieldNames.add("age");
+        FIELD_NAMES = Collections.unmodifiableList(fieldNames);
+    }
+
     @Override
     public String getName() {
         realm.checkIfValid();
-        return (java.lang.String) row.getString(Realm.columnIndices.get("Simple").get("name"));
+        return (java.lang.String) row.getString(INDEX_NAME);
     }
 
     @Override
     public void setName(String value) {
         realm.checkIfValid();
-        row.setString(Realm.columnIndices.get("Simple").get("name"), (String) value);
+        row.setString(INDEX_NAME, (String) value);
     }
 
     @Override
     public int getAge() {
         realm.checkIfValid();
-        return (int) row.getLong(Realm.columnIndices.get("Simple").get("age"));
+        return (int) row.getLong(INDEX_AGE);
     }
 
     @Override
     public void setAge(int value) {
         realm.checkIfValid();
-        row.setLong(Realm.columnIndices.get("Simple").get("age"), (long) value);
+        row.setLong(INDEX_AGE, (long) value);
     }
 
     public static Table initTable(ImplicitTransaction transaction) {
@@ -81,11 +95,28 @@ public static void validateTable(ImplicitTransaction transaction) {
             if (columnTypes.get("age") != ColumnType.INTEGER) {
                 throw new IllegalStateException("Invalid type 'int' for column 'age'");
             }
+
+            columnIndices = new HashMap<String, Long>();
+            for (String fieldName : getFieldNames()) {
+                long index = table.getColumnIndex(fieldName);
+                if (index == -1) {
+                    throw new RealmMigrationNeededException("Field '" + fieldName + "' not found for type Simple");
+                }
+                columnIndices.put(fieldName, index);
+            }
+            INDEX_NAME = table.getColumnIndex("name");
+            INDEX_AGE = table.getColumnIndex("age");
+        } else {
+            throw new RealmMigrationNeededException("The Simple class is missing from the schema for this Realm.");
         }
     }
 
     public static List<String> getFieldNames() {
-        return Arrays.asList("name", "age");
+        return FIELD_NAMES;
+    }
+
+    public static Map<String,Long> getColumnIndices() {
+        return columnIndices;
     }
 
     public static void populateUsingJsonObject(Simple obj, JSONObject json)
@@ -116,11 +147,14 @@ public static void populateUsingJsonStream(Simple obj, JsonReader reader)
         reader.endObject();
     }
 
-    public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmObject, RealmObject> cache) {
+    public static Simple copyOrUpdate(Realm realm, Simple object, boolean update, Map<RealmObject,RealmObject> cache) {
+        if (object.realm != null && object.realm.getId() == realm.getId()) {
+            return object;
+        }
         return copy(realm, object, update, cache);
     }
 
-    public static Simple copy(Realm realm, Simple newObject, boolean update, Map<RealmObject, RealmObject> cache) {
+    public static Simple copy(Realm realm, Simple newObject, boolean update, Map<RealmObject,RealmObject> cache) {
         Simple realmObject = realm.createObject(Simple.class);
         cache.put(newObject, realmObject);
         realmObject.setName(newObject.getName() != null ? newObject.getName() : "");
diff --git a/realm-annotations-processor/src/test/resources/some/test/AllTypes.java b/realm-annotations-processor/src/test/resources/some/test/AllTypes.java
index 944080522a..cdd623ea19 100644
--- a/realm-annotations-processor/src/test/resources/some/test/AllTypes.java
+++ b/realm-annotations-processor/src/test/resources/some/test/AllTypes.java
@@ -23,6 +23,9 @@
 import io.realm.annotations.PrimaryKey;
 
 public class AllTypes extends RealmObject {
+
+    public static final String TAG = "AllTypes";
+
     @PrimaryKey
     private String columnString;
     private long columnLong;
diff --git a/realm-annotations-processor/src/test/resources/some/test/CustomAccessor.java b/realm-annotations-processor/src/test/resources/some/test/CustomAccessor.java
new file mode 100644
index 0000000000..d71ff006cc
--- /dev/null
+++ b/realm-annotations-processor/src/test/resources/some/test/CustomAccessor.java
@@ -0,0 +1,10 @@
+package some.test;
+
+import io.realm.RealmObject;
+
+public class CustomAccessor extends RealmObject {
+
+    public String getColumnString() {
+        return "No associated field";
+    }
+}
diff --git a/realm-jni/build.gradle b/realm-jni/build.gradle
index 18836bd84d..66aaa91caf 100644
--- a/realm-jni/build.gradle
+++ b/realm-jni/build.gradle
@@ -1,4 +1,4 @@
-ext.coreVersion = '0.88.4'
+ext.coreVersion = '0.89.0'
 ext.clang = false // gcc is default for the NDK. It also produces smaller binaries
 
 def commonCflags = [ '-std=c++11', '-ffunction-sections', '-fdata-sections', '-flto' ]
@@ -148,25 +148,25 @@ targets.each { target ->
         environment PATH: "${buildDir}/standalone-toolchains/${target.toolchain.name}/bin:${System.env.PATH}"
         environment CC: "${target.toolchain.commandPrefix}-${clang?'clang':'gcc'}"
         environment STRIP: "${target.toolchain.commandPrefix}-strip"
-        environment TIGHTDB_ANDROID: '1'
+        environment REALM_ANDROID: '1'
         commandLine = [
             'make',
             '-C', "${projectDir}/src",
             "CC_IS=${clang?'clang':'gcc'}",
-            "TIGHTDB_CFLAGS=-Wno-variadic-macros -DTIGHTDB_HAVE_CONFIG -DPIC -I${projectDir}/../core-${project.coreVersion}/include",
+            "REALM_CFLAGS=-Wno-variadic-macros -DREALM_HAVE_CONFIG -DPIC -I${projectDir}/../core-${project.coreVersion}/include",
             "CFLAGS_ARCH=${(commonCflags + target.cflags).join(' ')}",
             "BASE_DENOM=${target.name}",
-            "TIGHTDB_LDFLAGS=-ltightdb-android-${target.name} -lstdc++ -lsupc++ -llog -L${projectDir}/../core-${project.coreVersion} -Wl,--gc-sections -flto",
+            "REALM_LDFLAGS=-lrealm-android-${target.name} -lstdc++ -lsupc++ -llog -L${projectDir}/../core-${project.coreVersion} -Wl,--gc-sections -flto",
             'LIB_SUFFIX_SHARED=.so',
-            "libtightdb-jni-${target.name}.so"
+            "librealm-jni-${target.name}.so"
         ]
     }
 
     task "copyAndroidJni${target.name.capitalize()}"(type: Copy) {
         dependsOn "buildAndroidJni${target.name.capitalize()}"
-        from "${projectDir}/src/libtightdb-jni-${target.name}.so"
+        from "${projectDir}/src/librealm-jni-${target.name}.so"
         into "${projectDir}/../realm/src/main/jniLibs/${target.jniFolder}"
-        rename "libtightdb-jni-${target.name}.so", 'libtightdb-jni.so'
+        rename "librealm-jni-${target.name}.so", 'librealm-jni.so'
     }
 }
 
diff --git a/realm-jni/project.mk b/realm-jni/project.mk
index f85d35e21e..7d6ac268f6 100644
--- a/realm-jni/project.mk
+++ b/realm-jni/project.mk
@@ -1,7 +1,7 @@
 ENABLE_INSTALL_DEBUG_LIBS = 1
 
 # Construct fat binaries on Darwin when using Clang
-ifneq ($(TIGHTDB_ENABLE_FAT_BINARIES),)
+ifneq ($(REALM_ENABLE_FAT_BINARIES),)
   ifeq ($(OS),Darwin)
     ifeq ($(COMPILER_IS),clang)
       CFLAGS_ARCH += -arch i386 -arch x86_64
@@ -13,7 +13,7 @@ ifeq ($(OS),Darwin)
   CFLAGS_ARCH += -mmacosx-version-min=10.8 -stdlib=libc++
 endif
 
-# FIXME: '-fno-elide-constructors' currently causes TightDB to fail
+# FIXME: '-fno-elide-constructors' currently causes Realm to fail
 #CFLAGS_DEBUG += -fno-elide-constructors
 CFLAGS_PTHREADS += -pthread
 CFLAGS_GENERAL += -Wextra -ansi -pedantic -Wno-long-long
@@ -37,11 +37,11 @@ endif
   #jnidir = $(JNI_INSTALL_DIR)
 #endif
 
-ifeq ($(TIGHTDB_ANDROID),)
-  TIGHTDB_LDFLAGS += -llog
+ifeq ($(REALM_ANDROID),)
+  REALM_LDFLAGS += -llog
   CFLAGS_INCLUDE += $(JAVA_CFLAGS)
-  ifneq ($(TIGHTDB_ENABLE_MEM_USAGE),)
-    PROJECT_CFLAGS += -DTIGHTDB_ENABLE_MEM_USAGE
+  ifneq ($(REALM_ENABLE_MEM_USAGE),)
+    PROJECT_CFLAGS += -DREALM_ENABLE_MEM_USAGE
     ifeq ($(shell pkg-config libprocps --exists 2>/dev/null && echo yes),yes)
       PROCPS_CFLAGS  := $(shell pkg-config libprocps --cflags)
       PROCPS_LDFLAGS := $(shell pkg-config libprocps --libs)
@@ -56,9 +56,9 @@ else
   CFLAGS_OPTIM = -Os -DNDEBUG
 endif
 
-PROJECT_CFLAGS_OPTIM  += $(TIGHTDB_CFLAGS)
-PROJECT_CFLAGS_DEBUG  += $(TIGHTDB_CFLAGS_DBG)
-PROJECT_CFLAGS_COVER  += $(TIGHTDB_CFLAGS_DBG)
-PROJECT_LDFLAGS_OPTIM += $(TIGHTDB_LDFLAGS)
-PROJECT_LDFLAGS_DEBUG += $(TIGHTDB_LDFLAGS_DBG)
-PROJECT_LDFLAGS_COVER += $(TIGHTDB_LDFLAGS_DBG)
+PROJECT_CFLAGS_OPTIM  += $(REALM_CFLAGS)
+PROJECT_CFLAGS_DEBUG  += $(REALM_CFLAGS_DBG)
+PROJECT_CFLAGS_COVER  += $(REALM_CFLAGS_DBG)
+PROJECT_LDFLAGS_OPTIM += $(REALM_LDFLAGS)
+PROJECT_LDFLAGS_DEBUG += $(REALM_LDFLAGS_DBG)
+PROJECT_LDFLAGS_COVER += $(REALM_LDFLAGS_DBG)
diff --git a/realm-jni/src/Makefile b/realm-jni/src/Makefile
index a06012a1ee..089e82bf0c 100644
--- a/realm-jni/src/Makefile
+++ b/realm-jni/src/Makefile
@@ -1,10 +1,10 @@
-lib_LIBRARIES = libtightdb-jni.a
+lib_LIBRARIES = librealm-jni.a
 
 JNI_SOURCES := $(wildcard *.cpp)
-libtightdb_jni_a_SOURCES = $(JNI_SOURCES)
+librealm_jni_a_SOURCES = $(JNI_SOURCES)
 
 # Used by ../../build.sh
 get-inst-libraries:
-	@echo $(filter-out libtightdb-jni-cov.%,$(TARGETS_LIB_SHARED_ALIASES))
+	@echo $(filter-out librealm-jni-cov.%,$(TARGETS_LIB_SHARED_ALIASES))
 
 include ../generic.mk
diff --git a/realm-jni/src/TableSpecUtil.cpp b/realm-jni/src/TableSpecUtil.cpp
index a11497f91d..f7f9588717 100644
--- a/realm-jni/src/TableSpecUtil.cpp
+++ b/realm-jni/src/TableSpecUtil.cpp
@@ -19,7 +19,7 @@
 #include "columntypeutil.hpp"
 
 using namespace std;
-using namespace tightdb;
+using namespace realm;
 
 jclass GetClassTableSpec(JNIEnv* env)
 {
diff --git a/realm-jni/src/TableSpecUtil.hpp b/realm-jni/src/TableSpecUtil.hpp
index 389e4bb5cd..d1d4715f45 100644
--- a/realm-jni/src/TableSpecUtil.hpp
+++ b/realm-jni/src/TableSpecUtil.hpp
@@ -20,7 +20,7 @@
 #include <cstddef>
 #include <vector>
 #include <jni.h>
-#include <tightdb/table.hpp>
+#include <realm/table.hpp>
 
 jlong Java_io_realm_TableSpec_getColumnCount(JNIEnv*, jobject jTableSpec);
 
@@ -32,8 +32,8 @@ jobject Java_io_realm_TableSpec_getTableSpec(JNIEnv*, jobject jTableSpec, jlong
 
 jlong Java_io_realm_TableSpec_getColumnIndex(JNIEnv*, jobject jTableSpec, jstring columnName);
 
-void set_descriptor(JNIEnv*,       tightdb::Descriptor&, jobject jTableSpec);
-void get_descriptor(JNIEnv*, const tightdb::Descriptor&, jobject jTableSpec);
+void set_descriptor(JNIEnv*,       realm::Descriptor&, jobject jTableSpec);
+void get_descriptor(JNIEnv*, const realm::Descriptor&, jobject jTableSpec);
 
 jclass GetClassTableSpec(JNIEnv*);
 jmethodID GetTableSpecMethodID(JNIEnv*, const char* methodStr, const char* typeStr);
diff --git a/realm-jni/src/columntypeutil.hpp b/realm-jni/src/columntypeutil.hpp
index 0a7f987bbf..07f3e5d324 100644
--- a/realm-jni/src/columntypeutil.hpp
+++ b/realm-jni/src/columntypeutil.hpp
@@ -18,11 +18,11 @@
 #define REALM_COLUMN_TYPE_UTIL_H
 
 #include <jni.h>
-#include <tightdb.hpp>
+#include <realm.hpp>
 
 #ifdef __cplusplus
 
-using tightdb::DataType;
+using realm::DataType;
 
 extern "C" {
 
diff --git a/realm-jni/src/io_realm_internal_Group.cpp b/realm-jni/src/io_realm_internal_Group.cpp
index f39edfaf82..9b85e9faf6 100644
--- a/realm-jni/src/io_realm_internal_Group.cpp
+++ b/realm-jni/src/io_realm_internal_Group.cpp
@@ -14,12 +14,12 @@
  * limitations under the License.
  */
 
-#include <tightdb/util/safe_int_ops.hpp>
+#include <realm/util/safe_int_ops.hpp>
 
 #include "util.hpp"
 #include "io_realm_internal_Group.h"
 
-using namespace tightdb;
+using namespace realm;
 using std::string;
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative__(
@@ -53,7 +53,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Group_createNative__Ljava_lang_St
         }
 
         KeyBuffer key(env, keyArray);
-#ifdef TIGHTDB_ENABLE_ENCRYPTION
+#ifdef REALM_ENABLE_ENCRYPTION
         pGroup = new Group(file_name, key.data(), openmode);
 #else
         pGroup = new Group(file_name, NULL, openmode);
@@ -179,7 +179,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Group_nativeWriteToFile(
     try {
         JStringAccessor file_name_tmp(env, jFileName); // throws
         file_name = StringData(file_name_tmp);
-#ifdef TIGHTDB_ENABLE_ENCRYPTION
+#ifdef REALM_ENABLE_ENCRYPTION
         G(nativeGroupPtr)->write(file_name, key.data());
 #else
         G(nativeGroupPtr)->write(file_name);
diff --git a/realm-jni/src/io_realm_internal_LinkView.cpp b/realm-jni/src/io_realm_internal_LinkView.cpp
index 73edc051ba..9fd98b44b9 100644
--- a/realm-jni/src/io_realm_internal_LinkView.cpp
+++ b/realm-jni/src/io_realm_internal_LinkView.cpp
@@ -18,7 +18,7 @@
 #include "tablequery.hpp"
 #include "util.hpp"
 
-using namespace tightdb;
+using namespace realm;
 
 JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeClose
   (JNIEnv*, jclass, jlong nativeLinkViewPtr)
diff --git a/realm-jni/src/io_realm_internal_Row.cpp b/realm-jni/src/io_realm_internal_Row.cpp
index 8dfda7f190..44140a7886 100644
--- a/realm-jni/src/io_realm_internal_Row.cpp
+++ b/realm-jni/src/io_realm_internal_Row.cpp
@@ -19,7 +19,7 @@
 #include "mixedutil.hpp"
 #include "tablebase_tpl.hpp"
 
-using namespace tightdb;
+using namespace realm;
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Row_nativeGetColumnCount
   (JNIEnv *, jobject, jlong nativeRowPtr)
diff --git a/realm-jni/src/io_realm_internal_SharedGroup.cpp b/realm-jni/src/io_realm_internal_SharedGroup.cpp
index 7f7eb4f5b7..7013c5e571 100644
--- a/realm-jni/src/io_realm_internal_SharedGroup.cpp
+++ b/realm-jni/src/io_realm_internal_SharedGroup.cpp
@@ -18,15 +18,15 @@
 
 #include "util.hpp"
 
-#include <tightdb/group_shared.hpp>
-#include <tightdb/replication.hpp>
-#include <tightdb/commit_log.hpp>
+#include <realm/group_shared.hpp>
+#include <realm/replication.hpp>
+#include <realm/commit_log.hpp>
 
 #include "util.hpp"
 #include "io_realm_internal_SharedGroup.h"
 
 using namespace std;
-using namespace tightdb;
+using namespace realm;
 
 #define SG(ptr) reinterpret_cast<SharedGroup*>(ptr)
 
@@ -42,7 +42,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreate(
         file_name = StringData(file_name_tmp);
 
         if (enable_replication) {
-#ifdef TIGHTDB_ENABLE_REPLICATION
+#ifdef REALM_ENABLE_REPLICATION
             ThrowException(env, UnsupportedOperation,
                            "Replication is not currently supported by the Java language binding.");
 //            db = new SharedGroup(SharedGroup::replication_tag(), *file_name_ptr ? file_name_ptr : 0);
@@ -69,7 +69,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreate(
             }
 
             KeyBuffer key(env, keyArray);
-#ifdef TIGHTDB_ENABLE_ENCRYPTION
+#ifdef REALM_ENABLE_ENCRYPTION
             db = new SharedGroup(file_name, no_create!=0, level, key.data());
 #else
             db = new SharedGroup(file_name, no_create!=0, level);
@@ -88,10 +88,10 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_createNativeWithImpli
     TR_ENTER()
     try {
         KeyBuffer key(env, keyArray);
-#ifdef TIGHTDB_ENABLE_ENCRYPTION
-        SharedGroup* db = new SharedGroup(*reinterpret_cast<tightdb::Replication*>(native_replication_ptr), SharedGroup::durability_Full, key.data());
+#ifdef REALM_ENABLE_ENCRYPTION
+        SharedGroup* db = new SharedGroup(*reinterpret_cast<realm::Replication*>(native_replication_ptr), SharedGroup::durability_Full, key.data());
 #else
-        SharedGroup* db = new SharedGroup(*reinterpret_cast<tightdb::Replication*>(native_replication_ptr));
+        SharedGroup* db = new SharedGroup(*reinterpret_cast<realm::Replication*>(native_replication_ptr));
 #endif
 
         return reinterpret_cast<jlong>(db);
@@ -110,12 +110,12 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedGroup_nativeCreateReplicati
         JStringAccessor file_name_tmp(env, jfile_name); // throws
         file_name = StringData(file_name_tmp);
         KeyBuffer key(env, keyArray);
-#ifdef TIGHTDB_ENABLE_ENCRYPTION
-        Replication* repl = makeWriteLogCollector(file_name, false, key.data());
+#ifdef REALM_ENABLE_ENCRYPTION
+        std::unique_ptr<Replication> repl = makeWriteLogCollector(file_name, false, key.data());
 #else
-        Replication* repl = makeWriteLogCollector(file_name);
+        std::unique_ptr<Replication> repl = makeWriteLogCollector(file_name);
 #endif
-        return reinterpret_cast<jlong>(repl);
+        return reinterpret_cast<jlong>(repl.release());
     }
     CATCH_FILE(file_name)
     CATCH_STD()
@@ -257,7 +257,7 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_SharedGroup_nativeGetDefaultRep
     JNIEnv* env, jclass)
 {
     TR_ENTER()
-#ifdef TIGHTDB_ENABLE_REPLICATION
+#ifdef REALM_ENABLE_REPLICATION
     ThrowException(env, UnsupportedOperation,
                    "Replication is not currently supported by the Java language binding.");
     return 0;
diff --git a/realm-jni/src/io_realm_internal_SubtableSchema.cpp b/realm-jni/src/io_realm_internal_SubtableSchema.cpp
index 2edfd12b00..4bfdcb8073 100644
--- a/realm-jni/src/io_realm_internal_SubtableSchema.cpp
+++ b/realm-jni/src/io_realm_internal_SubtableSchema.cpp
@@ -17,7 +17,7 @@
 #include "util.hpp"
 #include "io_realm_internal_SubtableSchema.h"
 
-using namespace tightdb;
+using namespace realm;
 using namespace std;
 
 void arrayToVector(JNIEnv* env, jlongArray path, vector<size_t>& nativePath)
diff --git a/realm-jni/src/io_realm_internal_TableQuery.cpp b/realm-jni/src/io_realm_internal_TableQuery.cpp
index 7db158ed64..ca9e0384db 100644
--- a/realm-jni/src/io_realm_internal_TableQuery.cpp
+++ b/realm-jni/src/io_realm_internal_TableQuery.cpp
@@ -18,7 +18,7 @@
 #include "io_realm_internal_TableQuery.h"
 #include "tablequery.hpp"
 
-using namespace tightdb;
+using namespace realm;
 
 #if 1
 #define COL_TYPE_VALID(env,ptr,col, type)           TBL_AND_COL_INDEX_AND_TYPE_VALID(env,ptr,col, type)
diff --git a/realm-jni/src/io_realm_internal_Version.cpp b/realm-jni/src/io_realm_internal_Version.cpp
index 5f4662d385..bcbdf120b0 100644
--- a/realm-jni/src/io_realm_internal_Version.cpp
+++ b/realm-jni/src/io_realm_internal_Version.cpp
@@ -19,16 +19,16 @@
 
 #include "util.hpp"
 #include "io_realm_internal_Version.h"
-#include <tightdb/version.hpp>
+#include <realm/version.hpp>
 
-static int tightdb_jni_version = 23;
+static int realm_jni_version = 23;
 
 
-using namespace tightdb;
+using namespace realm;
 
 JNIEXPORT jint JNICALL Java_io_realm_internal_Version_nativeGetAPIVersion(JNIEnv*, jclass)
 {
-    return tightdb_jni_version;
+    return realm_jni_version;
 }
 
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Version_nativeGetVersion(JNIEnv *env, jclass)
diff --git a/realm-jni/src/io_realm_internal_table.cpp b/realm-jni/src/io_realm_internal_table.cpp
index 7e2bad13b0..ee3b28bfdb 100644
--- a/realm-jni/src/io_realm_internal_table.cpp
+++ b/realm-jni/src/io_realm_internal_table.cpp
@@ -27,7 +27,7 @@
 #include "tablequery.hpp"
 
 using namespace std;
-using namespace tightdb;
+using namespace realm;
 
 // Note: Don't modify spec on a table which has a shared_spec.
 // A spec is shared on subtables that are not in Mixed columns.
@@ -254,7 +254,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddEmptyRow(
     if (!TABLE_VALID(env, pTable))
         return 0;
     if (pTable->get_column_count() < 1){
-        ThrowException(env, IndexOutOfBounds, "Table has no columns");
+        ThrowException(env, IndexOutOfBounds, concat_stringdata("Table has no columns: ", pTable->get_name()));
         return 0;
     }
     try {
@@ -1451,7 +1451,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(
         // I
         if (columnName == NULL || env->GetStringLength(columnName) == 0) {
             // No primary key set. Remove any previous set keys
-            if (row_index != tightdb::not_found) {
+            if (row_index != realm::not_found) {
                 pk_table->remove(row_index);
             }
             return jlong(io_realm_internal_Table_NO_PRIMARY_KEY);
@@ -1459,7 +1459,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(
         else {
             JStringAccessor columnName2(env, columnName);
             size_t primary_key_column_index = table->get_column_index(columnName2);
-            if (row_index == tightdb::not_found) {
+            if (row_index == realm::not_found) {
                 // No primary key is currently set
                 if (check_valid_primary_key_column(env, table, primary_key_column_index)) {
                     row_index = pk_table->add_empty_row();
diff --git a/realm-jni/src/io_realm_internal_tableview.cpp b/realm-jni/src/io_realm_internal_tableview.cpp
index c8d9c52c0e..f138569147 100644
--- a/realm-jni/src/io_realm_internal_tableview.cpp
+++ b/realm-jni/src/io_realm_internal_tableview.cpp
@@ -21,7 +21,7 @@
 #include "tablequery.hpp"
 #include <ostream>
 
-using namespace tightdb;
+using namespace realm;
 
 // if you disable the validation, please remember to call sync_in_needed() 
 #define VIEW_VALID_AND_IN_SYNC(env, ptr) view_valid_and_in_sync(env, ptr)
diff --git a/realm-jni/src/mem_usage.cpp b/realm-jni/src/mem_usage.cpp
index b8455c6db6..d4e337d528 100644
--- a/realm-jni/src/mem_usage.cpp
+++ b/realm-jni/src/mem_usage.cpp
@@ -16,7 +16,7 @@
 
 #include "mem_usage.hpp"
 
-#ifndef TIGHTDB_ENABLE_MEM_USAGE
+#ifndef REALM_ENABLE_MEM_USAGE
 
 size_t GetMemUsage()
 {
diff --git a/realm-jni/src/mem_usage.hpp b/realm-jni/src/mem_usage.hpp
index 85b0a634d1..e3935c6360 100644
--- a/realm-jni/src/mem_usage.hpp
+++ b/realm-jni/src/mem_usage.hpp
@@ -19,7 +19,7 @@
 
 #include <cstdlib> // size_t
 
-/// This function requires that TIGHTDB_ENABLE_MEM_USAGE is specified
+/// This function requires that REALM_ENABLE_MEM_USAGE is specified
 /// during building. Otherwise it always returns zero.
 size_t GetMemUsage();
 
diff --git a/realm-jni/src/mixedutil.cpp b/realm-jni/src/mixedutil.cpp
index 51dbcba8d5..98f3852d4c 100644
--- a/realm-jni/src/mixedutil.cpp
+++ b/realm-jni/src/mixedutil.cpp
@@ -18,7 +18,7 @@
 #include "mixedutil.hpp"
 #include "columntypeutil.hpp"
 
-using namespace tightdb;
+using namespace realm;
 
 jclass GetClassMixed(JNIEnv* env)
 {
diff --git a/realm-jni/src/mixedutil.hpp b/realm-jni/src/mixedutil.hpp
index 3ef6a1d575..e7010072b0 100644
--- a/realm-jni/src/mixedutil.hpp
+++ b/realm-jni/src/mixedutil.hpp
@@ -18,9 +18,9 @@
 #define MIXED_UTIL_H
 
 #include <jni.h>
-#include <tightdb.hpp>
+#include <realm.hpp>
 
-using namespace tightdb;
+using namespace realm;
 
 DataType GetMixedObjectType(JNIEnv* env, jobject jMixed);
 jobject CreateJMixedFromMixed(JNIEnv* env, Mixed& mixed);
diff --git a/realm-jni/src/tablequery.hpp b/realm-jni/src/tablequery.hpp
index 8f9d826b44..0c79b7d3d1 100644
--- a/realm-jni/src/tablequery.hpp
+++ b/realm-jni/src/tablequery.hpp
@@ -19,16 +19,16 @@
 
 #include <vector>
 #include <assert.h>
-#include <tightdb.hpp>
+#include <realm.hpp>
 
-class TableQuery : public tightdb::Query {
+class TableQuery : public realm::Query {
     // 'subtables' is used to figure out which subtable the query
     // is currectly working on, so that we can lookup the correct
     // table and verify the parameters related to that table.
     std::vector<size_t> subtables;  // holds subtable column indeces 
 
 public:
-    TableQuery(const Query& copy) : tightdb::Query(copy, tightdb::Query::TCopyExpressionTag{}) {};
+    TableQuery(const Query& copy) : realm::Query(copy, realm::Query::TCopyExpressionTag{}) {};
  
     void push_subtable(size_t index) {
         subtables.push_back(index);
@@ -41,8 +41,8 @@ class TableQuery : public tightdb::Query {
         return true;
     }
     
-    tightdb::TableRef get_current_table() {
-        tightdb::TableRef table = get_table();
+    realm::TableRef get_current_table() {
+        realm::TableRef table = get_table();
 
         // Go through the stack of subtables to find current subtable (if any)
         size_t size = subtables.size(); 
diff --git a/realm-jni/src/utf8.hpp b/realm-jni/src/utf8.hpp
index 3514df25fb..5811cd93b0 100644
--- a/realm-jni/src/utf8.hpp
+++ b/realm-jni/src/utf8.hpp
@@ -1,34 +1,34 @@
 /*************************************************************************
  *
- * TIGHTDB CONFIDENTIAL
+ * REALM CONFIDENTIAL
  * __________________
  *
- *  [2011] - [2012] TightDB Inc
+ *  [2011] - [2012] Realm Inc
  *  All Rights Reserved.
  *
  * NOTICE:  All information contained herein is, and remains
- * the property of TightDB Incorporated and its suppliers,
+ * the property of Realm Incorporated and its suppliers,
  * if any.  The intellectual and technical concepts contained
- * herein are proprietary to TightDB Incorporated
+ * herein are proprietary to Realm Incorporated
  * and its suppliers and may be covered by U.S. and Foreign Patents,
  * patents in process, and are protected by trade secret or copyright law.
  * Dissemination of this information or reproduction of this material
  * is strictly forbidden unless prior written permission is obtained
- * from TightDB Incorporated.
+ * from Realm Incorporated.
  *
  **************************************************************************/
-#ifndef TIGHTDB_UTIL_UTF8_HPP
-#define TIGHTDB_UTIL_UTF8_HPP
+#ifndef REALM_UTIL_UTF8_HPP
+#define REALM_UTIL_UTF8_HPP
 
 #include <stdint.h>
 #include <string>
 
-#include <tightdb/util/safe_int_ops.hpp>
-#include <tightdb/string_data.hpp>
-#include <tightdb/util/features.h>
-#include <tightdb/utilities.hpp>
+#include <realm/util/safe_int_ops.hpp>
+#include <realm/string_data.hpp>
+#include <realm/util/features.h>
+#include <realm/utilities.hpp>
 
-namespace tightdb {
+namespace realm {
 namespace util {
 
 
@@ -97,34 +97,34 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf16(const char*& in_begin, const c
     const char* in = in_begin;
     Char16* out = out_begin;
     while (in != in_end) {
-        if (TIGHTDB_UNLIKELY(out == out_end)) {
+        if (REALM_UNLIKELY(out == out_end)) {
             break; // Need space in output buffer
         }
         uint_fast16_t v1 = uint_fast16_t(traits8::to_int_type(in[0]));
-        if (TIGHTDB_LIKELY(v1 < 0x80)) { // One byte
+        if (REALM_LIKELY(v1 < 0x80)) { // One byte
             // UTF-8 layout: 0xxxxxxx
             *out++ = Traits16::to_char_type(v1);
             in += 1;
             continue;
         }
-        if (TIGHTDB_UNLIKELY(v1 < 0xC0)) {
+        if (REALM_UNLIKELY(v1 < 0xC0)) {
             invalid = true;
             break; // Invalid first byte of UTF-8 sequence
         }
-        if (TIGHTDB_LIKELY(v1 < 0xE0)) { // Two bytes
-            if (TIGHTDB_UNLIKELY(in_end - in < 2)) {
+        if (REALM_LIKELY(v1 < 0xE0)) { // Two bytes
+            if (REALM_UNLIKELY(in_end - in < 2)) {
                 invalid = 1;
                 break; // Incomplete UTF-8 sequence
             }
             uint_fast16_t v2 = uint_fast16_t(traits8::to_int_type(in[1]));
             // UTF-8 layout: 110xxxxx 10xxxxxx
-            if (TIGHTDB_UNLIKELY((v2 & 0xC0) != 0x80)) {
+            if (REALM_UNLIKELY((v2 & 0xC0) != 0x80)) {
                 invalid = 2;
                 break; // Invalid continuation byte
             }
             uint_fast16_t v = uint_fast16_t(((v1 & 0x1F) << 6) |
                                             ((v2 & 0x3F) << 0));
-            if (TIGHTDB_UNLIKELY(v < 0x80)) {
+            if (REALM_UNLIKELY(v < 0x80)) {
                 invalid = 3;
                 break; // Overlong encoding is invalid
             }
@@ -132,26 +132,26 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf16(const char*& in_begin, const c
             in += 2;
             continue;
         }
-        if (TIGHTDB_LIKELY(v1 < 0xF0)) { // Three bytes
-            if (TIGHTDB_UNLIKELY(in_end - in < 3)) {
+        if (REALM_LIKELY(v1 < 0xF0)) { // Three bytes
+            if (REALM_UNLIKELY(in_end - in < 3)) {
                 invalid = 4;
                 break; // Incomplete UTF-8 sequence
             }
             uint_fast16_t v2 = uint_fast16_t(traits8::to_int_type(in[1]));
             uint_fast16_t v3 = uint_fast16_t(traits8::to_int_type(in[2]));
             // UTF-8 layout: 1110xxxx 10xxxxxx 10xxxxxx
-            if (TIGHTDB_UNLIKELY((v2 & 0xC0) != 0x80 || (v3 & 0xC0) != 0x80)) {
+            if (REALM_UNLIKELY((v2 & 0xC0) != 0x80 || (v3 & 0xC0) != 0x80)) {
                 invalid = true;
                 break; // Invalid continuation byte
             }
             uint_fast16_t v = uint_fast16_t(((v1 & 0x0F) << 12) |
                                             ((v2 & 0x3F) <<  6) |
                                             ((v3 & 0x3F) <<  0));
-            if (TIGHTDB_UNLIKELY(v < 0x800)) {
+            if (REALM_UNLIKELY(v < 0x800)) {
                 invalid = 5;
                 break; // Overlong encoding is invalid
             }
-            if (TIGHTDB_UNLIKELY(0xD800 <= v && v < 0xE000)) {
+            if (REALM_UNLIKELY(0xD800 <= v && v < 0xE000)) {
                 invalid = 6;
                 break; // Illegal code point range (reserved for UTF-16 surrogate pairs)
             }
@@ -159,11 +159,11 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf16(const char*& in_begin, const c
             in += 3;
             continue;
         }
-        if (TIGHTDB_UNLIKELY(out + 1 == out_end)) {
+        if (REALM_UNLIKELY(out + 1 == out_end)) {
             break; // Need space in output buffer for surrogate pair
         }
-        if (TIGHTDB_LIKELY(v1 < 0xF8)) { // Four bytes
-            if (TIGHTDB_UNLIKELY(in_end - in < 4)) {
+        if (REALM_LIKELY(v1 < 0xF8)) { // Four bytes
+            if (REALM_UNLIKELY(in_end - in < 4)) {
                 invalid = 7;
                 break; // Incomplete UTF-8 sequence
             }
@@ -172,7 +172,7 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf16(const char*& in_begin, const c
             uint_fast16_t v3 = uint_fast16_t(traits8::to_int_type(in[2])); // 16 bit intended
             uint_fast16_t v4 = uint_fast16_t(traits8::to_int_type(in[3])); // 16 bit intended
             // UTF-8 layout: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
-            if (TIGHTDB_UNLIKELY((v2 & 0xC0) != 0x80 || (v3 & 0xC0) != 0x80 ||
+            if (REALM_UNLIKELY((v2 & 0xC0) != 0x80 || (v3 & 0xC0) != 0x80 ||
                                  (v4 & 0xC0) != 0x80)) {
                 invalid = 8;
                 break; // Invalid continuation byte
@@ -182,11 +182,11 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf16(const char*& in_begin, const c
                               ((v2 & 0x3F) << 12) | // Parenthesis is 32 bit partial result
                               ((v3 & 0x3F) <<  6) | // Parenthesis is 16 bit partial result
                               ((v4 & 0x3F) <<  0)); // Parenthesis is 16 bit partial result
-            if (TIGHTDB_UNLIKELY(v < 0x10000)) {
+            if (REALM_UNLIKELY(v < 0x10000)) {
                 invalid = 9;
                 break; // Overlong encoding is invalid
             }
-            if (TIGHTDB_UNLIKELY(0x110000 <= v)) {
+            if (REALM_UNLIKELY(0x110000 <= v)) {
                 invalid = 19;
                 break; // Code point too big for UTF-16
             }
@@ -219,17 +219,17 @@ inline std::size_t Utf8x16<Char16, Traits16>::find_utf16_buf_size(const char*& i
     const char* in = in_begin;
     while (in != in_end) {
         uint_fast16_t v1 = uint_fast16_t(traits8::to_int_type(in[0]));
-        if (TIGHTDB_LIKELY(v1 < 0x80)) { // One byte
+        if (REALM_LIKELY(v1 < 0x80)) { // One byte
             num_out += 1;
             in += 1;
             continue;
         }
-        if (TIGHTDB_UNLIKELY(v1 < 0xC0)) {
+        if (REALM_UNLIKELY(v1 < 0xC0)) {
             error_code = 1;
             break; // Invalid first byte of UTF-8 sequence
         }
-        if (TIGHTDB_LIKELY(v1 < 0xE0)) { // Two bytes
-            if (TIGHTDB_UNLIKELY(in_end - in < 2)) {
+        if (REALM_LIKELY(v1 < 0xE0)) { // Two bytes
+            if (REALM_UNLIKELY(in_end - in < 2)) {
                 error_code = 2;
                 break; // Incomplete UTF-8 sequence
             }
@@ -237,8 +237,8 @@ inline std::size_t Utf8x16<Char16, Traits16>::find_utf16_buf_size(const char*& i
             in += 2;
             continue;
         }
-        if (TIGHTDB_LIKELY(v1 < 0xF0)) { // Three bytes
-            if (TIGHTDB_UNLIKELY(in_end - in < 3)) {
+        if (REALM_LIKELY(v1 < 0xF0)) { // Three bytes
+            if (REALM_UNLIKELY(in_end - in < 3)) {
                 error_code = 3;
                 break; // Incomplete UTF-8 sequence
             }
@@ -246,8 +246,8 @@ inline std::size_t Utf8x16<Char16, Traits16>::find_utf16_buf_size(const char*& i
             in += 3;
             continue;
         }
-        if (TIGHTDB_LIKELY(v1 < 0xF8)) { // Four bytes
-            if (TIGHTDB_UNLIKELY(in_end - in < 4)) {
+        if (REALM_LIKELY(v1 < 0xF8)) { // Four bytes
+            if (REALM_UNLIKELY(in_end - in < 4)) {
                 error_code = 4;
                 break; // Incomplete UTF-8 sequence
             }
@@ -282,8 +282,8 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf8(const Char16*& in_begin, const
     char* out = out_begin;
     while (in != in_end) {
         uint_fast16_t v1 = uint_fast16_t(Traits16::to_int_type(in[0]));
-        if (TIGHTDB_LIKELY(v1 < 0x80)) {
-            if (TIGHTDB_UNLIKELY(out == out_end)) {
+        if (REALM_LIKELY(v1 < 0x80)) {
+            if (REALM_UNLIKELY(out == out_end)) {
                 error_code = 1;
                 break; // Not enough output buffer space
             }
@@ -292,8 +292,8 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf8(const Char16*& in_begin, const
             in += 1;
             continue;
         }
-        if (TIGHTDB_LIKELY(v1 < 0x800)) {
-            if (TIGHTDB_UNLIKELY(out_end - out < 2)) {
+        if (REALM_LIKELY(v1 < 0x800)) {
+            if (REALM_UNLIKELY(out_end - out < 2)) {
                 error_code = 2;
                 break; // Not enough output buffer space
             }
@@ -303,8 +303,8 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf8(const Char16*& in_begin, const
             in += 1;
             continue;
         }
-        if (TIGHTDB_LIKELY(v1 < 0xD800 || 0xE000 <= v1)) {
-            if (TIGHTDB_UNLIKELY(out_end - out < 3)) {
+        if (REALM_LIKELY(v1 < 0xD800 || 0xE000 <= v1)) {
+            if (REALM_UNLIKELY(out_end - out < 3)) {
                 error_code = 3;
                 break; // Not enough output buffer space
             }
@@ -317,22 +317,22 @@ inline size_t Utf8x16<Char16, Traits16>::to_utf8(const Char16*& in_begin, const
         }
 
         // Surrogate pair
-        if (TIGHTDB_UNLIKELY(out_end - out < 4)) {
+        if (REALM_UNLIKELY(out_end - out < 4)) {
             error_code = 4;
             break; // Not enough output buffer space
         }
-        if (TIGHTDB_UNLIKELY(0xDC00 <= v1)) {
+        if (REALM_UNLIKELY(0xDC00 <= v1)) {
             error_code = 5;
             invalid = true;
             break; // Invalid first half of surrogate pair
         }
-        if (TIGHTDB_UNLIKELY(in + 1 == in_end)) {
+        if (REALM_UNLIKELY(in + 1 == in_end)) {
             error_code = 6;
             invalid = true;
             break; // Incomplete surrogate pair
         }
         uint_fast16_t v2 = uint_fast16_t(Traits16::to_int_type(in[1]));
-        if (TIGHTDB_UNLIKELY(v2 < 0xDC00 || 0xE000 <= v2)) {
+        if (REALM_UNLIKELY(v2 < 0xDC00 || 0xE000 <= v2)) {
             error_code = 7;
             invalid = true;
             break; // Invalid second half of surrogate pair
@@ -363,33 +363,33 @@ inline std::size_t Utf8x16<Char16, Traits16>::find_utf8_buf_size(const Char16*&
     const Char16* in = in_begin;
     while (in != in_end) {
         uint_fast16_t v = uint_fast16_t(Traits16::to_int_type(in[0]));
-        if (TIGHTDB_LIKELY(v < 0x80)) {
-            if (TIGHTDB_UNLIKELY(int_add_with_overflow_detect(num_out, 1))) {
+        if (REALM_LIKELY(v < 0x80)) {
+            if (REALM_UNLIKELY(int_add_with_overflow_detect(num_out, 1))) {
                 error_code = 1;
                 break; // Avoid overflow
             }
             in += 1;
         }
-        else if (TIGHTDB_LIKELY(v < 0x800)) {
-            if (TIGHTDB_UNLIKELY(int_add_with_overflow_detect(num_out, 2))) {
+        else if (REALM_LIKELY(v < 0x800)) {
+            if (REALM_UNLIKELY(int_add_with_overflow_detect(num_out, 2))) {
                 error_code = 2;
                 break; // Avoid overflow
             }
             in += 1;
         }
-        else if (TIGHTDB_LIKELY(v < 0xD800 || 0xE000 <= v)) {
-            if (TIGHTDB_UNLIKELY(int_add_with_overflow_detect(num_out, 3))) {
+        else if (REALM_LIKELY(v < 0xD800 || 0xE000 <= v)) {
+            if (REALM_UNLIKELY(int_add_with_overflow_detect(num_out, 3))) {
                 error_code = 3;
                 break; // Avoid overflow
             }
             in += 1;
         }
         else {
-            if (TIGHTDB_UNLIKELY(in + 1 == in_end)) {
+            if (REALM_UNLIKELY(in + 1 == in_end)) {
                 error_code = 4;
                 break; // Incomplete surrogate pair
             }
-            if (TIGHTDB_UNLIKELY(int_add_with_overflow_detect(num_out, 4))) {
+            if (REALM_UNLIKELY(int_add_with_overflow_detect(num_out, 4))) {
                 error_code = 5;
                 break; // Avoid overflow
             }
@@ -401,6 +401,6 @@ inline std::size_t Utf8x16<Char16, Traits16>::find_utf8_buf_size(const Char16*&
     return num_out;
 }
 } // namespace util
-} // namespace tightdb
+} // namespace realm
 
-#endif // TIGHTDB_UTIL_UTF8_HPP
+#endif // REALM_UTIL_UTF8_HPP
diff --git a/realm-jni/src/util.cpp b/realm-jni/src/util.cpp
index d92962f3c6..aa3a2fc04d 100644
--- a/realm-jni/src/util.cpp
+++ b/realm-jni/src/util.cpp
@@ -17,15 +17,15 @@
 #include <algorithm>
 #include <stdexcept>
 
-#include <tightdb/util/assert.hpp>
+#include <realm/util/assert.hpp>
 #include "utf8.hpp"
 
 #include "util.hpp"
 #include "io_realm_internal_Util.h"
 
 using namespace std;
-using namespace tightdb;
-using namespace tightdb::util;
+using namespace realm;
+using namespace realm::util;
 
 void ConvertException(JNIEnv* env, const char *file, int line)
 {
@@ -42,7 +42,7 @@ void ConvertException(JNIEnv* env, const char *file, int line)
         ThrowException(env, Unspecified, ss.str());
     }
     catch (...) { \
-        TIGHTDB_ASSERT(false);
+        REALM_ASSERT(false);
         ss << "Exception in " << file << " line " << line;
         ThrowException(env, RuntimeError, ss.str());
     }
@@ -182,7 +182,7 @@ void jprintf(JNIEnv *env, const char *format, ...)
     va_end(argptr);
 }
 
-bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, tightdb::BinaryData& bin)
+bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, realm::BinaryData& bin)
 {
     const char* data = static_cast<char*>(env->GetDirectBufferAddress(jByteBuffer));
     if (!data) {
@@ -209,8 +209,8 @@ namespace {
 // non-sign value bits, that is, an unsigned 16-bit integer, or any
 // signed or unsigned integer with more than 16 bits.
 struct JcharTraits {
-    static jchar to_int_type(jchar c)  TIGHTDB_NOEXCEPT { return c; }
-    static jchar to_char_type(jchar i) TIGHTDB_NOEXCEPT { return i; }
+    static jchar to_int_type(jchar c)  REALM_NOEXCEPT { return c; }
+    static jchar to_char_type(jchar i) REALM_NOEXCEPT { return i; }
 };
 
 struct JStringCharsAccessor {
@@ -220,8 +220,8 @@ struct JStringCharsAccessor {
     {
         m_env->ReleaseStringChars(m_string, m_data);
     }
-    const jchar* data() const TIGHTDB_NOEXCEPT { return m_data; }
-    size_t size() const TIGHTDB_NOEXCEPT { return m_size; }
+    const jchar* data() const REALM_NOEXCEPT { return m_data; }
+    size_t size() const REALM_NOEXCEPT { return m_size; }
 
 private:
     JNIEnv* const m_env;
@@ -271,6 +271,11 @@ string string_to_hex(const string& message, const jchar *str, size_t size, size_
     return ret.str();
 }
 
+string concat_stringdata(const char *message, StringData strData)
+{
+    return std::string(message) + (strData != NULL ? strData.data() : "");
+}
+
 jstring to_jstring(JNIEnv* env, StringData str)
 {
     // For efficiency, if the incoming UTF-8 string is sufficiently
@@ -281,7 +286,7 @@ jstring to_jstring(JNIEnv* env, StringData str)
 
     const size_t stack_buf_size = 48;
     jchar stack_buf[stack_buf_size];
-    UniquePtr<jchar[]> dyn_buf;
+    std::unique_ptr<jchar[]> dyn_buf;
 
     const char* in_begin = str.data();
     const char* in_end   = str.data() + str.size();
@@ -314,7 +319,7 @@ jstring to_jstring(JNIEnv* env, StringData str)
         size_t retcode = Xcode::to_utf16(in_begin, in_end, out_curr, out_end);
         if (retcode != 0) 
             throw runtime_error(string_to_hex("Failure when converting long string to UTF-16", str, in_begin, in_end, out_curr, out_end, size_t(0), retcode));
-        TIGHTDB_ASSERT(in_begin == in_end);
+        REALM_ASSERT(in_begin == in_end);
     }
 
   transcode_complete:
@@ -341,7 +346,7 @@ JStringAccessor::JStringAccessor(JNIEnv* env, jstring str)
 
     typedef Utf8x16<jchar, JcharTraits> Xcode;
     size_t max_project_size = 48;
-    TIGHTDB_ASSERT(max_project_size <= numeric_limits<size_t>::max()/4);
+    REALM_ASSERT(max_project_size <= numeric_limits<size_t>::max()/4);
     size_t buf_size;
     if (chars.size() <= max_project_size) {
         buf_size = chars.size() * 4;
diff --git a/realm-jni/src/util.hpp b/realm-jni/src/util.hpp
index 8d81cf858f..aec219593d 100644
--- a/realm-jni/src/util.hpp
+++ b/realm-jni/src/util.hpp
@@ -19,6 +19,7 @@
 
 #include <string>
 #include <sstream>
+#include <memory>
 
 #include <jni.h>
 
@@ -26,11 +27,10 @@
 #define __STDC_FORMAT_MACROS
 #include <inttypes.h>
 
-#include <tightdb.hpp>
-#include <tightdb/util/meta.hpp>
-#include <tightdb/util/unique_ptr.hpp>
-#include <tightdb/util/safe_int_ops.hpp>
-#include <tightdb/lang_bind_helper.hpp>
+#include <realm.hpp>
+#include <realm/util/meta.hpp>
+#include <realm/util/safe_int_ops.hpp>
+#include <realm/lang_bind_helper.hpp>
 
 #include "io_realm_internal_Util.h"
 
@@ -94,12 +94,12 @@ std::string num_to_string(T pNumber)
 #define S(x)    static_cast<size_t>(x)
 #define B(x)    static_cast<bool>(x)
 #define S64(x)  static_cast<int64_t>(x)
-#define TBL(x)  reinterpret_cast<tightdb::Table*>(x)
-#define TV(x)   reinterpret_cast<tightdb::TableView*>(x)
-#define LV(x)   reinterpret_cast<tightdb::LinkView*>(x)
-#define Q(x)    reinterpret_cast<tightdb::Query*>(x)
-#define G(x)    reinterpret_cast<tightdb::Group*>(x)
-#define ROW(x)  reinterpret_cast<tightdb::Row*>(x)
+#define TBL(x)  reinterpret_cast<realm::Table*>(x)
+#define TV(x)   reinterpret_cast<realm::TableView*>(x)
+#define LV(x)   reinterpret_cast<realm::LinkView*>(x)
+#define Q(x)    reinterpret_cast<realm::Query*>(x)
+#define G(x)    reinterpret_cast<realm::Group*>(x)
+#define ROW(x)  reinterpret_cast<realm::Row*>(x)
 
 // Exception handling
 
@@ -212,7 +212,7 @@ extern const char *log_tag;
 
 
 inline jlong to_jlong_or_not_found(size_t res) {
-    return (res == tightdb::not_found) ? jlong(-1) : jlong(res);
+    return (res == realm::not_found) ? jlong(-1) : jlong(res);
 }
 
 template <class T>
@@ -221,7 +221,7 @@ inline bool TableIsValid(JNIEnv* env, T* objPtr)
     bool valid = (objPtr != NULL);
     if (valid) {
         // Check if Table is valid
-        if (tightdb::util::SameType<tightdb::Table, T>::value) {
+        if (realm::util::SameType<realm::Table, T>::value) {
             valid = TBL(objPtr)->is_attached();
         }
         // TODO: Add check for TableView
@@ -256,13 +256,13 @@ bool RowIndexesValid(JNIEnv* env, T* pTable, jlong startIndex, jlong endIndex, j
         ThrowException(env, IndexOutOfBounds, "startIndex < 0.");
         return false;
     }
-    if (tightdb::util::int_greater_than(startIndex, maxIndex)) {
+    if (realm::util::int_greater_than(startIndex, maxIndex)) {
         TR_ERR("startIndex %" PRId64 " > %" PRId64 " - invalid!", S64(startIndex), S64(maxIndex))
         ThrowException(env, IndexOutOfBounds, "startIndex > available rows.");
         return false;
     }
 
-    if (tightdb::util::int_greater_than(endIndex, maxIndex)) {
+    if (realm::util::int_greater_than(endIndex, maxIndex)) {
         TR_ERR("endIndex %" PRId64 " > %" PRId64 " - invalid!", S64(endIndex), S64(maxIndex))
         ThrowException(env, IndexOutOfBounds, "endIndex > available rows.");
         return false;
@@ -292,7 +292,7 @@ inline bool RowIndexValid(JNIEnv* env, T* pTable, jlong rowIndex, bool offset=fa
     size_t size = pTable->size();
     if (size > 0 && offset)
         size -= 1;
-    bool rowErr = tightdb::util::int_greater_than_or_equal(rowIndex, size);
+    bool rowErr = realm::util::int_greater_than_or_equal(rowIndex, size);
     if (rowErr) {
         TR_ERR("rowIndex %" PRId64 " > %" PRId64 " - invalid!", S64(rowIndex), S64(size))
         ThrowException(env, IndexOutOfBounds,
@@ -305,7 +305,7 @@ inline bool RowIndexValid(JNIEnv* env, T* pTable, jlong rowIndex, bool offset=fa
 template <class T>
 inline bool TblRowIndexValid(JNIEnv* env, T* pTable, jlong rowIndex, bool offset=false)
 {
-    if (tightdb::util::SameType<tightdb::Table, T>::value) {
+    if (realm::util::SameType<realm::Table, T>::value) {
         if (!TableIsValid(env, TBL(pTable)))
             return false;
     }
@@ -319,7 +319,7 @@ inline bool ColIndexValid(JNIEnv* env, T* pTable, jlong columnIndex)
         ThrowException(env, IndexOutOfBounds, "columnIndex is less than 0.");
         return false;
     }
-    bool colErr = tightdb::util::int_greater_than_or_equal(columnIndex, pTable->get_column_count());
+    bool colErr = realm::util::int_greater_than_or_equal(columnIndex, pTable->get_column_count());
     if (colErr) {
         TR_ERR("columnIndex %" PRId64 " > %" PRId64 " - invalid!", S64(columnIndex), S64(pTable->get_column_count()))
         ThrowException(env, IndexOutOfBounds, "columnIndex > available columns.");
@@ -330,7 +330,7 @@ inline bool ColIndexValid(JNIEnv* env, T* pTable, jlong columnIndex)
 template <class T>
 inline bool TblColIndexValid(JNIEnv* env, T* pTable, jlong columnIndex)
 {
-    if (tightdb::util::SameType<tightdb::Table, T>::value) {
+    if (realm::util::SameType<realm::Table, T>::value) {
         if (!TableIsValid(env, TBL(pTable)))
             return false;
     }
@@ -361,7 +361,7 @@ inline bool TblIndexInsertValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong
 {
     if (!TblColIndexValid(env, pTable, columnIndex))
         return false;
-    bool rowErr = tightdb::util::int_greater_than(rowIndex, pTable->size()+1);
+    bool rowErr = realm::util::int_greater_than(rowIndex, pTable->size()+1);
     if (rowErr) {
         TR_ERR("rowIndex %" PRId64 " > %" PRId64 " - invalid!", S64(rowIndex), S64(pTable->size()))
         ThrowException(env, IndexOutOfBounds,
@@ -377,7 +377,7 @@ inline bool TypeValid(JNIEnv* env, T* pTable, jlong columnIndex, jlong rowIndex,
     size_t col = static_cast<size_t>(columnIndex);
     int colType = pTable->get_column_type(col);
     if (allowMixed) {
-        if (colType == tightdb::type_Mixed) {
+        if (colType == realm::type_Mixed) {
             size_t row = static_cast<size_t>(rowIndex);
             colType = pTable->get_mixed_type(col, row);
         }
@@ -431,33 +431,37 @@ inline bool TblIndexAndTypeInsertValid(JNIEnv* env, T* pTable, jlong columnIndex
         && TypeValid(env, pTable, columnIndex, rowIndex, expectColType, false);
 }
 
-bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, tightdb::BinaryData& data);
+bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, realm::BinaryData& data);
 
 
+// Utility function for appending StringData, which is returned
+// by a lot of core functions, and might potentially be NULL.
+std::string concat_stringdata(const char *message, StringData data);
+
 // Note: JNI offers methods to convert between modified UTF-8 and
 // UTF-16. Unfortunately these methods are not appropriate in this
 // context. The reason is that they use a modified version of
 // UTF-8 where U+0000 is stored as 0xC0 0x80 instead of 0x00 and
 // where a character in the range U+10000 to U+10FFFF is stored as
 // two consecutive UTF-8 encodings of the corresponding UTF-16
-// surrogate pair. Because TightDB uses proper UTF-8, we need to
+// surrogate pair. Because Realm uses proper UTF-8, we need to
 // do the transcoding ourselves.
 //
 // See also http://en.wikipedia.org/wiki/UTF-8#Modified_UTF-8
 
-jstring to_jstring(JNIEnv*, tightdb::StringData);
+jstring to_jstring(JNIEnv*, realm::StringData);
 
 class JStringAccessor {
 public:
     JStringAccessor(JNIEnv*, jstring);  // throws
 
-    operator tightdb::StringData() const TIGHTDB_NOEXCEPT
+    operator realm::StringData() const REALM_NOEXCEPT
     {
-        return tightdb::StringData(m_data.get(), m_size);
+        return realm::StringData(m_data.get(), m_size);
     }
 
 private:
-    tightdb::util::UniquePtr<char[]> m_data;
+    std::unique_ptr<char[]> m_data;
     std::size_t m_size;
 };
 
@@ -468,7 +472,7 @@ class KeyBuffer {
     , m_array(arr)
     , m_ptr(0)
     {
-#ifdef TIGHTDB_ENABLE_ENCRYPTION
+#ifdef REALM_ENABLE_ENCRYPTION
         if (arr) {
             if (env->GetArrayLength(m_array) != 64)
                 ThrowException(env, UnsupportedOperation, "Encryption key must be exactly 64 bytes.");
diff --git a/realm/build.gradle b/realm/build.gradle
index 7cad48fdaf..197ae8ac85 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -61,7 +61,7 @@ android.libraryVariants.all { variant ->
 
 task androidJar(type: Jar, dependsOn: ['assemble']) {
     group 'Build'
-    description 'Generates a jar file continaining Realm and its annotation processor'
+    description 'Generates a jar file containing Realm and its annotation processor'
     from zipTree('build/intermediates/bundles/release/classes.jar')
     from zipTree("../realm-annotations-processor/build/libs/realm-annotations-processor-${version}.jar")
     from zipTree("../realm-annotations/build/libs/realm-annotations-${version}.jar")
@@ -143,7 +143,7 @@ if (version.endsWith('-SNAPSHOT')) { // Only publish if it's a snapshot version
 
 task buildApt(type: GradleBuild) {
     dir = file('../realm-annotations-processor')
-    tasks = ['assemble']
+    tasks = ['shadowJar']
 }
 
 task compileJni(type: GradleBuild) {
@@ -170,7 +170,7 @@ def examples = [
     encryptionExample: "RealmEncryptionExample"
 ]
 
-def abi = [ 'armeabi', 'armeabi-v7a', 'mips', 'x86' ]
+def abi = [ 'armeabi', 'armeabi-v7a', 'arm64-v8a', 'mips', 'x86' ]
 
 //for Ant filter
 import org.apache.tools.ant.filters.ReplaceTokens
@@ -211,7 +211,7 @@ task copyLibrariesToEclipseFolder(dependsOn: 'androidJar') << {
     }
     abi.each() { abiName ->
         copy {
-            from "build/intermediates/eclipse/lib/${abiName}/libtightdb-jni.so"
+            from "build/intermediates/eclipse/lib/${abiName}/librealm-jni.so"
             into "../distribution/eclipse/lib/${abiName}"
         }
     }
@@ -295,4 +295,4 @@ task release {
     group 'Release'
     description 'Release realm-java'
     dependsOn pushTag
-}
\ No newline at end of file
+}
diff --git a/realm/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/src/androidTest/java/io/realm/RealmMigrationTests.java
index 680965af7f..c8debea8ed 100644
--- a/realm/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ b/realm/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -2,13 +2,35 @@
 
 import android.test.AndroidTestCase;
 
+import java.io.File;
 import java.io.IOException;
 
 import io.realm.entities.AllTypes;
+import io.realm.entities.FieldOrder;
+import io.realm.entities.AnnotationTypes;
 import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.ColumnType;
+import io.realm.internal.Table;
 
 public class RealmMigrationTests extends AndroidTestCase {
 
+    public Realm realm;
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        Realm.deleteRealmFile(getContext());
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        super.tearDown();
+        if (realm != null) {
+            realm.close();
+        }
+        Realm.setSchema(null);
+    }
+
     public void testRealmClosedAfterMigrationException() throws IOException {
         String REALM_NAME = "default0.realm";
         Realm.deleteRealmFile(getContext(), REALM_NAME);
@@ -25,4 +47,108 @@ public void testRealmClosedAfterMigrationException() throws IOException {
         int result = realm.where(AllTypes.class).equalTo("columnString", "Foo").findAll().size();
         assertEquals(0, result);
     }
+
+    // If a migration creates a different ordering of columns on Realm A, while another ordering is generated by
+    // creating a new Realm B. Global column indices will not work. They must be calculated for each Realm.
+    public void testLocalColumnIndices() throws IOException {
+        String MIGRATED_REALM = "migrated.realm";
+        String NEW_REALM = "new.realm";
+
+        // Migrate old Realm to proper schema
+        Realm.deleteRealmFile(getContext(), MIGRATED_REALM);
+        Realm.setSchema(AllTypes.class);
+        Realm migratedRealm = Realm.getInstance(getContext(), MIGRATED_REALM);
+        migratedRealm.close();
+        Realm.migrateRealmAtPath(new File(getContext().getFilesDir(), MIGRATED_REALM).getAbsolutePath(), new RealmMigration() {
+            @Override
+            public long execute(Realm realm, long version) {
+                Table languageTable = realm.getTable(FieldOrder.class);
+                if (languageTable.getColumnCount() == 0) {
+                    languageTable.addColumn(ColumnType.INTEGER, "field2");
+                    languageTable.addColumn(ColumnType.BOOLEAN, "field1");
+                }
+
+                return version + 1;
+            }
+        });
+
+        // Open migrated Realm and populate column indices based on migration ordering.
+        Realm.setSchema(AllTypes.class, FieldOrder.class);
+        migratedRealm = Realm.getInstance(getContext(), MIGRATED_REALM);
+
+        // Create new Realm which will cause column indices to be recalculated based on the order in the java file
+        // instead of the migration
+        Realm.deleteRealmFile(getContext(), NEW_REALM);
+        Realm newRealm = Realm.getInstance(getContext(), NEW_REALM);
+        newRealm.close();
+
+        // Try to query migrated realm. With local column indices this will work. With global it will fail.
+        assertEquals(0, migratedRealm.where(FieldOrder.class).equalTo("field1", true).findAll().size());
+    }
+
+    public void testNotSettingIndexThrows() {
+        Realm.setSchema(AnnotationTypes.class);
+        Realm.migrateRealmAtPath(new File(getContext().getFilesDir(), "default.realm").getAbsolutePath(), new RealmMigration() {
+            @Override
+            public long execute(Realm realm, long version) {
+                Table table = realm.getTable(AnnotationTypes.class);
+                table.addColumn(ColumnType.INTEGER, "id");
+                table.setPrimaryKey("id");
+                table.addColumn(ColumnType.STRING, "indexString");
+                table.addColumn(ColumnType.STRING, "notIndexString");
+                // Forget to set @Index
+                return 1;
+            }
+        });
+
+        try {
+            realm = Realm.getInstance(getContext());
+            fail();
+        } catch (RealmMigrationNeededException expected) {
+        }
+    }
+
+    public void testNotSettingPrimaryKeyThrows() {
+        Realm.setSchema(AnnotationTypes.class);
+        Realm.migrateRealmAtPath(new File(getContext().getFilesDir(), "default.realm").getAbsolutePath(), new RealmMigration() {
+            @Override
+            public long execute(Realm realm, long version) {
+                Table table = realm.getTable(AnnotationTypes.class);
+                table.addColumn(ColumnType.INTEGER, "id");
+                // Forget to set @PrimaryKey
+                long columnIndex = table.addColumn(ColumnType.STRING, "indexString");
+                table.setIndex(columnIndex);
+                table.addColumn(ColumnType.STRING, "notIndexString");
+                return 1;
+            }
+        });
+
+        try {
+            realm = Realm.getInstance(getContext());
+            fail();
+        } catch (RealmMigrationNeededException expected) {
+        }
+    }
+
+    public void testSetAnnotations() {
+        Realm.setSchema(AnnotationTypes.class);
+        Realm.migrateRealmAtPath(new File(getContext().getFilesDir(), "default.realm").getAbsolutePath(), new RealmMigration() {
+            @Override
+            public long execute(Realm realm, long version) {
+                Table table = realm.getTable(AnnotationTypes.class);
+                table.addColumn(ColumnType.INTEGER, "id");
+                table.setPrimaryKey("id");
+                long columnIndex = table.addColumn(ColumnType.STRING, "indexString");
+                table.setIndex(columnIndex);
+                table.addColumn(ColumnType.STRING, "notIndexString");
+                return 1;
+            }
+        });
+
+        realm = Realm.getInstance(getContext());
+        Table table = realm.getTable(AnnotationTypes.class);
+        assertEquals(3, table.getColumnCount());
+        assertTrue(table.hasPrimaryKey());
+        assertTrue(table.hasIndex(table.getColumnIndex("indexString")));
+    }
 }
diff --git a/realm/src/androidTest/java/io/realm/RealmTest.java b/realm/src/androidTest/java/io/realm/RealmTest.java
index 7d00046e83..c7393dc931 100644
--- a/realm/src/androidTest/java/io/realm/RealmTest.java
+++ b/realm/src/androidTest/java/io/realm/RealmTest.java
@@ -46,6 +46,7 @@
 import io.realm.entities.Owner;
 import io.realm.entities.OwnerPrimaryKey;
 import io.realm.entities.PrimaryKeyAsLong;
+import io.realm.entities.PrimaryKeyAsString;
 import io.realm.entities.PrimaryKeyMix;
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.RealmException;
@@ -170,7 +171,26 @@ public void testGetInstanceFileNoWritePermissionThrows() throws IOException {
         }
     }
 
-
+    // TODO Disabled due to the build phone keep crashing on this. It might be related to https://github.com/realm/realm-java/issues/1008
+    public void DISABLEtestGetInstanceClearsCacheWhenFailed() {
+        String REALM_NAME = "invalid_cache.realm";
+        Realm.deleteRealmFile(getContext(), REALM_NAME);
+        Random random = new Random();
+        byte[] key = new byte[64];
+        random.nextBytes(key);
+        Realm realm = Realm.getInstance(getContext(), REALM_NAME, key); // Create starting Realm with key1
+        realm.close();
+        random.nextBytes(key);
+        try {
+            Realm.getInstance(getContext(), REALM_NAME, key); // Try to open with key 2
+        } catch (IllegalArgumentException expected) {
+            // Delete Realm so key 2 works. This should work as a Realm shouldn't be cached
+            // if initialization failed.
+            assertTrue(Realm.deleteRealmFile(getContext(), REALM_NAME));
+            Realm.getInstance(getContext(), REALM_NAME, key);
+            realm.close();
+        }
+    }
 
     public void testRealmCache() {
         Realm newRealm = Realm.getInstance(getContext());
@@ -1049,6 +1069,40 @@ public void testCopyToRealmDefaultValues() {
         assertArrayEquals(new byte[0], realmTypes.getColumnBinary());
     }
 
+    // Check that using copyToRealm will set the primary key directly instead of first setting
+    // it to the default value (which can fail)
+    public void testCopyToRealmWithPrimaryKeySetValueDirectly() {
+        testRealm.beginTransaction();
+        testRealm.createObject(OwnerPrimaryKey.class);
+        testRealm.copyToRealm(new OwnerPrimaryKey(1, "Foo"));
+        testRealm.commitTransaction();
+        assertEquals(2, testRealm.where(OwnerPrimaryKey.class).count());
+    }
+
+    public void testCopyToRealmWithPrimaryAsNullThrows() {
+        testRealm.beginTransaction();
+        try {
+            testRealm.copyToRealm(new PrimaryKeyAsString());
+            fail();
+        } catch (RealmException expected) {
+        } finally {
+            testRealm.cancelTransaction();
+        }
+    }
+
+    public void testCopyToRealmDontCopyNestedRealmObjets() {
+        testRealm.beginTransaction();
+        CyclicTypePrimaryKey childObj = testRealm.createObject(CyclicTypePrimaryKey.class);
+        childObj.setName("Child");
+        childObj.setId(1);
+
+        CyclicTypePrimaryKey parentObj = new CyclicTypePrimaryKey(2);
+        parentObj.setObject(childObj);
+        testRealm.copyToRealm(parentObj);
+        testRealm.commitTransaction();
+
+        assertEquals(2, testRealm.where(CyclicTypePrimaryKey.class).count());
+    }
 
     public void testCopyToRealmList() {
         Dog dog1 = new Dog();
@@ -1327,7 +1381,7 @@ public void testOpeningOfEncryptedRealmWithDifferentKeyInstances() {
         assertTrue(key1 != key2);
 
         final String ENCRYPTED_REALM = "differentKeys.realm";
-
+        Realm.deleteRealmFile(getContext(), ENCRYPTED_REALM);
         Realm realm1 = null;
         Realm realm2 = null;
         try {
@@ -1348,8 +1402,7 @@ public void testOpeningOfEncryptedRealmWithDifferentKeyInstances() {
         }
     }
 
-    // TODO Enable once copy to encrypted Realm works again
-    public void disableTestWriteEncryptedCopy() throws Exception {
+    public void testWriteEncryptedCopy() throws Exception {
         populateTestRealm();
         long before = testRealm.where(AllTypes.class).count();
         assertEquals(TEST_DATA_SIZE, before);
@@ -1483,6 +1536,39 @@ public void testWrongKeyShouldThrow() {
             fail();
         } catch (IllegalStateException ignored) {
         }
+    }
+
+    public void testUpdateObjectWithLinks() throws Exception {
+        testRealm.beginTransaction();
+
+        // Create an owner with two dogs
+        OwnerPrimaryKey owner = testRealm.createObject(OwnerPrimaryKey.class);
+        owner.setId(1);
+        owner.setName("Jack");
+        Dog rex = testRealm.createObject(Dog.class);
+        rex.setName("Rex");
+        Dog fido = testRealm.createObject(Dog.class);
+        fido.setName("Fido");
+        owner.getDogs().add(rex);
+        owner.getDogs().add(fido);
+        assertEquals(2, owner.getDogs().size());
+
+        // Changing the name of the owner should not affect the number of dogs
+        owner.setName("Peter");
+        assertEquals(2, owner.getDogs().size());
+
+        // Updating the user should not affect it either. This is actually a no-op since owner is a Realm backed object
+        OwnerPrimaryKey owner2 = testRealm.copyToRealmOrUpdate(owner);
+        assertEquals(2, owner.getDogs().size());
+        assertEquals(2, owner2.getDogs().size());
+
+        testRealm.commitTransaction();
+    }
 
+    public void testDeleteNonRealmFile() throws IOException {
+        File tmpFile = new File(getContext().getFilesDir(), "tmp");
+        tmpFile.delete();
+        assertTrue(tmpFile.createNewFile());
+        assertTrue(Realm.deleteRealmFile(tmpFile));
     }
 }
diff --git a/realm/src/androidTest/java/io/realm/entities/FieldOrder.java b/realm/src/androidTest/java/io/realm/entities/FieldOrder.java
new file mode 100644
index 0000000000..ef32a51c4f
--- /dev/null
+++ b/realm/src/androidTest/java/io/realm/entities/FieldOrder.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+
+public class FieldOrder extends RealmObject {
+
+    private boolean field1;
+    private int field2;
+
+    public boolean isField1() {
+        return field1;
+    }
+
+    public void setField1(boolean field1) {
+        this.field1 = field1;
+    }
+
+    public int getField2() {
+        return field2;
+    }
+
+    public void setField2(int field2) {
+        this.field2 = field2;
+    }
+}
diff --git a/realm/src/androidTest/java/io/realm/entities/OwnerPrimaryKey.java b/realm/src/androidTest/java/io/realm/entities/OwnerPrimaryKey.java
index 3a8ed2cb09..231e08a6aa 100644
--- a/realm/src/androidTest/java/io/realm/entities/OwnerPrimaryKey.java
+++ b/realm/src/androidTest/java/io/realm/entities/OwnerPrimaryKey.java
@@ -16,6 +16,7 @@
 
 package io.realm.entities;
 
+import io.realm.RealmList;
 import io.realm.RealmObject;
 import io.realm.annotations.PrimaryKey;
 
@@ -26,6 +27,7 @@
 
     private String name;
     private DogPrimaryKey dog;
+    private RealmList<Dog> dogs;
 
     public OwnerPrimaryKey() {
     }
@@ -58,4 +60,12 @@ public DogPrimaryKey getDog() {
     public void setDog(DogPrimaryKey dog) {
         this.dog = dog;
     }
+
+    public RealmList<Dog> getDogs() {
+        return dogs;
+    }
+
+    public void setDogs(RealmList<Dog> dogs) {
+        this.dogs = dogs;
+    }
 }
diff --git a/realm/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java b/realm/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
index 3bba1b003c..ce53189446 100644
--- a/realm/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
+++ b/realm/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
@@ -26,6 +26,13 @@
 
     private long id;
 
+    public PrimaryKeyAsString() {
+    }
+
+    public PrimaryKeyAsString(String name) {
+        this.name = name;
+    }
+
     public String getName() {
         return name;
     }
diff --git a/realm/src/androidTest/java/io/realm/internal/JNIBinaryTypeTest.java b/realm/src/androidTest/java/io/realm/internal/JNIBinaryTypeTest.java
index 503c5a3120..51280a6a6c 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNIBinaryTypeTest.java
+++ b/realm/src/androidTest/java/io/realm/internal/JNIBinaryTypeTest.java
@@ -9,7 +9,7 @@
 
     @Override
     public void setUp() {
-        TightDB.loadLibrary();
+        RealmCore.loadLibrary();
         //util.setDebugLevel(0); //Set to 1 to see more JNI debug messages
 
         table = new Table();
diff --git a/realm/src/androidTest/java/io/realm/internal/JNITransactions.java b/realm/src/androidTest/java/io/realm/internal/JNITransactions.java
index cbb78bfdfc..3106ea9625 100644
--- a/realm/src/androidTest/java/io/realm/internal/JNITransactions.java
+++ b/realm/src/androidTest/java/io/realm/internal/JNITransactions.java
@@ -36,7 +36,24 @@ protected void deleteFile(String filename) throws IOException {
         }
     }
 
-    
+    private Table getTableWithStringPrimaryKey() {
+        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
+        WriteTransaction trans = db.beginWrite();
+        Table t = trans.getTable("TestTable");
+        t.addColumn(ColumnType.STRING, "colName");
+        t.setPrimaryKey("colName");
+        return t;
+    }
+
+    private Table getTableWithIntegerPrimaryKey() {
+        SharedGroup db = new SharedGroup(testFile, SharedGroup.Durability.FULL, null);
+        WriteTransaction trans = db.beginWrite();
+        Table t = trans.getTable("TestTable");
+        t.addColumn(ColumnType.INTEGER, "colName");
+        t.setPrimaryKey("colName");
+        return t;
+    }
+
     private void createDBFileName(){
         testFile = new File(
                 this.getContext().getFilesDir(),
@@ -319,24 +336,44 @@ public void testRemovingPrimaryKeyRemovesConstraint_typeSetters() {
         fail("Primary key not enforced.");
     }
 
+    public void testAddEmptyRowWithPrimaryKeyWrongTypeStringThrows() {
+        Table t = getTableWithStringPrimaryKey();
+        try {
+            t.addEmptyRowWithPrimaryKey(42);
+            fail();
+        } catch (IllegalArgumentException expected) {
+        }
+    }
 
-
-    /*  ARM Only works for Java 1.7 - NOT available in Android.
-
-    @Test(enabled=true)
-    public void mustReadARM() {
-        writeOneTransaction(1);
-
-        // Read from table
-        // System.out.println("mustReadARM.");
-        try (ReadTransaction t = new ReadTransaction(db)) {
-            EmployeeTable employees = new EmployeeTable(t);
-            assertEquals(true, employees.isValid());
-            assertEquals(1, employees.size());
+    public void testAddEmptyRowWithPrimaryKeyNullStringThrows() {
+        Table t = getTableWithStringPrimaryKey();
+        try {
+            t.addEmptyRowWithPrimaryKey(null);
+            fail();
+        } catch (IllegalArgumentException expected) {
         }
-        catch (Throwable e) {
+    }
 
+    public void testAddEmptyRowWithPrimaryKeyWrongTypeIntegerThrows() {
+        Table t = getTableWithIntegerPrimaryKey();
+        try {
+            t.addEmptyRowWithPrimaryKey("Foo");
+            fail();
+        } catch (IllegalArgumentException expected) {
         }
     }
-     */
+
+    public void testAddEmptyRowWithPrimaryKeyString() {
+        Table t = getTableWithStringPrimaryKey();
+        long rowIndex = t.addEmptyRowWithPrimaryKey("Foo");
+        assertEquals(1, t.size());
+        assertEquals("Foo", t.getRow(rowIndex).getString(0));
+    }
+
+    public void testAddEmptyRowWithPrimaryKeyLong() {
+        Table t = getTableWithIntegerPrimaryKey();
+        long rowIndex = t.addEmptyRowWithPrimaryKey(42);
+        assertEquals(1, t.size());
+        assertEquals(42, t.getRow(rowIndex).getLong(0));
+    }
 }
diff --git a/realm/src/main/java/io/realm/Realm.java b/realm/src/main/java/io/realm/Realm.java
index e93dbd9d45..944fa3eacd 100644
--- a/realm/src/main/java/io/realm/Realm.java
+++ b/realm/src/main/java/io/realm/Realm.java
@@ -53,6 +53,7 @@
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmIOException;
 import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.ColumnIndices;
 import io.realm.internal.ColumnType;
 import io.realm.internal.ImplicitTransaction;
 import io.realm.internal.RealmJson;
@@ -168,13 +169,15 @@
     private final Map<Class<?>, Method> initTableMethods = new HashMap<Class<?>, Method>();
     private final Map<Class<?>, Method> insertOrUpdateMethods = new HashMap<Class<?>, Method>();
     private final Map<Class<?>, Constructor> generatedConstructors = new HashMap<Class<?>, Constructor>();
+
+    // Maps classes to the name of the proxied class. Examples: Dog.class -> Dog, DogRealmProxy -> Dog
+    private final Map<Class<?>, String> proxiedClassNames = new HashMap<Class<?>, String>();
     private final List<RealmChangeListener> changeListeners = new ArrayList<RealmChangeListener>();
     private final Map<Class<?>, Table> tables = new HashMap<Class<?>, Table>();
     private static final Set<Class<? extends RealmObject>> customSchema = new HashSet<Class<? extends RealmObject>>();
     private static final long UNVERSIONED = -1;
 
-    // Package protected to be reachable by proxy classes
-    static final Map<String, Map<String, Long>> columnIndices = new HashMap<String, Map<String, Long>>();
+    final ColumnIndices columnIndices = new ColumnIndices();
 
     static {
         RealmLog.add(BuildConfig.DEBUG ? new DebugAndroidLogger() : new ReleaseAndroidLogger());
@@ -210,8 +213,8 @@ private Realm(String absolutePath, byte[] key, boolean autoRefresh) {
     protected void finalize() throws Throwable {
         if (sharedGroup != null) {
             RealmLog.w("Remember to call close() on all Realm instances. " +
-                    "Realm " + path + " is being finalized without being closed, " +
-                    "this can lead to running out of native memory."
+                            "Realm " + path + " is being finalized without being closed, " +
+                            "this can lead to running out of native memory."
             );
         }
         super.finalize();
@@ -317,12 +320,14 @@ public void setAutoRefresh(boolean autoRefresh) {
 
     // Public because of migrations
     public Table getTable(Class<?> clazz) {
-        String simpleClassName = simpleClassNames.get(clazz);
-        if (simpleClassName == null) {
-            simpleClassName = clazz.getSimpleName();
-            simpleClassNames.put(clazz, simpleClassName);
+        final String proxySuffix = "RealmProxy";
+        String proxiedClassName = proxiedClassNames.get(clazz);
+        if (proxiedClassName == null) {
+            String classSimpleName = clazz.getSimpleName();
+            proxiedClassName = classSimpleName.replace(proxySuffix, "");
+            proxiedClassNames.put(clazz, proxiedClassName);
         }
-        return transaction.getTable(TABLE_PREFIX + simpleClassName);
+        return transaction.getTable(TABLE_PREFIX + proxiedClassName);
     }
 
     /**
@@ -485,25 +490,16 @@ private static Realm create(File writableFolder, String filename, byte[] key) {
     }
 
     private static synchronized Realm createAndValidate(String absolutePath, byte[] key, boolean validateSchema,
-                                            boolean autoRefresh) {
+                                                        boolean autoRefresh) {
+        // Check thread local cache for existing Realm
         int id = absolutePath.hashCode();
         Map<Integer, Integer> localRefCount = referenceCount.get();
         Integer references = localRefCount.get(id);
         if (references == null) {
             references = 0;
         }
-        if (references == 0) {
-            AtomicInteger counter = openRealms.get(id);
-            if (counter == null) {
-                openRealms.put(id, new AtomicInteger(1));
-            } else {
-                counter.incrementAndGet();
-            }
-
-        }
         Map<Integer, Realm> realms = realmsCache.get();
         Realm realm = realms.get(absolutePath.hashCode());
-
         if (realm != null) {
             if (!Arrays.equals(realm.key, key)) {
                 throw new IllegalStateException(DIFFERENT_KEY_MESSAGE);
@@ -519,6 +515,17 @@ private static synchronized Realm createAndValidate(String absolutePath, byte[]
         realmsCache.set(realms);
         localRefCount.put(id, references + 1);
 
+        // Increment global reference counter
+        if (references == 0) {
+            AtomicInteger counter = openRealms.get(id);
+            if (counter == null) {
+                openRealms.put(id, new AtomicInteger(1));
+            } else {
+                counter.incrementAndGet();
+            }
+        }
+
+        // Initialize Realm schema if needed
         if (validateSchema) {
             try {
                 initializeRealm(realm);
@@ -625,34 +632,22 @@ private static void initializeRealm(Realm realm) {
                 }
 
                 // Populate the columnIndices table
-                Method fieldNamesMethod;
+                Method columnIndiciesMethod;
                 try {
-                    fieldNamesMethod = generatedClass.getMethod("getFieldNames");
+                    columnIndiciesMethod = generatedClass.getMethod("getColumnIndices");
                 } catch (NoSuchMethodException e) {
-                    throw new RealmException("Could not find the getFieldNames method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
+                    throw new RealmException("Could not find the getColumnIndices method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                 }
-                List<String> fieldNames;
+                Map<String,Long> indices;
                 try {
                     //noinspection unchecked
-                    fieldNames = (List<String>) fieldNamesMethod.invoke(null);
+                    indices = (Map<String,Long>) columnIndiciesMethod.invoke(null);
                 } catch (IllegalAccessException e) {
-                    throw new RealmException("Could not execute the getFieldNames method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
+                    throw new RealmException("Could not execute the getColumnIndices method in the generated " + generatedClassName + " class", e);
                 } catch (InvocationTargetException e) {
-                    throw new RealmException("An exception was thrown in the getFieldNames method in the generated " + generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
-                }
-                Table table = realm.transaction.getTable(TABLE_PREFIX + modelClassName);
-                for (String fieldName : fieldNames) {
-                    long columnIndex = table.getColumnIndex(fieldName);
-                    if (columnIndex == -1) {
-                        throw new RealmMigrationNeededException("Field '" + fieldName + "' not found for type '" + modelClassName + "'");
-                    }
-                    Map<String, Long> innerMap = columnIndices.get(modelClassName);
-                    if (innerMap == null) {
-                        innerMap = new HashMap<String, Long>();
-                    }
-                    innerMap.put(fieldName, columnIndex);
-                    columnIndices.put(modelClassName, innerMap);
+                    throw new RealmException("An exception was thrown in the getColumnIndices method in the generated " + generatedClassName + " class", e);
                 }
+                realm.columnIndices.addClass((Class<? extends RealmObject>) generatedClass.getSuperclass(), indices);
             }
         } finally {
             if (commitNeeded) {
@@ -1035,17 +1030,12 @@ public void writeCopyTo(File destination) throws IOException {
      * @param destination File to save the Realm to
      * @throws java.io.IOException if any write operation fails
      */
-    @Deprecated
     public void writeEncryptedCopyTo(File destination, byte[] key) throws IOException {
         if (destination == null) {
             throw new IllegalArgumentException("The destination argument cannot be null");
         }
         checkIfValid();
-        if (key != null) {
-            throw new RealmException("This method has been disabled");
-        } else {
-            transaction.writeToFile(destination, key);
-        }
+        transaction.writeToFile(destination, key);
     }
 
 
@@ -1057,8 +1047,29 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws IOExceptio
      * @throws RealmException An object could not be created
      */
     public <E extends RealmObject> E createObject(Class<E> clazz) {
-        Table table;
-        table = tables.get(clazz);
+        Table table = initTable(clazz);
+        long rowIndex = table.addEmptyRow();
+        return get(clazz, rowIndex);
+    }
+
+    /**
+     * Creates a new object inside the Realm with the Primary key value initially set.
+     * If the value violates the primary key constraint, no object will be added and a
+     * {@link RealmException} will be thrown.
+     *
+     * @param clazz The Class of the object to create
+     * @param primaryKeyValue Value for the primary key field.
+     * @return The new object
+     * @throws {@link RealmException} if object could not be created.
+     */
+    <E extends RealmObject> E createObject(Class<E> clazz, Object primaryKeyValue) {
+        Table table = initTable(clazz);
+        long rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
+        return get(clazz, rowIndex);
+    }
+
+    private <E extends RealmObject> Table initTable(Class<E> clazz) {
+        Table table = tables.get(clazz);
         if (table == null) {
             Class<?> generatedClass = getProxyClass(clazz);
 
@@ -1083,17 +1094,12 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws IOExceptio
             }
         }
 
-        long rowIndex = table.addEmptyRow();
-        return get(clazz, rowIndex);
+        return table;
     }
 
     private Class<?> getProxyClass(Class<?> clazz) {
 
-        String simpleClassName = simpleClassNames.get(clazz);
-        if (simpleClassName == null) {
-            simpleClassName = clazz.getSimpleName();
-            simpleClassNames.put(clazz, simpleClassName);
-        }
+        String simpleClassName = getClassSimpleName(clazz);
         String generatedClassName = getProxyClassName(simpleClassName);
 
         Class<?> generatedClass = generatedClasses.get(generatedClassName);
@@ -1119,12 +1125,7 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws IOExceptio
 
         Table table = tables.get(clazz);
         if (table == null) {
-            String simpleClassName = simpleClassNames.get(clazz);
-            if (simpleClassName == null) {
-                simpleClassName = clazz.getSimpleName();
-                simpleClassNames.put(clazz, simpleClassName);
-            }
-
+            String simpleClassName = getClassSimpleName(clazz);
             table = transaction.getTable(TABLE_PREFIX + simpleClassName);
             tables.put(clazz, table);
         }
@@ -1133,14 +1134,9 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws IOExceptio
 
         Constructor constructor = generatedConstructors.get(clazz);
         if (constructor == null) {
-            String simpleClassName = simpleClassNames.get(clazz);
-            if (simpleClassName == null) {
-                simpleClassName = clazz.getSimpleName();
-                simpleClassNames.put(clazz, simpleClassName);
-            }
+            String simpleClassName = getClassSimpleName(clazz);
             String generatedClassName = getProxyClassName(simpleClassName);
 
-
             Class<?> generatedClass = generatedClasses.get(generatedClassName);
             if (generatedClass == null) {
                 try {
@@ -1190,10 +1186,6 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws IOExceptio
      */
     public <E extends RealmObject> E copyToRealm(E object) {
         checkNotNullObject(object);
-        if (isObjectInRealm(object)) {
-            return object;
-        }
-
         return copyOrUpdate(object, false);
     }
 
@@ -1210,10 +1202,6 @@ public void writeEncryptedCopyTo(File destination, byte[] key) throws IOExceptio
     public <E extends RealmObject> E copyToRealmOrUpdate(E object) {
         checkNotNullObject(object);
         checkHasPrimaryKey(object);
-        if (isObjectInRealm(object)) {
-            return object;
-        }
-
         return copyOrUpdate(object, true);
     }
 
@@ -1268,12 +1256,7 @@ private static String getProxyClassName(String simpleClassName) {
     }
 
     boolean contains(Class<?> clazz) {
-        String simpleClassName = simpleClassNames.get(clazz);
-        if (simpleClassName == null) {
-            simpleClassName = clazz.getSimpleName();
-            simpleClassNames.put(clazz, simpleClassName);
-        }
-        return transaction.hasTable(TABLE_PREFIX + simpleClassName);
+        return transaction.hasTable(TABLE_PREFIX + getClassSimpleName(clazz));
     }
 
     /**
@@ -1317,8 +1300,8 @@ boolean contains(Class<?> clazz) {
         checkIfValid();
         Table table = getTable(clazz);
         TableView.Order order = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
-        Long columnIndex = columnIndices.get(simpleClassNames.get(clazz)).get(fieldName);
-        if (columnIndex == null || columnIndex < 0) {
+        long columnIndex = columnIndices.getColumnIndex(clazz, fieldName);
+        if (columnIndex < 0) {
             throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
         }
 
@@ -1631,10 +1614,6 @@ void setVersion(long version) {
         }
     }
 
-    private <E extends RealmObject> boolean isObjectInRealm(E object) {
-        return (object.realm != null && object.realm.id == this.id);
-    }
-
     private <E extends RealmObject> void checkNotNullObject(E object) {
         if (object == null) {
             throw new IllegalArgumentException("Null objects cannot be copied into Realm.");
@@ -1642,10 +1621,9 @@ void setVersion(long version) {
     }
 
     private <E extends RealmObject> void checkHasPrimaryKey(E object) {
-
         Class<? extends RealmObject> objectClass = object.getClass();
         if (!getTable(objectClass).hasPrimaryKey()) {
-            throw new IllegalArgumentException("RealmObject has no @PrimaryKey defined: " + simpleClassNames.get(objectClass));
+            throw new IllegalArgumentException("RealmObject has no @PrimaryKey defined: " + getClassSimpleName(objectClass));
         }
     }
 
@@ -1681,7 +1659,7 @@ public static synchronized void migrateRealmAtPath(String realmPath, byte[] key,
 
     /**
      * Delete the Realm file from the filesystem for the default Realm (named "default.realm").
-     * The realm must be unused and closed before calling this method.
+     * The Realm must be unused and closed before calling this method.
      * WARNING: Your Realm must not be open (typically when your app launch).
      *
      * @param context an Android {@link android.content.Context}.
@@ -1694,26 +1672,40 @@ public static boolean deleteRealmFile(Context context) {
 
     /**
      * Delete the Realm file from the filesystem for a custom named Realm.
-     * The realm must be unused and closed before calling this method.
+     * The Realm must be unused and closed before calling this method.
      *
      * @param context  an Android {@link android.content.Context}.
      * @param fileName the name of the custom Realm (i.e. "myCustomRealm.realm").
      * @return false if a file could not be deleted. The failing file will be logged.
      */
-    public static synchronized boolean deleteRealmFile(Context context, String fileName) {
+    public static boolean deleteRealmFile(Context context, String fileName) {
+        return deleteRealmFile(new File(context.getFilesDir(), fileName));
+    }
+
+    /**
+     * Delete the Realm file from the filesystem for a custom named Realm.
+     * The Realm must be unused and closed before calling this method.
+     *
+     * @param realmFile The reference to the Realm file.
+     * @return false if a file could not be deleted. The failing file will be logged.
+     */
+    public static synchronized boolean deleteRealmFile(File realmFile) {
         boolean result = true;
-        File writableFolder = context.getFilesDir();
+        File realmFolder = realmFile.getParentFile();
+        String fileName = realmFile.getName();
 
-        File realmFile = new File(writableFolder, fileName);
         int realmId = realmFile.getAbsolutePath().hashCode();
-
         AtomicInteger counter = openRealms.get(realmId);
         if (counter != null && counter.get() > 0) {
             throw new IllegalStateException("It's not allowed to delete the file associated with an open Realm. " +
                     "Remember to close() all the instances of the Realm before deleting its file.");
         }
 
-        List<File> filesToDelete = Arrays.asList(realmFile, new File(writableFolder, fileName + ".lock"));
+        List<File> filesToDelete = Arrays.asList(realmFile,
+                new File(realmFolder, fileName + ".lock"),
+                new File(realmFolder, fileName + ".lock_a"),
+                new File(realmFolder, fileName + ".lock_b"),
+                new File(realmFolder, fileName + ".log"));
         for (File fileToDelete : filesToDelete) {
             if (fileToDelete.exists()) {
                 boolean deleteResult = fileToDelete.delete();
@@ -1818,4 +1810,13 @@ static void setSchema(Class<? extends RealmObject>... schemaClass) {
     public interface Transaction {
         public void execute(Realm realm);
     }
+
+    private String getClassSimpleName(Class<?> clazz) {
+        String simpleName = simpleClassNames.get(clazz);
+        if (simpleName == null) {
+            simpleName = clazz.getSimpleName();
+            simpleClassNames.put(clazz, simpleName);
+        }
+        return simpleName;
+    }
 }
diff --git a/realm/src/main/java/io/realm/RealmQuery.java b/realm/src/main/java/io/realm/RealmQuery.java
index 1553fabfcd..d7f4f064f0 100644
--- a/realm/src/main/java/io/realm/RealmQuery.java
+++ b/realm/src/main/java/io/realm/RealmQuery.java
@@ -74,7 +74,7 @@ public RealmQuery(Realm realm, Class<E> clazz) {
         this.clazz = clazz;
         this.table = realm.getTable(clazz);
         this.query = table.where();
-        this.columns = Realm.columnIndices.get(clazz.getSimpleName());
+        this.columns = realm.columnIndices.getClassFields(clazz);
     }
 
     /**
@@ -89,7 +89,7 @@ public RealmQuery(RealmResults realmList, Class<E> clazz) {
         this.clazz = clazz;
         this.table = realm.getTable(clazz);
         this.query = realmList.getTable().where();
-        this.columns = Realm.columnIndices.get(clazz.getSimpleName());
+        this.columns = realm.columnIndices.getClassFields(clazz);
     }
 
     RealmQuery(Realm realm, LinkView view, Class<E> clazz) {
@@ -98,7 +98,7 @@ public RealmQuery(RealmResults realmList, Class<E> clazz) {
         this.query = view.where();
         this.view = view;
         this.table = realm.getTable(clazz);
-        this.columns = Realm.columnIndices.get(clazz.getSimpleName());
+        this.columns = realm.columnIndices.getClassFields(clazz);
     }
 
     private boolean containsDot(String s) {
diff --git a/realm/src/main/java/io/realm/RealmResults.java b/realm/src/main/java/io/realm/RealmResults.java
index 1f20674f73..6a9c49988e 100644
--- a/realm/src/main/java/io/realm/RealmResults.java
+++ b/realm/src/main/java/io/realm/RealmResults.java
@@ -87,7 +87,7 @@ TableOrView getTable() {
     }
 
     /**
-     * Returns a typed @{link io.realm.RealmQuery}, which can be used to query for specific
+     * Returns a typed {@link io.realm.RealmQuery}, which can be used to query for specific
      * objects of this type.
      *
      * @return A typed RealmQuery
@@ -192,7 +192,7 @@ private long getColumnIndex(String fieldName) {
     }
 
     /**
-     * Sort (ascending) an existing @{link io.realm.RealmResults}.
+     * Sort (ascending) an existing {@link io.realm.RealmResults}.
      * 
      * @param fieldName  The field name to sort by. Only fields of type boolean, short, int, long,
      *                   float, double, Date, and String are supported.
@@ -203,7 +203,7 @@ public void sort(String fieldName) {
     }
 
     /**
-     * Sort existing @{link io.realm.RealmResults}.
+     * Sort existing {@link io.realm.RealmResults}.
      *
      * @param fieldName      The field name to sort by. Only fields of type boolean, short, int,
      *                       long, float, double, Date, and String are supported.
@@ -229,7 +229,7 @@ public void sort(String fieldName, boolean sortAscending) {
     }
 
     /**
-     * Sort existing @{link io.realm.RealmResults}.
+     * Sort existing {@link io.realm.RealmResults}.
      *
      * @param fieldNames an array of field names to sort by. Only fields of type boolean, short, int,
      *                       long, float, double, Date, and String are supported.
@@ -268,7 +268,7 @@ public void sort(String fieldNames[], boolean sortAscending[]) {
 
 
     /**
-     * Sort existing {link io.realm.RealmResults} using two fields.
+     * Sort existing {@link io.realm.RealmResults} using two fields.
      *
      * @param fieldName1 first field name.
      * @param sortAscending1 sort order for first field.
@@ -281,7 +281,7 @@ public void sort(String fieldName1, boolean sortAscending1, String fieldName2, b
     }
 
     /**
-     * Sort existing {link io.realm.RealmResults} using three fields.
+     * Sort existing {@link io.realm.RealmResults} using three fields.
      *
      * @param fieldName1 first field name.
      * @param sortAscending1 sort order for first field.
diff --git a/realm/src/main/java/io/realm/internal/ColumnIndices.java b/realm/src/main/java/io/realm/internal/ColumnIndices.java
new file mode 100644
index 0000000000..759c93d350
--- /dev/null
+++ b/realm/src/main/java/io/realm/internal/ColumnIndices.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+import io.realm.RealmObject;
+
+/**
+ * Utility class used to cache the mapping between object field names and their column indices.
+ */
+public class ColumnIndices {
+
+    private Map<Class<? extends RealmObject>, Map<String, Long>> classes = new HashMap<Class<? extends RealmObject>, Map<String, Long>>();
+
+    /**
+     * Add column indices from a given model class
+     */
+    public void addClass(Class<? extends RealmObject> clazz, Map<String, Long> indicies) {
+        classes.put(clazz, indicies);
+    }
+
+    /**
+     * Return mappings for the given class or null if no mapping exists.
+     */
+    public Map<String, Long> getClassFields(Class<? extends RealmObject> clazz) {
+        return classes.get(clazz);
+    }
+
+    /**
+     * Returns the column index for a given field on a clazz or -1 if no such field exists.
+     */
+    public long getColumnIndex(Class<? extends RealmObject> clazz, String fieldName) {
+        Map<String, Long> mapping = classes.get(clazz);
+        if (mapping != null) {
+            Long index = mapping.get(fieldName);
+            return (index != null) ? index : -1;
+        } else {
+            return -1;
+        }
+    }
+}
diff --git a/realm/src/main/java/io/realm/internal/Context.java b/realm/src/main/java/io/realm/internal/Context.java
index 7884eed62f..29ccb9122b 100644
--- a/realm/src/main/java/io/realm/internal/Context.java
+++ b/realm/src/main/java/io/realm/internal/Context.java
@@ -21,7 +21,7 @@
 
 class Context {
 
-    // Each group of related TightDB objects will have a Context object in the root.
+    // Each group of related Realm objects will have a Context object in the root.
     // The root can be a table, a group, or a shared group.
     // The Context object is used to store a list of native pointers 
     // whose disposal need to be handed over from the garbage 
diff --git a/realm/src/main/java/io/realm/internal/Group.java b/realm/src/main/java/io/realm/internal/Group.java
index cb97f86f7b..20d724562c 100644
--- a/realm/src/main/java/io/realm/internal/Group.java
+++ b/realm/src/main/java/io/realm/internal/Group.java
@@ -32,7 +32,7 @@
     private final Context context;
 
     static {
-        TightDB.loadLibrary();
+        RealmCore.loadLibrary();
     }
 
     //
@@ -217,7 +217,8 @@ public Table getTable(String name) {
         }
         if (immutable) {
             if (!hasTable(name)) {
-                throwImmutable();
+                throw new IllegalStateException("Requested table is not in this Realm. " +
+                        "Creating it requires a transaction: " + name);
             }
         }
 
diff --git a/realm/src/main/java/io/realm/internal/TightDB.java b/realm/src/main/java/io/realm/internal/RealmCore.java
similarity index 89%
rename from realm/src/main/java/io/realm/internal/TightDB.java
rename to realm/src/main/java/io/realm/internal/RealmCore.java
index 71f667eb4a..6c02c63a75 100644
--- a/realm/src/main/java/io/realm/internal/TightDB.java
+++ b/realm/src/main/java/io/realm/internal/RealmCore.java
@@ -29,9 +29,9 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
- * Utility methods for TightDB.
+ * Utility methods for Realm Core.
  */
-public class TightDB {
+public class RealmCore {
 
 ///*
     private static final String FILE_SEP = File.separator;
@@ -47,11 +47,11 @@ private static String getJniFileName()
     {
         String os = System.getProperty("os.name").toLowerCase();
         if (os.indexOf("win") >= 0)
-            return "tightdb_jni32.dll or tightdb_jni64.dll";
+            return "realm_jni32.dll or realm_jni64.dll";
         if (os.indexOf("mac") >= 0)
-            return "libtightdb-jni.jnilib";
+            return "librealm-jni.jnilib";
         if (os.indexOf("nix") >= 0 || os.indexOf("nux") >= 0 || os.indexOf("sunos") >= 0)
-            return "libtightdb-jni.so";
+            return "librealm-jni.so";
         return "realm-jni";
     }
 */
@@ -117,7 +117,7 @@ public void run(){
         });
     }
 
-    private static void initTightDB() {
+    private static void init() {
         // Guarantee gc is done on JVM exit to clean up any native resources
         gcOnExit();
     }
@@ -127,19 +127,19 @@ public static void loadLibrary() {
             // only load library once
             return;
 
-        initTightDB();
+        init();
 
         String jnilib;
         if (osIsWindows()) {
             jnilib = loadLibraryWindows();
         }
         else {
-            String debug = System.getenv("TIGHTDB_JAVA_DEBUG");
+            String debug = System.getenv("REALM_JAVA_DEBUG");
             if (debug == null || debug.isEmpty()) {
-                jnilib = "tightdb-jni";
+                jnilib = "realm-jni";
             }
             else {
-                jnilib = "tightdb-jni-dbg";
+                jnilib = "realm-jni-dbg";
             }
             System.loadLibrary(jnilib);
         }
@@ -160,15 +160,15 @@ private static String loadLibraryWindows() {
 //*/
         // Load debug library first - if available
         String jnilib;
-        jnilib = loadCorrectLibrary("tightdb_jni32d", "tightdb_jni64d");
+        jnilib = loadCorrectLibrary("realm_jni32d", "realm_jni64d");
         if (jnilib != null) {
-            System.out.println("!!! TightDB debug version loaded. !!!\n");
+            System.out.println("!!! Realm debug version loaded. !!!\n");
         }
         else {
-            jnilib = loadCorrectLibrary("tightdb_jni32", "tightdb_jni64");
+            jnilib = loadCorrectLibrary("realm_jni32", "realm_jni64");
             if (jnilib == null) {
                 System.err.println("Searched java.library.path=" + System.getProperty("java.library.path"));
-                throw new RuntimeException("Couldn't load the TightDB JNI library 'tightdb_jni32.dll or tightdb_jni64.dll" +
+                throw new RuntimeException("Couldn't load the Realm JNI library 'realm_jni32.dll or realm_jni64.dll" +
                                            "'. Please include the directory to the library in java.library.path.");
             }
         }
diff --git a/realm/src/main/java/io/realm/internal/SharedGroup.java b/realm/src/main/java/io/realm/internal/SharedGroup.java
index 4ce3b4de1a..dbff0bb48a 100644
--- a/realm/src/main/java/io/realm/internal/SharedGroup.java
+++ b/realm/src/main/java/io/realm/internal/SharedGroup.java
@@ -31,7 +31,7 @@
     private final Context context;
 
     static {
-        TightDB.loadLibrary();
+        RealmCore.loadLibrary();
     }
 
     public enum Durability {
diff --git a/realm/src/main/java/io/realm/internal/SharedGroupWithReplication.java b/realm/src/main/java/io/realm/internal/SharedGroupWithReplication.java
index c4a31b43d8..176d4b2291 100644
--- a/realm/src/main/java/io/realm/internal/SharedGroupWithReplication.java
+++ b/realm/src/main/java/io/realm/internal/SharedGroupWithReplication.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-/*package com.tightdb;
+/*package io.realm.internal;
 
 public class SharedGroupWithReplication extends SharedGroup {
 
diff --git a/realm/src/main/java/io/realm/internal/Table.java b/realm/src/main/java/io/realm/internal/Table.java
index 42d28b0af7..7a0065d51d 100644
--- a/realm/src/main/java/io/realm/internal/Table.java
+++ b/realm/src/main/java/io/realm/internal/Table.java
@@ -52,7 +52,7 @@
     protected static int TableCount = 0;
 
     static {
-        TightDB.loadLibrary();
+        RealmCore.loadLibrary();
     }
 
 
@@ -364,13 +364,12 @@ public void moveLastOver(long rowIndex) {
 
     protected native void nativeMoveLastOver(long nativeTablePtr, long rowIndex);
 
-    // Row Handling methods.
     public long addEmptyRow() {
         checkImmutable();
         if (hasPrimaryKey()) {
             long primaryKeyColumnIndex = getPrimaryKey();
             ColumnType type = getColumnType(primaryKeyColumnIndex);
-            switch(type) {
+            switch (type) {
                 case STRING:
                     if (findFirstString(primaryKeyColumnIndex, STRING_DEFAULT_VALUE) != NO_MATCH) {
                         throwDuplicatePrimaryKeyException(STRING_DEFAULT_VALUE);
@@ -390,6 +389,51 @@ public long addEmptyRow() {
         return nativeAddEmptyRow(nativePtr, 1);
     }
 
+    public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
+        checkImmutable();
+        checkHasPrimaryKey();
+        
+        long primaryKeyColumnIndex = getPrimaryKey();
+        ColumnType type = getColumnType(primaryKeyColumnIndex);
+        long rowIndex;
+        Row row;
+
+        // Add with primary key initially set
+        switch (type) {
+            case STRING:
+                if (!(primaryKeyValue instanceof String)) {
+                    throw new IllegalArgumentException("Primary key value is not a String: " + primaryKeyValue);
+                }
+                if (findFirstString(primaryKeyColumnIndex, (String)primaryKeyValue) != NO_MATCH) {
+                    throwDuplicatePrimaryKeyException(primaryKeyValue);
+                }
+                rowIndex = nativeAddEmptyRow(nativePtr, 1);
+                row = getRow(rowIndex);
+                row.setString(primaryKeyColumnIndex, (String) primaryKeyValue);
+                break;
+
+            case INTEGER:
+                long pkValue;
+                try {
+                    pkValue = new Long(primaryKeyValue.toString());
+                } catch (RuntimeException e) {
+                    throw new IllegalArgumentException("Primary key value is not a long: " + primaryKeyValue);
+                }
+                if (findFirstLong(primaryKeyColumnIndex, pkValue) != NO_MATCH) {
+                    throwDuplicatePrimaryKeyException(pkValue);
+                }
+                rowIndex = nativeAddEmptyRow(nativePtr, 1);
+                row = getRow(rowIndex);
+                row.setLong(primaryKeyColumnIndex, pkValue);
+                break;
+
+            default:
+                throw new RealmException("Cannot check for duplicate rows for unsupported primary key type: " + type);
+        }
+
+        return rowIndex;
+    }
+
     public long addEmptyRows(long rows) {
         checkImmutable();
         if (rows < 1) {
@@ -1202,6 +1246,12 @@ void checkImmutable() {
         }
     }
 
+    private void checkHasPrimaryKey() {
+        if (!hasPrimaryKey()) {
+            throw new IllegalStateException(getName() + " has no primary key defined");
+        }
+    }
+
     //
     // Aggregate functions
     //
diff --git a/realm/src/main/java/io/realm/internal/TableView.java b/realm/src/main/java/io/realm/internal/TableView.java
index f332007a2d..da409689b9 100644
--- a/realm/src/main/java/io/realm/internal/TableView.java
+++ b/realm/src/main/java/io/realm/internal/TableView.java
@@ -49,7 +49,7 @@
  *      byte[] imageData;
  *  }
  *
- * Once this class is compiled along with TightDB annotation processor
+ * Once this class is compiled along with Realm annotation processor
  * this will produce following classes.
  *
  * 1. Employee
diff --git a/realm/src/main/java/io/realm/internal/Util.java b/realm/src/main/java/io/realm/internal/Util.java
index e7c0b8dac4..3e0110f75b 100644
--- a/realm/src/main/java/io/realm/internal/Util.java
+++ b/realm/src/main/java/io/realm/internal/Util.java
@@ -21,7 +21,7 @@
 public class Util {
 
     static {
-        TightDB.loadLibrary();
+        RealmCore.loadLibrary();
     }
 
     public static long getNativeMemUsage() {
diff --git a/version.txt b/version.txt
index 6e403b1991..525aef9080 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-0.79.2-SNAPSHOT
\ No newline at end of file
+0.80.1-SNAPSHOT
\ No newline at end of file
