diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
index 4d223c132d..94718dbc2f 100644
--- a/.github/ISSUE_TEMPLATE.md
+++ b/.github/ISSUE_TEMPLATE.md
@@ -1,14 +1,15 @@
-> We LOVE to help with any issues or bug you have!
+<!---
 
-> **Questions**: If you have questions about how to use Realm, please ask on [SO](http://stackoverflow.com/questions/ask?tags=realm) - we monitor the Realm tag.
+**Questions**: If you have questions about how to use Realm, ask on
+[StackOverflow](http://stackoverflow.com/questions/ask?tags=realm).
+We monitor the `realm` tag.
 
-> **Feature Request**: Just fill in the first two sections below.
+**Feature Request**: Just fill in the first two sections below.
 
-> **Bugs**: To help you as fast as possible with an issue or bug please describe your issue and the steps you have taken to reproduce it in as many details as possible.
->
-> Thanks for helping us help you :-)
->
-> Remove this and above before submitting.
+**Bugs**: To help you as fast as possible with an issue please describe your issue
+and the steps you have taken to reproduce it in as many details as possible.
+
+-->
 
 #### Goal
 
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 2d12cd03c7..9c40fefa54 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,314 @@
+## 4.1.1 (2017-10-27)
+
+### Breaking Changes
+
+### Enhancements
+
+### Bug Fixes
+
+* Fixed the compile warnings of using deprecated method `RealmProxyMediator.getTableName()` in generated mediator classes (#5455).
+* [ObjectServer] now retrying network query when encountering any `IOException` (#5453).
+* Fixed a `NoClassDefFoundError` due to using `@SafeVarargs` below API 19 (#5463).
+
+### Internal
+
+* Updated Realm Sync to 2.1.0
+
+### Credits
+
+
+## 4.1.0 (2017-10-20)
+
+## Enhancements
+
+* `Realm.deleteRealm()` and `RealmConfiguration.assetFile()` are multi-processes safe now.
+
+## Bug Fixes
+
+* Fix some potential database corruption caused by deleting the Realm file while a Realm instance are still opened in another process or the sync client thread.
+* Added `realm.ignoreKotlinNullability` as a kapt argument to disable treating kotlin non-null types as `@Required` (#5412) (introduced in `v3.6.0`).
+* Increased http connect/write timeout for low bandwidth network.
+
+
+## 4.0.0 (2017-10-16)
+
+## Breaking Changes
+
+The internal file format has been upgraded. Opening an older Realm will upgrade the file automatically, but older versions of Realm will no longer be able to read the file.
+
+* [ObjectServer] Updated protocol version to 22 which is only compatible with Realm Object Server >= 2.0.0.
+* [ObjectServer] Removed deprecated APIs `SyncUser.retrieveUser()` and `SyncUser.retrieveUserAsync()`. Use `SyncUser.retrieveInfoForUser()` and `retrieveInfoForUserAsync()` instead.
+* [ObjectServer] `SyncUser.Callback` now accepts a generic parameter indicating type of object returned when `onSuccess` is called.
+* [ObjectServer] Renamed `SyncUser.getAccessToken` to `SyncUser.getRefreshToken`.
+* [ObjectServer] Removed deprecated API `SyncUser.getManagementRealm()`.
+* Calling `distinct()` on a sorted `RealmResults` no longer clears any sorting defined (#3503).
+* Relaxed upper bound of type parameter of `RealmList`, `RealmQuery`, `RealmResults`, `RealmCollection`, `OrderedRealmCollection` and `OrderedRealmCollectionSnapshot`.
+* Realm has upgraded its RxJava1 support to RxJava2 (#3497)
+  * `Realm.asObservable()` has been renamed to `Realm.asFlowable()`.
+  * `RealmList.asObservable()` has been renamed to `RealmList.asFlowable()`.
+  * `RealmResults.asObservable()` has been renamed to `RealmResults.asFlowable()`.
+  * `RealmObject.asObservable()` has been renamed to `RealmObject.asFlowable()`.
+  * `RxObservableFactory` now return RxJava2 types instead of RxJava1 types.
+* Removed deprecated APIs `RealmSchema.close()` and `RealmObjectSchema.close()`. Those don't have to be called anymore.
+* Removed deprecated API `RealmResults.removeChangeListeners()`. Use `RealmResults.removeAllChangeListeners()` instead.
+* Removed deprecated API `RealmObject.removeChangeListeners()`. Use `RealmObject.removeAllChangeListeners()` instead.
+* Removed `UNSUPPORTED_TABLE`, `UNSUPPORTED_MIXED` and `UNSUPPORTED_DATE` from `RealmFieldType`.
+* Removed deprecated API `RealmResults.distinct()`/`RealmResults.distinctAsync()`. Use `RealmQuery.distinct()`/`RealmQuery.distinctAsync()` instead.
+* `RealmQuery.createQuery(Realm, Class)`, `RealmQuery.createDynamicQuery(DynamicRealm, String)`, `RealmQuery.createQueryFromResult(RealmResults)` and `RealmQuery.createQueryFromList(RealmList)` have been removed. Use `Realm.where(Class)`, `DynamicRealm.where(String)`, `RealmResults.where()` and `RealmList.where()` instead.
+
+## Enhancements
+
+* [ObjectServer] `SyncUserInfo` now also exposes a users metadata using `SyncUserInfo.getMetadata()`
+* `RealmList` can now contain `String`, `byte[]`, `Boolean`, `Long`, `Integer`, `Short`, `Byte`, `Double`, `Float` and `Date` values. [Queries](https://github.com/realm/realm-java/issues/5361) and [Importing primitive lists from JSON](https://github.com/realm/realm-java/issues/5361) are not supported yet.
+* Added support for lists of primitives in `RealmObjectSchema` with `addRealmListField(String fieldName, Class<?> primitiveType)`
+* Added support for lists of primitives in `DynamicRealmObject` with `setList(String fieldName, RealmList<?> list)` and `getList(String fieldName, Class<?> primitiveType)`.
+* Minor performance improvement when copy/insert objects into Realm.
+* Added `static RealmObject.getRealm(RealmModel)`, `RealmObject.getRealm()` and `DynamicRealmObject.getDynamicRealm()` (#4720).
+* Added `RealmResults.asChangesetObservable()` that emits the pair `(results, changeset)` (#4277).
+* Added `RealmList.asChangesetObservable()` that emits the pair `(list, changeset)` (#4277).
+* Added `RealmObject.asChangesetObservable()` that emits the pair `(object, changeset)` (#4277).
+* All Realm annotations are now kept at runtime, allowing runtime tools access to them (#5344).
+* Speedup schema initialization when a Realm file is first accessed (#5391).
+
+## Bug Fixes
+
+* [ObjectServer] Exposing a `RealmConfiguration` that allows a user to open the backup Realm after the client reset (#4759/#5223).
+* [ObjectServer] Realm no longer throws a native “unsupported instruction” exception in some cases when opening a synced Realm asynchronously (https://github.com/realm/realm-object-store/issues/502).
+* [ObjectServer] Fixed "Cannot open the read only Realm" issue when get`PermissionManager` (#5414).
+* Throw `IllegalArgumentException` instead of `IllegalStateException` when calling string/binary data setters if the data length exceeds the limit.
+* Added support for ISO8601 2-digit time zone designators (#5309).
+* "Bad File Header" caused by the device running out of space while compacting the Realm (#5011).
+* `RealmQuery.equalTo()` failed to find null values on an indexed field if using Case.INSENSITIVE (#5299).
+* Assigning a managed object's own list to itself would accidentally clear it (#5395).
+* Don't try to acquire `ApplicationContext` if not available in `Realm.init(Context)` (#5389).
+* Removing and re-adding a changelistener from inside a changelistener sometimes caused notifications to be missed (#5411).
+
+## Internal
+
+* Upgraded to Realm Sync 2.0.2.
+* Upgraded to Realm Core 4.0.2.
+* Upgraded to OkHttp 3.9.0.
+* Upgraded to RxJava 2.1.4.
+* Use Object Store to create the primary key table.
+
+### Credits
+
+Thanks to @JussiPekonen for adding support for 2-digit time zone designators when importing JSON (#5309).
+
+
+## 3.7.2 (2017-09-12)
+
+### Bug Fixes
+
+* Fixed a JNI memory issue when doing queries which might potentially cause various native crashes.
+* Fixed a bug that `RealmList.deleteFromRealm(int)`, `RealmList.deleteFirstFromRealm()` and `RealmList.deleteLastFromRealm()` did not remove target objects from Realm. This bug was introduced in `3.7.1` (#5233).
+* Crash with "'xxx' doesn't exist in current schema." when ProGuard is enabled (#5211).
+
+
+## 3.7.1 (2017-09-07)
+
+### Bug Fixes
+
+* Fixed potential memory leaks of `LinkView` when calling bulk insertions APIs.
+* Fixed possible assertion when using `PermissionManager` at the beginning (#5195).
+* Crash caused by JNI couldn't find `SharedRealm`'s inner classes when ProGuard is enabled (#5211).
+
+### Internal
+
+* Replaced LinkView with Object Store's List.
+* Renaming `io.realm.internal.CollectionChangeSet` to `io.realm.internal.OsCollectionChangeSet`.
+
+
+## 3.7.0 (2017-09-01)
+
+### Deprecated
+
+* [ObjectServer] `SyncUser.getManagementRealm()`. Use `SyncUser.getPermissionManager()` instead.
+
+### Enhancements
+
+* [ObjectServer] `SyncUser.getPermissionManager` added as a helper API for working with permissions and permission offers.
+
+### Internal
+
+* [ObjectServer] Upgraded OkHttp to 3.7.0.
+
+
+## 3.6.0 (2017-09-01)
+
+### Breaking Changes
+
+* [ObjectServer] `SyncUser.logout()` no longer throws an exception when associated Realms instances are not closed (#4962).
+
+### Deprecated
+
+* [ObjectServer] `SyncUser#retrieveUser` and `SyncUser#retrieveUserAsync` replaced by `SyncUser#retrieveInfoForUser`
+and `SyncUser#retrieveInfoForUserAsync` which returns a `SyncUserInfo` with mode information (#5008).
+* [ObjectServer] `SyncUser#Callback` replaced by the generic version `SyncUser#RequestCallback<T>`.
+
+### Enhancements
+
+* [ObjectServer] Added `SyncSession.uploadAllLocalChanges()`.
+* [ObjectServer] APIs of `UserStore` have been changed to support same user identity but different authentication server scenario.
+* [ObjectServer] Added `SyncUser.allSessions` to retrieve the all valid sessions belonging to the user (#4783).
+* Added `Nullable` annotation to methods that may return `null` in order to improve Kotlin usability. This also introduced a dependency to `com.google.code.findbugs:jsr305`.
+* `org.jetbrains.annotations.NotNull` is now an alias for `@Required`. This means that the Realm Schema now fully understand Kotlin non-null types.
+* Added support for new data type `MutableRealmIntegers`. The new type behaves almost exactly as a reference to a Long (mutable nullable, etc) but supports `increment` and `decrement` methods, which implement a Conflict Free Replicated Data Type, whose value will converge even when changed across distributed devices with poor connections (#4266).
+* Added more detailed exception message for `RealmMigrationNeeded`.
+* Bumping schema version only without any actual schema changes will just succeed even when the migration block is not supplied. It threw an `RealmMigrationNeededException` before in the same case.
+* Throw `IllegalStateException` when schema validation fails because of wrong declaration of `@LinkingObjects`.
+
+### Bug Fixes
+
+* Potential crash after using `Realm.getSchema()` to change the schema of a typed Realm. `Realm.getSchema()` now returns an immutable `RealmSchema` instance.
+* `Realm.copyToRealmOrUpdate()` could cause a `RealmList` field to contain duplicated elements (#4957).
+* `RealmSchema.create(String)` and `RealmObjectSchema.setClassName(String)` did not accept class name whose length was 51 to 57.
+* Workaround for an Android JVM crash when using `compactOnLaunch()` (#4964).
+* Class name in exception message from link query is wrong (#5096).
+* The `compactOnLaunch` callback is no longer invoked if the Realm at that path is already open on other threads.
+
+### Internal
+
+* [ObjectServer] removed `ObjectServerUser` and its inner classes, in a step to reduce `SyncUser` complexity (#3741).
+* [ObjectServer] changed the `SyncSessionStopPolicy` to `AfterChangesUploaded` to align with other binding and to prevent use cases where the Realm might be deleted before the last changes get synchronized (#5028).
+* Upgraded Realm Sync to 1.10.8
+* Let Object Store handle migration.
+
+
+## 3.5.0 (2017-07-11)
+
+### Enhancements
+
+* Added `RealmConfiguration.Builder.compactOnLaunch()` to compact the file on launch (#3739).
+* [ObjectServer] Adding user lookup API for administrators (#4828).
+* An `IllegalStateException` will be thrown if the given `RealmModule` doesn't include all required model classes (#3398).
+
+### Bug Fixes
+
+* Bug in `isNull()`, `isNotNull()`, `isEmpty()`, and `isNotEmpty()` when queries involve nullable fields in link queries (#4856).
+* Bug in how to resolve field names when querying `@LinkingObjects` as the last field (#4864).
+* Rare crash in `RealmLog` when log level was set to `LogLevel.DEBUG`.
+* Broken case insensitive query with indexed field (#4788).
+* [ObjectServer] Bug related to the behaviour of `SyncUser#logout` and the use of invalid `SyncUser` with `SyncConfiguration` (#4822).
+* [ObjectServer] Not all error codes from the server were recognized correctly, resulting in UNKNOWN being reported instead.
+* [ObjectServer] Prevent the use of a `SyncUser` that explicitly logged out, to open a Realm (#4975).
+
+### Internal
+
+* Use Object Store to do table initialization.
+* Removed `Table#Table()`, `Table#addEmptyRow()`, `Table#addEmptyRows()`, `Table#add(Object...)`, `Table#pivot(long,long,PivotType)` and `Table#createnative()`.
+* Upgraded Realm Core to 2.8.6
+* Upgraded Realm Sync to 1.10.5
+* Removed `io.realm.internal.OutOfMemoryError`. `java.lang.OutOfMemoryError` will be thrown instead.
+
+
+## 3.4.0 (2017-06-22)
+
+### Breaking Changes
+
+* [ObjectServer] Updated protocol version to 18 which is only compatible with ROS > 1.6.0.
+
+### Deprecated
+
+* `RealmSchema.close()` and `RealmObjectSchema.close()`. They don't need to be closed manually. They were added to the public API by mistake.
+
+### Enhancements
+
+* [ObjectServer] Added support for Sync Progress Notifications through `SyncSession.addDownloadProgressListener(ProgressMode, ProgressListener)` and `SyncSession.addUploadProgressListener(ProgressMode, ProgressListener)` (#4104).
+* [ObjectServer] Added `SyncSession.getState()` (#4784).
+* Added support for querying inverse relationships (#2904).
+* Moved inverse relationships out of beta stage.
+* Added `Realm.getDefaultConfiguration()` (#4725).
+
+### Bug Fixes
+
+* [ObjectServer] Bug which may crash when the JNI local reference limitation was reached on sync client thread.
+* [ObjectServer] Retrying connections with exponential backoff, when encountering `ConnectException` (#4310).
+* When converting nullable BLOB field to required, `null` values should be converted to `byte[0]` instead of `byte[1]`.
+* Bug which may cause duplicated primary key values when migrating a nullable primary key field to not nullable. `RealmObjectSchema.setRequired()` and `RealmObjectSchema.setNullable()` will throw when converting a nullable primary key field with null values stored to a required primary key field.
+
+### Internal
+
+* Upgraded to Realm Sync 1.10.1
+* Upgraded to Realm Core 2.8.4
+
+### Credits
+
+* Thanks to Anis Ben Nsir (@abennsir) for upgrading Roboelectric in the unitTestExample (#4698).
+
+
+## 3.3.2 (2017-06-09)
+
+### Bug Fixes
+
+* [ObjectServer] Crash when an authentication error happens (#4726).
+* [ObjectServer] Enabled encryption with Sync (#4561).
+* [ObjectServer] Admin users did not connect correctly to the server (#4750).
+
+### Internal
+
+* Factor out internal interface ManagedObject.
+
+## 3.3.1 (2017-05-26)
+
+### Bug Fixes
+
+* [ObjectServer] Accepted extra columns against synced Realm (#4706).
+
+
+## 3.3.0 (2017-05-24)
+
+### Enhancements
+
+* [ObjectServer] Added two options to `SyncConfiguration` to provide a trusted root CA `trustedRootCA` and to disable SSL validation `disableSSLVerification` (#4371).
+* [ObjectServer] Added support for changing passwords through `SyncUser.changePassword()` using an admin user (#4588).
+
+### Bug Fixes
+
+* Queries on proguarded Realm model classes, failed with "Table not found" (#4673).
+
+
+## 3.2.1 (2017-05-19)
+
+### Enhancements
+
+* Not in transaction illegal state exception message changed to "Cannot modify managed objects outside of a write transaction.".
+
+### Bug Fixes
+
+* [ObjectServer] `schemaVersion` was mistakenly required in order to trigger migrations (#4658).
+* [ObjectServer] Fields removed from model classes will now correctly be hidden instead of throwing an exception when opening the Realm (#4658).
+* Random crashes which were caused by a race condition in encrypted Realm (#4343).
+
+### Internal
+
+* Upgraded to Realm Sync 1.8.5.
+* Upgraded to Realm Core 2.8.0.
+
+## 3.2.0 (2017-05-16)
+
+### Enhancements
+
+* [ObjectServer] Added support for `SyncUser.isAdmin()` (#4353).
+* [ObjectServer] New set of Permission API's have been added to `SyncUser` through `SyncUser.getPermissionManager()` (#4296).
+* [ObjectServer] Added support for changing passwords through `SyncUser.changePassword()` (#4423).
+* [ObjectServer] Added support for `SyncConfiguration.Builder.waitForInitialRemoteData()` (#4270).
+* Transient fields are now allowed in model classes, but are implicitly treated as having the `@Ignore` annotation (#4279).
+* Added `Realm.refresh()` and `DynamicRealm.refresh()` (#3476).
+* Added `Realm.getInstanceAsync()` and `DynamicRealm.getInstanceAsync()` (#2299).
+* Added `DynamicRealmObject#linkingObjects(String,String)` to support linking objects on `DynamicRealm` (#4492).
+* Added support for read only Realms using `RealmConfiguration.Builder.readOnly()` and `SyncConfiguration.Builder.readOnly()`(#1147).
+* Change listeners will now auto-expand variable names to be more descriptive when using Android Studio.
+* The `toString()` methods for the standard and dynamic proxies now print "proxy", or "dynamic" before the left bracket enclosing the data.
+
+### Bug Fixes
+
+* `@LinkingObjects` annotation now also works with Kotlin (#4611).
+
+### Internal
+
+* Use separated locks for different `RealmCache`s (#4551).
+
 ## 3.1.4 (2017-05-04)
 
 ## Bug fixes
@@ -71,7 +382,7 @@
 
 * Crash with `LogicError` with `Bad version number` on notifier thread (#4369).
 * `Realm.migrateRealm(RealmConfiguration)` now fails correctly with an `IllegalArgumentException` if a `SyncConfiguration` is provided (#4075).
-* Fixed a potential cause for Realm file corruptions (never reported).
+* Potential cause for Realm file corruptions (never reported).
 * Add `@Override` annotation to proxy class accessors and stop using raw type in proxy classes in order to remove warnings from javac (#4329).
 * `findFirstAsync()` now returns an invalid object if there is no object matches the query condition instead of running the query repeatedly until it can find one (#4352).
 * [ObjectServer] Changing the log level after starting a session now works correctly (#4337).
@@ -577,7 +888,7 @@ No changes since 0.91.1.
 
 ### Breaking changes
 
-* @PrimaryKey field value can now be null for String, Byte, Short, Integer, and Long types. Older Realms should be migrated, using RealmObjectSchema.setNullable(), or by adding the @Required annotation. (#2515).
+* @PrimaryKey field value can now be null for String, Byte, Short, Integer, and Long types. Older Realms should be migrated, using RealmObjectSchema.setNullable(), or by adding the @Required annotation (#2515).
 * `RealmResults.clear()` now throws UnsupportedOperationException. Use `RealmResults.deleteAllFromRealm()` instead.
 * `RealmResults.remove(int)` now throws UnsupportedOperationException. Use `RealmResults.deleteFromRealm(int)` instead.
 * `RealmResults.sort()` and `RealmList.sort()` now return the sorted result instead of sorting in-place.
@@ -619,7 +930,7 @@ No changes since 0.91.1.
 ### Bug fixes
 
 * Field annotated with @Ignored should not have accessors generated by the bytecode transformer (#2478).
-* RealmResults and RealmObjects can no longer accidentially be GC'ed if using `asObservable()`. Previously this caused the observable to stop emitting. (#2485).
+* RealmResults and RealmObjects can no longer accidentially be GC'ed if using `asObservable()`. Previously this caused the observable to stop emitting (#2485).
 * Fixed an build issue when using Realm in library projects on Windows (#2484).
 * Custom equals(), toString() and hashCode() are no longer incorrectly overwritten by the proxy class (#2545).
 
@@ -728,7 +1039,7 @@ No changes since 0.91.1.
 * Updated Realm Core to 0.95.6
   - Fixed a bug where an async query can be copied incomplete in rare cases (#1717).
 * Fixed potential memory leak when using async query.
-* Added a check to prevent removing a RealmChangeListener from a non-Looper thread (#1962). (Thank you @hohnamkung)
+* Added a check to prevent removing a RealmChangeListener from a non-Looper thread (#1962). (Thank you @hohnamkung.)
 
 ## 0.87.0 (2015-12-17)
 * Added Realm.asObservable(), RealmResults.asObservable(), RealmObject.asObservable(), DynamicRealm.asObservable() and DynamicRealmObject.asObservable().
@@ -778,7 +1089,7 @@ No changes since 0.91.1.
 * Added Realm.isEmpty().
 * Setters in managed object for RealmObject and RealmList now throw IllegalArgumentException if the value contains an invalid (unmanaged, removed, closed, from different Realm) object (#1749).
 * Attempting to refresh a Realm while a transaction is in process will now throw an IllegalStateException (#1712).
-* The Realm AAR now also contains the ProGuard configuration (#1767). (Thank you @skyisle)
+* The Realm AAR now also contains the ProGuard configuration (#1767). (Thank you @skyisle.)
 * Updated Realm Core to 0.95.
   - Removed reliance on POSIX signals when using encryption.
 
@@ -800,7 +1111,7 @@ No changes since 0.91.1.
 
 ## 0.84.0 (2015-10-22)
 * Added support for async queries and transactions.
-* Added support for parsing JSON Dates with timezone information. (Thank you @LateralKevin)
+* Added support for parsing JSON Dates with timezone information. (Thank you @LateralKevin.)
 * Added RealmQuery.isEmpty().
 * Added Realm.isClosed() method.
 * Added Realm.distinct() method.
@@ -872,7 +1183,7 @@ No changes since 0.91.1.
 * Deprecated Realm.deleteFile(). It has been replaced by Realm.deleteRealm(RealmConfiguration).
 * Deprecated Realm.compactFile(). It has been replaced by Realm.compactRealm(RealmConfiguration).
 * RealmList.add(), RealmList.addAt() and RealmList.set() now copy unmanaged objects transparently into Realm.
-* Realm now works with Kotlin (M12+). (Thank you @cypressious)
+* Realm now works with Kotlin (M12+). (Thank you @cypressious.)
 * Fixed a performance regression introduced in 0.80.3 occurring during the validation of the Realm schema.
 * Added a check to give a better error message when null is used as value for a primary key.
 * Fixed unchecked cast warnings when building with Realm.
@@ -886,7 +1197,7 @@ No changes since 0.91.1.
 * RealmChangedListener now also gets called on the same thread that did the commit.
 * Fixed bug where Realm.createOrUpdateWithJson() reset Date and Binary data to default values if not found in the JSON output.
 * Fixed a memory leak when using RealmBaseAdapter.
-* RealmBaseAdapter now allow RealmResults to be null. (Thanks @zaki50)
+* RealmBaseAdapter now allow RealmResults to be null. (Thanks @zaki50.)
 * Fixed a bug where a change to a model class (`RealmList<A>` to `RealmList<B>`) would not throw a RealmMigrationNeededException.
 * Fixed a bug where setting multiple RealmLists didn't remove the previously added objects.
 * Solved ConcurrentModificationException thrown when addChangeListener/removeChangeListener got called in the onChange. (Thanks @beeender)
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 88db58a2b6..d3a859633f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -33,6 +33,16 @@ While we havn't described our code style yet, please just follow the existing st
 
 For source code written in C++, we format it using `clang-format`. You can use the [plugin](https://plugins.jetbrains.com/plugin/8396-clangformatij): mark the entire file and right-click to execute `clang-format` before committing any changes. Of course, if you don't use Android Studio to edit C++ code, run `clang-format` on the command-line.
 
+### Nullability by Annotataion
+
+To improve code quality and usability in Kotlin, nullability of parameters and return types must be annotated with JSR305 annotations.
+
+If a parameter is nullable, you must add `@Nullable` annotation to the parameter. On the other hand, if a parameter is non-null, you don't need to add `@Nonnull` annotation since all parameters are treated as `@Nonnull` by default.
+
+For return types, there is no default nullability. If a method can return `null` as a return value, you must add `@Nullable` annotation to the return type. Currently, `Nonnull` annotation is not mandatory if the method never return `null`.
+
+When you add a new package, you must add `package-info.java` and add `@javax.annotation.ParametersAreNonnullByDefault` to the package. Please note that you can't add multiple `package-info.java` in the same package but different location (for example, main and androidTest). When you add a package to both main and androidTest, you only need to add `package-info.java` to main.
+
 ### Unit Tests
 
 All PR's must be accompanied by related unit tests. All bug fixes must have a unit test proving that the bug is fixed.
diff --git a/Dockerfile b/Dockerfile
index 450ccf5cff..e2c50e9865 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,7 +1,7 @@
 FROM ubuntu:16.04
 
 # Locales
-RUN locale-gen en_US.UTF-8
+RUN apt-get clean && apt-get -y update && apt-get install -y locales && locale-gen en_US.UTF-8
 ENV LANG "en_US.UTF-8"
 ENV LANGUAGE "en_US.UTF-8"
 ENV LC_ALL "en_US.UTF-8"
@@ -12,10 +12,9 @@ ENV ANDROID_HOME /opt/android-sdk-linux
 # Need by cmake
 ENV ANDROID_NDK_HOME /opt/android-ndk
 ENV ANDROID_NDK /opt/android-ndk
-ENV PATH ${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
+ENV PATH ${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/tools/bin:${ANDROID_HOME}/platform-tools
 ENV PATH ${PATH}:${NDK_HOME}
 ENV NDK_CCACHE /usr/bin/ccache
-ENV NDK_LCACHE /usr/bin/lcache
 
 # The 32 bit binaries because aapt requires it
 # `file` is need by the script that creates NDK toolchains
@@ -42,20 +41,21 @@ RUN DEBIAN_FRONTEND=noninteractive dpkg --add-architecture i386 \
 
 # Install the Android SDK
 RUN cd /opt && \
-    wget -q https://dl.google.com/android/repository/tools_r25.1.7-linux.zip -O android-tools-linux.zip && \
+    wget -q https://dl.google.com/android/repository/sdk-tools-linux-3859397.zip -O android-tools-linux.zip && \
     unzip android-tools-linux.zip -d ${ANDROID_HOME} && \
     rm -f android-tools-linux.zip
 
 # Grab what's needed in the SDK
-# ↓ updates tools to at least 25.1.7, but that prints 'Nothing was installed' (so I don't check the outputs).
 RUN mkdir "${ANDROID_HOME}/licenses" && \
-    echo -e "\n8933bad161af4178b1185d1a37fbf41ea5269c55" > "${ANDROID_HOME}/licenses/android-sdk-license" && \
-    echo -en "\nd23d63a1f23e25e2c7a316e29eb60396e7924281" > "${ANDROID_HOME}/licenses/android-sdk-preview-license"
-RUN echo y | android update sdk --no-ui --all --filter tools > /dev/null
-RUN echo y | android update sdk --no-ui --all --filter platform-tools | grep 'package installed'
-RUN echo y | android update sdk --no-ui --all --filter build-tools-25.0.3 | grep 'package installed'
-RUN echo y | android update sdk --no-ui --all --filter extra-android-m2repository | grep 'package installed'
-RUN echo y | android update sdk --no-ui --all --filter android-25 | grep 'package installed'
+    echo -e "\n8933bad161af4178b1185d1a37fbf41ea5269c55" > "${ANDROID_HOME}/licenses/android-sdk-license"
+RUN sdkmanager --update
+# Accept all licenses
+RUN yes y | sdkmanager --licenses
+RUN sdkmanager 'platform-tools'
+RUN sdkmanager 'build-tools;26.0.2'
+RUN sdkmanager 'extras;android;m2repository'
+RUN sdkmanager 'platforms;android-26'
+RUN sdkmanager 'cmake;3.6.4111459'
 
 # Install the NDK
 RUN mkdir /opt/android-ndk-tmp && \
@@ -67,17 +67,5 @@ RUN mkdir /opt/android-ndk-tmp && \
     rm -rf /opt/android-ndk-tmp && \
     chmod -R a+rX /opt/android-ndk
 
-# Install cmake
-RUN mkdir /opt/cmake-tmp && \
-    cd /opt/cmake-tmp && \
-    wget -q https://dl.google.com/android/repository/cmake-3.6.3155560-linux-x86_64.zip -O cmake-linux.zip && \
-    mkdir -p ${ANDROID_HOME}/cmake/3.6.3155560 && \
-    unzip cmake-linux.zip -d ${ANDROID_HOME}/cmake/3.6.3155560 && \
-    rm -rf /opt/cmake-tmp
-
 # Make the SDK universally writable
 RUN chmod -R a+rwX ${ANDROID_HOME}
-
-# Install lcache
-RUN wget -q https://github.com/beeender/lcache/releases/download/v0.0.2/lcache-linux -O /usr/bin/lcache && \
-    chmod +x /usr/bin/lcache
diff --git a/Jenkinsfile b/Jenkinsfile
index f8d9f2dccd..a5b2845569 100644
--- a/Jenkinsfile
+++ b/Jenkinsfile
@@ -6,107 +6,120 @@ def buildSuccess = false
 def rosContainer
 try {
   node('android') {
-    timeout(time: 1, unit: 'HOURS') {
+    timeout(time: 90, unit: 'MINUTES') {
       // Allocate a custom workspace to avoid having % in the path (it breaks ld)
       ws('/tmp/realm-java') {
-	stage('SCM') {
-	  checkout([
-		     $class: 'GitSCM',
-		    branches: scm.branches,
-		    gitTool: 'native git',
-		    extensions: scm.extensions + [
-		      [$class: 'CleanCheckout'],
-		      [$class: 'SubmoduleOption', recursiveSubmodules: true]
-		    ],
-		    userRemoteConfigs: scm.userRemoteConfigs
-		   ])
-	}
-
-	def buildEnv
-	def rosEnv
-	stage('Docker build') {
-	  // Docker image for build
-	  buildEnv = docker.build 'realm-java:snapshot'
-	  // Docker image for testing Realm Object Server
-	  def dependProperties = readProperties file: 'dependencies.list'
-	  def rosDeVersion = dependProperties["REALM_OBJECT_SERVER_DE_VERSION"]
-	  rosEnv = docker.build 'ros:snapshot', "--build-arg ROS_DE_VERSION=${rosDeVersion} tools/sync_test_server"
-	}
-
-	rosContainer = rosEnv.run('-v /tmp=/tmp/.ros')
-
-	try {
-          buildEnv.inside("-e HOME=/tmp " +
-			  "-e _JAVA_OPTIONS=-Duser.home=/tmp " +
-			  "--privileged " +
-			  "-v /dev/bus/usb:/dev/bus/usb " +
-			  "-v ${env.HOME}/gradle-cache:/tmp/.gradle " +
-			  "-v ${env.HOME}/.android:/tmp/.android " +
-			  "-v ${env.HOME}/ccache:/tmp/.ccache " +
-			  "-v ${env.HOME}/lcache:/tmp/.lcache " +
-			  "--network container:${rosContainer.id}") {
-            stage('JVM tests') {
-              try {
-                withCredentials([[$class: 'FileBinding', credentialsId: 'c0cc8f9e-c3f1-4e22-b22f-6568392e26ae', variable: 'S3CFG']]) {
-                  sh "chmod +x gradlew && ./gradlew assemble check javadoc -Ps3cfg=${env.S3CFG}"
+        stage('SCM') {
+          checkout([
+                 $class: 'GitSCM',
+                branches: scm.branches,
+                gitTool: 'native git',
+                extensions: scm.extensions + [
+                  [$class: 'CleanCheckout'],
+                  [$class: 'SubmoduleOption', recursiveSubmodules: true]
+                ],
+                userRemoteConfigs: scm.userRemoteConfigs
+               ])
+        }
+
+        // Toggles for PR vs. Master builds.
+        // For PR's, we just build for arm-v7a and run unit tests for the ObjectServer variant
+        // A full build is done on `master`.
+        // TODO Once Android emulators are available on all nodes, we can switch to x86 builds
+        // on PR's for even more throughput.
+        def ABIs = ""
+        def instrumentationTestTarget = "connectedAndroidTest"
+        if (!['master'].contains(env.BRANCH_NAME)) {
+            ABIs = "armeabi-v7a"
+            instrumentationTestTarget = "connectedObjectServerDebugAndroidTest" // Run in debug more for better error reporting
+        }
+
+        def buildEnv
+        def rosEnv
+        stage('Docker build') {
+          // Docker image for build
+          buildEnv = docker.build 'realm-java:snapshot'
+          // Docker image for testing Realm Object Server
+          def dependProperties = readProperties file: 'dependencies.list'
+          def rosDeVersion = dependProperties["REALM_OBJECT_SERVER_DE_VERSION"]
+          rosEnv = docker.build 'ros:snapshot', "--build-arg ROS_DE_VERSION=${rosDeVersion} tools/sync_test_server"
+        }
+
+	    rosContainer = rosEnv.run()
+
+        try {
+              buildEnv.inside("-e HOME=/tmp " +
+                  "-e _JAVA_OPTIONS=-Duser.home=/tmp " +
+                  "--privileged " +
+                  "-v /dev/bus/usb:/dev/bus/usb " +
+                  "-v ${env.HOME}/gradle-cache:/tmp/.gradle " +
+                  "-v ${env.HOME}/.android:/tmp/.android " +
+                  "-v ${env.HOME}/ccache:/tmp/.ccache " +
+                  "-e REALM_CORE_DOWNLOAD_DIR=/tmp/.gradle " +
+                  "--network container:${rosContainer.id}") {
+                stage('JVM tests') {
+                  try {
+                    withCredentials([[$class: 'FileBinding', credentialsId: 'c0cc8f9e-c3f1-4e22-b22f-6568392e26ae', variable: 'S3CFG']]) {
+                      sh "chmod +x gradlew && ./gradlew assemble check javadoc -Ps3cfg=${env.S3CFG} -PbuildTargetABIs=${ABIs}"
+                    }
+                  } finally {
+                    storeJunitResults 'realm/realm-annotations-processor/build/test-results/test/TEST-*.xml'
+                    storeJunitResults 'examples/unitTestExample/build/test-results/**/TEST-*.xml'
+                    step([$class: 'LintPublisher'])
+                  }
                 }
-              } finally {
-                storeJunitResults 'realm/realm-annotations-processor/build/test-results/test/TEST-*.xml'
-                storeJunitResults 'examples/unitTestExample/build/test-results/**/TEST-*.xml'
-                step([$class: 'LintPublisher'])
-              }
-            }
-
-            stage('Static code analysis') {
-              try {
-                gradle('realm', 'findbugs pmd checkstyle')
-              } finally {
-                publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/findbugs', reportFiles: 'findbugs-output.html', reportName: 'Findbugs issues'])
-                publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/reports/pmd', reportFiles: 'pmd.html', reportName: 'PMD Issues'])
-                step([$class: 'CheckStylePublisher',
-		      canComputeNew: false,
-		      defaultEncoding: '',
-		      healthy: '',
-		      pattern: 'realm/realm-library/build/reports/checkstyle/checkstyle.xml',
-		      unHealthy: ''
-		     ])
-              }
-            }
-
-            stage('Run instrumented tests') {
-              lock("${env.NODE_NAME}-android") {
-                boolean archiveLog = true
-                String backgroundPid
-                try {
-                  backgroundPid = startLogCatCollector()
-                  forwardAdbPorts()
-                  gradle('realm', 'connectedUnitTests')
-                  archiveLog = false;
-                } finally {
-                  stopLogCatCollector(backgroundPid, archiveLog)
-                  storeJunitResults 'realm/realm-library/build/outputs/androidTest-results/connected/**/TEST-*.xml'
+
+                stage('Static code analysis') {
+                  try {
+                    gradle('realm', 'findbugs pmd checkstyle')
+                  } finally {
+                    publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/findbugs', reportFiles: 'findbugs-output.html', reportName: 'Findbugs issues'])
+                    publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/reports/pmd', reportFiles: 'pmd.html', reportName: 'PMD Issues'])
+                    step([$class: 'CheckStylePublisher',
+                  canComputeNew: false,
+                  defaultEncoding: '',
+                  healthy: '',
+                  pattern: 'realm/realm-library/build/reports/checkstyle/checkstyle.xml',
+                  unHealthy: ''
+                 ])
+                  }
                 }
-              }
-            }
 
-            // TODO: add support for running monkey on the example apps
+                stage('Run instrumented tests') {
+                  lock("${env.NODE_NAME}-android") {
+                    boolean archiveLog = true
+                    String backgroundPid
+                    try {
+                      backgroundPid = startLogCatCollector()
+                      forwardAdbPorts()
+                      gradle('realm', "${instrumentationTestTarget}")
+                      archiveLog = false;
+                    } finally {
+                      stopLogCatCollector(backgroundPid, archiveLog)
+                      storeJunitResults 'realm/realm-library/build/outputs/androidTest-results/connected/**/TEST-*.xml'
+                    }
+                  }
+                }
 
-            if (env.BRANCH_NAME == 'master') {
-              stage('Collect metrics') {
-                collectAarMetrics()
-              }
+                // TODO: add support for running monkey on the example apps
+
+                if (env.BRANCH_NAME == 'master') {
+                  stage('Collect metrics') {
+                    collectAarMetrics()
+                  }
 
-              stage('Publish to OJO') {
-                withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: 'bintray', passwordVariable: 'BINTRAY_KEY', usernameVariable: 'BINTRAY_USER']]) {
-                  sh "chmod +x gradlew && ./gradlew -PbintrayUser=${env.BINTRAY_USER} -PbintrayKey=${env.BINTRAY_KEY} assemble ojoUpload --stacktrace"
+                  stage('Publish to OJO') {
+                    withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: 'bintray', passwordVariable: 'BINTRAY_KEY', usernameVariable: 'BINTRAY_USER']]) {
+                      sh "chmod +x gradlew && ./gradlew -PbintrayUser=${env.BINTRAY_USER} -PbintrayKey=${env.BINTRAY_KEY} assemble ojoUpload --stacktrace"
+                    }
+                  }
                 }
               }
-            }
-          }
-	} finally {
-          sh "docker logs ${rosContainer.id}"
-          rosContainer.stop()
-	}
+        } finally {
+              archiveRosLog(rosContainer.id)
+              sh "docker logs ${rosContainer.id}"
+              rosContainer.stop()
+        }
       }
     }
     currentBuild.rawBuild.setResult(Result.SUCCESS)
@@ -136,7 +149,7 @@ try {
 }
 
 def forwardAdbPorts() {
-  sh ''' adb reverse tcp:9080 tcp:9080 &&
+  sh ''' adb reverse tcp:9080 tcp:9080 && adb reverse tcp:9443 tcp:9443 &&
       adb reverse tcp:8888 tcp:8888
   '''
 }
@@ -161,6 +174,16 @@ def stopLogCatCollector(String backgroundPid, boolean archiveLog) {
   sh 'rm logcat.txt'
 }
 
+def archiveRosLog(String id) {
+  sh "docker cp ${id}:/tmp/ros-testing-server.log ./ros.log"
+  zip([
+      'zipFile': 'roslog.zip',
+      'archive': true,
+      'glob' : 'ros.log'
+  ])
+  sh 'rm ros.log'
+}
+
 def sendMetrics(String metricName, String metricValue, Map<String, String> tags) {
   def tagsString = getTagsString(tags)
   withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: '5b8ad2d9-61a4-43b5-b4df-b8ff6b1f16fa', passwordVariable: 'influx_pass', usernameVariable: 'influx_user']]) {
diff --git a/LICENSE b/LICENSE
index 273b4d5f7b..57a0e0b24a 100644
--- a/LICENSE
+++ b/LICENSE
@@ -181,8 +181,6 @@ TABLE OF CONTENTS
       incurred by, or claims asserted against, such Contributor by reason
       of your accepting any such warranty or additional liability.
 
-   END OF TERMS AND CONDITIONS
-
 2. -------------------------------------------------------------------------------
 
 REALM COMPONENTS
@@ -195,7 +193,7 @@ For the Realm Platform Extensions component
 
   Realm Platform Extensions License
 
-  Copyright (c) 2011-2016 Realm Inc All rights reserved
+  Copyright (c) 2011-2017 Realm Inc All rights reserved
 
   Redistribution and use in binary form, with or without modification, is
   permitted provided that the following conditions are met:
@@ -232,16 +230,19 @@ EXPORT COMPLIANCE
 
 You understand that the Software may contain cryptographic functions that may be
 subject to export restrictions, and you represent and warrant that you are not
-located in a country that is subject to United States export restriction or embargo,
-including Cuba, Iran, North Korea, Sudan, Syria or the Crimea region, and that you
-are not on the Department of Commerce list of Denied Persons, Unverified Parties,
-or affiliated with a Restricted Entity.
+(i) located in a jurisdiction that is subject to United States economic
+sanctions (“Prohibited Jurisdiction”), including Cuba, Iran, North Korea,
+Sudan, Syria or the Crimea region, (ii) a person listed on any U.S. government
+blacklist (to include the List of Specially Designated Nationals and Blocked
+Persons or the Consolidated Sanctions List administered by the U.S. Department
+of the Treasury’s Office of Foreign Assets Control, or the Denied Persons List
+or Entity List administered by the U.S. Department of Commerce)
+(“Sanctioned Person”), or (iii) controlled or 50% or more owned by a Sanctioned
+Person.
 
 You agree to comply with all export, re-export and import restrictions and
-regulations of the Department of Commerce or other agency or authority of the
-United States or other applicable countries. You also agree not to transfer, or
-authorize the transfer of, directly or indirectly, the Software to any prohibited
-country, including Cuba, Iran, North Korea, Sudan, Syria or the Crimea region,
-or to any person or organization on or affiliated with the Department of
-Commerce lists of Denied Persons, Unverified Parties or Restricted Entities, or
-otherwise in violation of any such restrictions or regulations.
+regulations of the U.S. Department of Commerce or other agency or authority of
+the United States or other applicable countries. You also agree not to transfer,
+or authorize the transfer of, directly or indirectly, of the Software to any
+Prohibited Jurisdiction, or otherwise in violation of any such restrictions or
+regulations.
diff --git a/README.md b/README.md
index fcd8d6c7f3..e6b22c7e0b 100644
--- a/README.md
+++ b/README.md
@@ -24,11 +24,11 @@ The API reference is located at [realm.io/docs/java/api](https://realm.io/docs/j
 - **Need help with your code?**: Look for previous questions on the [#realm tag](https://stackoverflow.com/questions/tagged/realm?sort=newest) — or [ask a new question](http://stackoverflow.com/questions/ask?tags=realm). We activtely monitor & answer questions on SO!
 - **Have a bug to report?** [Open an issue](https://github.com/realm/realm-java/issues/new). If possible, include the version of Realm, a full log, the Realm file, and a project that shows the issue.
 - **Have a feature request?** [Open an issue](https://github.com/realm/realm-java/issues/new). Tell us what the feature should do, and why you want the feature.
-- Sign up for our [**Community Newsletter**](http://eepurl.com/VEKCn) to get regular tips, learn about other use-cases and get alerted of blogposts and tutorials about Realm.
+- Sign up for our [**Community Newsletter**](https://go.pardot.com/l/210132/2017-04-26/3j74l) to get regular tips, learn about other use-cases and get alerted of blogposts and tutorials about Realm.
 
 ## Using Snapshots
 
-If you want to test recent bugfixes or features that have not been packaged in an official release yet, you can use a **-SNAPSHOT** release of the current development version of Realm via Gradle, available on [OJO](http://oss.jfrog.org/oss-snapshot-local/io/realm/realm-android/)
+If you want to test recent bugfixes or features that have not been packaged in an official release yet, you can use a **-SNAPSHOT** release of the current development version of Realm via Gradle, available on [Jfrog OSS](http://oss.jfrog.org/oss-snapshot-local/io/realm/realm-gradle-plugin/)
 
 ```gradle
 buildscript {
@@ -60,11 +60,12 @@ In case you don't want to use the precompiled version, you can build Realm yours
 ### Prerequisites
 
  * Download the [**JDK 7**](http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html) or [**JDK 8**](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) from Oracle and install it.
- * Download & install the Android SDK **Build-Tools 25.0.3**, **Android N (API 25)** (for example through Android Studio’s **Android SDK Manager**).
+ * Download & install the Android SDK **Build-Tools 26.0.2**, **Android O (API 26)** (for example through Android Studio’s **Android SDK Manager**).
  * Install CMake from SDK manager in Android Studio ("SDK Tools" -> "CMake").
+ * If you use Android Studio, Android Studio 3.0 or later is required.
 
  * Realm currently requires version r10e of the NDK.  Download the one appropriate for your development platform, from the NDK [archive](https://developer.android.com/ndk/downloads/older_releases.html).
-You may unzip the file wherever you choose.  For OSX, a suggested location is `~/Library/Android`.  The download will unzip as the directory `android-ndk-r10e`.
+You may unzip the file wherever you choose.  For macOS, a suggested location is `~/Library/Android`.  The download will unzip as the directory `android-ndk-r10e`.
 
  * If you will be building with Android Studio, you will need to tell it to use the correct NDK.  To do this, define the variable `ndk.dir` in `realm/local.properties` and assign it the full path name of the directory that you unzipped above.  Note that there is a `local.properites` in the root directory that is *not* the one that needs to be edited.
 
@@ -80,7 +81,7 @@ You may unzip the file wherever you choose.  For OSX, a suggested location is `~
     export ANDROID_NDK_HOME=~/Library/Android/android-ndk-r10e
     ```
 
- * If you will be launching Android Studio from the OS X Finder, you should also run the following two commands:
+ * If you will be launching Android Studio from the macOS Finder, you should also run the following two commands:
 
     ```
     launchctl setenv ANDROID_HOME "$ANDROID_HOME"
@@ -93,14 +94,20 @@ You may unzip the file wherever you choose.  For OSX, a suggested location is `~
    export REALM_CORE_DOWNLOAD_DIR=~/.realmCore
    ```
 
-   OS X users must also run the following command in order for Android Studio to see this environment variable..
+   macOS users must also run the following command in order for Android Studio to see this environment variable..
 
    ```
    launchctl setenv REALM_CORE_DOWNLOAD_DIR "$REALM_CORE_DOWNLOAD_DIR"
    ```
 
-It would be a good idea to add all of the symbol definitions (and their accompanying `launchctl` commands, if you are using OS X) to your `~/.profile` (or `~/.zprofile` if the login shell is `zsh`)
+It would be a good idea to add all of the symbol definitions (and their accompanying `launchctl` commands, if you are using macOS) to your `~/.profile` (or `~/.zprofile` if the login shell is `zsh`)
 
+ * If you develop Realm Java with Android Studio, we recommend you to exclude some directories from indexing target by executing following steps on Android Studio. It really speeds up indexing phase after build.
+
+    - Under `/realm/realm-library/`, select `build`, `.externalNativeBuild` and `distribution` folders in `Project` view.
+    - Press `Command + Shift + A` to open `Find action` dialog. If you are not using defaut keymap nor using macOS, you can find your shortcut key in `Keymap` preference by searching `Find action`.
+    - Search `Excluded` (not `Exclude`) action and select it. Selected folder icons should become orange (in default theme).
+    - Restart Android Studio.
 
 ### Download sources
 
@@ -144,6 +151,16 @@ The full build may take an hour or more, to complete.
 
 Generating the Javadoc using the command above may generate warnings. The Javadoc is generated despite the warnings.
 
+
+### Upgrading Gradle Wrappers
+
+ All gradle projects in this repository have `wrapper` task to generate Gradle Wrappers. Those tasks refer `gradleVersion` propertiy defined in `/realm.properties` in order to determine Geadle Version of generating wrappers. After generating Gradle Wrappers, we need to modify `gradle/wrapper/gradle-wrapper.properties` to use `*-all.zip` distribution instead of `*-bin.zip` distribution.
+
+We have a script `./tools/update_gradle_wrapper.sh` to automate these steps. When you update Gradle Wrappers, please obey the following steps.
+
+ 1. Edit `gradleVersion` property in defined in `/realm.properties` to new Gradle Wrapper version.
+ 2. Execute `/tools/update_gradle_wrapper.sh`.
+
 ### Gotchas
 
 The repository is organized in six Gradle projects:
@@ -239,7 +256,9 @@ style/lint in the drop-down to the left of the Manage... button.
 ## License
 
 Realm Java is published under the Apache 2.0 license.
-The underlying core is available under the [Realm Core Binary License](LICENSE#L210-L243) while we [work to open-source it under the Apache 2.0 license](https://realm.io/docs/java/#faq).
+
+Realm Core is also published under the Apache 2.0 license and is available
+[here](https://github.com/realm/realm-core).
 
 **This product is not being made available to any person located in Cuba, Iran,
 North Korea, Sudan, Syria or the Crimea region, or to any other person that is
@@ -247,7 +266,7 @@ not eligible to receive the product under U.S. law.**
 
 ## Feedback
 
-**_If you use Realm and are happy with it, all we ask is that you please consider sending out a tweet mentioning [@realm](http://twitter.com/realm), announce your app on [our mailing-list](https://groups.google.com/forum/#!forum/realm-java), or email [help@realm.io](mailto:help@realm.io) to let us know about it!_**
+**_If you use Realm and are happy with it, all we ask is that you please consider sending out a tweet mentioning [@realm](http://twitter.com/realm) to share your thoughts!_**
 
 **_And if you don't like it, please let us know what you would like improved, so we can fix it!_**
 
diff --git a/SUPPORT.md b/SUPPORT.md
new file mode 100644
index 0000000000..4cfe265eca
--- /dev/null
+++ b/SUPPORT.md
@@ -0,0 +1,19 @@
+# Support
+
+The Realm team is here to help you with your Realm-related issues!
+
+## Documentation
+
+Before asking questions, please familiarize yourself with our [Java](https://realm.io/docs/java/latest) documentation. We also have a number of [Tech Notes](https://realm.io/docs/tech-notes/) which cover various topics that may be of interest.
+
+## Stack Overflow
+
+If you have questions about configuring or using Realm you can ask them on Stack Overflow. We continually monitor the [`realm` tag](https://stackoverflow.com/tags/realm). Please also tag your question with `java`, `android`, or other tags as appropriate.
+
+When asking questions on Stack Overflow, please keep in mind Stack Overflow's [question guidelines](https://stackoverflow.com/help/how-to-ask), and please use their search functionality to see if your question has been asked before.
+
+## GitHub Issues
+
+If you are running into issues with Realm, including potential bugs or feature requests, we encourage you to file an issue on our [GitHub issue tracker](https://github.com/realm/realm-java/issues). Please check out our [Contribution Guidelines](CONTRIBUTING.md) for information on how to properly file an issue.
+
+We greatly appreciate demonstration projects that we can run for ourselves in order to see issues or potential bugs; we prioritize clearly-written tickets that include reproduction cases. You may attach these to the ticket; let us know if you need to share them confidentially, and we’ll provide instructions on how to do so.
diff --git a/build.gradle b/build.gradle
index 3eac28d01d..a27e1486e0 100644
--- a/build.gradle
+++ b/build.gradle
@@ -89,12 +89,45 @@ task check {
     dependsOn checkExamples
 }
 
+task assembleUnitTests(type:GradleBuild) {
+    group = 'Build'
+    description = 'Assemble Android unit tests of the Realm project'
+    dependsOn installTransformer
+    buildFile = file('realm/build.gradle')
+    tasks = ['assembleAndroidTest']
+    if (project.hasProperty('buildTargetABIs')) {
+        startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
+    }
+}
+
 task connectedUnitTests(type:GradleBuild) {
     group = 'Test'
     description = 'Run the Android unit tests of the Realm project'
     dependsOn installTransformer
     buildFile = file('realm/build.gradle')
-    tasks = ['connectedUnitTests']
+    tasks = ['connectedAndroidTest']
+    if (project.hasProperty('buildTargetABIs')) {
+        startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
+    }
+}
+
+task assembleBenchmarks(type:GradleBuild) {
+    group = 'Build'
+    description = 'Assemble benchmark tests for the library '
+    dependsOn installTransformer
+    buildFile = file('library-benchmarks/build.gradle')
+    tasks = ['assembleAndroidTest']
+    if (project.hasProperty('buildTargetABIs')) {
+        startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
+    }
+}
+
+task connectedBenchmarks(type:GradleBuild) {
+    group = 'Test'
+    description = 'Run all the benchmark tests for the library '
+    dependsOn installTransformer
+    buildFile = file('library-benchmarks/build.gradle')
+    tasks = ['connectedAndroidTest']
     if (project.hasProperty('buildTargetABIs')) {
         startParameter.projectProperties += [buildTargetABIs: project.getProperty('buildTargetABIs')]
     }
diff --git a/dependencies.list b/dependencies.list
index 06db1eeb3f..49ad30bacb 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,13 +1,9 @@
 # Realm Sync Core release used by Realm Java
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=1.6.0
-REALM_SYNC_SHA256=e8a973dbe6ab33ac49d3d0e45d6b63d69cec8d1d87d9a2311fcdd02767f76cf8
+REALM_SYNC_VERSION=2.1.0
+REALM_SYNC_SHA256=cd52b2ee53ef80b4b9ec80eede7ca5fa28a96353ad7e4d26cf516dbb12586966
+
+# Object Server Release used by Integration tests. Installed using NPM.
+# Use `npm view realm-object-server versions` to get a list of available versions.
+REALM_OBJECT_SERVER_DE_VERSION=2.0.6
 
-# Object Server Release used by Integration tests
-# `realm` is stable releases, `realm-testing` is developer builds.
-# https://packagecloud.io/realm/realm?filter=debs
-# https://packagecloud.io/realm/realm-testing?filter=debs
-# /tools/sync_test_server/Dockerfile specify which repo (apt) we should
-# install/use between 'realm' and 'realm-testing', the version below should
-# correspond to an existing version on the *specified* repo.
-REALM_OBJECT_SERVER_DE_VERSION=1.3.0-294
diff --git a/examples/build.gradle b/examples/build.gradle
index 8fd93d0f63..944e287edb 100644
--- a/examples/build.gradle
+++ b/examples/build.gradle
@@ -1,11 +1,20 @@
-project.ext.sdkVersion = 25
-project.ext.buildTools = '25.0.3'
+project.ext.sdkVersion = 26
+project.ext.buildTools = '26.0.2'
 
 // Don't cache SNAPSHOT (changing) dependencies.
 configurations.all {
     resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
 }
 
+static String getAppId (path) {
+    String build = new File(path).text
+    def matcher = build =~ 'applicationId.*'
+    def appId = matcher.size() > 0 ? matcher[0].trim() - 'applicationId' - ~/\s/ : '';
+    String myappId = appId.replaceAll('"', '')
+    myappId = myappId.replaceAll('\'', '')
+    return myappId
+}
+
 allprojects {
     def currentVersion = file("${rootDir}/../version.txt").text.trim()
 
@@ -17,15 +26,14 @@ allprojects {
 
     buildscript {
         repositories {
+            google()
             mavenLocal()
             jcenter()
             maven { url 'https://jitpack.io' }
         }
         dependencies {
-            classpath 'com.android.tools.build:gradle:2.3.1'
-            classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
-            classpath 'com.github.JakeWharton:sdk-manager-plugin:0ce4cdf08009d79223850a59959d9d6e774d0f77'
-            classpath 'com.novoda:gradle-android-command-plugin:1.5.0'
+            classpath 'com.android.tools.build:gradle:3.0.0-rc2'
+            classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
             classpath "io.realm:realm-gradle-plugin:${currentVersion}"
         }
     }
@@ -36,6 +44,32 @@ allprojects {
     repositories {
         mavenLocal()
         jcenter()
+        google()
+    }
+
+    if (!project.name.startsWith("realm-examples")
+            && !project.name.startsWith("library")
+            && !project.name.startsWith("moduleExample")) { // exclude root and library project
+        ["Debug", "Release"].each {
+            task "monkey${it}"(dependsOn: "install${it}") {
+                doLast {
+                    def numberOfEvents = 2000
+                    def appId = getAppId("${project.projectDir}/build.gradle")
+                    def process = "adb shell monkey -p ${appId} ${numberOfEvents}".execute([], project.rootDir)
+
+                    def sout = new StringBuilder(), serr = new StringBuilder()
+                    process.consumeProcessOutput(sout, serr)
+                    process.waitFor()
+
+                    if (process.exitValue() != 0
+                            || serr?.toString()?.trim()?.size() > 0
+                            || !sout?.toString()?.trim()?.contains("Events injected: ${numberOfEvents}")) {
+                        // fail Gradle build
+                        throw new GradleException("monkey failed for AppID: ${appId} \nStd out:  ${sout}\nStd err:  ${serr}")
+                    }
+                }
+            }
+        }
     }
 }
 
diff --git a/examples/encryptionExample/build.gradle b/examples/encryptionExample/build.gradle
index c58427e952..1d7baebd33 100644
--- a/examples/encryptionExample/build.gradle
+++ b/examples/encryptionExample/build.gradle
@@ -1,5 +1,4 @@
 apply plugin: 'com.android.application'
-apply plugin: 'android-command'
 apply plugin: 'realm-android'
 
 android {
@@ -16,13 +15,13 @@ android {
 
     buildTypes {
         release {
-            minifyEnabled false
+            minifyEnabled true
+            signingConfig signingConfigs.debug
+        }
+        debug {
+            minifyEnabled true
         }
     }
     productFlavors {
     }
-
-    command {
-        events 2000
-    }
 }
diff --git a/examples/gradle.properties b/examples/gradle.properties
index 4a9594aeec..69f84662c3 100644
--- a/examples/gradle.properties
+++ b/examples/gradle.properties
@@ -1 +1,13 @@
-org.gradle.jvmargs=-Xmx2048M
\ No newline at end of file
+org.gradle.jvmargs=-Xmx2048M
+org.gradle.caching=true
+
+# disable AAPT2 to work around an issue of Robolectric in unitTestExample https://github.com/robolectric/robolectric/issues/3169
+android.enableAapt2=false
+
+# Gradle sync failed: Due to a limitation of Gradle’s new variant-aware dependency management, loading the Android Gradle plugin in different class loaders leads to a build error.
+# This can occur when the buildscript classpaths that contain the Android Gradle plugin in sub-projects, or included projects in the case of composite builds, are set differently.
+# To resolve this issue, add the Android Gradle plugin to only the buildscript classpath of the top-level build.gradle file.
+# In the case of composite builds, also make sure the build script classpaths that contain the Android Gradle plugin are identical across the main and included projects.
+# If you are using a version of Gradle that has fixed the issue, you can disable this check by setting android.enableBuildScriptClasspathCheck=false in the gradle.properties file.
+# To learn more about this issue, go to https://d.android.com/r/tools/buildscript-classpath-check.html.
+android.enableBuildScriptClasspathCheck=false
\ No newline at end of file
diff --git a/examples/gradle/wrapper/gradle-wrapper.jar b/examples/gradle/wrapper/gradle-wrapper.jar
index 1149f4ca38..d457a1a990 100644
Binary files a/examples/gradle/wrapper/gradle-wrapper.jar and b/examples/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/examples/gradle/wrapper/gradle-wrapper.properties b/examples/gradle/wrapper/gradle-wrapper.properties
index cbb9ce3c56..c583957d2b 100644
--- a/examples/gradle/wrapper/gradle-wrapper.properties
+++ b/examples/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Wed Mar 22 16:44:51 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
diff --git a/examples/gradlew b/examples/gradlew
index 4453ccea33..cccdd3d517 100755
--- a/examples/gradlew
+++ b/examples/gradlew
@@ -33,11 +33,11 @@ DEFAULT_JVM_OPTS=""
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
-warn ( ) {
+warn () {
     echo "$*"
 }
 
-die ( ) {
+die () {
     echo
     echo "$*"
     echo
@@ -155,7 +155,7 @@ if $cygwin ; then
 fi
 
 # Escape application args
-save ( ) {
+save () {
     for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
     echo " "
 }
diff --git a/examples/gridViewExample/build.gradle b/examples/gridViewExample/build.gradle
index 474e8611e1..10615bfbe1 100644
--- a/examples/gridViewExample/build.gradle
+++ b/examples/gridViewExample/build.gradle
@@ -1,5 +1,4 @@
 apply plugin: 'com.android.application'
-apply plugin: 'android-command'
 apply plugin: 'realm-android'
 
 android {
@@ -15,16 +14,18 @@ android {
     }
     buildTypes {
         release {
-            minifyEnabled false
+            minifyEnabled true
+            signingConfig signingConfigs.debug
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+        debug {
+            minifyEnabled true
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
         }
     }
     productFlavors {
     }
 
-    command {
-        events 2000
-    }
-
     splits {
         // Split apks on build target ABI, view all options for the splits here:
         // http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits
@@ -37,5 +38,5 @@ android {
 }
 
 dependencies {
-    compile 'com.google.code.gson:gson:2.5'
+    implementation 'com.google.code.gson:gson:2.5'
 }
diff --git a/examples/gridViewExample/proguard-rules.pro b/examples/gridViewExample/proguard-rules.pro
new file mode 100644
index 0000000000..ca55feb449
--- /dev/null
+++ b/examples/gridViewExample/proguard-rules.pro
@@ -0,0 +1 @@
+-keep class io.realm.examples.realmgridview.City { <fields>; }
\ No newline at end of file
diff --git a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/City.java b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/City.java
index f0aec3c61c..020f0c422b 100644
--- a/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/City.java
+++ b/examples/gridViewExample/src/main/java/io/realm/examples/realmgridview/City.java
@@ -19,7 +19,8 @@
 import io.realm.RealmObject;
 
 public class City extends RealmObject {
-
+    // If you are using GSON, field names should not be obfuscated.
+    // Add either the proguard rule in proguard-rules.pro or the @SerializedName annotation.
     private String name;
     private long votes;
 
diff --git a/examples/introExample/build.gradle b/examples/introExample/build.gradle
index 6559bb309a..fdf0d2dfdc 100644
--- a/examples/introExample/build.gradle
+++ b/examples/introExample/build.gradle
@@ -1,5 +1,4 @@
 apply plugin: 'com.android.application'
-apply plugin: 'android-command'
 apply plugin: 'realm-android'
 
 android {
@@ -16,14 +15,15 @@ android {
 
     buildTypes {
         release {
-            minifyEnabled false
+            minifyEnabled true
+            signingConfig signingConfigs.debug
+        }
+        debug {
+            minifyEnabled true
         }
     }
 
     productFlavors {
     }
 
-    command {
-        events 2000
-    }
 }
diff --git a/examples/jsonExample/build.gradle b/examples/jsonExample/build.gradle
index c46861f443..e3bd188356 100644
--- a/examples/jsonExample/build.gradle
+++ b/examples/jsonExample/build.gradle
@@ -1,5 +1,4 @@
 apply plugin: 'com.android.application'
-apply plugin: 'android-command'
 apply plugin: 'realm-android'
 
 android {
@@ -12,21 +11,22 @@ android {
         minSdkVersion 15
         versionCode 1
         versionName "1.0"
+        javaCompileOptions.annotationProcessorOptions.includeCompileClasspath = true
     }
     buildTypes {
         release {
-            minifyEnabled false
+            minifyEnabled true
+            signingConfig signingConfigs.debug
+        }
+        debug {
+            minifyEnabled true
         }
     }
     productFlavors {
     }
-
-    command {
-        events 2000
-    }
 }
 
 dependencies {
-    provided 'org.projectlombok:lombok:1.16.6'
+    compileOnly 'org.projectlombok:lombok:1.16.6'
     annotationProcessor 'org.projectlombok:lombok:1.16.6'
 }
diff --git a/examples/kotlinExample/build.gradle b/examples/kotlinExample/build.gradle
index 737177a801..91d3f3166a 100644
--- a/examples/kotlinExample/build.gradle
+++ b/examples/kotlinExample/build.gradle
@@ -1,5 +1,5 @@
 buildscript {
-    ext.kotlin_version = '1.1.2-2'
+    ext.kotlin_version = '1.1.51'
     repositories {
         jcenter()
         mavenCentral()
@@ -11,7 +11,7 @@ buildscript {
 
 apply plugin: 'com.android.application'
 apply plugin: 'kotlin-android'
-apply plugin: 'android-command'
+apply plugin: 'kotlin-kapt'
 apply plugin: 'realm-android'
 
 android {
@@ -31,12 +31,12 @@ android {
 
     buildTypes {
         release {
-            minifyEnabled false
+            minifyEnabled true
+            signingConfig signingConfigs.debug
+        }
+        debug {
+            minifyEnabled true
         }
-    }
-
-    command {
-        events 2000
     }
 
     sourceSets {
@@ -44,7 +44,14 @@ android {
     }
 }
 
+// enable @ParametersAreNonnullByDefault annotation. See https://blog.jetbrains.com/kotlin/2017/08/kotlin-1-1-4-is-out/
+tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
+    kotlinOptions {
+        freeCompilerArgs = ["-Xjsr305-annotations=enable"]
+    }
+}
+
 dependencies {
-    compile "org.jetbrains.kotlin:kotlin-stdlib:${kotlin_version}"
-    compile 'org.jetbrains.anko:anko-sdk15:0.8.2'
+    implementation "org.jetbrains.kotlin:kotlin-stdlib-jre7:${kotlin_version}"
+    implementation 'org.jetbrains.anko:anko-sdk15:0.9.1'
 }
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
index aba7c85d6e..643704a169 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
@@ -26,7 +26,7 @@ import io.realm.Sort
 import io.realm.examples.kotlin.model.Cat
 import io.realm.examples.kotlin.model.Dog
 import io.realm.examples.kotlin.model.Person
-import org.jetbrains.anko.async
+import org.jetbrains.anko.doAsync
 import org.jetbrains.anko.uiThread
 import kotlin.properties.Delegates
 
@@ -42,7 +42,7 @@ class KotlinExampleActivity : Activity() {
     override fun onCreate(savedInstanceState: Bundle?) {
         super.onCreate(savedInstanceState)
         setContentView(R.layout.activity_realm_basic_example)
-        rootLayout = findViewById(R.id.container) as LinearLayout
+        rootLayout = findViewById(R.id.container)
         rootLayout.removeAllViews()
 
         // These operations are small enough that
@@ -63,11 +63,10 @@ class KotlinExampleActivity : Activity() {
         basicLinkQuery(realm)
 
         // More complex operations can be executed on another thread, for example using
-        // Anko's async extension method.
-        async {
+        // Anko's doAsync extension method.
+        doAsync {
             var info = complexReadWrite()
             info += complexQuery()
-
             uiThread {
                 showStatus(info)
             }
@@ -98,7 +97,7 @@ class KotlinExampleActivity : Activity() {
         }
 
         // Find the first person (no query conditions) and read a field
-        val person = realm.where(Person::class.java).findFirst()
+        val person = realm.where(Person::class.java).findFirst()!!
         showStatus(person.name + ": " + person.age)
 
         // Update person in a transaction
@@ -113,7 +112,7 @@ class KotlinExampleActivity : Activity() {
         showStatus("\nPerforming basic Query operation...")
         showStatus("Number of persons: ${realm.where(Person::class.java).count()}")
 
-        val results = realm.where(Person::class.java).equalTo("age", 99).findAll()
+        val results = realm.where(Person::class.java).equalTo("age", 99.toInt()).findAll()
 
         showStatus("Size of result set: " + results.size)
     }
@@ -175,7 +174,7 @@ class KotlinExampleActivity : Activity() {
 
             // Sorting
             val sortedPersons = realm.where(Person::class.java).findAllSorted("age", Sort.DESCENDING)
-            status += "\nSorting ${sortedPersons.last().name} == ${realm.where(Person::class.java).findAll().first().name}"
+            status += "\nSorting ${sortedPersons.last()?.name} == ${realm.where(Person::class.java).findAll().first()?.name}"
 
         } finally {
             realm.close()
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Cat.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Cat.kt
index 803eb7fcef..60e21b81b5 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Cat.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Cat.kt
@@ -19,5 +19,5 @@ package io.realm.examples.kotlin.model
 import io.realm.RealmObject
 
 open class Cat : RealmObject() {
-    open var name: String? = null
+    var name: String? = null
 }
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Dog.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Dog.kt
index dd4b8452e8..17d8b5fd75 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Dog.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Dog.kt
@@ -17,7 +17,11 @@
 package io.realm.examples.kotlin.model
 
 import io.realm.RealmObject
+import io.realm.RealmResults
+import io.realm.annotations.LinkingObjects
 
 open class Dog : RealmObject() {
-    open var name: String? = null
+    var name: String? = null
+    @LinkingObjects("dog")
+    val owners: RealmResults<Person>? = null
 }
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt
index c408a12472..829fb1b8cd 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/model/Person.kt
@@ -21,8 +21,7 @@ import io.realm.RealmObject
 import io.realm.annotations.Ignore
 import io.realm.annotations.PrimaryKey
 
-// Your model has to extend RealmObject. Furthermore, the class and all of the
-// properties must be annotated with open (Kotlin classes and methods are final
+// Your model has to extend RealmObject. Furthermore, the class must be annotated with open (Kotlin classes are final
 // by default).
 open class Person(
         // You can put properties in the constructor as long as all of them are initialized with
@@ -30,20 +29,20 @@ open class Person(
         // All properties are by default persisted.
         // Properties can be annotated with PrimaryKey or Index.
         // If you use non-nullable types, properties must be initialized with non-null values.
-        @PrimaryKey open var id: Long = 0,
+        @PrimaryKey var id: Long = 0,
 
-        open var name: String = "",
+        var name: String = "",
 
-        open var age: Int = 0,
+        var age: Int = 0,
 
         // Other objects in a one-to-one relation must also subclass RealmObject
-        open var dog: Dog? = null,
+        var dog: Dog? = null,
 
         // One-to-many relations is simply a RealmList of the objects which also subclass RealmObject
-        open var cats: RealmList<Cat> = RealmList(),
+        var cats: RealmList<Cat> = RealmList(),
 
         // You can instruct Realm to ignore a field and not persist it.
-        @Ignore open var tempReference: Int = 0
+        @Ignore var tempReference: Int = 0
 
 ) : RealmObject() {
     // The Kotlin compiler generates standard getters and setters.
diff --git a/examples/migrationExample/build.gradle b/examples/migrationExample/build.gradle
index 800fa0ee4f..b7991c006c 100644
--- a/examples/migrationExample/build.gradle
+++ b/examples/migrationExample/build.gradle
@@ -1,5 +1,4 @@
 apply plugin: 'com.android.application'
-apply plugin: 'android-command'
 apply plugin: 'realm-android'
 
 android {
@@ -15,10 +14,11 @@ android {
     }
     buildTypes {
         release {
-            minifyEnabled false
+            minifyEnabled true
+            signingConfig signingConfigs.debug
+        }
+        debug {
+            minifyEnabled true
         }
-    }
-    command {
-        events 2000
     }
 }
diff --git a/examples/moduleExample/app/build.gradle b/examples/moduleExample/app/build.gradle
index c8e16e60d3..424f257901 100644
--- a/examples/moduleExample/app/build.gradle
+++ b/examples/moduleExample/app/build.gradle
@@ -1,5 +1,4 @@
 apply plugin: 'com.android.application'
-apply plugin: 'android-command'
 apply plugin: 'realm-android'
 
 android {
@@ -25,17 +24,13 @@ android {
 
     buildTypes {
         release {
-            minifyEnabled false // FIXME Why is this suddenly broken?
+            minifyEnabled true
             proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
             signingConfig signingConfigs.release
         }
     }
-
-    command {
-        events 2000
-    }
 }
 
 dependencies {
-    compile project(':moduleExample:library')
+    implementation project(':moduleExample:library')
 }
diff --git a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
index 1d2cb4a177..780029cf8b 100644
--- a/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
+++ b/examples/moduleExample/app/src/main/java/io/realm/examples/appmodules/ModulesExampleActivity.java
@@ -128,7 +128,7 @@ public void execute(Realm realm) {
             }
         });
 
-        showStatus("Number of pigs on the farm : " + farmRealm.where(Pig.class).count());
+        showStatus("Number of unnamed pigs on the farm : " + farmRealm.where(Pig.class).isNull("name").count());
 
         // Each Realm is restricted to only accept the classes in their schema.
         showStatus("Trying to add an unsupported class");
diff --git a/examples/newsreaderExample/build.gradle b/examples/newsreaderExample/build.gradle
index dcc0165a06..e5cfcf0acb 100644
--- a/examples/newsreaderExample/build.gradle
+++ b/examples/newsreaderExample/build.gradle
@@ -1,5 +1,4 @@
 apply plugin: 'com.android.application'
-apply plugin: 'android-command'
 apply plugin: 'realm-android'
 
 android {
@@ -13,37 +12,43 @@ android {
         versionCode 1
         versionName "1.0"
     }
+
     buildTypes {
         release {
+            // FIXME: Fix the proguard with 3rd party libs
             minifyEnabled false
+            signingConfig signingConfigs.debug
         }
     }
-    command {
-        events 2000
-    }
+
     lintOptions {
         disable 'InvalidPackage'
     }
+
     packagingOptions {
         exclude 'META-INF/services/javax.annotation.processing.Processor'
         exclude 'META-INF/NOTICE'
         exclude 'META-INF/LICENSE'
     }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
 }
 
 dependencies {
-    compile fileTree(dir: 'libs', include: ['*.jar'])
     //noinspection GradleDependency
-    compile 'com.android.support:appcompat-v7:25.2.0'
+    implementation 'com.android.support:appcompat-v7:26.0.1'
     //noinspection GradleDependency
-    compile 'com.android.support:design:25.2.0'
-    compile 'io.reactivex:rxjava:1.1.0'
-    compile 'io.reactivex:rxandroid:1.1.0'
-    compile 'com.squareup.retrofit:retrofit:2.0.0-beta2'
-    compile 'com.squareup.retrofit:converter-jackson:2.0.0-beta2'
-    compile 'com.squareup.retrofit:adapter-rxjava:2.0.0-beta2'
-    compile 'com.jakewharton.timber:timber:4.1.0'
-    compile 'com.jakewharton:butterknife:8.5.1'
+    implementation 'com.android.support:design:26.0.1'
+    implementation 'com.jakewharton.timber:timber:4.1.0'
+    implementation 'com.jakewharton:butterknife:8.5.1'
+    implementation 'com.squareup.retrofit2:adapter-rxjava2:2.3.0'
+    implementation 'com.squareup.retrofit2:converter-jackson:2.3.0'
+    implementation 'com.squareup.retrofit2:retrofit:2.3.0'
+    implementation 'io.reactivex.rxjava2:rxandroid:2.0.1'
+    implementation 'io.reactivex.rxjava2:rxjava:2.1.0'
+    implementation 'me.zhanghai.android.materialprogressbar:library:1.1.4'
     annotationProcessor 'com.jakewharton:butterknife-compiler:8.5.1'
-    compile 'me.zhanghai.android.materialprogressbar:library:1.1.4'
 }
diff --git a/examples/newsreaderExample/gradle.properties b/examples/newsreaderExample/gradle.properties
new file mode 100644
index 0000000000..31590309be
--- /dev/null
+++ b/examples/newsreaderExample/gradle.properties
@@ -0,0 +1 @@
+android.enableD8=true
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/NewsReaderApplication.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/NewsReaderApplication.java
index 77674d9c2b..7bba7cdf16 100644
--- a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/NewsReaderApplication.java
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/NewsReaderApplication.java
@@ -19,10 +19,9 @@
 import android.app.Application;
 import android.content.Context;
 
+import io.reactivex.plugins.RxJavaPlugins;
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
-import rx.plugins.RxJavaErrorHandler;
-import rx.plugins.RxJavaPlugins;
 import timber.log.Timber;
 
 public abstract class NewsReaderApplication extends Application {
@@ -35,13 +34,7 @@ public void onCreate() {
         context = this;
 
         initializeTimber();
-        RxJavaPlugins.getInstance().registerErrorHandler(new RxJavaErrorHandler() {
-            @Override
-            public void handleError(Throwable e) {
-                super.handleError(e);
-                Timber.e(e.toString());
-            }
-        });
+        RxJavaPlugins.setErrorHandler(throwable -> Timber.e(throwable.toString()));
 
         // Configure default configuration for Realm
         Realm.init(this);
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Model.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Model.java
index bfd914f6ad..401ba2ac0a 100644
--- a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Model.java
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Model.java
@@ -22,10 +22,10 @@
 import java.util.HashMap;
 import java.util.Map;
 
+import io.reactivex.Flowable;
+import io.reactivex.Observable;
 import io.realm.RealmResults;
 import io.realm.examples.newsreader.model.entity.NYTimesStory;
-import rx.Observable;
-import rx.functions.Func1;
 
 /**
  * Model class for handling the business rules of the app.
@@ -78,7 +78,7 @@ private Model(Repository repository) {
     /**
      * Returns the news feed for the currently selected category.
      */
-    public Observable<RealmResults<NYTimesStory>> getSelectedNewsFeed() {
+    public Flowable<RealmResults<NYTimesStory>> getSelectedNewsFeed() {
         return repository.loadNewsFeed(selectedSection, false);
     }
 
@@ -106,20 +106,14 @@ public void markAsRead(@NonNull String storyId, boolean read) {
     /**
      * Returns the story with the given Id
      */
-    public Observable<NYTimesStory> getStory(@NonNull final String storyId) {
+    public Flowable<NYTimesStory> getStory(@NonNull final String storyId) {
         // Repository is only responsible for loading the data
         // Any validation is done by the model
         // See http://blog.danlew.net/2015/12/08/error-handling-in-rxjava/
         if (TextUtils.isEmpty(storyId)) {
             throw new IllegalArgumentException("Invalid storyId: " + storyId);
         }
-        return repository.loadStory(storyId)
-                .filter(new Func1<NYTimesStory, Boolean>() {
-                    @Override
-                    public Boolean call(NYTimesStory story) {
-                        return story.isValid();
-                    }
-                });
+        return repository.loadStory(storyId).filter(story -> story.isValid());
     }
 
     /**
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Repository.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Repository.java
index ab86adcbac..dc75037989 100644
--- a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Repository.java
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/Repository.java
@@ -24,6 +24,9 @@
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
 
+import io.reactivex.Flowable;
+import io.reactivex.Observable;
+import io.reactivex.subjects.BehaviorSubject;
 import io.realm.Realm;
 import io.realm.RealmResults;
 import io.realm.Sort;
@@ -31,9 +34,6 @@
 import io.realm.examples.newsreader.R;
 import io.realm.examples.newsreader.model.entity.NYTimesStory;
 import io.realm.examples.newsreader.model.network.NYTimesDataLoader;
-import rx.Observable;
-import rx.functions.Func1;
-import rx.subjects.BehaviorSubject;
 import timber.log.Timber;
 
 /**
@@ -51,7 +51,7 @@
     private final NYTimesDataLoader dataLoader;
     private final String apiKey;
     private Map<String, Long> lastNetworkRequest = new HashMap<>();
-    private BehaviorSubject<Boolean> networkLoading = BehaviorSubject.create(false);
+    private BehaviorSubject<Boolean> networkLoading = BehaviorSubject.createDefault(false);
 
     @UiThread
     public Repository() {
@@ -67,14 +67,14 @@ public Repository() {
      */
     @UiThread
     public Observable<Boolean> networkInUse() {
-        return networkLoading.asObservable();
+        return networkLoading.hide();
     }
 
     /**
      * Loads the news feed as well as all future updates.
      */
     @UiThread
-    public Observable<RealmResults<NYTimesStory>> loadNewsFeed(@NonNull String sectionKey, boolean forceReload) {
+    public Flowable<RealmResults<NYTimesStory>> loadNewsFeed(@NonNull String sectionKey, boolean forceReload) {
         // Start loading data from the network if needed
         // It will put all data into Realm
         if (forceReload || timeSinceLastNetworkRequest(sectionKey) > MINIMUM_NETWORK_WAIT_SEC) {
@@ -84,9 +84,10 @@ public Repository() {
 
         // Return the data in Realm. The query result will be automatically updated when the network requests
         // save data in Realm
-        return realm.where(NYTimesStory.class).equalTo(NYTimesStory.API_SECTION, sectionKey)
+        return realm.where(NYTimesStory.class)
+                .equalTo(NYTimesStory.API_SECTION, sectionKey)
                 .findAllSortedAsync(NYTimesStory.PUBLISHED_DATE, Sort.DESCENDING)
-                .asObservable();
+                .asFlowable();
     }
 
     private long timeSinceLastNetworkRequest(@NonNull String sectionKey) {
@@ -128,15 +129,10 @@ public void onError(Throwable throwable) {
      * Returns story details
      */
     @UiThread
-    public Observable<NYTimesStory> loadStory(final String storyId) {
+    public Flowable<NYTimesStory> loadStory(final String storyId) {
         return realm.where(NYTimesStory.class).equalTo(NYTimesStory.URL, storyId).findFirstAsync()
-                .<NYTimesStory>asObservable()
-                .filter(new Func1<NYTimesStory, Boolean>() {
-                    @Override
-                    public Boolean call(NYTimesStory story) {
-                        return story.isLoaded();
-                    }
-                });
+                .<NYTimesStory>asFlowable()
+                .filter(story -> story.isLoaded());
     }
 
     /**
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/NYTimesDataLoader.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/NYTimesDataLoader.java
index c9be445097..7e3d6a4624 100644
--- a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/NYTimesDataLoader.java
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/NYTimesDataLoader.java
@@ -24,15 +24,15 @@
 import java.util.List;
 import java.util.Locale;
 
+import io.reactivex.android.schedulers.AndroidSchedulers;
+import io.reactivex.functions.Consumer;
+import io.reactivex.schedulers.Schedulers;
+import io.reactivex.subjects.BehaviorSubject;
 import io.realm.Realm;
 import io.realm.examples.newsreader.model.entity.NYTimesStory;
-import retrofit.JacksonConverterFactory;
-import retrofit.Retrofit;
-import retrofit.RxJavaCallAdapterFactory;
-import rx.android.schedulers.AndroidSchedulers;
-import rx.functions.Action1;
-import rx.schedulers.Schedulers;
-import rx.subjects.BehaviorSubject;
+import retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory;
+import retrofit2.converter.jackson.JacksonConverterFactory;
+import retrofit2.Retrofit;
 import timber.log.Timber;
 
 /**
@@ -49,7 +49,7 @@
 
     public NYTimesDataLoader() {
         Retrofit retrofit = new Retrofit.Builder()
-                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
                 .addConverterFactory(JacksonConverterFactory.create())
                 .baseUrl("http://api.nytimes.com/")
                 .build();
@@ -69,19 +69,13 @@ private void loadNextSection(@NonNull final String sectionKey) {
         nyTimesService.topStories(sectionKey, apiKey)
                 .subscribeOn(Schedulers.io())
                 .observeOn(AndroidSchedulers.mainThread())
-                .subscribe(new Action1<NYTimesResponse<List<NYTimesStory>>>() {
-                    @Override
-                    public void call(NYTimesResponse<List<NYTimesStory>> response) {
-                        Timber.d("Success - Data received: %s", sectionKey);
-                        processAndAddData(realm, response.section, response.results);
-                        networkInUse.onNext(false);
-                    }
-                }, new Action1<Throwable>() {
-                    @Override
-                    public void call(Throwable throwable) {
-                        networkInUse.onNext(false);
-                        Timber.d("Failure: Data not loaded: %s - %s", sectionKey, throwable.toString());
-                    }
+                .subscribe(response -> {
+                    Timber.d("Success - Data received: %s", sectionKey);
+                    processAndAddData(realm, response.section, response.results);
+                    networkInUse.onNext(false);
+                }, throwable -> {
+                    networkInUse.onNext(false);
+                    Timber.d("Failure: Data not loaded: %s - %s", sectionKey, throwable.toString());
                 });
     }
 
@@ -89,35 +83,27 @@ public void call(Throwable throwable) {
     private void processAndAddData(final Realm realm, final String sectionKey, final List<NYTimesStory> stories) {
         if (stories.isEmpty()) return;
 
-        realm.executeTransactionAsync(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                for (NYTimesStory story : stories) {
-                    Date parsedPublishedDate = inputDateFormat.parse(story.getPublishedDate(), new ParsePosition(0));
-                    story.setSortTimeStamp(parsedPublishedDate.getTime());
-                    story.setPublishedDate(outputDateFormat.format(parsedPublishedDate));
+        realm.executeTransactionAsync(r -> {
+            for (NYTimesStory story : stories) {
+                Date parsedPublishedDate = inputDateFormat.parse(story.getPublishedDate(), new ParsePosition(0));
+                story.setSortTimeStamp(parsedPublishedDate.getTime());
+                story.setPublishedDate(outputDateFormat.format(parsedPublishedDate));
 
-                    // Find existing story in Realm (if any)
-                    // If it exists, we need to merge the local state with the remote, because the local state
-                    // contains more info than is available on the server.
-                    NYTimesStory persistedStory = realm.where(NYTimesStory.class).equalTo(NYTimesStory.URL, story.getUrl()).findFirst();
-                    if (persistedStory != null) {
-                        // Only local state is the `read` boolean.
-                        story.setRead(persistedStory.isRead());
-                   }
+                // Find existing story in Realm (if any)
+                // If it exists, we need to merge the local state with the remote, because the local state
+                // contains more info than is available on the server.
+                NYTimesStory persistedStory = r.where(NYTimesStory.class).equalTo(NYTimesStory.URL, story.getUrl()).findFirst();
+                if (persistedStory != null) {
+                    // Only local state is the `read` boolean.
+                    story.setRead(persistedStory.isRead());
+                }
 
-                    // Only create or update the local story if needed
-                    if (persistedStory == null || !persistedStory.getUpdatedDate().equals(story.getUpdatedDate())) {
-                        story.setApiSection(sectionKey);
-                        realm.copyToRealmOrUpdate(story);
-                    }
+                // Only create or update the local story if needed
+                if (persistedStory == null || !persistedStory.getUpdatedDate().equals(story.getUpdatedDate())) {
+                    story.setApiSection(sectionKey);
+                    r.copyToRealmOrUpdate(story);
                 }
             }
-        }, new Realm.Transaction.OnError() {
-            @Override
-            public void onError(Throwable throwable) {
-                Timber.e(throwable, "Could not save data");
-            }
-        });
+        }, throwable -> Timber.e(throwable, "Could not save data"));
     }
 }
\ No newline at end of file
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/NYTimesService.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/NYTimesService.java
index a234cfede0..41c799c578 100644
--- a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/NYTimesService.java
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/NYTimesService.java
@@ -19,11 +19,11 @@
 
 import java.util.List;
 
+import io.reactivex.Observable;
 import io.realm.examples.newsreader.model.entity.NYTimesStory;
-import retrofit.http.GET;
-import retrofit.http.Path;
-import retrofit.http.Query;
-import rx.Observable;
+import retrofit2.http.GET;
+import retrofit2.http.Path;
+import retrofit2.http.Query;
 
 /**
  * Retrofit interface for the New York Times WebService
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/RealmListNYTimesMultimediumDeserializer.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/RealmListNYTimesMultimediumDeserializer.java
index 9db49e3b1f..e0626af31f 100644
--- a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/RealmListNYTimesMultimediumDeserializer.java
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/model/network/RealmListNYTimesMultimediumDeserializer.java
@@ -32,17 +32,17 @@
 
 public class RealmListNYTimesMultimediumDeserializer extends JsonDeserializer<List<NYTimesMultimedium>> {
 
-    ObjectMapper objectMapper;
+    private ObjectMapper objectMapper;
 
     public RealmListNYTimesMultimediumDeserializer() {
         objectMapper = new ObjectMapper();
     }
 
     @Override
-    public List<NYTimesMultimedium> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
+    public List<NYTimesMultimedium> deserialize(JsonParser parser, DeserializationContext context) throws IOException {
         RealmList<NYTimesMultimedium> list = new RealmList<>();
 
-        TreeNode treeNode = jp.getCodec().readTree(jp);
+        TreeNode treeNode = parser.getCodec().readTree(parser);
         if (!(treeNode instanceof ArrayNode)) {
             return list;
         }
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsActivity.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsActivity.java
index 5222153ecf..99e6d0b499 100644
--- a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsActivity.java
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsActivity.java
@@ -58,7 +58,7 @@ protected void onCreate(Bundle savedInstanceState) {
         // Setup initial views
         setContentView(R.layout.activity_details);
         ButterKnife.bind(this);
-        toolbar = (Toolbar) findViewById(R.id.toolbar);
+        toolbar = findViewById(R.id.toolbar);
         setSupportActionBar(toolbar);
         loaderView.setVisibility(View.VISIBLE);
 
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsPresenter.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsPresenter.java
index 0efde8359c..d5c36c1e7c 100644
--- a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsPresenter.java
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/details/DetailsPresenter.java
@@ -18,14 +18,12 @@
 
 import java.util.concurrent.TimeUnit;
 
+import io.reactivex.Observable;
+import io.reactivex.android.schedulers.AndroidSchedulers;
+import io.reactivex.disposables.CompositeDisposable;
+import io.reactivex.disposables.Disposable;
 import io.realm.examples.newsreader.model.Model;
-import io.realm.examples.newsreader.model.entity.NYTimesStory;
 import io.realm.examples.newsreader.ui.Presenter;
-import rx.Observable;
-import rx.Subscription;
-import rx.android.schedulers.AndroidSchedulers;
-import rx.functions.Action1;
-import rx.subscriptions.CompositeSubscription;
 
 /**
  * Presenter class for controlling the Main Activity
@@ -35,7 +33,7 @@
     private final DetailsActivity view;
     private final Model model;
     private final String storyId;
-    private CompositeSubscription subscriptions;
+    private CompositeDisposable compositeDisposable = new CompositeDisposable();
 
     public DetailsPresenter(DetailsActivity detailsActivity, Model model, String storyId) {
         this.storyId = storyId;
@@ -51,32 +49,24 @@ public void onCreate() {
     @Override
     public void onResume() {
         // Show story details
-        Subscription detailsSubscription = model.getStory(storyId)
-                .subscribe(new Action1<NYTimesStory>() {
-                    @Override
-                    public void call(NYTimesStory story) {
-                        view.hideLoader();
-                        view.showStory(story);
-                        view.setRead(story.isRead());
-                    }
+        Disposable detailsDisposable = model.getStory(storyId)
+                .subscribe(story -> {
+                    view.hideLoader();
+                    view.showStory(story);
+                    view.setRead(story.isRead());
                 });
+        compositeDisposable.add(detailsDisposable);
 
         // Mark story as read if screen is visible for 2 seconds
-        Subscription timerSubscription = Observable.timer(2, TimeUnit.SECONDS)
+        Disposable timberDisposable = Observable.timer(2, TimeUnit.SECONDS)
                 .observeOn(AndroidSchedulers.mainThread())
-                .subscribe(new Action1<Long>() {
-                    @Override
-                    public void call(Long aLong) {
-                        model.markAsRead(storyId, true);
-                    }
-                });
-        
-        subscriptions = new CompositeSubscription(detailsSubscription, timerSubscription);
+                .subscribe(aLong -> model.markAsRead(storyId, true));
+        compositeDisposable.add(timberDisposable);
     }
 
     @Override
     public void onPause() {
-        subscriptions.unsubscribe();
+        compositeDisposable.clear();
     }
 
     @Override
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainActivity.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainActivity.java
index fd6030a7c0..41b2d41c10 100644
--- a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainActivity.java
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainActivity.java
@@ -58,26 +58,16 @@ protected void onCreate(Bundle savedInstanceState) {
         // Setup initial views
         setContentView(R.layout.activity_main);
         ButterKnife.bind(this);
-        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
+        Toolbar toolbar = findViewById(R.id.toolbar);
         setSupportActionBar(toolbar);
         //noinspection ConstantConditions
         getSupportActionBar().setDisplayShowTitleEnabled(false);
 
         adapter = null;
-        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
-            @Override
-            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-                presenter.listItemSelected(position);
-            }
-        });
+        listView.setOnItemClickListener((parent, view, position, id) -> presenter.listItemSelected(position));
         listView.setEmptyView(getLayoutInflater().inflate(R.layout.common_emptylist, listView, false));
 
-        refreshView.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
-            @Override
-            public void onRefresh() {
-                presenter.refreshList();
-            }
-        });
+        refreshView.setOnRefreshListener(() -> presenter.refreshList());
         progressBar.setVisibility(View.INVISIBLE);
 
         // After setup, notify presenter
diff --git a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainPresenter.java b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainPresenter.java
index e9d3a840f4..96cd119a4f 100644
--- a/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainPresenter.java
+++ b/examples/newsreaderExample/src/main/java/io/realm/examples/newsreader/ui/main/MainPresenter.java
@@ -21,17 +21,14 @@
 
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.Comparator;
 import java.util.List;
 import java.util.Map;
 
-import io.realm.RealmResults;
+import io.reactivex.disposables.Disposable;
 import io.realm.examples.newsreader.model.Model;
 import io.realm.examples.newsreader.model.entity.NYTimesStory;
 import io.realm.examples.newsreader.ui.Presenter;
 import io.realm.examples.newsreader.ui.details.DetailsActivity;
-import rx.Subscription;
-import rx.functions.Action1;
 
 /**
  * Presenter class for controlling the Main Activity
@@ -42,8 +39,8 @@
     private final Model model;
     private List<NYTimesStory> storiesData;
     private Map<String, String> sections;
-    private Subscription loaderSubscription;
-    private Subscription listDataSubscription;
+    private Disposable loaderDisposable;
+    private Disposable listDataDisposable;
 
     public MainPresenter(MainActivity mainActivity, Model model) {
         this.view = mainActivity;
@@ -55,34 +52,24 @@ public void onCreate() {
         sections = model.getSections();
         // Sort sections alphabetically, but always have Home at the top
         ArrayList<String> sectionList = new ArrayList<>(sections.values());
-        Collections.sort(sectionList, new Comparator<String>() {
-            @Override
-            public int compare(String lhs, String rhs) {
-                if (lhs.equals("Home")) return -1;
-                if (rhs.equals("Home")) return 1;
-                return lhs.compareToIgnoreCase(rhs);
-            }
+        Collections.sort(sectionList, (lhs, rhs) -> {
+            if (lhs.equals("Home")) return -1;
+            if (rhs.equals("Home")) return 1;
+            return lhs.compareToIgnoreCase(rhs);
         });
         view.configureToolbar(sectionList);
     }
 
     @Override
     public void onResume() {
-        loaderSubscription = model.isNetworkUsed()
-                .subscribe(new Action1<Boolean>() {
-                    @Override
-                    public void call(Boolean networkInUse) {
-                        view.showNetworkLoading(networkInUse);
-                    }
-                });
-
+        loaderDisposable = model.isNetworkUsed().subscribe(networkInUse -> view.showNetworkLoading(networkInUse));
         sectionSelected(model.getCurrentSectionKey());
     }
 
     @Override
     public void onPause() {
-        loaderSubscription.unsubscribe();
-        listDataSubscription.unsubscribe();
+        loaderDisposable.dispose();
+        listDataDisposable.dispose();
     }
 
     @Override
@@ -111,16 +98,13 @@ public void titleSpinnerSectionSelected(@NonNull String sectionLabel) {
 
     private void sectionSelected(@NonNull String sectionKey) {
         model.selectSection(sectionKey);
-        if (listDataSubscription != null) {
-            listDataSubscription.unsubscribe();
+        if (listDataDisposable != null) {
+            listDataDisposable.dispose();
         }
-        listDataSubscription = model.getSelectedNewsFeed()
-                .subscribe(new Action1<RealmResults<NYTimesStory>>() {
-                    @Override
-                    public void call(RealmResults<NYTimesStory> stories) {
-                        storiesData = stories;
-                        view.showList(stories);
-                    }
+        listDataDisposable = model.getSelectedNewsFeed()
+                .subscribe(stories -> {
+                    storiesData = stories;
+                    view.showList(stories);
                 });
     }
 }
diff --git a/examples/objectServerExample/README.md b/examples/objectServerExample/README.md
index f9ec43ab2d..d3c8558940 100644
--- a/examples/objectServerExample/README.md
+++ b/examples/objectServerExample/README.md
@@ -1,14 +1,20 @@
 # Using this example
 
-This example shows a minimal example on how to connect to and use the
+This example is a minimal demonstration of how to connect to and use the
 Realm Object Server to synchronize changes between devices.
 
-The example will assume that the Object Server is running on the machine
-building the example and the IP address will automatically be injected
-into the build configuration.
+The example assumes that the Object Server is running on the machine
+that built the application: The build machine IP address is automatically
+injected into the build configuration.
 
-If this for some reasons does not work, please insert the IP Address into
-the `build.gradle` accordingly.
+To use a different ObjectServer, simply put the server IP Address into
+the `build.gradle`, as indicated in the comments, on the lines like this:
+
+    buildConfigField "String", "OBJECT_SERVER_IP", "\"${host}\""
+
+For instance:
+
+    buildConfigField "String", "OBJECT_SERVER_IP", "192.168.0.1"
 
 To read more about the Realm Object Server and how to deploy it, see
 https://realm.io/news/introducing-realm-mobile-platform/
diff --git a/examples/objectServerExample/build.gradle b/examples/objectServerExample/build.gradle
index e3080cda9f..722e362451 100644
--- a/examples/objectServerExample/build.gradle
+++ b/examples/objectServerExample/build.gradle
@@ -1,5 +1,4 @@
 apply plugin: 'com.android.application'
-apply plugin: 'android-command'
 apply plugin: 'realm-android'
 
 // Credit: http://jeremie-martinez.com/2015/05/05/inject-host-gradle/
@@ -29,7 +28,7 @@ android {
     defaultConfig {
         applicationId 'io.realm.examples.objectserver'
         targetSdkVersion rootProject.sdkVersion
-        minSdkVersion 15
+        minSdkVersion 16
         versionCode 1
         versionName "1.0"
     }
@@ -43,16 +42,14 @@ android {
         def host = getIP()
         debug {
             buildConfigField "String", "OBJECT_SERVER_IP", "\"${host}\""
+            minifyEnabled true
         }
         release {
-            minifyEnabled false
             buildConfigField "String", "OBJECT_SERVER_IP", "\"${host}\""
+            minifyEnabled true
+            signingConfig signingConfigs.debug
         }
     }
-
-    command {
-        events 2000
-    }
 }
 
 realm {
@@ -60,8 +57,10 @@ realm {
 }
 
 dependencies {
-    compile 'com.android.support:support-v4:25.2.0'
-    compile 'com.android.support:design:25.2.0'
-    compile 'com.jakewharton:butterknife:8.5.1'
+    implementation 'com.android.support:support-v4:26.0.1'
+    implementation 'com.android.support:appcompat-v7:26.0.1'
+    implementation 'com.android.support:design:26.0.1'
+    implementation 'me.zhanghai.android.materialprogressbar:library:1.3.0'
+    implementation 'com.jakewharton:butterknife:8.5.1'
     annotationProcessor 'com.jakewharton:butterknife-compiler:8.5.1'
 }
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
index 97c67d2443..1baf3a9e2f 100644
--- a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/CounterActivity.java
@@ -17,89 +17,122 @@
 package io.realm.examples.objectserver;
 
 import android.content.Intent;
+import android.graphics.PorterDuff;
 import android.os.Bundle;
+import android.support.annotation.ColorRes;
 import android.support.v7.app.AppCompatActivity;
 import android.view.Menu;
 import android.view.MenuItem;
+import android.view.View;
 import android.widget.TextView;
 
 import java.util.Locale;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import javax.annotation.Nonnull;
 
 import butterknife.BindView;
 import butterknife.ButterKnife;
 import butterknife.OnClick;
+import io.realm.Progress;
+import io.realm.ProgressListener;
+import io.realm.ProgressMode;
 import io.realm.Realm;
 import io.realm.RealmChangeListener;
 import io.realm.SyncConfiguration;
+import io.realm.SyncManager;
+import io.realm.SyncSession;
 import io.realm.SyncUser;
 import io.realm.examples.objectserver.model.CRDTCounter;
+import me.zhanghai.android.materialprogressbar.MaterialProgressBar;
 
 public class CounterActivity extends AppCompatActivity {
-
     private static final String REALM_URL = "realm://" + BuildConfig.OBJECT_SERVER_IP + ":9080/~/default";
 
+    private final ProgressListener downloadListener = new ProgressListener() {
+        @Override
+        public void onChange(@Nonnull Progress progress) {
+            downloadingChanges.set(!progress.isTransferComplete());
+            runOnUiThread(updateProgressBar);
+        }
+    };
+    private final ProgressListener uploadListener = new ProgressListener() {
+        @Override
+        public void onChange(@Nonnull Progress progress) {
+            uploadingChanges.set(!progress.isTransferComplete());
+            runOnUiThread(updateProgressBar);
+        }
+    };
+    private final Runnable updateProgressBar = new Runnable() {
+        @Override
+        public void run() {
+            updateProgressBar(downloadingChanges.get(), uploadingChanges.get());
+        }
+    };
+
+    private final AtomicBoolean downloadingChanges = new AtomicBoolean(false);
+    private final AtomicBoolean uploadingChanges = new AtomicBoolean(false);
+
     private Realm realm;
-    private CRDTCounter counter;
+    private SyncSession session;
     private SyncUser user;
 
     @BindView(R.id.text_counter) TextView counterView;
+    @BindView(R.id.progressbar) MaterialProgressBar progressBar;
+    private CRDTCounter counter; // Keep strong reference to counter to keep change listeners alive.
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_counter);
         ButterKnife.bind(this);
-
-        // Check if we have a valid user, otherwise redirect to login
-        if (SyncUser.currentUser() == null) {
-            gotoLoginActivity();
-        }
     }
 
     @Override
     protected void onStart() {
         super.onStart();
-        user = SyncUser.currentUser();
-        if (user != null) {
-            // Create a RealmConfiguration for our user
-            SyncConfiguration config = new SyncConfiguration.Builder(user, REALM_URL)
-                    .initialData(new Realm.Transaction() {
-                        @Override
-                        public void execute(Realm realm) {
-                            realm.createObject(CRDTCounter.class, 1);
-                        }
-                    })
-                    .build();
-
-            // This will automatically sync all changes in the background for as long as the Realm is open
-            realm = Realm.getInstance(config);
-
-            counter = realm.where(CRDTCounter.class).findFirstAsync();
-            counter.addChangeListener(new RealmChangeListener<CRDTCounter>() {
-                @Override
-                public void onChange(CRDTCounter counter) {
-                    if (counter.isValid()) {
-                        counterView.setText(String.format(Locale.US, "%d", counter.getCount()));
-                    } else {
-                        counterView.setText("-");
+        user = getLoggedInUser();
+        if (user == null) { return; }
+
+        // Create a RealmConfiguration for our user
+        SyncConfiguration config = new SyncConfiguration.Builder(user, REALM_URL)
+                .initialData(new Realm.Transaction() {
+                    @Override
+                    public void execute(@Nonnull Realm realm) {
+                        realm.createObject(CRDTCounter.class, user.getIdentity());
                     }
-                }
-            });
-            counterView.setText("0");
-        }
+                })
+                .build();
+
+        // This will automatically sync all changes in the background for as long as the Realm is open
+        realm = Realm.getInstance(config);
+
+        counterView.setText("-");
+        counter = realm.where(CRDTCounter.class).equalTo("name", user.getIdentity()).findFirstAsync();
+        counter.addChangeListener(new RealmChangeListener<CRDTCounter>() {
+            @Override
+            public void onChange(@Nonnull CRDTCounter counter) {
+                counterView.setText((!counter.isValid()) ? "-" : String.format(Locale.US, "%d", counter.getCount()));
+            }
+        });
+
+        // Setup progress listeners for indeterminate progress bars
+        session = SyncManager.getSession(config);
+        session.addDownloadProgressListener(ProgressMode.INDEFINITELY, downloadListener);
+        session.addUploadProgressListener(ProgressMode.INDEFINITELY, uploadListener);
     }
 
     @Override
     protected void onStop() {
         super.onStop();
+        if (session != null) {
+            session.removeProgressListener(downloadListener);
+            session.removeProgressListener(uploadListener);
+            session = null;
+        }
         closeRealm();
         user = null;
-    }
-
-    private void closeRealm() {
-        if (realm != null && !realm.isClosed()) {
-            realm.close();
-        }
+        counter = null;
     }
 
     @Override
@@ -114,7 +147,7 @@ public boolean onOptionsItemSelected(MenuItem item) {
             case R.id.action_logout:
                 closeRealm();
                 user.logout();
-                gotoLoginActivity();
+                user = getLoggedInUser();
                 return true;
 
             default:
@@ -132,20 +165,52 @@ public void decrementCounter() {
         adjustCounter(-1);
     }
 
+    private void updateProgressBar(boolean downloading, boolean uploading) {
+        @ColorRes int color = android.R.color.black;
+        int visibility = View.VISIBLE;
+        if (downloading && uploading) {
+            color = R.color.progress_both;
+        } else if (downloading) {
+            color = R.color.progress_download;
+        } else if (uploading) {
+            color = R.color.progress_upload;
+        } else {
+            visibility = View.GONE;
+        }
+        progressBar.getIndeterminateDrawable().setColorFilter(getResources().getColor(color), PorterDuff.Mode.SRC_IN);
+        progressBar.setVisibility(visibility);
+    }
+
     private void adjustCounter(final int adjustment) {
         // A synchronized Realm can get written to at any point in time, so doing synchronous writes on the UI
-        // thread is HIGHLY discouraged as it might block longer than intended. Only use async transactions.
+        // thread is HIGHLY discouraged as it might block longer than intended. Use only async transactions.
         realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
-            public void execute(Realm realm) {
+            public void execute(@Nonnull Realm realm) {
                 CRDTCounter counter = realm.where(CRDTCounter.class).findFirst();
-                counter.add(adjustment);
+                if (counter != null) {
+                    counter.incrementCounter(adjustment);
+                }
             }
         });
     }
 
-    private void gotoLoginActivity() {
-        Intent intent = new Intent(this, LoginActivity.class);
-        startActivity(intent);
+    private SyncUser getLoggedInUser() {
+        SyncUser user = null;
+
+        try { user = SyncUser.currentUser(); }
+        catch (IllegalStateException ignore) { }
+
+        if (user == null) {
+            startActivity(new Intent(this, LoginActivity.class));
+        }
+
+        return user;
+    }
+
+    private void closeRealm() {
+        if (realm != null && !realm.isClosed()) {
+            realm.close();
+        }
     }
 }
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java
index 5ce56afb27..9bf5479f15 100644
--- a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/LoginActivity.java
@@ -24,16 +24,17 @@
 import android.widget.EditText;
 import android.widget.Toast;
 
+import javax.annotation.Nonnull;
+
 import butterknife.BindView;
 import butterknife.ButterKnife;
 import io.realm.SyncCredentials;
 import io.realm.ObjectServerError;
 import io.realm.SyncUser;
-import io.realm.UserStore;
 
-import static io.realm.ErrorCode.UNKNOWN_ACCOUNT;
 
 public class LoginActivity extends AppCompatActivity {
+    private static final String REALM_AUTH_URL = "http://" + BuildConfig.OBJECT_SERVER_IP + ":9080/auth";
 
     @BindView(R.id.input_username) EditText username;
     @BindView(R.id.input_password) EditText password;
@@ -77,16 +78,15 @@ public void login(boolean createUser) {
         String password = this.password.getText().toString();
 
         SyncCredentials creds = SyncCredentials.usernamePassword(username, password, createUser);
-        String authUrl = "http://" + BuildConfig.OBJECT_SERVER_IP + ":9080/auth";
-        SyncUser.Callback callback = new SyncUser.Callback() {
+        SyncUser.Callback<SyncUser> callback = new SyncUser.Callback<SyncUser>() {
             @Override
-            public void onSuccess(SyncUser user) {
+            public void onSuccess(@Nonnull SyncUser user) {
                 progressDialog.dismiss();
                 onLoginSuccess();
             }
 
             @Override
-            public void onError(ObjectServerError error) {
+            public void onError(@Nonnull ObjectServerError error) {
                 progressDialog.dismiss();
                 String errorMsg;
                 switch (error.getErrorCode()) {
@@ -103,7 +103,7 @@ public void onError(ObjectServerError error) {
             }
         };
 
-        SyncUser.loginAsync(creds, authUrl, callback);
+        SyncUser.loginAsync(creds, REALM_AUTH_URL, callback);
     }
 
     @Override
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/MyApplication.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/MyApplication.java
index 8fb13a829b..e4511eeb78 100644
--- a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/MyApplication.java
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/MyApplication.java
@@ -31,7 +31,7 @@ public void onCreate() {
 
         // Enable full log output when debugging
         if (BuildConfig.DEBUG) {
-            RealmLog.setLevel(Log.VERBOSE);
+            RealmLog.setLevel(Log.DEBUG);
         }
     }
 }
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/model/CRDTCounter.java b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/model/CRDTCounter.java
index 93096e3ac6..0bca8fd53c 100644
--- a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/model/CRDTCounter.java
+++ b/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/model/CRDTCounter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2016 Realm Inc.
+ * Copyright 2017 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,38 +13,30 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package io.realm.examples.objectserver.model;
 
-import io.realm.RealmList;
+import io.realm.MutableRealmInteger;
 import io.realm.RealmObject;
 import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.Required;
 
 /**
- * Counter class that is eventually consistent. Two devices can simultaneous increment this and eventually reach
- * the same value.
- *
- * @see <href ref="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">Conflict Free Replicated Data Structures</href>
+ * A named, conflict-free replicated data-type.
  */
 public class CRDTCounter extends RealmObject {
-
     @PrimaryKey
-    private long id;
-    private RealmList<CounterOperation> operations;
+    private String name;
+
+    @Required
+    public final MutableRealmInteger counter = MutableRealmInteger.valueOf(0L);
 
-    public CRDTCounter() {
-        // Required by Realm
-    }
+    // Required for Realm
+    public CRDTCounter() {}
 
-    public CRDTCounter(long id) {
-        this.id = id;
-    }
+    public CRDTCounter(String name) { this.name = name; }
 
-    public long getCount() {
-        return operations.where().sum("adjustment").longValue();
-    }
+    public String getName() { return name; }
 
-    public void add(long val) {
-        operations.add(new CounterOperation(val));
-    }
+    public long getCount() { return counter.get().longValue(); }
+    public void incrementCounter(long delta) { counter.increment(delta); }
 }
diff --git a/examples/objectServerExample/src/main/res/layout/activity_counter.xml b/examples/objectServerExample/src/main/res/layout/activity_counter.xml
index 62127eca0d..a1300b2123 100644
--- a/examples/objectServerExample/src/main/res/layout/activity_counter.xml
+++ b/examples/objectServerExample/src/main/res/layout/activity_counter.xml
@@ -1,19 +1,20 @@
 <RelativeLayout
     xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
     android:layout_width="match_parent"
-    android:layout_height="match_parent">
+    android:layout_height="match_parent"
+    >
 
     <LinearLayout
         android:layout_width="match_parent"
         android:layout_height="match_parent"
-        android:orientation="vertical"
-        android:weightSum="1.0">
+        android:orientation="vertical">
 
         <View
             android:id="@+id/upper"
             android:layout_width="match_parent"
             android:layout_height="0dp"
-            android:layout_weight="0.5"
+            android:layout_weight="1"
             android:background="@drawable/button_counter">
         </View>
 
@@ -21,7 +22,7 @@
             android:id="@+id/lower"
             android:layout_width="match_parent"
             android:layout_height="0dp"
-            android:layout_weight="0.5"
+            android:layout_weight="1"
             android:background="@drawable/button_counter">
         </View>
     </LinearLayout>
@@ -34,4 +35,15 @@
         android:fontFamily="sans-serif-light"
         android:textSize="160sp"/>
 
+    <me.zhanghai.android.materialprogressbar.MaterialProgressBar
+        android:id="@+id/progressbar"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_gravity="top"
+        android:indeterminate="true"
+        app:mpb_progressStyle="horizontal"
+        android:visibility="gone"
+        style="@style/Widget.MaterialProgressBar.ProgressBar.Horizontal.NoPadding"
+        />
+
 </RelativeLayout>
diff --git a/examples/objectServerExample/src/main/res/layout/activity_login.xml b/examples/objectServerExample/src/main/res/layout/activity_login.xml
index 142ad539e1..375cdbca98 100644
--- a/examples/objectServerExample/src/main/res/layout/activity_login.xml
+++ b/examples/objectServerExample/src/main/res/layout/activity_login.xml
@@ -17,6 +17,7 @@
             android:layout_height="72dp"
             android:layout_gravity="center_horizontal"
             android:layout_marginBottom="24dp"
+            android:contentDescription="@string/realm_logo"
             android:src="@drawable/logo"/>
 
         <android.support.design.widget.TextInputLayout
@@ -29,7 +30,7 @@
                 android:id="@+id/input_username"
                 android:layout_width="match_parent"
                 android:layout_height="wrap_content"
-                android:hint="Username"
+                android:hint="@string/username"
                 android:inputType="text"/>
         </android.support.design.widget.TextInputLayout>
 
@@ -43,7 +44,7 @@
                 android:id="@+id/input_password"
                 android:layout_width="match_parent"
                 android:layout_height="wrap_content"
-                android:hint="Password"
+                android:hint="@string/password"
                 android:inputType="textPassword"/>
         </android.support.design.widget.TextInputLayout>
 
@@ -54,7 +55,7 @@
             android:layout_marginBottom="12dp"
             android:layout_marginTop="24dp"
             android:padding="12dp"
-            android:text="Login" />
+            android:text="@string/login" />
 
         <android.support.v7.widget.AppCompatButton
             android:id="@+id/button_create"
@@ -62,6 +63,6 @@
             android:layout_height="wrap_content"
             android:layout_marginBottom="24dp"
             android:padding="12dp"
-            android:text="Create account and login" />
+            android:text="@string/create_account" />
     </LinearLayout>
-</ScrollView>
\ No newline at end of file
+</ScrollView>
diff --git a/examples/objectServerExample/src/main/res/menu/menu_counter.xml b/examples/objectServerExample/src/main/res/menu/menu_counter.xml
index 858fd2e7e8..d0e93f2e8b 100644
--- a/examples/objectServerExample/src/main/res/menu/menu_counter.xml
+++ b/examples/objectServerExample/src/main/res/menu/menu_counter.xml
@@ -5,7 +5,7 @@
     <item
         android:id="@+id/action_logout"
         android:orderInCategory="100"
-        android:title="Logout"
+        android:title="@string/logout"
         android:icon="@drawable/ic_exit_to_app_white_24dp"
         app:showAsAction="always"/>
 </menu>
diff --git a/examples/objectServerExample/src/main/res/values/realm_colors.xml b/examples/objectServerExample/src/main/res/values/realm_colors.xml
index aada8ea195..3d435a5c44 100644
--- a/examples/objectServerExample/src/main/res/values/realm_colors.xml
+++ b/examples/objectServerExample/src/main/res/values/realm_colors.xml
@@ -1,12 +1,12 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
-    // Grays
+    <!-- Grays -->
     <color name="charcoal">#1C233F</color>
     <color name="elephant">#9A9BA5</color>
     <color name="elephant_half">#b1b3bf</color>
     <color name="dove">#EBEBF2</color>
 
-    // Orb colors
+    <!-- Orb colors -->
     <color name="ultramarine">#39477F</color>
     <color name="indigo">#59569E</color>
     <color name="grape_jelly">#9A59A5</color>
@@ -16,8 +16,13 @@
     <color name="peach">#FC9F95</color>
     <color name="melon">#FCC397</color>
 
-    // Material adjustments
+    <!-- Material adjustments -->
     <color name="flamingo_darker">#d64881</color>
     <color name="touch_area_pressed">#dadada</color>
 
+    <!-- Progress bar colors -->
+    <color name="progress_upload">#EF5350</color>
+    <color name="progress_download">#9CCC65</color>
+    <color name="progress_both">#FFA726</color>
+
 </resources>
\ No newline at end of file
diff --git a/examples/objectServerExample/src/main/res/values/strings.xml b/examples/objectServerExample/src/main/res/values/strings.xml
index 10e43bd0a9..b4f90b3676 100644
--- a/examples/objectServerExample/src/main/res/values/strings.xml
+++ b/examples/objectServerExample/src/main/res/values/strings.xml
@@ -1,4 +1,10 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
     <string name="app_name">Object Server Example</string>
+    <string name="realm_logo">Realm Logo</string>
+    <string name="username">Username</string>
+    <string name="password">Password</string>
+    <string name="create_account">Create account and login</string>
+    <string name="login">Login</string>
+    <string name="logout">Logout</string>
 </resources>
diff --git a/examples/rxJavaExample/build.gradle b/examples/rxJavaExample/build.gradle
index 9a916ede8a..d6269c5c59 100644
--- a/examples/rxJavaExample/build.gradle
+++ b/examples/rxJavaExample/build.gradle
@@ -1,5 +1,4 @@
 apply plugin: 'com.android.application'
-apply plugin: 'android-command'
 apply plugin: 'realm-android'
 
 android {
@@ -19,18 +18,28 @@ android {
 
     buildTypes {
         release {
+            // FIXME: Fix the proguard with 3rd party libs
             minifyEnabled false
+            signingConfig signingConfigs.debug
         }
     }
 
-    command {
-        events 2000
+    packagingOptions {
+        exclude 'META-INF/LICENSE'
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
     }
 }
 
 dependencies {
-    compile 'io.reactivex:rxandroid:1.1.0'
-    compile 'io.reactivex:rxjava:1.1.0'
-    compile 'com.jakewharton.rxbinding:rxbinding:0.3.0'
-    compile 'com.squareup.retrofit:retrofit:1.9.0'
+    implementation 'io.reactivex.rxjava2:rxandroid:2.0.1'
+    implementation 'io.reactivex.rxjava2:rxjava:2.1.0'
+    implementation 'com.android.support:appcompat-v7:26.0.1'
+    implementation 'com.jakewharton.rxbinding2:rxbinding:2.0.0'
+    implementation 'com.squareup.retrofit2:adapter-rxjava2:2.3.0'
+    implementation 'com.squareup.retrofit2:converter-jackson:2.3.0'
+    implementation 'com.squareup.retrofit2:retrofit:2.3.0'
 }
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MainActivity.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MainActivity.java
index 91bd8f5d2c..dfd5532375 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MainActivity.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MainActivity.java
@@ -19,7 +19,7 @@
 import android.app.Activity;
 import android.content.Intent;
 import android.os.Bundle;
-import android.view.View;
+import android.support.v7.app.AppCompatActivity;
 import android.view.ViewGroup;
 import android.widget.Button;
 
@@ -31,7 +31,7 @@
 import io.realm.examples.rxjava.retrofit.RetrofitExample;
 import io.realm.examples.rxjava.throttle.ThrottleSearchActivity;
 
-public class MainActivity extends Activity {
+public class MainActivity extends AppCompatActivity {
 
     private ViewGroup container;
     private final TreeMap<String, Class<? extends Activity>> buttons = new TreeMap<String, Class<? extends Activity>>() {{
@@ -45,7 +45,7 @@
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_main);
-        container = (ViewGroup) findViewById(R.id.list);
+        container = findViewById(R.id.list);
         setupButtons();
     }
 
@@ -53,12 +53,7 @@ private void setupButtons() {
         for (final Map.Entry<String, Class<? extends Activity>> entry : buttons.entrySet()) {
             Button button = new Button(this);
             button.setText(entry.getKey());
-            button.setOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View v) {
-                    startActivity(entry.getValue());
-                }
-            });
+            button.setOnClickListener(view -> startActivity(entry.getValue()));
             container.addView(button);
         }
     }
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MyApplication.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MyApplication.java
index 9ac0f17b60..52ed89fdb1 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MyApplication.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/MyApplication.java
@@ -28,7 +28,6 @@
 
 public class MyApplication extends Application {
 
-    private static MyApplication context;
     private static final TreeMap<String, String> testPersons = new TreeMap<>();
     static {
         testPersons.put("Chris", null);
@@ -39,12 +38,12 @@
         testPersons.put("Donn", "donnfelker");
         testPersons.put("Nabil", "nhachicha");
         testPersons.put("Ron", null);
+        testPersons.put("Leonardo", "dalinaum");
     }
 
     @Override
     public void onCreate() {
         super.onCreate();
-        context = this;
         Realm.init(this);
         RealmConfiguration config = new RealmConfiguration.Builder().build();
         Realm.deleteRealm(config);
@@ -54,23 +53,16 @@ public void onCreate() {
 
     // Create test data
     private void createTestData() {
-        final Random r = new Random(42);
+        final Random random = new Random(42);
         Realm realm = Realm.getDefaultInstance();
-        realm.executeTransaction(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                for (Map.Entry<String, String> entry : testPersons.entrySet()) {
-                    Person p = realm.createObject(Person.class);
-                    p.setName(entry.getKey());
-                    p.setGithubUserName(entry.getValue());
-                    p.setAge(r.nextInt(100));
-                }
+        realm.executeTransaction(r -> {
+            for (Map.Entry<String, String> entry : testPersons.entrySet()) {
+                Person p = r.createObject(Person.class);
+                p.setName(entry.getKey());
+                p.setGithubUserName(entry.getValue());
+                p.setAge(random.nextInt(100));
             }
         });
         realm.close();
     }
-
-    public static MyApplication getContext() {
-        return context;
-    }
 }
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/animation/AnimationActivity.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/animation/AnimationActivity.java
index ebcb5e1a05..291c5b5fba 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/animation/AnimationActivity.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/animation/AnimationActivity.java
@@ -16,35 +16,31 @@
 
 package io.realm.examples.rxjava.animation;
 
-import android.app.Activity;
 import android.os.Bundle;
+import android.support.v7.app.AppCompatActivity;
 import android.view.ViewGroup;
 import android.widget.TextView;
 
 import java.util.concurrent.TimeUnit;
 
+import io.reactivex.Flowable;
+import io.reactivex.android.schedulers.AndroidSchedulers;
+import io.reactivex.disposables.Disposable;
 import io.realm.Realm;
-import io.realm.RealmResults;
 import io.realm.examples.rxjava.R;
 import io.realm.examples.rxjava.model.Person;
-import rx.Observable;
-import rx.Subscription;
-import rx.android.schedulers.AndroidSchedulers;
-import rx.functions.Action1;
-import rx.functions.Func1;
-import rx.functions.Func2;
 
-public class AnimationActivity extends Activity {
+public class AnimationActivity extends AppCompatActivity {
 
     private Realm realm;
-    private Subscription subscription;
+    private Disposable disposable;
     private ViewGroup container;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_animations);
-        container = (ViewGroup) findViewById(R.id.list);
+        container = findViewById(R.id.list);
         realm = Realm.getDefaultInstance();
     }
 
@@ -55,34 +51,21 @@ protected void onResume() {
         // Load all persons and start inserting them with 1 sec. intervals.
         // All RealmObject access has to be done on the same thread `findAllAsync` was called on.
         // Warning: This example doesn't handle back pressure well.
-        subscription = realm.where(Person.class).findAllAsync().asObservable()
-                .flatMap(new Func1<RealmResults<Person>, Observable<Person>>() {
-                    @Override
-                    public Observable<Person> call(RealmResults<Person> persons) {
-                        return Observable.from(persons);
-                    }
-                })
-                .zipWith(Observable.interval(1, TimeUnit.SECONDS), new Func2<Person, Long, Person>() {
-                    @Override
-                    public Person call(Person person, Long tick) {
-                        return person;
-                    }
-                })
+        disposable = realm.where(Person.class).findAllAsync().asFlowable()
+                .flatMap(persons -> Flowable.fromIterable(persons))
+                .zipWith(Flowable.interval(1, TimeUnit.SECONDS), (person, tick) -> person)
                 .observeOn(AndroidSchedulers.mainThread())
-                .subscribe(new Action1<Person>() {
-                    @Override
-                    public void call(Person person) {
-                        TextView personView = new TextView(AnimationActivity.this);
-                        personView.setText(person.getName());
-                        container.addView(personView);
-                    }
+                .subscribe(person -> {
+                    TextView personView = new TextView(AnimationActivity.this);
+                    personView.setText(person.getName());
+                    container.addView(personView);
                 });
     }
 
     @Override
     protected void onPause() {
         super.onPause();
-        subscription.unsubscribe();
+        disposable.dispose();
     }
 
     @Override
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java
index fcfd43d85e..4a269e0dd2 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/gotchas/GotchasActivity.java
@@ -16,24 +16,21 @@
 
 package io.realm.examples.rxjava.gotchas;
 
-import android.app.Activity;
 import android.os.Bundle;
+import android.support.v7.app.AppCompatActivity;
 import android.view.ViewGroup;
 import android.widget.TextView;
 
-import java.util.List;
 import java.util.Random;
 
+import io.reactivex.Flowable;
+import io.reactivex.disposables.CompositeDisposable;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.schedulers.Schedulers;
 import io.realm.Realm;
 import io.realm.Sort;
 import io.realm.examples.rxjava.R;
 import io.realm.examples.rxjava.model.Person;
-import rx.Observable;
-import rx.Subscription;
-import rx.functions.Action1;
-import rx.functions.Func1;
-import rx.schedulers.Schedulers;
-import rx.subscriptions.CompositeSubscription;
 
 /**
  * This class shows some of the current obstacles when combining RxJava and Realm. 2 things are
@@ -52,151 +49,95 @@
  * - https://github.com/realm/realm-java/issues/1208
  * - https://github.com/realm/realm-java/issues/931
  */
-public class GotchasActivity extends Activity {
+public class GotchasActivity extends AppCompatActivity {
     private Realm realm;
-    private Subscription subscription;
+    private CompositeDisposable compositeDisposable = new CompositeDisposable();
     private ViewGroup container;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_gotchas);
-        container = (ViewGroup) findViewById(R.id.list);
+        container = findViewById(R.id.list);
         realm = Realm.getDefaultInstance();
     }
 
     @Override
     protected void onResume() {
         super.onResume();
-
-        Subscription distinctSubscription = testDistinct();
-        Subscription bufferSubscription = testBuffer();
-        Subscription subscribeOnSubscription = testSubscribeOn();
+        testDistinct();
+        testBuffer();
+        testSubscribeOn();
 
         // Trigger updates
-        realm.executeTransaction(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                realm.where(Person.class).findAllSorted( "name", Sort.ASCENDING).get(0).setAge(new Random().nextInt(100));
-            }
-        });
-
-        subscription = new CompositeSubscription(
-                distinctSubscription,
-                bufferSubscription,
-                subscribeOnSubscription
-        );
+        realm.executeTransaction(r ->
+                r.where(Person.class).findAllSorted( "name", Sort.ASCENDING).get(0).setAge(new Random().nextInt(100)));
     }
 
     /**
      * Shows how to be careful with `subscribeOn()`
      */
-    private Subscription testSubscribeOn() {
-        Subscription subscribeOn = realm.asObservable()
-                .map(new Func1<Realm, Person>() {
-                    @Override
-                    public Person call(Realm realm) {
-                        return realm.where(Person.class).findAllSorted("name").get(0);
-                    }
-                })
+    private void testSubscribeOn() {
+        Disposable subscribeOnDisposable = realm.asFlowable()
+                .map(realm -> realm.where(Person.class).findAllSorted("name").get(0))
                 // The Realm was created on the UI thread. Accessing it on `Schedulers.io()` will crash.
                 // Avoid using subscribeOn() and use Realms `findAllAsync*()` methods instead.
                 .subscribeOn(Schedulers.io()) //
-                .subscribe(new Action1<Person>() {
-                    @Override
-                    public void call(Person person) {
-                        // Do nothing
-                    }
-                }, new Action1<Throwable>() {
-                    @Override
-                    public void call(Throwable throwable) {
-                        showStatus("subscribeOn: " + throwable.toString());
-                    }
-                });
+                .subscribe(
+                        person -> {}, // Do nothing
+                        throwable -> showStatus("subscribeOn: " + throwable.toString())
+                );
+        compositeDisposable.add(subscribeOnDisposable);
 
         // Use Realms Async API instead
-        Subscription asyncSubscribeOn = realm.where(Person.class).findAllSortedAsync("name").get(0).<Person>asObservable()
-                .subscribe(new Action1<Person>() {
-                    @Override
-                    public void call(Person person) {
-                        showStatus("subscribeOn/async: " + person.getName() + ":" + person.getAge());
-                    }
-                }, new Action1<Throwable>() {
-                    @Override
-                    public void call(Throwable throwable) {
-                        showStatus("subscribeOn/async: " + throwable.toString());
-                    }
-                });
-
-        return new CompositeSubscription(subscribeOn, asyncSubscribeOn);
+        Disposable asyncSubscribeOnDisposable = realm.where(Person.class).findAllSortedAsync("name").get(0).<Person>asFlowable()
+                .subscribe(
+                        person -> showStatus("subscribeOn/async: " + person.getName() + ":" + person.getAge()),
+                        throwable -> showStatus("subscribeOn/async: " +throwable.toString())
+                );
+        compositeDisposable.add(asyncSubscribeOnDisposable);
     }
 
     /**
      * Shows how to be careful with `buffer()`
      */
-    private Subscription testBuffer() {
-        Observable<Person> personObserver = realm.asObservable().map(new Func1<Realm, Person>() {
-            @Override
-            public Person call(Realm realm) {
-                return realm.where(Person.class).findAllSorted("name").get(0);
-            }
-        });
+    private void testBuffer() {
+        Flowable<Person> personFlowable =
+                realm.asFlowable().map(realm -> realm.where(Person.class).findAllSorted("name").get(0));
 
         // buffer() caches objects until the buffer is full. Due to Realms auto-update of all objects it means
         // that all objects in the cache will contain the same data.
         // Either avoid using buffer or copy data into an unmanaged object.
-        return personObserver
+        Disposable disposable = personFlowable
                 .buffer(2)
-                .subscribe(new Action1<List<Person>>() {
-                    @Override
-                    public void call(List<Person> persons) {
-                        showStatus("Buffer[0] : " + persons.get(0).getName() + ":" + persons.get(0).getAge());
-                        showStatus("Buffer[1] : " + persons.get(1).getName() + ":" + persons.get(1).getAge());
-                    }
+                .subscribe(people -> {
+                    showStatus("Buffer[0] : " + people.get(0).getName() + ":" + people.get(0).getAge());
+                    showStatus("Buffer[1] : " + people.get(1).getName() + ":" + people.get(1).getAge());
                 });
+        compositeDisposable.add(disposable);
     }
 
     /**
      * Shows how to to be careful when using `distinct()`
      */
-    private Subscription testDistinct() {
-        Observable<Person> personObserver = realm.asObservable().map(new Func1<Realm, Person>() {
-            @Override
-            public Person call(Realm realm) {
-                return realm.where(Person.class).findAllSorted("name").get(0);
-            }
-        });
+    private void testDistinct() {
+        Flowable<Person> personFlowable =
+                realm.asFlowable().map(realm -> realm.where(Person.class).findAllSorted("name").get(0));
 
         // distinct() and distinctUntilChanged() uses standard equals with older objects stored in a HashMap.
         // Realm objects auto-update which means the objects stored will also auto-update.
         // This makes comparing against older objects impossible (even if the new object has changed) because the
         // cached object will also have changed.
         // Use a keySelector function to work around this.
-        Subscription distinctItemTest = personObserver
+        Disposable distinctDisposable = personFlowable
                 .distinct() // Because old == new. This will only allow the first version of the "Chris" object to pass.
-                .subscribe(new Action1<Person>() {
-                    @Override
-                    public void call(Person p) {
-                        showStatus("distinct(): " + p.getName() + ":" + p.getAge());
-                    }
-                });
+                .subscribe(person -> showStatus("distinct(): " + person.getName() + ":" + person.getAge()));
+        compositeDisposable.add(distinctDisposable);
 
-        Subscription distinctKeySelectorItemTest = personObserver
-                .distinct(new Func1<Person, Integer>() { // Use a keySelector function instead
-                    @Override
-                    public Integer call(Person p) {
-                        return p.getAge();
-                    }
-                })
-                .subscribe(new Action1<Person>() {
-                    @Override
-                    public void call(Person p) {
-                        showStatus("distinct(keySelector): " + p.getName() + ":" + p.getAge());
-                    }
-                });
-
-
-        return new CompositeSubscription(distinctItemTest, distinctKeySelectorItemTest);
+        Disposable distinctKeySelectorDisposable = personFlowable
+                .distinct(person -> person.getAge())
+                .subscribe(person -> showStatus("distinct(keySelector): " + person.getName() + ":" + person.getAge()));
+        compositeDisposable.add(distinctKeySelectorDisposable);
     }
 
     private void showStatus(String message) {
@@ -208,7 +149,7 @@ private void showStatus(String message) {
     @Override
     protected void onPause() {
         super.onPause();
-        subscription.unsubscribe();
+        compositeDisposable.clear();
     }
 
     @Override
@@ -216,5 +157,4 @@ protected void onDestroy() {
         super.onDestroy();
         realm.close();
     }
-
 }
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GithubApi.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GitHubApi.java
similarity index 82%
rename from examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GithubApi.java
rename to examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GitHubApi.java
index f28d8ab6f8..4302178386 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GithubApi.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GitHubApi.java
@@ -16,17 +16,17 @@
 
 package io.realm.examples.rxjava.retrofit;
 
-import retrofit.http.GET;
-import retrofit.http.Path;
-import rx.Observable;
+import io.reactivex.Flowable;
+import retrofit2.http.GET;
+import retrofit2.http.Path;
 
 /**
  * GitHub API definition
  */
-interface GithubApi {
+interface GitHubApi {
     /**
      * See https://developer.github.com/v3/users/
      */
     @GET("/users/{user}")
-    Observable<GitHubUser> user(@Path("user") String user);
+    Flowable<GitHubUser> user(@Path("user") String user);
 }
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GitHubUser.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GitHubUser.java
index a659b752c8..860ee27525 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GitHubUser.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/GitHubUser.java
@@ -16,10 +16,13 @@
 
 package io.realm.examples.rxjava.retrofit;
 
+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
+
 /**
  * Model class for GitHub users: https://developer.github.com/v3/users/#get-a-single-user
  */
 @SuppressWarnings("unused")
+@JsonIgnoreProperties(ignoreUnknown = true)
 class GitHubUser {
     public String name;
     public int public_repos;
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/RetrofitExample.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/RetrofitExample.java
index 2412dfb88b..4f01dbfa11 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/RetrofitExample.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/retrofit/RetrofitExample.java
@@ -16,40 +16,41 @@
 
 package io.realm.examples.rxjava.retrofit;
 
-import android.app.Activity;
 import android.os.Bundle;
+import android.support.v7.app.AppCompatActivity;
 import android.view.ViewGroup;
 import android.widget.TextView;
 
 import java.util.Locale;
 
+import io.reactivex.Flowable;
+import io.reactivex.android.schedulers.AndroidSchedulers;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.schedulers.Schedulers;
 import io.realm.Realm;
-import io.realm.RealmResults;
 import io.realm.examples.rxjava.R;
 import io.realm.examples.rxjava.model.Person;
-import retrofit.RequestInterceptor;
-import retrofit.RestAdapter;
-import rx.Observable;
-import rx.Subscription;
-import rx.android.schedulers.AndroidSchedulers;
-import rx.functions.Action1;
-import rx.functions.Func1;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import retrofit2.Retrofit;
+import retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory;
+import retrofit2.converter.jackson.JacksonConverterFactory;
 
 import static android.text.TextUtils.isEmpty;
 import static java.lang.String.format;
 
-public class RetrofitExample extends Activity {
+public class RetrofitExample extends AppCompatActivity {
 
     private Realm realm;
-    private Subscription subscription;
+    private Disposable disposable;
     private ViewGroup container;
-    private GithubApi api;
+    private GitHubApi api;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_network);
-        container = (ViewGroup) findViewById(R.id.list);
+        container = findViewById(R.id.list);
         realm = Realm.getDefaultInstance();
         api = createGitHubApi();
     }
@@ -59,57 +60,33 @@ protected void onResume() {
         super.onResume();
 
         // Load all persons and merge them with their latest stats from GitHub (if they have any)
-        subscription = realm.where(Person.class).isNotNull("githubUserName").findAllSortedAsync("name").asObservable()
-                .filter(new Func1<RealmResults<Person>, Boolean>() {
-                    @Override
-                    public Boolean call(RealmResults<Person> persons) {
-                        // We only want the list once it is loaded.
-                        return persons.isLoaded();
-                    }
-                })
-                .flatMap(new Func1<RealmResults<Person>, Observable<Person>>() {
-                    @Override
-                    public Observable<Person> call(RealmResults<Person> persons) {
-                        // Emit each person individually
-                        return Observable.from(persons);
-                    }
-                })
-                .flatMap(new Func1<Person, Observable<GitHubUser>>() {
-                    @Override
-                    public Observable<GitHubUser> call(Person person) {
-                        // get GitHub statistics. Retrofit automatically does this on a separate thread.
-                        return api.user(person.getGithubUserName());
-                    }
-                })
-                .map(new Func1<GitHubUser, UserViewModel>() {
-                    @Override
-                    public UserViewModel call(GitHubUser gitHubUser) {
-                        // Map Network model to our View model
-                        return new UserViewModel(gitHubUser.name, gitHubUser.public_repos, gitHubUser.public_gists);
-                    }
-                })
-                .observeOn(AndroidSchedulers.mainThread()) // Retrofit put us on a worker thread. Move back to UI
-                .subscribe(new Action1<UserViewModel>() {
-                    @Override
-                    public void call(UserViewModel user) {
-                        // Print user info.
-                        TextView userView = new TextView(RetrofitExample.this);
-                        userView.setText(String.format(Locale.US, "%s : %d/%d",
-                                user.getUsername(), user.getPublicRepos(), user.getPublicGists()));
-                        container.addView(userView);
-                    }
-                }, new Action1<Throwable>() {
-                    @Override
-                    public void call(Throwable throwable) {
-                        throwable.printStackTrace();
-                    }
-                });
+        disposable = realm.where(Person.class).isNotNull("githubUserName").findAllSortedAsync("name").asFlowable()
+                // We only want the list once it is loaded.
+                .filter(people -> people.isLoaded())
+                .switchMap(people -> Flowable.fromIterable(people))
+
+                // get GitHub statistics.
+                .flatMap(person -> api.user(person.getGithubUserName()))
+
+                // Map Network model to our View model
+                .map(gitHubUser -> new UserViewModel(gitHubUser.name, gitHubUser.public_repos, gitHubUser.public_gists))
+
+                // Retrofit put us on a worker thread. Move back to UI
+                .observeOn(AndroidSchedulers.mainThread())
+
+                .subscribe(user -> {
+                    // Print user info.
+                    TextView userView = new TextView(RetrofitExample.this);
+                    userView.setText(
+                            String.format(Locale.US, "%s : %d/%d", user.getUsername(), user.getPublicRepos(), user.getPublicGists()));
+                    container.addView(userView);
+                }, throwable -> throwable.printStackTrace());
     }
 
     @Override
     protected void onPause() {
         super.onPause();
-        subscription.unsubscribe();
+        disposable.dispose();
     }
 
     @Override
@@ -118,20 +95,31 @@ protected void onDestroy() {
         realm.close();
     }
 
-    private GithubApi createGitHubApi() {
+    private GitHubApi createGitHubApi() {
 
-        RestAdapter.Builder builder = new RestAdapter.Builder().setEndpoint("https://api.github.com/");
+        Retrofit.Builder builder = new Retrofit.Builder()
+                .baseUrl("https://api.github.com/")
+                .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(Schedulers.io()))
+                .addConverterFactory(JacksonConverterFactory.create());
 
-        final String githubToken = ""; // Set GitHub OAuth token to avoid throttling if example is used a lot
-        if (!isEmpty(githubToken)) {
-            builder.setRequestInterceptor(new RequestInterceptor() {
-                @Override
-                public void intercept(RequestFacade request) {
-                    request.addHeader("Authorization", format("token %s", githubToken));
-                }
+        OkHttpClient.Builder httpClientBuilder = new OkHttpClient.Builder();
+
+        final String gitHubToken = ""; // Set GitHub OAuth token to avoid throttling if example is used a lot
+
+        if (!isEmpty(gitHubToken)) {
+            httpClientBuilder.addInterceptor(chain -> {
+                Request originalRequest = chain.request();
+                Request modifiedRequest = originalRequest
+                        .newBuilder()
+                        .header("Authorization", format("token %s", gitHubToken))
+                        .method(originalRequest.method(), originalRequest.body())
+                        .build();
+                return chain.proceed(modifiedRequest);
             });
         }
 
-        return builder.build().create(GithubApi.class);
+        OkHttpClient httpClient = httpClientBuilder.build();
+        builder.client(httpClient);
+        return builder.build().create(GitHubApi.class);
     }
 }
diff --git a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/throttle/ThrottleSearchActivity.java b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/throttle/ThrottleSearchActivity.java
index 6a5c27991b..5b4bdd1df8 100644
--- a/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/throttle/ThrottleSearchActivity.java
+++ b/examples/rxJavaExample/src/main/java/io/realm/examples/rxjava/throttle/ThrottleSearchActivity.java
@@ -16,31 +16,27 @@
 
 package io.realm.examples.rxjava.throttle;
 
-import android.app.Activity;
 import android.os.Bundle;
+import android.support.v7.app.AppCompatActivity;
 import android.view.ViewGroup;
 import android.widget.EditText;
 import android.widget.TextView;
 
-import com.jakewharton.rxbinding.widget.RxTextView;
-import com.jakewharton.rxbinding.widget.TextViewTextChangeEvent;
+import com.jakewharton.rxbinding2.widget.RxTextView;
 
 import java.util.concurrent.TimeUnit;
 
+import io.reactivex.BackpressureStrategy;
+import io.reactivex.android.schedulers.AndroidSchedulers;
+import io.reactivex.disposables.Disposable;
 import io.realm.Realm;
-import io.realm.RealmResults;
 import io.realm.examples.rxjava.R;
 import io.realm.examples.rxjava.model.Person;
-import rx.Observable;
-import rx.Subscription;
-import rx.android.schedulers.AndroidSchedulers;
-import rx.functions.Action1;
-import rx.functions.Func1;
 
-public class ThrottleSearchActivity extends Activity {
+public class ThrottleSearchActivity extends AppCompatActivity {
 
     private Realm realm;
-    private Subscription subscription;
+    private Disposable disposable;
     private EditText searchInputView;
     private ViewGroup searchResultsView;
 
@@ -48,8 +44,8 @@
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_throttlesearch);
-        searchInputView = (EditText) findViewById(R.id.search);
-        searchResultsView = (ViewGroup) findViewById(R.id.search_results);
+        searchInputView = findViewById(R.id.search);
+        searchResultsView = findViewById(R.id.search_results);
         realm = Realm.getDefaultInstance();
     }
 
@@ -58,49 +54,35 @@ protected void onResume() {
         super.onResume();
 
         // Listen to key presses and only start search after user paused to avoid excessive redrawing on the screen.
-        subscription = RxTextView.textChangeEvents(searchInputView)
+        disposable = RxTextView.textChangeEvents(searchInputView)
                 .debounce(200, TimeUnit.MILLISECONDS) // default Scheduler is Schedulers.computation()
                 .observeOn(AndroidSchedulers.mainThread()) // Needed to access Realm data
-                .flatMap(new Func1<TextViewTextChangeEvent, Observable<RealmResults<Person>>>() {
-                    @Override
-                    public Observable<RealmResults<Person>> call(TextViewTextChangeEvent event) {
-                        // Use Async API to move Realm queries off the main thread.
-                        // Realm currently doesn't support the standard Schedulers.
-                        return realm.where(Person.class)
-                                .beginsWith("name", event.text().toString())
-                                .findAllSortedAsync("name").asObservable();
-                    }
-                })
-                .filter(new Func1<RealmResults<Person>, Boolean>() {
-                    @Override
-                    public Boolean call(RealmResults<Person> persons) {
-                        // Only continue once data is actually loaded
-                        // RealmObservables will emit the unloaded (empty) list as its first item
-                        return persons.isLoaded();
-                    }
+                .toFlowable(BackpressureStrategy.BUFFER)
+                .switchMap(textChangeEvent -> {
+                    // Use Async API to move Realm queries off the main thread.
+                    // Realm currently doesn't support the standard Schedulers.
+                    return realm.where(Person.class)
+                            .beginsWith("name", textChangeEvent.text().toString())
+                            .findAllSortedAsync("name")
+                            .asFlowable();
                 })
-                .subscribe(new Action1<RealmResults<Person>>() {
-                    @Override
-                    public void call(RealmResults<Person> persons) {
-                        searchResultsView.removeAllViews();
-                        for (Person person : persons) {
-                            TextView view = new TextView(ThrottleSearchActivity.this);
-                            view.setText(person.getName());
-                            searchResultsView.addView(view);
-                        }
-                    }
-                }, new Action1<Throwable>() {
-                    @Override
-                    public void call(Throwable throwable) {
-                        throwable.printStackTrace();
+                // Only continue once data is actually loaded
+                // RealmObservables will emit the unloaded (empty) list as its first item
+                .filter(people -> people.isLoaded())
+                .subscribe(people -> {
+                    searchResultsView.removeAllViews();
+                    for (Person person : people) {
+                        TextView view = new TextView(ThrottleSearchActivity.this);
+                        view.setText(person.getName());
+                        searchResultsView.addView(view);
                     }
-                });
+                }, throwable -> throwable.printStackTrace());
     }
 
     @Override
     protected void onPause() {
         super.onPause();
-        subscription.unsubscribe();
+        disposable.dispose();
     }
 
     @Override
diff --git a/examples/rxJavaExample/src/main/res/values/colors.xml b/examples/rxJavaExample/src/main/res/values/colors.xml
new file mode 100644
index 0000000000..cb09b5ec1d
--- /dev/null
+++ b/examples/rxJavaExample/src/main/res/values/colors.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <color name="colorPrimary">#3F51B5</color>
+    <color name="colorPrimaryDark">#303F9F</color>
+    <color name="colorAccent">#FF4081</color>
+</resources>
\ No newline at end of file
diff --git a/examples/rxJavaExample/src/main/res/values/styles.xml b/examples/rxJavaExample/src/main/res/values/styles.xml
index ff6c9d2c0f..b4390a2166 100644
--- a/examples/rxJavaExample/src/main/res/values/styles.xml
+++ b/examples/rxJavaExample/src/main/res/values/styles.xml
@@ -1,8 +1,9 @@
 <resources>
 
-    <!-- Base application theme. -->
-    <style name="AppTheme" parent="android:Theme.Holo.Light.DarkActionBar">
-        <!-- Customize your theme here. -->
+    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
+        <item name="colorPrimary">@color/colorPrimary</item>
+        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
+        <item name="colorAccent">@color/colorAccent</item>
     </style>
 
 </resources>
diff --git a/examples/secureTokenAndroidKeyStore/build.gradle b/examples/secureTokenAndroidKeyStore/build.gradle
index b523a941c8..9e90be2ad2 100644
--- a/examples/secureTokenAndroidKeyStore/build.gradle
+++ b/examples/secureTokenAndroidKeyStore/build.gradle
@@ -7,7 +7,7 @@ android {
 
     defaultConfig {
         applicationId "io.realm.examples.securetokenandroidkeystore"
-        minSdkVersion 9
+        minSdkVersion 14
         targetSdkVersion 25
         versionCode 1
         versionName "1.0"
@@ -17,20 +17,25 @@ android {
     }
     buildTypes {
         release {
-            minifyEnabled false
+            minifyEnabled true
+            signingConfig signingConfigs.debug
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+        debug {
+            minifyEnabled true
             proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
         }
     }
 }
 
 dependencies {
-    compile fileTree(dir: 'libs', include: ['*.jar'])
-    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
+    implementation fileTree(dir: 'libs', include: ['*.jar'])
+    androidTestImplementation('com.android.support.test.espresso:espresso-core:2.2.2', {
         exclude group: 'com.android.support', module: 'support-annotations'
     })
-    compile 'com.android.support:appcompat-v7:25.2.0'
-    testCompile 'junit:junit:4.12'
-    compile 'io.realm:android-secure-userstore:1.0.0'
+    implementation 'com.android.support:appcompat-v7:26.0.1'
+    testImplementation 'junit:junit:4.12'
+    implementation 'io.realm:secure-userstore:1.0.1'
 }
 
 realm {
diff --git a/examples/secureTokenAndroidKeyStore/src/main/java/io/realm/examples/securetokenandroidkeystore/MainActivity.java b/examples/secureTokenAndroidKeyStore/src/main/java/io/realm/examples/securetokenandroidkeystore/MainActivity.java
index c4b618b704..6fff42f95e 100644
--- a/examples/secureTokenAndroidKeyStore/src/main/java/io/realm/examples/securetokenandroidkeystore/MainActivity.java
+++ b/examples/secureTokenAndroidKeyStore/src/main/java/io/realm/examples/securetokenandroidkeystore/MainActivity.java
@@ -23,31 +23,26 @@
 
 import com.example.securetokenandroidkeystore.R;
 
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
 import java.security.KeyStoreException;
-import java.util.UUID;
 
-import io.realm.android.CipherClient;
-import io.realm.android.SecureUserStore;
+import io.realm.ObjectServerError;
+import io.realm.Realm;
+import io.realm.SyncConfiguration;
+import io.realm.SyncCredentials;
+import io.realm.SyncManager;
 import io.realm.SyncUser;
 import io.realm.android.SecureUserStore;
-import io.realm.SyncManager;
-import io.realm.SyncConfiguration;
-import io.realm.Realm;
-import io.realm.internal.objectserver.Token;
-import io.realm.internal.objectserver.ObjectServerUser;
 
 /**
  * Activity responsible of unlocking the KeyStore
- * before using the {@link realm.io.android.SecureUserStore} to encrypt
+ * before using the {@link io.realm.android.SecureUserStore} to encrypt
  * the Token we get from the session
  */
 public class MainActivity extends AppCompatActivity {
-    private CipherClient cryptoClient;
     private TextView txtKeystoreState;
+
+    private SecureUserStore secureUserStore;
+
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
@@ -55,12 +50,14 @@ protected void onCreate(Bundle savedInstanceState) {
         txtKeystoreState = (TextView) findViewById(R.id.txtLabelKeyStore);
 
         try {
-            cryptoClient = new CipherClient(this);
-            if (cryptoClient.isKeystoreUnlocked()) {
+            secureUserStore = new SecureUserStore(this);
+            SyncManager.setUserStore(secureUserStore);
+
+            if (secureUserStore.isKeystoreUnlocked()) {
                 buildSyncConf();
                 keystoreUnlockedMessage();
             } else {
-                cryptoClient.unlockKeystore();
+                secureUserStore.unlockKeystore();
             }
         } catch (KeyStoreException e) {
             e.printStackTrace();
@@ -72,11 +69,11 @@ protected void onResume() {
         super.onResume();
         try {
             // We return to the app after the KeyStore is unlocked or not.
-            if (cryptoClient.isKeystoreUnlocked()) {
+            if (secureUserStore.isKeystoreUnlocked()) {
                 buildSyncConf();
-                keystoreUnlockedMessage ();
+                keystoreUnlockedMessage();
             } else {
-                keystoreLockedMessage ();
+                keystoreLockedMessage();
             }
         } catch (KeyStoreException e) {
             e.printStackTrace();
@@ -84,52 +81,31 @@ protected void onResume() {
     }
 
     // build SyncConfiguration with a user store to store encrypted Token.
-    private void buildSyncConf () {
-        try {
-            SyncManager.setUserStore(new SecureUserStore(MainActivity.this));
-            // the rest of Sync logic ...
-            SyncUser user = createTestUser(0);
-            String url = "realm://objectserver.realm.io/default";
-            SyncConfiguration secureConfig = new SyncConfiguration.Builder(user, url).build();
-            Realm realm = Realm.getInstance(secureConfig);
-            // ... 
-
-        } catch (KeyStoreException e) {
-            e.printStackTrace();
-        }
-    }
-    // Helpers
-    private final static String USER_TOKEN = UUID.randomUUID().toString();
-    private final static String REALM_TOKEN = UUID.randomUUID().toString();
-
-    private static SyncUser createTestUser(long expires) {
-        Token userToken = new Token(USER_TOKEN, "JohnDoe", null, expires, null);
-        Token accessToken = new Token(REALM_TOKEN, "JohnDoe", "/foo", expires, new Token.Permission[] {Token.Permission.DOWNLOAD });
-        ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(accessToken, "/data/data/myapp/files/default", false);
+    private void buildSyncConf() {
+        // the rest of Sync logic ...
+        SyncCredentials credentials = SyncCredentials.usernamePassword("username", "password");
+        final String urlAuth = "http://objectserver.realm.io:9080/auth";
+        final String url = "realm://objectserver.realm.io/default";
+
+        SyncUser.loginAsync(credentials, urlAuth, new SyncUser.Callback<SyncUser>() {
+            @Override
+            public void onSuccess(SyncUser user) {
+                SyncConfiguration secureConfig = new SyncConfiguration.Builder(user, url).build();
+                Realm realm = Realm.getInstance(secureConfig);
+                // ...
+            }
 
-        JSONObject obj = new JSONObject();
-        try {
-            JSONArray realmList = new JSONArray();
-            JSONObject realmDesc = new JSONObject();
-            realmDesc.put("uri", "realm://objectserver.realm.io/default");
-            realmDesc.put("description", desc.toJson());
-            realmList.put(realmDesc);
-
-            obj.put("authUrl", "http://objectserver.realm.io/auth");
-            obj.put("userToken", userToken.toJson());
-            obj.put("realms", realmList);
-            return SyncUser.fromJson(obj.toString());
-        } catch (JSONException e) {
-            throw new RuntimeException(e);
-        }
+            @Override
+            public void onError(ObjectServerError error) {}
+        });
     }
 
-    private void keystoreLockedMessage () {
+    private void keystoreLockedMessage() {
         txtKeystoreState.setBackgroundColor(ContextCompat.getColor(this, R.color.colorLocked));
         txtKeystoreState.setText(R.string.locked_text);
     }
 
-    private void keystoreUnlockedMessage () {
+    private void keystoreUnlockedMessage() {
         txtKeystoreState.setBackgroundColor(ContextCompat.getColor(this, R.color.colorActivated));
         txtKeystoreState.setText(R.string.unlocked_text);
     }
diff --git a/examples/settings.gradle b/examples/settings.gradle
index 0f9f5242bd..5dbeeef366 100644
--- a/examples/settings.gradle
+++ b/examples/settings.gradle
@@ -7,7 +7,6 @@ include 'kotlinExample'
 include 'migrationExample'
 include 'moduleExample:app'
 include 'moduleExample:library'
-include 'realmModuleExample'
 include 'threadExample'
 include 'unitTestExample'
 include 'newsreaderExample'
@@ -15,4 +14,3 @@ include 'rxJavaExample'
 include 'objectServerExample'
 
 rootProject.name = 'realm-examples'
-
diff --git a/examples/threadExample/build.gradle b/examples/threadExample/build.gradle
index 98ec9f1827..91f88acc74 100644
--- a/examples/threadExample/build.gradle
+++ b/examples/threadExample/build.gradle
@@ -1,5 +1,4 @@
 apply plugin: 'com.android.application'
-apply plugin: 'android-command'
 apply plugin: 'realm-android'
 
 android {
@@ -15,15 +14,16 @@ android {
     }
     buildTypes {
         release {
-            minifyEnabled false
+            minifyEnabled true
+            signingConfig signingConfigs.debug
+        }
+        debug {
+            minifyEnabled true
         }
-    }
-    command {
-        events 2000
     }
 }
 
 dependencies {
     //noinspection GradleDependency
-    compile 'com.android.support:appcompat-v7:24.0.0'
+    implementation 'com.android.support:appcompat-v7:24.0.0'
 }
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java b/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java
index 43b9da847a..fc61e0bef6 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/ThreadFragment.java
@@ -169,6 +169,7 @@ public void onPause() {
     public void onStop() {
         super.onStop();
         // Remember to close the Realm instance when done with it.
+        dotsView.setRealmResults(null);
         realm.close();
     }
 }
diff --git a/examples/threadExample/src/main/java/io/realm/examples/threads/widget/DotsView.java b/examples/threadExample/src/main/java/io/realm/examples/threads/widget/DotsView.java
index e3fcbea651..3756f3ccd0 100644
--- a/examples/threadExample/src/main/java/io/realm/examples/threads/widget/DotsView.java
+++ b/examples/threadExample/src/main/java/io/realm/examples/threads/widget/DotsView.java
@@ -77,6 +77,9 @@ protected void onSizeChanged(int w, int h, int oldw, int oldh) {
     @Override
     protected void onDraw(Canvas canvas) {
         super.onDraw(canvas);
+        if (results == null) {
+            return;
+        }
         canvas.drawColor(Color.TRANSPARENT);
         for (Dot dot : results) {
             circlePaint.setColor(dot.getColor());
diff --git a/examples/unitTestExample/build.gradle b/examples/unitTestExample/build.gradle
index a6752c2738..ef7e152157 100644
--- a/examples/unitTestExample/build.gradle
+++ b/examples/unitTestExample/build.gradle
@@ -1,5 +1,4 @@
 apply plugin: 'com.android.application'
-apply plugin: 'android-command'
 apply plugin: 'realm-android'
 
 android {
@@ -19,34 +18,41 @@ android {
 
     buildTypes {
         release {
-            minifyEnabled false
+            minifyEnabled true
+            signingConfig signingConfigs.debug
+        }
+        debug {
+            minifyEnabled true
         }
     }
 
-    command {
-        events 2000
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
     }
 }
 
 
 dependencies {
-    testCompile 'io.reactivex:rxjava:1.1.0'
+    implementation 'com.android.support:appcompat-v7:26.0.1'
+
+    testImplementation 'io.reactivex.rxjava2:rxjava:2.1.0'
 
     // Testing
-    testCompile 'junit:junit:4.12'
-    testCompile "org.robolectric:robolectric:3.0"
-    testCompile "org.mockito:mockito-core:1.10.19"
-    testCompile 'org.robolectric:shadows-support-v4:3.0'
+    testImplementation 'junit:junit:4.12'
+    testImplementation "org.robolectric:robolectric:3.3.2"
+    testImplementation "org.mockito:mockito-core:1.10.19"
+    testImplementation 'org.robolectric:shadows-support-v4:3.0'
 
-    testCompile "org.powermock:powermock-module-junit4:1.6.4"
-    testCompile "org.powermock:powermock-module-junit4-rule:1.6.4"
-    testCompile "org.powermock:powermock-api-mockito:1.6.4"
-    testCompile "org.powermock:powermock-classloading-xstream:1.6.4"
+    testImplementation "org.powermock:powermock-module-junit4:1.6.5"
+    testImplementation "org.powermock:powermock-module-junit4-rule:1.6.5"
+    testImplementation "org.powermock:powermock-api-mockito:1.6.5"
+    testImplementation "org.powermock:powermock-classloading-xstream:1.6.5"
 
 
-    androidTestCompile 'com.android.support.test:runner:0.5'
+    androidTestImplementation 'com.android.support.test:runner:1.0.1'
     // Set this dependency to use JUnit 4 rules
-    androidTestCompile 'com.android.support.test:rules:0.5'
+    androidTestImplementation 'com.android.support.test:rules:1.0.1'
     // Set this dependency to build and run Espresso tests
-    androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'
+    androidTestImplementation 'com.android.support.test.espresso:espresso-core:2.2.2'
 }
diff --git a/examples/unitTestExample/src/androidTest/java/io/realm/examples/unittesting/jUnit4ExampleTest.java b/examples/unitTestExample/src/androidTest/java/io/realm/examples/unittesting/jUnit4ExampleTest.java
index f605f1e1ea..12f8d2e44e 100644
--- a/examples/unitTestExample/src/androidTest/java/io/realm/examples/unittesting/jUnit4ExampleTest.java
+++ b/examples/unitTestExample/src/androidTest/java/io/realm/examples/unittesting/jUnit4ExampleTest.java
@@ -33,7 +33,7 @@
 public class jUnit4ExampleTest {
 
     @Rule
-    public ActivityTestRule<ExampleActivity> mActivityRule = new ActivityTestRule<ExampleActivity>(ExampleActivity.class);
+    public ActivityTestRule<ExampleActivity> mActivityRule = new ActivityTestRule<>(ExampleActivity.class);
 
     @Test
     public void testShouldBeAbleToLaunchActivityAndSeeRealmResults() {
diff --git a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java
index 479037fabb..4b0f94e752 100644
--- a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java
+++ b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/ExampleActivity.java
@@ -16,21 +16,18 @@
 
 package io.realm.examples.unittesting;
 
-import android.app.Activity;
 import android.os.AsyncTask;
 import android.os.Bundle;
+import android.support.v7.app.AppCompatActivity;
 import android.util.Log;
-import android.view.View;
 import android.widget.LinearLayout;
 import android.widget.TextView;
 
 import io.realm.Realm;
-import io.realm.RealmConfiguration;
 import io.realm.RealmResults;
 import io.realm.examples.unittesting.model.Person;
 
-
-public class ExampleActivity extends Activity {
+public class ExampleActivity extends AppCompatActivity {
 
     public static final String TAG = ExampleActivity.class.getName();
     private LinearLayout rootLayout = null;
@@ -42,7 +39,7 @@ protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         Realm.init(getApplicationContext());
         setContentView(R.layout.activity_example);
-        rootLayout = ((LinearLayout) findViewById(R.id.container));
+        rootLayout = findViewById(R.id.container);
         rootLayout.removeAllViews();
 
         // Open the default Realm for the UI thread.
@@ -71,24 +68,17 @@ protected void onPostExecute(String result) {
 
         foo.execute();
 
-        findViewById(R.id.clean_up).setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                v.setEnabled(false);
-                cleanUp();
-                v.setEnabled(true);
-            }
+        findViewById(R.id.clean_up).setOnClickListener(view -> {
+            view.setEnabled(false);
+            Log.d("TAG", "clean up");
+            cleanUp();
+            view.setEnabled(true);
         });
     }
 
     private void cleanUp() {
         // Delete all persons
-        realm.executeTransaction(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                realm.delete(Person.class);
-            }
-        });
+        realm.executeTransaction(r -> r.delete(Person.class));
     }
 
     @Override
@@ -108,15 +98,12 @@ private void basicCRUD(Realm realm) {
         showStatus("Perform basic Create/Read/Update/Delete (CRUD) operations...");
 
         // All writes must be wrapped in a transaction to facilitate safe multi threading
-        realm.executeTransaction(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                // Add a person
-                Person person = realm.createObject(Person.class);
-                person.setId(1);
-                person.setName("John Young");
-                person.setAge(14);
-            }
+        realm.executeTransaction(r -> {
+            // Add a person
+            Person person = r.createObject(Person.class);
+            person.setId(1);
+            person.setName("John Young");
+            person.setAge(14);
         });
 
         // Find the first person (no query conditions) and read a field
@@ -124,28 +111,22 @@ public void execute(Realm realm) {
         showStatus(person.getName() + ":" + person.getAge());
 
         // Update person in a transaction
-        realm.executeTransaction(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                person.setName("John Senior");
-                person.setAge(89);
-            }
+        realm.executeTransaction(r -> {
+            person.setName("John Senior");
+            person.setAge(89);
         });
 
         showStatus(person.getName() + " got older: " + person.getAge());
 
         // Add two more people
-        realm.executeTransaction(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                Person jane = realm.createObject(Person.class);
-                jane.setName("Jane");
-                jane.setAge(27);
-
-                Person doug = realm.createObject(Person.class);
-                doug.setName("Robert");
-                doug.setAge(42);
-            }
+        realm.executeTransaction(r -> {
+            Person jane = r.createObject(Person.class);
+            jane.setName("Jane");
+            jane.setAge(27);
+
+            Person doug = r.createObject(Person.class);
+            doug.setName("Robert");
+            doug.setAge(42);
         });
 
         RealmResults<Person> people = realm.where(Person.class).findAll();
@@ -164,7 +145,8 @@ private String complexQuery() {
         // Find all persons where age between 1 and 99 and name begins with "J".
         RealmResults<Person> results = realm.where(Person.class)
                 .between("age", 1, 99)       // Notice implicit "and" operation
-                .beginsWith("name", "J").findAll();
+                .beginsWith("name", "J")
+                .findAll();
         status += "\nNumber of people aged between 1 and 99 who's name start with 'J': " + results.size();
 
         realm.close();
diff --git a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/repository/DogRepositoryImpl.java b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/repository/DogRepositoryImpl.java
index 60ff3b2eeb..b421c16413 100644
--- a/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/repository/DogRepositoryImpl.java
+++ b/examples/unitTestExample/src/main/java/io/realm/examples/unittesting/repository/DogRepositoryImpl.java
@@ -19,17 +19,13 @@
 import io.realm.Realm;
 import io.realm.examples.unittesting.model.Dog;
 
-
 public class DogRepositoryImpl implements DogRepository {
     @Override
     public void createDog(final String name) {
         Realm realm = Realm.getDefaultInstance();
-        realm.executeTransaction(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                Dog dog = realm.createObject(Dog.class);
-                dog.setName(name);
-            }
+        realm.executeTransaction(r -> {
+            Dog dog = r.createObject(Dog.class);
+            dog.setName(name);
         });
         realm.close();
     }
diff --git a/examples/unitTestExample/src/main/res/values/colors.xml b/examples/unitTestExample/src/main/res/values/colors.xml
new file mode 100644
index 0000000000..cb09b5ec1d
--- /dev/null
+++ b/examples/unitTestExample/src/main/res/values/colors.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <color name="colorPrimary">#3F51B5</color>
+    <color name="colorPrimaryDark">#303F9F</color>
+    <color name="colorAccent">#FF4081</color>
+</resources>
\ No newline at end of file
diff --git a/examples/unitTestExample/src/main/res/values/styles.xml b/examples/unitTestExample/src/main/res/values/styles.xml
index ff6c9d2c0f..b4390a2166 100644
--- a/examples/unitTestExample/src/main/res/values/styles.xml
+++ b/examples/unitTestExample/src/main/res/values/styles.xml
@@ -1,8 +1,9 @@
 <resources>
 
-    <!-- Base application theme. -->
-    <style name="AppTheme" parent="android:Theme.Holo.Light.DarkActionBar">
-        <!-- Customize your theme here. -->
+    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
+        <item name="colorPrimary">@color/colorPrimary</item>
+        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
+        <item name="colorAccent">@color/colorAccent</item>
     </style>
 
 </resources>
diff --git a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
index e478db6428..6123c0784f 100644
--- a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
+++ b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
@@ -19,22 +19,20 @@
 import android.content.Context;
 
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mockito;
-import org.powermock.api.mockito.PowerMockito;
 import org.powermock.core.classloader.annotations.PowerMockIgnore;
 import org.powermock.core.classloader.annotations.PrepareForTest;
 import org.powermock.core.classloader.annotations.SuppressStaticInitializationFor;
-import org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl;
+import org.powermock.modules.junit4.PowerMockRunner;
+import org.powermock.modules.junit4.PowerMockRunnerDelegate;
 import org.powermock.modules.junit4.rule.PowerMockRule;
 import org.robolectric.Robolectric;
-import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
-import org.robolectric.util.ActivityController;
 
 import java.util.Arrays;
 import java.util.List;
@@ -46,7 +44,6 @@
 import io.realm.RealmResults;
 import io.realm.examples.unittesting.model.Person;
 import io.realm.internal.RealmCore;
-import io.realm.internal.Util;
 import io.realm.log.RealmLog;
 
 import static org.hamcrest.CoreMatchers.is;
@@ -64,13 +61,14 @@
 import static org.powermock.api.mockito.PowerMockito.when;
 import static org.powermock.api.mockito.PowerMockito.whenNew;
 
-@RunWith(RobolectricGradleTestRunner.class)
+
+@RunWith(PowerMockRunner.class)
+@PowerMockRunnerDelegate(RobolectricTestRunner.class)
 @Config(constants = BuildConfig.class, sdk = 21)
 @PowerMockIgnore({"org.mockito.*", "org.robolectric.*", "android.*"})
 @SuppressStaticInitializationFor("io.realm.internal.Util")
 @PrepareForTest({Realm.class, RealmConfiguration.class, RealmQuery.class, RealmResults.class, RealmCore.class, RealmLog.class})
 public class ExampleActivityTest {
-
     // Robolectric, Using Power Mock https://github.com/robolectric/robolectric/wiki/Using-PowerMock
 
     @Rule
@@ -176,14 +174,12 @@ public void setup() throws Exception {
     }
 
 
-    @Ignore("FIXME: Some problems mocking OKHttp")
     @Test
     public void shouldBeAbleToAccessActivityAndVerifyRealmInteractions() {
         doCallRealMethod().when(mockRealm).executeTransaction(Mockito.any(Realm.Transaction.class));
 
         // Create activity
-        ActivityController<ExampleActivity> controller = Robolectric.buildActivity(ExampleActivity.class).setup();
-        ExampleActivity activity = controller.get();
+        ExampleActivity activity = Robolectric.buildActivity(ExampleActivity.class).create().start().resume().visible().get();
 
         assertThat(activity.getTitle().toString(), is("Unit Test Example"));
 
@@ -211,7 +207,7 @@ public void shouldBeAbleToAccessActivityAndVerifyRealmInteractions() {
         verify(mockRealm, times(2)).delete(Person.class);
 
         // Call the destroy method so we can verify that the .close() method was called (below)
-        controller.destroy();
+        activity.onDestroy();
 
         // Verify that the realm got closed 2 separate times. Once in the AsyncTask, once
         // in onDestroy
@@ -222,13 +218,11 @@ public void shouldBeAbleToAccessActivityAndVerifyRealmInteractions() {
      * Have to verify the transaction execution in a different test because
      * of a problem with Powermock: https://github.com/jayway/powermock/issues/649
      */
-    @Ignore("FIXME: Some problems mocking OKHttp")
     @Test
     public void shouldBeAbleToVerifyTransactionCalls() {
 
         // Create activity
-        ActivityController<ExampleActivity> controller = Robolectric.buildActivity(ExampleActivity.class).setup();
-        ExampleActivity activity = controller.get();
+        ExampleActivity activity = Robolectric.buildActivity(ExampleActivity.class).create().start().resume().visible().get();
 
         assertThat(activity.getTitle().toString(), is("Unit Test Example"));
 
@@ -248,7 +242,7 @@ public void shouldBeAbleToVerifyTransactionCalls() {
         verify(mockRealm, times(5)).executeTransaction(Mockito.any(Realm.Transaction.class));
 
         // Call the destroy method so we can verify that the .close() method was called (below)
-        controller.destroy();
+        activity.onDestroy();
 
         // Verify that the realm got closed 2 separate times. Once in the AsyncTask, once
         // in onDestroy
diff --git a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java
index 147c9aa553..3f1b9c87d3 100644
--- a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java
+++ b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleRealmTest.java
@@ -26,7 +26,7 @@
 import org.powermock.core.classloader.annotations.PrepareForTest;
 import org.powermock.core.classloader.annotations.SuppressStaticInitializationFor;
 import org.powermock.modules.junit4.rule.PowerMockRule;
-import org.robolectric.RobolectricGradleTestRunner;
+import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
 import io.realm.Realm;
@@ -44,7 +44,8 @@
 import static org.powermock.api.mockito.PowerMockito.mockStatic;
 import static org.powermock.api.mockito.PowerMockito.when;
 
-@RunWith(RobolectricGradleTestRunner.class)
+
+@RunWith(RobolectricTestRunner.class)
 @Config(constants = BuildConfig.class, sdk = 19)
 @PowerMockIgnore({"org.mockito.*", "org.robolectric.*", "android.*"})
 @SuppressStaticInitializationFor("io.realm.internal.Util")
diff --git a/gradle-plugin/build.gradle b/gradle-plugin/build.gradle
index 945728116b..24cedb3dc1 100644
--- a/gradle-plugin/build.gradle
+++ b/gradle-plugin/build.gradle
@@ -3,8 +3,8 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:3.1.1'
-        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
+        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:4.5.2'
+        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
     }
 }
 
diff --git a/gradle-plugin/gradle.properties b/gradle-plugin/gradle.properties
new file mode 100644
index 0000000000..160890028a
--- /dev/null
+++ b/gradle-plugin/gradle.properties
@@ -0,0 +1 @@
+org.gradle.caching=true
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.jar b/gradle-plugin/gradle/wrapper/gradle-wrapper.jar
index 1deb4fd325..d457a1a990 100644
Binary files a/gradle-plugin/gradle/wrapper/gradle-wrapper.jar and b/gradle-plugin/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
index 7dd58c667b..c583957d2b 100644
--- a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Wed Mar 22 16:44:52 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
diff --git a/gradle-plugin/gradlew b/gradle-plugin/gradlew
index 4453ccea33..cccdd3d517 100755
--- a/gradle-plugin/gradlew
+++ b/gradle-plugin/gradlew
@@ -33,11 +33,11 @@ DEFAULT_JVM_OPTS=""
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
-warn ( ) {
+warn () {
     echo "$*"
 }
 
-die ( ) {
+die () {
     echo
     echo "$*"
     echo
@@ -155,7 +155,7 @@ if $cygwin ; then
 fi
 
 # Escape application args
-save ( ) {
+save () {
     for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
     echo " "
 }
diff --git a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
index 43bf3f89cd..6a24fa434d 100644
--- a/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
+++ b/gradle-plugin/src/main/groovy/io/realm/gradle/Realm.groovy
@@ -23,6 +23,7 @@ import io.realm.transformer.RealmTransformer
 import org.gradle.api.GradleException
 import org.gradle.api.Plugin
 import org.gradle.api.Project
+import org.gradle.api.artifacts.UnknownConfigurationException
 
 class Realm implements Plugin<Project> {
 
@@ -40,7 +41,8 @@ class Realm implements Plugin<Project> {
         }
 
         def syncEnabledDefault = false
-        project.extensions.create('realm', RealmPluginExtension, project, syncEnabledDefault)
+        def dependencyConfigurationName = getDependencyConfigurationName(project)
+        project.extensions.create('realm', RealmPluginExtension, project, syncEnabledDefault, dependencyConfigurationName)
 
         def usesAptPlugin = project.plugins.findPlugin('com.neenbedankt.android-apt') != null
         def isKotlinProject = project.plugins.findPlugin('kotlin-android') != null
@@ -57,7 +59,7 @@ class Realm implements Plugin<Project> {
         project.android.registerTransform(new RealmTransformer(project))
 
         project.repositories.add(project.getRepositories().jcenter())
-        project.dependencies.add("compile", "io.realm:realm-annotations:${Version.VERSION}")
+        project.dependencies.add(dependencyConfigurationName, "io.realm:realm-annotations:${Version.VERSION}")
         if (usesAptPlugin) {
             project.dependencies.add("apt", "io.realm:realm-annotations-processor:${Version.VERSION}")
             project.dependencies.add("androidTestApt", "io.realm:realm-annotations-processor:${Version.VERSION}")
@@ -80,6 +82,22 @@ class Realm implements Plugin<Project> {
         }
     }
 
+    private static String getDependencyConfigurationName(Project project) {
+        /*
+         * Dependency configuration name for android gradle plugin 3.0.0-*.
+         * We need to use 'api' instead of 'implementation' since user's model class
+         * might be using Realm's classes and annotations.
+         */
+        def newDependencyName = "api"
+        def oldDependencyName = "compile"
+        try {
+            project.getConfigurations().getByName(newDependencyName)
+            return newDependencyName
+        } catch (UnknownConfigurationException ignored) {
+            oldDependencyName
+        }
+    }
+
     private static boolean shouldApplyAndroidAptPlugin(boolean usesAptPlugin, boolean isKotlinProject,
                                                        boolean hasAnnotationProcessorConfiguration,
                                                        boolean preferAptOnKotlinProject) {
diff --git a/gradle-plugin/src/main/groovy/io/realm/gradle/RealmPluginExtension.groovy b/gradle-plugin/src/main/groovy/io/realm/gradle/RealmPluginExtension.groovy
index ac2fc4012a..42bd8e5f39 100644
--- a/gradle-plugin/src/main/groovy/io/realm/gradle/RealmPluginExtension.groovy
+++ b/gradle-plugin/src/main/groovy/io/realm/gradle/RealmPluginExtension.groovy
@@ -21,9 +21,11 @@ import org.gradle.api.Project
 class RealmPluginExtension {
     private Project project
     def boolean syncEnabled
+    private String dependencyConfigurationName
 
-    RealmPluginExtension(Project project, boolean syncEnabledDefault) {
+    RealmPluginExtension(Project project, boolean syncEnabledDefault, String dependencyConfigurationName) {
         this.project = project
+        this.dependencyConfigurationName = dependencyConfigurationName
         setSyncEnabled(syncEnabledDefault)
     }
 
@@ -31,7 +33,7 @@ class RealmPluginExtension {
         this.syncEnabled = value;
 
         // remove realm android library first
-        def iterator = project.getConfigurations().getByName("compile").getDependencies().iterator();
+        def iterator = project.getConfigurations().getByName(dependencyConfigurationName).getDependencies().iterator();
         while (iterator.hasNext()) {
             def item = iterator.next()
             if (item.group == 'io.realm' && item.name.startsWith('realm-android-library')) {
@@ -41,6 +43,6 @@ class RealmPluginExtension {
 
         // then add again
         def artifactName = "realm-android-library${syncEnabled ? '-object-server' : ''}"
-        project.dependencies.add("compile", "io.realm:${artifactName}:${Version.VERSION}")
+        project.dependencies.add(dependencyConfigurationName, "io.realm:${artifactName}:${Version.VERSION}")
     }
 }
diff --git a/gradle.properties b/gradle.properties
index 00ce074090..a409f36833 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1 +1,2 @@
 org.gradle.jvmargs=-XX:MaxPermSize=512m
+org.gradle.caching=true
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 34c574f227..d457a1a990 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index a5f34943f0..c583957d2b 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Wed Mar 22 16:45:06 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
diff --git a/gradlew b/gradlew
index 4453ccea33..cccdd3d517 100755
--- a/gradlew
+++ b/gradlew
@@ -33,11 +33,11 @@ DEFAULT_JVM_OPTS=""
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
-warn ( ) {
+warn () {
     echo "$*"
 }
 
-die ( ) {
+die () {
     echo
     echo "$*"
     echo
@@ -155,7 +155,7 @@ if $cygwin ; then
 fi
 
 # Escape application args
-save ( ) {
+save () {
     for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
     echo " "
 }
diff --git a/library-benchmarks/build.gradle b/library-benchmarks/build.gradle
new file mode 100644
index 0000000000..6d48a2410e
--- /dev/null
+++ b/library-benchmarks/build.gradle
@@ -0,0 +1,62 @@
+buildscript {
+    repositories {
+        mavenLocal()
+        google()
+        jcenter()
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:3.0.0-rc2'
+        classpath "io.realm:realm-gradle-plugin:${file("${rootDir}/../version.txt").text.trim()}"
+    }
+}
+
+allprojects {
+    def props = new Properties()
+    props.load(new FileInputStream("${rootDir}/../realm.properties"))
+    props.each { key, val ->
+        project.ext.set(key, val)
+    }
+}
+
+task wrapper(type: Wrapper) {
+    gradleVersion = project.gradleVersion
+}
+
+apply plugin: 'com.android.library'
+apply plugin: 'realm-android'
+
+android {
+    compileSdkVersion 26
+    buildToolsVersion "26.0.2"
+
+    defaultConfig {
+        minSdkVersion 15
+        targetSdkVersion 22 // Below 23 to avoid new permission system introduced in M
+        versionCode 1
+        versionName "1.0"
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    }
+
+    buildTypes {
+        debug {
+            minifyEnabled = false
+            // Running with DEBUG = true will disable the JIT
+            debuggable = false
+        }
+    }
+}
+
+repositories {
+    mavenLocal()
+    google()
+    jcenter()
+}
+
+dependencies {
+    androidTestImplementation 'com.android.support.test:runner:1.0.1'
+    androidTestImplementation 'com.android.support.test:rules:1.0.1'
+    androidTestImplementation 'junit:junit:4.12'
+    androidTestImplementation 'dk.ilios:spanner:0.6.0'
+    androidTestImplementation 'com.opencsv:opencsv:3.4'
+    androidTestImplementation 'junit:junit:4.12'
+}
diff --git a/library-benchmarks/gradle.properties b/library-benchmarks/gradle.properties
new file mode 100644
index 0000000000..160890028a
--- /dev/null
+++ b/library-benchmarks/gradle.properties
@@ -0,0 +1 @@
+org.gradle.caching=true
diff --git a/library-benchmarks/gradle/wrapper/gradle-wrapper.jar b/library-benchmarks/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000000..d457a1a990
Binary files /dev/null and b/library-benchmarks/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/library-benchmarks/gradle/wrapper/gradle-wrapper.properties b/library-benchmarks/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000000..c583957d2b
--- /dev/null
+++ b/library-benchmarks/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,5 @@
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
diff --git a/library-benchmarks/gradlew b/library-benchmarks/gradlew
new file mode 100755
index 0000000000..cccdd3d517
--- /dev/null
+++ b/library-benchmarks/gradlew
@@ -0,0 +1,172 @@
+#!/usr/bin/env sh
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn () {
+    echo "$*"
+}
+
+die () {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+nonstop=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
+esac
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
+}
+APP_ARGS=$(save "$@")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
+
+exec "$JAVACMD" "$@"
diff --git a/library-benchmarks/gradlew.bat b/library-benchmarks/gradlew.bat
new file mode 100644
index 0000000000..e95643d6a2
--- /dev/null
+++ b/library-benchmarks/gradlew.bat
@@ -0,0 +1,84 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windows variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/library-benchmarks/settings.gradle b/library-benchmarks/settings.gradle
new file mode 100644
index 0000000000..78b0be004f
--- /dev/null
+++ b/library-benchmarks/settings.gradle
@@ -0,0 +1 @@
+rootProject.name = 'realm-library-benchmarks'
\ No newline at end of file
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmAllocBenchmarks.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmAllocBenchmarks.java
similarity index 96%
rename from realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmAllocBenchmarks.java
rename to library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmAllocBenchmarks.java
index f9f5a62a6b..3365dabc55 100644
--- a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmAllocBenchmarks.java
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmAllocBenchmarks.java
@@ -31,8 +31,8 @@
 import io.realm.RealmQuery;
 import io.realm.RealmResults;
 import io.realm.benchmarks.config.BenchmarkConfig;
-import io.realm.entities.AllTypes;
-import io.realm.entities.Dog;
+import io.realm.benchmarks.entities.AllTypes;
+
 
 @RunWith(SpannerRunner.class)
 public class RealmAllocBenchmarks {
@@ -48,7 +48,7 @@ public void before() {
         Realm.deleteRealm(config);
         realm = Realm.getInstance(config);
         realm.beginTransaction();
-        realm.createObject(AllTypes.class).getColumnRealmList().add(realm.createObject(Dog.class));
+        realm.createObject(AllTypes.class).getColumnRealmList().add(realm.createObject(AllTypes.class));
         realm.commitTransaction();
     }
 
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmBenchmarks.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmBenchmarks.java
similarity index 98%
rename from realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmBenchmarks.java
rename to library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmBenchmarks.java
index cf307a1b5b..a05d2676e8 100644
--- a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmBenchmarks.java
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmBenchmarks.java
@@ -29,7 +29,8 @@
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
 import io.realm.benchmarks.config.BenchmarkConfig;
-import io.realm.entities.AllTypes;
+import io.realm.benchmarks.entities.AllTypes;
+
 
 @RunWith(SpannerRunner.class)
 public class RealmBenchmarks {
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmInsertBenchmark.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmInsertBenchmark.java
new file mode 100644
index 0000000000..b8151e9e95
--- /dev/null
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmInsertBenchmark.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks;
+
+import android.support.test.InstrumentationRegistry;
+
+import org.junit.runner.RunWith;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import dk.ilios.spanner.AfterExperiment;
+import dk.ilios.spanner.BeforeExperiment;
+import dk.ilios.spanner.Benchmark;
+import dk.ilios.spanner.BenchmarkConfiguration;
+import dk.ilios.spanner.SpannerConfig;
+import dk.ilios.spanner.junit.SpannerRunner;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.benchmarks.config.BenchmarkConfig;
+import io.realm.benchmarks.entities.AllTypes;
+import io.realm.benchmarks.entities.AllTypesPrimaryKey;
+
+
+@RunWith(SpannerRunner.class)
+public class RealmInsertBenchmark {
+
+    @BenchmarkConfiguration
+    public SpannerConfig configuration = BenchmarkConfig.getConfiguration(this.getClass().getCanonicalName());
+
+    private Realm realm;
+    private static final int COLLECTION_SIZE = 100;
+    private List<AllTypes> noPkObjects = new ArrayList<>(COLLECTION_SIZE);
+    private List<AllTypesPrimaryKey> pkObjects = new ArrayList<>(COLLECTION_SIZE);
+
+    @BeforeExperiment
+    public void before() {
+        Realm.init(InstrumentationRegistry.getTargetContext());
+        RealmConfiguration config = new RealmConfiguration.Builder().build();
+        Realm.deleteRealm(config);
+        realm = Realm.getInstance(config);
+
+        for (int i = 0; i < COLLECTION_SIZE; i++) {
+            noPkObjects.add(new AllTypes());
+        }
+
+        for (int i = 0; i < COLLECTION_SIZE; i++) {
+            AllTypesPrimaryKey allTypesPrimaryKey = new AllTypesPrimaryKey();
+            allTypesPrimaryKey.setColumnLong(i);
+            pkObjects.add(allTypesPrimaryKey);
+        }
+
+        realm.beginTransaction();
+    }
+
+    @AfterExperiment
+    public void after() {
+        realm.cancelTransaction();
+        realm.close();
+    }
+
+    @Benchmark
+    public void insertNoPrimaryKey(long reps) {
+        AllTypes allTypes = new AllTypes();
+        for (long i = 0; i < reps; i++) {
+            realm.insert(allTypes);
+        }
+    }
+
+    @Benchmark
+    public void insertNoPrimaryKeyList(long reps) {
+        for (long i = 0; i < reps; i++) {
+            realm.insert(noPkObjects);
+        }
+    }
+
+    @Benchmark
+    public void insertWithPrimaryKey(long reps) {
+        AllTypesPrimaryKey allTypesPrimaryKey = new AllTypesPrimaryKey();
+        for (long i = 0; i < reps; i++) {
+            allTypesPrimaryKey.setColumnLong(i);
+            realm.insertOrUpdate(allTypesPrimaryKey);
+        }
+    }
+
+    @Benchmark
+    public void insertOrUpdateWithPrimaryKeyList(long reps) {
+        for (long i = 0; i < reps; i++) {
+            realm.insertOrUpdate(pkObjects);
+        }
+    }
+}
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectReadBenchmarks.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmObjectReadBenchmarks.java
similarity index 98%
rename from realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectReadBenchmarks.java
rename to library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmObjectReadBenchmarks.java
index 30719457ff..974fe33815 100644
--- a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectReadBenchmarks.java
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmObjectReadBenchmarks.java
@@ -29,7 +29,8 @@
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
 import io.realm.benchmarks.config.BenchmarkConfig;
-import io.realm.entities.AllTypes;
+import io.realm.benchmarks.entities.AllTypes;
+
 
 @RunWith(SpannerRunner.class)
 public class RealmObjectReadBenchmarks {
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.java
similarity index 98%
rename from realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.java
rename to library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.java
index 68719a222f..3cf64b0d3b 100644
--- a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.java
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmObjectWriteBenchmarks.java
@@ -27,7 +27,8 @@
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
 import io.realm.benchmarks.config.BenchmarkConfig;
-import io.realm.entities.AllTypes;
+import io.realm.benchmarks.entities.AllTypes;
+
 
 @RunWith(SpannerRunner.class)
 public class RealmObjectWriteBenchmarks {
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmQueryBenchmarks.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmQueryBenchmarks.java
similarity index 97%
rename from realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmQueryBenchmarks.java
rename to library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmQueryBenchmarks.java
index 8487c9d668..f1e3571c5d 100644
--- a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmQueryBenchmarks.java
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmQueryBenchmarks.java
@@ -16,8 +16,6 @@
 
 package io.realm.benchmarks;
 
-import android.support.test.InstrumentationRegistry;
-
 import org.junit.runner.RunWith;
 
 import dk.ilios.spanner.AfterExperiment;
@@ -31,7 +29,8 @@
 import io.realm.RealmResults;
 import io.realm.Sort;
 import io.realm.benchmarks.config.BenchmarkConfig;
-import io.realm.entities.AllTypes;
+import io.realm.benchmarks.entities.AllTypes;
+
 
 @RunWith(SpannerRunner.class)
 public class RealmQueryBenchmarks {
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmResultsBenchmarks.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmResultsBenchmarks.java
similarity index 98%
rename from realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmResultsBenchmarks.java
rename to library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmResultsBenchmarks.java
index f4cee113b9..e33aeed563 100644
--- a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/RealmResultsBenchmarks.java
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/RealmResultsBenchmarks.java
@@ -30,7 +30,8 @@
 import io.realm.RealmConfiguration;
 import io.realm.RealmResults;
 import io.realm.benchmarks.config.BenchmarkConfig;
-import io.realm.entities.AllTypes;
+import io.realm.benchmarks.entities.AllTypes;
+
 
 @RunWith(SpannerRunner.class)
 public class RealmResultsBenchmarks {
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/BenchmarkConfig.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/config/BenchmarkConfig.java
similarity index 100%
rename from realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/BenchmarkConfig.java
rename to library-benchmarks/src/androidTest/java/io/realm/benchmarks/config/BenchmarkConfig.java
diff --git a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/CSVResultProcessor.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/config/CSVResultProcessor.java
similarity index 99%
rename from realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/CSVResultProcessor.java
rename to library-benchmarks/src/androidTest/java/io/realm/benchmarks/config/CSVResultProcessor.java
index 54e69d495d..d241934afa 100644
--- a/realm/realm-library/src/benchmarks/java/io/realm/benchmarks/config/CSVResultProcessor.java
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/config/CSVResultProcessor.java
@@ -20,7 +20,6 @@
 import com.opencsv.CSVWriter;
 
 import java.io.File;
-import java.io.FileWriter;
 import java.io.IOException;
 import java.nio.charset.Charset;
 import java.text.DecimalFormat;
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/entities/AllTypes.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/entities/AllTypes.java
new file mode 100644
index 0000000000..ec212de056
--- /dev/null
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/entities/AllTypes.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks.entities;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.Required;
+
+
+public class AllTypes extends RealmObject {
+
+    public static final String CLASS_NAME = "AllTypes";
+    public static final String FIELD_STRING = "columnString";
+    public static final String FIELD_LONG = "columnLong";
+    public static final String FIELD_FLOAT = "columnFloat";
+    public static final String FIELD_DOUBLE = "columnDouble";
+    public static final String FIELD_BOOLEAN = "columnBoolean";
+    public static final String FIELD_DATE = "columnDate";
+    public static final String FIELD_BINARY = "columnBinary";
+    public static final String FIELD_REALMOBJECT = "columnRealmObject";
+    public static final String FIELD_REALMLIST = "columnRealmList";
+
+    public static final String[] INVALID_TYPES_FIELDS_FOR_DISTINCT = new String[]{FIELD_REALMOBJECT, FIELD_REALMLIST, FIELD_DOUBLE, FIELD_FLOAT};
+
+    @Required
+    private String columnString = "";
+    private long columnLong;
+    private float columnFloat;
+    private double columnDouble;
+    private boolean columnBoolean;
+    @Required
+    private Date columnDate = new Date(0);
+    @Required
+    private byte[] columnBinary = new byte[0];
+    private AllTypes columnRealmObject;
+    private RealmList<AllTypes> columnRealmList;
+
+    public String getColumnString() {
+        return columnString;
+    }
+
+    public void setColumnString(String columnString) {
+        this.columnString = columnString;
+    }
+
+    public long getColumnLong() {
+        return columnLong;
+    }
+
+    public void setColumnLong(long columnLong) {
+        this.columnLong = columnLong;
+    }
+
+    public float getColumnFloat() {
+        return columnFloat;
+    }
+
+    public void setColumnFloat(float columnFloat) {
+        this.columnFloat = columnFloat;
+    }
+
+    public double getColumnDouble() {
+        return columnDouble;
+    }
+
+    public void setColumnDouble(double columnDouble) {
+        this.columnDouble = columnDouble;
+    }
+
+    public boolean isColumnBoolean() {
+        return columnBoolean;
+    }
+
+    public void setColumnBoolean(boolean columnBoolean) {
+        this.columnBoolean = columnBoolean;
+    }
+
+    public Date getColumnDate() {
+        return columnDate;
+    }
+
+    public void setColumnDate(Date columnDate) {
+        this.columnDate = columnDate;
+    }
+
+    public byte[] getColumnBinary() {
+        return columnBinary;
+    }
+
+    public void setColumnBinary(byte[] columnBinary) {
+        this.columnBinary = columnBinary;
+    }
+
+    public AllTypes getColumnRealmObject() {
+        return columnRealmObject;
+    }
+
+    public void setColumnRealmObject(AllTypes columnRealmObject) {
+        this.columnRealmObject = columnRealmObject;
+    }
+
+    public RealmList<AllTypes> getColumnRealmList() {
+        return columnRealmList;
+    }
+
+    public void setColumnRealmList(RealmList<AllTypes> columnRealmList) {
+        this.columnRealmList = columnRealmList;
+    }
+}
diff --git a/library-benchmarks/src/androidTest/java/io/realm/benchmarks/entities/AllTypesPrimaryKey.java b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/entities/AllTypesPrimaryKey.java
new file mode 100644
index 0000000000..71dc3d88ae
--- /dev/null
+++ b/library-benchmarks/src/androidTest/java/io/realm/benchmarks/entities/AllTypesPrimaryKey.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.benchmarks.entities;
+
+import java.util.Date;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+
+
+public class AllTypesPrimaryKey extends RealmObject {
+    private String columnString;
+    @PrimaryKey
+    private long columnLong;
+    private float columnFloat;
+    private double columnDouble;
+    private boolean columnBoolean;
+    private Date columnDate;
+    private byte[] columnBinary;
+    private AllTypesPrimaryKey columnRealmObject;
+    private RealmList<AllTypesPrimaryKey> columnRealmList;
+    private Boolean columnBoxedBoolean;
+
+    public String getColumnString() {
+        return columnString;
+    }
+
+    public void setColumnString(String columnString) {
+        this.columnString = columnString;
+    }
+
+    public long getColumnLong() {
+        return columnLong;
+    }
+
+    public void setColumnLong(long columnLong) {
+        this.columnLong = columnLong;
+    }
+
+    public float getColumnFloat() {
+        return columnFloat;
+    }
+
+    public void setColumnFloat(float columnFloat) {
+        this.columnFloat = columnFloat;
+    }
+
+    public double getColumnDouble() {
+        return columnDouble;
+    }
+
+    public void setColumnDouble(double columnDouble) {
+        this.columnDouble = columnDouble;
+    }
+
+    public boolean isColumnBoolean() {
+        return columnBoolean;
+    }
+
+    public void setColumnBoolean(boolean columnBoolean) {
+        this.columnBoolean = columnBoolean;
+    }
+
+    public Date getColumnDate() {
+        return columnDate;
+    }
+
+    public void setColumnDate(Date columnDate) {
+        this.columnDate = columnDate;
+    }
+
+    public byte[] getColumnBinary() {
+        return columnBinary;
+    }
+
+    public void setColumnBinary(byte[] columnBinary) {
+        this.columnBinary = columnBinary;
+    }
+
+    public AllTypesPrimaryKey getColumnRealmObject() {
+        return columnRealmObject;
+    }
+
+    public void setColumnRealmObject(AllTypesPrimaryKey columnRealmObject) {
+        this.columnRealmObject = columnRealmObject;
+    }
+
+    public RealmList<AllTypesPrimaryKey> getColumnRealmList() {
+        return columnRealmList;
+    }
+
+    public void setColumnRealmList(RealmList<AllTypesPrimaryKey> columnRealmList) {
+        this.columnRealmList = columnRealmList;
+    }
+
+    public Boolean getColumnBoxedBoolean() {
+        return columnBoxedBoolean;
+    }
+
+    public void setColumnBoxedBoolean(Boolean columnBoxedBoolean) {
+        this.columnBoxedBoolean = columnBoxedBoolean;
+    }
+}
diff --git a/library-benchmarks/src/main/AndroidManifest.xml b/library-benchmarks/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..f05a423d71
--- /dev/null
+++ b/library-benchmarks/src/main/AndroidManifest.xml
@@ -0,0 +1,13 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="io.realm.benchmarks">
+
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
+
+    <application
+        android:allowBackup="true"
+        android:label="@string/app_name"
+        android:supportsRtl="true">
+    </application>
+
+</manifest>
diff --git a/library-benchmarks/src/main/res/values/strings.xml b/library-benchmarks/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..dbe19ccec8
--- /dev/null
+++ b/library-benchmarks/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<resources>
+    <string name="app_name">Realm Benchmarks</string>
+</resources>
diff --git a/realm-annotations/build.gradle b/realm-annotations/build.gradle
index 40213eb437..f97d38992e 100644
--- a/realm-annotations/build.gradle
+++ b/realm-annotations/build.gradle
@@ -3,8 +3,8 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:3.1.1'
-        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
+        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:4.5.2'
+        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
     }
 }
 
diff --git a/realm-annotations/gradle.properties b/realm-annotations/gradle.properties
new file mode 100644
index 0000000000..160890028a
--- /dev/null
+++ b/realm-annotations/gradle.properties
@@ -0,0 +1 @@
+org.gradle.caching=true
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.jar b/realm-annotations/gradle/wrapper/gradle-wrapper.jar
index 1149be9d86..d457a1a990 100644
Binary files a/realm-annotations/gradle/wrapper/gradle-wrapper.jar and b/realm-annotations/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.properties b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
index a5e2a078c3..c583957d2b 100644
--- a/realm-annotations/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Wed Mar 22 16:45:01 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
diff --git a/realm-annotations/gradlew b/realm-annotations/gradlew
index 4453ccea33..cccdd3d517 100755
--- a/realm-annotations/gradlew
+++ b/realm-annotations/gradlew
@@ -33,11 +33,11 @@ DEFAULT_JVM_OPTS=""
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
-warn ( ) {
+warn () {
     echo "$*"
 }
 
-die ( ) {
+die () {
     echo
     echo "$*"
     echo
@@ -155,7 +155,7 @@ if $cygwin ; then
 fi
 
 # Escape application args
-save ( ) {
+save () {
     for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
     echo " "
 }
diff --git a/realm-annotations/src/main/java/io/realm/annotations/Ignore.java b/realm-annotations/src/main/java/io/realm/annotations/Ignore.java
index 784f6c7676..bc86b24c26 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/Ignore.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/Ignore.java
@@ -21,7 +21,7 @@
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
-@Retention(RetentionPolicy.CLASS)
+@Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.FIELD)
 public @interface Ignore {
 
diff --git a/realm-annotations/src/main/java/io/realm/annotations/Index.java b/realm-annotations/src/main/java/io/realm/annotations/Index.java
index bb4f9e1b17..ea6000c336 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/Index.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/Index.java
@@ -27,7 +27,7 @@
  * <p>
  * NOTICE: Only String, int, byte, short, long, boolean and Date fields can be indexed.
  */
-@Retention(RetentionPolicy.CLASS)
+@Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.FIELD)
 public @interface Index {
 
diff --git a/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java b/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java
index d79258c51d..93be19f438 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/LinkingObjects.java
@@ -91,10 +91,14 @@
  * assert john.dogs.size() == 2;
  * assert fido.owners.size() == 2;
  * }
+ * <p>
+ * Querying inverse relationship is like querying any {@code RealmResults}. This means that an inverse relationship
+ * cannot be {@code null} but it can be empty (length is 0). It is possible to query fields in the source class. This is
+ * equivalent to link queries. Please read <a href="https://realm.io/docs/java/latest/#link-queries">for more
+ * information</a>.
  */
-@Retention(RetentionPolicy.SOURCE)
+@Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.FIELD)
-@Beta
 public @interface LinkingObjects {
     /**
      * The name of a field that contains a relation to an instance of the
diff --git a/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java b/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java
index b9e263cf4e..daac8c110f 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/PrimaryKey.java
@@ -34,7 +34,7 @@
  * String, Byte, Short, Integer, and Long are also allowed, and further permitted to have {@code null}
  * as a primary key value.
  */
-@Retention(RetentionPolicy.CLASS)
+@Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.FIELD)
 public @interface PrimaryKey {
 
diff --git a/realm-annotations/src/main/java/io/realm/annotations/RealmClass.java b/realm-annotations/src/main/java/io/realm/annotations/RealmClass.java
index 22111078c4..d0ab776fbb 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/RealmClass.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/RealmClass.java
@@ -23,7 +23,7 @@
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
-@Retention(RetentionPolicy.CLASS)
+@Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.TYPE)
 @Inherited
 public @interface RealmClass {
diff --git a/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java b/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java
index f28f9eb835..c8690de362 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/RealmModule.java
@@ -23,8 +23,8 @@
 import java.lang.annotation.Target;
 
 /**
- * By default a Realm can stores all classes extending RealmObject in a project. However, if you want to restrict a
- * Realm to only contain a subset of classes or want to share them between a library project and an app project you must
+ * By default a Realm can store all classes extending RealmObject in a project. However, if you want to restrict a
+ * Realm to only contain a subset of classes or want to share them between a library project and an app project, you must
  * use a RealmModule.
  * <p>
  * A RealmModule is a collection of classes extending RealmObject that can be combined with other RealmModules to create
diff --git a/realm-annotations/src/main/java/io/realm/annotations/Required.java b/realm-annotations/src/main/java/io/realm/annotations/Required.java
index a6e500c637..2950b0e3de 100644
--- a/realm-annotations/src/main/java/io/realm/annotations/Required.java
+++ b/realm-annotations/src/main/java/io/realm/annotations/Required.java
@@ -29,7 +29,7 @@
  * Fields with primitive types and the {@link io.realm.RealmList} type are required implicitly.
  * Fields with {@link io.realm.RealmObject} type are always nullable.
  */
-@Retention(RetentionPolicy.CLASS)
+@Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.FIELD)
 public @interface Required {
 
diff --git a/realm-transformer/build.gradle b/realm-transformer/build.gradle
index 1c9eeff064..a10ba1ecb0 100644
--- a/realm-transformer/build.gradle
+++ b/realm-transformer/build.gradle
@@ -3,8 +3,8 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:3.1.1'
-        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
+        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:4.5.2'
+        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
     }
 }
 
diff --git a/realm-transformer/gradle.properties b/realm-transformer/gradle.properties
new file mode 100644
index 0000000000..160890028a
--- /dev/null
+++ b/realm-transformer/gradle.properties
@@ -0,0 +1 @@
+org.gradle.caching=true
diff --git a/realm-transformer/gradle/wrapper/gradle-wrapper.jar b/realm-transformer/gradle/wrapper/gradle-wrapper.jar
index 28afc97bba..d457a1a990 100644
Binary files a/realm-transformer/gradle/wrapper/gradle-wrapper.jar and b/realm-transformer/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm-transformer/gradle/wrapper/gradle-wrapper.properties b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
index d24868644c..c583957d2b 100644
--- a/realm-transformer/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Wed Mar 22 16:45:02 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
diff --git a/realm-transformer/gradlew b/realm-transformer/gradlew
index 4453ccea33..cccdd3d517 100755
--- a/realm-transformer/gradlew
+++ b/realm-transformer/gradlew
@@ -33,11 +33,11 @@ DEFAULT_JVM_OPTS=""
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
-warn ( ) {
+warn () {
     echo "$*"
 }
 
-die ( ) {
+die () {
     echo
     echo "$*"
     echo
@@ -155,7 +155,7 @@ if $cygwin ; then
 fi
 
 # Escape application args
-save ( ) {
+save () {
     for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
     echo " "
 }
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
index d64572ea3c..2ad7183dd2 100644
--- a/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
@@ -30,6 +30,10 @@ class BytecodeModifier {
 
     private static final Logger logger = LoggerFactory.getLogger('realm-logger')
 
+    static boolean isModelField(CtField field) {
+        return !field.hasAnnotation(Ignore.class) && !Modifier.isTransient(field.getModifiers()) && !Modifier.isStatic(field.getModifiers())
+    }
+
     /**
      * Adds Realm specific accessors to a model class.
      * All the declared fields will be associated with a getter and a setter.
@@ -40,7 +44,7 @@ class BytecodeModifier {
         logger.debug "  Realm: Adding accessors to ${clazz.simpleName}"
         def methods = clazz.getDeclaredMethods()*.name
         clazz.declaredFields.each { CtField field ->
-            if (!Modifier.isStatic(field.getModifiers()) && !field.hasAnnotation(Ignore.class)) {
+            if (isModelField(field)) {
                 if (!methods.contains("realmGet\$${field.name}".toString())) {
                     clazz.addMethod(CtNewMethod.getter("realmGet\$${field.name}", field))
                 }
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
index d7ca24a76a..bd99fb271d 100644
--- a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
@@ -66,6 +66,7 @@ class RealmTransformer extends Transform {
 
     @Override
     Set<Scope> getReferencedScopes() {
+        // Scope.PROJECT_LOCAL_DEPS and Scope.SUB_PROJECTS_LOCAL_DEPS is only for compatibility with AGP 1.x, 2.x
         return Sets.immutableEnumSet(Scope.EXTERNAL_LIBRARIES, Scope.PROJECT_LOCAL_DEPS,
                 Scope.SUB_PROJECTS, Scope.SUB_PROJECTS_LOCAL_DEPS, Scope.TESTED_CODE)
     }
@@ -121,7 +122,7 @@ class RealmTransformer extends Transform {
         def allManagedFields = []
         allModelClasses.each {
             allManagedFields.addAll(it.declaredFields.findAll {
-                !it.hasAnnotation(Ignore.class) && !Modifier.isStatic(it.getModifiers())
+                BytecodeModifier.isModelField(it)
             })
         }
         logger.debug "Managed Fields: ${allManagedFields*.name}"
diff --git a/realm.properties b/realm.properties
index aa5f3da99d..b36f4827a1 100644
--- a/realm.properties
+++ b/realm.properties
@@ -1,2 +1,2 @@
-gradleVersion=3.4.1
+gradleVersion=4.2.1
 ndkVersion=r10e
diff --git a/realm/build.gradle b/realm/build.gradle
index b7c98a3e74..87890bb6a3 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -1,22 +1,25 @@
 buildscript {
+    ext.kotlin_version = '1.1.51'
     repositories {
         mavenLocal()
+        google()
         jcenter()
         maven { url 'https://jitpack.io' }
         maven { url "https://plugins.gradle.org/m2/" }
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.3.1'
-        classpath 'de.undercouch:gradle-download-task:3.1.1'
+        classpath 'com.android.tools.build:gradle:3.0.0-rc2'
+        classpath 'de.undercouch:gradle-download-task:3.2.0'
         classpath 'com.github.dcendents:android-maven-gradle-plugin:1.5'
-        classpath 'com.novoda:gradle-android-command-plugin:1.3.0'
-        classpath 'com.github.skhatri:gradle-s3-plugin:1.0.2'
-        classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.4.0'
-        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:3.1.1'
-        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
+        classpath 'com.novoda:gradle-android-command-plugin:1.7.1'
+        classpath 'com.github.skhatri:gradle-s3-plugin:1.0.4'
+        classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.8.1'
+        classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:4.5.2'
+        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
         classpath "io.realm:realm-transformer:${file('../version.txt').text.trim()}"
-        classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.0.9'
+        classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.0.11'
+        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
     }
 }
 
@@ -31,6 +34,7 @@ allprojects {
     version = file("${rootDir}/../version.txt").text.trim();
     repositories {
         mavenLocal()
+        google()
         jcenter()
     }
 }
diff --git a/realm/config/findbugs/findbugs-filter.xml b/realm/config/findbugs/findbugs-filter.xml
index c7079866b1..25485943d5 100644
--- a/realm/config/findbugs/findbugs-filter.xml
+++ b/realm/config/findbugs/findbugs-filter.xml
@@ -21,5 +21,8 @@
     <Match>
         <Class name="io.realm.PermissionOfferResponseRealmProxy"/>
     </Match>
+    <Match>
+        <Class name="io.realm.PermissionRealmProxy"/>
+    </Match>
 
 </FindBugsFilter>
diff --git a/realm/gradle.properties b/realm/gradle.properties
index f3f16fcaac..0be17a49db 100644
--- a/realm/gradle.properties
+++ b/realm/gradle.properties
@@ -1 +1,2 @@
 org.gradle.jvmargs=-Xms512m -Xmx2048m
+org.gradle.caching=true
diff --git a/realm/gradle/wrapper/gradle-wrapper.jar b/realm/gradle/wrapper/gradle-wrapper.jar
index 3123a9e708..d457a1a990 100644
Binary files a/realm/gradle/wrapper/gradle-wrapper.jar and b/realm/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm/gradle/wrapper/gradle-wrapper.properties b/realm/gradle/wrapper/gradle-wrapper.properties
index 783df36eb6..c583957d2b 100644
--- a/realm/gradle/wrapper/gradle-wrapper.properties
+++ b/realm/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Wed Mar 22 16:44:59 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip
diff --git a/realm/gradlew b/realm/gradlew
index 4453ccea33..cccdd3d517 100755
--- a/realm/gradlew
+++ b/realm/gradlew
@@ -33,11 +33,11 @@ DEFAULT_JVM_OPTS=""
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
-warn ( ) {
+warn () {
     echo "$*"
 }
 
-die ( ) {
+die () {
     echo
     echo "$*"
     echo
@@ -155,7 +155,7 @@ if $cygwin ; then
 fi
 
 # Escape application args
-save ( ) {
+save () {
     for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
     echo " "
 }
diff --git a/realm/realm-annotations-processor/build.gradle b/realm/realm-annotations-processor/build.gradle
index 67d444c432..43c75faafd 100644
--- a/realm/realm-annotations-processor/build.gradle
+++ b/realm/realm-annotations-processor/build.gradle
@@ -8,14 +8,14 @@ sourceCompatibility = '1.6'
 targetCompatibility = '1.6'
 
 dependencies {
-    compile group:'com.squareup', name:'javawriter', version:'2.5.0'
+    compile "com.squareup:javawriter:2.5.0"
     compile "io.realm:realm-annotations:${version}"
 
     testCompile files('../realm-library/build/intermediates/bundles/baseRelease/classes.jar') // Java projects cannot depend on AAR files
     testCompile files("${System.properties['java.home']}/../lib/tools.jar") // This is needed otherwise compile-testing won't be able to find it
     testCompile group:'junit', name:'junit', version:'4.12'
     testCompile group:'com.google.testing.compile', name:'compile-testing', version:'0.6'
-    testCompile files(file("${System.env.ANDROID_HOME}/platforms/android-25/android.jar"))
+    testCompile files(file("${System.env.ANDROID_HOME}/platforms/android-26/android.jar"))
 }
 
 // for Ant filter
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.java
index ceeaff107a..e658f157a8 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Backlink.java
@@ -16,6 +16,8 @@
 
 package io.realm.processor;
 
+import java.util.Locale;
+
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.VariableElement;
 
@@ -87,7 +89,7 @@
 
     public Backlink(ClassMetaData clazz, VariableElement backlink) {
         if ((null == clazz) || (null == backlink)) {
-            throw new NullPointerException(String.format("null parameter: %s, %s", clazz, backlink));
+            throw new NullPointerException(String.format(Locale.US, "null parameter: %s, %s", clazz, backlink));
         }
 
         this.backlink = backlink;
@@ -130,6 +132,7 @@ public boolean validateSource() {
         // A @LinkingObjects cannot be @Required
         if (backlink.getAnnotation(Required.class) != null) {
             Utils.error(String.format(
+                    Locale.US,
                     "The @LinkingObjects field \"%s.%s\" cannot be @Required.",
                     targetClass,
                     targetField));
@@ -139,6 +142,7 @@ public boolean validateSource() {
         // The annotation must have an argument, identifying the linked field
         if ((sourceField == null) || sourceField.equals("")) {
             Utils.error(String.format(
+                    Locale.US,
                     "The @LinkingObjects annotation for the field \"%s.%s\" must have a parameter identifying the link target.",
                     targetClass,
                     targetField));
@@ -148,6 +152,7 @@ public boolean validateSource() {
         // Using link syntax to try to reference a linked field is not possible.
         if (sourceField.contains(".")) {
             Utils.error(String.format(
+                    Locale.US,
                     "The parameter to the @LinkingObjects annotation for the field \"%s.%s\" contains a '.'.  The use of '.' to specify fields in referenced classes is not supported.",
                     targetClass,
                     targetField));
@@ -157,6 +162,7 @@ public boolean validateSource() {
         // The annotated element must be a RealmResult
         if (!Utils.isRealmResults(backlink)) {
             Utils.error(String.format(
+                    Locale.US,
                     "The field \"%s.%s\" is a \"%s\". Fields annotated with @LinkingObjects must be RealmResults.",
                     targetClass,
                     targetField,
@@ -166,6 +172,7 @@ public boolean validateSource() {
 
         if (sourceClass == null) {
             Utils.error(String.format(
+                    Locale.US,
                     "\"The field \"%s.%s\", annotated with @LinkingObjects, must specify a generic type.",
                     targetClass,
                     targetField));
@@ -175,6 +182,7 @@ public boolean validateSource() {
         // A @LinkingObjects field must be final
         if (!backlink.getModifiers().contains(Modifier.FINAL)) {
             Utils.error(String.format(
+                    Locale.US,
                     "A @LinkingObjects field \"%s.%s\" must be final.",
                     targetClass,
                     targetField));
@@ -188,7 +196,7 @@ public boolean validateTarget(ClassMetaData clazz) {
         VariableElement field = clazz.getDeclaredField(sourceField);
 
         if (field == null) {
-            Utils.error(String.format(
+            Utils.error(String.format(Locale.US,
                     "Field \"%s\", the target of the @LinkedObjects annotation on field \"%s.%s\", does not exist in class \"%s\".",
                     sourceField,
                     targetClass,
@@ -199,7 +207,7 @@ public boolean validateTarget(ClassMetaData clazz) {
 
         String fieldType = field.asType().toString();
         if (!(targetClass.equals(fieldType) || targetClass.equals(Utils.getRealmListType(field)))) {
-            Utils.error(String.format(
+            Utils.error(String.format(Locale.US,
                     "Field \"%s.%s\", the target of the @LinkedObjects annotation on field \"%s.%s\", has type \"%s\" instead of \"%3$s\".",
                     sourceClass,
                     sourceField,
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
index 02b1e46921..cb8b7a54c7 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/ClassMetaData.java
@@ -21,9 +21,11 @@
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Locale;
 import java.util.Set;
 
 import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
@@ -49,36 +51,56 @@
  * Utility class for holding metadata for RealmProxy classes.
  */
 public class ClassMetaData {
+    private static final String OPTION_IGNORE_KOTLIN_NULLABILITY = "realm.ignoreKotlinNullability";
 
     private final TypeElement classType; // Reference to model class.
-    private String className; // Model class simple name.
+    private final String className; // Model class simple name.
+    private final List<VariableElement> fields = new ArrayList<VariableElement>(); // List of all fields in the class except those @Ignored.
+    private final List<VariableElement> indexedFields = new ArrayList<VariableElement>(); // list of all fields marked @Index.
+    private final Set<Backlink> backlinks = new HashSet<Backlink>();
+    private final Set<VariableElement> nullableFields = new HashSet<VariableElement>(); // Set of fields which can be nullable
+    private final Set<VariableElement> nullableValueListFields = new HashSet<VariableElement>(); // Set of fields whose elements can be nullable
+
     private String packageName; // package name for model class.
     private boolean hasDefaultConstructor; // True if model has a public no-arg constructor.
     private VariableElement primaryKey; // Reference to field used as primary key, if any.
-    private List<VariableElement> fields = new ArrayList<VariableElement>(); // List of all fields in the class except those @Ignored.
-    private List<VariableElement> indexedFields = new ArrayList<VariableElement>(); // list of all fields marked @Index.
-    private Set<Backlink> backlinks = new HashSet<Backlink>();
-    private Set<VariableElement> nullableFields = new HashSet<VariableElement>(); // Set of fields which can be nullable
     private boolean containsToString;
     private boolean containsEquals;
     private boolean containsHashCode;
 
     private final List<TypeMirror> validPrimaryKeyTypes;
+    private final List<TypeMirror> validListValueTypes;
     private final Types typeUtils;
     private final Elements elements;
 
-    public ClassMetaData(ProcessingEnvironment env, TypeElement clazz) {
+    private final boolean ignoreKotlinNullability;
+
+    public ClassMetaData(ProcessingEnvironment env, TypeMirrors typeMirrors, TypeElement clazz) {
         this.classType = clazz;
         this.className = clazz.getSimpleName().toString();
         typeUtils = env.getTypeUtils();
         elements = env.getElementUtils();
-        TypeMirror stringType = env.getElementUtils().getTypeElement("java.lang.String").asType();
+
+
         validPrimaryKeyTypes = Arrays.asList(
-                stringType,
-                typeUtils.getPrimitiveType(TypeKind.SHORT),
-                typeUtils.getPrimitiveType(TypeKind.INT),
-                typeUtils.getPrimitiveType(TypeKind.LONG),
-                typeUtils.getPrimitiveType(TypeKind.BYTE)
+                typeMirrors.STRING_MIRROR,
+                typeMirrors.PRIMITIVE_LONG_MIRROR,
+                typeMirrors.PRIMITIVE_INT_MIRROR,
+                typeMirrors.PRIMITIVE_SHORT_MIRROR,
+                typeMirrors.PRIMITIVE_BYTE_MIRROR
+        );
+
+        validListValueTypes = Arrays.asList(
+                typeMirrors.STRING_MIRROR,
+                typeMirrors.BINARY_MIRROR,
+                typeMirrors.BOOLEAN_MIRROR,
+                typeMirrors.LONG_MIRROR,
+                typeMirrors.INTEGER_MIRROR,
+                typeMirrors.SHORT_MIRROR,
+                typeMirrors.BYTE_MIRROR,
+                typeMirrors.DOUBLE_MIRROR,
+                typeMirrors.FLOAT_MIRROR,
+                typeMirrors.DATE_MIRROR
         );
 
         for (Element element : classType.getEnclosedElements()) {
@@ -93,6 +115,9 @@ public ClassMetaData(ProcessingEnvironment env, TypeElement clazz) {
                 }
             }
         }
+
+        ignoreKotlinNullability = Boolean.valueOf(
+                env.getOptions().getOrDefault(OPTION_IGNORE_KOTLIN_NULLABILITY, "false"));
     }
 
     @Override
@@ -117,7 +142,7 @@ public String getFullyQualifiedClassName() {
     }
 
     public Set<Backlink> getBacklinkFields() {
-        return backlinks;
+        return Collections.unmodifiableSet(backlinks);
     }
 
     public String getInternalGetter(String fieldName) {
@@ -129,7 +154,7 @@ public String getInternalSetter(String fieldName) {
     }
 
     public List<VariableElement> getIndexedFields() {
-        return indexedFields;
+        return Collections.unmodifiableList(indexedFields);
     }
 
     public boolean hasPrimaryKey() {
@@ -165,6 +190,15 @@ public boolean isNullable(VariableElement variableElement) {
         return nullableFields.contains(variableElement);
     }
 
+    /**
+     * Checks if the element of {@code RealmList} designated by {@code realmListVariableElement} is nullable.
+     *
+     * @return {@code true} if the element is nullable type, {@code false} otherwise.
+     */
+    public boolean isElementNullable(VariableElement realmListVariableElement) {
+        return nullableValueListFields.contains(realmListVariableElement);
+    }
+
     /**
      * Checks if a VariableElement is indexed.
      *
@@ -182,10 +216,7 @@ public boolean isIndexed(VariableElement variableElement) {
      * @return {@code true} if a VariableElement is primary key, {@code false} otherwise.
      */
     public boolean isPrimaryKey(VariableElement variableElement) {
-        if (primaryKey == null) {
-            return false;
-        }
-        return primaryKey.equals(variableElement);
+        return primaryKey != null && primaryKey.equals(variableElement);
     }
 
     /**
@@ -195,10 +226,7 @@ public boolean isPrimaryKey(VariableElement variableElement) {
      */
     public boolean isModelClass() {
         String type = classType.toString();
-        if (type.equals("io.realm.DynamicRealmObject")) {
-            return false;
-        }
-        return (!type.endsWith(".RealmObject") && !type.endsWith("RealmProxy"));
+        return !type.equals("io.realm.DynamicRealmObject") && !type.endsWith(".RealmObject") && !type.endsWith("RealmProxy");
     }
 
     /**
@@ -244,11 +272,10 @@ public boolean generate() {
         packageName = packageElement.getQualifiedName().toString();
 
         if (!categorizeClassElements()) { return false; }
-        if (!checkListTypes()) { return false; }
+        if (!checkCollectionTypes()) { return false; }
         if (!checkReferenceTypes()) { return false; }
         if (!checkDefaultConstructor()) { return false; }
         if (!checkForFinalFields()) { return false; }
-        if (!checkForTransientFields()) { return false; }
         if (!checkForVolatileFields()) { return false; }
 
         return true; // Meta data was successfully generated
@@ -273,31 +300,20 @@ private boolean categorizeClassElements() {
         }
 
         if (fields.size() == 0) {
-            Utils.error(String.format("Class \"%s\" must contain at least 1 persistable field.", className));
+            Utils.error(String.format(Locale.US, "Class \"%s\" must contain at least 1 persistable field.", className));
         }
 
         return true;
     }
 
-    private boolean checkListTypes() {
+    private boolean checkCollectionTypes() {
         for (VariableElement field : fields) {
-            if (Utils.isRealmList(field) || Utils.isRealmResults(field)) {
-                // Check for missing generic (default back to Object)
-                if (Utils.getGenericTypeQualifiedName(field) == null) {
-                    Utils.error("No generic type supplied for field", field);
+            if (Utils.isRealmList(field)) {
+                if (!checkRealmListType(field)) {
                     return false;
                 }
-
-                // Check that the referenced type is a concrete class and not an interface
-                TypeMirror fieldType = field.asType();
-                List<? extends TypeMirror> typeArguments = ((DeclaredType) fieldType).getTypeArguments();
-                String genericCanonicalType = typeArguments.get(0).toString();
-                TypeElement typeElement = elements.getTypeElement(genericCanonicalType);
-                if (typeElement.getSuperclass().getKind() == TypeKind.NONE) {
-                    Utils.error(
-                            "Only concrete Realm classes are allowed in RealmLists. "
-                                    + "Neither interfaces nor abstract classes are allowed.",
-                            field);
+            } else if (Utils.isRealmResults(field)) {
+                if (!checkRealmResultsType(field)) {
                     return false;
                 }
             }
@@ -306,6 +322,75 @@ private boolean checkListTypes() {
         return true;
     }
 
+    private boolean checkRealmListType(VariableElement field) {
+        // Check for missing generic (default back to Object)
+        if (Utils.getGenericTypeQualifiedName(field) == null) {
+            Utils.error("No generic type supplied for field", field);
+            return false;
+        }
+
+        // Check that the referenced type is a concrete class and not an interface
+        TypeMirror fieldType = field.asType();
+        final TypeMirror elementTypeMirror = ((DeclaredType) fieldType).getTypeArguments().get(0);
+        if (elementTypeMirror.getKind() == TypeKind.DECLARED /* class of interface*/) {
+            TypeElement elementTypeElement = (TypeElement) ((DeclaredType) elementTypeMirror).asElement();
+            if (elementTypeElement.getSuperclass().getKind() == TypeKind.NONE) {
+                Utils.error(
+                        "Only concrete Realm classes are allowed in RealmLists. "
+                                + "Neither interfaces nor abstract classes are allowed.",
+                        field);
+                return false;
+            }
+        }
+
+        // Check if the actual value class is acceptable
+        if (!validListValueTypes.contains(elementTypeMirror) && !Utils.isRealmModel(elementTypeMirror)) {
+            final StringBuilder messageBuilder = new StringBuilder(
+                    "Element type of RealmList must be a class implementing 'RealmModel' or one of the ");
+            final String separator = ", ";
+            for (TypeMirror type : validListValueTypes) {
+                messageBuilder.append('\'').append(type.toString()).append('\'').append(separator);
+            }
+            messageBuilder.setLength(messageBuilder.length() - separator.length());
+            messageBuilder.append('.');
+            Utils.error(messageBuilder.toString(), field);
+            return false;
+        }
+
+        return true;
+    }
+
+    private boolean checkRealmResultsType(VariableElement field) {
+        // Only classes implementing RealmModel are allowed since RealmResults field is used only for backlinks.
+
+        // Check for missing generic (default back to Object)
+        if (Utils.getGenericTypeQualifiedName(field) == null) {
+            Utils.error("No generic type supplied for field", field);
+            return false;
+        }
+
+        TypeMirror fieldType = field.asType();
+        final TypeMirror elementTypeMirror = ((DeclaredType) fieldType).getTypeArguments().get(0);
+        if (elementTypeMirror.getKind() == TypeKind.DECLARED /* class or interface*/) {
+            TypeElement elementTypeElement = (TypeElement) ((DeclaredType) elementTypeMirror).asElement();
+            if (elementTypeElement.getSuperclass().getKind() == TypeKind.NONE) {
+                Utils.error(
+                        "Only concrete Realm classes are allowed in RealmResults. "
+                                + "Neither interfaces nor abstract classes are allowed.",
+                        field);
+                return false;
+            }
+        }
+
+        // Check if the actual value class is acceptable
+        if (!Utils.isRealmModel(elementTypeMirror)) {
+            Utils.error("Element type of RealmResults must be a class implementing 'RealmModel'.", field);
+            return false;
+        }
+
+        return true;
+    }
+
     private boolean checkReferenceTypes() {
         for (VariableElement field : fields) {
             if (Utils.isRealmModel(field)) {
@@ -327,7 +412,7 @@ private boolean checkReferenceTypes() {
     // Report if the default constructor is missing
     private boolean checkDefaultConstructor() {
         if (!hasDefaultConstructor) {
-            Utils.error(String.format(
+            Utils.error(String.format(Locale.US,
                     "Class \"%s\" must declare a public constructor with no arguments if it contains custom constructors.",
                     className));
             return false;
@@ -338,24 +423,17 @@ private boolean checkDefaultConstructor() {
 
     private boolean checkForFinalFields() {
         for (VariableElement field : fields) {
-            if (field.getModifiers().contains(Modifier.FINAL)) {
-                Utils.error(String.format(
-                        "Class \"%s\" contains illegal final field \"%s\".", className, field.getSimpleName().toString()));
-                return false;
+            if (!field.getModifiers().contains(Modifier.FINAL)) {
+                continue;
             }
-        }
-        return true;
-    }
-
-    private boolean checkForTransientFields() {
-        for (VariableElement field : fields) {
-            if (field.getModifiers().contains(Modifier.TRANSIENT)) {
-                Utils.error(String.format(
-                        "Class \"%s\" contains illegal transient field \"%s\".",
-                        className,
-                        field.getSimpleName().toString()));
-                return false;
+            if (Utils.isMutableRealmInteger(field)) {
+                continue;
             }
+
+            Utils.error(String.format(Locale.US, "Class \"%s\" contains illegal final field \"%s\".", className,
+                    field.getSimpleName().toString()));
+
+            return false;
         }
         return true;
     }
@@ -363,7 +441,7 @@ private boolean checkForTransientFields() {
     private boolean checkForVolatileFields() {
         for (VariableElement field : fields) {
             if (field.getModifiers().contains(Modifier.VOLATILE)) {
-                Utils.error(String.format(
+                Utils.error(String.format(Locale.US,
                         "Class \"%s\" contains illegal volatile field \"%s\".",
                         className,
                         field.getSimpleName().toString()));
@@ -374,79 +452,150 @@ private boolean checkForVolatileFields() {
     }
 
     private boolean categorizeField(Element element) {
-        VariableElement variableElement = (VariableElement) element;
+        VariableElement field = (VariableElement) element;
 
         // completely ignore any static fields
-        if (variableElement.getModifiers().contains(Modifier.STATIC)) { return true; }
+        if (field.getModifiers().contains(Modifier.STATIC)) { return true; }
 
-        if (variableElement.getAnnotation(Ignore.class) != null) { return true; }
+        // Ignore fields marked with @Ignore or if they are transient
+        if (field.getAnnotation(Ignore.class) != null || field.getModifiers().contains(Modifier.TRANSIENT)) {
+            return true;
+        }
 
-        if (variableElement.getAnnotation(Index.class) != null) {
-            if (!categorizeIndexField(element, variableElement)) { return false; }
+        if (field.getAnnotation(Index.class) != null) {
+            if (!categorizeIndexField(element, field)) { return false; }
         }
 
-        if (variableElement.getAnnotation(Required.class) != null) {
-            categorizeRequiredField(element, variableElement);
+        // @Required annotation of RealmList field only affects its value type, not field itself.
+        if (Utils.isRealmList(field)) {
+            // We only check @Required annotation. @org.jetbrains.annotations.NotNull annotation should not affect nullability of the list values.
+            if (!hasRequiredAnnotation(field)) {
+                final List<? extends TypeMirror> fieldTypeArguments = ((DeclaredType) field.asType()).getTypeArguments();
+                if (fieldTypeArguments.isEmpty() || !Utils.isRealmModel(fieldTypeArguments.get(0))) {
+                    nullableValueListFields.add(field);
+                }
+            }
+        } else if (isRequiredField(field)) {
+            categorizeRequiredField(element, field);
         } else {
-            // The field doesn't have the @Required annotation.
+            // The field doesn't have the @Required and @org.jetbrains.annotations.NotNull annotation.
             // Without @Required annotation, boxed types/RealmObject/Date/String/bytes should be added to
             // nullableFields.
-            // RealmList and Primitive types are NOT nullable always. @Required annotation is not supported.
-            if (!Utils.isPrimitiveType(variableElement) && !Utils.isRealmList(variableElement)) {
-                nullableFields.add(variableElement);
+            // RealmList of models, RealmResults(backlinks) and primitive types are NOT nullable. @Required annotation is not supported.
+            if (!Utils.isPrimitiveType(field) && !Utils.isRealmResults(field)) {
+                nullableFields.add(field);
             }
         }
 
-        if (variableElement.getAnnotation(PrimaryKey.class) != null) {
-            if (!categorizePrimaryKeyField(variableElement)) { return false; }
+        if (field.getAnnotation(PrimaryKey.class) != null) {
+            if (!categorizePrimaryKeyField(field)) { return false; }
         }
 
-        // Check @LinkingObjects last since it is not allowed to be either @Index, @Required or @PrimaryKey
-        if (variableElement.getAnnotation(LinkingObjects.class) != null) {
-            return categorizeBacklinkField(variableElement);
+        // @LinkingObjects cannot be @PrimaryKey or @Index.
+        if (field.getAnnotation(LinkingObjects.class) != null) {
+            // Do not add backlinks to fields list.
+            return categorizeBacklinkField(field);
         }
 
-        // Standard field that appear valid (more fine grained checks might fail later).
-        fields.add(variableElement);
+        // Similarly, a MutableRealmInteger cannot be a @PrimaryKey or @LinkingObject.
+        if (Utils.isMutableRealmInteger(field)) {
+            if (!categorizeMutableRealmIntegerField(field)) { return false; }
+        }
+
+        // Standard field that appears to be valid (more fine grained checks might fail later).
+        fields.add(field);
 
         return true;
     }
 
+    /**
+     * This method only checks if the field has {@code @Required} annotation.
+     * In most cases, you should use {@link #isRequiredField(VariableElement)} to take into account
+     * Kotlin's annotation as well.
+     *
+     * @param field target field.
+     * @return {@code true} if the field has {@code @Required} annotation, {@code false} otherwise.
+     * @see #isRequiredField(VariableElement)
+     */
+    private boolean hasRequiredAnnotation(VariableElement field) {
+        return field.getAnnotation(Required.class) != null;
+    }
+
+    /**
+     * Checks if the field is annotated as required.
+     * @param field target field.
+     * @return {@code true} if the field is annotated as required, {@code false} otherwise.
+     */
+    private boolean isRequiredField(VariableElement field) {
+        if (hasRequiredAnnotation(field)) {
+            return true;
+        }
+
+        if (ignoreKotlinNullability) {
+            return false;
+        }
+
+        // Kotlin uses the `org.jetbrains.annotations.NotNull` annotation to mark non-null fields.
+        // In order to fully support the Kotlin type system we interpret `@NotNull` as an alias
+        // for `@Required`
+        for (AnnotationMirror annotation : field.getAnnotationMirrors()) {
+            if (annotation.getAnnotationType().toString().equals("org.jetbrains.annotations.NotNull")) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    // The field has the @Index annotation. It's only valid for column types:
+    // STRING, DATE, INTEGER, BOOLEAN, and RealmMutableInteger
     private boolean categorizeIndexField(Element element, VariableElement variableElement) {
-        // The field has the @Index annotation. It's only valid for column types:
-        // STRING, DATE, INTEGER, BOOLEAN
-        String elementTypeCanonicalName = variableElement.asType().toString();
-        String columnType = Constants.JAVA_TO_COLUMN_TYPES.get(elementTypeCanonicalName);
-        if (columnType != null &&
-                (columnType.equals("RealmFieldType.STRING") ||
-                        columnType.equals("RealmFieldType.DATE") ||
-                        columnType.equals("RealmFieldType.INTEGER") ||
-                        columnType.equals("RealmFieldType.BOOLEAN"))) {
-            indexedFields.add(variableElement);
+        boolean indexable = false;
+
+        if (Utils.isMutableRealmInteger(variableElement)) {
+            indexable = true;
         } else {
-            Utils.error(String.format("Field \"%s\" of type \"%s\" cannot be an @Index.", element, element.asType()));
-            return false;
+            Constants.RealmFieldType realmType = Constants.JAVA_TO_REALM_TYPES.get(variableElement.asType().toString());
+            if (realmType != null) {
+                switch (realmType) {
+                    case STRING:
+                    case DATE:
+                    case INTEGER:
+                    case BOOLEAN:
+                        indexable = true;
+                }
+            }
         }
 
-        return true;
+        if (indexable) {
+            indexedFields.add(variableElement);
+            return true;
+        }
+
+        Utils.error(String.format(Locale.US, "Field \"%s\" of type \"%s\" cannot be an @Index.", element, element.asType()));
+        return false;
     }
 
     // The field has the @Required annotation
     private void categorizeRequiredField(Element element, VariableElement variableElement) {
         if (Utils.isPrimitiveType(variableElement)) {
-            Utils.error(String.format(
-                    "@Required annotation is unnecessary for primitive field \"%s\".", element));
-        } else if (Utils.isRealmList(variableElement) || Utils.isRealmModel(variableElement)) {
-            Utils.error(String.format(
-                    "Field \"%s\" with type \"%s\" cannot be @Required.", element, element.asType()));
-        } else {
-            // Should never get here - user should remove @Required
-            if (nullableFields.contains(variableElement)) {
-                Utils.error(String.format(
-                        "Field \"%s\" with type \"%s\" appears to be nullable. Consider removing @Required.",
-                        element,
-                        element.asType()));
-            }
+            Utils.error(String.format(Locale.US,
+                    "@Required or @NotNull annotation is unnecessary for primitive field \"%s\".", element));
+            return;
+        }
+
+        if (Utils.isRealmModel(variableElement)) {
+            Utils.error(String.format(Locale.US,
+                    "Field \"%s\" with type \"%s\" cannot be @Required or @NotNull.", element, element.asType()));
+            return;
+        }
+
+        // Should never get here - user should remove @Required
+        if (nullableFields.contains(variableElement)) {
+            Utils.error(String.format(Locale.US,
+                    "Field \"%s\" with type \"%s\" appears to be nullable. Consider removing @Required.",
+                    element,
+                    element.asType()));
         }
     }
 
@@ -454,7 +603,7 @@ private void categorizeRequiredField(Element element, VariableElement variableEl
     // String, short, int, long and must only be present one time
     private boolean categorizePrimaryKeyField(VariableElement variableElement) {
         if (primaryKey != null) {
-            Utils.error(String.format(
+            Utils.error(String.format(Locale.US,
                     "A class cannot have more than one @PrimaryKey. Both \"%s\" and \"%s\" are annotated as @PrimaryKey.",
                     primaryKey.getSimpleName().toString(),
                     variableElement.getSimpleName().toString()));
@@ -463,7 +612,7 @@ private boolean categorizePrimaryKeyField(VariableElement variableElement) {
 
         TypeMirror fieldType = variableElement.asType();
         if (!isValidPrimaryKeyType(fieldType)) {
-            Utils.error(String.format(
+            Utils.error(String.format(Locale.US,
                     "Field \"%s\" with type \"%s\" cannot be used as primary key. See @PrimaryKey for legal types.",
                     variableElement.getSimpleName().toString(),
                     fieldType));
@@ -489,6 +638,17 @@ private boolean categorizeBacklinkField(VariableElement variableElement) {
         return true;
     }
 
+    private boolean categorizeMutableRealmIntegerField(VariableElement field) {
+        if (field.getModifiers().contains(Modifier.FINAL)) {
+            return true;
+        }
+
+        Utils.error(String.format(Locale.US,
+                "Field \"%s\", a MutableRealmInteger, must be final.",
+                field.getSimpleName().toString()));
+        return false;
+    }
+
     private boolean isValidPrimaryKeyType(TypeMirror type) {
         for (TypeMirror validType : validPrimaryKeyTypes) {
             if (typeUtils.isAssignable(type, validType)) {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
index 4cd364a843..0c6d09306c 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Constants.java
@@ -16,6 +16,7 @@
 
 package io.realm.processor;
 
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -25,7 +26,6 @@
     public static final String PROXY_SUFFIX = "RealmProxy";
     public static final String INTERFACE_SUFFIX = "RealmProxyInterface";
     public static final String INDENT = "    ";
-    public static final String TABLE_PREFIX = "class_";
     public static final String DEFAULT_MODULE_CLASS_NAME = "DefaultRealmModule";
     static final String STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE =
             "throw new IllegalArgumentException(\"Trying to set non-nullable field '%s' to null.\")";
@@ -37,73 +37,103 @@
     static final String STATEMENT_EXCEPTION_ILLEGAL_JSON_LOAD =
             "throw new io.realm.exceptions.RealmException(\"\\\"%s\\\" field \\\"%s\\\" cannot be loaded from json\")";
 
-    static final Map<String, String> JAVA_TO_REALM_TYPES;
 
-    static {
-        JAVA_TO_REALM_TYPES = new HashMap<String, String>();
-        JAVA_TO_REALM_TYPES.put("byte", "Long");
-        JAVA_TO_REALM_TYPES.put("short", "Long");
-        JAVA_TO_REALM_TYPES.put("int", "Long");
-        JAVA_TO_REALM_TYPES.put("long", "Long");
-        JAVA_TO_REALM_TYPES.put("float", "Float");
-        JAVA_TO_REALM_TYPES.put("double", "Double");
-        JAVA_TO_REALM_TYPES.put("boolean", "Boolean");
-        JAVA_TO_REALM_TYPES.put("java.lang.Byte", "Long");
-        JAVA_TO_REALM_TYPES.put("java.lang.Short", "Long");
-        JAVA_TO_REALM_TYPES.put("java.lang.Integer", "Long");
-        JAVA_TO_REALM_TYPES.put("java.lang.Long", "Long");
-        JAVA_TO_REALM_TYPES.put("java.lang.Float", "Float");
-        JAVA_TO_REALM_TYPES.put("java.lang.Double", "Double");
-        JAVA_TO_REALM_TYPES.put("java.lang.Boolean", "Boolean");
-        JAVA_TO_REALM_TYPES.put("java.lang.String", "String");
-        JAVA_TO_REALM_TYPES.put("java.util.Date", "Date");
-        JAVA_TO_REALM_TYPES.put("byte[]", "BinaryByteArray");
-        // TODO: add support for char and Char
+    /**
+     * Realm types and their corresponding Java types
+     */
+    public enum RealmFieldType {
+        NOTYPE(null, "Void"),
+        INTEGER("INTEGER", "Long"),
+        FLOAT("FLOAT", "Float"),
+        DOUBLE("DOUBLE", "Double"),
+        BOOLEAN("BOOLEAN", "Boolean"),
+        STRING("STRING", "String"),
+        DATE("DATE", "Date"),
+        BINARY("BINARY", "BinaryByteArray"),
+        REALM_INTEGER("INTEGER", "Long"),
+        OBJECT("OBJECT", "Object"),
+        LIST("LIST", "List"),
+
+        BACKLINK("LINKING_OBJECTS", null),
+
+        INTEGER_LIST("INTEGER_LIST", "List"),
+        BOOLEAN_LIST("BOOLEAN_LIST", "List"),
+        STRING_LIST("STRING_LIST", "List"),
+        BINARY_LIST("BINARY_LIST", "List"),
+        DATE_LIST("DATE_LIST", "List"),
+        FLOAT_LIST("FLOAT_LIST", "List"),
+        DOUBLE_LIST("DOUBLE_LIST", "List");
+
+        private final String realmType;
+        private final String javaType;
+
+        /**
+         * @param realmType The simple name of the Enum type used in the Java bindings, to represent this type.
+         * @param javaType The simple name of the Java type needed to store this Realm Type
+         */
+        RealmFieldType(String realmType, String javaType) {
+            this.realmType = "RealmFieldType." + realmType;
+            this.javaType = javaType;
+        }
+
+        /**
+         * Get the name of the enum, used in the Java bindings, used to represent the corresponding type.
+         * @return the name of the enum used to represent this Realm Type
+         */
+        public String getRealmType() {
+            return realmType;
+        }
+
+        /**
+         * Get the name of the Java type needed to store this Realm Type
+         * @return the simple name for the corresponding Java type
+         */
+        public String getJavaType() {
+            return javaType;
+        }
     }
 
-    static final Map<String, String> JAVA_TO_COLUMN_TYPES;
+
+    static final Map<String, RealmFieldType> JAVA_TO_REALM_TYPES;
 
     static {
-        JAVA_TO_COLUMN_TYPES = new HashMap<String, String>();
-        JAVA_TO_COLUMN_TYPES.put("byte", "RealmFieldType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("short", "RealmFieldType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("int", "RealmFieldType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("long", "RealmFieldType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("float", "RealmFieldType.FLOAT");
-        JAVA_TO_COLUMN_TYPES.put("double", "RealmFieldType.DOUBLE");
-        JAVA_TO_COLUMN_TYPES.put("boolean", "RealmFieldType.BOOLEAN");
-        JAVA_TO_COLUMN_TYPES.put("java.lang.Byte", "RealmFieldType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("java.lang.Short", "RealmFieldType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("java.lang.Integer", "RealmFieldType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("java.lang.Long", "RealmFieldType.INTEGER");
-        JAVA_TO_COLUMN_TYPES.put("java.lang.Float", "RealmFieldType.FLOAT");
-        JAVA_TO_COLUMN_TYPES.put("java.lang.Double", "RealmFieldType.DOUBLE");
-        JAVA_TO_COLUMN_TYPES.put("java.lang.Boolean", "RealmFieldType.BOOLEAN");
-        JAVA_TO_COLUMN_TYPES.put("java.lang.String", "RealmFieldType.STRING");
-        JAVA_TO_COLUMN_TYPES.put("java.util.Date", "RealmFieldType.DATE");
-        JAVA_TO_COLUMN_TYPES.put("byte[]", "RealmFieldType.BINARY");
+        Map<String, RealmFieldType> m = new HashMap<String, RealmFieldType>();
+        m.put("byte", RealmFieldType.INTEGER);
+        m.put("short", RealmFieldType.INTEGER);
+        m.put("int", RealmFieldType.INTEGER);
+        m.put("long", RealmFieldType.INTEGER);
+        m.put("float", RealmFieldType.FLOAT);
+        m.put("double", RealmFieldType.DOUBLE);
+        m.put("boolean", RealmFieldType.BOOLEAN);
+        m.put("java.lang.Byte", RealmFieldType.INTEGER);
+        m.put("java.lang.Short", RealmFieldType.INTEGER);
+        m.put("java.lang.Integer", RealmFieldType.INTEGER);
+        m.put("java.lang.Long", RealmFieldType.INTEGER);
+        m.put("java.lang.Float", RealmFieldType.FLOAT);
+        m.put("java.lang.Double", RealmFieldType.DOUBLE);
+        m.put("java.lang.Boolean", RealmFieldType.BOOLEAN);
+        m.put("java.lang.String", RealmFieldType.STRING);
+        m.put("java.util.Date", RealmFieldType.DATE);
+        m.put("byte[]", RealmFieldType.BINARY);
+        // TODO: add support for char and Char
+        JAVA_TO_REALM_TYPES = Collections.unmodifiableMap(m);
     }
 
-    static final Map<String, String> JAVA_TO_FIELD_SETTER;
+
+    static final Map<String, RealmFieldType> LIST_ELEMENT_TYPE_TO_REALM_TYPES;
 
     static {
-        JAVA_TO_FIELD_SETTER = new HashMap<String, String>();
-        JAVA_TO_FIELD_SETTER.put("byte", "setByte");
-        JAVA_TO_FIELD_SETTER.put("short", "setShort");
-        JAVA_TO_FIELD_SETTER.put("int", "setInt");
-        JAVA_TO_FIELD_SETTER.put("long", "setLong");
-        JAVA_TO_FIELD_SETTER.put("float", "setFloat");
-        JAVA_TO_FIELD_SETTER.put("double", "setDouble");
-        JAVA_TO_FIELD_SETTER.put("boolean", "setBoolean");
-        JAVA_TO_FIELD_SETTER.put("java.lang.Byte", "set");
-        JAVA_TO_FIELD_SETTER.put("java.lang.Short", "set");
-        JAVA_TO_FIELD_SETTER.put("java.lang.Integer", "set");
-        JAVA_TO_FIELD_SETTER.put("java.lang.Long", "set");
-        JAVA_TO_FIELD_SETTER.put("java.lang.Float", "set");
-        JAVA_TO_FIELD_SETTER.put("java.lang.Double", "set");
-        JAVA_TO_FIELD_SETTER.put("java.lang.Boolean", "set");
-        JAVA_TO_FIELD_SETTER.put("java.lang.String", "set");
-        JAVA_TO_FIELD_SETTER.put("java.util.Date", "set");
-        JAVA_TO_FIELD_SETTER.put("byte[]", "set");
+        Map<String, RealmFieldType> m = new HashMap<String, RealmFieldType>();
+        m.put("java.lang.Byte", RealmFieldType.INTEGER_LIST);
+        m.put("java.lang.Short", RealmFieldType.INTEGER_LIST);
+        m.put("java.lang.Integer", RealmFieldType.INTEGER_LIST);
+        m.put("java.lang.Long", RealmFieldType.INTEGER_LIST);
+        m.put("java.lang.Float", RealmFieldType.FLOAT_LIST);
+        m.put("java.lang.Double", RealmFieldType.DOUBLE_LIST);
+        m.put("java.lang.Boolean", RealmFieldType.BOOLEAN_LIST);
+        m.put("java.lang.String", RealmFieldType.STRING_LIST);
+        m.put("java.util.Date", RealmFieldType.DATE_LIST);
+        m.put("byte[]", RealmFieldType.BINARY_LIST);
+        LIST_ELEMENT_TYPE_TO_REALM_TYPES = Collections.unmodifiableMap(m);
     }
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java
index 1b177c5183..cdae9807cc 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/DefaultModuleGenerator.java
@@ -22,6 +22,7 @@
 import java.io.IOException;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.Locale;
 import java.util.Map;
 
 import javax.annotation.processing.ProcessingEnvironment;
@@ -44,7 +45,7 @@ public DefaultModuleGenerator(ProcessingEnvironment env) {
     }
 
     public void generate() throws IOException {
-        String qualifiedGeneratedClassName = String.format("%s.%s", Constants.REALM_PACKAGE_NAME, Constants.DEFAULT_MODULE_CLASS_NAME);
+        String qualifiedGeneratedClassName = String.format(Locale.US, "%s.%s", Constants.REALM_PACKAGE_NAME, Constants.DEFAULT_MODULE_CLASS_NAME);
         JavaFileObject sourceFile = env.getFiler().createSourceFile(qualifiedGeneratedClassName);
         JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));
         writer.setIndent("    ");
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
index 2239201e2e..dcaa1fd63b 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmJsonTypeHelper.java
@@ -19,7 +19,9 @@
 import com.squareup.javawriter.JavaWriter;
 
 import java.io.IOException;
+import java.util.Collections;
 import java.util.HashMap;
+import java.util.Locale;
 import java.util.Map;
 
 
@@ -30,221 +32,148 @@
     private static final Map<String, JsonToRealmFieldTypeConverter> JAVA_TO_JSON_TYPES;
 
     static {
-        JAVA_TO_JSON_TYPES = new HashMap<String, JsonToRealmFieldTypeConverter>();
-        JAVA_TO_JSON_TYPES.put("byte", new SimpleTypeConverter("byte", "Int"));
-        JAVA_TO_JSON_TYPES.put("short", new SimpleTypeConverter("short", "Int"));
-        JAVA_TO_JSON_TYPES.put("int", new SimpleTypeConverter("int", "Int"));
-        JAVA_TO_JSON_TYPES.put("long", new SimpleTypeConverter("long", "Long"));
-        JAVA_TO_JSON_TYPES.put("float", new SimpleTypeConverter("float", "Double"));
-        JAVA_TO_JSON_TYPES.put("double", new SimpleTypeConverter("double", "Double"));
-        JAVA_TO_JSON_TYPES.put("boolean", new SimpleTypeConverter("boolean", "Boolean"));
-        JAVA_TO_JSON_TYPES.put("java.lang.Byte", new SimpleTypeConverter("byte", "Int"));
-        JAVA_TO_JSON_TYPES.put("java.lang.Short", new SimpleTypeConverter("short", "Int"));
-        JAVA_TO_JSON_TYPES.put("java.lang.Integer", new SimpleTypeConverter("int", "Int"));
-        JAVA_TO_JSON_TYPES.put("java.lang.Long", new SimpleTypeConverter("long", "Long"));
-        JAVA_TO_JSON_TYPES.put("java.lang.Float", new SimpleTypeConverter("float", "Double"));
-        JAVA_TO_JSON_TYPES.put("java.lang.Double", new SimpleTypeConverter("double", "Double"));
-        JAVA_TO_JSON_TYPES.put("java.lang.Boolean", new SimpleTypeConverter("boolean", "Boolean"));
-        JAVA_TO_JSON_TYPES.put("java.lang.String", new SimpleTypeConverter("String", "String"));
-        JAVA_TO_JSON_TYPES.put("java.util.Date", new JsonToRealmFieldTypeConverter() {
-            // @formatter:off
-            @Override
-            public void emitTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
-                JavaWriter writer) throws IOException {
-                writer
-                    .beginControlFlow("if (json.has(\"%s\"))", fieldName)
-                        .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
-                            .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
-                        .nextControlFlow("else")
-                            .emitStatement("Object timestamp = json.get(\"%s\")", fieldName)
-                            .beginControlFlow("if (timestamp instanceof String)")
-                               .emitStatement("((%s) obj).%s(JsonUtils.stringToDate((String) timestamp))",
-                                       interfaceName, setter)
-                            .nextControlFlow("else")
-                                .emitStatement("((%s) obj).%s(new Date(json.getLong(\"%s\")))", interfaceName, setter,
-                                        fieldName)
-                            .endControlFlow()
-                        .endControlFlow()
-                    .endControlFlow();
-            }
-            //@formatter:on
-
-            // @formatter:off
-            @Override
-            public void emitStreamTypeConversion(String interfaceName, String setter, String fieldName,
-                String fieldType, JavaWriter writer, boolean isPrimaryKey) throws IOException {
-                writer
-                    .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
-                        .emitStatement("reader.skipValue()")
-                        .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
-                    .nextControlFlow("else if (reader.peek() == JsonToken.NUMBER)")
-                        .emitStatement("long timestamp = reader.nextLong()", fieldName)
-                        .beginControlFlow("if (timestamp > -1)")
-                            .emitStatement("((%s) obj).%s(new Date(timestamp))", interfaceName, setter)
-                        .endControlFlow()
-                    .nextControlFlow("else")
-                        .emitStatement("((%s) obj).%s(JsonUtils.stringToDate(reader.nextString()))", interfaceName,
-                                setter)
-                    .endControlFlow();
-            }
-            //@formatter:on
-
-            @Override
-            public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
-                    String qualifiedRealmObjectProxyClass, String fieldName, JavaWriter writer) throws IOException {
-                throw new IllegalArgumentException("'Date' is not allowed as a primary key value.");
-            }
-        });
-        JAVA_TO_JSON_TYPES.put("byte[]", new JsonToRealmFieldTypeConverter() {
-            // @formatter:off
-            @Override
-            public void emitTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
-                JavaWriter writer) throws IOException {
-                writer
-                    .beginControlFlow("if (json.has(\"%s\"))", fieldName)
-                        .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
-                            .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
-                        .nextControlFlow("else")
-                            .emitStatement("((%s) obj).%s(JsonUtils.stringToBytes(json.getString(\"%s\")))",
-                                    interfaceName, setter, fieldName)
-                        .endControlFlow()
-                    .endControlFlow();
-            }
-            //@formatter:on
-
-            // @formatter:off
-            @Override
-            public void emitStreamTypeConversion(String interfaceName, String setter, String fieldName,
-                String fieldType, JavaWriter writer, boolean isPrimaryKey) throws IOException {
-                writer
-                    .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
-                        .emitStatement("reader.skipValue()")
-                        .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
-                    .nextControlFlow("else")
-                        .emitStatement("((%s) obj).%s(JsonUtils.stringToBytes(reader.nextString()))", interfaceName,
-                                setter)
-                    .endControlFlow();
-            }
-            //@formatter:on
-
-            @Override
-            public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
-                    String qualifiedRealmObjectProxyClass, String fieldName, JavaWriter writer) throws IOException {
-                throw new IllegalArgumentException("'byte[]' is not allowed as a primary key value.");
-            }
-        });
+        Map<String, JsonToRealmFieldTypeConverter> m = new HashMap<String, JsonToRealmFieldTypeConverter>();
+        m.put("byte", new SimpleTypeConverter("byte", "Int"));
+        m.put("short", new SimpleTypeConverter("short", "Int"));
+        m.put("int", new SimpleTypeConverter("int", "Int"));
+        m.put("long", new SimpleTypeConverter("long", "Long"));
+        m.put("float", new SimpleTypeConverter("float", "Double"));
+        m.put("double", new SimpleTypeConverter("double", "Double"));
+        m.put("boolean", new SimpleTypeConverter("boolean", "Boolean"));
+        m.put("byte[]", new ByteArrayTypeConverter());
+        m.put("java.lang.Byte", m.get("byte"));
+        m.put("java.lang.Short", m.get("short"));
+        m.put("java.lang.Integer", m.get("int"));
+        m.put("java.lang.Long", m.get("long"));
+        m.put("java.lang.Float", m.get("float"));
+        m.put("java.lang.Double", m.get("double"));
+        m.put("java.lang.Boolean", m.get("boolean"));
+        m.put("java.lang.String", new SimpleTypeConverter("String", "String"));
+        m.put("java.util.Date", new DateTypeConverter());
+        m.put("io.realm.MutableRealmInteger", new MutableRealmIntegerTypeConverter());
+        JAVA_TO_JSON_TYPES = Collections.unmodifiableMap(m);
     }
 
-    public static void emitCreateObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
-            String qualifiedRealmObjectProxyClass, String qualifiedFieldType, String fieldName, JavaWriter writer)
+    // Static helper class
+    private RealmJsonTypeHelper() { }
+
+    // @formatter:off
+    public static void emitIllegalJsonValueException(String fieldType, String fieldName, JavaWriter writer)
             throws IOException {
-        JsonToRealmFieldTypeConverter typeEmitter = JAVA_TO_JSON_TYPES.get(qualifiedFieldType);
-        if (typeEmitter != null) {
-            typeEmitter.emitGetObjectWithPrimaryKeyValue(qualifiedRealmObjectClass, qualifiedRealmObjectProxyClass,
-                    fieldName, writer);
-        }
+        writer
+            .beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_JSON_LOAD, fieldType, fieldName)
+            .endControlFlow();
     }
+    // @formatter:on
 
-    public static void emitFillJavaTypeWithJsonValue(String interfaceName, String setter, String fieldName,
-            String qualifiedFieldType, JavaWriter writer) throws IOException {
+    public static void emitCreateObjectWithPrimaryKeyValue(
+            String qualifiedRealmObjectClass, String qualifiedRealmObjectProxyClass, String qualifiedFieldType, String fieldName, JavaWriter writer)
+            throws IOException {
         JsonToRealmFieldTypeConverter typeEmitter = JAVA_TO_JSON_TYPES.get(qualifiedFieldType);
         if (typeEmitter != null) {
-            typeEmitter.emitTypeConversion(interfaceName, setter, fieldName, qualifiedFieldType, writer);
+            typeEmitter.emitGetObjectWithPrimaryKeyValue(
+                    qualifiedRealmObjectClass, qualifiedRealmObjectProxyClass, fieldName, writer);
         }
     }
 
-    public static void emitIllegalJsonValueException(String fieldType, String fieldName, JavaWriter writer)
-            throws IOException {
-        writer.beginControlFlow("if (json.has(\"%s\"))", fieldName);
-        writer.emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_JSON_LOAD, fieldType, fieldName);
-        writer.endControlFlow();
-    }
-
     // @formatter:off
-    public static void emitFillRealmObjectWithJsonValue(String interfaceName, String setter, String fieldName,
-        String qualifiedFieldType, String proxyClass, JavaWriter writer) throws IOException {
+    public static void emitFillRealmObjectWithJsonValue(
+            String varName, String setter, String fieldName, String qualifiedFieldType, String proxyClass, JavaWriter writer)
+            throws IOException {
         writer
             .beginControlFlow("if (json.has(\"%s\"))", fieldName)
                 .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
-                    .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+                    .emitStatement("%s.%s(null)", varName, setter)
                 .nextControlFlow("else")
-                    .emitStatement("%s %sObj = %s.createOrUpdateUsingJsonObject(realm, json.getJSONObject(\"%s\"), update)",
-                            qualifiedFieldType, fieldName, proxyClass, fieldName)
-                    .emitStatement("((%s) obj).%s(%sObj)", interfaceName, setter, fieldName)
+                    .emitStatement(
+                        "%s %sObj = %s.createOrUpdateUsingJsonObject(realm, json.getJSONObject(\"%s\"), update)",
+                        qualifiedFieldType, fieldName, proxyClass, fieldName)
+                    .emitStatement("%s.%s(%sObj)", varName, setter, fieldName)
                 .endControlFlow()
             .endControlFlow();
     }
-    //@formatter:on
+    // @formatter:on
 
     // @formatter:off
-    public static void emitFillRealmListWithJsonValue(String interfaceName, String getter, String setter,
-        String fieldName, String fieldTypeCanonicalName, String proxyClass, JavaWriter writer) throws IOException {
+    public static void emitFillRealmListWithJsonValue(
+            String varName, String getter, String setter, String fieldName, String fieldTypeCanonicalName, String proxyClass, JavaWriter writer)
+            throws IOException {
         writer
             .beginControlFlow("if (json.has(\"%s\"))", fieldName)
                 .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
-                    .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+                    .emitStatement("%s.%s(null)", varName, setter)
                 .nextControlFlow("else")
-                    .emitStatement("((%s) obj).%s().clear()", interfaceName, getter)
+                    .emitStatement("%s.%s().clear()", varName, getter)
                     .emitStatement("JSONArray array = json.getJSONArray(\"%s\")", fieldName)
                     .beginControlFlow("for (int i = 0; i < array.length(); i++)")
-                        .emitStatement("%s item = %s.createOrUpdateUsingJsonObject(realm, array.getJSONObject(i), update)",
+                        .emitStatement(
+                                "%s item = %s.createOrUpdateUsingJsonObject(realm, array.getJSONObject(i), update)",
                                 fieldTypeCanonicalName, proxyClass, fieldTypeCanonicalName)
-                        .emitStatement("((%s) obj).%s().add(item)", interfaceName, getter)
+                        .emitStatement("%s.%s().add(item)", varName, getter)
                     .endControlFlow()
                 .endControlFlow()
             .endControlFlow();
     }
-    //@formatter:on
-
-    public static void emitFillJavaTypeFromStream(String interfaceName, ClassMetaData metaData, String fieldName,
-            String fieldType, JavaWriter writer) throws IOException {
-        String setter = metaData.getInternalSetter(fieldName);
-        boolean isPrimaryKey = false;
-        if (metaData.hasPrimaryKey() && metaData.getPrimaryKey().getSimpleName().toString().equals(fieldName)) {
-            isPrimaryKey = true;
-        }
-        if (JAVA_TO_JSON_TYPES.containsKey(fieldType)) {
-            JAVA_TO_JSON_TYPES.get(fieldType).emitStreamTypeConversion(interfaceName, setter, fieldName, fieldType,
-                    writer, isPrimaryKey);
+    // @formatter:on
+
+    public static void emitFillJavaTypeWithJsonValue(
+            String varName, String accessor, String fieldName, String qualifiedFieldType, JavaWriter writer)
+            throws IOException {
+        JsonToRealmFieldTypeConverter typeEmitter = JAVA_TO_JSON_TYPES.get(qualifiedFieldType);
+        if (typeEmitter != null) {
+            typeEmitter.emitTypeConversion(varName, accessor, fieldName, qualifiedFieldType, writer);
         }
     }
 
     // @formatter:off
-    public static void emitFillRealmObjectFromStream(String interfaceName, String setter, String fieldName,
-        String fieldTypeCanonicalName, String proxyClass, JavaWriter writer) throws IOException {
+    public static void emitFillRealmObjectFromStream(
+            String varName, String setter, String fieldName, String fieldTypeCanonicalName, String proxyClass, JavaWriter writer)
+            throws IOException {
         writer
             .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
                 .emitStatement("reader.skipValue()")
-                .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+                .emitStatement("%s.%s(null)", varName, setter)
             .nextControlFlow("else")
-                .emitStatement("%s %sObj = %s.createUsingJsonStream(realm, reader)", fieldTypeCanonicalName, fieldName,
-                        proxyClass)
-                .emitStatement("((%s) obj).%s(%sObj)", interfaceName, setter, fieldName)
+                .emitStatement(
+                        "%s %sObj = %s.createUsingJsonStream(realm, reader)",
+                        fieldTypeCanonicalName, fieldName, proxyClass)
+                .emitStatement("%s.%s(%sObj)", varName, setter, fieldName)
             .endControlFlow();
     }
-    //@formatter:on
+    // @formatter:on
 
     // @formatter:off
-    public static void emitFillRealmListFromStream(String interfaceName, String getter, String setter,
-        String fieldTypeCanonicalName, String proxyClass, JavaWriter writer) throws IOException {
+    public static void emitFillRealmListFromStream(
+            String varName, String getter, String setter, String fieldTypeCanonicalName, String proxyClass, JavaWriter writer)
+            throws IOException {
         writer
             .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
                 .emitStatement("reader.skipValue()")
-                .emitStatement("((%s) obj).%s(null)", interfaceName, setter)
+                .emitStatement("%s.%s(null)", varName, setter)
             .nextControlFlow("else")
-                .emitStatement("((%s) obj).%s(new RealmList<%s>())", interfaceName, setter, fieldTypeCanonicalName)
+                .emitStatement("%s.%s(new RealmList<%s>())", varName, setter, fieldTypeCanonicalName)
                 .emitStatement("reader.beginArray()")
                 .beginControlFlow("while (reader.hasNext())")
                     .emitStatement("%s item = %s.createUsingJsonStream(realm, reader)", fieldTypeCanonicalName, proxyClass)
-                    .emitStatement("((%s) obj).%s().add(item)", interfaceName, getter)
+                    .emitStatement("%s.%s().add(item)", varName, getter)
                 .endControlFlow()
                 .emitStatement("reader.endArray()")
             .endControlFlow();
     }
-    //@formatter:on
+    // @formatter:on
 
-    private static class SimpleTypeConverter implements JsonToRealmFieldTypeConverter {
+    public static void emitFillJavaTypeFromStream(
+            String varName, ClassMetaData metaData, String accessor, String fieldName, String fieldType, JavaWriter writer)
+            throws IOException {
+        boolean isPrimaryKey = metaData.hasPrimaryKey() && metaData.getPrimaryKey().getSimpleName().toString().equals(fieldName);
+        JsonToRealmFieldTypeConverter typeEmitter = JAVA_TO_JSON_TYPES.get(fieldType);
+        if (typeEmitter != null) {
+            typeEmitter.emitStreamTypeConversion(varName, accessor, fieldName, fieldType, writer, isPrimaryKey);
+        }
+    }
 
+    private static class SimpleTypeConverter implements JsonToRealmFieldTypeConverter {
         private final String castType;
         private final String jsonType;
 
@@ -261,84 +190,205 @@ private SimpleTypeConverter(String castType, String jsonType) {
         }
 
         @Override
-        public void emitTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
-                JavaWriter writer) throws IOException {
-            String statementSetNullOrThrow;
-            if (Utils.isPrimitiveType(fieldType)) {
-                // Only throw exception for primitive types. For boxed types and String, exception will be thrown in
-                // the setter.
-                statementSetNullOrThrow = String.format(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName);
-            } else {
-                statementSetNullOrThrow = String.format("((%s) obj).%s(null)", interfaceName, setter);
-            }
+        public void emitTypeConversion(
+                String varName, String accessor, String fieldName, String fieldType, JavaWriter writer)
+                throws IOException {
+            // Only throw exception for primitive types.
+            // For boxed types and String, exception will be thrown in the setter.
+            String statementSetNullOrThrow = Utils.isPrimitiveType(fieldType) ?
+                    String.format(Locale.US, Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName) :
+                    String.format(Locale.US, "%s.%s(null)", varName, accessor);
+
             // @formatter:off
             writer
                 .beginControlFlow("if (json.has(\"%s\"))", fieldName)
                     .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
                         .emitStatement(statementSetNullOrThrow)
                     .nextControlFlow("else")
-                        .emitStatement("((%s) obj).%s((%s) json.get%s(\"%s\"))", interfaceName, setter, castType,
-                                jsonType, fieldName)
+                        .emitStatement("%s.%s((%s) json.get%s(\"%s\"))", varName, accessor, castType, jsonType, fieldName)
                     .endControlFlow()
                 .endControlFlow();
-            //@formatter:on
+            // @formatter:on
         }
 
         @Override
-        public void emitStreamTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
-                JavaWriter writer, boolean isPrimaryKey) throws IOException {
-            String statementSetNullOrThrow;
-            if (Utils.isPrimitiveType(fieldType)) {
-                // Only throw exception for primitive types. For boxed types and String, exception will be thrown in
-                // the setter.
-                statementSetNullOrThrow = String.format(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName);
-            } else {
-                statementSetNullOrThrow = String.format("((%s) obj).%s(null)", interfaceName, setter);
-            }
+        public void emitStreamTypeConversion(
+                String varName, String setter, String fieldName, String fieldType, JavaWriter writer, boolean isPrimaryKey)
+                throws IOException {
+            // Only throw exception for primitive types.
+            // For boxed types and String, exception will be thrown in the setter.
+            String statementSetNullOrThrow = (Utils.isPrimitiveType(fieldType)) ?
+                    String.format(Locale.US, Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName) :
+                    String.format(Locale.US, "%s.%s(null)", varName, setter);
+
             // @formatter:off
             writer
-                .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
+                .beginControlFlow("if (reader.peek() != JsonToken.NULL)")
+                    .emitStatement("%s.%s((%s) reader.next%s())", varName, setter, castType, jsonType)
+                .nextControlFlow("else")
                     .emitStatement("reader.skipValue()")
                     .emitStatement(statementSetNullOrThrow)
-                .nextControlFlow("else")
-                    .emitStatement("((%s) obj).%s((%s) reader.next%s())", interfaceName, setter, castType, jsonType)
                 .endControlFlow();
+            // @formatter:on
+
             if (isPrimaryKey) {
                 writer.emitStatement("jsonHasPrimaryKey = true");
             }
-            //@formatter:on
         }
 
         // @formatter:off
         @Override
         public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass,
             String qualifiedRealmObjectProxyClass, String fieldName, JavaWriter writer) throws IOException {
-            // No error checking is done here for valid primary key types. This should be done by the annotation
-            // processor
+            // No error checking is done here for valid primary key types.
+            // This should be done by the annotation processor.
             writer
                 .beginControlFlow("if (json.has(\"%s\"))", fieldName)
                     .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
                         .emitStatement("obj = (%1$s) realm.createObjectInternal(%2$s.class, null, true, excludeFields)",
                                 qualifiedRealmObjectProxyClass, qualifiedRealmObjectClass)
                     .nextControlFlow("else")
-                        .emitStatement("obj = (%1$s) realm.createObjectInternal(%2$s.class, json.get%3$s(\"%4$s\"), true, excludeFields)",
+                        .emitStatement(
+                                "obj = (%1$s) realm.createObjectInternal(%2$s.class, json.get%3$s(\"%4$s\"), true, excludeFields)",
                                 qualifiedRealmObjectProxyClass, qualifiedRealmObjectClass, jsonType, fieldName)
                     .endControlFlow()
                 .nextControlFlow("else")
                     .emitStatement(Constants.STATEMENT_EXCEPTION_NO_PRIMARY_KEY_IN_JSON, fieldName)
-                    .endControlFlow();
+                .endControlFlow();
+        }
+        // @formatter:on
+    }
+
+    private static class ByteArrayTypeConverter implements JsonToRealmFieldTypeConverter {
+        // @formatter:off
+        @Override
+        public void emitTypeConversion(String varName, String accessor, String fieldName, String fieldType, JavaWriter writer)
+                throws IOException {
+            writer
+                .beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                    .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
+                        .emitStatement("%s.%s(null)", varName, accessor)
+                    .nextControlFlow("else")
+                        .emitStatement("%s.%s(JsonUtils.stringToBytes(json.getString(\"%s\")))", varName, accessor, fieldName)
+                    .endControlFlow()
+                .endControlFlow();
+        }
+        // @formatter:on
+
+        // @formatter:off
+        @Override
+        public void emitStreamTypeConversion(String varName, String accessor, String fieldName, String fieldType, JavaWriter writer, boolean isPrimaryKey)
+                throws IOException {
+            writer
+                .beginControlFlow("if (reader.peek() != JsonToken.NULL)")
+                    .emitStatement("%s.%s(JsonUtils.stringToBytes(reader.nextString()))", varName, accessor)
+                .nextControlFlow("else")
+                    .emitStatement("reader.skipValue()")
+                    .emitStatement("%s.%s(null)", varName, accessor)
+                .endControlFlow();
+        }
+        // @formatter:on
+
+        @Override
+        public void emitGetObjectWithPrimaryKeyValue(
+                String qualifiedRealmObjectClass, String qualifiedRealmObjectProxyClass, String fieldName, JavaWriter writer)
+                throws IOException {
+            throw new IllegalArgumentException("'byte[]' is not allowed as a primary key value.");
+        }
+    }
+
+    private static class DateTypeConverter implements JsonToRealmFieldTypeConverter {
+        // @formatter:off
+        @Override
+        public void emitTypeConversion(
+                String varName, String accessor, String fieldName, String fieldType, JavaWriter writer)
+                throws IOException {
+            writer
+                .beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                    .beginControlFlow("if (json.isNull(\"%s\"))", fieldName)
+                        .emitStatement("%s.%s(null)", varName, accessor)
+                    .nextControlFlow("else")
+                        .emitStatement("Object timestamp = json.get(\"%s\")", fieldName)
+                        .beginControlFlow("if (timestamp instanceof String)")
+                            .emitStatement("%s.%s(JsonUtils.stringToDate((String) timestamp))", varName, accessor)
+                        .nextControlFlow("else")
+                            .emitStatement("%s.%s(new Date(json.getLong(\"%s\")))", varName, accessor, fieldName)
+                        .endControlFlow()
+                    .endControlFlow()
+                .endControlFlow();
+        }
+        // @formatter:on
+
+        // @formatter:off
+        @Override
+        public void emitStreamTypeConversion(
+                String varName, String accessor, String fieldName, String fieldType, JavaWriter writer, boolean isPrimaryKey)
+                throws IOException {
+            writer
+                .beginControlFlow("if (reader.peek() == JsonToken.NULL)")
+                    .emitStatement("reader.skipValue()")
+                    .emitStatement("%s.%s(null)", varName, accessor)
+                .nextControlFlow("else if (reader.peek() == JsonToken.NUMBER)")
+                    .emitStatement("long timestamp = reader.nextLong()", fieldName)
+                    .beginControlFlow("if (timestamp > -1)")
+                        .emitStatement("%s.%s(new Date(timestamp))", varName, accessor)
+                    .endControlFlow()
+                .nextControlFlow("else")
+                    .emitStatement("%s.%s(JsonUtils.stringToDate(reader.nextString()))", varName, accessor)
+                .endControlFlow();
+        }
+        // @formatter:on
+
+        @Override
+        public void emitGetObjectWithPrimaryKeyValue(
+                String qualifiedRealmObjectClass, String qualifiedRealmObjectProxyClass, String fieldName, JavaWriter writer)
+                throws IOException {
+            throw new IllegalArgumentException("'Date' is not allowed as a primary key value.");
+        }
+    }
+
+    private static class MutableRealmIntegerTypeConverter implements JsonToRealmFieldTypeConverter {
+        // @formatter:off
+        @Override
+        public void emitTypeConversion(String varName, String accessor, String fieldName, String fieldType, JavaWriter writer)
+                throws IOException {
+            writer
+                .beginControlFlow("if (json.has(\"%s\"))", fieldName)
+                    .emitStatement("%1$s.%2$s().set((json.isNull(\"%3$s\")) ? null : json.getLong(\"%3$s\"))", varName, accessor, fieldName)
+                .endControlFlow();
+        }
+        // @formatter:on
+
+        // @formatter:off
+        @Override
+        public void emitStreamTypeConversion(String varName, String accessor, String fieldName, String fieldType, JavaWriter writer, boolean isPrimaryKey)
+                throws IOException {
+            writer
+                .emitStatement("Long val = null")
+                .beginControlFlow("if (reader.peek() != JsonToken.NULL)")
+                    .emitStatement("val = reader.nextLong()")
+                .nextControlFlow("else")
+                    .emitStatement("reader.skipValue()")
+                .endControlFlow()
+                .emitStatement("%1$s.%2$s().set(val)", varName, accessor);
+        }
+        // @formatter:on
+
+        @Override
+        public void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String qualifiedRealmObjectProxyClass, String fieldName, JavaWriter writer)
+                throws IOException {
+            throw new IllegalArgumentException("'MutableRealmInteger' is not allowed as a primary key value.");
         }
     }
-    //@formatter:on
 
     private interface JsonToRealmFieldTypeConverter {
-        void emitTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
-                JavaWriter writer) throws IOException;
+        void emitTypeConversion(String varName, String accessor, String fieldName, String fieldType, JavaWriter writer)
+                throws IOException;
 
-        void emitStreamTypeConversion(String interfaceName, String setter, String fieldName, String fieldType,
-                JavaWriter writer, boolean isPrimaryKey) throws IOException;
+        void emitStreamTypeConversion(String varName, String accessor, String fieldName, String fieldType, JavaWriter writer, boolean isPrimaryKey)
+                throws IOException;
 
-        void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String qualifiedRealmObjectProxyClass,
-                String fieldName, JavaWriter writer) throws IOException;
+        void emitGetObjectWithPrimaryKeyValue(String qualifiedRealmObjectClass, String qualifiedRealmObjectProxyClass, String fieldName, JavaWriter writer)
+                throws IOException;
     }
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
index b4b9663ba6..1d68cae873 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProcessor.java
@@ -25,6 +25,7 @@
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
+import javax.annotation.processing.SupportedOptions;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
@@ -123,7 +124,9 @@
         "io.realm.annotations.RealmModule",
         "io.realm.annotations.Required"
 })
+@SupportedOptions(value = {"realm.suppressWarnings", "realm.ignoreKotlinNullability"})
 public class RealmProcessor extends AbstractProcessor {
+
     // Don't consume annotations. This allows 3rd party annotation processors to run.
     private static final boolean CONSUME_ANNOTATIONS = false;
 
@@ -169,6 +172,8 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
 
     // Create all proxy classes
     private boolean processAnnotations(RoundEnvironment roundEnv) {
+        final TypeMirrors typeMirrors = new TypeMirrors(processingEnv);
+
         for (Element classElement : roundEnv.getElementsAnnotatedWith(RealmClass.class)) {
 
             // The class must either extend RealmObject or implement RealmModel
@@ -183,7 +188,7 @@ private boolean processAnnotations(RoundEnvironment roundEnv) {
                 return false;
             }
 
-            ClassMetaData metadata = new ClassMetaData(processingEnv, (TypeElement) classElement);
+            ClassMetaData metadata = new ClassMetaData(processingEnv, typeMirrors, (TypeElement) classElement);
             if (!metadata.isModelClass()) { continue; }
 
             Utils.note("Processing class " + metadata.getSimpleClassName());
@@ -199,7 +204,7 @@ private boolean processAnnotations(RoundEnvironment roundEnv) {
                 Utils.error(e.getMessage(), classElement);
             }
 
-            RealmProxyClassGenerator sourceCodeGenerator = new RealmProxyClassGenerator(processingEnv, metadata);
+            RealmProxyClassGenerator sourceCodeGenerator = new RealmProxyClassGenerator(processingEnv, typeMirrors, metadata);
             try {
                 sourceCodeGenerator.generate();
             } catch (IOException e) {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index 44772ce258..fcb035547e 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -25,34 +25,79 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.EnumSet;
-import java.util.Set;
+import java.util.List;
+import java.util.Locale;
 
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 import javax.tools.JavaFileObject;
 
 
 public class RealmProxyClassGenerator {
+    private static final String OPTION_SUPPRESS_WARNINGS = "realm.suppressWarnings";
     private static final String BACKLINKS_FIELD_EXTENSION = "Backlinks";
 
+    private static final List<String> IMPORTS;
+    static {
+        List<String> l = Arrays.asList(
+            "android.annotation.TargetApi",
+            "android.os.Build",
+            "android.util.JsonReader",
+            "android.util.JsonToken",
+            "io.realm.exceptions.RealmMigrationNeededException",
+            "io.realm.internal.ColumnInfo",
+            "io.realm.internal.OsList",
+            "io.realm.internal.OsObject",
+            "io.realm.internal.OsSchemaInfo",
+            "io.realm.internal.OsObjectSchemaInfo",
+            "io.realm.internal.Property",
+            "io.realm.internal.ProxyUtils",
+            "io.realm.internal.RealmObjectProxy",
+            "io.realm.internal.Row",
+            "io.realm.internal.SharedRealm",
+            "io.realm.internal.Table",
+            "io.realm.internal.android.JsonUtils",
+            "io.realm.log.RealmLog",
+            "java.io.IOException",
+            "java.util.ArrayList",
+            "java.util.Collections",
+            "java.util.List",
+            "java.util.Iterator",
+            "java.util.Date",
+            "java.util.Map",
+            "java.util.HashMap",
+            "org.json.JSONObject",
+            "org.json.JSONException",
+            "org.json.JSONArray");
+        IMPORTS = Collections.unmodifiableList(l);
+    }
+
     private final ProcessingEnvironment processingEnvironment;
+    private final TypeMirrors typeMirrors;
     private final ClassMetaData metadata;
     private final String simpleClassName;
     private final String qualifiedClassName;
     private final String interfaceName;
     private final String qualifiedGeneratedClassName;
+    private final boolean suppressWarnings;
 
-    public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment, ClassMetaData metadata) {
+    public RealmProxyClassGenerator(ProcessingEnvironment processingEnvironment, TypeMirrors typeMirrors, ClassMetaData metadata) {
         this.processingEnvironment = processingEnvironment;
+        this.typeMirrors = typeMirrors;
         this.metadata = metadata;
         this.simpleClassName = metadata.getSimpleClassName();
         this.qualifiedClassName = metadata.getFullyQualifiedClassName();
         this.interfaceName = Utils.getProxyInterfaceName(simpleClassName);
-        this.qualifiedGeneratedClassName = String.format("%s.%s",
+        this.qualifiedGeneratedClassName = String.format(Locale.US, "%s.%s",
                 Constants.REALM_PACKAGE_NAME, Utils.getProxyClassName(simpleClassName));
+
+        // See the configuration for the debug build type,
+        //  in the realm-library project, for an example of how to set this flag.
+        this.suppressWarnings = !"false".equalsIgnoreCase(processingEnvironment.getOptions().get(OPTION_SUPPRESS_WARNINGS));
     }
 
     public void generate() throws IOException, UnsupportedOperationException {
@@ -65,39 +110,19 @@ public void generate() throws IOException, UnsupportedOperationException {
         writer.emitPackage(Constants.REALM_PACKAGE_NAME)
                 .emitEmptyLine();
 
-        ArrayList<String> imports = new ArrayList<String>();
-        imports.add("android.annotation.TargetApi");
-        imports.add("android.os.Build");
-        imports.add("android.util.JsonReader");
-        imports.add("android.util.JsonToken");
-        imports.add("io.realm.RealmObjectSchema");
-        imports.add("io.realm.RealmSchema");
-        imports.add("io.realm.exceptions.RealmMigrationNeededException");
-        imports.add("io.realm.internal.ColumnInfo");
-        imports.add("io.realm.internal.RealmObjectProxy");
-        imports.add("io.realm.internal.Row");
-        imports.add("io.realm.internal.Table");
-        imports.add("io.realm.internal.SharedRealm");
-        imports.add("io.realm.internal.LinkView");
-        imports.add("io.realm.internal.android.JsonUtils");
-        imports.add("io.realm.log.RealmLog");
-        imports.add("java.io.IOException");
-        imports.add("java.util.ArrayList");
-        imports.add("java.util.Collections");
-        imports.add("java.util.List");
-        imports.add("java.util.Iterator");
-        imports.add("java.util.Date");
-        imports.add("java.util.Map");
-        imports.add("java.util.HashMap");
-        imports.add("org.json.JSONObject");
-        imports.add("org.json.JSONException");
-        imports.add("org.json.JSONArray");
-
+        List<String> imports = new ArrayList<String>(IMPORTS);
+        if (!metadata.getBacklinkFields().isEmpty()) {
+            imports.add("io.realm.internal.UncheckedRow");
+        }
         writer.emitImports(imports)
                 .emitEmptyLine();
 
         // Begin the class definition
-        writer.beginType(
+        if (suppressWarnings) {
+            writer.emitAnnotation("SuppressWarnings(\"all\")");
+        }
+        writer
+                .beginType(
                 qualifiedGeneratedClassName, // full qualified name of the item to generate
                 "class",                     // the type of the item
                 EnumSet.of(Modifier.PUBLIC), // modifiers to apply
@@ -106,17 +131,20 @@ public void generate() throws IOException, UnsupportedOperationException {
                 interfaceName)
                 .emitEmptyLine();
 
-        emitColumnIndicesClass(writer);
+        emitColumnInfoClass(writer);
 
         emitClassFields(writer);
+
+        emitInstanceFields(writer);
         emitConstructor(writer);
 
         emitInjectContextMethod(writer);
         emitPersistedFieldAccessors(writer);
         emitBacklinkFieldAccessors(writer);
-        emitCreateRealmObjectSchemaMethod(writer);
-        emitValidateTableMethod(writer);
-        emitGetTableNameMethod(writer);
+        emitCreateExpectedObjectSchemaInfo(writer);
+        emitGetExpectedObjectSchemaInfo(writer);
+        emitCreateColumnInfoMethod(writer);
+        emitGetSimpleClassNameMethod(writer);
         emitGetFieldNamesMethod(writer);
         emitCreateOrUpdateUsingJsonObject(writer);
         emitCreateUsingJsonStream(writer);
@@ -138,115 +166,140 @@ public void generate() throws IOException, UnsupportedOperationException {
         writer.close();
     }
 
-    private void emitColumnIndicesClass(JavaWriter writer) throws IOException {
+    private void emitColumnInfoClass(JavaWriter writer) throws IOException {
         writer.beginType(
                 columnInfoClassName(),                       // full qualified name of the item to generate
                 "class",                                     // the type of the item
                 EnumSet.of(Modifier.STATIC, Modifier.FINAL), // modifiers to apply
-                "ColumnInfo",                                // base class
-                "Cloneable")                                 // interfaces
-                .emitEmptyLine();
+                "ColumnInfo");                               // base class
 
         // fields
         for (VariableElement variableElement : metadata.getFields()) {
-            writer.emitField("long", columnIndexVarName(variableElement),
-                    EnumSet.of(Modifier.PUBLIC));
+            writer.emitField("long", columnIndexVarName(variableElement));
         }
         writer.emitEmptyLine();
 
-        // constructor
-        writer.beginConstructor(EnumSet.noneOf(Modifier.class),
-                "String", "path",
-                "Table", "table");
-        writer.emitStatement("final Map<String, Long> indicesMap = new HashMap<String, Long>(%s)",
-                metadata.getFields().size());
-        for (VariableElement variableElement : metadata.getFields()) {
-            final String columnName = variableElement.getSimpleName().toString();
-            final String columnIndexVarName = columnIndexVarName(variableElement);
-            writer.emitStatement("this.%s = getValidColumnIndex(path, table, \"%s\", \"%s\")",
-                    columnIndexVarName, simpleClassName, columnName)
-                    .emitStatement("indicesMap.put(\"%s\", this.%s)", columnName, columnIndexVarName);
+        // constructor #1
+        writer.beginConstructor(
+                EnumSet.noneOf(Modifier.class),
+                "OsSchemaInfo", "schemaInfo");
+        writer.emitStatement("super(%s)", metadata.getFields().size());
+        writer.emitStatement("OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo(\"%1$s\")",
+                simpleClassName);
+        for (VariableElement field : metadata.getFields()) {
+            writer.emitStatement(
+                    "this.%1$sIndex = addColumnDetails(\"%1$s\", objectSchemaInfo)",
+                    field.getSimpleName().toString());
         }
+        for (Backlink backlink : metadata.getBacklinkFields()) {
+            writer.emitStatement(
+                    "addBacklinkDetails(schemaInfo, \"%s\", \"%s\", \"%s\")",
+                    backlink.getTargetField(), Utils.stripPackage(backlink.getSourceClass()), backlink.getSourceField());
+        }
+        writer.endConstructor()
+                .emitEmptyLine();
 
-        writer.emitEmptyLine()
-                .emitStatement("setIndicesMap(indicesMap)");
+        // constructor #2
+        writer.beginConstructor(
+                EnumSet.noneOf(Modifier.class),
+                "ColumnInfo", "src", "boolean", "mutable");
+        writer.emitStatement("super(src, mutable)")
+                .emitStatement("copy(src, this)");
         writer.endConstructor()
                 .emitEmptyLine();
 
-        // copyColumnInfoFrom method
+        // no-args copy method
         writer.emitAnnotation("Override")
                 .beginMethod(
-                        "void",                      // return type
-                        "copyColumnInfoFrom",        // method name
-                        EnumSet.of(Modifier.PUBLIC, Modifier.FINAL), // modifiers
-                        "ColumnInfo", "other");      // parameters
-        {
-            writer.emitStatement("final %1$s otherInfo = (%1$s) other", columnInfoClassName());
-
-            // copy field values
-            for (VariableElement variableElement : metadata.getFields()) {
-                writer.emitStatement("this.%1$s = otherInfo.%1$s", columnIndexVarName(variableElement));
-            }
-            writer.emitEmptyLine()
-                    .emitStatement("setIndicesMap(otherInfo.getIndicesMap())");
-        }
+                        "ColumnInfo",                                   // return type
+                        "copy",                                         // method name
+                        EnumSet.of(Modifier.PROTECTED, Modifier.FINAL), // modifiers
+                        "boolean", "mutable");     // parameters
+        writer.emitStatement("return new %s(this, mutable)", columnInfoClassName());
         writer.endMethod()
                 .emitEmptyLine();
 
-        // clone method
-        //@formatter:off
+        // copy method
         writer.emitAnnotation("Override")
-            .beginMethod(
-                columnInfoClassName(),       // return type
-                "clone",                     // method name
-                EnumSet.of(Modifier.PUBLIC, Modifier.FINAL)) // modifiers
-                // method body
-                .emitStatement("return (%1$s) super.clone()", columnInfoClassName())
-                .endMethod()
-                .emitEmptyLine();
-        //@formatter:on
+                .beginMethod(
+                        "void",                                          // return type
+                        "copy",                                          // method name
+                        EnumSet.of(Modifier.PROTECTED, Modifier.FINAL),  // modifiers
+                        "ColumnInfo", "rawSrc", "ColumnInfo", "rawDst"); // parameters
+        writer.emitStatement("final %1$s src = (%1$s) rawSrc", columnInfoClassName());
+        writer.emitStatement("final %1$s dst = (%1$s) rawDst", columnInfoClassName());
+        for (VariableElement variableElement : metadata.getFields()) {
+            writer.emitStatement("dst.%1$s = src.%1$s", columnIndexVarName(variableElement));
+        }
+        writer.endMethod();
 
         writer.endType();
     }
 
+    //@formatter:off
     private void emitClassFields(JavaWriter writer) throws IOException {
-        writer.emitField(columnInfoClassName(), "columnInfo", EnumSet.of(Modifier.PRIVATE))
+        writer.emitEmptyLine()
+                .emitField("OsObjectSchemaInfo", "expectedObjectSchemaInfo",
+                EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL), "createExpectedObjectSchemaInfo()");
+
+        writer.emitField("List<String>", "FIELD_NAMES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL));
+        writer.beginInitializer(true)
+            .emitStatement("List<String> fieldNames = new ArrayList<String>(%s)", metadata.getFields().size());
+            for (VariableElement field : metadata.getFields()) {
+                writer.emitStatement("fieldNames.add(\"%s\")", field.getSimpleName().toString());
+            }
+        writer.emitStatement("FIELD_NAMES = Collections.unmodifiableList(fieldNames)")
+            .endInitializer();
+    }
+    //@formatter:on
+
+    //@formatter:off
+    private void emitInstanceFields(JavaWriter writer) throws IOException {
+        writer.emitEmptyLine()
+                .emitField(columnInfoClassName(), "columnInfo", EnumSet.of(Modifier.PRIVATE))
                 .emitField("ProxyState<" + qualifiedClassName + ">", "proxyState", EnumSet.of(Modifier.PRIVATE));
 
         for (VariableElement variableElement : metadata.getFields()) {
-            if (Utils.isRealmList(variableElement)) {
+            if (Utils.isMutableRealmInteger(variableElement)) {
+                emitMutableRealmIntegerField(writer, variableElement);
+            } else if (Utils.isRealmList(variableElement)) {
                 String genericType = Utils.getGenericTypeQualifiedName(variableElement);
                 writer.emitField("RealmList<" + genericType + ">", variableElement.getSimpleName().toString() + "RealmList", EnumSet.of(Modifier.PRIVATE));
             }
         }
 
         for (Backlink backlink : metadata.getBacklinkFields()) {
-            writer.emitField(
-                    backlink.getTargetFieldType(),
-                    backlink.getTargetField() + BACKLINKS_FIELD_EXTENSION,
+            writer.emitField(backlink.getTargetFieldType(), backlink.getTargetField() + BACKLINKS_FIELD_EXTENSION,
                     EnumSet.of(Modifier.PRIVATE));
         }
+    }
+    //@formatter:on
 
-        //@formatter:off
-        writer.emitField("List<String>", "FIELD_NAMES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL))
-            .beginInitializer(true)
-            .emitStatement("List<String> fieldNames = new ArrayList<String>()");
-        for (VariableElement field : metadata.getFields()) {
-            writer.emitStatement("fieldNames.add(\"%s\")", field.getSimpleName().toString());
-        }
-        writer.emitStatement("FIELD_NAMES = Collections.unmodifiableList(fieldNames)")
-            .endInitializer()
-            .emitEmptyLine();
-        //@formatter:on
+    // The anonymous subclass of MutableRealmInteger.Managed holds a reference to this proxy.
+    // Even if all other references to the proxy are dropped, the proxy will not be GCed until
+    // the MutableInteger that it owns, also becomes unreachable.
+    //@formatter:off
+    private void emitMutableRealmIntegerField(JavaWriter writer, VariableElement variableElement) throws IOException{
+        writer.emitField("MutableRealmInteger.Managed",
+                mutableRealmIntegerFieldName(variableElement),
+                EnumSet.of(Modifier.PRIVATE, Modifier.FINAL),
+                String.format(
+                        "new MutableRealmInteger.Managed<%1$s>() {\n"
+                                + "    @Override protected ProxyState<%1$s> getProxyState() { return proxyState; }\n"
+                                + "    @Override protected long getColumnIndex() { return columnInfo.%2$s; }\n"
+                                + "}",
+                        qualifiedClassName, columnIndexVarName(variableElement)));
     }
+    //@formatter:on
 
     //@formatter:off
     private void emitConstructor(JavaWriter writer) throws IOException {
         // FooRealmProxy(ColumnInfo)
-        writer.beginConstructor(EnumSet.noneOf(Modifier.class))
-            .emitStatement("proxyState.setConstructionFinished()")
-            .endConstructor()
-            .emitEmptyLine();
+        writer.emitEmptyLine()
+                .beginConstructor(EnumSet.noneOf(Modifier.class))
+                .emitStatement("proxyState.setConstructionFinished()")
+                .endConstructor()
+                .emitEmptyLine();
     }
     //@formatter:on
 
@@ -257,12 +310,15 @@ private void emitPersistedFieldAccessors(final JavaWriter writer) throws IOExcep
 
             if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
                 emitPrimitiveType(writer, field, fieldName, fieldTypeCanonicalName);
+            } else if (Utils.isMutableRealmInteger(field)) {
+                emitMutableRealmInteger(writer, field, fieldName, fieldTypeCanonicalName);
             } else if (Utils.isRealmModel(field)) {
                 emitRealmModel(writer, field, fieldName, fieldTypeCanonicalName);
             } else if (Utils.isRealmList(field)) {
-                emitRealmList(writer, field, fieldName, fieldTypeCanonicalName);
+                final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
+                emitRealmList(writer, field, fieldName, fieldTypeCanonicalName, elementTypeMirror);
             } else {
-                throw new UnsupportedOperationException(String.format(
+                throw new UnsupportedOperationException(String.format(Locale.US,
                         "Field \"%s\" of type \"%s\" is not supported.", fieldName, fieldTypeCanonicalName));
             }
 
@@ -278,20 +334,21 @@ private void emitPrimitiveType(
             final VariableElement field,
             final String fieldName,
             String fieldTypeCanonicalName) throws IOException {
-        final String realmType = Constants.JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
+
+        final String fieldJavaType = getRealmTypeChecked(field).getJavaType();
 
         // Getter
         //@formatter:off
         writer.emitAnnotation("Override");
         writer.emitAnnotation("SuppressWarnings", "\"cast\"")
-            .beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
-            .emitStatement("proxyState.getRealm$realm().checkIfValid()");
+                .beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
+                .emitStatement("proxyState.getRealm$realm().checkIfValid()");
 
         // For String and bytes[], null value will be returned by JNI code. Try to save one JNI call here.
         if (metadata.isNullable(field) && !Utils.isString(field) && !Utils.isByteArray(field)) {
             writer.beginControlFlow("if (proxyState.getRow$realm().isNull(%s))", fieldIndexVariableReference(field))
-                .emitStatement("return null")
-                .endControlFlow();
+                    .emitStatement("return null")
+                    .endControlFlow();
         }
         //@formatter:on
 
@@ -305,7 +362,7 @@ private void emitPrimitiveType(
         }
         writer.emitStatement(
                 "return (%s) proxyState.getRow$realm().get%s(%s)",
-                castingBackType, realmType, fieldIndexVariableReference(field));
+                castingBackType, fieldJavaType, fieldIndexVariableReference(field));
         writer.endMethod()
                 .emitEmptyLine();
 
@@ -321,20 +378,20 @@ public void emit(JavaWriter writer) throws IOException {
                 //@formatter:off
                 if (metadata.isNullable(field)) {
                     writer.beginControlFlow("if (value == null)")
-                        .emitStatement("row.getTable().setNull(%s, row.getIndex(), true)",
-                            fieldIndexVariableReference(field))
-                        .emitStatement("return")
-                        .endControlFlow();
+                            .emitStatement("row.getTable().setNull(%s, row.getIndex(), true)",
+                                    fieldIndexVariableReference(field))
+                            .emitStatement("return")
+                            .endControlFlow();
                 } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
                     writer.beginControlFlow("if (value == null)")
-                        .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
-                        .endControlFlow();
+                            .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
+                            .endControlFlow();
                 }
                 //@formatter:on
 
                 writer.emitStatement(
                         "row.getTable().set%s(%s, row.getIndex(), value, true)",
-                        realmType, fieldIndexVariableReference(field));
+                        fieldJavaType, fieldIndexVariableReference(field));
                 writer.emitStatement("return");
             }
         });
@@ -348,46 +405,55 @@ public void emit(JavaWriter writer) throws IOException {
             //@formatter:off
             if (metadata.isNullable(field)) {
                 writer.beginControlFlow("if (value == null)")
-                    .emitStatement("proxyState.getRow$realm().setNull(%s)", fieldIndexVariableReference(field))
-                    .emitStatement("return")
-                    .endControlFlow();
+                        .emitStatement("proxyState.getRow$realm().setNull(%s)", fieldIndexVariableReference(field))
+                        .emitStatement("return")
+                        .endControlFlow();
             } else if (!metadata.isNullable(field) && !Utils.isPrimitiveType(field)) {
                 // Same reason, throw IAE earlier.
                 writer
-                    .beginControlFlow("if (value == null)")
-                    .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
-                    .endControlFlow();
+                        .beginControlFlow("if (value == null)")
+                        .emitStatement(Constants.STATEMENT_EXCEPTION_ILLEGAL_NULL_VALUE, fieldName)
+                        .endControlFlow();
             }
             //@formatter:on
             writer.emitStatement(
                     "proxyState.getRow$realm().set%s(%s, value)",
-                    realmType, fieldIndexVariableReference(field));
+                    fieldJavaType, fieldIndexVariableReference(field));
         }
         writer.endMethod();
     }
 
+    //@formatter:off
+    private void emitMutableRealmInteger(JavaWriter writer, VariableElement field, String fieldName, String fieldTypeCanonicalName) throws IOException {
+        writer.emitAnnotation("Override")
+            .beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
+                .emitStatement("proxyState.getRealm$realm().checkIfValid()")
+                .emitStatement("return this.%s", mutableRealmIntegerFieldName(field))
+            .endMethod();
+    }
+    //@formatter:on
+
     /**
      * Links
      */
     //@formatter:off
     private void emitRealmModel(
-        JavaWriter writer,
-        final VariableElement field,
-        String fieldName,
-        String fieldTypeCanonicalName) throws IOException
-    {
+            JavaWriter writer,
+            final VariableElement field,
+            String fieldName,
+            String fieldTypeCanonicalName) throws IOException {
 
         // Getter
         writer.emitAnnotation("Override");
         writer.beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
-            .emitStatement("proxyState.getRealm$realm().checkIfValid()")
-            .beginControlFlow("if (proxyState.getRow$realm().isNullLink(%s))", fieldIndexVariableReference(field))
+                .emitStatement("proxyState.getRealm$realm().checkIfValid()")
+                .beginControlFlow("if (proxyState.getRow$realm().isNullLink(%s))", fieldIndexVariableReference(field))
                 .emitStatement("return null")
-            .endControlFlow()
-            .emitStatement("return proxyState.getRealm$realm().get(%s.class, proxyState.getRow$realm().getLink(%s), false, Collections.<String>emptyList())",
-                fieldTypeCanonicalName, fieldIndexVariableReference(field))
-            .endMethod()
-            .emitEmptyLine();
+                .endControlFlow()
+                .emitStatement("return proxyState.getRealm$realm().get(%s.class, proxyState.getRow$realm().getLink(%s), false, Collections.<String>emptyList())",
+                        fieldTypeCanonicalName, fieldIndexVariableReference(field))
+                .endMethod()
+                .emitEmptyLine();
 
         // Setter
         writer.emitAnnotation("Override");
@@ -397,74 +463,71 @@ private void emitRealmModel(
             public void emit(JavaWriter writer) throws IOException {
                 // check excludeFields
                 writer.beginControlFlow("if (proxyState.getExcludeFields$realm().contains(\"%1$s\"))",
-                    field.getSimpleName().toString())
-                    .emitStatement("return")
-                    .endControlFlow();
+                        field.getSimpleName().toString())
+                        .emitStatement("return")
+                        .endControlFlow();
                 writer.beginControlFlow("if (value != null && !RealmObject.isManaged(value))")
-                    .emitStatement("value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value)")
-                    .endControlFlow();
+                        .emitStatement("value = ((Realm) proxyState.getRealm$realm()).copyToRealm(value)")
+                        .endControlFlow();
 
                 // set value as default value
                 writer.emitStatement("final Row row = proxyState.getRow$realm()");
                 writer.beginControlFlow("if (value == null)")
-                    .emitSingleLineComment("Table#nullifyLink() does not support default value. Just using Row.")
-                    .emitStatement("row.nullifyLink(%s)", fieldIndexVariableReference(field))
-                    .emitStatement("return")
-                    .endControlFlow();
-                writer.beginControlFlow("if (!RealmObject.isValid(value))")
-                    .emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")")
-                    .endControlFlow();
-                writer.beginControlFlow("if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
-                    .emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")")
-                    .endControlFlow();
+                        .emitSingleLineComment("Table#nullifyLink() does not support default value. Just using Row.")
+                        .emitStatement("row.nullifyLink(%s)", fieldIndexVariableReference(field))
+                        .emitStatement("return")
+                        .endControlFlow();
+                writer.emitStatement("proxyState.checkValidObject(value)");
                 writer.emitStatement("row.getTable().setLink(%s, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true)",
-                    fieldIndexVariableReference(field));
+                        fieldIndexVariableReference(field));
                 writer.emitStatement("return");
             }
         });
         writer.emitStatement("proxyState.getRealm$realm().checkIfValid()")
-            .beginControlFlow("if (value == null)")
+                .beginControlFlow("if (value == null)")
                 .emitStatement("proxyState.getRow$realm().nullifyLink(%s)", fieldIndexVariableReference(field))
                 .emitStatement("return")
-            .endControlFlow()
-            .beginControlFlow("if (!(RealmObject.isManaged(value) && RealmObject.isValid(value)))")
-                .emitStatement("throw new IllegalArgumentException(\"'value' is not a valid managed object.\")")
-            .endControlFlow()
-            .beginControlFlow("if (((RealmObjectProxy)value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
-                .emitStatement("throw new IllegalArgumentException(\"'value' belongs to a different Realm.\")")
-            .endControlFlow()
-            .emitStatement("proxyState.getRow$realm().setLink(%s, ((RealmObjectProxy)value).realmGet$proxyState().getRow$realm().getIndex())", fieldIndexVariableReference(field))
-            .endMethod();
+                .endControlFlow()
+                .emitStatement("proxyState.checkValidObject(value)")
+                .emitStatement("proxyState.getRow$realm().setLink(%s, ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex())", fieldIndexVariableReference(field))
+                .endMethod();
     }
     //@formatter:on
 
     /**
-     * LinkLists
+     * ModelList, ValueList
      */
     //@formatter:off
     private void emitRealmList(
-        JavaWriter writer,
-        final VariableElement field,
-        String fieldName,
-        String fieldTypeCanonicalName) throws IOException
-    {
-        String genericType = Utils.getGenericTypeQualifiedName(field);
+            JavaWriter writer,
+            final VariableElement field,
+            String fieldName,
+            String fieldTypeCanonicalName,
+            final TypeMirror elementTypeMirror) throws IOException {
+        final String genericType = Utils.getGenericTypeQualifiedName(field);
+        final boolean forRealmModel = Utils.isRealmModel(elementTypeMirror);
 
         // Getter
         writer.emitAnnotation("Override");
         writer.beginMethod(fieldTypeCanonicalName, metadata.getInternalGetter(fieldName), EnumSet.of(Modifier.PUBLIC))
-            .emitStatement("proxyState.getRealm$realm().checkIfValid()")
-            .emitSingleLineComment("use the cached value if available")
-            .beginControlFlow("if (" + fieldName + "RealmList != null)")
+                .emitStatement("proxyState.getRealm$realm().checkIfValid()")
+                .emitSingleLineComment("use the cached value if available")
+                .beginControlFlow("if (" + fieldName + "RealmList != null)")
                 .emitStatement("return " + fieldName + "RealmList")
-            .nextControlFlow("else")
-                .emitStatement("LinkView linkView = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field))
-                .emitStatement(fieldName + "RealmList = new RealmList<%s>(%s.class, linkView, proxyState.getRealm$realm())",
-                    genericType, genericType)
+                .nextControlFlow("else");
+                if (Utils.isRealmModelList(field)) {
+                    writer.emitStatement("OsList osList = proxyState.getRow$realm().getModelList(%s)",
+                            fieldIndexVariableReference(field));
+                } else {
+                    writer.emitStatement("OsList osList = proxyState.getRow$realm().getValueList(%1$s, RealmFieldType.%2$s)",
+                            fieldIndexVariableReference(field), Utils.getValueListFieldType(field).name());
+                }
+                writer.emitStatement(fieldName + "RealmList = new RealmList<%s>(%s.class, osList, proxyState.getRealm$realm())",
+                        genericType, genericType)
                 .emitStatement("return " + fieldName + "RealmList")
-            .endControlFlow()
-            .endMethod()
-            .emitEmptyLine();
+                .endControlFlow()
+                .endMethod()
+                .emitEmptyLine();
 
         // Setter
         writer.emitAnnotation("Override");
@@ -477,42 +540,109 @@ public void emit(JavaWriter writer) throws IOException {
                         field.getSimpleName().toString())
                         .emitStatement("return")
                         .endControlFlow();
-                final String modelFqcn = Utils.getGenericTypeQualifiedName(field);
-                writer.beginControlFlow("if (value != null && !value.isManaged())")
+
+                if (!forRealmModel) {
+                    return;
+                }
+
+                writer.emitSingleLineComment("if the list contains unmanaged RealmObjects, convert them to managed.")
+                        .beginControlFlow("if (value != null && !value.isManaged())")
                         .emitStatement("final Realm realm = (Realm) proxyState.getRealm$realm()")
-                        .emitStatement("final RealmList<%1$s> original = value", modelFqcn)
-                        .emitStatement("value = new RealmList<%1$s>()", modelFqcn)
-                        .beginControlFlow("for (%1$s item : original)", modelFqcn)
-                            .beginControlFlow("if (item == null || RealmObject.isManaged(item))")
-                                .emitStatement("value.add(item)")
-                            .nextControlFlow("else")
-                                .emitStatement("value.add(realm.copyToRealm(item))")
-                            .endControlFlow()
+                        .emitStatement("final RealmList<%1$s> original = value", genericType)
+                        .emitStatement("value = new RealmList<%1$s>()", genericType)
+                        .beginControlFlow("for (%1$s item : original)", genericType)
+                        .beginControlFlow("if (item == null || RealmObject.isManaged(item))")
+                        .emitStatement("value.add(item)")
+                        .nextControlFlow("else")
+                        .emitStatement("value.add(realm.copyToRealm(item))")
                         .endControlFlow()
-                    .endControlFlow();
+                        .endControlFlow()
+                        .endControlFlow();
 
                 // LinkView currently does not support default value feature. Just fallback to normal code.
             }
         });
-        writer.emitStatement("proxyState.getRealm$realm().checkIfValid()")
-            .emitStatement("LinkView links = proxyState.getRow$realm().getLinkList(%s)", fieldIndexVariableReference(field))
-            .emitStatement("links.clear()")
-            .beginControlFlow("if (value == null)")
-                .emitStatement("return")
-            .endControlFlow()
-            .beginControlFlow("for (RealmModel linkedObject : (RealmList<? extends RealmModel>) value)")
-                .beginControlFlow("if (!(RealmObject.isManaged(linkedObject) && RealmObject.isValid(linkedObject)))")
-                    .emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must be a valid managed object.\")")
-                .endControlFlow()
-                .beginControlFlow("if (((RealmObjectProxy)linkedObject).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm())")
-                    .emitStatement("throw new IllegalArgumentException(\"Each element of 'value' must belong to the same Realm.\")")
+
+        writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
+        if (Utils.isRealmModelList(field)) {
+            writer.emitStatement("OsList osList = proxyState.getRow$realm().getModelList(%s)",
+                    fieldIndexVariableReference(field));
+        } else {
+            writer.emitStatement("OsList osList = proxyState.getRow$realm().getValueList(%1$s, RealmFieldType.%2$s)",
+                    fieldIndexVariableReference(field), Utils.getValueListFieldType(field).name());
+        }
+        if (forRealmModel) {
+            // Model lists.
+            writer
+                .emitSingleLineComment("For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.")
+                .beginControlFlow("if (value != null && value.size() == osList.size())")
+                    .emitStatement("int objects = value.size()")
+                    .beginControlFlow("for (int i = 0; i < objects; i++)")
+                        .emitStatement("%s linkedObject = value.get(i)", genericType)
+                        .emitStatement("proxyState.checkValidObject(linkedObject)")
+                        .emitStatement("osList.setRow(i, ((RealmObjectProxy) linkedObject).realmGet$proxyState().getRow$realm().getIndex())")
+                    .endControlFlow()
+                .nextControlFlow("else")
+                    .emitStatement("osList.removeAll()")
+                    .beginControlFlow("if (value == null)")
+                        .emitStatement("return")
+                    .endControlFlow()
+                    .emitStatement("int objects = value.size()")
+                    .beginControlFlow("for (int i = 0; i < objects; i++)")
+                        .emitStatement("%s linkedObject = value.get(i)", genericType)
+                        .emitStatement("proxyState.checkValidObject(linkedObject)")
+                        .emitStatement("osList.addRow(((RealmObjectProxy) linkedObject).realmGet$proxyState().getRow$realm().getIndex())")
+                    .endControlFlow()
+                .endControlFlow();
+        } else {
+            // Value lists
+            writer
+                .emitStatement("osList.removeAll()")
+                .beginControlFlow("if (value == null)")
+                    .emitStatement("return")
                 .endControlFlow()
-                .emitStatement("links.add(((RealmObjectProxy)linkedObject).realmGet$proxyState().getRow$realm().getIndex())")
-            .endControlFlow()
-            .endMethod();
+                .beginControlFlow("for (%1$s item : value)", genericType)
+                    .beginControlFlow("if (item == null)")
+                        .emitStatement(metadata.isElementNullable(field) ? "osList.addNull()" : "throw new IllegalArgumentException(\"Storing 'null' into " + fieldName + "' is not allowed by the schema.\")")
+                    .nextControlFlow("else")
+                        .emitStatement(getStatementForAppendingValueToOsList("osList", "item", elementTypeMirror))
+                    .endControlFlow()
+                .endControlFlow();
+        }
+        writer.endMethod();
+
     }
     //@formatter:on
 
+    private String getStatementForAppendingValueToOsList(
+            @SuppressWarnings("SameParameterValue") String osListVariableName,
+            @SuppressWarnings("SameParameterValue") String valueVariableName,
+            TypeMirror elementTypeMirror) {
+        if (elementTypeMirror == typeMirrors.STRING_MIRROR) {
+            return osListVariableName + ".addString(" + valueVariableName + ")";
+        }
+        if (elementTypeMirror == typeMirrors.LONG_MIRROR || elementTypeMirror == typeMirrors.INTEGER_MIRROR
+                || elementTypeMirror == typeMirrors.SHORT_MIRROR || elementTypeMirror == typeMirrors.BYTE_MIRROR) {
+            return osListVariableName + ".addLong(" + valueVariableName + ".longValue())";
+        }
+        if (elementTypeMirror.equals(typeMirrors.BINARY_MIRROR)) {
+            return osListVariableName + ".addBinary(" + valueVariableName + ")";
+        }
+        if (elementTypeMirror == typeMirrors.DATE_MIRROR) {
+            return osListVariableName + ".addDate(" + valueVariableName + ")";
+        }
+        if (elementTypeMirror == typeMirrors.BOOLEAN_MIRROR) {
+            return osListVariableName + ".addBoolean(" + valueVariableName + ")";
+        }
+        if (elementTypeMirror == typeMirrors.DOUBLE_MIRROR) {
+            return osListVariableName + ".addDouble(" + valueVariableName + ".doubleValue())";
+        }
+        if (elementTypeMirror == typeMirrors.FLOAT_MIRROR) {
+            return osListVariableName + ".addFloat(" + valueVariableName + ".floatValue())";
+        }
+        throw new RuntimeException("unexpected element type: " + elementTypeMirror.toString());
+    }
+
     private interface CodeEmitter {
         void emit(JavaWriter writer) throws IOException;
     }
@@ -533,6 +663,8 @@ private void emitCodeForUnderConstruction(JavaWriter writer, boolean isPrimaryKe
                 .emitEmptyLine();
     }
 
+    // Note that because of bytecode hackery, this method may run before the constructor!
+    // It may even run before fields have been initialized.
     //@formatter:off
     private void emitInjectContextMethod(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
@@ -540,21 +672,20 @@ private void emitInjectContextMethod(JavaWriter writer) throws IOException {
                 "void", // Return type
                 "realm$injectObjectContext", // Method name
                 EnumSet.of(Modifier.PUBLIC) // Modifiers
-                ); // Argument type & argument name
+        ); // Argument type & argument name
 
         writer.beginControlFlow("if (this.proxyState != null)")
                 .emitStatement("return")
-            .endControlFlow()
-            .emitStatement("final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get()")
-            .emitStatement("this.columnInfo = (%1$s) context.getColumnInfo()", columnInfoClassName())
-            .emitStatement("this.proxyState = new ProxyState<%1$s>(this)", qualifiedClassName)
-            .emitStatement("proxyState.setRealm$realm(context.getRealm())")
-            .emitStatement("proxyState.setRow$realm(context.getRow())")
-            .emitStatement("proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue())")
-            .emitStatement("proxyState.setExcludeFields$realm(context.getExcludeFields())");
-
-        writer.endMethod()
-            .emitEmptyLine();
+                .endControlFlow()
+                .emitStatement("final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get()")
+                .emitStatement("this.columnInfo = (%1$s) context.getColumnInfo()", columnInfoClassName())
+                .emitStatement("this.proxyState = new ProxyState<%1$s>(this)", qualifiedClassName)
+                .emitStatement("proxyState.setRealm$realm(context.getRealm())")
+                .emitStatement("proxyState.setRow$realm(context.getRow())")
+                .emitStatement("proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue())")
+                .emitStatement("proxyState.setExcludeFields$realm(context.getExcludeFields())")
+                .endMethod()
+                .emitEmptyLine();
     }
     //@formatter:on
 
@@ -567,16 +698,16 @@ private void emitBacklinkFieldAccessors(JavaWriter writer) throws IOException {
             // Getter, no setter
             writer.emitAnnotation("Override");
             writer.beginMethod(realmResultsType, metadata.getInternalGetter(backlink.getTargetField()), EnumSet.of(Modifier.PUBLIC))
-                .emitStatement("BaseRealm realm = proxyState.getRealm$realm()")
-                .emitStatement("realm.checkIfValid()")
-                .emitStatement("proxyState.getRow$realm().checkIfAttached()")
-                .beginControlFlow("if (" + cacheFieldName + " == null)")
+                    .emitStatement("BaseRealm realm = proxyState.getRealm$realm()")
+                    .emitStatement("realm.checkIfValid()")
+                    .emitStatement("proxyState.getRow$realm().checkIfAttached()")
+                    .beginControlFlow("if (" + cacheFieldName + " == null)")
                     .emitStatement(cacheFieldName + " = RealmResults.createBacklinkResults(realm, proxyState.getRow$realm(), %s.class, \"%s\")",
-                        backlink.getSourceClass(), backlink.getSourceField())
-                .endControlFlow()
-                .emitStatement("return " + cacheFieldName)
-                .endMethod()
-                .emitEmptyLine();
+                            backlink.getSourceClass(), backlink.getSourceField())
+                    .endControlFlow()
+                    .emitStatement("return " + cacheFieldName)
+                    .endMethod()
+                    .emitEmptyLine();
         }
     }
     //@formatter:on
@@ -584,338 +715,138 @@ private void emitBacklinkFieldAccessors(JavaWriter writer) throws IOException {
     //@formatter:off
     private void emitRealmObjectProxyImplementation(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override")
-            .beginMethod("ProxyState<?>", "realmGet$proxyState", EnumSet.of(Modifier.PUBLIC))
+                .beginMethod("ProxyState<?>", "realmGet$proxyState", EnumSet.of(Modifier.PUBLIC))
                 .emitStatement("return proxyState")
-            .endMethod()
-            .emitEmptyLine();
+                .endMethod()
+                .emitEmptyLine();
     }
     //@formatter:on
 
-    private void emitCreateRealmObjectSchemaMethod(JavaWriter writer) throws IOException {
+    private void emitCreateExpectedObjectSchemaInfo(JavaWriter writer) throws IOException {
         writer.beginMethod(
-                "RealmObjectSchema", // Return type
-                "createRealmObjectSchema", // Method name
-                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "RealmSchema", "realmSchema"); // Argument type & argument name
+                "OsObjectSchemaInfo", // Return type
+                "createExpectedObjectSchemaInfo", // Method name
+                EnumSet.of(Modifier.PRIVATE, Modifier.STATIC)); // Modifiers
 
-        writer.beginControlFlow("if (!realmSchema.contains(\"" + this.simpleClassName + "\"))");
-        writer.emitStatement("RealmObjectSchema realmObjectSchema = realmSchema.create(\"%s\")", this.simpleClassName);
+        // Guess capacity for Arrays used by OsObjectSchemaInfo.
+        // Used to prevent array resizing at runtime
+        int persistedFields = metadata.getFields().size();
+        int computedFields = metadata.getBacklinkFields().size();
+
+        writer.emitStatement(
+                "OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder(\"%s\", %s, %s)",
+                this.simpleClassName, persistedFields, computedFields);
 
         // For each field generate corresponding table index constant
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
-            String fieldTypeCanonicalName = field.asType().toString();
-            String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
 
-            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeCanonicalName)) {
-                String nullableFlag = (metadata.isNullable(field) ? "!" : "") + "Property.REQUIRED";
-                String indexedFlag = (metadata.isIndexed(field) ? "" : "!") + "Property.INDEXED";
-                String primaryKeyFlag = (metadata.isPrimaryKey(field) ? "" : "!") + "Property.PRIMARY_KEY";
-                writer.emitStatement("realmObjectSchema.add(\"%s\", %s, %s, %s, %s)",
-                        fieldName,
-                        Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeCanonicalName),
-                        primaryKeyFlag,
-                        indexedFlag,
-                        nullableFlag);
-            } else if (Utils.isRealmModel(field)) {
-                writer.beginControlFlow("if (!realmSchema.contains(\"" + fieldTypeSimpleName + "\"))")
-                        .emitStatement("%s%s.createRealmObjectSchema(realmSchema)", fieldTypeSimpleName, Constants.PROXY_SUFFIX)
-                        .endControlFlow()
-                        .emitStatement("realmObjectSchema.add(\"%s\", RealmFieldType.OBJECT, realmSchema.get(\"%s\"))",
-                                fieldName, fieldTypeSimpleName);
-            } else if (Utils.isRealmList(field)) {
-                String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
-                writer.beginControlFlow("if (!realmSchema.contains(\"" + genericTypeSimpleName + "\"))")
-                        .emitStatement("%s%s.createRealmObjectSchema(realmSchema)", genericTypeSimpleName, Constants.PROXY_SUFFIX)
-                        .endControlFlow()
-                        .emitStatement("realmObjectSchema.add(\"%s\", RealmFieldType.LIST, realmSchema.get(\"%s\"))",
-                                fieldName, genericTypeSimpleName);
+            Constants.RealmFieldType fieldType = getRealmTypeChecked(field);
+            switch (fieldType) {
+                case NOTYPE:
+                    // Perhaps this should fail quickly?
+                    break;
+
+                case OBJECT:
+                    String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
+                    writer.emitStatement("builder.addPersistedLinkProperty(\"%s\", RealmFieldType.OBJECT, \"%s\")",
+                            fieldName, fieldTypeSimpleName);
+                    break;
+
+                case LIST:
+                    // only for model list.
+                    String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
+                    writer.emitStatement("builder.addPersistedLinkProperty(\"%s\", RealmFieldType.LIST, \"%s\")",
+                            fieldName, genericTypeSimpleName);
+                    break;
+
+                case INTEGER_LIST:
+                case BOOLEAN_LIST:
+                case STRING_LIST:
+                case BINARY_LIST:
+                case DATE_LIST:
+                case FLOAT_LIST:
+                case DOUBLE_LIST:
+                    writer.emitStatement("builder.addPersistedValueListProperty(\"%s\", %s, %s)",
+                            fieldName, fieldType.getRealmType(), metadata.isElementNullable(field) ? "!Property.REQUIRED" : "Property.REQUIRED");
+                    break;
+
+                case BACKLINK:
+                    throw new IllegalArgumentException("LinkingObject field should not be added to metadata");
+
+                case INTEGER:
+                case FLOAT:
+                case DOUBLE:
+                case BOOLEAN:
+                case STRING:
+                case DATE:
+                case BINARY:
+                case REALM_INTEGER:
+                    String nullableFlag = (metadata.isNullable(field) ? "!" : "") + "Property.REQUIRED";
+                    String indexedFlag = (metadata.isIndexed(field) ? "" : "!") + "Property.INDEXED";
+                    String primaryKeyFlag = (metadata.isPrimaryKey(field) ? "" : "!") + "Property.PRIMARY_KEY";
+                    writer.emitStatement("builder.addPersistedProperty(\"%s\", %s, %s, %s, %s)",
+                            fieldName,
+                            fieldType.getRealmType(),
+                            primaryKeyFlag,
+                            indexedFlag,
+                            nullableFlag);
+                    break;
+
+                default:
+                    throw new IllegalArgumentException("'fieldType' " + fieldName + " is not handled");
             }
         }
-        writer.emitStatement("return realmObjectSchema");
-        writer.endControlFlow();
-        writer.emitStatement("return realmSchema.get(\"" + this.simpleClassName + "\")");
+        for (Backlink backlink: metadata.getBacklinkFields()) {
+            writer.emitStatement("builder.addComputedLinkProperty(\"%s\", \"%s\", \"%s\")",
+                    backlink.getTargetField(), backlink.getSimpleSourceClass(), backlink.getSourceField());
+        }
+        writer.emitStatement("return builder.build()");
         writer.endMethod()
                 .emitEmptyLine();
     }
 
-    private void emitValidateTableMethod(JavaWriter writer) throws IOException {
+    private void emitGetExpectedObjectSchemaInfo(JavaWriter writer) throws IOException {
         writer.beginMethod(
-                columnInfoClassName(),        // Return type
-                "validateTable",              // Method name
-                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
-                "SharedRealm", "sharedRealm", // Argument type & argument name
-                "boolean", "allowExtraColumns");
+                "OsObjectSchemaInfo", // Return type
+                "getExpectedObjectSchemaInfo", // Method name
+                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC)); // Modifiers
 
-        writer.beginControlFlow(
-                "if (!sharedRealm.hasTable(\"" + Constants.TABLE_PREFIX + this.simpleClassName + "\"))");
-        emitMigrationNeededException(writer, "\"The '%s' class is missing from the schema for this Realm.\")",
-                metadata.getSimpleClassName());
-        writer.endControlFlow();
+        writer.emitStatement("return expectedObjectSchemaInfo");
 
-        writer.emitStatement(
-                "Table table = sharedRealm.getTable(\"%s%s\")",
-                Constants.TABLE_PREFIX,
-                this.simpleClassName);
-
-        // verify number of columns
-        writer.emitStatement("final long columnCount = table.getColumnCount()");
-        writer.beginControlFlow("if (columnCount != %d)", metadata.getFields().size());
-        writer.beginControlFlow("if (columnCount < %d)", metadata.getFields().size());
-        emitMigrationNeededException(writer, "\"Field count is less than expected - expected %d but was \" + columnCount)",
-                metadata.getFields().size());
-        writer.endControlFlow();
-        writer.beginControlFlow("if (allowExtraColumns)");
-        writer.emitStatement(
-                "RealmLog.debug(\"Field count is more than expected - expected %d but was %%1$d\", columnCount)",
-                metadata.getFields().size());
-        writer.nextControlFlow("else");
-        emitMigrationNeededException(writer, "\"Field count is more than expected - expected %d but was \" + columnCount)",
-                metadata.getFields().size());
-        writer.endControlFlow();
-        writer.endControlFlow();
-
-        // create type dictionary for lookup
-        writer.emitStatement("Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>()");
-        writer.beginControlFlow("for (long i = 0; i < columnCount; i++)")
-                .emitStatement("columnTypes.put(table.getColumnName(i), table.getColumnType(i))")
-                .endControlFlow()
-                .emitEmptyLine();
-
-        // create an instance of ColumnInfo
-        writer.emitStatement("final %1$s columnInfo = new %1$s(sharedRealm.getPath(), table)", columnInfoClassName())
+        writer.endMethod()
                 .emitEmptyLine();
+    }
 
-        // verify primary key definition was not altered
-        if (metadata.hasPrimaryKey()) {
-            // the current model defines a PK, make sure it's defined in the Realm schema
-            String fieldName = metadata.getPrimaryKey().getSimpleName().toString();
-            writer.beginControlFlow("if (!table.hasPrimaryKey())");
-            emitMigrationNeededException(writer, "\"Primary key not defined for field '%s' in existing Realm file. @PrimaryKey was added.\")",
-                    metadata.getPrimaryKey().getSimpleName().toString());
-            writer.nextControlFlow("else")
-                    .beginControlFlow("if (table.getPrimaryKey() != columnInfo.%sIndex)", fieldName);
-            emitMigrationNeededException(writer, "\"Primary Key annotation definition was changed, from field \" + table.getColumnName(table.getPrimaryKey()) + \" to field %s\")",
-                    metadata.getPrimaryKey().getSimpleName().toString());
-            writer.endControlFlow()
-                    .endControlFlow();
-        } else {
-            // the current model doesn't define a PK, make sure it's not defined in the Realm schema
-            writer.beginControlFlow("if (table.hasPrimaryKey())");
-            emitMigrationNeededException(writer, "\"Primary Key defined for field \" + table.getColumnName(table.getPrimaryKey()) + \" was removed.\")");
-            writer.endControlFlow();
-        }
-        writer.emitEmptyLine();
-
-        // For each field verify there is a corresponding
-        long fieldIndex = -1;
-        for (VariableElement field : metadata.getFields()) {
-            fieldIndex++;
-            String fieldName = field.getSimpleName().toString();
-            String fieldTypeQualifiedName = Utils.getFieldTypeQualifiedName(field);
-            if (Constants.JAVA_TO_REALM_TYPES.containsKey(fieldTypeQualifiedName)) {
-                emitValidateRealmType(writer, field, fieldName, fieldTypeQualifiedName);
-            } else if (Utils.isRealmModel(field)) { // Links
-                emitValidateRealmModelType(writer, field, fieldIndex, fieldName);
-            } else if (Utils.isRealmList(field)) { // Link Lists
-                emitValidateRealmListType(writer, field, fieldIndex, fieldName);
-            }
-        }
-
-        // verify the backlinks
-        Set<Backlink> backlinks = metadata.getBacklinkFields();
-        if (backlinks.size() > 0) {
-            writer.emitEmptyLine()
-                    .emitStatement("long backlinkFieldIndex")
-                    .emitStatement("Table backlinkSourceTable")
-                    .emitStatement("Table backlinkTargetTable")
-                    .emitStatement("RealmFieldType backlinkFieldType");
-            for (Backlink backlink : metadata.getBacklinkFields()) {
-                emitValidateBacklink(writer, backlink);
-            }
-        }
+    private void emitCreateColumnInfoMethod(JavaWriter writer) throws IOException {
+        writer.beginMethod(
+                columnInfoClassName(),        // Return type
+                "createColumnInfo",              // Method name
+                EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
+                "OsSchemaInfo", "schemaInfo"); // Argument type & argument name
 
-        writer.emitEmptyLine();
-        writer.emitStatement("return %s", "columnInfo");
+        // create an instance of ColumnInfo
+        writer.emitStatement("return new %1$s(schemaInfo)", columnInfoClassName());
 
         writer.endMethod();
         writer.emitEmptyLine();
     }
 
-    private void emitValidateRealmType(JavaWriter writer, VariableElement field, String fieldName, String fieldTypeQualifiedName)
-            throws IOException {
-
-        // make sure types align
-        writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
-        emitMigrationNeededException(writer, "\"Missing field '%s' in existing Realm file. " +
-                "Either remove field or migrate using io.realm.internal.Table.addColumn()." +
-                "\")", fieldName);
-        writer.endControlFlow();
-        writer.beginControlFlow("if (columnTypes.get(\"%s\") != %s)",
-                fieldName, Constants.JAVA_TO_COLUMN_TYPES.get(fieldTypeQualifiedName));
-        emitMigrationNeededException(writer, "\"Invalid type '%s' for field '%s' in existing Realm file.\")",
-                Utils.getFieldTypeSimpleName(field), fieldName);
-        writer.endControlFlow();
-
-        // make sure that nullability matches
-        if (metadata.isNullable(field)) {
-            writer.beginControlFlow("if (!table.isColumnNullable(%s))", fieldIndexVariableReference(field));
-            // Check if the existing PrimaryKey does support null value for String, Byte, Short, Integer, & Long
-            if (metadata.isPrimaryKey(field)) {
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
-                                "\"@PrimaryKey field '%s' does not support null values in the existing Realm file. " +
-                                "Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.\")",
-                        fieldName);
-                // nullability check for boxed types
-            } else if (Utils.isBoxedType(fieldTypeQualifiedName)) {
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
-                                "\"Field '%s' does not support null values in the existing Realm file. " +
-                                "Either set @Required, use the primitive type for field '%s' " +
-                                "or migrate using RealmObjectSchema.setNullable().\")",
-                        fieldName, fieldName);
-            } else {
-                writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
-                                " \"Field '%s' is required. Either set @Required to field '%s' " +
-                                "or migrate using RealmObjectSchema.setNullable().\")",
-                        fieldName, fieldName);
-            }
-            writer.endControlFlow();
-        } else {
-            // check before migrating a nullable field containing null value to not-nullable PrimaryKey field for Realm version 0.89+
-            if (metadata.isPrimaryKey(field)) {
-                writer
-                        .beginControlFlow("if (table.isColumnNullable(%s) && table.findFirstNull(%s) != Table.NO_MATCH)",
-                                fieldIndexVariableReference(field), fieldIndexVariableReference(field))
-                        .emitStatement("throw new IllegalStateException(\"Cannot migrate an object with null value in field '%s'." +
-                                        " Either maintain the same type for primary key field '%s', or remove the object with null value before migration.\")",
-                                fieldName, fieldName)
-                        .endControlFlow();
-            } else {
-                writer.beginControlFlow("if (table.isColumnNullable(%s))", fieldIndexVariableReference(field));
-                if (Utils.isPrimitiveType(fieldTypeQualifiedName)) {
-                    writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
-                                    " \"Field '%s' does support null values in the existing Realm file. " +
-                                    "Use corresponding boxed type for field '%s' or migrate using RealmObjectSchema.setNullable().\")",
-                            fieldName, fieldName);
-                } else {
-                    writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath()," +
-                                    " \"Field '%s' does support null values in the existing Realm file. " +
-                                    "Remove @Required or @PrimaryKey from field '%s' or migrate using RealmObjectSchema.setNullable().\")",
-                            fieldName, fieldName);
-                }
-                writer.endControlFlow();
-            }
-        }
-
-        // Validate @Index
-        if (metadata.getIndexedFields().contains(field)) {
-            writer.beginControlFlow("if (!table.hasSearchIndex(table.getColumnIndex(\"%s\")))", fieldName);
-            emitMigrationNeededException(writer, "\"Index not defined for field '%s' in existing Realm file. " +
-                    "Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().\")", fieldName);
-            writer.endControlFlow();
-        }
-    }
-
-    private void emitValidateRealmModelType(JavaWriter writer, VariableElement field, long fieldIndex, String fieldName)
-            throws IOException {
-        String fieldTypeSimpleName = Utils.getFieldTypeSimpleName(field);
-
-        writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
-        emitMigrationNeededException(writer, "\"Missing field '%s' in existing Realm file. " +
-                "Either remove field or migrate using io.realm.internal.Table.addColumn().\")", fieldName);
-        writer.endControlFlow();
-        writer.beginControlFlow("if (columnTypes.get(\"%s\") != RealmFieldType.OBJECT)", fieldName);
-        emitMigrationNeededException(writer, "\"Invalid type '%s' for field '%s'\")",
-                fieldTypeSimpleName, fieldName);
-        writer.endControlFlow();
-        writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, fieldTypeSimpleName);
-        emitMigrationNeededException(writer, "\"Missing class '%s%s' for field '%s'\")",
-                Constants.TABLE_PREFIX, fieldTypeSimpleName, fieldName);
-        writer.endControlFlow();
-
-        writer.emitStatement("Table table_%d = sharedRealm.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, fieldTypeSimpleName);
-        writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
-                fieldIndexVariableReference(field), fieldIndex);
-        emitMigrationNeededException(writer, "\"Invalid RealmObject for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
-                fieldName, fieldIndexVariableReference(field), fieldIndex);
-        writer.endControlFlow();
-    }
-
-    private void emitValidateRealmListType(JavaWriter writer, VariableElement field, long fieldIndex, String fieldName)
-            throws IOException {
-        String genericTypeSimpleName = Utils.getGenericTypeSimpleName(field);
-        writer.beginControlFlow("if (!columnTypes.containsKey(\"%s\"))", fieldName);
-        emitMigrationNeededException(writer, "\"Missing field '%s'\")", fieldName);
-        writer.endControlFlow();
-        writer.beginControlFlow("if (columnTypes.get(\"%s\") != RealmFieldType.LIST)", fieldName);
-        emitMigrationNeededException(writer, "\"Invalid type '%s' for field '%s'\")",
-                genericTypeSimpleName, fieldName);
-        writer.endControlFlow();
-        writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, genericTypeSimpleName);
-        emitMigrationNeededException(writer, "\"Missing class '%s%s' for field '%s'\")",
-                Constants.TABLE_PREFIX, genericTypeSimpleName, fieldName);
-        writer.endControlFlow();
-
-        writer.emitStatement("Table table_%d = sharedRealm.getTable(\"%s%s\")", fieldIndex, Constants.TABLE_PREFIX, genericTypeSimpleName);
-        writer.beginControlFlow("if (!table.getLinkTarget(%s).hasSameSchema(table_%d))",
-                fieldIndexVariableReference(field), fieldIndex);
-        emitMigrationNeededException(writer, "\"Invalid RealmList type for field '%s': '\" + table.getLinkTarget(%s).getName() + \"' expected - was '\" + table_%d.getName() + \"'\")",
-                fieldName, fieldIndexVariableReference(field), fieldIndex);
-        writer.endControlFlow();
-    }
-
-    private void emitValidateBacklink(JavaWriter writer, Backlink backlink) throws IOException {
-        String targetField = backlink.getTargetField();
-        String targetClass = backlink.getTargetClass();
-
-        // Preceding code has already verified that the backlink field is not in the table.
-        // If it were, either the column count would be wrong, or some field would be missing.
-
-        // verify that the source class exists
-        String sourceClass = backlink.getSimpleSourceClass();
-        String fullyQualifiedSourceClass = backlink.getSourceClass();
-        writer.beginControlFlow("if (!sharedRealm.hasTable(\"%s%s\"))", Constants.TABLE_PREFIX, sourceClass);
-        emitMigrationNeededException(writer, "\"Cannot find source class '%s' for @LinkingObjects field '%s.%s'\")",
-                fullyQualifiedSourceClass, targetClass, targetField);
-        writer.endControlFlow();
-
-        // verify that the source class contains the source field
-        String sourceField = backlink.getSourceField();
-        writer.emitStatement("backlinkSourceTable = sharedRealm.getTable(\"%s%s\")", Constants.TABLE_PREFIX, sourceClass);
-        writer.emitStatement("backlinkFieldIndex = backlinkSourceTable.getColumnIndex(\"%s\")", sourceField);
-        writer.beginControlFlow("if (backlinkFieldIndex == Table.NO_MATCH)");
-        emitMigrationNeededException(writer, "\"Cannot find source field '%s.%s' for @LinkingObjects field '%s.%s'\")",
-                fullyQualifiedSourceClass, sourceField, targetClass, targetField);
-        writer.endControlFlow();
-
-        // verify that the source field type is target class
-        writer.emitStatement("backlinkFieldType = backlinkSourceTable.getColumnType(backlinkFieldIndex)");
-        writer.beginControlFlow("if ((backlinkFieldType != RealmFieldType.OBJECT) && (backlinkFieldType != RealmFieldType.LIST))");
-        emitMigrationNeededException(writer, "\"Source field '%s.%s' for @LinkingObjects field '%s.%s' is not a RealmObject type\")",
-                fullyQualifiedSourceClass, sourceField, targetClass, targetField);
-        writer.endControlFlow();
-        writer.emitStatement("backlinkTargetTable = backlinkSourceTable.getLinkTarget(backlinkFieldIndex)");
-        writer.beginControlFlow("if (!table.hasSameSchema(backlinkTargetTable))");
-        emitMigrationNeededException(writer, "\"Source field '%s.%s' for @LinkingObjects field '%s.%s' has wrong type '\" + backlinkTargetTable.getName() + \"'\")",
-                fullyQualifiedSourceClass, sourceField, targetClass, targetField);
-        writer.endControlFlow();
-    }
-
     //@formatter:off
-    private void emitGetTableNameMethod(JavaWriter writer) throws IOException {
-        writer.beginMethod("String", "getTableName", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC))
-            .emitStatement("return \"%s%s\"", Constants.TABLE_PREFIX, simpleClassName)
-            .endMethod()
-            .emitEmptyLine();
+    private void emitGetSimpleClassNameMethod(JavaWriter writer) throws IOException {
+        writer.beginMethod("String", "getSimpleClassName", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC))
+                .emitStatement("return \"%s\"", simpleClassName)
+                .endMethod()
+                .emitEmptyLine();
     }
     //@formatter:on
 
     //@formatter:off
     private void emitGetFieldNamesMethod(JavaWriter writer) throws IOException {
         writer.beginMethod("List<String>", "getFieldNames", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC))
-            .emitStatement("return FIELD_NAMES")
-            .endMethod()
-            .emitEmptyLine();
+                .emitStatement("return FIELD_NAMES")
+                .endMethod()
+                .emitEmptyLine();
     }
     //@formatter:on
 
@@ -929,39 +860,44 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
         );
 
         writer
-            .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId)")
-                .emitStatement("throw new IllegalArgumentException(\"Objects which belong to Realm instances in other" +
-                        " threads cannot be copied into this Realm instance.\")")
-            .endControlFlow();
+                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null)")
+                    .emitStatement("final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm()")
+                    .beginControlFlow("if (otherRealm.threadId != realm.threadId)")
+                        .emitStatement("throw new IllegalArgumentException(\"Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.\")")
+                    .endControlFlow()
+
+                    // If object is already in the Realm there is nothing to update
+                    .beginControlFlow("if (otherRealm.getPath().equals(realm.getPath()))")
+                        .emitStatement("return object")
+                    .endControlFlow()
+                .endControlFlow();
 
-        // If object is already in the Realm there is nothing to update
-        writer
-            .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))")
-                .emitStatement("return object")
-            .endControlFlow();
 
         writer.emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()");
 
-        writer.emitStatement("RealmObjectProxy cachedRealmObject = cache.get(object)");
-        writer.beginControlFlow("if (cachedRealmObject != null)")
-                .emitStatement("return (%s) cachedRealmObject", qualifiedClassName)
-                .nextControlFlow("else");
+        writer.emitStatement("RealmObjectProxy cachedRealmObject = cache.get(object)")
+                .beginControlFlow("if (cachedRealmObject != null)")
+                    .emitStatement("return (%s) cachedRealmObject", qualifiedClassName)
+                .endControlFlow()
+                .emitEmptyLine();
 
-            if (!metadata.hasPrimaryKey()) {
-                writer.emitStatement("return copy(realm, object, update, cache)");
-            } else {
-                writer
+        if (!metadata.hasPrimaryKey()) {
+            writer.emitStatement("return copy(realm, object, update, cache)");
+        } else {
+            writer
                     .emitStatement("%s realmObject = null", qualifiedClassName)
                     .emitStatement("boolean canUpdate = update")
                     .beginControlFlow("if (canUpdate)")
-                        .emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName)
-                        .emitStatement("long pkColumnIndex = table.getPrimaryKey()");
+                    .emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName)
+                    .emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
+                        columnInfoClassName(), columnInfoClassName(), qualifiedClassName)
+                    .emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.getPrimaryKey()));
 
-                String primaryKeyGetter = metadata.getPrimaryKeyGetter();
-                VariableElement primaryKeyElement = metadata.getPrimaryKey();
-                if (metadata.isNullable(primaryKeyElement)) {
-                    if (Utils.isString(primaryKeyElement)) {
-                        writer
+            String primaryKeyGetter = metadata.getPrimaryKeyGetter();
+            VariableElement primaryKeyElement = metadata.getPrimaryKey();
+            if (metadata.isNullable(primaryKeyElement)) {
+                if (Utils.isString(primaryKeyElement)) {
+                    writer
                             .emitStatement("String value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
                             .emitStatement("long rowIndex = Table.NO_MATCH")
                             .beginControlFlow("if (value == null)")
@@ -969,8 +905,8 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                             .nextControlFlow("else")
                                 .emitStatement("rowIndex = table.findFirstString(pkColumnIndex, value)")
                             .endControlFlow();
-                    } else {
-                        writer
+                } else {
+                    writer
                             .emitStatement("Number value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
                             .emitStatement("long rowIndex = Table.NO_MATCH")
                             .beginControlFlow("if (value == null)")
@@ -978,43 +914,37 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                             .nextControlFlow("else")
                                 .emitStatement("rowIndex = table.findFirstLong(pkColumnIndex, value.longValue())")
                             .endControlFlow();
-                    }
-                } else {
-                    String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
-                    writer.emitStatement("long rowIndex = table.findFirst%s(pkColumnIndex, ((%s) object).%s())",
-                            pkType, interfaceName, primaryKeyGetter);
                 }
+            } else {
+                String pkType = Utils.isString(metadata.getPrimaryKey()) ? "String" : "Long";
+                writer.emitStatement("long rowIndex = table.findFirst%s(pkColumnIndex, ((%s) object).%s())",
+                        pkType, interfaceName, primaryKeyGetter);
+            }
 
-                writer
-                    .beginControlFlow("if (rowIndex != Table.NO_MATCH)")
+            writer
+                    .beginControlFlow("if (rowIndex == Table.NO_MATCH)")
+                        .emitStatement("canUpdate = false")
+                    .nextControlFlow("else")
                         .beginControlFlow("try")
-                            .emitStatement("objectContext.set(realm, table.getUncheckedRow(rowIndex)," +
-                                    " realm.schema.getColumnInfo(%s.class)," +
-                                    " false, Collections.<String> emptyList())", qualifiedClassName)
+                            .emitStatement(
+                                "objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())",
+                                qualifiedClassName)
                             .emitStatement("realmObject = new %s()", qualifiedGeneratedClassName)
                             .emitStatement("cache.put(object, (RealmObjectProxy) realmObject)")
                         .nextControlFlow("finally")
                             .emitStatement("objectContext.clear()")
                         .endControlFlow()
-
-                    .nextControlFlow("else")
-                        .emitStatement("canUpdate = false")
                     .endControlFlow();
 
-                writer.endControlFlow();
+            writer.endControlFlow();
 
-                writer
+            writer
                     .emitEmptyLine()
-                    .beginControlFlow("if (canUpdate)")
-                        .emitStatement("return update(realm, realmObject, object, cache)")
-                    .nextControlFlow("else")
-                        .emitStatement("return copy(realm, object, update, cache)")
-                    .endControlFlow();
-            }
+                       .emitStatement("return (canUpdate) ? update(realm, realmObject, object, cache) : copy(realm, object, update, cache)");
+        }
 
-        writer.endControlFlow();
         writer.endMethod()
-            .emitEmptyLine();
+                .emitEmptyLine();
     }
     //@formatter:on
 
@@ -1024,97 +954,108 @@ private void setTableValues(JavaWriter writer, String fieldType, String fieldNam
                 || "int".equals(fieldType)
                 || "short".equals(fieldType)
                 || "byte".equals(fieldType)) {
-            writer.emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s(), false)", fieldName, interfaceName, getter);
+            writer.emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter);
 
         } else if ("java.lang.Long".equals(fieldType)
                 || "java.lang.Integer".equals(fieldType)
                 || "java.lang.Short".equals(fieldType)
                 || "java.lang.Byte".equals(fieldType)) {
             writer
-                    .emitStatement("Number %s = ((%s)object).%s()", getter, interfaceName, getter)
+                    .emitStatement("Number %s = ((%s) object).%s()", getter, interfaceName, getter)
+                    .beginControlFlow("if (%s != null)", getter)
+                    .emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue(), false)", fieldName, getter);
+            if (isUpdate) {
+                writer.nextControlFlow("else")
+                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
+            }
+            writer.endControlFlow();
+
+        } else if ("io.realm.MutableRealmInteger".equals(fieldType)) {
+            writer
+                    .emitStatement("Long %s = ((%s) object).%s().get()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue(), false)", fieldName, getter);
-                    if (isUpdate) {
-                        writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-                    }
-                    writer.endControlFlow();
+                    .emitStatement("Table.nativeSetLong(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.longValue(), false)", fieldName, getter);
+            if (isUpdate) {
+                writer.nextControlFlow("else")
+                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
+            }
+            writer.endControlFlow();
 
         } else if ("double".equals(fieldType)) {
-            writer.emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s(), false)", fieldName, interfaceName, getter);
+            writer.emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter);
 
-        } else if("java.lang.Double".equals(fieldType)) {
+        } else if ("java.lang.Double".equals(fieldType)) {
             writer
-                    .emitStatement("Double %s = ((%s)object).%s()", getter, interfaceName, getter)
+                    .emitStatement("Double %s = ((%s) object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
-                    if (isUpdate) {
-                        writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-                    }
-                    writer.endControlFlow();
+                    .emitStatement("Table.nativeSetDouble(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
+            if (isUpdate) {
+                writer.nextControlFlow("else")
+                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
+            }
+            writer.endControlFlow();
 
         } else if ("float".equals(fieldType)) {
-            writer.emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s(), false)", fieldName, interfaceName, getter);
+            writer.emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter);
 
         } else if ("java.lang.Float".equals(fieldType)) {
             writer
-                    .emitStatement("Float %s = ((%s)object).%s()", getter, interfaceName, getter)
+                    .emitStatement("Float %s = ((%s) object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
-                    if (isUpdate) {
-                        writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-                    }
-                    writer.endControlFlow();
+                    .emitStatement("Table.nativeSetFloat(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
+            if (isUpdate) {
+                writer.nextControlFlow("else")
+                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
+            }
+            writer.endControlFlow();
 
         } else if ("boolean".equals(fieldType)) {
-            writer.emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s)object).%s(), false)", fieldName, interfaceName, getter);
+            writer.emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, ((%s) object).%s(), false)", fieldName, interfaceName, getter);
 
         } else if ("java.lang.Boolean".equals(fieldType)) {
             writer
-                    .emitStatement("Boolean %s = ((%s)object).%s()", getter, interfaceName, getter)
+                    .emitStatement("Boolean %s = ((%s) object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
-                    if (isUpdate) {
-                        writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-                    }
-                    writer.endControlFlow();
+                    .emitStatement("Table.nativeSetBoolean(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
+            if (isUpdate) {
+                writer.nextControlFlow("else")
+                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
+            }
+            writer.endControlFlow();
 
         } else if ("byte[]".equals(fieldType)) {
             writer
-                    .emitStatement("byte[] %s = ((%s)object).%s()", getter, interfaceName, getter)
+                    .emitStatement("byte[] %s = ((%s) object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetByteArray(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
-                    if (isUpdate) {
-                        writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-                    }
-                    writer.endControlFlow();
+                    .emitStatement("Table.nativeSetByteArray(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
+            if (isUpdate) {
+                writer.nextControlFlow("else")
+                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
+            }
+            writer.endControlFlow();
 
 
         } else if ("java.util.Date".equals(fieldType)) {
             writer
-                    .emitStatement("java.util.Date %s = ((%s)object).%s()", getter, interfaceName, getter)
+                    .emitStatement("java.util.Date %s = ((%s) object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetTimestamp(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.getTime(), false)", fieldName, getter);
-                    if (isUpdate) {
-                        writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-                    }
-                    writer.endControlFlow();
+                    .emitStatement("Table.nativeSetTimestamp(tableNativePtr, columnInfo.%sIndex, rowIndex, %s.getTime(), false)", fieldName, getter);
+            if (isUpdate) {
+                writer.nextControlFlow("else")
+                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
+            }
+            writer.endControlFlow();
 
         } else if ("java.lang.String".equals(fieldType)) {
             writer
-                    .emitStatement("String %s = ((%s)object).%s()", getter, interfaceName, getter)
+                    .emitStatement("String %s = ((%s) object).%s()", getter, interfaceName, getter)
                     .beginControlFlow("if (%s != null)", getter)
-                        .emitStatement("Table.nativeSetString(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
-                    if (isUpdate) {
-                        writer.nextControlFlow("else")
-                                .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
-                    }
-                    writer.endControlFlow();
+                    .emitStatement("Table.nativeSetString(tableNativePtr, columnInfo.%sIndex, rowIndex, %s, false)", fieldName, getter);
+            if (isUpdate) {
+                writer.nextControlFlow("else")
+                        .emitStatement("Table.nativeSetNull(tableNativePtr, columnInfo.%sIndex, rowIndex, false)", fieldName);
+            }
+            writer.endControlFlow();
         } else {
             throw new IllegalStateException("Unsupported type " + fieldType);
         }
@@ -1131,17 +1072,17 @@ private void emitInsertMethod(JavaWriter writer) throws IOException {
 
         // If object is already in the Realm there is nothing to update
         writer
-                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))")
-                .emitStatement("return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex()")
+                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))")
+                .emitStatement("return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex()")
                 .endControlFlow();
 
         writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
-        writer.emitStatement("long tableNativePtr = table.getNativeTablePointer()");
-        writer.emitStatement("%s columnInfo = (%s) realm.schema.getColumnInfo(%s.class)",
+        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
+        writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
                 columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
 
         if (metadata.hasPrimaryKey()) {
-            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
+            writer.emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.getPrimaryKey()));
         }
         addPrimaryKeyCheckIfNeeded(metadata, true, writer);
 
@@ -1156,33 +1097,48 @@ private void emitInsertMethod(JavaWriter writer) throws IOException {
                         .emitEmptyLine()
                         .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
                         .beginControlFlow("if (%sObj != null)", fieldName)
-                            .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
-                            .beginControlFlow("if (cache%s == null)", fieldName)
-                                .emitStatement("cache%s = %s.insert(realm, %sObj, cache)",
-                                        fieldName,
-                                        Utils.getProxyClassSimpleName(field),
-                                        fieldName)
-                            .endControlFlow()
-                           .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
+                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
+                        .beginControlFlow("if (cache%s == null)", fieldName)
+                        .emitStatement("cache%s = %s.insert(realm, %sObj, cache)",
+                                fieldName,
+                                Utils.getProxyClassSimpleName(field),
+                                fieldName)
+                        .endControlFlow()
+                        .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                         .endControlFlow();
-            } else if (Utils.isRealmList(field)) {
+            } else if (Utils.isRealmModelList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
                 writer
                         .emitEmptyLine()
                         .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
                                 genericType, fieldName, interfaceName, getter)
                         .beginControlFlow("if (%sList != null)", fieldName)
-                            .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
-                            .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
-                                .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
-                             .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
-                                .emitStatement("cacheItemIndex%1$s = %2$s.insert(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
-                             .endControlFlow()
-                             .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
-                            .endControlFlow()
+                        .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
+                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
+                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                        .emitStatement("cacheItemIndex%1$s = %2$s.insert(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
                         .endControlFlow()
-                        .emitEmptyLine();
-
+                        .emitStatement("%1$sOsList.addRow(cacheItemIndex%1$s)", fieldName)
+                        .endControlFlow()
+                        .endControlFlow();
+            } else if (Utils.isRealmValueList(field)) {
+                final String genericType = Utils.getGenericTypeQualifiedName(field);
+                final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
+                                genericType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sList != null)", fieldName)
+                        .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
+                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                        .beginControlFlow("if (%1$sItem == null)", fieldName)
+                        .emitStatement(fieldName + "OsList.addNull()")
+                        .nextControlFlow("else")
+                        .emitStatement(getStatementForAppendingValueToOsList(fieldName + "OsList", fieldName + "Item", elementTypeMirror))
+                        .endControlFlow()
+                        .endControlFlow()
+                        .endControlFlow();
             } else {
                 if (metadata.getPrimaryKey() != field) {
                     setTableValues(writer, fieldType, fieldName, interfaceName, getter, false);
@@ -1205,20 +1161,22 @@ private void emitInsertListMethod(JavaWriter writer) throws IOException {
         );
 
         writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
-        writer.emitStatement("long tableNativePtr = table.getNativeTablePointer()");
-        writer.emitStatement("%s columnInfo = (%s) realm.schema.getColumnInfo(%s.class)",
+        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
+        writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
                 columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
         if (metadata.hasPrimaryKey()) {
-            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
+            writer.emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.getPrimaryKey()));
         }
         writer.emitStatement("%s object = null", qualifiedClassName);
 
         writer.beginControlFlow("while (objects.hasNext())")
                 .emitStatement("object = (%s) objects.next()", qualifiedClassName);
-        writer.beginControlFlow("if(!cache.containsKey(object))");
+        writer.beginControlFlow("if (cache.containsKey(object))")
+                .emitStatement("continue")
+                .endControlFlow();
 
-        writer.beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))");
-        writer.emitStatement("cache.put(object, ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex())")
+        writer.beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))");
+        writer.emitStatement("cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex())")
                 .emitStatement("continue");
         writer.endControlFlow();
 
@@ -1235,33 +1193,49 @@ private void emitInsertListMethod(JavaWriter writer) throws IOException {
                         .emitEmptyLine()
                         .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
                         .beginControlFlow("if (%sObj != null)", fieldName)
-                            .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
-                         .beginControlFlow("if (cache%s == null)", fieldName)
-                                .emitStatement("cache%s = %s.insert(realm, %sObj, cache)",
-                                        fieldName,
-                                        Utils.getProxyClassSimpleName(field),
-                                        fieldName)
-                                .endControlFlow()
+                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
+                        .beginControlFlow("if (cache%s == null)", fieldName)
+                        .emitStatement("cache%s = %s.insert(realm, %sObj, cache)",
+                                fieldName,
+                                Utils.getProxyClassSimpleName(field),
+                                fieldName)
+                        .endControlFlow()
                         .emitStatement("table.setLink(columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                         .endControlFlow();
-            } else if (Utils.isRealmList(field)) {
+            } else if (Utils.isRealmModelList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
                 writer
                         .emitEmptyLine()
                         .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
                                 genericType, fieldName, interfaceName, getter)
                         .beginControlFlow("if (%sList != null)", fieldName)
-                            .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
-                          .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
-                                .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
-                             .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
-                                    .emitStatement("cacheItemIndex%1$s = %2$s.insert(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
-                             .endControlFlow()
-                        .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
+                        .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
+                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                        .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
+                        .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                        .emitStatement("cacheItemIndex%1$s = %2$s.insert(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
                         .endControlFlow()
+                        .emitStatement("%1$sOsList.addRow(cacheItemIndex%1$s)", fieldName)
                         .endControlFlow()
-                        .emitEmptyLine();
+                        .endControlFlow();
 
+            } else if (Utils.isRealmValueList(field)) {
+                final String genericType = Utils.getGenericTypeQualifiedName(field);
+                final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
+                                genericType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sList != null)", fieldName)
+                        .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
+                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                        .beginControlFlow("if (%1$sItem == null)", fieldName)
+                        .emitStatement("%1$sOsList.addNull()", fieldName)
+                        .nextControlFlow("else")
+                        .emitStatement(getStatementForAppendingValueToOsList(fieldName + "OsList", fieldName + "Item", elementTypeMirror))
+                        .endControlFlow()
+                        .endControlFlow()
+                        .endControlFlow();
             } else {
                 if (metadata.getPrimaryKey() != field) {
                     setTableValues(writer, fieldType, fieldName, interfaceName, getter, false);
@@ -1270,7 +1244,6 @@ private void emitInsertListMethod(JavaWriter writer) throws IOException {
         }
         //@formatter:on
 
-        writer.endControlFlow();
         writer.endControlFlow();
         writer.endMethod();
         writer.emitEmptyLine();
@@ -1286,17 +1259,17 @@ private void emitInsertOrUpdateMethod(JavaWriter writer) throws IOException {
 
         // If object is already in the Realm there is nothing to update
         writer
-                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))")
-                .emitStatement("return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex()")
+                .beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))")
+                .emitStatement("return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex()")
                 .endControlFlow();
 
         writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
-        writer.emitStatement("long tableNativePtr = table.getNativeTablePointer()");
-        writer.emitStatement("%s columnInfo = (%s) realm.schema.getColumnInfo(%s.class)",
+        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
+        writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
                 columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
 
         if (metadata.hasPrimaryKey()) {
-            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
+            writer.emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.getPrimaryKey()));
         }
         addPrimaryKeyCheckIfNeeded(metadata, false, writer);
 
@@ -1311,36 +1284,67 @@ private void emitInsertOrUpdateMethod(JavaWriter writer) throws IOException {
                         .emitEmptyLine()
                         .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
                         .beginControlFlow("if (%sObj != null)", fieldName)
-                            .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
-                            .beginControlFlow("if (cache%s == null)", fieldName)
-                                .emitStatement("cache%1$s = %2$s.insertOrUpdate(realm, %1$sObj, cache)",
-                                        fieldName,
-                                        Utils.getProxyClassSimpleName(field))
-                            .endControlFlow()
-                            .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
+                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
+                        .beginControlFlow("if (cache%s == null)", fieldName)
+                        .emitStatement("cache%1$s = %2$s.insertOrUpdate(realm, %1$sObj, cache)",
+                                fieldName,
+                                Utils.getProxyClassSimpleName(field))
+                        .endControlFlow()
+                        .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                         .nextControlFlow("else")
-                                // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
-                            .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
+                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
+                        .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
                         .endControlFlow();
-            } else if (Utils.isRealmList(field)) {
+            } else if (Utils.isRealmModelList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
                 writer
-                        .emitEmptyLine()
-                        .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
-                        .emitStatement("LinkView.nativeClear(%sNativeLinkViewPtr)", fieldName)
-                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
-                                genericType, fieldName, interfaceName, getter)
+                    .emitEmptyLine()
+                    .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
+                    .emitStatement("RealmList<%s> %sList = ((%s) object).%s()", genericType, fieldName, interfaceName, getter)
+                    .beginControlFlow("if (%1$sList != null && %1$sList.size() == %1$sOsList.size())", fieldName)
+                        .emitSingleLineComment("For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.")
+                        .emitStatement("int objects = %1$sList.size()", fieldName)
+                        .beginControlFlow("for (int i = 0; i < objects; i++)")
+                            .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
+                            .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
+                            .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                                .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                            .endControlFlow()
+                            .emitStatement("%1$sOsList.setRow(i, cacheItemIndex%1$s)", fieldName)
+                    .endControlFlow()
+                    .nextControlFlow("else")
+                        .emitStatement("%1$sOsList.removeAll()", fieldName)
                         .beginControlFlow("if (%sList != null)", fieldName)
                             .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
                                 .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
                                 .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
                                     .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
                                 .endControlFlow()
-                                .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
+                                .emitStatement("%1$sOsList.addRow(cacheItemIndex%1$s)", fieldName)
                             .endControlFlow()
                         .endControlFlow()
-                        .emitEmptyLine();
+                    .endControlFlow()
+                    .emitEmptyLine();
 
+            } else if (Utils.isRealmValueList(field)) {
+                final String genericType = Utils.getGenericTypeQualifiedName(field);
+                final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
+                        .emitStatement("%1$sOsList.removeAll()", fieldName)
+                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
+                                genericType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sList != null)", fieldName)
+                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                        .beginControlFlow("if (%1$sItem == null)", fieldName)
+                        .emitStatement("%1$sOsList.addNull()", fieldName)
+                        .nextControlFlow("else")
+                        .emitStatement(getStatementForAppendingValueToOsList(fieldName + "OsList", fieldName + "Item", elementTypeMirror))
+                        .endControlFlow()
+                        .endControlFlow()
+                        .endControlFlow()
+                        .emitEmptyLine();
             } else {
                 if (metadata.getPrimaryKey() != field) {
                     setTableValues(writer, fieldType, fieldName, interfaceName, getter, true);
@@ -1364,20 +1368,22 @@ private void emitInsertOrUpdateListMethod(JavaWriter writer) throws IOException
         );
 
         writer.emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName);
-        writer.emitStatement("long tableNativePtr = table.getNativeTablePointer()");
-        writer.emitStatement("%s columnInfo = (%s) realm.schema.getColumnInfo(%s.class)",
+        writer.emitStatement("long tableNativePtr = table.getNativePtr()");
+        writer.emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
                 columnInfoClassName(), columnInfoClassName(), qualifiedClassName);
         if (metadata.hasPrimaryKey()) {
-            writer.emitStatement("long pkColumnIndex = table.getPrimaryKey()");
+            writer.emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.getPrimaryKey()));
         }
         writer.emitStatement("%s object = null", qualifiedClassName);
 
         writer.beginControlFlow("while (objects.hasNext())");
         writer.emitStatement("object = (%s) objects.next()", qualifiedClassName);
-        writer.beginControlFlow("if(!cache.containsKey(object))");
+        writer.beginControlFlow("if (cache.containsKey(object))")
+                .emitStatement("continue")
+                .endControlFlow();
 
-        writer.beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))");
-        writer.emitStatement("cache.put(object, ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex())")
+        writer.beginControlFlow("if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath()))");
+        writer.emitStatement("cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex())")
                 .emitStatement("continue");
         writer.endControlFlow();
         addPrimaryKeyCheckIfNeeded(metadata, false, writer);
@@ -1393,36 +1399,68 @@ private void emitInsertOrUpdateListMethod(JavaWriter writer) throws IOException
                         .emitEmptyLine()
                         .emitStatement("%s %sObj = ((%s) object).%s()", fieldType, fieldName, interfaceName, getter)
                         .beginControlFlow("if (%sObj != null)", fieldName)
-                            .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
-                            .beginControlFlow("if (cache%s == null)", fieldName)
-                                .emitStatement("cache%1$s = %2$s.insertOrUpdate(realm, %1$sObj, cache)",
-                                        fieldName,
-                                        Utils.getProxyClassSimpleName(field))
-                                    .endControlFlow()
-                            .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
+                        .emitStatement("Long cache%1$s = cache.get(%1$sObj)", fieldName)
+                        .beginControlFlow("if (cache%s == null)", fieldName)
+                        .emitStatement("cache%1$s = %2$s.insertOrUpdate(realm, %1$sObj, cache)",
+                                fieldName,
+                                Utils.getProxyClassSimpleName(field))
+                        .endControlFlow()
+                        .emitStatement("Table.nativeSetLink(tableNativePtr, columnInfo.%1$sIndex, rowIndex, cache%1$s, false)", fieldName)
                         .nextControlFlow("else")
-                                // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
-                            .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
+                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
+                        .emitStatement("Table.nativeNullifyLink(tableNativePtr, columnInfo.%sIndex, rowIndex)", fieldName)
                         .endControlFlow();
-            } else if (Utils.isRealmList(field)) {
+            } else if (Utils.isRealmModelList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
                 writer
-                        .emitEmptyLine()
-                        .emitStatement("long %1$sNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.%1$sIndex, rowIndex)", fieldName)
-                        .emitStatement("LinkView.nativeClear(%sNativeLinkViewPtr)", fieldName)
-                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
-                                genericType, fieldName, interfaceName, getter)
+                    .emitEmptyLine()
+                    .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
+                    .emitStatement("RealmList<%s> %sList = ((%s) object).%s()", genericType, fieldName, interfaceName, getter)
+                    .beginControlFlow("if (%1$sList != null && %1$sList.size() == %1$sOsList.size())", fieldName)
+                        .emitSingleLineComment("For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.")
+                        .emitStatement("int objectCount = %1$sList.size()", fieldName)
+                        .beginControlFlow("for (int i = 0; i < objectCount; i++)")
+                            .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
+                            .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
+                            .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                                .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
+                            .endControlFlow()
+                            .emitStatement("%1$sOsList.setRow(i, cacheItemIndex%1$s)", fieldName)
+                        .endControlFlow()
+                    .nextControlFlow("else")
+                        .emitStatement("%1$sOsList.removeAll()", fieldName)
                         .beginControlFlow("if (%sList != null)", fieldName)
                             .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
                                 .emitStatement("Long cacheItemIndex%1$s = cache.get(%1$sItem)", fieldName)
-                            .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
+                                .beginControlFlow("if (cacheItemIndex%s == null)", fieldName)
                                     .emitStatement("cacheItemIndex%1$s = %2$s.insertOrUpdate(realm, %1$sItem, cache)", fieldName, Utils.getProxyClassSimpleName(field))
                                 .endControlFlow()
-                            .emitStatement("LinkView.nativeAdd(%1$sNativeLinkViewPtr, cacheItemIndex%1$s)", fieldName)
+                                .emitStatement("%1$sOsList.addRow(cacheItemIndex%1$s)", fieldName)
                             .endControlFlow()
                         .endControlFlow()
-                        .emitEmptyLine();
+                    .endControlFlow()
+                    .emitEmptyLine();
 
+            } else if (Utils.isRealmValueList(field)) {
+                final String genericType = Utils.getGenericTypeQualifiedName(field);
+                final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("OsList %1$sOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.%1$sIndex)", fieldName)
+                        .emitStatement("%1$sOsList.removeAll()", fieldName)
+                        .emitStatement("RealmList<%s> %sList = ((%s) object).%s()",
+                                genericType, fieldName, interfaceName, getter)
+                        .beginControlFlow("if (%sList != null)", fieldName)
+                        .beginControlFlow("for (%1$s %2$sItem : %2$sList)", genericType, fieldName)
+                        .beginControlFlow("if (%1$sItem == null)", fieldName)
+                        .emitStatement("%1$sOsList.addNull()", fieldName)
+                        .nextControlFlow("else")
+                        .emitStatement(getStatementForAppendingValueToOsList(fieldName + "OsList",
+                                fieldName + "Item", elementTypeMirror))
+                        .endControlFlow()
+                        .endControlFlow()
+                        .endControlFlow()
+                        .emitEmptyLine();
             } else {
                 if (metadata.getPrimaryKey() != field) {
                     setTableValues(writer, fieldType, fieldName, interfaceName, getter, true);
@@ -1431,7 +1469,6 @@ private void emitInsertOrUpdateListMethod(JavaWriter writer) throws IOException
             //@formatter:on
         }
         writer.endControlFlow();
-        writer.endControlFlow();
 
         writer.endMethod();
         writer.emitEmptyLine();
@@ -1445,22 +1482,22 @@ private void addPrimaryKeyCheckIfNeeded(ClassMetaData metadata, boolean throwIfP
                 //@formatter:off
                 if (Utils.isString(primaryKeyElement)) {
                     writer
-                        .emitStatement("String primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
-                        .emitStatement("long rowIndex = Table.NO_MATCH")
-                        .beginControlFlow("if (primaryKeyValue == null)")
-                        .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
-                        .nextControlFlow("else")
-                        .emitStatement("rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue)")
-                        .endControlFlow();
+                            .emitStatement("String primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
+                            .emitStatement("long rowIndex = Table.NO_MATCH")
+                            .beginControlFlow("if (primaryKeyValue == null)")
+                            .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
+                            .nextControlFlow("else")
+                            .emitStatement("rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue)")
+                            .endControlFlow();
                 } else {
                     writer
-                        .emitStatement("Object primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
-                        .emitStatement("long rowIndex = Table.NO_MATCH")
-                        .beginControlFlow("if (primaryKeyValue == null)")
-                        .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
-                        .nextControlFlow("else")
-                        .emitStatement("rowIndex = Table.nativeFindFirstInt(tableNativePtr, pkColumnIndex, ((%s) object).%s())", interfaceName, primaryKeyGetter)
-                        .endControlFlow();
+                            .emitStatement("Object primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
+                            .emitStatement("long rowIndex = Table.NO_MATCH")
+                            .beginControlFlow("if (primaryKeyValue == null)")
+                            .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
+                            .nextControlFlow("else")
+                            .emitStatement("rowIndex = Table.nativeFindFirstInt(tableNativePtr, pkColumnIndex, ((%s) object).%s())", interfaceName, primaryKeyGetter)
+                            .endControlFlow();
                 }
                 //@formatter:on
             } else {
@@ -1478,9 +1515,11 @@ private void addPrimaryKeyCheckIfNeeded(ClassMetaData metadata, boolean throwIfP
 
             writer.beginControlFlow("if (rowIndex == Table.NO_MATCH)");
             if (Utils.isString(metadata.getPrimaryKey())) {
-                writer.emitStatement("rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false)");
+                writer.emitStatement(
+                        "rowIndex = OsObject.createRowWithPrimaryKey(table, pkColumnIndex, primaryKeyValue)");
             } else {
-                writer.emitStatement("rowIndex = table.addEmptyRowWithPrimaryKey(((%s) object).%s(), false)",
+                writer.emitStatement(
+                        "rowIndex = OsObject.createRowWithPrimaryKey(table, pkColumnIndex, ((%s) object).%s())",
                         interfaceName, primaryKeyGetter);
             }
 
@@ -1492,7 +1531,7 @@ private void addPrimaryKeyCheckIfNeeded(ClassMetaData metadata, boolean throwIfP
             writer.endControlFlow();
             writer.emitStatement("cache.put(object, rowIndex)");
         } else {
-            writer.emitStatement("long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1)");
+            writer.emitStatement("long rowIndex = OsObject.createRow(table)");
             writer.emitStatement("cache.put(object, rowIndex)");
         }
     }
@@ -1507,9 +1546,11 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
         writer.emitStatement("RealmObjectProxy cachedRealmObject = cache.get(newObject)");
         writer.beginControlFlow("if (cachedRealmObject != null)")
                 .emitStatement("return (%s) cachedRealmObject", qualifiedClassName)
-                .nextControlFlow("else");
+                .endControlFlow();
 
-        writer.emitSingleLineComment("rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.");
+
+        writer.emitEmptyLine()
+                .emitSingleLineComment("rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.");
         if (metadata.hasPrimaryKey()) {
             writer.emitStatement("%s realmObject = realm.createObjectInternal(%s.class, ((%s) newObject).%s(), false, Collections.<String>emptyList())",
                     qualifiedClassName, qualifiedClassName, interfaceName, metadata.getPrimaryKeyGetter());
@@ -1518,6 +1559,12 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
                     qualifiedClassName, qualifiedClassName);
         }
         writer.emitStatement("cache.put(newObject, (RealmObjectProxy) realmObject)");
+
+        writer.emitEmptyLine()
+                .emitStatement("%1$s realmObjectSource = (%1$s) newObject", interfaceName)
+                .emitStatement("%1$s realmObjectCopy = (%1$s) realmObject", interfaceName);
+
+        writer.emitEmptyLine();
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String fieldType = field.asType().toString();
@@ -1530,55 +1577,55 @@ private void emitCopyMethod(JavaWriter writer) throws IOException {
             }
 
             //@formatter:off
-                if (Utils.isRealmModel(field)) {
-                    writer
-                        .emitEmptyLine()
-                        .emitStatement("%s %sObj = ((%s) newObject).%s()", fieldType, fieldName, interfaceName, getter)
-                        .beginControlFlow("if (%sObj != null)", fieldName)
+            if (Utils.isRealmModel(field)) {
+                writer.emitEmptyLine()
+                        .emitStatement("%s %sObj = realmObjectSource.%s()", fieldType, fieldName, getter)
+                        .beginControlFlow("if (%sObj == null)", fieldName)
+                            .emitStatement("realmObjectCopy.%s(null)", setter)
+                        .nextControlFlow("else")
                             .emitStatement("%s cache%s = (%s) cache.get(%sObj)", fieldType, fieldName, fieldType, fieldName)
                             .beginControlFlow("if (cache%s != null)", fieldName)
-                                .emitStatement("((%s) realmObject).%s(cache%s)", interfaceName, setter, fieldName)
+                                .emitStatement("realmObjectCopy.%s(cache%s)", setter, fieldName)
                             .nextControlFlow("else")
-                                .emitStatement("((%s) realmObject).%s(%s.copyOrUpdate(realm, %sObj, update, cache))",
-                                        interfaceName,
-                                        setter,
-                                        Utils.getProxyClassSimpleName(field),
-                                        fieldName)
+                                .emitStatement("realmObjectCopy.%s(%s.copyOrUpdate(realm, %sObj, update, cache))",
+                                    setter, Utils.getProxyClassSimpleName(field), fieldName)
                             .endControlFlow()
-                        .nextControlFlow("else")
-                            // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
-                            .emitStatement("((%s) realmObject).%s(null)", interfaceName, setter)
+                        // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
                         .endControlFlow();
-                } else if (Utils.isRealmList(field)) {
-                    final String genericType = Utils.getGenericTypeQualifiedName(field);
-                    writer
-                        .emitEmptyLine()
-                        .emitStatement("RealmList<%s> %sList = ((%s) newObject).%s()",
-                                genericType, fieldName, interfaceName, getter)
+            } else if (Utils.isRealmModelList(field)) {
+                final String genericType = Utils.getGenericTypeQualifiedName(field);
+                writer.emitEmptyLine()
+                        .emitStatement("RealmList<%s> %sList = realmObjectSource.%s()", genericType, fieldName, getter)
                         .beginControlFlow("if (%sList != null)", fieldName)
-                            .emitStatement("RealmList<%s> %sRealmList = ((%s) realmObject).%s()",
-                                    genericType, fieldName, interfaceName, getter)
+                            .emitStatement("RealmList<%s> %sRealmList = realmObjectCopy.%s()",
+                                genericType, fieldName, getter)
+                             // Clear is needed. See bug https://github.com/realm/realm-java/issues/4957
+                            .emitStatement("%sRealmList.clear()", fieldName)
                             .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
-                                    .emitStatement("%s %sItem = %sList.get(i)", genericType, fieldName, fieldName)
-                                    .emitStatement("%s cache%s = (%s) cache.get(%sItem)", genericType, fieldName, genericType, fieldName)
-                                    .beginControlFlow("if (cache%s != null)", fieldName)
-                                            .emitStatement("%sRealmList.add(cache%s)", fieldName, fieldName)
-                                    .nextControlFlow("else")
-                                            .emitStatement("%sRealmList.add(%s.copyOrUpdate(realm, %sList.get(i), update, cache))", fieldName, Utils.getProxyClassSimpleName(field), fieldName)
-                                    .endControlFlow()
+                                .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
+                                .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sItem)", genericType, fieldName)
+                                .beginControlFlow("if (cache%s != null)", fieldName)
+                                    .emitStatement("%1$sRealmList.add(cache%1$s)", fieldName)
+                                .nextControlFlow("else")
+                                    .emitStatement("%1$sRealmList.add(%2$s.copyOrUpdate(realm, %1$sItem, update, cache))",
+                                        fieldName, Utils.getProxyClassSimpleName(field))
+                                .endControlFlow()
                             .endControlFlow()
                         .endControlFlow()
                         .emitEmptyLine();
 
-                } else {
-                    writer.emitStatement("((%s) realmObject).%s(((%s) newObject).%s())",
-                            interfaceName, setter, interfaceName, getter);
-                }
-                //@formatter:on
+            } else if (Utils.isRealmValueList(field)) {
+                writer.emitStatement("realmObjectCopy.%s(realmObjectSource.%s())", setter, getter);
+            } else if (Utils.isMutableRealmInteger(field)) {
+                writer.emitEmptyLine()
+                        .emitStatement("realmObjectCopy.%1$s().set(realmObjectSource.%1$s().get())", getter);
+            } else {
+                writer.emitStatement("realmObjectCopy.%s(realmObjectSource.%s())", setter, getter);
+            }
+            //@formatter:on
         }
 
         writer.emitStatement("return realmObject");
-        writer.endControlFlow();
         writer.endMethod();
         writer.emitEmptyLine();
     }
@@ -1591,23 +1638,26 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
                 EnumSet.of(Modifier.PUBLIC, Modifier.STATIC), // Modifiers
                 qualifiedClassName, "realmObject", "int", "currentDepth", "int", "maxDepth", "Map<RealmModel, CacheData<RealmModel>>", "cache");
         writer
-            .beginControlFlow("if (currentDepth > maxDepth || realmObject == null)")
+                .beginControlFlow("if (currentDepth > maxDepth || realmObject == null)")
                 .emitStatement("return null")
-            .endControlFlow()
-            .emitStatement("CacheData<RealmModel> cachedObject = cache.get(realmObject)")
-            .emitStatement("%s unmanagedObject", qualifiedClassName)
-            .beginControlFlow("if (cachedObject != null)")
-                .emitSingleLineComment("Reuse cached object or recreate it because it was encountered at a lower depth.")
-                .beginControlFlow("if (currentDepth >= cachedObject.minDepth)")
-                    .emitStatement("return (%s)cachedObject.object", qualifiedClassName)
-                .nextControlFlow("else")
-                    .emitStatement("unmanagedObject = (%s)cachedObject.object", qualifiedClassName)
-                    .emitStatement("cachedObject.minDepth = currentDepth")
                 .endControlFlow()
-            .nextControlFlow("else")
+                .emitStatement("CacheData<RealmModel> cachedObject = cache.get(realmObject)")
+                .emitStatement("%s unmanagedObject", qualifiedClassName)
+                .beginControlFlow("if (cachedObject == null)")
                 .emitStatement("unmanagedObject = new %s()", qualifiedClassName)
                 .emitStatement("cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject))")
-            .endControlFlow();
+                .nextControlFlow("else")
+                .emitSingleLineComment("Reuse cached object or recreate it because it was encountered at a lower depth.")
+                .beginControlFlow("if (currentDepth >= cachedObject.minDepth)")
+                .emitStatement("return (%s) cachedObject.object", qualifiedClassName)
+                .endControlFlow()
+                .emitStatement("unmanagedObject = (%s) cachedObject.object", qualifiedClassName)
+                .emitStatement("cachedObject.minDepth = currentDepth")
+                .endControlFlow();
+
+        // may cause an unused variable warning if the object contains only null lists
+        writer.emitStatement("%1$s unmanagedCopy = (%1$s) unmanagedObject", interfaceName)
+            .emitStatement("%1$s realmSource = (%1$s) realmObject", interfaceName);
 
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
@@ -1616,35 +1666,43 @@ private void emitCreateDetachedCopyMethod(JavaWriter writer) throws IOException
 
             if (Utils.isRealmModel(field)) {
                 writer
-                    .emitEmptyLine()
-                    .emitSingleLineComment("Deep copy of %s", fieldName)
-                    .emitStatement("((%s) unmanagedObject).%s(%s.createDetachedCopy(((%s) realmObject).%s(), currentDepth + 1, maxDepth, cache))",
-                                interfaceName, setter, Utils.getProxyClassSimpleName(field), interfaceName, getter);
-            } else if (Utils.isRealmList(field)) {
+                        .emitEmptyLine()
+                        .emitSingleLineComment("Deep copy of %s", fieldName)
+                        .emitStatement("unmanagedCopy.%s(%s.createDetachedCopy(realmSource.%s(), currentDepth + 1, maxDepth, cache))",
+                                setter, Utils.getProxyClassSimpleName(field), getter);
+            } else if (Utils.isRealmModelList(field)) {
                 writer
-                    .emitEmptyLine()
-                    .emitSingleLineComment("Deep copy of %s", fieldName)
-                    .beginControlFlow("if (currentDepth == maxDepth)")
-                        .emitStatement("((%s) unmanagedObject).%s(null)", interfaceName, setter)
-                    .nextControlFlow("else")
-                        .emitStatement("RealmList<%s> managed%sList = ((%s) realmObject).%s()",
-                                 Utils.getGenericTypeQualifiedName(field), fieldName, interfaceName, getter)
+                        .emitEmptyLine()
+                        .emitSingleLineComment("Deep copy of %s", fieldName)
+                        .beginControlFlow("if (currentDepth == maxDepth)")
+                        .emitStatement("unmanagedCopy.%s(null)", setter)
+                        .nextControlFlow("else")
+                        .emitStatement("RealmList<%s> managed%sList = realmSource.%s()",
+                                Utils.getGenericTypeQualifiedName(field), fieldName, getter)
                         .emitStatement("RealmList<%1$s> unmanaged%2$sList = new RealmList<%1$s>()", Utils.getGenericTypeQualifiedName(field), fieldName)
-                        .emitStatement("((%s) unmanagedObject).%s(unmanaged%sList)", interfaceName, setter, fieldName)
+                        .emitStatement("unmanagedCopy.%s(unmanaged%sList)", setter, fieldName)
                         .emitStatement("int nextDepth = currentDepth + 1")
                         .emitStatement("int size = managed%sList.size()", fieldName)
                         .beginControlFlow("for (int i = 0; i < size; i++)")
-                            .emitStatement("%s item = %s.createDetachedCopy(managed%sList.get(i), nextDepth, maxDepth, cache)",
-                                    Utils.getGenericTypeQualifiedName(field), Utils.getProxyClassSimpleName(field), fieldName)
-                            .emitStatement("unmanaged%sList.add(item)", fieldName)
+                        .emitStatement("%s item = %s.createDetachedCopy(managed%sList.get(i), nextDepth, maxDepth, cache)",
+                                Utils.getGenericTypeQualifiedName(field), Utils.getProxyClassSimpleName(field), fieldName)
+                        .emitStatement("unmanaged%sList.add(item)", fieldName)
                         .endControlFlow()
-                    .endControlFlow();
+                        .endControlFlow();
+            } else if (Utils.isRealmValueList(field)) {
+                writer
+                        .emitEmptyLine()
+                        .emitStatement("unmanagedCopy.%1$s(new RealmList<%2$s>())", setter, Utils.getGenericTypeQualifiedName(field))
+                        .emitStatement("unmanagedCopy.%1$s().addAll(realmSource.%1$s())", getter);
+            } else if (Utils.isMutableRealmInteger(field)) {
+                // If the user initializes the unmanaged MutableRealmInteger to null, this will fail mysteriously.
+                writer.emitStatement("unmanagedCopy.%s().set(realmSource.%s().get())", getter, getter);
             } else {
-                writer.emitStatement("((%s) unmanagedObject).%s(((%s) realmObject).%s())",
-                        interfaceName, setter, interfaceName, getter);
+                writer.emitStatement("unmanagedCopy.%s(realmSource.%s())", setter, getter);
             }
         }
 
+        writer.emitEmptyLine();
         writer.emitStatement("return unmanagedObject");
         writer.endMethod();
         writer.emitEmptyLine();
@@ -1662,6 +1720,10 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
                 EnumSet.of(Modifier.STATIC), // Modifiers
                 "Realm", "realm", qualifiedClassName, "realmObject", qualifiedClassName, "newObject", "Map<RealmModel, RealmObjectProxy>", "cache"); // Argument type & argument name
 
+        writer
+                .emitStatement("%1$s realmObjectTarget = (%1$s) realmObject", interfaceName)
+                .emitStatement("%1$s realmObjectSource = (%1$s) newObject", interfaceName);
+
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String setter = metadata.getInternalSetter(fieldName);
@@ -1669,50 +1731,60 @@ private void emitUpdateMethod(JavaWriter writer) throws IOException {
             //@formatter:off
             if (Utils.isRealmModel(field)) {
                 writer
-                    .emitStatement("%s %sObj = ((%s) newObject).%s()",
-                            Utils.getFieldTypeQualifiedName(field), fieldName, interfaceName, getter)
-                    .beginControlFlow("if (%sObj != null)", fieldName)
-                        .emitStatement("%s cache%s = (%s) cache.get(%sObj)", Utils.getFieldTypeQualifiedName(field), fieldName, Utils.getFieldTypeQualifiedName(field), fieldName)
+                        .emitStatement("%s %sObj = realmObjectSource.%s()",
+                                Utils.getFieldTypeQualifiedName(field), fieldName, getter)
+                        .beginControlFlow("if (%sObj == null)", fieldName)
+                        .emitStatement("realmObjectTarget.%s(null)", setter)
+                        .nextControlFlow("else")
+                        .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sObj)",
+                                Utils.getFieldTypeQualifiedName(field), fieldName)
                         .beginControlFlow("if (cache%s != null)", fieldName)
-                            .emitStatement("((%s) realmObject).%s(cache%s)", interfaceName, setter, fieldName)
+                        .emitStatement("realmObjectTarget.%s(cache%s)", setter, fieldName)
                         .nextControlFlow("else")
-                            .emitStatement("((%s) realmObject).%s(%s.copyOrUpdate(realm, %sObj, true, cache))",
-                                    interfaceName,
-                                    setter,
-                                    Utils.getProxyClassSimpleName(field),
-                                    fieldName
-                            )
+                        .emitStatement("realmObjectTarget.%s(%s.copyOrUpdate(realm, %sObj, true, cache))",
+                                setter, Utils.getProxyClassSimpleName(field), fieldName)
                         .endControlFlow()
-                    .nextControlFlow("else")
                         // No need to throw exception here if the field is not nullable. A exception will be thrown in setter.
-                        .emitStatement("((%s) realmObject).%s(null)", interfaceName, setter)
-                    .endControlFlow();
-            } else if (Utils.isRealmList(field)) {
+                        .endControlFlow();
+            } else if (Utils.isRealmModelList(field)) {
                 final String genericType = Utils.getGenericTypeQualifiedName(field);
                 writer
-                    .emitStatement("RealmList<%s> %sList = ((%s) newObject).%s()",
-                            genericType, fieldName, interfaceName, getter)
-                    .emitStatement("RealmList<%s> %sRealmList = ((%s) realmObject).%s()",
-                            genericType, fieldName, interfaceName, getter)
-                    .emitStatement("%sRealmList.clear()", fieldName)
-                    .beginControlFlow("if (%sList != null)", fieldName)
-                        .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
-                            .emitStatement("%s %sItem = %sList.get(i)", genericType, fieldName, fieldName)
-                            .emitStatement("%s cache%s = (%s) cache.get(%sItem)", genericType, fieldName, genericType, fieldName)
+                    .emitStatement("RealmList<%s> %sList = realmObjectSource.%s()", genericType, fieldName, getter)
+                    .emitStatement("RealmList<%s> %sRealmList = realmObjectTarget.%s()", genericType, fieldName, getter)
+                    .beginControlFlow("if (%1$sList != null && %1$sList.size() == %1$sRealmList.size())", fieldName)
+                        .emitSingleLineComment("For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.")
+                        .emitStatement("int objects = %sList.size()", fieldName)
+                        .beginControlFlow("for (int i = 0; i < objects; i++)")
+                            .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
+                            .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sItem)", genericType, fieldName)
                             .beginControlFlow("if (cache%s != null)", fieldName)
-                                .emitStatement("%sRealmList.add(cache%s)", fieldName, fieldName)
+                                .emitStatement("%1$sRealmList.set(i, cache%1$s)", fieldName)
                             .nextControlFlow("else")
-                                .emitStatement("%sRealmList.add(%s.copyOrUpdate(realm, %sList.get(i), true, cache))", fieldName, Utils.getProxyClassSimpleName(field), fieldName)
+                                .emitStatement("%1$sRealmList.set(i, %2$s.copyOrUpdate(realm, %1$sItem, true, cache))", fieldName, Utils.getProxyClassSimpleName(field))
+                            .endControlFlow()
+                        .endControlFlow()
+                    .nextControlFlow("else")
+                        .emitStatement("%sRealmList.clear()", fieldName)
+                        .beginControlFlow("if (%sList != null)", fieldName)
+                            .beginControlFlow("for (int i = 0; i < %sList.size(); i++)", fieldName)
+                                .emitStatement("%1$s %2$sItem = %2$sList.get(i)", genericType, fieldName)
+                                .emitStatement("%1$s cache%2$s = (%1$s) cache.get(%2$sItem)", genericType, fieldName)
+                                .beginControlFlow("if (cache%s != null)", fieldName)
+                                    .emitStatement("%1$sRealmList.add(cache%1$s)", fieldName)
+                                .nextControlFlow("else")
+                                    .emitStatement("%1$sRealmList.add(%2$s.copyOrUpdate(realm, %1$sItem, true, cache))", fieldName, Utils.getProxyClassSimpleName(field))
+                                .endControlFlow()
                             .endControlFlow()
                         .endControlFlow()
                     .endControlFlow();
-
+            } else if (Utils.isRealmValueList(field)) {
+                writer.emitStatement("realmObjectTarget.%s(realmObjectSource.%s())", setter, getter);
+            } else if (Utils.isMutableRealmInteger(field)) {
+                writer.emitStatement("realmObjectTarget.%s().set(realmObjectSource.%s().get())", getter, getter);
             } else {
-                if (field == metadata.getPrimaryKey()) {
-                    continue;
+                if (field != metadata.getPrimaryKey()) {
+                    writer.emitStatement("realmObjectTarget.%s(realmObjectSource.%s())", setter, getter);
                 }
-                writer.emitStatement("((%s) realmObject).%s(((%s) newObject).%s())",
-                        interfaceName, setter, interfaceName, getter);
             }
             //@formatter:on
         }
@@ -1732,7 +1804,7 @@ private void emitToStringMethod(JavaWriter writer) throws IOException {
                 .beginControlFlow("if (!RealmObject.isValid(this))")
                 .emitStatement("return \"Invalid object\"")
                 .endControlFlow();
-        writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = [\")", simpleClassName);
+        writer.emitStatement("StringBuilder stringBuilder = new StringBuilder(\"%s = proxy[\")", simpleClassName);
 
         Collection<VariableElement> fields = metadata.getFields();
         int i = fields.size() - 1;
@@ -1752,6 +1824,8 @@ private void emitToStringMethod(JavaWriter writer) throws IOException {
                 writer.emitStatement("stringBuilder.append(\"RealmList<%s>[\").append(%s().size()).append(\"]\")",
                         genericTypeSimpleName,
                         metadata.getInternalGetter(fieldName));
+            } else if (Utils.isMutableRealmInteger(field)) {
+                writer.emitStatement("stringBuilder.append(%s().get())", metadata.getInternalGetter(fieldName));
             } else {
                 if (metadata.isNullable(field)) {
                     writer.emitStatement("stringBuilder.append(%s() != null ? %s() : \"null\")",
@@ -1786,7 +1860,7 @@ private void emitHashcodeMethod(JavaWriter writer) throws IOException {
             return;
         }
         writer.emitAnnotation("Override")
-            .beginMethod("int", "hashCode", EnumSet.of(Modifier.PUBLIC))
+                .beginMethod("int", "hashCode", EnumSet.of(Modifier.PUBLIC))
                 .emitStatement("String realmName = proxyState.getRealm$realm().getPath()")
                 .emitStatement("String tableName = proxyState.getRow$realm().getTable().getName()")
                 .emitStatement("long rowIndex = proxyState.getRow$realm().getIndex()")
@@ -1796,8 +1870,8 @@ private void emitHashcodeMethod(JavaWriter writer) throws IOException {
                 .emitStatement("result = 31 * result + ((tableName != null) ? tableName.hashCode() : 0)")
                 .emitStatement("result = 31 * result + (int) (rowIndex ^ (rowIndex >>> 32))")
                 .emitStatement("return result")
-            .endMethod()
-            .emitEmptyLine();
+                .endMethod()
+                .emitEmptyLine();
     }
     //@formatter:on
 
@@ -1809,7 +1883,7 @@ private void emitEqualsMethod(JavaWriter writer) throws IOException {
         String proxyClassName = Utils.getProxyClassName(simpleClassName);
         String otherObjectVarName = "a" + simpleClassName;
         writer.emitAnnotation("Override")
-            .beginMethod("boolean", "equals", EnumSet.of(Modifier.PUBLIC), "Object", "o")
+                .beginMethod("boolean", "equals", EnumSet.of(Modifier.PUBLIC), "Object", "o")
                 .emitStatement("if (this == o) return true")
                 .emitStatement("if (o == null || getClass() != o.getClass()) return false")
                 .emitStatement("%s %s = (%s)o", proxyClassName, otherObjectVarName, proxyClassName)  // FooRealmProxy aFoo = (FooRealmProxy)o
@@ -1825,8 +1899,7 @@ private void emitEqualsMethod(JavaWriter writer) throws IOException {
                 .emitStatement("if (proxyState.getRow$realm().getIndex() != %s.proxyState.getRow$realm().getIndex()) return false", otherObjectVarName)
                 .emitEmptyLine()
                 .emitStatement("return true")
-            .endMethod()
-            .emitEmptyLine();
+                .endMethod();
     }
     //@formatter:on
 
@@ -1858,47 +1931,54 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
                 .emitStatement("%s obj = null", qualifiedClassName)
                 .beginControlFlow("if (update)")
                     .emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName)
-                    .emitStatement("long pkColumnIndex = table.getPrimaryKey()")
+                    .emitStatement("%s columnInfo = (%s) realm.getSchema().getColumnInfo(%s.class)",
+                        columnInfoClassName(), columnInfoClassName(), qualifiedClassName)
+                    .emitStatement("long pkColumnIndex = %s", fieldIndexVariableReference(metadata.getPrimaryKey()))
                     .emitStatement("long rowIndex = Table.NO_MATCH");
             if (metadata.isNullable(metadata.getPrimaryKey())) {
                 writer
                     .beginControlFlow("if (json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
                         .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
                     .nextControlFlow("else")
-                        .emitStatement("rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
+                        .emitStatement(
+                                "rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
                                 pkType, pkType, metadata.getPrimaryKey().getSimpleName())
                     .endControlFlow();
             } else {
                 writer
                     .beginControlFlow("if (!json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
-                    .emitStatement("rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
-                            pkType, pkType, metadata.getPrimaryKey().getSimpleName())
+                        .emitStatement(
+                                "rowIndex = table.findFirst%s(pkColumnIndex, json.get%s(\"%s\"))",
+                                pkType, pkType, metadata.getPrimaryKey().getSimpleName())
                     .endControlFlow();
             }
             writer
-                    .beginControlFlow("if (rowIndex != Table.NO_MATCH)")
-                        .emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()")
-                        .beginControlFlow("try")
-                            .emitStatement("objectContext.set(realm, table.getUncheckedRow(rowIndex)," +
-                                    " realm.schema.getColumnInfo(%s.class)," +
-                                    " false, Collections.<String> emptyList())", qualifiedClassName)
-                            .emitStatement("obj = new %s()", qualifiedGeneratedClassName)
-                        .nextControlFlow("finally")
-                            .emitStatement("objectContext.clear()")
-                        .endControlFlow()
+                .beginControlFlow("if (rowIndex != Table.NO_MATCH)")
+                    .emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()")
+                    .beginControlFlow("try")
+                        .emitStatement(
+                                "objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(%s.class), false, Collections.<String> emptyList())",
+                                qualifiedClassName)
+                        .emitStatement("obj = new %s()", qualifiedGeneratedClassName)
+                    .nextControlFlow("finally")
+                        .emitStatement("objectContext.clear()")
                     .endControlFlow()
-                .endControlFlow();
+                .endControlFlow()
+            .endControlFlow();
 
             writer.beginControlFlow("if (obj == null)");
             buildExcludeFieldsList(writer, metadata.getFields());
             String primaryKeyFieldType = metadata.getPrimaryKey().asType().toString();
             String primaryKeyFieldName = metadata.getPrimaryKey().getSimpleName().toString();
-            RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(qualifiedClassName, qualifiedGeneratedClassName,
-                    primaryKeyFieldType, primaryKeyFieldName, writer);
+            RealmJsonTypeHelper.emitCreateObjectWithPrimaryKeyValue(
+                    qualifiedClassName, qualifiedGeneratedClassName, primaryKeyFieldType, primaryKeyFieldName, writer);
             writer.endControlFlow();
         }
         //@formatter:on
 
+        writer
+                .emitEmptyLine()
+                .emitStatement("final %1$s objProxy = (%1$s) obj", interfaceName);
         for (VariableElement field : metadata.getFields()) {
             String fieldName = field.getSimpleName().toString();
             String qualifiedFieldType = field.asType().toString();
@@ -1908,7 +1988,7 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
             }
             if (Utils.isRealmModel(field)) {
                 RealmJsonTypeHelper.emitFillRealmObjectWithJsonValue(
-                        interfaceName,
+                        "objProxy",
                         metadata.getInternalSetter(fieldName),
                         fieldName,
                         qualifiedFieldType,
@@ -1916,9 +1996,9 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
                         writer
                 );
 
-            } else if (Utils.isRealmList(field)) {
+            } else if (Utils.isRealmModelList(field)) {
                 RealmJsonTypeHelper.emitFillRealmListWithJsonValue(
-                        interfaceName,
+                        "objProxy",
                         metadata.getInternalGetter(fieldName),
                         metadata.getInternalSetter(fieldName),
                         fieldName,
@@ -1926,9 +2006,21 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
                         Utils.getProxyClassSimpleName(field),
                         writer);
 
+            } else if (Utils.isRealmValueList(field)) {
+                // FIXME need to implement logic for value list fields.
+                writer.emitSingleLineComment(String.format(Locale.ENGLISH,
+                        "TODO implement logic for value list %1$s.", field.getSimpleName()));
+            } else if (Utils.isMutableRealmInteger(field)) {
+                RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(
+                        "objProxy",
+                        metadata.getInternalGetter(fieldName),
+                        fieldName,
+                        qualifiedFieldType,
+                        writer);
+
             } else {
                 RealmJsonTypeHelper.emitFillJavaTypeWithJsonValue(
-                        interfaceName,
+                        "objProxy",
                         metadata.getInternalSetter(fieldName),
                         fieldName,
                         qualifiedFieldType,
@@ -1968,12 +2060,12 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
         if (metadata.hasPrimaryKey()) {
             writer.emitStatement("boolean jsonHasPrimaryKey = false");
         }
-        writer.emitStatement("%s obj = new %s()", qualifiedClassName, qualifiedClassName);
+        writer.emitStatement("final %s obj = new %s()", qualifiedClassName, qualifiedClassName);
+        writer.emitStatement("final %1$s objProxy = (%1$s) obj", interfaceName);
         writer.emitStatement("reader.beginObject()");
         writer.beginControlFlow("while (reader.hasNext())");
         writer.emitStatement("String name = reader.nextName()");
         writer.beginControlFlow("if (false)");
-
         Collection<VariableElement> fields = metadata.getFields();
         for (VariableElement field : fields) {
             String fieldName = field.getSimpleName().toString();
@@ -1982,7 +2074,7 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
 
             if (Utils.isRealmModel(field)) {
                 RealmJsonTypeHelper.emitFillRealmObjectFromStream(
-                        interfaceName,
+                        "objProxy",
                         metadata.getInternalSetter(fieldName),
                         fieldName,
                         qualifiedFieldType,
@@ -1990,19 +2082,32 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
                         writer
                 );
 
-            } else if (Utils.isRealmList(field)) {
+            } else if (Utils.isRealmModelList(field)) {
                 RealmJsonTypeHelper.emitFillRealmListFromStream(
-                        interfaceName,
+                        "objProxy",
                         metadata.getInternalGetter(fieldName),
                         metadata.getInternalSetter(fieldName),
                         ((DeclaredType) field.asType()).getTypeArguments().get(0).toString(),
                         Utils.getProxyClassSimpleName(field),
                         writer);
 
+            } else if (Utils.isRealmValueList(field)) {
+                // FIXME need to implement logic for value list fields.
+                writer.emitSingleLineComment("TODO implement logic for value list.");
+            } else if (Utils.isMutableRealmInteger(field)) {
+                RealmJsonTypeHelper.emitFillJavaTypeFromStream(
+                        "objProxy",
+                        metadata,
+                        metadata.getInternalGetter(fieldName),
+                        fieldName,
+                        qualifiedFieldType,
+                        writer
+                );
             } else {
                 RealmJsonTypeHelper.emitFillJavaTypeFromStream(
-                        interfaceName,
+                        "objProxy",
                         metadata,
+                        metadata.getInternalSetter(fieldName),
                         fieldName,
                         qualifiedFieldType,
                         writer
@@ -2023,16 +2128,11 @@ private void emitCreateUsingJsonStream(JavaWriter writer) throws IOException {
                     .endControlFlow();
         }
 
-        writer.emitStatement("obj = realm.copyToRealm(obj)");
-        writer.emitStatement("return obj");
+        writer.emitStatement("return realm.copyToRealm(obj)");
         writer.endMethod();
         writer.emitEmptyLine();
     }
 
-    private void emitMigrationNeededException(JavaWriter writer, String message, Object... args) throws IOException {
-        writer.emitStatement("throw new RealmMigrationNeededException(sharedRealm.getPath(), " + message, args);
-    }
-
     private String columnInfoClassName() {
         return simpleClassName + "ColumnInfo";
     }
@@ -2041,6 +2141,10 @@ private String columnIndexVarName(VariableElement variableElement) {
         return variableElement.getSimpleName().toString() + "Index";
     }
 
+    private String mutableRealmIntegerFieldName(VariableElement variableElement) {
+        return variableElement.getSimpleName().toString() + "MutableRealmInteger";
+    }
+
     private String fieldIndexVariableReference(VariableElement variableElement) {
         return "columnInfo." + columnIndexVarName(variableElement);
     }
@@ -2054,4 +2158,37 @@ private static int countModelOrListFields(Collection<VariableElement> fields) {
         }
         return count;
     }
+
+    private Constants.RealmFieldType getRealmType(VariableElement field) {
+        String fieldTypeCanonicalName = field.asType().toString();
+        Constants.RealmFieldType type = Constants.JAVA_TO_REALM_TYPES.get(fieldTypeCanonicalName);
+        if (type != null) {
+            return type;
+        }
+        if (Utils.isMutableRealmInteger(field)) {
+            return Constants.RealmFieldType.REALM_INTEGER;
+        }
+        if (Utils.isRealmModel(field)) {
+            return Constants.RealmFieldType.OBJECT;
+        }
+        if (Utils.isRealmModelList(field)) {
+            return Constants.RealmFieldType.LIST;
+        }
+        if (Utils.isRealmValueList(field)) {
+            final Constants.RealmFieldType fieldType = Utils.getValueListFieldType(field);
+            if (fieldType == null) {
+                return Constants.RealmFieldType.NOTYPE;
+            }
+            return fieldType;
+        }
+        return Constants.RealmFieldType.NOTYPE;
+    }
+
+    private Constants.RealmFieldType getRealmTypeChecked(VariableElement field) {
+        Constants.RealmFieldType type = getRealmType(field);
+        if (type == Constants.RealmFieldType.NOTYPE) {
+            throw new IllegalStateException("Unsupported type " + field.asType().toString());
+        }
+        return type;
+    }
 }
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java
index ed1785e904..ebe68a616c 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyInterfaceGenerator.java
@@ -20,6 +20,7 @@
 import java.io.BufferedWriter;
 import java.io.IOException;
 import java.util.EnumSet;
+import java.util.Locale;
 
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.Modifier;
@@ -42,7 +43,7 @@ public RealmProxyInterfaceGenerator(ProcessingEnvironment processingEnvironment,
 
     public void generate() throws IOException {
         String qualifiedGeneratedInterfaceName =
-                String.format("%s.%s", Constants.REALM_PACKAGE_NAME, Utils.getProxyInterfaceName(className));
+                String.format(Locale.US, "%s.%s", Constants.REALM_PACKAGE_NAME, Utils.getProxyInterfaceName(className));
         JavaFileObject sourceFile = processingEnvironment.getFiler().createSourceFile(qualifiedGeneratedInterfaceName);
         JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));
 
@@ -53,24 +54,29 @@ public void generate() throws IOException {
                 .emitEmptyLine()
                 .beginType(qualifiedGeneratedInterfaceName, "interface", EnumSet.of(Modifier.PUBLIC));
         for (VariableElement field : metaData.getFields()) {
-            // The field is neither static nor ignored
-            if (!field.getModifiers().contains(Modifier.STATIC) && field.getAnnotation(Ignore.class) == null) {
-                String fieldName = field.getSimpleName().toString();
-                String fieldTypeCanonicalName = field.asType().toString();
-                writer
-                        .beginMethod(
-                                fieldTypeCanonicalName,
-                                metaData.getInternalGetter(fieldName),
-                                EnumSet.of(Modifier.PUBLIC))
-                        .endMethod()
-                        .beginMethod(
-                                "void",
-                                metaData.getInternalSetter(fieldName),
-                                EnumSet.of(Modifier.PUBLIC),
-                                fieldTypeCanonicalName,
-                                "value")
-                        .endMethod();
+            if (field.getModifiers().contains(Modifier.STATIC) || (field.getAnnotation(Ignore.class) != null)) {
+                continue;
             }
+            // The field is neither static nor ignored
+            String fieldName = field.getSimpleName().toString();
+            String fieldTypeCanonicalName = field.asType().toString();
+            writer
+                    .beginMethod(
+                            fieldTypeCanonicalName,
+                            metaData.getInternalGetter(fieldName),
+                            EnumSet.of(Modifier.PUBLIC))
+                    .endMethod();
+
+            // MutableRealmIntegers do not have setters.
+            if (Utils.isMutableRealmInteger(field)) { continue; }
+            writer
+                    .beginMethod(
+                            "void",
+                            metaData.getInternalSetter(fieldName),
+                            EnumSet.of(Modifier.PUBLIC),
+                            fieldTypeCanonicalName,
+                            "value")
+                    .endMethod();
         }
 
         // backlinks are final and have only a getter.
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
index 65f4e7a843..4e1a89aba5 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyMediatorGenerator.java
@@ -25,6 +25,7 @@
 import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
+import java.util.Locale;
 import java.util.Set;
 
 import javax.annotation.processing.ProcessingEnvironment;
@@ -55,7 +56,7 @@ public RealmProxyMediatorGenerator(ProcessingEnvironment processingEnvironment,
     }
 
     public void generate() throws IOException {
-        String qualifiedGeneratedClassName = String.format("%s.%sMediator", REALM_PACKAGE_NAME, className);
+        String qualifiedGeneratedClassName = String.format(Locale.US, "%s.%sMediator", REALM_PACKAGE_NAME, className);
         JavaFileObject sourceFile = processingEnvironment.getFiler().createSourceFile(qualifiedGeneratedClassName);
         JavaWriter writer = new JavaWriter(new BufferedWriter(sourceFile.openWriter()));
         writer.setIndent("    ");
@@ -79,8 +80,8 @@ public void generate() throws IOException {
                 "io.realm.internal.RealmObjectProxy",
                 "io.realm.internal.RealmProxyMediator",
                 "io.realm.internal.Row",
-                "io.realm.internal.Table",
-                "io.realm.RealmObjectSchema",
+                "io.realm.internal.OsSchemaInfo",
+                "io.realm.internal.OsObjectSchemaInfo",
                 "org.json.JSONException",
                 "org.json.JSONObject"
         );
@@ -96,10 +97,10 @@ public void generate() throws IOException {
         writer.emitEmptyLine();
 
         emitFields(writer);
-        emitCreateRealmObjectSchema(writer);
-        emitValidateTableMethod(writer);
+        emitGetExpectedObjectSchemaInfoMap(writer);
+        emitCreateColumnInfoMethod(writer);
         emitGetFieldNamesMethod(writer);
-        emitGetTableNameMethod(writer);
+        emitGetSimpleClassNameMethod(writer);
         emitNewInstanceMethod(writer);
         emitGetClassModelList(writer);
         emitCopyToRealmMethod(writer);
@@ -117,7 +118,7 @@ public void generate() throws IOException {
     private void emitFields(JavaWriter writer) throws IOException {
         writer.emitField("Set<Class<? extends RealmModel>>", "MODEL_CLASSES", EnumSet.of(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL));
         writer.beginInitializer(true);
-        writer.emitStatement("Set<Class<? extends RealmModel>> modelClasses = new HashSet<Class<? extends RealmModel>>()");
+        writer.emitStatement("Set<Class<? extends RealmModel>> modelClasses = new HashSet<Class<? extends RealmModel>>(%s)", qualifiedModelClasses.size());
         for (String clazz : qualifiedModelClasses) {
             writer.emitStatement("modelClasses.add(%s.class)", clazz);
         }
@@ -126,38 +127,40 @@ private void emitFields(JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
-    private void emitCreateRealmObjectSchema(JavaWriter writer) throws IOException {
+    private void emitGetExpectedObjectSchemaInfoMap(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod(
-                "RealmObjectSchema",
-                "createRealmObjectSchema",
-                EnumSet.of(Modifier.PUBLIC),
-                "Class<? extends RealmModel>", "clazz", "RealmSchema", "realmSchema"
-        );
-        emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
-            @Override
-            public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return %s.createRealmObjectSchema(realmSchema)", qualifiedProxyClasses.get(i));
-            }
-        }, writer);
+                "Map<Class<? extends RealmModel>, OsObjectSchemaInfo>",
+                "getExpectedObjectSchemaInfoMap",
+                EnumSet.of(Modifier.PUBLIC));
+
+        writer.emitStatement(
+                "Map<Class<? extends RealmModel>, OsObjectSchemaInfo> infoMap = " +
+                        "new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>(%s)", qualifiedProxyClasses.size());
+        for (int i = 0; i < qualifiedProxyClasses.size(); i++) {
+            writer.emitStatement("infoMap.put(%s.class, %s.getExpectedObjectSchemaInfo())",
+                    qualifiedModelClasses.get(i), qualifiedProxyClasses.get(i));
+        }
+        writer.emitStatement("return infoMap");
+
         writer.endMethod();
         writer.emitEmptyLine();
     }
 
-    private void emitValidateTableMethod(JavaWriter writer) throws IOException {
+    private void emitCreateColumnInfoMethod(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod(
                 "ColumnInfo",
-                "validateTable",
+                "createColumnInfo",
                 EnumSet.of(Modifier.PUBLIC),
                 "Class<? extends RealmModel>", "clazz", // Argument type & argument name
-                "SharedRealm", "sharedRealm",
-                "boolean", "allowExtraColumns"
+                "OsSchemaInfo", "schemaInfo"
         );
+
         emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return %s.validateTable(sharedRealm, allowExtraColumns)",
+                writer.emitStatement("return %s.createColumnInfo(schemaInfo)",
                         qualifiedProxyClasses.get(i));
             }
         }, writer);
@@ -183,18 +186,18 @@ public void emitStatement(int i, JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
-    private void emitGetTableNameMethod(JavaWriter writer) throws IOException {
+    private void emitGetSimpleClassNameMethod(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod(
                 "String",
-                "getTableName",
+                "getSimpleClassNameImpl",
                 EnumSet.of(Modifier.PUBLIC),
                 "Class<? extends RealmModel>", "clazz"
         );
         emitMediatorShortCircuitSwitch(new ProxySwitchStatement() {
             @Override
             public void emitStatement(int i, JavaWriter writer) throws IOException {
-                writer.emitStatement("return %s.getTableName()", qualifiedProxyClasses.get(i));
+                writer.emitStatement("return %s.getSimpleClassName()", qualifiedProxyClasses.get(i));
             }
         }, writer);
         writer.endMethod();
@@ -448,10 +451,6 @@ public void emitStatement(int i, JavaWriter writer) throws IOException {
     // Emits the control flow for selecting the appropriate proxy class based on the model class
     // Currently it is just if..else, which is inefficient for large amounts amounts of model classes.
     // Consider switching to HashMap or similar.
-    private void emitMediatorSwitch(ProxySwitchStatement statement, JavaWriter writer) throws IOException {
-        emitMediatorSwitch(statement, writer, true);
-    }
-
     private void emitMediatorSwitch(ProxySwitchStatement statement, JavaWriter writer, boolean nullPointerCheck)
             throws IOException {
         if (nullPointerCheck) {
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/TypeMirrors.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/TypeMirrors.java
new file mode 100644
index 0000000000..8757727a14
--- /dev/null
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/TypeMirrors.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor;
+
+import java.util.Date;
+
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+
+/**
+ * This class provides {@link TypeMirror} instances used in annotation processor.
+ */
+class TypeMirrors {
+    final TypeMirror STRING_MIRROR;
+    final TypeMirror BINARY_MIRROR;
+    final TypeMirror BOOLEAN_MIRROR;
+    final TypeMirror LONG_MIRROR;
+    final TypeMirror INTEGER_MIRROR;
+    final TypeMirror SHORT_MIRROR;
+    final TypeMirror BYTE_MIRROR;
+    final TypeMirror DOUBLE_MIRROR;
+    final TypeMirror FLOAT_MIRROR;
+    final TypeMirror DATE_MIRROR;
+
+    final TypeMirror PRIMITIVE_LONG_MIRROR;
+    final TypeMirror PRIMITIVE_INT_MIRROR;
+    final TypeMirror PRIMITIVE_SHORT_MIRROR;
+    final TypeMirror PRIMITIVE_BYTE_MIRROR;
+
+    TypeMirrors(ProcessingEnvironment env) {
+        final Types typeUtils = env.getTypeUtils();
+        final Elements elementUtils = env.getElementUtils();
+
+        STRING_MIRROR = elementUtils.getTypeElement("java.lang.String").asType();
+        BINARY_MIRROR = typeUtils.getArrayType(typeUtils.getPrimitiveType(TypeKind.BYTE));
+        BOOLEAN_MIRROR = elementUtils.getTypeElement(Boolean.class.getName()).asType();
+        LONG_MIRROR = elementUtils.getTypeElement(Long.class.getName()).asType();
+        INTEGER_MIRROR = elementUtils.getTypeElement(Integer.class.getName()).asType();
+        SHORT_MIRROR = elementUtils.getTypeElement(Short.class.getName()).asType();
+        BYTE_MIRROR = elementUtils.getTypeElement(Byte.class.getName()).asType();
+        DOUBLE_MIRROR = elementUtils.getTypeElement(Double.class.getName()).asType();
+        FLOAT_MIRROR = elementUtils.getTypeElement(Float.class.getName()).asType();
+        DATE_MIRROR = elementUtils.getTypeElement(Date.class.getName()).asType();
+
+        PRIMITIVE_LONG_MIRROR = typeUtils.getPrimitiveType(TypeKind.LONG);
+        PRIMITIVE_INT_MIRROR = typeUtils.getPrimitiveType(TypeKind.INT);
+        PRIMITIVE_SHORT_MIRROR = typeUtils.getPrimitiveType(TypeKind.SHORT);
+        PRIMITIVE_BYTE_MIRROR = typeUtils.getPrimitiveType(TypeKind.BYTE);
+    }
+
+    /**
+     * @return the {@link TypeMirror} of the elements in {@code RealmList}.
+     */
+    public static TypeMirror getRealmListElementTypeMirror(VariableElement field) {
+        if (!Utils.isRealmList(field)) {
+            return null;
+        }
+        return ((DeclaredType) field.asType()).getTypeArguments().get(0);
+    }
+}
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
index 4b157b4404..24d20531cd 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/Utils.java
@@ -12,6 +12,7 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
@@ -23,20 +24,23 @@
 
     public static Types typeUtils;
     private static Messager messager;
+    private static TypeMirror realmInteger;
     private static DeclaredType realmList;
     private static DeclaredType realmResults;
     private static DeclaredType markerInterface;
     private static TypeMirror realmModel;
 
     public static void initialize(ProcessingEnvironment env) {
+        Elements elementUtils = env.getElementUtils();
         typeUtils = env.getTypeUtils();
         messager = env.getMessager();
-        realmList = typeUtils.getDeclaredType(env.getElementUtils().getTypeElement("io.realm.RealmList"),
-                typeUtils.getWildcardType(null, null));
-        realmResults = typeUtils.getDeclaredType(env.getElementUtils().getTypeElement("io.realm.RealmResults"),
-                typeUtils.getWildcardType(null, null));
-        realmModel = env.getElementUtils().getTypeElement("io.realm.RealmModel").asType();
-        markerInterface = env.getTypeUtils().getDeclaredType(env.getElementUtils().getTypeElement("io.realm.RealmModel"));
+        realmInteger = elementUtils.getTypeElement("io.realm.MutableRealmInteger").asType();
+        realmList = typeUtils.getDeclaredType(
+                elementUtils.getTypeElement("io.realm.RealmList"), typeUtils.getWildcardType(null, null));
+        realmResults = typeUtils.getDeclaredType(
+                env.getElementUtils().getTypeElement("io.realm.RealmResults"), typeUtils.getWildcardType(null, null));
+        realmModel = elementUtils.getTypeElement("io.realm.RealmModel").asType();
+        markerInterface = typeUtils.getDeclaredType(elementUtils.getTypeElement("io.realm.RealmModel"));
     }
 
     /**
@@ -146,6 +150,13 @@ public static boolean isImplementingMarkerInterface(Element classElement) {
         return typeUtils.isAssignable(classElement.asType(), markerInterface);
     }
 
+    /**
+     * @return {@code true} if a given field type is {@code MutableRealmInteger}, {@code false} otherwise.
+     */
+    public static boolean isMutableRealmInteger(VariableElement field) {
+        return typeUtils.isAssignable(field.asType(), realmInteger);
+    }
+
     /**
      * @return {@code true} if a given field type is {@code RealmList}, {@code false} otherwise.
      */
@@ -153,11 +164,51 @@ public static boolean isRealmList(VariableElement field) {
         return typeUtils.isAssignable(field.asType(), realmList);
     }
 
+    /**
+     * @param field {@link VariableElement} of a value list field.
+     * @return element type of the list field.
+     */
+    public static Constants.RealmFieldType getValueListFieldType(VariableElement field) {
+        final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
+        return Constants.LIST_ELEMENT_TYPE_TO_REALM_TYPES.get(elementTypeMirror.toString());
+    }
+
+    /**
+     * @return {@code true} if a given field type is {@code RealmList} and its element type is {@Code RealmObject},
+     * {@code false} otherwise.
+     */
+    public static boolean isRealmModelList(VariableElement field) {
+        final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
+        if (elementTypeMirror == null) {
+            return false;
+        }
+        return isRealmModel(elementTypeMirror);
+    }
+
+    /**
+     * @return {@code true} if a given field type is {@code RealmList} and its element type is value type,
+     * {@code false} otherwise.
+     */
+    public static boolean isRealmValueList(VariableElement field) {
+        final TypeMirror elementTypeMirror = TypeMirrors.getRealmListElementTypeMirror(field);
+        if (elementTypeMirror == null) {
+            return false;
+        }
+        return !isRealmModel(elementTypeMirror);
+    }
+
     /**
      * @return {@code true} if a given field type is {@code RealmModel}, {@code false} otherwise.
      */
-    public static boolean isRealmModel(VariableElement field) {
-        return typeUtils.isAssignable(field.asType(), realmModel);
+    public static boolean isRealmModel(Element field) {
+        return isRealmModel(field.asType());
+    }
+
+    /**
+     * @return {@code true} if a given type is {@code RealmModel}, {@code false} otherwise.
+     */
+    public static boolean isRealmModel(TypeMirror type) {
+        return typeUtils.isAssignable(type, realmModel);
     }
 
     public static boolean isRealmResults(VariableElement field) {
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmBacklinkProcessorTest.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmBacklinkProcessorTest.java
new file mode 100644
index 0000000000..76a8f61ffd
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmBacklinkProcessorTest.java
@@ -0,0 +1,215 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.processor;
+
+import com.google.testing.compile.JavaFileObjects;
+
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.Arrays;
+
+import javax.lang.model.element.Modifier;
+import javax.tools.JavaFileObject;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static org.truth0.Truth.ASSERT;
+
+
+public class RealmBacklinkProcessorTest {
+    private final JavaFileObject backlinks = JavaFileObjects.forResource("some/test/Backlinks.java");
+    private final JavaFileObject backlinksTarget = JavaFileObjects.forResource("some/test/BacklinkTarget.java");
+    private final JavaFileObject invalidResultsValueType = JavaFileObjects.forResource("some/test/InvalidResultsElementType.java");
+
+    @Test
+    public void compileBacklinks() {
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(backlinks, backlinksTarget))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileSyntheticBacklinks() throws IOException {
+        RealmSyntheticTestClass javaFileObject = createBacklinkTestClass()
+                .builder().build();
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(backlinksTarget, javaFileObject))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void failOnLinkingObjectsWithInvalidFieldType() throws IOException {
+        RealmSyntheticTestClass javaFileObject = createBacklinkTestClass()
+                // Backlinks must be RealmResults
+                .type("BacklinkTarget")
+                .builder().build();
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(backlinksTarget, javaFileObject))
+                .processedWith(new RealmProcessor())
+                .failsToCompile()
+                .withErrorContaining("Fields annotated with @LinkingObjects must be RealmResults");
+    }
+
+    @Test
+    public void failOnLinkingObjectsWithNonFinalField() throws IOException {
+        RealmSyntheticTestClass javaFileObject = createBacklinkTestClass()
+                // A field with a @LinkingObjects annotation must be final
+                .modifiers(Modifier.PUBLIC)
+                .builder().build();
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(backlinksTarget, javaFileObject))
+                .processedWith(new RealmProcessor())
+                .failsToCompile()
+                .withErrorContaining("must be final");
+    }
+
+    @Test
+    public void failsOnLinkingObjectsWithLinkedFields() throws IOException {
+        RealmSyntheticTestClass javaFileObject = createBacklinkTestClass()
+                // Defining a backlink more than one levels back is not supported.
+                // It can be queried though: `equalTo("selectedFieldParents.selectedFieldParents")
+                .clearAnnotations()
+                .annotation("LinkingObjects(\"child.id\")")
+                .builder().build();
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(backlinksTarget, javaFileObject))
+                .processedWith(new RealmProcessor())
+                .failsToCompile()
+                .withErrorContaining("The use of '.' to specify fields in referenced classes is not supported");
+    }
+
+    @Test
+    public void failsOnLinkingObjectsMissingFieldName() throws IOException {
+        RealmSyntheticTestClass javaFileObject = createBacklinkTestClass()
+                // No backlinked field specified
+                .clearAnnotations()
+                .annotation("LinkingObjects")
+                .builder().build();
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(backlinksTarget, javaFileObject))
+                .processedWith(new RealmProcessor())
+                .failsToCompile()
+                .withErrorContaining("must have a parameter identifying the link target");
+    }
+
+    @Test
+    public void failsOnLinkingObjectsMissingGeneric() throws IOException {
+        RealmSyntheticTestClass javaFileObject = createBacklinkTestClass()
+                // No backlink generic param specified
+                .type("RealmResults")
+                .builder().build();
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(backlinksTarget, javaFileObject))
+                .processedWith(new RealmProcessor())
+                .failsToCompile()
+                .withErrorContaining("must specify a generic type");
+    }
+
+    @Test
+    public void failsOnLinkingObjectsWithRequiredFields() throws IOException {
+        RealmSyntheticTestClass javaFileObject = createBacklinkTestClass()
+                // A backlinked field may not be @Required
+                .annotation("Required")
+                .builder().build();
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(backlinksTarget, javaFileObject))
+                .processedWith(new RealmProcessor())
+                .failsToCompile()
+                .withErrorContaining("cannot be @Required");
+    }
+
+    @Test
+    public void failsOnLinkingObjectsWithIgnoreFields() throws IOException {
+        RealmSyntheticTestClass javaFileObject = createBacklinkTestClass()
+                // An  @Ignored, backlinked field is completely ignored
+                .annotation("Ignore")
+                .builder().build();
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(backlinksTarget, javaFileObject))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    // TODO: This seems like a "gottcha".  We should warn.
+    @Test
+    public void ignoreStaticLinkingObjects() throws IOException {
+        RealmSyntheticTestClass javaFileObject = createBacklinkTestClass()
+                .modifiers(Modifier.PUBLIC, Modifier.STATIC)
+                .type("RealmResults")
+                .clearAnnotations()
+                .annotation("LinkingObjects(\"xxx\")")
+                .builder().build();
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(backlinksTarget, javaFileObject))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void failsOnLinkingObjectsFieldNotFound() throws IOException {
+        RealmSyntheticTestClass javaFileObject = createBacklinkTestClass()
+                // The argument to the @LinkingObjects annotation must name a field in the target class
+                .clearAnnotations()
+                .annotation("LinkingObjects(\"xxx\")")
+                .builder().build();
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(backlinksTarget, javaFileObject))
+                .processedWith(new RealmProcessor())
+                .failsToCompile()
+                .withErrorContaining("does not exist in class");
+    }
+
+    @Test
+    public void failsOnLinkingObjectsWithFieldWrongType() throws IOException {
+        RealmSyntheticTestClass javaFileObject = createBacklinkTestClass()
+                // The type of the field named in the @LinkingObjects annotation must match
+                // the generic type of the annotated field.  BacklinkTarget.child is a Backlink,
+                // not a Backlinks_WrongType.
+                .builder().name("Backlinks_WrongType").build();
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(backlinksTarget, javaFileObject))
+                .processedWith(new RealmProcessor())
+                .failsToCompile()
+                .withErrorContaining("instead of");
+    }
+
+    // This method constructs a synthetic Backlink class that *should* compile correctly.
+    // It returns the ref to the backlinked Field.  Tests can modify the
+    // field in perverse ways, to verify failure modes.
+    private RealmSyntheticTestClass.Field createBacklinkTestClass() {
+        return new RealmSyntheticTestClass.Builder().name("Backlinks")
+                .field().name("id").type("int").builder()
+                .field()
+                    .name("parents")
+                    .type("RealmResults<BacklinkTarget>")
+                    .modifiers(Modifier.PUBLIC, Modifier.FINAL)
+                    .annotation("LinkingObjects(\"child\")")
+                    .initializer("null")
+                    .hasGetter(false)
+                    .hasSetter(false);
+    }
+
+    @Test
+    public void failToCompileInvalidResultsElementType() {
+        ASSERT.about(javaSource())
+                .that(invalidResultsValueType)
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+}
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmCounterProcessorTest.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmCounterProcessorTest.java
new file mode 100644
index 0000000000..90dba9f50f
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmCounterProcessorTest.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright 2014-2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor;
+
+import com.google.testing.compile.JavaFileObjects;
+
+import org.junit.Ignore;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.Arrays;
+
+import javax.lang.model.element.Modifier;
+import javax.tools.JavaFileObject;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static org.truth0.Truth.ASSERT;
+
+
+public class RealmCounterProcessorTest {
+
+    @Test
+    public void compileMutableRealmInteger() throws IOException {
+        RealmSyntheticTestClass javaFileObject = createCounterTestClass()
+                .builder().build();
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(javaFileObject))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileIgnoredMutableRealmInteger() throws IOException {
+        RealmSyntheticTestClass javaFileObject = createCounterTestClass()
+                .annotation("Ignore")
+                .builder().build();
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(javaFileObject))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileIndexedMutableRealmInteger() throws IOException {
+        RealmSyntheticTestClass javaFileObject = createCounterTestClass()
+                .annotation("Index")
+                .builder().build();
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(javaFileObject))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileRequiredMutableRealmInteger() throws IOException {
+        RealmSyntheticTestClass javaFileObject = createCounterTestClass()
+                .annotation("Required")
+                .builder().build();
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(javaFileObject))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void compileStaticMutableRealmInteger() throws IOException {
+        RealmSyntheticTestClass javaFileObject = createCounterTestClass()
+                .modifiers(Modifier.PRIVATE, Modifier.FINAL, Modifier.STATIC)
+                .builder().build();
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(javaFileObject))
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void failOnPKMutableRealmInteger() throws IOException {
+        RealmSyntheticTestClass javaFileObject = createCounterTestClass()
+                .annotation("PrimaryKey")
+                .builder().build();
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(javaFileObject))
+                .processedWith(new RealmProcessor())
+                .failsToCompile()
+                .withErrorContaining("cannot be used as primary key");
+    }
+
+    @Test
+    public void failUnlessFinalMutableRealmInteger() throws IOException {
+        RealmSyntheticTestClass javaFileObject = createCounterTestClass()
+                .modifiers(Modifier.PRIVATE)
+                .builder().build();
+        ASSERT.about(javaSources())
+                .that(Arrays.asList(javaFileObject))
+                .processedWith(new RealmProcessor())
+                .failsToCompile()
+                .withErrorContaining("must be final");
+    }
+
+    // This method constructs a synthetic Counter test class that *should* compile correctly.
+    // It returns the ref to the Counter Field.  Tests can modify the
+    // field in perverse ways, to verify failure modes.
+    private RealmSyntheticTestClass.Field createCounterTestClass() {
+        return new RealmSyntheticTestClass.Builder().name("Counter")
+                .field().name("id").type("int").builder()
+                .field()
+                .name("columnMutableRealmInteger")
+                .type("MutableRealmInteger")
+                .modifiers(Modifier.PRIVATE, Modifier.FINAL)
+                .initializer("MutableRealmInteger.valueOf(0)")
+                .hasSetter(false);
+    }
+}
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
index b888290450..9907db2b3c 100644
--- a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmProcessorTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2016 Realm Inc.
+ * Copyright 2014-2017 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,6 +18,7 @@
 
 import com.google.testing.compile.JavaFileObjects;
 
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.IOException;
@@ -29,44 +30,34 @@
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static org.truth0.Truth.ASSERT;
 
-public class RealmProcessorTest {
 
-    private JavaFileObject simpleModel = JavaFileObjects.forResource("some/test/Simple.java");
-    private JavaFileObject simpleProxy = JavaFileObjects.forResource("io/realm/SimpleRealmProxy.java");
-    private JavaFileObject allTypesModel = JavaFileObjects.forResource("some/test/AllTypes.java");
-    private JavaFileObject allTypesProxy = JavaFileObjects.forResource("io/realm/AllTypesRealmProxy.java");
-    private JavaFileObject allTypesDefaultModule = JavaFileObjects.forResource("io/realm/RealmDefaultModule.java");
-    private JavaFileObject allTypesDefaultMediator = JavaFileObjects.forResource("io/realm/RealmDefaultModuleMediator.java");
-    private JavaFileObject booleansModel = JavaFileObjects.forResource("some/test/Booleans.java");
-    private JavaFileObject booleansProxy = JavaFileObjects.forResource("io/realm/BooleansRealmProxy.java");
-    private JavaFileObject emptyModel = JavaFileObjects.forResource("some/test/Empty.java");
-    private JavaFileObject finalModel = JavaFileObjects.forResource("some/test/Final.java");
-    private JavaFileObject transientModel = JavaFileObjects.forResource("some/test/Transient.java");
-    private JavaFileObject volatileModel = JavaFileObjects.forResource("some/test/Volatile.java");
-    private JavaFileObject fieldNamesModel = JavaFileObjects.forResource("some/test/FieldNames.java");
-    private JavaFileObject customAccessorModel = JavaFileObjects.forResource("some/test/CustomAccessor.java");
-    private JavaFileObject nullTypesModel = JavaFileObjects.forResource("some/test/NullTypes.java");
-    private JavaFileObject nullTypesProxy = JavaFileObjects.forResource("io/realm/NullTypesRealmProxy.java");
-    private JavaFileObject missingGenericTypeModel = JavaFileObjects.forResource("some/test/MissingGenericType.java");
-    private JavaFileObject conflictingFieldNameModel = JavaFileObjects.forResource("some/test/ConflictingFieldName.java");
-    private JavaFileObject invalidRealmModelModel_1 = JavaFileObjects.forResource("some/test/InvalidModelRealmModel_1.java");
-    private JavaFileObject invalidRealmModelModel_2 = JavaFileObjects.forResource("some/test/InvalidModelRealmModel_2.java");
-    private JavaFileObject invalidRealmModelModel_3 = JavaFileObjects.forResource("some/test/InvalidModelRealmModel_3.java");
-    private JavaFileObject ValidModelPojo_ExtendingRealmObject = JavaFileObjects.forResource("some/test/ValidModelRealmModel_ExtendingRealmObject.java");
-    private JavaFileObject UseExtendRealmList = JavaFileObjects.forResource("some/test/UseExtendRealmList.java");
-    private JavaFileObject SimpleRealmModel = JavaFileObjects.forResource("some/test/SimpleRealmModel.java");
-    private JavaFileObject customInterface = JavaFileObjects.forResource("some/test/CustomInterface.java");
-    private JavaFileObject backlinks = JavaFileObjects.forResource("some/test/Backlinks.java");
-    private JavaFileObject backlinksTarget = JavaFileObjects.forResource("some/test/BacklinkTarget.java");
-    private JavaFileObject backlinksInvalidField = JavaFileObjects.forResource("some/test/Backlinks_InvalidFieldType.java");
-    private JavaFileObject backlinksLinked = JavaFileObjects.forResource("some/test/Backlinks_LinkedFields.java");
-    private JavaFileObject backlinksMissingParam = JavaFileObjects.forResource("some/test/Backlinks_MissingParameter.java");
-    private JavaFileObject backlinksMissingGeneric = JavaFileObjects.forResource("some/test/Backlinks_MissingGeneric.java");
-    private JavaFileObject backlinksRequired = JavaFileObjects.forResource("some/test/Backlinks_Required.java");
-    private JavaFileObject backlinksIgnored = JavaFileObjects.forResource("some/test/Backlinks_Ignored.java");
-    private JavaFileObject backlinksNotFound = JavaFileObjects.forResource("some/test/Backlinks_NotFound.java");
-    private JavaFileObject backlinksNonFinalField = JavaFileObjects.forResource("some/test/Backlinks_NotFinal.java");
-    private JavaFileObject backlinksWrongType = JavaFileObjects.forResource("some/test/Backlinks_WrongType.java");
+public class RealmProcessorTest {
+    private final JavaFileObject simpleModel = JavaFileObjects.forResource("some/test/Simple.java");
+    private final JavaFileObject simpleProxy = JavaFileObjects.forResource("io/realm/SimpleRealmProxy.java");
+    private final JavaFileObject allTypesModel = JavaFileObjects.forResource("some/test/AllTypes.java");
+    private final JavaFileObject allTypesProxy = JavaFileObjects.forResource("io/realm/AllTypesRealmProxy.java");
+    private final JavaFileObject allTypesDefaultModule = JavaFileObjects.forResource("io/realm/RealmDefaultModule.java");
+    private final JavaFileObject allTypesDefaultMediator = JavaFileObjects.forResource("io/realm/RealmDefaultModuleMediator.java");
+    private final JavaFileObject booleansModel = JavaFileObjects.forResource("some/test/Booleans.java");
+    private final JavaFileObject booleansProxy = JavaFileObjects.forResource("io/realm/BooleansRealmProxy.java");
+    private final JavaFileObject emptyModel = JavaFileObjects.forResource("some/test/Empty.java");
+    private final JavaFileObject finalModel = JavaFileObjects.forResource("some/test/Final.java");
+    private final JavaFileObject transientModel = JavaFileObjects.forResource("some/test/Transient.java");
+    private final JavaFileObject volatileModel = JavaFileObjects.forResource("some/test/Volatile.java");
+    private final JavaFileObject fieldNamesModel = JavaFileObjects.forResource("some/test/FieldNames.java");
+    private final JavaFileObject customAccessorModel = JavaFileObjects.forResource("some/test/CustomAccessor.java");
+    private final JavaFileObject nullTypesModel = JavaFileObjects.forResource("some/test/NullTypes.java");
+    private final JavaFileObject nullTypesProxy = JavaFileObjects.forResource("io/realm/NullTypesRealmProxy.java");
+    private final JavaFileObject missingGenericTypeModel = JavaFileObjects.forResource("some/test/MissingGenericType.java");
+    private final JavaFileObject conflictingFieldNameModel = JavaFileObjects.forResource("some/test/ConflictingFieldName.java");
+    private final JavaFileObject invalidRealmModelModel_1 = JavaFileObjects.forResource("some/test/InvalidModelRealmModel_1.java");
+    private final JavaFileObject invalidRealmModelModel_2 = JavaFileObjects.forResource("some/test/InvalidModelRealmModel_2.java");
+    private final JavaFileObject invalidRealmModelModel_3 = JavaFileObjects.forResource("some/test/InvalidModelRealmModel_3.java");
+    private final JavaFileObject ValidModelPojo_ExtendingRealmObject = JavaFileObjects.forResource("some/test/ValidModelRealmModel_ExtendingRealmObject.java");
+    private final JavaFileObject UseExtendRealmList = JavaFileObjects.forResource("some/test/UseExtendRealmList.java");
+    private final JavaFileObject SimpleRealmModel = JavaFileObjects.forResource("some/test/SimpleRealmModel.java");
+    private final JavaFileObject customInterface = JavaFileObjects.forResource("some/test/CustomInterface.java");
+    private final JavaFileObject nonLatinName = JavaFileObjects.forResource("some/test/ÁrvíztűrőTükörfúrógép.java");
 
     @Test
     public void compileSimpleFile() {
@@ -76,7 +67,7 @@ public void compileSimpleFile() {
     }
 
     @Test
-    public void compileProcessedSimpleFile() throws Exception {
+    public void compileProcessedSimpleFile() {
         ASSERT.about(javaSource())
                 .that(simpleModel)
                 .processedWith(new RealmProcessor())
@@ -84,22 +75,23 @@ public void compileProcessedSimpleFile() throws Exception {
     }
 
     @Test
-    public void compileProcessedEmptyFile() throws Exception {
+    public void compileProcessedEmptyFile() {
         ASSERT.about(javaSource())
                 .that(emptyModel)
                 .processedWith(new RealmProcessor())
                 .failsToCompile();
     }
 
-    // Disabled because it does not seem to find the generated interface file @Test
-    public void compileSimpleProxyFile() throws Exception {
+    @Ignore("Disabled because it does not seem to find the generated interface file")
+    @Test
+    public void compileSimpleProxyFile() {
         ASSERT.about(javaSource())
                 .that(simpleProxy)
                 .compilesWithoutError();
     }
 
     @Test
-    public void compareProcessedSimpleFile() throws Exception {
+    public void compareProcessedSimpleFile() {
         ASSERT.about(javaSource())
                 .that(simpleModel)
                 .processedWith(new RealmProcessor())
@@ -109,7 +101,7 @@ public void compareProcessedSimpleFile() throws Exception {
     }
 
     @Test
-    public void compileProcessedNullTypesFile() throws Exception {
+    public void compileProcessedNullTypesFile() {
         ASSERT.about(javaSource())
                 .that(nullTypesModel)
                 .processedWith(new RealmProcessor())
@@ -117,7 +109,7 @@ public void compileProcessedNullTypesFile() throws Exception {
     }
 
     @Test
-    public void compareProcessedNullTypesFile() throws Exception {
+    public void compareProcessedNullTypesFile() {
         ASSERT.about(javaSource())
                 .that(nullTypesModel)
                 .processedWith(new RealmProcessor())
@@ -134,7 +126,7 @@ public void compileAllTypesFile() {
     }
 
     @Test
-    public void compileProcessedAllTypesFile() throws Exception {
+    public void compileProcessedAllTypesFile() {
         ASSERT.about(javaSource())
                 .that(allTypesModel)
                 .processedWith(new RealmProcessor())
@@ -142,14 +134,14 @@ public void compileProcessedAllTypesFile() throws Exception {
     }
 
     @Test
-    public void compileAllTypesProxyFile() throws Exception {
+    public void compileAllTypesProxyFile() {
         ASSERT.about(javaSource())
                 .that(allTypesModel)
                 .compilesWithoutError();
     }
 
     @Test
-    public void compareProcessedAllTypesFile() throws Exception {
+    public void compareProcessedAllTypesFile() {
         ASSERT.about(javaSource())
                 .that(allTypesModel)
                 .processedWith(new RealmProcessor())
@@ -160,7 +152,7 @@ public void compareProcessedAllTypesFile() throws Exception {
     }
 
     @Test
-    public void compileAppModuleCustomClasses() throws Exception {
+    public void compileAppModuleCustomClasses() {
         ASSERT.about(javaSources())
                 .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/AppModuleCustomClasses.java")))
                 .processedWith(new RealmProcessor())
@@ -168,7 +160,7 @@ public void compileAppModuleCustomClasses() throws Exception {
     }
 
     @Test
-    public void compileAppModuleAllClasses() throws Exception {
+    public void compileAppModuleAllClasses() {
         ASSERT.about(javaSources())
                 .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/AppModuleAllClasses.java")))
                 .processedWith(new RealmProcessor())
@@ -176,7 +168,7 @@ public void compileAppModuleAllClasses() throws Exception {
     }
 
     @Test
-    public void compileLibraryModulesAllClasses() throws Exception {
+    public void compileLibraryModulesAllClasses() {
         ASSERT.about(javaSources())
                 .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/LibraryModuleAllClasses.java")))
                 .processedWith(new RealmProcessor())
@@ -184,7 +176,7 @@ public void compileLibraryModulesAllClasses() throws Exception {
     }
 
     @Test
-    public void compileLibraryModulesCustomClasses() throws Exception {
+    public void compileLibraryModulesCustomClasses() {
         ASSERT.about(javaSources())
                 .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/LibraryModuleCustomClasses.java")))
                 .processedWith(new RealmProcessor())
@@ -192,25 +184,25 @@ public void compileLibraryModulesCustomClasses() throws Exception {
     }
 
     @Test
-    public void compileAppModuleMixedParametersFail() throws Exception {
+    public void compileAppModuleMixedParametersFail() {
         ASSERT.about(javaSources())
                 .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource(
-                    "some/test/InvalidAllTypesModuleMixedParameters.java")))
+                        "some/test/InvalidAllTypesModuleMixedParameters.java")))
                 .processedWith(new RealmProcessor())
                 .failsToCompile();
     }
 
     @Test
-    public void compileAppModuleWrongTypeFail() throws Exception {
+    public void compileAppModuleWrongTypeFail() {
         ASSERT.about(javaSources())
                 .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource(
-                    "some/test/InvalidAllTypesModuleWrongType.java")))
+                        "some/test/InvalidAllTypesModuleWrongType.java")))
                 .processedWith(new RealmProcessor())
                 .failsToCompile();
     }
 
     @Test
-    public void compileLibraryModuleMixedParametersFail() throws Exception {
+    public void compileLibraryModuleMixedParametersFail() {
         ASSERT.about(javaSources())
                 .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/InvalidLibraryModuleMixedParameters.java")))
                 .processedWith(new RealmProcessor())
@@ -218,7 +210,7 @@ public void compileLibraryModuleMixedParametersFail() throws Exception {
     }
 
     @Test
-    public void compileLibraryModuleWrongTypeFail() throws Exception {
+    public void compileLibraryModuleWrongTypeFail() {
         ASSERT.about(javaSources())
                 .that(Arrays.asList(allTypesModel, JavaFileObjects.forResource("some/test/InvalidLibraryModuleWrongType.java")))
                 .processedWith(new RealmProcessor())
@@ -233,7 +225,7 @@ public void compileBooleanFile() {
     }
 
     @Test
-    public void compileProcessedBooleansFile() throws Exception {
+    public void compileProcessedBooleansFile() {
         ASSERT.about(javaSource())
                 .that(booleansModel)
                 .processedWith(new RealmProcessor())
@@ -241,14 +233,14 @@ public void compileProcessedBooleansFile() throws Exception {
     }
 
     @Test
-    public void compileBooleansProxyFile() throws Exception {
+    public void compileBooleansProxyFile() {
         ASSERT.about(javaSource())
                 .that(booleansModel)
                 .compilesWithoutError();
     }
 
     @Test
-    public void compareProcessedBooleansFile() throws Exception {
+    public void compareProcessedBooleansFile() {
         ASSERT.about(javaSource())
                 .that(booleansModel)
                 .processedWith(new RealmProcessor())
@@ -265,7 +257,8 @@ public void compileMissingGenericType() {
                 .failsToCompile();
     }
 
-    // Disabled because it does not seem to find the generated Interface file @Test
+    @Test
+    @Ignore("Disabled because it does not find the generated Interface file")
     public void compileFieldNamesFiles() {
         ASSERT.about(javaSource())
                 .that(fieldNamesModel)
@@ -288,8 +281,8 @@ public void compileIndexTypes() throws IOException {
                 "Byte", "Short", "Integer", "Long", "Boolean"};
 
         for (String fieldType : validIndexFieldTypes) {
-            TestRealmObjectFileObject javaFileObject =
-                    TestRealmObjectFileObject.getSingleFieldInstance("ValidIndexType", "Index", fieldType, "testField");
+            RealmSyntheticTestClass javaFileObject =
+                    new RealmSyntheticTestClass.Builder().name("ValidIndexType").field("testField", fieldType, "Index").build();
             ASSERT.about(javaSource())
                     .that(javaFileObject)
                     .processedWith(new RealmProcessor())
@@ -303,8 +296,8 @@ public void compileInvalidIndexTypes() throws IOException {
         final String[] invalidIndexFieldTypes = {"float", "double", "byte[]", "Simple", "RealmList", "Float", "Double"};
 
         for (String fieldType : invalidIndexFieldTypes) {
-            TestRealmObjectFileObject javaFileObject = TestRealmObjectFileObject.getSingleFieldInstance(
-                    "InvalidIndexType", "Index", fieldType, "testField");
+            RealmSyntheticTestClass javaFileObject =
+                    new RealmSyntheticTestClass.Builder().name("InvalidIndexType").field("testField", fieldType, "Index").build();
             ASSERT.about(javaSource())
                     .that(javaFileObject)
                     .processedWith(new RealmProcessor())
@@ -318,8 +311,8 @@ public void compilePrimaryKeyTypes() throws IOException {
         final String[] validPrimaryKeyFieldTypes = {"byte", "short", "int", "long", "String", "Byte", "Short", "Integer", "Long"};
 
         for (String fieldType : validPrimaryKeyFieldTypes) {
-            TestRealmObjectFileObject javaFileObject = TestRealmObjectFileObject.getSingleFieldInstance(
-                    "ValidPrimaryKeyType", "PrimaryKey", fieldType, "testField");
+            RealmSyntheticTestClass javaFileObject =
+                    new RealmSyntheticTestClass.Builder().name("ValidPrimaryKeyType").field("testField", fieldType, "PrimaryKey").build();
             ASSERT.about(javaSource())
                     .that(javaFileObject)
                     .processedWith(new RealmProcessor())
@@ -333,9 +326,8 @@ public void compileInvalidPrimaryKeyTypes() throws IOException {
         final String[] invalidPrimaryKeyFieldTypes = {"boolean", "java.util.Date", "Simple", "RealmList<Simple>", "Boolean"};
 
         for (String fieldType : invalidPrimaryKeyFieldTypes) {
-            TestRealmObjectFileObject javaFileObject =
-                    TestRealmObjectFileObject.getSingleFieldInstance(
-                            "InvalidPrimaryKeyType", "PrimaryKey", fieldType, "testField");
+            RealmSyntheticTestClass javaFileObject =
+                    new RealmSyntheticTestClass.Builder().name("InvalidPrimaryKeyType").field("testField", fieldType, "PrimaryKey").build();
             ASSERT.about(javaSource())
                     .that(javaFileObject)
                     .processedWith(new RealmProcessor())
@@ -350,8 +342,8 @@ public void compileRequiredTypes() throws IOException {
                 "Float", "Double", "Boolean", "java.util.Date"};
 
         for (String fieldType : validPrimaryKeyFieldTypes) {
-            TestRealmObjectFileObject javaFileObject = TestRealmObjectFileObject.getSingleFieldInstance(
-                    "ValidPrimaryKeyType", "Required", fieldType, "testField");
+            RealmSyntheticTestClass javaFileObject =
+                    new RealmSyntheticTestClass.Builder().name("ValidPrimaryKeyType").field("testField", fieldType, "Required").build();
             ASSERT.about(javaSource())
                     .that(javaFileObject)
                     .processedWith(new RealmProcessor())
@@ -366,8 +358,8 @@ public void compileInvalidRequiredTypes() throws IOException {
                 "boolean", "RealmList<Simple>", "Simple"};
 
         for (String fieldType : validPrimaryKeyFieldTypes) {
-            TestRealmObjectFileObject javaFileObject = TestRealmObjectFileObject.getSingleFieldInstance(
-                    "ValidPrimaryKeyType", "Required", fieldType, "testField");
+            RealmSyntheticTestClass javaFileObject =
+                    new RealmSyntheticTestClass.Builder().name("ValidPrimaryKeyType").field("testField", fieldType, "Required").build();
             ASSERT.about(javaSource())
                     .that(javaFileObject)
                     .processedWith(new RealmProcessor())
@@ -376,7 +368,7 @@ public void compileInvalidRequiredTypes() throws IOException {
     }
 
     @Test
-    public void compileConflictingFieldName() throws Exception {
+    public void compileConflictingFieldName() {
         ASSERT.about(javaSource())
                 .that(conflictingFieldNameModel)
                 .processedWith(new RealmProcessor())
@@ -384,7 +376,7 @@ public void compileConflictingFieldName() throws Exception {
     }
 
     @Test
-    public void failOnFinalFields() throws Exception {
+    public void failOnFinalFields() {
         ASSERT.about(javaSource())
                 .that(finalModel)
                 .processedWith(new RealmProcessor())
@@ -392,15 +384,15 @@ public void failOnFinalFields() throws Exception {
     }
 
     @Test
-    public void failOnTransientFields() throws Exception {
+    public void compileTransientFields() {
         ASSERT.about(javaSource())
                 .that(transientModel)
                 .processedWith(new RealmProcessor())
-                .failsToCompile();
+                .compilesWithoutError();
     }
 
     @Test
-    public void failOnVolatileFields() throws Exception {
+    public void failOnVolatileFields() {
         ASSERT.about(javaSource())
                 .that(volatileModel)
                 .processedWith(new RealmProcessor())
@@ -409,7 +401,7 @@ public void failOnVolatileFields() throws Exception {
 
     // annotation without implementing RealmModel interface
     @Test
-    public void failOnInvalidRealmModel_1() throws Exception {
+    public void failOnInvalidRealmModel_1() {
         ASSERT.about(javaSource())
                 .that(invalidRealmModelModel_1)
                 .processedWith(new RealmProcessor())
@@ -418,7 +410,7 @@ public void failOnInvalidRealmModel_1() throws Exception {
 
     // it's not allowed to extend from another RealmObject
     @Test
-    public void failOnInvalidRealmModel_2() throws Exception {
+    public void failOnInvalidRealmModel_2() {
         ASSERT.about(javaSource())
                 .that(invalidRealmModelModel_2)
                 .processedWith(new RealmProcessor())
@@ -427,7 +419,7 @@ public void failOnInvalidRealmModel_2() throws Exception {
 
     // it's not allowed to extend from another RealmObject
     @Test
-    public void failOnInvalidRealmModel_3() throws Exception {
+    public void failOnInvalidRealmModel_3() {
         ASSERT.about(javaSource())
                 .that(invalidRealmModelModel_3)
                 .processedWith(new RealmProcessor())
@@ -435,7 +427,7 @@ public void failOnInvalidRealmModel_3() throws Exception {
     }
 
     @Test
-    public void validRealmModelUsingInheritance() throws Exception {
+    public void validRealmModelUsingInheritance() {
         ASSERT.about(javaSource())
                 .that(ValidModelPojo_ExtendingRealmObject)
                 .processedWith(new RealmProcessor())
@@ -443,7 +435,7 @@ public void validRealmModelUsingInheritance() throws Exception {
     }
 
     @Test
-    public void canNotInheritRealmList() throws Exception {
+    public void canNotInheritRealmList() {
         ASSERT.about(javaSource())
                 .that(UseExtendRealmList)
                 .processedWith(new RealmProcessor())
@@ -475,90 +467,10 @@ public void compileWithInterfaceForObject() {
     }
 
     @Test
-    public void compileBacklinks() {
-        ASSERT.about(javaSources())
-            .that(Arrays.asList(backlinks, backlinksTarget))
-            .processedWith(new RealmProcessor())
-            .compilesWithoutError();
-    }
-
-    @Test
-    public void failOnLinkingObjectsWithInvalidFieldType() {
-        ASSERT.about(javaSources())
-            .that(Arrays.asList(backlinks, backlinksTarget, backlinksInvalidField))
-            .processedWith(new RealmProcessor())
-            .failsToCompile()
-            .withErrorContaining("Fields annotated with @LinkingObjects must be RealmResults");
-    }
-
-    @Test
-    public void failOnLinkingObjectsWithNonFinalField() {
-        ASSERT.about(javaSources())
-            .that(Arrays.asList(backlinks, backlinksTarget, backlinksNonFinalField))
-            .processedWith(new RealmProcessor())
-            .failsToCompile()
-            .withErrorContaining("must be final");
-    }
-
-    @Test
-    public void failsOnLinkingObjectsWithLinkedFields() {
-        ASSERT.about(javaSources())
-            .that(Arrays.asList(backlinks, backlinksTarget, backlinksLinked))
-            .processedWith(new RealmProcessor())
-            .failsToCompile()
-            .withErrorContaining("The use of '.' to specify fields in referenced classes is not supported");
-    }
-
-    @Test
-    public void failsOnLinkingObjectsMissingFieldName() {
-        ASSERT.about(javaSources())
-            .that(Arrays.asList(backlinks, backlinksTarget, backlinksMissingParam))
-            .processedWith(new RealmProcessor())
-            .failsToCompile()
-            .withErrorContaining("must have a parameter identifying the link target");
-    }
-
-    @Test
-    public void failsOnLinkingObjectsMissingGeneric() {
-        ASSERT.about(javaSources())
-            .that(Arrays.asList(backlinks, backlinksTarget, backlinksMissingGeneric))
-            .processedWith(new RealmProcessor())
-            .failsToCompile()
-            .withErrorContaining("must specify a generic type");
-    }
-
-    @Test
-    public void failsOnLinkingObjectsWithRequiredFields() {
-        ASSERT.about(javaSources())
-            .that(Arrays.asList(backlinks, backlinksTarget, backlinksRequired))
-            .processedWith(new RealmProcessor())
-            .failsToCompile()
-            .withErrorContaining("cannot be @Required");
-    }
-
-    @Test
-    public void failsOnLinkingObjectsWithIgnoreFields() {
-        ASSERT.about(javaSources())
-            .that(Arrays.asList(backlinks, backlinksTarget, backlinksIgnored))
-            .processedWith(new RealmProcessor())
-            .compilesWithoutError();
-    }
-
-    @Test
-    public void failsOnLinkingObjectsFieldNotFound() {
-        ASSERT.about(javaSources())
-            .that(Arrays.asList(backlinks, backlinksTarget, backlinksNotFound))
-            .processedWith(new RealmProcessor())
-            .failsToCompile()
-            .withErrorContaining("does not exist in class");
-    }
-
-    @Test
-    public void failsOnLinkingObjectsWithFieldWrongType() {
-        ASSERT.about(javaSources())
-            .that(Arrays.asList(backlinks, backlinksTarget, backlinksWrongType))
-            .processedWith(new RealmProcessor())
-            .failsToCompile()
-            .withErrorContaining("instead of");
+    public void compareNonLatinName() {
+        ASSERT.about(javaSource())
+                .that(nonLatinName)
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
     }
 }
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmSyntheticTestClass.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmSyntheticTestClass.java
new file mode 100644
index 0000000000..2659602714
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/RealmSyntheticTestClass.java
@@ -0,0 +1,201 @@
+/*
+ * Copyright 2015-2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.processor;
+
+import com.squareup.javawriter.JavaWriter;
+
+import java.io.IOException;
+import java.io.StringWriter;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.EnumSet;
+import java.util.List;
+
+import javax.lang.model.element.Modifier;
+import javax.tools.SimpleJavaFileObject;
+
+// Helper class for creating RealmObject java files
+public class RealmSyntheticTestClass extends SimpleJavaFileObject {
+    public static class Field {
+        private final Builder builder;
+        private String name;
+        private String type;
+        private String initializer;
+        private boolean hasGetter = true;
+        private boolean hasSetter = true;
+        private EnumSet<Modifier> modifiers = EnumSet.of(Modifier.PRIVATE);
+        private final List<String> annotations = new ArrayList<String>();
+
+        Field(Builder builder) {
+            this.builder = builder;
+        }
+
+        public Field name(String name) {
+            this.name = name.substring(0, 1).toUpperCase() + name.substring(1, name.length());
+            return this;
+        }
+
+        public Field type(String type) {
+            this.type = type;
+            return this;
+        }
+
+        public Field modifiers(Modifier... modifiers) {
+            this.modifiers = EnumSet.of(modifiers[0], modifiers); // yuk
+            return this;
+        }
+
+        public Field clearAnnotations() {
+            this.annotations.clear();
+            return this;
+        }
+
+        public Field annotation(String annotation) {
+            this.annotations.add(annotation);
+            return this;
+        }
+
+        public Field initializer(String initializer) {
+            this.initializer = initializer;
+            return this;
+        }
+
+        public Field hasGetter(boolean hasGetter) {
+            this.hasGetter = hasGetter;
+            return this;
+        }
+
+        public Field hasSetter(boolean hasSetter) {
+            this.hasSetter = hasSetter;
+            return this;
+        }
+
+        public Builder builder() {
+            return builder;
+        }
+    }
+
+    public static class Builder {
+        private final List<Field> fields = new ArrayList<Field>();
+        private String name;
+
+        public Builder name(String name) {
+            this.name = name;
+            return this;
+        }
+
+        // Note: this returns the new field, not the builder.
+        // To get the builder back, use Field.builder()
+        public Field field() {
+            Field f = new Field(this);
+            fields.add(f);
+            return f;
+        }
+
+        // Convenience method to support legacy usage
+        public Builder field(String name, String type, String annotation) {
+            field().name(name).type(type).annotation(annotation);
+            return this;
+        }
+
+        public RealmSyntheticTestClass build() throws IOException {
+            StringWriter stringWriter = new StringWriter();
+            JavaWriter writer = new JavaWriter(stringWriter);
+
+            // Package name
+            writer.emitPackage("some.test");
+
+            // Import Realm classes
+            writer.emitImports("io.realm.*");
+            writer.emitImports("io.realm.annotations.*");
+
+            // Begin the class definition
+            writer.beginType(
+                    name,                        // full qualified name of the item to generate
+                    "class",                     // the type of the item
+                    EnumSet.of(Modifier.PUBLIC), // modifiers to apply
+                    "RealmObject")               // class to extend
+                    .emitEmptyLine();
+
+            for (Field field : fields) { generateField(writer, field); }
+
+            writer.endType();
+
+            return new RealmSyntheticTestClass(stringWriter, name);
+        }
+
+        private void generateField(JavaWriter writer, Field field) throws IOException {
+            if (field.name == null) { throw new IllegalArgumentException("A field must have a name"); }
+            if (field.type == null) { throw new IllegalArgumentException("A field must have a type"); }
+
+            // Declaration of field
+            for (String annotation : field.annotations) { writer.emitAnnotation(annotation); }
+            writer.emitField(field.type, field.name, field.modifiers, field.initializer);
+
+            if (field.hasSetter) { emitSetter(writer, field); }
+            if (field.hasGetter) { emitGetter(writer, field); }
+       }
+
+        private void emitSetter(JavaWriter writer, Field field) throws IOException {
+            // Setter
+            writer.beginMethod(
+                    "void", // Return type
+                    "set" + field.name, // Method name
+                    EnumSet.of(Modifier.PUBLIC), field.type, field.name); // Modifiers
+            writer.emitStatement("realmSet$" + field.name + "(" + field.name + ")");
+            writer.endMethod();
+
+            // Realm Setter
+            writer.beginMethod(
+                    "void", // Return type
+                    "realmSet$" + field.name, // Method name
+                    EnumSet.of(Modifier.PUBLIC), field.type, field.name); // Modifiers
+            writer.emitStatement("this." + field.name + "=" + field.name);
+            writer.endMethod();
+        }
+
+        private void emitGetter(JavaWriter writer, Field field) throws IOException {
+            // Getter
+            writer.beginMethod(
+                    field.type, // Return type
+                    "get" + field.name, // Method name
+                    EnumSet.of(Modifier.PUBLIC)); // Modifiers
+            writer.emitStatement("return realmGet$" + field.name + "()");
+            writer.endMethod();
+
+            // Realm Getter
+            writer.beginMethod(
+                    field.type, // Return type
+                    "realmGet$" + field.name, // Method name
+                    EnumSet.of(Modifier.PUBLIC)); // Modifiers
+            writer.emitStatement("return " + field.name);
+            writer.endMethod();
+        }
+    }
+
+    private final StringWriter stringWriter;
+
+    private RealmSyntheticTestClass(StringWriter stringWriter, String name) {
+        super(URI.create(name + ".java"), Kind.SOURCE);
+        this.stringWriter = stringWriter;
+    }
+
+    @Override
+    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
+        return stringWriter.getBuffer();
+    }
+}
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/TestRealmObjectFileObject.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/TestRealmObjectFileObject.java
deleted file mode 100644
index 60114a4e07..0000000000
--- a/realm/realm-annotations-processor/src/test/java/io/realm/processor/TestRealmObjectFileObject.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.processor;
-
-import com.squareup.javawriter.JavaWriter;
-
-import java.io.IOException;
-import java.io.StringWriter;
-import java.net.URI;
-import java.util.EnumSet;
-
-import javax.lang.model.element.Modifier;
-import javax.tools.SimpleJavaFileObject;
-
-// Helper class for creating RealmObject java files
-public class TestRealmObjectFileObject extends SimpleJavaFileObject {
-    private StringWriter stringWriter;
-
-    private TestRealmObjectFileObject(String name, StringWriter stringWriter) {
-        super(URI.create(name + ".java"), Kind.SOURCE);
-        this.stringWriter = stringWriter;
-    }
-
-    @Override
-    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
-        return stringWriter.getBuffer();
-    }
-
-    // Helper function to create a Realm object java file with a single field.
-    public static TestRealmObjectFileObject getSingleFieldInstance(String className,
-                                                            String annotationToField,
-                                                            String fieldType,
-                                                            String fieldName) throws IOException {
-        String FieldName = fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1, fieldName.length());
-        StringWriter stringWriter = new StringWriter();
-        JavaWriter writer = new JavaWriter(stringWriter);
-
-        // Package name
-        writer.emitPackage("some.test");
-
-        // Import Realm classes
-        writer.emitImports("io.realm.*");
-        writer.emitImports("io.realm.annotations.*");
-
-        // Begin the class definition
-        writer.beginType(
-                className, // full qualified name of the item to generate
-                "class",                     // the type of the item
-                EnumSet.of(Modifier.PUBLIC), // modifiers to apply
-                "RealmObject")                   // class to extend
-                .emitEmptyLine();
-
-        // Declaration of field
-        writer.emitAnnotation(annotationToField);
-        writer.emitField(fieldType, fieldName, EnumSet.of(Modifier.PRIVATE));
-
-        // Getter
-        writer.beginMethod(
-                fieldType, // Return type
-                "get" + FieldName, // Method name
-                EnumSet.of(Modifier.PUBLIC)); // Modifiers
-        writer.emitStatement("return realmGet$" +  fieldName + "()");
-        writer.endMethod();
-
-        // Setter
-        writer.beginMethod(
-                "void", // Return type
-                "set"+ FieldName, // Method name
-                EnumSet.of(Modifier.PUBLIC),
-                fieldType, fieldName); // Modifiers
-        writer.emitStatement("realmSet$" + fieldName + "(" + fieldName + ")");
-        writer.endMethod();
-
-        // Realm Getter
-        writer.beginMethod(
-                fieldType, // Return type
-                "realmGet$" + fieldName, // Method name
-                EnumSet.of(Modifier.PUBLIC)); // Modifiers
-        writer.emitStatement("return " +  fieldName);
-        writer.endMethod();
-
-        // Realm Setter
-        writer.beginMethod(
-                "void", // Return type
-                "realmSet$"+ fieldName, // Method name
-                EnumSet.of(Modifier.PUBLIC),
-                fieldType, fieldName); // Modifiers
-        writer.emitStatement("this." + fieldName + "=" + fieldName);
-        writer.endMethod();
-
-        writer.endType();
-
-        return new TestRealmObjectFileObject(className, stringWriter);
-    }
-}
diff --git a/realm/realm-annotations-processor/src/test/java/io/realm/processor/ValueListProcessorTest.java b/realm/realm-annotations-processor/src/test/java/io/realm/processor/ValueListProcessorTest.java
new file mode 100644
index 0000000000..1cb0bf9bb9
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/java/io/realm/processor/ValueListProcessorTest.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.processor;
+
+import com.google.testing.compile.JavaFileObjects;
+
+import org.junit.Ignore;
+import org.junit.Test;
+
+import javax.tools.JavaFileObject;
+
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static org.truth0.Truth.ASSERT;
+
+
+public class ValueListProcessorTest {
+    private final JavaFileObject valueList = JavaFileObjects.forResource("some/test/ValueList.java");
+    private final JavaFileObject invalidListValueType = JavaFileObjects.forResource("some/test/InvalidListElementType.java");
+
+    @Test
+    @Ignore("need to implement primitive list support in realm-library")
+    public void compileValueList() {
+        ASSERT.about(javaSource())
+                .that(valueList)
+                .processedWith(new RealmProcessor())
+                .compilesWithoutError();
+    }
+
+    @Test
+    public void failToCompileInvalidListElementType() {
+        ASSERT.about(javaSource())
+                .that(invalidListValueType)
+                .processedWith(new RealmProcessor())
+                .failsToCompile();
+    }
+}
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index 8eeb68202c..0c429a8dec 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -5,15 +5,19 @@
 import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
-import io.realm.RealmObjectSchema;
-import io.realm.RealmSchema;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.LinkView;
+import io.realm.internal.OsList;
+import io.realm.internal.OsObject;
+import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.OsSchemaInfo;
+import io.realm.internal.Property;
+import io.realm.internal.ProxyUtils;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
+import io.realm.internal.UncheckedRow;
 import io.realm.internal.android.JsonUtils;
 import io.realm.log.RealmLog;
 import java.io.IOException;
@@ -28,75 +32,99 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 
+@SuppressWarnings("all")
 public class AllTypesRealmProxy extends some.test.AllTypes
         implements RealmObjectProxy, AllTypesRealmProxyInterface {
 
-    static final class AllTypesColumnInfo extends ColumnInfo
-            implements Cloneable {
-
-        public long columnStringIndex;
-        public long columnLongIndex;
-        public long columnFloatIndex;
-        public long columnDoubleIndex;
-        public long columnBooleanIndex;
-        public long columnDateIndex;
-        public long columnBinaryIndex;
-        public long columnObjectIndex;
-        public long columnRealmListIndex;
-
-        AllTypesColumnInfo(String path, Table table) {
-            final Map<String, Long> indicesMap = new HashMap<String, Long>(9);
-            this.columnStringIndex = getValidColumnIndex(path, table, "AllTypes", "columnString");
-            indicesMap.put("columnString", this.columnStringIndex);
-            this.columnLongIndex = getValidColumnIndex(path, table, "AllTypes", "columnLong");
-            indicesMap.put("columnLong", this.columnLongIndex);
-            this.columnFloatIndex = getValidColumnIndex(path, table, "AllTypes", "columnFloat");
-            indicesMap.put("columnFloat", this.columnFloatIndex);
-            this.columnDoubleIndex = getValidColumnIndex(path, table, "AllTypes", "columnDouble");
-            indicesMap.put("columnDouble", this.columnDoubleIndex);
-            this.columnBooleanIndex = getValidColumnIndex(path, table, "AllTypes", "columnBoolean");
-            indicesMap.put("columnBoolean", this.columnBooleanIndex);
-            this.columnDateIndex = getValidColumnIndex(path, table, "AllTypes", "columnDate");
-            indicesMap.put("columnDate", this.columnDateIndex);
-            this.columnBinaryIndex = getValidColumnIndex(path, table, "AllTypes", "columnBinary");
-            indicesMap.put("columnBinary", this.columnBinaryIndex);
-            this.columnObjectIndex = getValidColumnIndex(path, table, "AllTypes", "columnObject");
-            indicesMap.put("columnObject", this.columnObjectIndex);
-            this.columnRealmListIndex = getValidColumnIndex(path, table, "AllTypes", "columnRealmList");
-            indicesMap.put("columnRealmList", this.columnRealmListIndex);
-
-            setIndicesMap(indicesMap);
+    static final class AllTypesColumnInfo extends ColumnInfo {
+        long columnStringIndex;
+        long columnLongIndex;
+        long columnFloatIndex;
+        long columnDoubleIndex;
+        long columnBooleanIndex;
+        long columnDateIndex;
+        long columnBinaryIndex;
+        long columnMutableRealmIntegerIndex;
+        long columnObjectIndex;
+        long columnRealmListIndex;
+        long columnStringListIndex;
+        long columnBinaryListIndex;
+        long columnBooleanListIndex;
+        long columnLongListIndex;
+        long columnIntegerListIndex;
+        long columnShortListIndex;
+        long columnByteListIndex;
+        long columnDoubleListIndex;
+        long columnFloatListIndex;
+        long columnDateListIndex;
+
+        AllTypesColumnInfo(OsSchemaInfo schemaInfo) {
+            super(20);
+            OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo("AllTypes");
+            this.columnStringIndex = addColumnDetails("columnString", objectSchemaInfo);
+            this.columnLongIndex = addColumnDetails("columnLong", objectSchemaInfo);
+            this.columnFloatIndex = addColumnDetails("columnFloat", objectSchemaInfo);
+            this.columnDoubleIndex = addColumnDetails("columnDouble", objectSchemaInfo);
+            this.columnBooleanIndex = addColumnDetails("columnBoolean", objectSchemaInfo);
+            this.columnDateIndex = addColumnDetails("columnDate", objectSchemaInfo);
+            this.columnBinaryIndex = addColumnDetails("columnBinary", objectSchemaInfo);
+            this.columnMutableRealmIntegerIndex = addColumnDetails("columnMutableRealmInteger", objectSchemaInfo);
+            this.columnObjectIndex = addColumnDetails("columnObject", objectSchemaInfo);
+            this.columnRealmListIndex = addColumnDetails("columnRealmList", objectSchemaInfo);
+            this.columnStringListIndex = addColumnDetails("columnStringList", objectSchemaInfo);
+            this.columnBinaryListIndex = addColumnDetails("columnBinaryList", objectSchemaInfo);
+            this.columnBooleanListIndex = addColumnDetails("columnBooleanList", objectSchemaInfo);
+            this.columnLongListIndex = addColumnDetails("columnLongList", objectSchemaInfo);
+            this.columnIntegerListIndex = addColumnDetails("columnIntegerList", objectSchemaInfo);
+            this.columnShortListIndex = addColumnDetails("columnShortList", objectSchemaInfo);
+            this.columnByteListIndex = addColumnDetails("columnByteList", objectSchemaInfo);
+            this.columnDoubleListIndex = addColumnDetails("columnDoubleList", objectSchemaInfo);
+            this.columnFloatListIndex = addColumnDetails("columnFloatList", objectSchemaInfo);
+            this.columnDateListIndex = addColumnDetails("columnDateList", objectSchemaInfo);
+            addBacklinkDetails(schemaInfo, "parentObjects", "AllTypes", "columnObject");
+        }
+
+        AllTypesColumnInfo(ColumnInfo src, boolean mutable) {
+            super(src, mutable);
+            copy(src, this);
         }
 
         @Override
-        public final void copyColumnInfoFrom(ColumnInfo other) {
-            final AllTypesColumnInfo otherInfo = (AllTypesColumnInfo) other;
-            this.columnStringIndex = otherInfo.columnStringIndex;
-            this.columnLongIndex = otherInfo.columnLongIndex;
-            this.columnFloatIndex = otherInfo.columnFloatIndex;
-            this.columnDoubleIndex = otherInfo.columnDoubleIndex;
-            this.columnBooleanIndex = otherInfo.columnBooleanIndex;
-            this.columnDateIndex = otherInfo.columnDateIndex;
-            this.columnBinaryIndex = otherInfo.columnBinaryIndex;
-            this.columnObjectIndex = otherInfo.columnObjectIndex;
-            this.columnRealmListIndex = otherInfo.columnRealmListIndex;
-
-            setIndicesMap(otherInfo.getIndicesMap());
+        protected final ColumnInfo copy(boolean mutable) {
+            return new AllTypesColumnInfo(this, mutable);
         }
 
         @Override
-        public final AllTypesColumnInfo clone() {
-            return (AllTypesColumnInfo) super.clone();
+        protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
+            final AllTypesColumnInfo src = (AllTypesColumnInfo) rawSrc;
+            final AllTypesColumnInfo dst = (AllTypesColumnInfo) rawDst;
+            dst.columnStringIndex = src.columnStringIndex;
+            dst.columnLongIndex = src.columnLongIndex;
+            dst.columnFloatIndex = src.columnFloatIndex;
+            dst.columnDoubleIndex = src.columnDoubleIndex;
+            dst.columnBooleanIndex = src.columnBooleanIndex;
+            dst.columnDateIndex = src.columnDateIndex;
+            dst.columnBinaryIndex = src.columnBinaryIndex;
+            dst.columnMutableRealmIntegerIndex = src.columnMutableRealmIntegerIndex;
+            dst.columnObjectIndex = src.columnObjectIndex;
+            dst.columnRealmListIndex = src.columnRealmListIndex;
+            dst.columnStringListIndex = src.columnStringListIndex;
+            dst.columnBinaryListIndex = src.columnBinaryListIndex;
+            dst.columnBooleanListIndex = src.columnBooleanListIndex;
+            dst.columnLongListIndex = src.columnLongListIndex;
+            dst.columnIntegerListIndex = src.columnIntegerListIndex;
+            dst.columnShortListIndex = src.columnShortListIndex;
+            dst.columnByteListIndex = src.columnByteListIndex;
+            dst.columnDoubleListIndex = src.columnDoubleListIndex;
+            dst.columnFloatListIndex = src.columnFloatListIndex;
+            dst.columnDateListIndex = src.columnDateListIndex;
         }
-
     }
-    private AllTypesColumnInfo columnInfo;
-    private ProxyState<some.test.AllTypes> proxyState;
-    private RealmList<some.test.AllTypes> columnRealmListRealmList;
-    private RealmResults<some.test.AllTypes> parentObjectsBacklinks;
+
+    private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
     private static final List<String> FIELD_NAMES;
     static {
-        List<String> fieldNames = new ArrayList<String>();
+        List<String> fieldNames = new ArrayList<String>(20);
         fieldNames.add("columnString");
         fieldNames.add("columnLong");
         fieldNames.add("columnFloat");
@@ -104,11 +132,41 @@ public final AllTypesColumnInfo clone() {
         fieldNames.add("columnBoolean");
         fieldNames.add("columnDate");
         fieldNames.add("columnBinary");
+        fieldNames.add("columnMutableRealmInteger");
         fieldNames.add("columnObject");
         fieldNames.add("columnRealmList");
+        fieldNames.add("columnStringList");
+        fieldNames.add("columnBinaryList");
+        fieldNames.add("columnBooleanList");
+        fieldNames.add("columnLongList");
+        fieldNames.add("columnIntegerList");
+        fieldNames.add("columnShortList");
+        fieldNames.add("columnByteList");
+        fieldNames.add("columnDoubleList");
+        fieldNames.add("columnFloatList");
+        fieldNames.add("columnDateList");
         FIELD_NAMES = Collections.unmodifiableList(fieldNames);
     }
 
+    private AllTypesColumnInfo columnInfo;
+    private ProxyState<some.test.AllTypes> proxyState;
+    private final MutableRealmInteger.Managed columnMutableRealmIntegerMutableRealmInteger = new MutableRealmInteger.Managed<some.test.AllTypes>() {
+        @Override protected ProxyState<some.test.AllTypes> getProxyState() { return proxyState; }
+        @Override protected long getColumnIndex() { return columnInfo.columnMutableRealmIntegerIndex; }
+    };
+    private RealmList<some.test.AllTypes> columnRealmListRealmList;
+    private RealmList<String> columnStringListRealmList;
+    private RealmList<byte[]> columnBinaryListRealmList;
+    private RealmList<Boolean> columnBooleanListRealmList;
+    private RealmList<Long> columnLongListRealmList;
+    private RealmList<Integer> columnIntegerListRealmList;
+    private RealmList<Short> columnShortListRealmList;
+    private RealmList<Byte> columnByteListRealmList;
+    private RealmList<Double> columnDoubleListRealmList;
+    private RealmList<Float> columnFloatListRealmList;
+    private RealmList<Date> columnDateListRealmList;
+    private RealmResults<some.test.AllTypes> parentObjectsBacklinks;
+
     AllTypesRealmProxy() {
         proxyState.setConstructionFinished();
     }
@@ -289,6 +347,12 @@ public final AllTypesColumnInfo clone() {
         proxyState.getRow$realm().setBinaryByteArray(columnInfo.columnBinaryIndex, value);
     }
 
+    @Override
+    public MutableRealmInteger realmGet$columnMutableRealmInteger() {
+        proxyState.getRealm$realm().checkIfValid();
+        return this.columnMutableRealmIntegerMutableRealmInteger;
+    }
+
     @Override
     public some.test.AllTypes realmGet$columnObject() {
         proxyState.getRealm$realm().checkIfValid();
@@ -316,12 +380,7 @@ public final AllTypesColumnInfo clone() {
                 row.nullifyLink(columnInfo.columnObjectIndex);
                 return;
             }
-            if (!RealmObject.isValid(value)) {
-                throw new IllegalArgumentException("'value' is not a valid managed object.");
-            }
-            if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
-                throw new IllegalArgumentException("'value' belongs to a different Realm.");
-            }
+            proxyState.checkValidObject(value);
             row.getTable().setLink(columnInfo.columnObjectIndex, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true);
             return;
         }
@@ -331,13 +390,8 @@ public final AllTypesColumnInfo clone() {
             proxyState.getRow$realm().nullifyLink(columnInfo.columnObjectIndex);
             return;
         }
-        if (!(RealmObject.isManaged(value) && RealmObject.isValid(value))) {
-            throw new IllegalArgumentException("'value' is not a valid managed object.");
-        }
-        if (((RealmObjectProxy)value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
-            throw new IllegalArgumentException("'value' belongs to a different Realm.");
-        }
-        proxyState.getRow$realm().setLink(columnInfo.columnObjectIndex, ((RealmObjectProxy)value).realmGet$proxyState().getRow$realm().getIndex());
+        proxyState.checkValidObject(value);
+        proxyState.getRow$realm().setLink(columnInfo.columnObjectIndex, ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex());
     }
 
     @Override
@@ -347,8 +401,8 @@ public final AllTypesColumnInfo clone() {
         if (columnRealmListRealmList != null) {
             return columnRealmListRealmList;
         } else {
-            LinkView linkView = proxyState.getRow$realm().getLinkList(columnInfo.columnRealmListIndex);
-            columnRealmListRealmList = new RealmList<some.test.AllTypes>(some.test.AllTypes.class, linkView, proxyState.getRealm$realm());
+            OsList osList = proxyState.getRow$realm().getModelList(columnInfo.columnRealmListIndex);
+            columnRealmListRealmList = new RealmList<some.test.AllTypes>(some.test.AllTypes.class, osList, proxyState.getRealm$realm());
             return columnRealmListRealmList;
         }
     }
@@ -362,6 +416,7 @@ public final AllTypesColumnInfo clone() {
             if (proxyState.getExcludeFields$realm().contains("columnRealmList")) {
                 return;
             }
+            // if the list contains unmanaged RealmObjects, convert them to managed.
             if (value != null && !value.isManaged()) {
                 final Realm realm = (Realm) proxyState.getRealm$realm();
                 final RealmList<some.test.AllTypes> original = value;
@@ -377,206 +432,466 @@ public final AllTypesColumnInfo clone() {
         }
 
         proxyState.getRealm$realm().checkIfValid();
-        LinkView links = proxyState.getRow$realm().getLinkList(columnInfo.columnRealmListIndex);
-        links.clear();
-        if (value == null) {
-            return;
-        }
-        for (RealmModel linkedObject : (RealmList<? extends RealmModel>) value) {
-            if (!(RealmObject.isManaged(linkedObject) && RealmObject.isValid(linkedObject))) {
-                throw new IllegalArgumentException("Each element of 'value' must be a valid managed object.");
+        OsList osList = proxyState.getRow$realm().getModelList(columnInfo.columnRealmListIndex);
+        // For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.
+        if (value != null && value.size() == osList.size()) {
+            int objects = value.size();
+            for (int i = 0; i < objects; i++) {
+                some.test.AllTypes linkedObject = value.get(i);
+                proxyState.checkValidObject(linkedObject);
+                osList.setRow(i, ((RealmObjectProxy) linkedObject).realmGet$proxyState().getRow$realm().getIndex());
+            }
+        } else {
+            osList.removeAll();
+            if (value == null) {
+                return;
             }
-            if (((RealmObjectProxy)linkedObject).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
-                throw new IllegalArgumentException("Each element of 'value' must belong to the same Realm.");
+            int objects = value.size();
+            for (int i = 0; i < objects; i++) {
+                some.test.AllTypes linkedObject = value.get(i);
+                proxyState.checkValidObject(linkedObject);
+                osList.addRow(((RealmObjectProxy) linkedObject).realmGet$proxyState().getRow$realm().getIndex());
             }
-            links.add(((RealmObjectProxy)linkedObject).realmGet$proxyState().getRow$realm().getIndex());
         }
     }
 
     @Override
-    public RealmResults<some.test.AllTypes> realmGet$parentObjects() {
-        BaseRealm realm = proxyState.getRealm$realm();
-        realm.checkIfValid();
-        proxyState.getRow$realm().checkIfAttached();
-        if (parentObjectsBacklinks == null) {
-            parentObjectsBacklinks = RealmResults.createBacklinkResults(realm, proxyState.getRow$realm(), some.test.AllTypes.class, "columnObject");
+    public RealmList<String> realmGet$columnStringList() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (columnStringListRealmList != null) {
+            return columnStringListRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnStringListIndex, RealmFieldType.STRING_LIST);
+            columnStringListRealmList = new RealmList<java.lang.String>(java.lang.String.class, osList, proxyState.getRealm$realm());
+            return columnStringListRealmList;
         }
-        return parentObjectsBacklinks;
     }
 
-    public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
-        if (!realmSchema.contains("AllTypes")) {
-            RealmObjectSchema realmObjectSchema = realmSchema.create("AllTypes");
-            realmObjectSchema.add("columnString", RealmFieldType.STRING, Property.PRIMARY_KEY, Property.INDEXED, !Property.REQUIRED);
-            realmObjectSchema.add("columnLong", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-            realmObjectSchema.add("columnFloat", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-            realmObjectSchema.add("columnDouble", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-            realmObjectSchema.add("columnBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-            realmObjectSchema.add("columnDate", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-            realmObjectSchema.add("columnBinary", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-            if (!realmSchema.contains("AllTypes")) {
-                AllTypesRealmProxy.createRealmObjectSchema(realmSchema);
-            }
-            realmObjectSchema.add("columnObject", RealmFieldType.OBJECT, realmSchema.get("AllTypes"));
-            if (!realmSchema.contains("AllTypes")) {
-                AllTypesRealmProxy.createRealmObjectSchema(realmSchema);
-            }
-            realmObjectSchema.add("columnRealmList", RealmFieldType.LIST, realmSchema.get("AllTypes"));
-            return realmObjectSchema;
-        }
-        return realmSchema.get("AllTypes");
-    }
+    @Override
+    public void realmSet$columnStringList(RealmList<String> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnStringList")) {
+                return;
+            }
+        }
 
-    public static AllTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
-        if (!sharedRealm.hasTable("class_AllTypes")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'AllTypes' class is missing from the schema for this Realm.");
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnStringListIndex, RealmFieldType.STRING_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        Table table = sharedRealm.getTable("class_AllTypes");
-        final long columnCount = table.getColumnCount();
-        if (columnCount != 9) {
-            if (columnCount < 9) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 9 but was " + columnCount);
-            }
-            if (allowExtraColumns) {
-                RealmLog.debug("Field count is more than expected - expected 9 but was %1$d", columnCount);
+        for (java.lang.String item : value) {
+            if (item == null) {
+                osList.addNull();
             } else {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 9 but was " + columnCount);
+                osList.addString(item);
             }
         }
-        Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
-        for (long i = 0; i < columnCount; i++) {
-            columnTypes.put(table.getColumnName(i), table.getColumnType(i));
-        }
-
-        final AllTypesColumnInfo columnInfo = new AllTypesColumnInfo(sharedRealm.getPath(), table);
+    }
 
-        if (!table.hasPrimaryKey()) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary key not defined for field 'columnString' in existing Realm file. @PrimaryKey was added.");
+    @Override
+    public RealmList<byte[]> realmGet$columnBinaryList() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (columnBinaryListRealmList != null) {
+            return columnBinaryListRealmList;
         } else {
-            if (table.getPrimaryKey() != columnInfo.columnStringIndex) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key annotation definition was changed, from field " + table.getColumnName(table.getPrimaryKey()) + " to field columnString");
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnBinaryListIndex, RealmFieldType.BINARY_LIST);
+            columnBinaryListRealmList = new RealmList<byte[]>(byte[].class, osList, proxyState.getRealm$realm());
+            return columnBinaryListRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$columnBinaryList(RealmList<byte[]> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnBinaryList")) {
+                return;
             }
         }
 
-        if (!columnTypes.containsKey("columnString")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnString' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnBinaryListIndex, RealmFieldType.BINARY_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (columnTypes.get("columnString") != RealmFieldType.STRING) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'columnString' in existing Realm file.");
+        for (byte[] item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addBinary(item);
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Boolean> realmGet$columnBooleanList() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (columnBooleanListRealmList != null) {
+            return columnBooleanListRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnBooleanListIndex, RealmFieldType.BOOLEAN_LIST);
+            columnBooleanListRealmList = new RealmList<java.lang.Boolean>(java.lang.Boolean.class, osList, proxyState.getRealm$realm());
+            return columnBooleanListRealmList;
         }
-        if (!table.isColumnNullable(columnInfo.columnStringIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(),"@PrimaryKey field 'columnString' does not support null values in the existing Realm file. Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.");
+    }
+
+    @Override
+    public void realmSet$columnBooleanList(RealmList<Boolean> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnBooleanList")) {
+                return;
+            }
         }
-        if (!table.hasSearchIndex(table.getColumnIndex("columnString"))) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Index not defined for field 'columnString' in existing Realm file. Either set @Index or migrate using io.realm.internal.Table.removeSearchIndex().");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnBooleanListIndex, RealmFieldType.BOOLEAN_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (!columnTypes.containsKey("columnLong")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnLong' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        for (java.lang.Boolean item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addBoolean(item);
+            }
         }
-        if (columnTypes.get("columnLong") != RealmFieldType.INTEGER) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'long' for field 'columnLong' in existing Realm file.");
+    }
+
+    @Override
+    public RealmList<Long> realmGet$columnLongList() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (columnLongListRealmList != null) {
+            return columnLongListRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnLongListIndex, RealmFieldType.INTEGER_LIST);
+            columnLongListRealmList = new RealmList<java.lang.Long>(java.lang.Long.class, osList, proxyState.getRealm$realm());
+            return columnLongListRealmList;
         }
-        if (table.isColumnNullable(columnInfo.columnLongIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnLong' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnLong' or migrate using RealmObjectSchema.setNullable().");
+    }
+
+    @Override
+    public void realmSet$columnLongList(RealmList<Long> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnLongList")) {
+                return;
+            }
         }
-        if (!columnTypes.containsKey("columnFloat")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnFloat' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnLongListIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (columnTypes.get("columnFloat") != RealmFieldType.FLOAT) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'float' for field 'columnFloat' in existing Realm file.");
+        for (java.lang.Long item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addLong(item.longValue());
+            }
         }
-        if (table.isColumnNullable(columnInfo.columnFloatIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnFloat' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnFloat' or migrate using RealmObjectSchema.setNullable().");
+    }
+
+    @Override
+    public RealmList<Integer> realmGet$columnIntegerList() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (columnIntegerListRealmList != null) {
+            return columnIntegerListRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnIntegerListIndex, RealmFieldType.INTEGER_LIST);
+            columnIntegerListRealmList = new RealmList<java.lang.Integer>(java.lang.Integer.class, osList, proxyState.getRealm$realm());
+            return columnIntegerListRealmList;
         }
-        if (!columnTypes.containsKey("columnDouble")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnDouble' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+    }
+
+    @Override
+    public void realmSet$columnIntegerList(RealmList<Integer> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnIntegerList")) {
+                return;
+            }
         }
-        if (columnTypes.get("columnDouble") != RealmFieldType.DOUBLE) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'double' for field 'columnDouble' in existing Realm file.");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnIntegerListIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (table.isColumnNullable(columnInfo.columnDoubleIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDouble' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnDouble' or migrate using RealmObjectSchema.setNullable().");
+        for (java.lang.Integer item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addLong(item.longValue());
+            }
         }
-        if (!columnTypes.containsKey("columnBoolean")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnBoolean' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+    }
+
+    @Override
+    public RealmList<Short> realmGet$columnShortList() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (columnShortListRealmList != null) {
+            return columnShortListRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnShortListIndex, RealmFieldType.INTEGER_LIST);
+            columnShortListRealmList = new RealmList<java.lang.Short>(java.lang.Short.class, osList, proxyState.getRealm$realm());
+            return columnShortListRealmList;
         }
-        if (columnTypes.get("columnBoolean") != RealmFieldType.BOOLEAN) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'columnBoolean' in existing Realm file.");
+    }
+
+    @Override
+    public void realmSet$columnShortList(RealmList<Short> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnShortList")) {
+                return;
+            }
         }
-        if (table.isColumnNullable(columnInfo.columnBooleanIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'columnBoolean' or migrate using RealmObjectSchema.setNullable().");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnShortListIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (!columnTypes.containsKey("columnDate")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnDate' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        for (java.lang.Short item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addLong(item.longValue());
+            }
         }
-        if (columnTypes.get("columnDate") != RealmFieldType.DATE) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Date' for field 'columnDate' in existing Realm file.");
+    }
+
+    @Override
+    public RealmList<Byte> realmGet$columnByteList() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (columnByteListRealmList != null) {
+            return columnByteListRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnByteListIndex, RealmFieldType.INTEGER_LIST);
+            columnByteListRealmList = new RealmList<java.lang.Byte>(java.lang.Byte.class, osList, proxyState.getRealm$realm());
+            return columnByteListRealmList;
         }
-        if (table.isColumnNullable(columnInfo.columnDateIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnDate' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnDate' or migrate using RealmObjectSchema.setNullable().");
+    }
+
+    @Override
+    public void realmSet$columnByteList(RealmList<Byte> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnByteList")) {
+                return;
+            }
         }
-        if (!columnTypes.containsKey("columnBinary")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnBinary' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnByteListIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (columnTypes.get("columnBinary") != RealmFieldType.BINARY) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'byte[]' for field 'columnBinary' in existing Realm file.");
+        for (java.lang.Byte item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addLong(item.longValue());
+            }
         }
-        if (table.isColumnNullable(columnInfo.columnBinaryIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'columnBinary' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'columnBinary' or migrate using RealmObjectSchema.setNullable().");
+    }
+
+    @Override
+    public RealmList<Double> realmGet$columnDoubleList() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (columnDoubleListRealmList != null) {
+            return columnDoubleListRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnDoubleListIndex, RealmFieldType.DOUBLE_LIST);
+            columnDoubleListRealmList = new RealmList<java.lang.Double>(java.lang.Double.class, osList, proxyState.getRealm$realm());
+            return columnDoubleListRealmList;
         }
-        if (!columnTypes.containsKey("columnObject")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnObject' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+    }
+
+    @Override
+    public void realmSet$columnDoubleList(RealmList<Double> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnDoubleList")) {
+                return;
+            }
         }
-        if (columnTypes.get("columnObject") != RealmFieldType.OBJECT) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'AllTypes' for field 'columnObject'");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnDoubleListIndex, RealmFieldType.DOUBLE_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (!sharedRealm.hasTable("class_AllTypes")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnObject'");
+        for (java.lang.Double item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addDouble(item.doubleValue());
+            }
         }
-        Table table_7 = sharedRealm.getTable("class_AllTypes");
-        if (!table.getLinkTarget(columnInfo.columnObjectIndex).hasSameSchema(table_7)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmObject for field 'columnObject': '" + table.getLinkTarget(columnInfo.columnObjectIndex).getName() + "' expected - was '" + table_7.getName() + "'");
+    }
+
+    @Override
+    public RealmList<Float> realmGet$columnFloatList() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (columnFloatListRealmList != null) {
+            return columnFloatListRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnFloatListIndex, RealmFieldType.FLOAT_LIST);
+            columnFloatListRealmList = new RealmList<java.lang.Float>(java.lang.Float.class, osList, proxyState.getRealm$realm());
+            return columnFloatListRealmList;
         }
-        if (!columnTypes.containsKey("columnRealmList")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'columnRealmList'");
+    }
+
+    @Override
+    public void realmSet$columnFloatList(RealmList<Float> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnFloatList")) {
+                return;
+            }
         }
-        if (columnTypes.get("columnRealmList") != RealmFieldType.LIST) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'AllTypes' for field 'columnRealmList'");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnFloatListIndex, RealmFieldType.FLOAT_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (!sharedRealm.hasTable("class_AllTypes")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_AllTypes' for field 'columnRealmList'");
+        for (java.lang.Float item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addFloat(item.floatValue());
+            }
         }
-        Table table_8 = sharedRealm.getTable("class_AllTypes");
-        if (!table.getLinkTarget(columnInfo.columnRealmListIndex).hasSameSchema(table_8)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmList type for field 'columnRealmList': '" + table.getLinkTarget(columnInfo.columnRealmListIndex).getName() + "' expected - was '" + table_8.getName() + "'");
+    }
+
+    @Override
+    public RealmList<Date> realmGet$columnDateList() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (columnDateListRealmList != null) {
+            return columnDateListRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnDateListIndex, RealmFieldType.DATE_LIST);
+            columnDateListRealmList = new RealmList<java.util.Date>(java.util.Date.class, osList, proxyState.getRealm$realm());
+            return columnDateListRealmList;
         }
+    }
 
-        long backlinkFieldIndex;
-        Table backlinkSourceTable;
-        Table backlinkTargetTable;
-        RealmFieldType backlinkFieldType;
-        if (!sharedRealm.hasTable("class_AllTypes")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Cannot find source class 'some.test.AllTypes' for @LinkingObjects field 'some.test.AllTypes.parentObjects'");
+    @Override
+    public void realmSet$columnDateList(RealmList<Date> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("columnDateList")) {
+                return;
+            }
         }
-        backlinkSourceTable = sharedRealm.getTable("class_AllTypes");
-        backlinkFieldIndex = backlinkSourceTable.getColumnIndex("columnObject");
-        if (backlinkFieldIndex == Table.NO_MATCH) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Cannot find source field 'some.test.AllTypes.columnObject' for @LinkingObjects field 'some.test.AllTypes.parentObjects'");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.columnDateListIndex, RealmFieldType.DATE_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        backlinkFieldType = backlinkSourceTable.getColumnType(backlinkFieldIndex);
-        if ((backlinkFieldType != RealmFieldType.OBJECT) && (backlinkFieldType != RealmFieldType.LIST)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Source field 'some.test.AllTypes.columnObject' for @LinkingObjects field 'some.test.AllTypes.parentObjects' is not a RealmObject type");
+        for (java.util.Date item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addDate(item);
+            }
         }
-        backlinkTargetTable = backlinkSourceTable.getLinkTarget(backlinkFieldIndex);
-        if (!table.hasSameSchema(backlinkTargetTable)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Source field 'some.test.AllTypes.columnObject' for @LinkingObjects field 'some.test.AllTypes.parentObjects' has wrong type '" + backlinkTargetTable.getName() + "'");
+    }
+
+    @Override
+    public RealmResults<some.test.AllTypes> realmGet$parentObjects() {
+        BaseRealm realm = proxyState.getRealm$realm();
+        realm.checkIfValid();
+        proxyState.getRow$realm().checkIfAttached();
+        if (parentObjectsBacklinks == null) {
+            parentObjectsBacklinks = RealmResults.createBacklinkResults(realm, proxyState.getRow$realm(), some.test.AllTypes.class, "columnObject");
         }
+        return parentObjectsBacklinks;
+    }
+
+    private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
+        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("AllTypes", 20, 1);
+        builder.addPersistedProperty("columnString", RealmFieldType.STRING, Property.PRIMARY_KEY, Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("columnLong", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("columnFloat", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("columnDouble", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("columnBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("columnDate", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("columnBinary", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("columnMutableRealmInteger", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedLinkProperty("columnObject", RealmFieldType.OBJECT, "AllTypes");
+        builder.addPersistedLinkProperty("columnRealmList", RealmFieldType.LIST, "AllTypes");
+        builder.addPersistedValueListProperty("columnStringList", RealmFieldType.STRING_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("columnBinaryList", RealmFieldType.BINARY_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("columnBooleanList", RealmFieldType.BOOLEAN_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("columnLongList", RealmFieldType.INTEGER_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("columnIntegerList", RealmFieldType.INTEGER_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("columnShortList", RealmFieldType.INTEGER_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("columnByteList", RealmFieldType.INTEGER_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("columnDoubleList", RealmFieldType.DOUBLE_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("columnFloatList", RealmFieldType.FLOAT_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("columnDateList", RealmFieldType.DATE_LIST, !Property.REQUIRED);
+        builder.addComputedLinkProperty("parentObjects", "AllTypes", "columnObject");
+        return builder.build();
+    }
+
+    public static OsObjectSchemaInfo getExpectedObjectSchemaInfo() {
+        return expectedObjectSchemaInfo;
+    }
 
-        return columnInfo;
+    public static AllTypesColumnInfo createColumnInfo(OsSchemaInfo schemaInfo) {
+        return new AllTypesColumnInfo(schemaInfo);
     }
 
-    public static String getTableName() {
-        return "class_AllTypes";
+    public static String getSimpleClassName() {
+        return "AllTypes";
     }
 
     public static List<String> getFieldNames() {
@@ -586,11 +901,12 @@ public static String getTableName() {
     @SuppressWarnings("cast")
     public static some.test.AllTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
-        final List<String> excludeFields = new ArrayList<String>(2);
+        final List<String> excludeFields = new ArrayList<String>(12);
         some.test.AllTypes obj = null;
         if (update) {
             Table table = realm.getTable(some.test.AllTypes.class);
-            long pkColumnIndex = table.getPrimaryKey();
+            AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class);
+            long pkColumnIndex = columnInfo.columnStringIndex;
             long rowIndex = Table.NO_MATCH;
             if (json.isNull("columnString")) {
                 rowIndex = table.findFirstNull(pkColumnIndex);
@@ -600,7 +916,7 @@ public static String getTableName() {
             if (rowIndex != Table.NO_MATCH) {
                 final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
                 try {
-                    objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.schema.getColumnInfo(some.test.AllTypes.class), false, Collections.<String> emptyList());
+                    objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(some.test.AllTypes.class), false, Collections.<String> emptyList());
                     obj = new io.realm.AllTypesRealmProxy();
                 } finally {
                     objectContext.clear();
@@ -614,9 +930,39 @@ public static String getTableName() {
             if (json.has("columnRealmList")) {
                 excludeFields.add("columnRealmList");
             }
-            if (json.has("columnString")) {
-                if (json.isNull("columnString")) {
-                    obj = (io.realm.AllTypesRealmProxy) realm.createObjectInternal(some.test.AllTypes.class, null, true, excludeFields);
+            if (json.has("columnStringList")) {
+                excludeFields.add("columnStringList");
+            }
+            if (json.has("columnBinaryList")) {
+                excludeFields.add("columnBinaryList");
+            }
+            if (json.has("columnBooleanList")) {
+                excludeFields.add("columnBooleanList");
+            }
+            if (json.has("columnLongList")) {
+                excludeFields.add("columnLongList");
+            }
+            if (json.has("columnIntegerList")) {
+                excludeFields.add("columnIntegerList");
+            }
+            if (json.has("columnShortList")) {
+                excludeFields.add("columnShortList");
+            }
+            if (json.has("columnByteList")) {
+                excludeFields.add("columnByteList");
+            }
+            if (json.has("columnDoubleList")) {
+                excludeFields.add("columnDoubleList");
+            }
+            if (json.has("columnFloatList")) {
+                excludeFields.add("columnFloatList");
+            }
+            if (json.has("columnDateList")) {
+                excludeFields.add("columnDateList");
+            }
+            if (json.has("columnString")) {
+                if (json.isNull("columnString")) {
+                    obj = (io.realm.AllTypesRealmProxy) realm.createObjectInternal(some.test.AllTypes.class, null, true, excludeFields);
                 } else {
                     obj = (io.realm.AllTypesRealmProxy) realm.createObjectInternal(some.test.AllTypes.class, json.getString("columnString"), true, excludeFields);
                 }
@@ -624,73 +970,88 @@ public static String getTableName() {
                 throw new IllegalArgumentException("JSON object doesn't have the primary key field 'columnString'.");
             }
         }
+
+        final AllTypesRealmProxyInterface objProxy = (AllTypesRealmProxyInterface) obj;
         if (json.has("columnLong")) {
             if (json.isNull("columnLong")) {
                 throw new IllegalArgumentException("Trying to set non-nullable field 'columnLong' to null.");
             } else {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnLong((long) json.getLong("columnLong"));
+                objProxy.realmSet$columnLong((long) json.getLong("columnLong"));
             }
         }
         if (json.has("columnFloat")) {
             if (json.isNull("columnFloat")) {
                 throw new IllegalArgumentException("Trying to set non-nullable field 'columnFloat' to null.");
             } else {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnFloat((float) json.getDouble("columnFloat"));
+                objProxy.realmSet$columnFloat((float) json.getDouble("columnFloat"));
             }
         }
         if (json.has("columnDouble")) {
             if (json.isNull("columnDouble")) {
                 throw new IllegalArgumentException("Trying to set non-nullable field 'columnDouble' to null.");
             } else {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnDouble((double) json.getDouble("columnDouble"));
+                objProxy.realmSet$columnDouble((double) json.getDouble("columnDouble"));
             }
         }
         if (json.has("columnBoolean")) {
             if (json.isNull("columnBoolean")) {
                 throw new IllegalArgumentException("Trying to set non-nullable field 'columnBoolean' to null.");
             } else {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnBoolean((boolean) json.getBoolean("columnBoolean"));
+                objProxy.realmSet$columnBoolean((boolean) json.getBoolean("columnBoolean"));
             }
         }
         if (json.has("columnDate")) {
             if (json.isNull("columnDate")) {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnDate(null);
+                objProxy.realmSet$columnDate(null);
             } else {
                 Object timestamp = json.get("columnDate");
                 if (timestamp instanceof String) {
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnDate(JsonUtils.stringToDate((String) timestamp));
+                    objProxy.realmSet$columnDate(JsonUtils.stringToDate((String) timestamp));
                 } else {
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnDate(new Date(json.getLong("columnDate")));
+                    objProxy.realmSet$columnDate(new Date(json.getLong("columnDate")));
                 }
             }
         }
         if (json.has("columnBinary")) {
             if (json.isNull("columnBinary")) {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnBinary(null);
+                objProxy.realmSet$columnBinary(null);
             } else {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnBinary(JsonUtils.stringToBytes(json.getString("columnBinary")));
+                objProxy.realmSet$columnBinary(JsonUtils.stringToBytes(json.getString("columnBinary")));
             }
         }
+        if (json.has("columnMutableRealmInteger")) {
+            objProxy.realmGet$columnMutableRealmInteger().set((json.isNull("columnMutableRealmInteger")) ? null : json.getLong("columnMutableRealmInteger"));
+        }
         if (json.has("columnObject")) {
             if (json.isNull("columnObject")) {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnObject(null);
+                objProxy.realmSet$columnObject(null);
             } else {
                 some.test.AllTypes columnObjectObj = AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, json.getJSONObject("columnObject"), update);
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnObject(columnObjectObj);
+                objProxy.realmSet$columnObject(columnObjectObj);
             }
         }
         if (json.has("columnRealmList")) {
             if (json.isNull("columnRealmList")) {
-                ((AllTypesRealmProxyInterface) obj).realmSet$columnRealmList(null);
+                objProxy.realmSet$columnRealmList(null);
             } else {
-                ((AllTypesRealmProxyInterface) obj).realmGet$columnRealmList().clear();
+                objProxy.realmGet$columnRealmList().clear();
                 JSONArray array = json.getJSONArray("columnRealmList");
                 for (int i = 0; i < array.length(); i++) {
                     some.test.AllTypes item = AllTypesRealmProxy.createOrUpdateUsingJsonObject(realm, array.getJSONObject(i), update);
-                    ((AllTypesRealmProxyInterface) obj).realmGet$columnRealmList().add(item);
+                    objProxy.realmGet$columnRealmList().add(item);
                 }
             }
         }
+        // TODO implement logic for value list columnStringList.
+        // TODO implement logic for value list columnBinaryList.
+        // TODO implement logic for value list columnBooleanList.
+        // TODO implement logic for value list columnLongList.
+        // TODO implement logic for value list columnIntegerList.
+        // TODO implement logic for value list columnShortList.
+        // TODO implement logic for value list columnByteList.
+        // TODO implement logic for value list columnDoubleList.
+        // TODO implement logic for value list columnFloatList.
+        // TODO implement logic for value list columnDateList.
         return obj;
     }
 
@@ -699,87 +1060,116 @@ public static String getTableName() {
     public static some.test.AllTypes createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
         boolean jsonHasPrimaryKey = false;
-        some.test.AllTypes obj = new some.test.AllTypes();
+        final some.test.AllTypes obj = new some.test.AllTypes();
+        final AllTypesRealmProxyInterface objProxy = (AllTypesRealmProxyInterface) obj;
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
             if (false) {
             } else if (name.equals("columnString")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnString(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$columnString((String) reader.nextString());
                 } else {
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnString((String) reader.nextString());
+                    reader.skipValue();
+                    objProxy.realmSet$columnString(null);
                 }
                 jsonHasPrimaryKey = true;
             } else if (name.equals("columnLong")) {
-                if (reader.peek() == JsonToken.NULL) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$columnLong((long) reader.nextLong());
+                } else {
                     reader.skipValue();
                     throw new IllegalArgumentException("Trying to set non-nullable field 'columnLong' to null.");
-                } else {
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnLong((long) reader.nextLong());
                 }
             } else if (name.equals("columnFloat")) {
-                if (reader.peek() == JsonToken.NULL) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$columnFloat((float) reader.nextDouble());
+                } else {
                     reader.skipValue();
                     throw new IllegalArgumentException("Trying to set non-nullable field 'columnFloat' to null.");
-                } else {
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnFloat((float) reader.nextDouble());
                 }
             } else if (name.equals("columnDouble")) {
-                if (reader.peek() == JsonToken.NULL) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$columnDouble((double) reader.nextDouble());
+                } else {
                     reader.skipValue();
                     throw new IllegalArgumentException("Trying to set non-nullable field 'columnDouble' to null.");
-                } else {
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnDouble((double) reader.nextDouble());
                 }
             } else if (name.equals("columnBoolean")) {
-                if (reader.peek() == JsonToken.NULL) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$columnBoolean((boolean) reader.nextBoolean());
+                } else {
                     reader.skipValue();
                     throw new IllegalArgumentException("Trying to set non-nullable field 'columnBoolean' to null.");
-                } else {
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnBoolean((boolean) reader.nextBoolean());
                 }
             } else if (name.equals("columnDate")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnDate(null);
+                    objProxy.realmSet$columnDate(null);
                 } else if (reader.peek() == JsonToken.NUMBER) {
                     long timestamp = reader.nextLong();
                     if (timestamp > -1) {
-                        ((AllTypesRealmProxyInterface) obj).realmSet$columnDate(new Date(timestamp));
+                        objProxy.realmSet$columnDate(new Date(timestamp));
                     }
                 } else {
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnDate(JsonUtils.stringToDate(reader.nextString()));
+                    objProxy.realmSet$columnDate(JsonUtils.stringToDate(reader.nextString()));
                 }
             } else if (name.equals("columnBinary")) {
-                if (reader.peek() == JsonToken.NULL) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$columnBinary(JsonUtils.stringToBytes(reader.nextString()));
+                } else {
                     reader.skipValue();
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnBinary(null);
+                    objProxy.realmSet$columnBinary(null);
+                }
+            } else if (name.equals("columnMutableRealmInteger")) {
+                Long val = null;
+                if (reader.peek() != JsonToken.NULL) {
+                    val = reader.nextLong();
                 } else {
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnBinary(JsonUtils.stringToBytes(reader.nextString()));
+                    reader.skipValue();
                 }
+                objProxy.realmGet$columnMutableRealmInteger().set(val);
             } else if (name.equals("columnObject")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnObject(null);
+                    objProxy.realmSet$columnObject(null);
                 } else {
                     some.test.AllTypes columnObjectObj = AllTypesRealmProxy.createUsingJsonStream(realm, reader);
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnObject(columnObjectObj);
+                    objProxy.realmSet$columnObject(columnObjectObj);
                 }
             } else if (name.equals("columnRealmList")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnRealmList(null);
+                    objProxy.realmSet$columnRealmList(null);
                 } else {
-                    ((AllTypesRealmProxyInterface) obj).realmSet$columnRealmList(new RealmList<some.test.AllTypes>());
+                    objProxy.realmSet$columnRealmList(new RealmList<some.test.AllTypes>());
                     reader.beginArray();
                     while (reader.hasNext()) {
                         some.test.AllTypes item = AllTypesRealmProxy.createUsingJsonStream(realm, reader);
-                        ((AllTypesRealmProxyInterface) obj).realmGet$columnRealmList().add(item);
+                        objProxy.realmGet$columnRealmList().add(item);
                     }
                     reader.endArray();
                 }
+            } else if (name.equals("columnStringList")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("columnBinaryList")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("columnBooleanList")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("columnLongList")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("columnIntegerList")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("columnShortList")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("columnByteList")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("columnDoubleList")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("columnFloatList")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("columnDateList")) {
+                // TODO implement logic for value list.
             } else {
                 reader.skipValue();
             }
@@ -788,108 +1178,124 @@ public static String getTableName() {
         if (!jsonHasPrimaryKey) {
             throw new IllegalArgumentException("JSON object doesn't have the primary key field 'columnString'.");
         }
-        obj = realm.copyToRealm(obj);
-        return obj;
+        return realm.copyToRealm(obj);
     }
 
     public static some.test.AllTypes copyOrUpdate(Realm realm, some.test.AllTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
-            throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
-        }
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-            return object;
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null) {
+            final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm();
+            if (otherRealm.threadId != realm.threadId) {
+                throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
+            }
+            if (otherRealm.getPath().equals(realm.getPath())) {
+                return object;
+            }
         }
         final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
         RealmObjectProxy cachedRealmObject = cache.get(object);
         if (cachedRealmObject != null) {
             return (some.test.AllTypes) cachedRealmObject;
-        } else {
-            some.test.AllTypes realmObject = null;
-            boolean canUpdate = update;
-            if (canUpdate) {
-                Table table = realm.getTable(some.test.AllTypes.class);
-                long pkColumnIndex = table.getPrimaryKey();
-                String value = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
-                long rowIndex = Table.NO_MATCH;
-                if (value == null) {
-                    rowIndex = table.findFirstNull(pkColumnIndex);
-                } else {
-                    rowIndex = table.findFirstString(pkColumnIndex, value);
-                }
-                if (rowIndex != Table.NO_MATCH) {
-                    try {
-                        objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.schema.getColumnInfo(some.test.AllTypes.class), false, Collections.<String> emptyList());
-                        realmObject = new io.realm.AllTypesRealmProxy();
-                        cache.put(object, (RealmObjectProxy) realmObject);
-                    } finally {
-                        objectContext.clear();
-                    }
-                } else {
-                    canUpdate = false;
-                }
-            }
+        }
 
-            if (canUpdate) {
-                return update(realm, realmObject, object, cache);
+        some.test.AllTypes realmObject = null;
+        boolean canUpdate = update;
+        if (canUpdate) {
+            Table table = realm.getTable(some.test.AllTypes.class);
+            AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class);
+            long pkColumnIndex = columnInfo.columnStringIndex;
+            String value = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
+            long rowIndex = Table.NO_MATCH;
+            if (value == null) {
+                rowIndex = table.findFirstNull(pkColumnIndex);
             } else {
-                return copy(realm, object, update, cache);
+                rowIndex = table.findFirstString(pkColumnIndex, value);
+            }
+            if (rowIndex == Table.NO_MATCH) {
+                canUpdate = false;
+            } else {
+                try {
+                    objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.getSchema().getColumnInfo(some.test.AllTypes.class), false, Collections.<String> emptyList());
+                    realmObject = new io.realm.AllTypesRealmProxy();
+                    cache.put(object, (RealmObjectProxy) realmObject);
+                } finally {
+                    objectContext.clear();
+                }
             }
         }
+
+        return (canUpdate) ? update(realm, realmObject, object, cache) : copy(realm, object, update, cache);
     }
 
     public static some.test.AllTypes copy(Realm realm, some.test.AllTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
         RealmObjectProxy cachedRealmObject = cache.get(newObject);
         if (cachedRealmObject != null) {
             return (some.test.AllTypes) cachedRealmObject;
+        }
+
+        // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
+        some.test.AllTypes realmObject = realm.createObjectInternal(some.test.AllTypes.class, ((AllTypesRealmProxyInterface) newObject).realmGet$columnString(), false, Collections.<String>emptyList());
+        cache.put(newObject, (RealmObjectProxy) realmObject);
+
+        AllTypesRealmProxyInterface realmObjectSource = (AllTypesRealmProxyInterface) newObject;
+        AllTypesRealmProxyInterface realmObjectCopy = (AllTypesRealmProxyInterface) realmObject;
+
+        realmObjectCopy.realmSet$columnLong(realmObjectSource.realmGet$columnLong());
+        realmObjectCopy.realmSet$columnFloat(realmObjectSource.realmGet$columnFloat());
+        realmObjectCopy.realmSet$columnDouble(realmObjectSource.realmGet$columnDouble());
+        realmObjectCopy.realmSet$columnBoolean(realmObjectSource.realmGet$columnBoolean());
+        realmObjectCopy.realmSet$columnDate(realmObjectSource.realmGet$columnDate());
+        realmObjectCopy.realmSet$columnBinary(realmObjectSource.realmGet$columnBinary());
+
+        realmObjectCopy.realmGet$columnMutableRealmInteger().set(realmObjectSource.realmGet$columnMutableRealmInteger().get());
+
+        some.test.AllTypes columnObjectObj = realmObjectSource.realmGet$columnObject();
+        if (columnObjectObj == null) {
+            realmObjectCopy.realmSet$columnObject(null);
         } else {
-            // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
-            some.test.AllTypes realmObject = realm.createObjectInternal(some.test.AllTypes.class, ((AllTypesRealmProxyInterface) newObject).realmGet$columnString(), false, Collections.<String>emptyList());
-            cache.put(newObject, (RealmObjectProxy) realmObject);
-            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnLong(((AllTypesRealmProxyInterface) newObject).realmGet$columnLong());
-            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) newObject).realmGet$columnFloat());
-            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) newObject).realmGet$columnDouble());
-            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBoolean(((AllTypesRealmProxyInterface) newObject).realmGet$columnBoolean());
-            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDate(((AllTypesRealmProxyInterface) newObject).realmGet$columnDate());
-            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBinary(((AllTypesRealmProxyInterface) newObject).realmGet$columnBinary());
-
-            some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) newObject).realmGet$columnObject();
-            if (columnObjectObj != null) {
-                some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
-                if (cachecolumnObject != null) {
-                    ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(cachecolumnObject);
-                } else {
-                    ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, update, cache));
-                }
+            some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
+            if (cachecolumnObject != null) {
+                realmObjectCopy.realmSet$columnObject(cachecolumnObject);
             } else {
-                ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(null);
+                realmObjectCopy.realmSet$columnObject(AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, update, cache));
             }
+        }
 
-            RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) newObject).realmGet$columnRealmList();
-            if (columnRealmListList != null) {
-                RealmList<some.test.AllTypes> columnRealmListRealmList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
-                for (int i = 0; i < columnRealmListList.size(); i++) {
-                    some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
-                    some.test.AllTypes cachecolumnRealmList = (some.test.AllTypes) cache.get(columnRealmListItem);
-                    if (cachecolumnRealmList != null) {
-                        columnRealmListRealmList.add(cachecolumnRealmList);
-                    } else {
-                        columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListList.get(i), update, cache));
-                    }
+        RealmList<some.test.AllTypes> columnRealmListList = realmObjectSource.realmGet$columnRealmList();
+        if (columnRealmListList != null) {
+            RealmList<some.test.AllTypes> columnRealmListRealmList = realmObjectCopy.realmGet$columnRealmList();
+            columnRealmListRealmList.clear();
+            for (int i = 0; i < columnRealmListList.size(); i++) {
+                some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
+                some.test.AllTypes cachecolumnRealmList = (some.test.AllTypes) cache.get(columnRealmListItem);
+                if (cachecolumnRealmList != null) {
+                    columnRealmListRealmList.add(cachecolumnRealmList);
+                } else {
+                    columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListItem, update, cache));
                 }
             }
-
-            return realmObject;
         }
+
+        realmObjectCopy.realmSet$columnStringList(realmObjectSource.realmGet$columnStringList());
+        realmObjectCopy.realmSet$columnBinaryList(realmObjectSource.realmGet$columnBinaryList());
+        realmObjectCopy.realmSet$columnBooleanList(realmObjectSource.realmGet$columnBooleanList());
+        realmObjectCopy.realmSet$columnLongList(realmObjectSource.realmGet$columnLongList());
+        realmObjectCopy.realmSet$columnIntegerList(realmObjectSource.realmGet$columnIntegerList());
+        realmObjectCopy.realmSet$columnShortList(realmObjectSource.realmGet$columnShortList());
+        realmObjectCopy.realmSet$columnByteList(realmObjectSource.realmGet$columnByteList());
+        realmObjectCopy.realmSet$columnDoubleList(realmObjectSource.realmGet$columnDoubleList());
+        realmObjectCopy.realmSet$columnFloatList(realmObjectSource.realmGet$columnFloatList());
+        realmObjectCopy.realmSet$columnDateList(realmObjectSource.realmGet$columnDateList());
+        return realmObject;
     }
 
     public static long insert(Realm realm, some.test.AllTypes object, Map<RealmModel,Long> cache) {
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-            return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+            return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex();
         }
         Table table = realm.getTable(some.test.AllTypes.class);
-        long tableNativePtr = table.getNativeTablePointer();
-        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.schema.getColumnInfo(some.test.AllTypes.class);
-        long pkColumnIndex = table.getPrimaryKey();
+        long tableNativePtr = table.getNativePtr();
+        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class);
+        long pkColumnIndex = columnInfo.columnStringIndex;
         String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
         long rowIndex = Table.NO_MATCH;
         if (primaryKeyValue == null) {
@@ -898,23 +1304,27 @@ public static long insert(Realm realm, some.test.AllTypes object, Map<RealmModel
             rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
         }
         if (rowIndex == Table.NO_MATCH) {
-            rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false);
+            rowIndex = OsObject.createRowWithPrimaryKey(table, pkColumnIndex, primaryKeyValue);
         } else {
             Table.throwDuplicatePrimaryKeyException(primaryKeyValue);
         }
         cache.put(object, rowIndex);
-        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong(), false);
-        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat(), false);
-        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble(), false);
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean(), false);
-        java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface)object).realmGet$columnDate();
+        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnLong(), false);
+        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnFloat(), false);
+        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnDouble(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnBoolean(), false);
+        java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface) object).realmGet$columnDate();
         if (realmGet$columnDate != null) {
             Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
         }
-        byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface)object).realmGet$columnBinary();
+        byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface) object).realmGet$columnBinary();
         if (realmGet$columnBinary != null) {
             Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
         }
+        Long realmGet$columnMutableRealmInteger = ((AllTypesRealmProxyInterface) object).realmGet$columnMutableRealmInteger().get();
+        if (realmGet$columnMutableRealmInteger != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, realmGet$columnMutableRealmInteger.longValue(), false);
+        }
 
         some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
         if (columnObjectObj != null) {
@@ -927,91 +1337,334 @@ public static long insert(Realm realm, some.test.AllTypes object, Map<RealmModel
 
         RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
         if (columnRealmListList != null) {
-            long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
+            OsList columnRealmListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnRealmListIndex);
             for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
                 Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
                 if (cacheItemIndexcolumnRealmList == null) {
                     cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insert(realm, columnRealmListItem, cache);
                 }
-                LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
+                columnRealmListOsList.addRow(cacheItemIndexcolumnRealmList);
+            }
+        }
+
+        RealmList<java.lang.String> columnStringListList = ((AllTypesRealmProxyInterface) object).realmGet$columnStringList();
+        if (columnStringListList != null) {
+            OsList columnStringListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnStringListIndex);
+            for (java.lang.String columnStringListItem : columnStringListList) {
+                if (columnStringListItem == null) {
+                    columnStringListOsList.addNull();
+                } else {
+                    columnStringListOsList.addString(columnStringListItem);
+                }
             }
         }
 
+        RealmList<byte[]> columnBinaryListList = ((AllTypesRealmProxyInterface) object).realmGet$columnBinaryList();
+        if (columnBinaryListList != null) {
+            OsList columnBinaryListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnBinaryListIndex);
+            for (byte[] columnBinaryListItem : columnBinaryListList) {
+                if (columnBinaryListItem == null) {
+                    columnBinaryListOsList.addNull();
+                } else {
+                    columnBinaryListOsList.addBinary(columnBinaryListItem);
+                }
+            }
+        }
+
+        RealmList<java.lang.Boolean> columnBooleanListList = ((AllTypesRealmProxyInterface) object).realmGet$columnBooleanList();
+        if (columnBooleanListList != null) {
+            OsList columnBooleanListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnBooleanListIndex);
+            for (java.lang.Boolean columnBooleanListItem : columnBooleanListList) {
+                if (columnBooleanListItem == null) {
+                    columnBooleanListOsList.addNull();
+                } else {
+                    columnBooleanListOsList.addBoolean(columnBooleanListItem);
+                }
+            }
+        }
+
+        RealmList<java.lang.Long> columnLongListList = ((AllTypesRealmProxyInterface) object).realmGet$columnLongList();
+        if (columnLongListList != null) {
+            OsList columnLongListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnLongListIndex);
+            for (java.lang.Long columnLongListItem : columnLongListList) {
+                if (columnLongListItem == null) {
+                    columnLongListOsList.addNull();
+                } else {
+                    columnLongListOsList.addLong(columnLongListItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Integer> columnIntegerListList = ((AllTypesRealmProxyInterface) object).realmGet$columnIntegerList();
+        if (columnIntegerListList != null) {
+            OsList columnIntegerListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnIntegerListIndex);
+            for (java.lang.Integer columnIntegerListItem : columnIntegerListList) {
+                if (columnIntegerListItem == null) {
+                    columnIntegerListOsList.addNull();
+                } else {
+                    columnIntegerListOsList.addLong(columnIntegerListItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Short> columnShortListList = ((AllTypesRealmProxyInterface) object).realmGet$columnShortList();
+        if (columnShortListList != null) {
+            OsList columnShortListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnShortListIndex);
+            for (java.lang.Short columnShortListItem : columnShortListList) {
+                if (columnShortListItem == null) {
+                    columnShortListOsList.addNull();
+                } else {
+                    columnShortListOsList.addLong(columnShortListItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Byte> columnByteListList = ((AllTypesRealmProxyInterface) object).realmGet$columnByteList();
+        if (columnByteListList != null) {
+            OsList columnByteListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnByteListIndex);
+            for (java.lang.Byte columnByteListItem : columnByteListList) {
+                if (columnByteListItem == null) {
+                    columnByteListOsList.addNull();
+                } else {
+                    columnByteListOsList.addLong(columnByteListItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Double> columnDoubleListList = ((AllTypesRealmProxyInterface) object).realmGet$columnDoubleList();
+        if (columnDoubleListList != null) {
+            OsList columnDoubleListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnDoubleListIndex);
+            for (java.lang.Double columnDoubleListItem : columnDoubleListList) {
+                if (columnDoubleListItem == null) {
+                    columnDoubleListOsList.addNull();
+                } else {
+                    columnDoubleListOsList.addDouble(columnDoubleListItem.doubleValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Float> columnFloatListList = ((AllTypesRealmProxyInterface) object).realmGet$columnFloatList();
+        if (columnFloatListList != null) {
+            OsList columnFloatListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnFloatListIndex);
+            for (java.lang.Float columnFloatListItem : columnFloatListList) {
+                if (columnFloatListItem == null) {
+                    columnFloatListOsList.addNull();
+                } else {
+                    columnFloatListOsList.addFloat(columnFloatListItem.floatValue());
+                }
+            }
+        }
+
+        RealmList<java.util.Date> columnDateListList = ((AllTypesRealmProxyInterface) object).realmGet$columnDateList();
+        if (columnDateListList != null) {
+            OsList columnDateListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnDateListIndex);
+            for (java.util.Date columnDateListItem : columnDateListList) {
+                if (columnDateListItem == null) {
+                    columnDateListOsList.addNull();
+                } else {
+                    columnDateListOsList.addDate(columnDateListItem);
+                }
+            }
+        }
         return rowIndex;
     }
 
     public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
         Table table = realm.getTable(some.test.AllTypes.class);
-        long tableNativePtr = table.getNativeTablePointer();
-        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.schema.getColumnInfo(some.test.AllTypes.class);
-        long pkColumnIndex = table.getPrimaryKey();
+        long tableNativePtr = table.getNativePtr();
+        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class);
+        long pkColumnIndex = columnInfo.columnStringIndex;
         some.test.AllTypes object = null;
         while (objects.hasNext()) {
             object = (some.test.AllTypes) objects.next();
-            if(!cache.containsKey(object)) {
-                if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-                    cache.put(object, ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex());
-                    continue;
-                }
-                String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
-                long rowIndex = Table.NO_MATCH;
-                if (primaryKeyValue == null) {
-                    rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
-                } else {
-                    rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
+            if (cache.containsKey(object)) {
+                continue;
+            }
+            if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex());
+                continue;
+            }
+            String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
+            long rowIndex = Table.NO_MATCH;
+            if (primaryKeyValue == null) {
+                rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
+            } else {
+                rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
+            }
+            if (rowIndex == Table.NO_MATCH) {
+                rowIndex = OsObject.createRowWithPrimaryKey(table, pkColumnIndex, primaryKeyValue);
+            } else {
+                Table.throwDuplicatePrimaryKeyException(primaryKeyValue);
+            }
+            cache.put(object, rowIndex);
+            Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnLong(), false);
+            Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnFloat(), false);
+            Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnDouble(), false);
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnBoolean(), false);
+            java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface) object).realmGet$columnDate();
+            if (realmGet$columnDate != null) {
+                Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
+            }
+            byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface) object).realmGet$columnBinary();
+            if (realmGet$columnBinary != null) {
+                Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
+            }
+            Long realmGet$columnMutableRealmInteger = ((AllTypesRealmProxyInterface) object).realmGet$columnMutableRealmInteger().get();
+            if (realmGet$columnMutableRealmInteger != null) {
+                Table.nativeSetLong(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, realmGet$columnMutableRealmInteger.longValue(), false);
+            }
+
+            some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
+            if (columnObjectObj != null) {
+                Long cachecolumnObject = cache.get(columnObjectObj);
+                if (cachecolumnObject == null) {
+                    cachecolumnObject = AllTypesRealmProxy.insert(realm, columnObjectObj, cache);
                 }
-                if (rowIndex == Table.NO_MATCH) {
-                    rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false);
-                } else {
-                    Table.throwDuplicatePrimaryKeyException(primaryKeyValue);
-                }
-                cache.put(object, rowIndex);
-                Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong(), false);
-                Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat(), false);
-                Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble(), false);
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean(), false);
-                java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface)object).realmGet$columnDate();
-                if (realmGet$columnDate != null) {
-                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
-                }
-                byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface)object).realmGet$columnBinary();
-                if (realmGet$columnBinary != null) {
-                    Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
-                }
-
-                some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
-                if (columnObjectObj != null) {
-                    Long cachecolumnObject = cache.get(columnObjectObj);
-                    if (cachecolumnObject == null) {
-                        cachecolumnObject = AllTypesRealmProxy.insert(realm, columnObjectObj, cache);
+                table.setLink(columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
+            }
+
+            RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
+            if (columnRealmListList != null) {
+                OsList columnRealmListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnRealmListIndex);
+                for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
+                    Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
+                    if (cacheItemIndexcolumnRealmList == null) {
+                        cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insert(realm, columnRealmListItem, cache);
                     }
-                    table.setLink(columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
+                    columnRealmListOsList.addRow(cacheItemIndexcolumnRealmList);
                 }
+            }
 
-                RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
-                if (columnRealmListList != null) {
-                    long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
-                    for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
-                        Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
-                        if (cacheItemIndexcolumnRealmList == null) {
-                            cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insert(realm, columnRealmListItem, cache);
-                        }
-                        LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
+            RealmList<java.lang.String> columnStringListList = ((AllTypesRealmProxyInterface) object).realmGet$columnStringList();
+            if (columnStringListList != null) {
+                OsList columnStringListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnStringListIndex);
+                for (java.lang.String columnStringListItem : columnStringListList) {
+                    if (columnStringListItem == null) {
+                        columnStringListOsList.addNull();
+                    } else {
+                        columnStringListOsList.addString(columnStringListItem);
+                    }
+                }
+            }
+
+            RealmList<byte[]> columnBinaryListList = ((AllTypesRealmProxyInterface) object).realmGet$columnBinaryList();
+            if (columnBinaryListList != null) {
+                OsList columnBinaryListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnBinaryListIndex);
+                for (byte[] columnBinaryListItem : columnBinaryListList) {
+                    if (columnBinaryListItem == null) {
+                        columnBinaryListOsList.addNull();
+                    } else {
+                        columnBinaryListOsList.addBinary(columnBinaryListItem);
+                    }
+                }
+            }
+
+            RealmList<java.lang.Boolean> columnBooleanListList = ((AllTypesRealmProxyInterface) object).realmGet$columnBooleanList();
+            if (columnBooleanListList != null) {
+                OsList columnBooleanListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnBooleanListIndex);
+                for (java.lang.Boolean columnBooleanListItem : columnBooleanListList) {
+                    if (columnBooleanListItem == null) {
+                        columnBooleanListOsList.addNull();
+                    } else {
+                        columnBooleanListOsList.addBoolean(columnBooleanListItem);
+                    }
+                }
+            }
+
+            RealmList<java.lang.Long> columnLongListList = ((AllTypesRealmProxyInterface) object).realmGet$columnLongList();
+            if (columnLongListList != null) {
+                OsList columnLongListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnLongListIndex);
+                for (java.lang.Long columnLongListItem : columnLongListList) {
+                    if (columnLongListItem == null) {
+                        columnLongListOsList.addNull();
+                    } else {
+                        columnLongListOsList.addLong(columnLongListItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Integer> columnIntegerListList = ((AllTypesRealmProxyInterface) object).realmGet$columnIntegerList();
+            if (columnIntegerListList != null) {
+                OsList columnIntegerListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnIntegerListIndex);
+                for (java.lang.Integer columnIntegerListItem : columnIntegerListList) {
+                    if (columnIntegerListItem == null) {
+                        columnIntegerListOsList.addNull();
+                    } else {
+                        columnIntegerListOsList.addLong(columnIntegerListItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Short> columnShortListList = ((AllTypesRealmProxyInterface) object).realmGet$columnShortList();
+            if (columnShortListList != null) {
+                OsList columnShortListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnShortListIndex);
+                for (java.lang.Short columnShortListItem : columnShortListList) {
+                    if (columnShortListItem == null) {
+                        columnShortListOsList.addNull();
+                    } else {
+                        columnShortListOsList.addLong(columnShortListItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Byte> columnByteListList = ((AllTypesRealmProxyInterface) object).realmGet$columnByteList();
+            if (columnByteListList != null) {
+                OsList columnByteListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnByteListIndex);
+                for (java.lang.Byte columnByteListItem : columnByteListList) {
+                    if (columnByteListItem == null) {
+                        columnByteListOsList.addNull();
+                    } else {
+                        columnByteListOsList.addLong(columnByteListItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Double> columnDoubleListList = ((AllTypesRealmProxyInterface) object).realmGet$columnDoubleList();
+            if (columnDoubleListList != null) {
+                OsList columnDoubleListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnDoubleListIndex);
+                for (java.lang.Double columnDoubleListItem : columnDoubleListList) {
+                    if (columnDoubleListItem == null) {
+                        columnDoubleListOsList.addNull();
+                    } else {
+                        columnDoubleListOsList.addDouble(columnDoubleListItem.doubleValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Float> columnFloatListList = ((AllTypesRealmProxyInterface) object).realmGet$columnFloatList();
+            if (columnFloatListList != null) {
+                OsList columnFloatListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnFloatListIndex);
+                for (java.lang.Float columnFloatListItem : columnFloatListList) {
+                    if (columnFloatListItem == null) {
+                        columnFloatListOsList.addNull();
+                    } else {
+                        columnFloatListOsList.addFloat(columnFloatListItem.floatValue());
                     }
                 }
+            }
 
+            RealmList<java.util.Date> columnDateListList = ((AllTypesRealmProxyInterface) object).realmGet$columnDateList();
+            if (columnDateListList != null) {
+                OsList columnDateListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnDateListIndex);
+                for (java.util.Date columnDateListItem : columnDateListList) {
+                    if (columnDateListItem == null) {
+                        columnDateListOsList.addNull();
+                    } else {
+                        columnDateListOsList.addDate(columnDateListItem);
+                    }
+                }
             }
         }
     }
 
     public static long insertOrUpdate(Realm realm, some.test.AllTypes object, Map<RealmModel,Long> cache) {
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-            return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+            return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex();
         }
         Table table = realm.getTable(some.test.AllTypes.class);
-        long tableNativePtr = table.getNativeTablePointer();
-        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.schema.getColumnInfo(some.test.AllTypes.class);
-        long pkColumnIndex = table.getPrimaryKey();
+        long tableNativePtr = table.getNativePtr();
+        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class);
+        long pkColumnIndex = columnInfo.columnStringIndex;
         String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
         long rowIndex = Table.NO_MATCH;
         if (primaryKeyValue == null) {
@@ -1020,25 +1673,31 @@ public static long insertOrUpdate(Realm realm, some.test.AllTypes object, Map<Re
             rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
         }
         if (rowIndex == Table.NO_MATCH) {
-            rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false);
+            rowIndex = OsObject.createRowWithPrimaryKey(table, pkColumnIndex, primaryKeyValue);
         }
         cache.put(object, rowIndex);
-        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong(), false);
-        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat(), false);
-        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble(), false);
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean(), false);
-        java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface)object).realmGet$columnDate();
+        Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnLong(), false);
+        Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnFloat(), false);
+        Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnDouble(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnBoolean(), false);
+        java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface) object).realmGet$columnDate();
         if (realmGet$columnDate != null) {
             Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.columnDateIndex, rowIndex, false);
         }
-        byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface)object).realmGet$columnBinary();
+        byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface) object).realmGet$columnBinary();
         if (realmGet$columnBinary != null) {
             Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, false);
         }
+        Long realmGet$columnMutableRealmInteger = ((AllTypesRealmProxyInterface) object).realmGet$columnMutableRealmInteger().get();
+        if (realmGet$columnMutableRealmInteger != null) {
+            Table.nativeSetLong(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, realmGet$columnMutableRealmInteger.longValue(), false);
+        } else {
+            Table.nativeSetNull(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, false);
+        }
 
         some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
         if (columnObjectObj != null) {
@@ -1051,16 +1710,169 @@ public static long insertOrUpdate(Realm realm, some.test.AllTypes object, Map<Re
             Table.nativeNullifyLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex);
         }
 
-        long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
-        LinkView.nativeClear(columnRealmListNativeLinkViewPtr);
+        OsList columnRealmListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnRealmListIndex);
         RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
-        if (columnRealmListList != null) {
-            for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
+        if (columnRealmListList != null && columnRealmListList.size() == columnRealmListOsList.size()) {
+            // For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.
+            int objects = columnRealmListList.size();
+            for (int i = 0; i < objects; i++) {
+                some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
                 Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
                 if (cacheItemIndexcolumnRealmList == null) {
                     cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insertOrUpdate(realm, columnRealmListItem, cache);
                 }
-                LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
+                columnRealmListOsList.setRow(i, cacheItemIndexcolumnRealmList);
+            }
+        } else {
+            columnRealmListOsList.removeAll();
+            if (columnRealmListList != null) {
+                for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
+                    Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
+                    if (cacheItemIndexcolumnRealmList == null) {
+                        cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insertOrUpdate(realm, columnRealmListItem, cache);
+                    }
+                    columnRealmListOsList.addRow(cacheItemIndexcolumnRealmList);
+                }
+            }
+        }
+
+
+        OsList columnStringListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnStringListIndex);
+        columnStringListOsList.removeAll();
+        RealmList<java.lang.String> columnStringListList = ((AllTypesRealmProxyInterface) object).realmGet$columnStringList();
+        if (columnStringListList != null) {
+            for (java.lang.String columnStringListItem : columnStringListList) {
+                if (columnStringListItem == null) {
+                    columnStringListOsList.addNull();
+                } else {
+                    columnStringListOsList.addString(columnStringListItem);
+                }
+            }
+        }
+
+
+        OsList columnBinaryListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnBinaryListIndex);
+        columnBinaryListOsList.removeAll();
+        RealmList<byte[]> columnBinaryListList = ((AllTypesRealmProxyInterface) object).realmGet$columnBinaryList();
+        if (columnBinaryListList != null) {
+            for (byte[] columnBinaryListItem : columnBinaryListList) {
+                if (columnBinaryListItem == null) {
+                    columnBinaryListOsList.addNull();
+                } else {
+                    columnBinaryListOsList.addBinary(columnBinaryListItem);
+                }
+            }
+        }
+
+
+        OsList columnBooleanListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnBooleanListIndex);
+        columnBooleanListOsList.removeAll();
+        RealmList<java.lang.Boolean> columnBooleanListList = ((AllTypesRealmProxyInterface) object).realmGet$columnBooleanList();
+        if (columnBooleanListList != null) {
+            for (java.lang.Boolean columnBooleanListItem : columnBooleanListList) {
+                if (columnBooleanListItem == null) {
+                    columnBooleanListOsList.addNull();
+                } else {
+                    columnBooleanListOsList.addBoolean(columnBooleanListItem);
+                }
+            }
+        }
+
+
+        OsList columnLongListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnLongListIndex);
+        columnLongListOsList.removeAll();
+        RealmList<java.lang.Long> columnLongListList = ((AllTypesRealmProxyInterface) object).realmGet$columnLongList();
+        if (columnLongListList != null) {
+            for (java.lang.Long columnLongListItem : columnLongListList) {
+                if (columnLongListItem == null) {
+                    columnLongListOsList.addNull();
+                } else {
+                    columnLongListOsList.addLong(columnLongListItem.longValue());
+                }
+            }
+        }
+
+
+        OsList columnIntegerListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnIntegerListIndex);
+        columnIntegerListOsList.removeAll();
+        RealmList<java.lang.Integer> columnIntegerListList = ((AllTypesRealmProxyInterface) object).realmGet$columnIntegerList();
+        if (columnIntegerListList != null) {
+            for (java.lang.Integer columnIntegerListItem : columnIntegerListList) {
+                if (columnIntegerListItem == null) {
+                    columnIntegerListOsList.addNull();
+                } else {
+                    columnIntegerListOsList.addLong(columnIntegerListItem.longValue());
+                }
+            }
+        }
+
+
+        OsList columnShortListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnShortListIndex);
+        columnShortListOsList.removeAll();
+        RealmList<java.lang.Short> columnShortListList = ((AllTypesRealmProxyInterface) object).realmGet$columnShortList();
+        if (columnShortListList != null) {
+            for (java.lang.Short columnShortListItem : columnShortListList) {
+                if (columnShortListItem == null) {
+                    columnShortListOsList.addNull();
+                } else {
+                    columnShortListOsList.addLong(columnShortListItem.longValue());
+                }
+            }
+        }
+
+
+        OsList columnByteListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnByteListIndex);
+        columnByteListOsList.removeAll();
+        RealmList<java.lang.Byte> columnByteListList = ((AllTypesRealmProxyInterface) object).realmGet$columnByteList();
+        if (columnByteListList != null) {
+            for (java.lang.Byte columnByteListItem : columnByteListList) {
+                if (columnByteListItem == null) {
+                    columnByteListOsList.addNull();
+                } else {
+                    columnByteListOsList.addLong(columnByteListItem.longValue());
+                }
+            }
+        }
+
+
+        OsList columnDoubleListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnDoubleListIndex);
+        columnDoubleListOsList.removeAll();
+        RealmList<java.lang.Double> columnDoubleListList = ((AllTypesRealmProxyInterface) object).realmGet$columnDoubleList();
+        if (columnDoubleListList != null) {
+            for (java.lang.Double columnDoubleListItem : columnDoubleListList) {
+                if (columnDoubleListItem == null) {
+                    columnDoubleListOsList.addNull();
+                } else {
+                    columnDoubleListOsList.addDouble(columnDoubleListItem.doubleValue());
+                }
+            }
+        }
+
+
+        OsList columnFloatListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnFloatListIndex);
+        columnFloatListOsList.removeAll();
+        RealmList<java.lang.Float> columnFloatListList = ((AllTypesRealmProxyInterface) object).realmGet$columnFloatList();
+        if (columnFloatListList != null) {
+            for (java.lang.Float columnFloatListItem : columnFloatListList) {
+                if (columnFloatListItem == null) {
+                    columnFloatListOsList.addNull();
+                } else {
+                    columnFloatListOsList.addFloat(columnFloatListItem.floatValue());
+                }
+            }
+        }
+
+
+        OsList columnDateListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnDateListIndex);
+        columnDateListOsList.removeAll();
+        RealmList<java.util.Date> columnDateListList = ((AllTypesRealmProxyInterface) object).realmGet$columnDateList();
+        if (columnDateListList != null) {
+            for (java.util.Date columnDateListItem : columnDateListList) {
+                if (columnDateListItem == null) {
+                    columnDateListOsList.addNull();
+                } else {
+                    columnDateListOsList.addDate(columnDateListItem);
+                }
             }
         }
 
@@ -1069,70 +1881,230 @@ public static long insertOrUpdate(Realm realm, some.test.AllTypes object, Map<Re
 
     public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
         Table table = realm.getTable(some.test.AllTypes.class);
-        long tableNativePtr = table.getNativeTablePointer();
-        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.schema.getColumnInfo(some.test.AllTypes.class);
-        long pkColumnIndex = table.getPrimaryKey();
+        long tableNativePtr = table.getNativePtr();
+        AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.AllTypes.class);
+        long pkColumnIndex = columnInfo.columnStringIndex;
         some.test.AllTypes object = null;
         while (objects.hasNext()) {
             object = (some.test.AllTypes) objects.next();
-            if(!cache.containsKey(object)) {
-                if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-                    cache.put(object, ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex());
-                    continue;
-                }
-                String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
-                long rowIndex = Table.NO_MATCH;
-                if (primaryKeyValue == null) {
-                    rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
-                } else {
-                    rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
-                }
-                if (rowIndex == Table.NO_MATCH) {
-                    rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false);
-                }
-                cache.put(object, rowIndex);
-                Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnLong(), false);
-                Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnFloat(), false);
-                Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnDouble(), false);
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface)object).realmGet$columnBoolean(), false);
-                java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface)object).realmGet$columnDate();
-                if (realmGet$columnDate != null) {
-                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
-                } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.columnDateIndex, rowIndex, false);
-                }
-                byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface)object).realmGet$columnBinary();
-                if (realmGet$columnBinary != null) {
-                    Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
-                } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, false);
+            if (cache.containsKey(object)) {
+                continue;
+            }
+            if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex());
+                continue;
+            }
+            String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
+            long rowIndex = Table.NO_MATCH;
+            if (primaryKeyValue == null) {
+                rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
+            } else {
+                rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
+            }
+            if (rowIndex == Table.NO_MATCH) {
+                rowIndex = OsObject.createRowWithPrimaryKey(table, pkColumnIndex, primaryKeyValue);
+            }
+            cache.put(object, rowIndex);
+            Table.nativeSetLong(tableNativePtr, columnInfo.columnLongIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnLong(), false);
+            Table.nativeSetFloat(tableNativePtr, columnInfo.columnFloatIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnFloat(), false);
+            Table.nativeSetDouble(tableNativePtr, columnInfo.columnDoubleIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnDouble(), false);
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.columnBooleanIndex, rowIndex, ((AllTypesRealmProxyInterface) object).realmGet$columnBoolean(), false);
+            java.util.Date realmGet$columnDate = ((AllTypesRealmProxyInterface) object).realmGet$columnDate();
+            if (realmGet$columnDate != null) {
+                Table.nativeSetTimestamp(tableNativePtr, columnInfo.columnDateIndex, rowIndex, realmGet$columnDate.getTime(), false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.columnDateIndex, rowIndex, false);
+            }
+            byte[] realmGet$columnBinary = ((AllTypesRealmProxyInterface) object).realmGet$columnBinary();
+            if (realmGet$columnBinary != null) {
+                Table.nativeSetByteArray(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, realmGet$columnBinary, false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.columnBinaryIndex, rowIndex, false);
+            }
+            Long realmGet$columnMutableRealmInteger = ((AllTypesRealmProxyInterface) object).realmGet$columnMutableRealmInteger().get();
+            if (realmGet$columnMutableRealmInteger != null) {
+                Table.nativeSetLong(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, realmGet$columnMutableRealmInteger.longValue(), false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.columnMutableRealmIntegerIndex, rowIndex, false);
+            }
+
+            some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
+            if (columnObjectObj != null) {
+                Long cachecolumnObject = cache.get(columnObjectObj);
+                if (cachecolumnObject == null) {
+                    cachecolumnObject = AllTypesRealmProxy.insertOrUpdate(realm, columnObjectObj, cache);
                 }
+                Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
+            } else {
+                Table.nativeNullifyLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex);
+            }
 
-                some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) object).realmGet$columnObject();
-                if (columnObjectObj != null) {
-                    Long cachecolumnObject = cache.get(columnObjectObj);
-                    if (cachecolumnObject == null) {
-                        cachecolumnObject = AllTypesRealmProxy.insertOrUpdate(realm, columnObjectObj, cache);
+            OsList columnRealmListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnRealmListIndex);
+            RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
+            if (columnRealmListList != null && columnRealmListList.size() == columnRealmListOsList.size()) {
+                // For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.
+                int objectCount = columnRealmListList.size();
+                for (int i = 0; i < objectCount; i++) {
+                    some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
+                    Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
+                    if (cacheItemIndexcolumnRealmList == null) {
+                        cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insertOrUpdate(realm, columnRealmListItem, cache);
                     }
-                    Table.nativeSetLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex, cachecolumnObject, false);
-                } else {
-                    Table.nativeNullifyLink(tableNativePtr, columnInfo.columnObjectIndex, rowIndex);
+                    columnRealmListOsList.setRow(i, cacheItemIndexcolumnRealmList);
                 }
-
-                long columnRealmListNativeLinkViewPtr = Table.nativeGetLinkView(tableNativePtr, columnInfo.columnRealmListIndex, rowIndex);
-                LinkView.nativeClear(columnRealmListNativeLinkViewPtr);
-                RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) object).realmGet$columnRealmList();
+            } else {
+                columnRealmListOsList.removeAll();
                 if (columnRealmListList != null) {
                     for (some.test.AllTypes columnRealmListItem : columnRealmListList) {
                         Long cacheItemIndexcolumnRealmList = cache.get(columnRealmListItem);
                         if (cacheItemIndexcolumnRealmList == null) {
                             cacheItemIndexcolumnRealmList = AllTypesRealmProxy.insertOrUpdate(realm, columnRealmListItem, cache);
                         }
-                        LinkView.nativeAdd(columnRealmListNativeLinkViewPtr, cacheItemIndexcolumnRealmList);
+                        columnRealmListOsList.addRow(cacheItemIndexcolumnRealmList);
+                    }
+                }
+            }
+
+
+            OsList columnStringListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnStringListIndex);
+            columnStringListOsList.removeAll();
+            RealmList<java.lang.String> columnStringListList = ((AllTypesRealmProxyInterface) object).realmGet$columnStringList();
+            if (columnStringListList != null) {
+                for (java.lang.String columnStringListItem : columnStringListList) {
+                    if (columnStringListItem == null) {
+                        columnStringListOsList.addNull();
+                    } else {
+                        columnStringListOsList.addString(columnStringListItem);
+                    }
+                }
+            }
+
+
+            OsList columnBinaryListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnBinaryListIndex);
+            columnBinaryListOsList.removeAll();
+            RealmList<byte[]> columnBinaryListList = ((AllTypesRealmProxyInterface) object).realmGet$columnBinaryList();
+            if (columnBinaryListList != null) {
+                for (byte[] columnBinaryListItem : columnBinaryListList) {
+                    if (columnBinaryListItem == null) {
+                        columnBinaryListOsList.addNull();
+                    } else {
+                        columnBinaryListOsList.addBinary(columnBinaryListItem);
+                    }
+                }
+            }
+
+
+            OsList columnBooleanListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnBooleanListIndex);
+            columnBooleanListOsList.removeAll();
+            RealmList<java.lang.Boolean> columnBooleanListList = ((AllTypesRealmProxyInterface) object).realmGet$columnBooleanList();
+            if (columnBooleanListList != null) {
+                for (java.lang.Boolean columnBooleanListItem : columnBooleanListList) {
+                    if (columnBooleanListItem == null) {
+                        columnBooleanListOsList.addNull();
+                    } else {
+                        columnBooleanListOsList.addBoolean(columnBooleanListItem);
+                    }
+                }
+            }
+
+
+            OsList columnLongListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnLongListIndex);
+            columnLongListOsList.removeAll();
+            RealmList<java.lang.Long> columnLongListList = ((AllTypesRealmProxyInterface) object).realmGet$columnLongList();
+            if (columnLongListList != null) {
+                for (java.lang.Long columnLongListItem : columnLongListList) {
+                    if (columnLongListItem == null) {
+                        columnLongListOsList.addNull();
+                    } else {
+                        columnLongListOsList.addLong(columnLongListItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList columnIntegerListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnIntegerListIndex);
+            columnIntegerListOsList.removeAll();
+            RealmList<java.lang.Integer> columnIntegerListList = ((AllTypesRealmProxyInterface) object).realmGet$columnIntegerList();
+            if (columnIntegerListList != null) {
+                for (java.lang.Integer columnIntegerListItem : columnIntegerListList) {
+                    if (columnIntegerListItem == null) {
+                        columnIntegerListOsList.addNull();
+                    } else {
+                        columnIntegerListOsList.addLong(columnIntegerListItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList columnShortListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnShortListIndex);
+            columnShortListOsList.removeAll();
+            RealmList<java.lang.Short> columnShortListList = ((AllTypesRealmProxyInterface) object).realmGet$columnShortList();
+            if (columnShortListList != null) {
+                for (java.lang.Short columnShortListItem : columnShortListList) {
+                    if (columnShortListItem == null) {
+                        columnShortListOsList.addNull();
+                    } else {
+                        columnShortListOsList.addLong(columnShortListItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList columnByteListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnByteListIndex);
+            columnByteListOsList.removeAll();
+            RealmList<java.lang.Byte> columnByteListList = ((AllTypesRealmProxyInterface) object).realmGet$columnByteList();
+            if (columnByteListList != null) {
+                for (java.lang.Byte columnByteListItem : columnByteListList) {
+                    if (columnByteListItem == null) {
+                        columnByteListOsList.addNull();
+                    } else {
+                        columnByteListOsList.addLong(columnByteListItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList columnDoubleListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnDoubleListIndex);
+            columnDoubleListOsList.removeAll();
+            RealmList<java.lang.Double> columnDoubleListList = ((AllTypesRealmProxyInterface) object).realmGet$columnDoubleList();
+            if (columnDoubleListList != null) {
+                for (java.lang.Double columnDoubleListItem : columnDoubleListList) {
+                    if (columnDoubleListItem == null) {
+                        columnDoubleListOsList.addNull();
+                    } else {
+                        columnDoubleListOsList.addDouble(columnDoubleListItem.doubleValue());
+                    }
+                }
+            }
+
+
+            OsList columnFloatListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnFloatListIndex);
+            columnFloatListOsList.removeAll();
+            RealmList<java.lang.Float> columnFloatListList = ((AllTypesRealmProxyInterface) object).realmGet$columnFloatList();
+            if (columnFloatListList != null) {
+                for (java.lang.Float columnFloatListItem : columnFloatListList) {
+                    if (columnFloatListItem == null) {
+                        columnFloatListOsList.addNull();
+                    } else {
+                        columnFloatListOsList.addFloat(columnFloatListItem.floatValue());
                     }
                 }
+            }
+
 
+            OsList columnDateListOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.columnDateListIndex);
+            columnDateListOsList.removeAll();
+            RealmList<java.util.Date> columnDateListList = ((AllTypesRealmProxyInterface) object).realmGet$columnDateList();
+            if (columnDateListList != null) {
+                for (java.util.Date columnDateListItem : columnDateListList) {
+                    if (columnDateListItem == null) {
+                        columnDateListOsList.addNull();
+                    } else {
+                        columnDateListOsList.addDate(columnDateListItem);
+                    }
+                }
             }
+
         }
     }
 
@@ -1142,36 +2114,38 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
         }
         CacheData<RealmModel> cachedObject = cache.get(realmObject);
         some.test.AllTypes unmanagedObject;
-        if (cachedObject != null) {
+        if (cachedObject == null) {
+            unmanagedObject = new some.test.AllTypes();
+            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject));
+        } else {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
             if (currentDepth >= cachedObject.minDepth) {
-                return (some.test.AllTypes)cachedObject.object;
-            } else {
-                unmanagedObject = (some.test.AllTypes)cachedObject.object;
-                cachedObject.minDepth = currentDepth;
+                return (some.test.AllTypes) cachedObject.object;
             }
-        } else {
-            unmanagedObject = new some.test.AllTypes();
-            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject));
-        }
-        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnString(((AllTypesRealmProxyInterface) realmObject).realmGet$columnString());
-        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnLong(((AllTypesRealmProxyInterface) realmObject).realmGet$columnLong());
-        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) realmObject).realmGet$columnFloat());
-        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) realmObject).realmGet$columnDouble());
-        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnBoolean(((AllTypesRealmProxyInterface) realmObject).realmGet$columnBoolean());
-        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnDate(((AllTypesRealmProxyInterface) realmObject).realmGet$columnDate());
-        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnBinary(((AllTypesRealmProxyInterface) realmObject).realmGet$columnBinary());
+            unmanagedObject = (some.test.AllTypes) cachedObject.object;
+            cachedObject.minDepth = currentDepth;
+        }
+        AllTypesRealmProxyInterface unmanagedCopy = (AllTypesRealmProxyInterface) unmanagedObject;
+        AllTypesRealmProxyInterface realmSource = (AllTypesRealmProxyInterface) realmObject;
+        unmanagedCopy.realmSet$columnString(realmSource.realmGet$columnString());
+        unmanagedCopy.realmSet$columnLong(realmSource.realmGet$columnLong());
+        unmanagedCopy.realmSet$columnFloat(realmSource.realmGet$columnFloat());
+        unmanagedCopy.realmSet$columnDouble(realmSource.realmGet$columnDouble());
+        unmanagedCopy.realmSet$columnBoolean(realmSource.realmGet$columnBoolean());
+        unmanagedCopy.realmSet$columnDate(realmSource.realmGet$columnDate());
+        unmanagedCopy.realmSet$columnBinary(realmSource.realmGet$columnBinary());
+        unmanagedCopy.realmGet$columnMutableRealmInteger().set(realmSource.realmGet$columnMutableRealmInteger().get());
 
         // Deep copy of columnObject
-        ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnObject(AllTypesRealmProxy.createDetachedCopy(((AllTypesRealmProxyInterface) realmObject).realmGet$columnObject(), currentDepth + 1, maxDepth, cache));
+        unmanagedCopy.realmSet$columnObject(AllTypesRealmProxy.createDetachedCopy(realmSource.realmGet$columnObject(), currentDepth + 1, maxDepth, cache));
 
         // Deep copy of columnRealmList
         if (currentDepth == maxDepth) {
-            ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnRealmList(null);
+            unmanagedCopy.realmSet$columnRealmList(null);
         } else {
-            RealmList<some.test.AllTypes> managedcolumnRealmListList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
+            RealmList<some.test.AllTypes> managedcolumnRealmListList = realmSource.realmGet$columnRealmList();
             RealmList<some.test.AllTypes> unmanagedcolumnRealmListList = new RealmList<some.test.AllTypes>();
-            ((AllTypesRealmProxyInterface) unmanagedObject).realmSet$columnRealmList(unmanagedcolumnRealmListList);
+            unmanagedCopy.realmSet$columnRealmList(unmanagedcolumnRealmListList);
             int nextDepth = currentDepth + 1;
             int size = managedcolumnRealmListList.size();
             for (int i = 0; i < size; i++) {
@@ -1179,41 +2153,99 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
                 unmanagedcolumnRealmListList.add(item);
             }
         }
+
+        unmanagedCopy.realmSet$columnStringList(new RealmList<java.lang.String>());
+        unmanagedCopy.realmGet$columnStringList().addAll(realmSource.realmGet$columnStringList());
+
+        unmanagedCopy.realmSet$columnBinaryList(new RealmList<byte[]>());
+        unmanagedCopy.realmGet$columnBinaryList().addAll(realmSource.realmGet$columnBinaryList());
+
+        unmanagedCopy.realmSet$columnBooleanList(new RealmList<java.lang.Boolean>());
+        unmanagedCopy.realmGet$columnBooleanList().addAll(realmSource.realmGet$columnBooleanList());
+
+        unmanagedCopy.realmSet$columnLongList(new RealmList<java.lang.Long>());
+        unmanagedCopy.realmGet$columnLongList().addAll(realmSource.realmGet$columnLongList());
+
+        unmanagedCopy.realmSet$columnIntegerList(new RealmList<java.lang.Integer>());
+        unmanagedCopy.realmGet$columnIntegerList().addAll(realmSource.realmGet$columnIntegerList());
+
+        unmanagedCopy.realmSet$columnShortList(new RealmList<java.lang.Short>());
+        unmanagedCopy.realmGet$columnShortList().addAll(realmSource.realmGet$columnShortList());
+
+        unmanagedCopy.realmSet$columnByteList(new RealmList<java.lang.Byte>());
+        unmanagedCopy.realmGet$columnByteList().addAll(realmSource.realmGet$columnByteList());
+
+        unmanagedCopy.realmSet$columnDoubleList(new RealmList<java.lang.Double>());
+        unmanagedCopy.realmGet$columnDoubleList().addAll(realmSource.realmGet$columnDoubleList());
+
+        unmanagedCopy.realmSet$columnFloatList(new RealmList<java.lang.Float>());
+        unmanagedCopy.realmGet$columnFloatList().addAll(realmSource.realmGet$columnFloatList());
+
+        unmanagedCopy.realmSet$columnDateList(new RealmList<java.util.Date>());
+        unmanagedCopy.realmGet$columnDateList().addAll(realmSource.realmGet$columnDateList());
+
         return unmanagedObject;
     }
 
     static some.test.AllTypes update(Realm realm, some.test.AllTypes realmObject, some.test.AllTypes newObject, Map<RealmModel, RealmObjectProxy> cache) {
-        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnLong(((AllTypesRealmProxyInterface) newObject).realmGet$columnLong());
-        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnFloat(((AllTypesRealmProxyInterface) newObject).realmGet$columnFloat());
-        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDouble(((AllTypesRealmProxyInterface) newObject).realmGet$columnDouble());
-        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBoolean(((AllTypesRealmProxyInterface) newObject).realmGet$columnBoolean());
-        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnDate(((AllTypesRealmProxyInterface) newObject).realmGet$columnDate());
-        ((AllTypesRealmProxyInterface) realmObject).realmSet$columnBinary(((AllTypesRealmProxyInterface) newObject).realmGet$columnBinary());
-        some.test.AllTypes columnObjectObj = ((AllTypesRealmProxyInterface) newObject).realmGet$columnObject();
-        if (columnObjectObj != null) {
+        AllTypesRealmProxyInterface realmObjectTarget = (AllTypesRealmProxyInterface) realmObject;
+        AllTypesRealmProxyInterface realmObjectSource = (AllTypesRealmProxyInterface) newObject;
+        realmObjectTarget.realmSet$columnLong(realmObjectSource.realmGet$columnLong());
+        realmObjectTarget.realmSet$columnFloat(realmObjectSource.realmGet$columnFloat());
+        realmObjectTarget.realmSet$columnDouble(realmObjectSource.realmGet$columnDouble());
+        realmObjectTarget.realmSet$columnBoolean(realmObjectSource.realmGet$columnBoolean());
+        realmObjectTarget.realmSet$columnDate(realmObjectSource.realmGet$columnDate());
+        realmObjectTarget.realmSet$columnBinary(realmObjectSource.realmGet$columnBinary());
+        realmObjectTarget.realmGet$columnMutableRealmInteger().set(realmObjectSource.realmGet$columnMutableRealmInteger().get());
+        some.test.AllTypes columnObjectObj = realmObjectSource.realmGet$columnObject();
+        if (columnObjectObj == null) {
+            realmObjectTarget.realmSet$columnObject(null);
+        } else {
             some.test.AllTypes cachecolumnObject = (some.test.AllTypes) cache.get(columnObjectObj);
             if (cachecolumnObject != null) {
-                ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(cachecolumnObject);
+                realmObjectTarget.realmSet$columnObject(cachecolumnObject);
             } else {
-                ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, true, cache));
+                realmObjectTarget.realmSet$columnObject(AllTypesRealmProxy.copyOrUpdate(realm, columnObjectObj, true, cache));
             }
-        } else {
-            ((AllTypesRealmProxyInterface) realmObject).realmSet$columnObject(null);
         }
-        RealmList<some.test.AllTypes> columnRealmListList = ((AllTypesRealmProxyInterface) newObject).realmGet$columnRealmList();
-        RealmList<some.test.AllTypes> columnRealmListRealmList = ((AllTypesRealmProxyInterface) realmObject).realmGet$columnRealmList();
-        columnRealmListRealmList.clear();
-        if (columnRealmListList != null) {
-            for (int i = 0; i < columnRealmListList.size(); i++) {
+        RealmList<some.test.AllTypes> columnRealmListList = realmObjectSource.realmGet$columnRealmList();
+        RealmList<some.test.AllTypes> columnRealmListRealmList = realmObjectTarget.realmGet$columnRealmList();
+        if (columnRealmListList != null && columnRealmListList.size() == columnRealmListRealmList.size()) {
+            // For lists of equal lengths, we need to set each element directly as clearing the receiver list can be wrong if the input and target list are the same.
+            int objects = columnRealmListList.size();
+            for (int i = 0; i < objects; i++) {
                 some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
                 some.test.AllTypes cachecolumnRealmList = (some.test.AllTypes) cache.get(columnRealmListItem);
                 if (cachecolumnRealmList != null) {
-                    columnRealmListRealmList.add(cachecolumnRealmList);
+                    columnRealmListRealmList.set(i, cachecolumnRealmList);
                 } else {
-                    columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListList.get(i), true, cache));
+                    columnRealmListRealmList.set(i, AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListItem, true, cache));
+                }
+            }
+        } else {
+            columnRealmListRealmList.clear();
+            if (columnRealmListList != null) {
+                for (int i = 0; i < columnRealmListList.size(); i++) {
+                    some.test.AllTypes columnRealmListItem = columnRealmListList.get(i);
+                    some.test.AllTypes cachecolumnRealmList = (some.test.AllTypes) cache.get(columnRealmListItem);
+                    if (cachecolumnRealmList != null) {
+                        columnRealmListRealmList.add(cachecolumnRealmList);
+                    } else {
+                        columnRealmListRealmList.add(AllTypesRealmProxy.copyOrUpdate(realm, columnRealmListItem, true, cache));
+                    }
                 }
             }
         }
+        realmObjectTarget.realmSet$columnStringList(realmObjectSource.realmGet$columnStringList());
+        realmObjectTarget.realmSet$columnBinaryList(realmObjectSource.realmGet$columnBinaryList());
+        realmObjectTarget.realmSet$columnBooleanList(realmObjectSource.realmGet$columnBooleanList());
+        realmObjectTarget.realmSet$columnLongList(realmObjectSource.realmGet$columnLongList());
+        realmObjectTarget.realmSet$columnIntegerList(realmObjectSource.realmGet$columnIntegerList());
+        realmObjectTarget.realmSet$columnShortList(realmObjectSource.realmGet$columnShortList());
+        realmObjectTarget.realmSet$columnByteList(realmObjectSource.realmGet$columnByteList());
+        realmObjectTarget.realmSet$columnDoubleList(realmObjectSource.realmGet$columnDoubleList());
+        realmObjectTarget.realmSet$columnFloatList(realmObjectSource.realmGet$columnFloatList());
+        realmObjectTarget.realmSet$columnDateList(realmObjectSource.realmGet$columnDateList());
         return realmObject;
     }
 
@@ -1223,7 +2255,7 @@ public String toString() {
         if (!RealmObject.isValid(this)) {
             return "Invalid object";
         }
-        StringBuilder stringBuilder = new StringBuilder("AllTypes = [");
+        StringBuilder stringBuilder = new StringBuilder("AllTypes = proxy[");
         stringBuilder.append("{columnString:");
         stringBuilder.append(realmGet$columnString() != null ? realmGet$columnString() : "null");
         stringBuilder.append("}");
@@ -1252,6 +2284,10 @@ public String toString() {
         stringBuilder.append(realmGet$columnBinary());
         stringBuilder.append("}");
         stringBuilder.append(",");
+        stringBuilder.append("{columnMutableRealmInteger:");
+        stringBuilder.append(realmGet$columnMutableRealmInteger().get());
+        stringBuilder.append("}");
+        stringBuilder.append(",");
         stringBuilder.append("{columnObject:");
         stringBuilder.append(realmGet$columnObject() != null ? "AllTypes" : "null");
         stringBuilder.append("}");
@@ -1259,6 +2295,46 @@ public String toString() {
         stringBuilder.append("{columnRealmList:");
         stringBuilder.append("RealmList<AllTypes>[").append(realmGet$columnRealmList().size()).append("]");
         stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnStringList:");
+        stringBuilder.append("RealmList<String>[").append(realmGet$columnStringList().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnBinaryList:");
+        stringBuilder.append("RealmList<byte[]>[").append(realmGet$columnBinaryList().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnBooleanList:");
+        stringBuilder.append("RealmList<Boolean>[").append(realmGet$columnBooleanList().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnLongList:");
+        stringBuilder.append("RealmList<Long>[").append(realmGet$columnLongList().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnIntegerList:");
+        stringBuilder.append("RealmList<Integer>[").append(realmGet$columnIntegerList().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnShortList:");
+        stringBuilder.append("RealmList<Short>[").append(realmGet$columnShortList().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnByteList:");
+        stringBuilder.append("RealmList<Byte>[").append(realmGet$columnByteList().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnDoubleList:");
+        stringBuilder.append("RealmList<Double>[").append(realmGet$columnDoubleList().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnFloatList:");
+        stringBuilder.append("RealmList<Float>[").append(realmGet$columnFloatList().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{columnDateList:");
+        stringBuilder.append("RealmList<Date>[").append(realmGet$columnDateList().size()).append("]");
+        stringBuilder.append("}");
         stringBuilder.append("]");
         return stringBuilder.toString();
     }
@@ -1299,5 +2375,4 @@ public boolean equals(Object o) {
 
         return true;
     }
-
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index 5a07ed0d92..28beeb3ebb 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -5,11 +5,14 @@
 import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
-import io.realm.RealmObjectSchema;
-import io.realm.RealmSchema;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.LinkView;
+import io.realm.internal.OsList;
+import io.realm.internal.OsObject;
+import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.OsSchemaInfo;
+import io.realm.internal.Property;
+import io.realm.internal.ProxyUtils;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
@@ -28,53 +31,50 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 
+@SuppressWarnings("all")
 public class BooleansRealmProxy extends some.test.Booleans
         implements RealmObjectProxy, BooleansRealmProxyInterface {
 
-    static final class BooleansColumnInfo extends ColumnInfo
-            implements Cloneable {
-
-        public long doneIndex;
-        public long isReadyIndex;
-        public long mCompletedIndex;
-        public long anotherBooleanIndex;
-
-        BooleansColumnInfo(String path, Table table) {
-            final Map<String, Long> indicesMap = new HashMap<String, Long>(4);
-            this.doneIndex = getValidColumnIndex(path, table, "Booleans", "done");
-            indicesMap.put("done", this.doneIndex);
-            this.isReadyIndex = getValidColumnIndex(path, table, "Booleans", "isReady");
-            indicesMap.put("isReady", this.isReadyIndex);
-            this.mCompletedIndex = getValidColumnIndex(path, table, "Booleans", "mCompleted");
-            indicesMap.put("mCompleted", this.mCompletedIndex);
-            this.anotherBooleanIndex = getValidColumnIndex(path, table, "Booleans", "anotherBoolean");
-            indicesMap.put("anotherBoolean", this.anotherBooleanIndex);
-
-            setIndicesMap(indicesMap);
+    static final class BooleansColumnInfo extends ColumnInfo {
+        long doneIndex;
+        long isReadyIndex;
+        long mCompletedIndex;
+        long anotherBooleanIndex;
+
+        BooleansColumnInfo(OsSchemaInfo schemaInfo) {
+            super(4);
+            OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo("Booleans");
+            this.doneIndex = addColumnDetails("done", objectSchemaInfo);
+            this.isReadyIndex = addColumnDetails("isReady", objectSchemaInfo);
+            this.mCompletedIndex = addColumnDetails("mCompleted", objectSchemaInfo);
+            this.anotherBooleanIndex = addColumnDetails("anotherBoolean", objectSchemaInfo);
         }
 
-        @Override
-        public final void copyColumnInfoFrom(ColumnInfo other) {
-            final BooleansColumnInfo otherInfo = (BooleansColumnInfo) other;
-            this.doneIndex = otherInfo.doneIndex;
-            this.isReadyIndex = otherInfo.isReadyIndex;
-            this.mCompletedIndex = otherInfo.mCompletedIndex;
-            this.anotherBooleanIndex = otherInfo.anotherBooleanIndex;
-
-            setIndicesMap(otherInfo.getIndicesMap());
+        BooleansColumnInfo(ColumnInfo src, boolean mutable) {
+            super(src, mutable);
+            copy(src, this);
         }
 
         @Override
-        public final BooleansColumnInfo clone() {
-            return (BooleansColumnInfo) super.clone();
+        protected final ColumnInfo copy(boolean mutable) {
+            return new BooleansColumnInfo(this, mutable);
         }
 
+        @Override
+        protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
+            final BooleansColumnInfo src = (BooleansColumnInfo) rawSrc;
+            final BooleansColumnInfo dst = (BooleansColumnInfo) rawDst;
+            dst.doneIndex = src.doneIndex;
+            dst.isReadyIndex = src.isReadyIndex;
+            dst.mCompletedIndex = src.mCompletedIndex;
+            dst.anotherBooleanIndex = src.anotherBooleanIndex;
+        }
     }
-    private BooleansColumnInfo columnInfo;
-    private ProxyState<some.test.Booleans> proxyState;
+
+    private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
     private static final List<String> FIELD_NAMES;
     static {
-        List<String> fieldNames = new ArrayList<String>();
+        List<String> fieldNames = new ArrayList<String>(4);
         fieldNames.add("done");
         fieldNames.add("isReady");
         fieldNames.add("mCompleted");
@@ -82,6 +82,9 @@ public final BooleansColumnInfo clone() {
         FIELD_NAMES = Collections.unmodifiableList(fieldNames);
     }
 
+    private BooleansColumnInfo columnInfo;
+    private ProxyState<some.test.Booleans> proxyState;
+
     BooleansRealmProxy() {
         proxyState.setConstructionFinished();
     }
@@ -188,87 +191,25 @@ public final BooleansColumnInfo clone() {
         proxyState.getRow$realm().setBoolean(columnInfo.anotherBooleanIndex, value);
     }
 
-    public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
-        if (!realmSchema.contains("Booleans")) {
-            RealmObjectSchema realmObjectSchema = realmSchema.create("Booleans");
-            realmObjectSchema.add("done", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-            realmObjectSchema.add("isReady", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-            realmObjectSchema.add("mCompleted", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-            realmObjectSchema.add("anotherBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-            return realmObjectSchema;
-        }
-        return realmSchema.get("Booleans");
+    private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
+        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("Booleans", 4, 0);
+        builder.addPersistedProperty("done", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("isReady", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("mCompleted", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("anotherBoolean", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        return builder.build();
     }
 
-    public static BooleansColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
-        if (!sharedRealm.hasTable("class_Booleans")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'Booleans' class is missing from the schema for this Realm.");
-        }
-        Table table = sharedRealm.getTable("class_Booleans");
-        final long columnCount = table.getColumnCount();
-        if (columnCount != 4) {
-            if (columnCount < 4) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 4 but was " + columnCount);
-            }
-            if (allowExtraColumns) {
-                RealmLog.debug("Field count is more than expected - expected 4 but was %1$d", columnCount);
-            } else {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 4 but was " + columnCount);
-            }
-        }
-        Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
-        for (long i = 0; i < columnCount; i++) {
-            columnTypes.put(table.getColumnName(i), table.getColumnType(i));
-        }
-
-        final BooleansColumnInfo columnInfo = new BooleansColumnInfo(sharedRealm.getPath(), table);
-
-        if (table.hasPrimaryKey()) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key defined for field " + table.getColumnName(table.getPrimaryKey()) + " was removed.");
-        }
-
-        if (!columnTypes.containsKey("done")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'done' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("done") != RealmFieldType.BOOLEAN) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'done' in existing Realm file.");
-        }
-        if (table.isColumnNullable(columnInfo.doneIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'done' does support null values in the existing Realm file. Use corresponding boxed type for field 'done' or migrate using RealmObjectSchema.setNullable().");
-        }
-        if (!columnTypes.containsKey("isReady")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'isReady' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("isReady") != RealmFieldType.BOOLEAN) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'isReady' in existing Realm file.");
-        }
-        if (table.isColumnNullable(columnInfo.isReadyIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'isReady' does support null values in the existing Realm file. Use corresponding boxed type for field 'isReady' or migrate using RealmObjectSchema.setNullable().");
-        }
-        if (!columnTypes.containsKey("mCompleted")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'mCompleted' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("mCompleted") != RealmFieldType.BOOLEAN) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'mCompleted' in existing Realm file.");
-        }
-        if (table.isColumnNullable(columnInfo.mCompletedIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'mCompleted' does support null values in the existing Realm file. Use corresponding boxed type for field 'mCompleted' or migrate using RealmObjectSchema.setNullable().");
-        }
-        if (!columnTypes.containsKey("anotherBoolean")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'anotherBoolean' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("anotherBoolean") != RealmFieldType.BOOLEAN) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'boolean' for field 'anotherBoolean' in existing Realm file.");
-        }
-        if (table.isColumnNullable(columnInfo.anotherBooleanIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'anotherBoolean' does support null values in the existing Realm file. Use corresponding boxed type for field 'anotherBoolean' or migrate using RealmObjectSchema.setNullable().");
-        }
+    public static OsObjectSchemaInfo getExpectedObjectSchemaInfo() {
+        return expectedObjectSchemaInfo;
+    }
 
-        return columnInfo;
+    public static BooleansColumnInfo createColumnInfo(OsSchemaInfo schemaInfo) {
+        return new BooleansColumnInfo(schemaInfo);
     }
 
-    public static String getTableName() {
-        return "class_Booleans";
+    public static String getSimpleClassName() {
+        return "Booleans";
     }
 
     public static List<String> getFieldNames() {
@@ -280,32 +221,34 @@ public static String getTableName() {
             throws JSONException {
         final List<String> excludeFields = Collections.<String> emptyList();
         some.test.Booleans obj = realm.createObjectInternal(some.test.Booleans.class, true, excludeFields);
+
+        final BooleansRealmProxyInterface objProxy = (BooleansRealmProxyInterface) obj;
         if (json.has("done")) {
             if (json.isNull("done")) {
                 throw new IllegalArgumentException("Trying to set non-nullable field 'done' to null.");
             } else {
-                ((BooleansRealmProxyInterface) obj).realmSet$done((boolean) json.getBoolean("done"));
+                objProxy.realmSet$done((boolean) json.getBoolean("done"));
             }
         }
         if (json.has("isReady")) {
             if (json.isNull("isReady")) {
                 throw new IllegalArgumentException("Trying to set non-nullable field 'isReady' to null.");
             } else {
-                ((BooleansRealmProxyInterface) obj).realmSet$isReady((boolean) json.getBoolean("isReady"));
+                objProxy.realmSet$isReady((boolean) json.getBoolean("isReady"));
             }
         }
         if (json.has("mCompleted")) {
             if (json.isNull("mCompleted")) {
                 throw new IllegalArgumentException("Trying to set non-nullable field 'mCompleted' to null.");
             } else {
-                ((BooleansRealmProxyInterface) obj).realmSet$mCompleted((boolean) json.getBoolean("mCompleted"));
+                objProxy.realmSet$mCompleted((boolean) json.getBoolean("mCompleted"));
             }
         }
         if (json.has("anotherBoolean")) {
             if (json.isNull("anotherBoolean")) {
                 throw new IllegalArgumentException("Trying to set non-nullable field 'anotherBoolean' to null.");
             } else {
-                ((BooleansRealmProxyInterface) obj).realmSet$anotherBoolean((boolean) json.getBoolean("anotherBoolean"));
+                objProxy.realmSet$anotherBoolean((boolean) json.getBoolean("anotherBoolean"));
             }
         }
         return obj;
@@ -315,153 +258,162 @@ public static String getTableName() {
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
     public static some.test.Booleans createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        some.test.Booleans obj = new some.test.Booleans();
+        final some.test.Booleans obj = new some.test.Booleans();
+        final BooleansRealmProxyInterface objProxy = (BooleansRealmProxyInterface) obj;
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
             if (false) {
             } else if (name.equals("done")) {
-                if (reader.peek() == JsonToken.NULL) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$done((boolean) reader.nextBoolean());
+                } else {
                     reader.skipValue();
                     throw new IllegalArgumentException("Trying to set non-nullable field 'done' to null.");
-                } else {
-                    ((BooleansRealmProxyInterface) obj).realmSet$done((boolean) reader.nextBoolean());
                 }
             } else if (name.equals("isReady")) {
-                if (reader.peek() == JsonToken.NULL) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$isReady((boolean) reader.nextBoolean());
+                } else {
                     reader.skipValue();
                     throw new IllegalArgumentException("Trying to set non-nullable field 'isReady' to null.");
-                } else {
-                    ((BooleansRealmProxyInterface) obj).realmSet$isReady((boolean) reader.nextBoolean());
                 }
             } else if (name.equals("mCompleted")) {
-                if (reader.peek() == JsonToken.NULL) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$mCompleted((boolean) reader.nextBoolean());
+                } else {
                     reader.skipValue();
                     throw new IllegalArgumentException("Trying to set non-nullable field 'mCompleted' to null.");
-                } else {
-                    ((BooleansRealmProxyInterface) obj).realmSet$mCompleted((boolean) reader.nextBoolean());
                 }
             } else if (name.equals("anotherBoolean")) {
-                if (reader.peek() == JsonToken.NULL) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$anotherBoolean((boolean) reader.nextBoolean());
+                } else {
                     reader.skipValue();
                     throw new IllegalArgumentException("Trying to set non-nullable field 'anotherBoolean' to null.");
-                } else {
-                    ((BooleansRealmProxyInterface) obj).realmSet$anotherBoolean((boolean) reader.nextBoolean());
                 }
             } else {
                 reader.skipValue();
             }
         }
         reader.endObject();
-        obj = realm.copyToRealm(obj);
-        return obj;
+        return realm.copyToRealm(obj);
     }
 
     public static some.test.Booleans copyOrUpdate(Realm realm, some.test.Booleans object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
-            throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
-        }
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-            return object;
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null) {
+            final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm();
+            if (otherRealm.threadId != realm.threadId) {
+                throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
+            }
+            if (otherRealm.getPath().equals(realm.getPath())) {
+                return object;
+            }
         }
         final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
         RealmObjectProxy cachedRealmObject = cache.get(object);
         if (cachedRealmObject != null) {
             return (some.test.Booleans) cachedRealmObject;
-        } else {
-            return copy(realm, object, update, cache);
         }
+
+        return copy(realm, object, update, cache);
     }
 
     public static some.test.Booleans copy(Realm realm, some.test.Booleans newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
         RealmObjectProxy cachedRealmObject = cache.get(newObject);
         if (cachedRealmObject != null) {
             return (some.test.Booleans) cachedRealmObject;
-        } else {
-            // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
-            some.test.Booleans realmObject = realm.createObjectInternal(some.test.Booleans.class, false, Collections.<String>emptyList());
-            cache.put(newObject, (RealmObjectProxy) realmObject);
-            ((BooleansRealmProxyInterface) realmObject).realmSet$done(((BooleansRealmProxyInterface) newObject).realmGet$done());
-            ((BooleansRealmProxyInterface) realmObject).realmSet$isReady(((BooleansRealmProxyInterface) newObject).realmGet$isReady());
-            ((BooleansRealmProxyInterface) realmObject).realmSet$mCompleted(((BooleansRealmProxyInterface) newObject).realmGet$mCompleted());
-            ((BooleansRealmProxyInterface) realmObject).realmSet$anotherBoolean(((BooleansRealmProxyInterface) newObject).realmGet$anotherBoolean());
-            return realmObject;
         }
+
+        // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
+        some.test.Booleans realmObject = realm.createObjectInternal(some.test.Booleans.class, false, Collections.<String>emptyList());
+        cache.put(newObject, (RealmObjectProxy) realmObject);
+
+        BooleansRealmProxyInterface realmObjectSource = (BooleansRealmProxyInterface) newObject;
+        BooleansRealmProxyInterface realmObjectCopy = (BooleansRealmProxyInterface) realmObject;
+
+        realmObjectCopy.realmSet$done(realmObjectSource.realmGet$done());
+        realmObjectCopy.realmSet$isReady(realmObjectSource.realmGet$isReady());
+        realmObjectCopy.realmSet$mCompleted(realmObjectSource.realmGet$mCompleted());
+        realmObjectCopy.realmSet$anotherBoolean(realmObjectSource.realmGet$anotherBoolean());
+        return realmObject;
     }
 
     public static long insert(Realm realm, some.test.Booleans object, Map<RealmModel,Long> cache) {
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-            return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+            return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex();
         }
         Table table = realm.getTable(some.test.Booleans.class);
-        long tableNativePtr = table.getNativeTablePointer();
-        BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(some.test.Booleans.class);
-        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+        long tableNativePtr = table.getNativePtr();
+        BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.getSchema().getColumnInfo(some.test.Booleans.class);
+        long rowIndex = OsObject.createRow(table);
         cache.put(object, rowIndex);
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done(), false);
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady(), false);
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted(), false);
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface) object).realmGet$done(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface) object).realmGet$isReady(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface) object).realmGet$mCompleted(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface) object).realmGet$anotherBoolean(), false);
         return rowIndex;
     }
 
     public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
         Table table = realm.getTable(some.test.Booleans.class);
-        long tableNativePtr = table.getNativeTablePointer();
-        BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(some.test.Booleans.class);
+        long tableNativePtr = table.getNativePtr();
+        BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.getSchema().getColumnInfo(some.test.Booleans.class);
         some.test.Booleans object = null;
         while (objects.hasNext()) {
             object = (some.test.Booleans) objects.next();
-            if(!cache.containsKey(object)) {
-                if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-                    cache.put(object, ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex());
-                    continue;
-                }
-                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
-                cache.put(object, rowIndex);
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done(), false);
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady(), false);
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted(), false);
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean(), false);
+            if (cache.containsKey(object)) {
+                continue;
             }
+            if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex());
+                continue;
+            }
+            long rowIndex = OsObject.createRow(table);
+            cache.put(object, rowIndex);
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface) object).realmGet$done(), false);
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface) object).realmGet$isReady(), false);
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface) object).realmGet$mCompleted(), false);
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface) object).realmGet$anotherBoolean(), false);
         }
     }
 
     public static long insertOrUpdate(Realm realm, some.test.Booleans object, Map<RealmModel,Long> cache) {
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-            return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+            return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex();
         }
         Table table = realm.getTable(some.test.Booleans.class);
-        long tableNativePtr = table.getNativeTablePointer();
-        BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(some.test.Booleans.class);
-        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+        long tableNativePtr = table.getNativePtr();
+        BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.getSchema().getColumnInfo(some.test.Booleans.class);
+        long rowIndex = OsObject.createRow(table);
         cache.put(object, rowIndex);
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done(), false);
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady(), false);
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted(), false);
-        Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface) object).realmGet$done(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface) object).realmGet$isReady(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface) object).realmGet$mCompleted(), false);
+        Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface) object).realmGet$anotherBoolean(), false);
         return rowIndex;
     }
 
     public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
         Table table = realm.getTable(some.test.Booleans.class);
-        long tableNativePtr = table.getNativeTablePointer();
-        BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.schema.getColumnInfo(some.test.Booleans.class);
+        long tableNativePtr = table.getNativePtr();
+        BooleansColumnInfo columnInfo = (BooleansColumnInfo) realm.getSchema().getColumnInfo(some.test.Booleans.class);
         some.test.Booleans object = null;
         while (objects.hasNext()) {
             object = (some.test.Booleans) objects.next();
-            if(!cache.containsKey(object)) {
-                if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-                    cache.put(object, ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex());
-                    continue;
-                }
-                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
-                cache.put(object, rowIndex);
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$done(), false);
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$isReady(), false);
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$mCompleted(), false);
-                Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface)object).realmGet$anotherBoolean(), false);
+            if (cache.containsKey(object)) {
+                continue;
             }
+            if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex());
+                continue;
+            }
+            long rowIndex = OsObject.createRow(table);
+            cache.put(object, rowIndex);
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.doneIndex, rowIndex, ((BooleansRealmProxyInterface) object).realmGet$done(), false);
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.isReadyIndex, rowIndex, ((BooleansRealmProxyInterface) object).realmGet$isReady(), false);
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.mCompletedIndex, rowIndex, ((BooleansRealmProxyInterface) object).realmGet$mCompleted(), false);
+            Table.nativeSetBoolean(tableNativePtr, columnInfo.anotherBooleanIndex, rowIndex, ((BooleansRealmProxyInterface) object).realmGet$anotherBoolean(), false);
         }
     }
 
@@ -471,22 +423,24 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
         }
         CacheData<RealmModel> cachedObject = cache.get(realmObject);
         some.test.Booleans unmanagedObject;
-        if (cachedObject != null) {
+        if (cachedObject == null) {
+            unmanagedObject = new some.test.Booleans();
+            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject));
+        } else {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
             if (currentDepth >= cachedObject.minDepth) {
-                return (some.test.Booleans)cachedObject.object;
-            } else {
-                unmanagedObject = (some.test.Booleans)cachedObject.object;
-                cachedObject.minDepth = currentDepth;
+                return (some.test.Booleans) cachedObject.object;
             }
-        } else {
-            unmanagedObject = new some.test.Booleans();
-            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject));
+            unmanagedObject = (some.test.Booleans) cachedObject.object;
+            cachedObject.minDepth = currentDepth;
         }
-        ((BooleansRealmProxyInterface) unmanagedObject).realmSet$done(((BooleansRealmProxyInterface) realmObject).realmGet$done());
-        ((BooleansRealmProxyInterface) unmanagedObject).realmSet$isReady(((BooleansRealmProxyInterface) realmObject).realmGet$isReady());
-        ((BooleansRealmProxyInterface) unmanagedObject).realmSet$mCompleted(((BooleansRealmProxyInterface) realmObject).realmGet$mCompleted());
-        ((BooleansRealmProxyInterface) unmanagedObject).realmSet$anotherBoolean(((BooleansRealmProxyInterface) realmObject).realmGet$anotherBoolean());
+        BooleansRealmProxyInterface unmanagedCopy = (BooleansRealmProxyInterface) unmanagedObject;
+        BooleansRealmProxyInterface realmSource = (BooleansRealmProxyInterface) realmObject;
+        unmanagedCopy.realmSet$done(realmSource.realmGet$done());
+        unmanagedCopy.realmSet$isReady(realmSource.realmGet$isReady());
+        unmanagedCopy.realmSet$mCompleted(realmSource.realmGet$mCompleted());
+        unmanagedCopy.realmSet$anotherBoolean(realmSource.realmGet$anotherBoolean());
+
         return unmanagedObject;
     }
 
@@ -496,7 +450,7 @@ public String toString() {
         if (!RealmObject.isValid(this)) {
             return "Invalid object";
         }
-        StringBuilder stringBuilder = new StringBuilder("Booleans = [");
+        StringBuilder stringBuilder = new StringBuilder("Booleans = proxy[");
         stringBuilder.append("{done:");
         stringBuilder.append(realmGet$done());
         stringBuilder.append("}");
@@ -552,5 +506,4 @@ public boolean equals(Object o) {
 
         return true;
     }
-
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index c91b122f0c..65562e6d8e 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -5,11 +5,14 @@
 import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
-import io.realm.RealmObjectSchema;
-import io.realm.RealmSchema;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.LinkView;
+import io.realm.internal.OsList;
+import io.realm.internal.OsObject;
+import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.OsSchemaInfo;
+import io.realm.internal.Property;
+import io.realm.internal.ProxyUtils;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
@@ -28,121 +31,161 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 
+@SuppressWarnings("all")
 public class NullTypesRealmProxy extends some.test.NullTypes
         implements RealmObjectProxy, NullTypesRealmProxyInterface {
 
-    static final class NullTypesColumnInfo extends ColumnInfo
-            implements Cloneable {
-
-        public long fieldStringNotNullIndex;
-        public long fieldStringNullIndex;
-        public long fieldBooleanNotNullIndex;
-        public long fieldBooleanNullIndex;
-        public long fieldBytesNotNullIndex;
-        public long fieldBytesNullIndex;
-        public long fieldByteNotNullIndex;
-        public long fieldByteNullIndex;
-        public long fieldShortNotNullIndex;
-        public long fieldShortNullIndex;
-        public long fieldIntegerNotNullIndex;
-        public long fieldIntegerNullIndex;
-        public long fieldLongNotNullIndex;
-        public long fieldLongNullIndex;
-        public long fieldFloatNotNullIndex;
-        public long fieldFloatNullIndex;
-        public long fieldDoubleNotNullIndex;
-        public long fieldDoubleNullIndex;
-        public long fieldDateNotNullIndex;
-        public long fieldDateNullIndex;
-        public long fieldObjectNullIndex;
-
-        NullTypesColumnInfo(String path, Table table) {
-            final Map<String, Long> indicesMap = new HashMap<String, Long>(21);
-            this.fieldStringNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldStringNotNull");
-            indicesMap.put("fieldStringNotNull", this.fieldStringNotNullIndex);
-            this.fieldStringNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldStringNull");
-            indicesMap.put("fieldStringNull", this.fieldStringNullIndex);
-            this.fieldBooleanNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldBooleanNotNull");
-            indicesMap.put("fieldBooleanNotNull", this.fieldBooleanNotNullIndex);
-            this.fieldBooleanNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldBooleanNull");
-            indicesMap.put("fieldBooleanNull", this.fieldBooleanNullIndex);
-            this.fieldBytesNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldBytesNotNull");
-            indicesMap.put("fieldBytesNotNull", this.fieldBytesNotNullIndex);
-            this.fieldBytesNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldBytesNull");
-            indicesMap.put("fieldBytesNull", this.fieldBytesNullIndex);
-            this.fieldByteNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldByteNotNull");
-            indicesMap.put("fieldByteNotNull", this.fieldByteNotNullIndex);
-            this.fieldByteNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldByteNull");
-            indicesMap.put("fieldByteNull", this.fieldByteNullIndex);
-            this.fieldShortNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldShortNotNull");
-            indicesMap.put("fieldShortNotNull", this.fieldShortNotNullIndex);
-            this.fieldShortNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldShortNull");
-            indicesMap.put("fieldShortNull", this.fieldShortNullIndex);
-            this.fieldIntegerNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldIntegerNotNull");
-            indicesMap.put("fieldIntegerNotNull", this.fieldIntegerNotNullIndex);
-            this.fieldIntegerNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldIntegerNull");
-            indicesMap.put("fieldIntegerNull", this.fieldIntegerNullIndex);
-            this.fieldLongNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldLongNotNull");
-            indicesMap.put("fieldLongNotNull", this.fieldLongNotNullIndex);
-            this.fieldLongNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldLongNull");
-            indicesMap.put("fieldLongNull", this.fieldLongNullIndex);
-            this.fieldFloatNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldFloatNotNull");
-            indicesMap.put("fieldFloatNotNull", this.fieldFloatNotNullIndex);
-            this.fieldFloatNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldFloatNull");
-            indicesMap.put("fieldFloatNull", this.fieldFloatNullIndex);
-            this.fieldDoubleNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldDoubleNotNull");
-            indicesMap.put("fieldDoubleNotNull", this.fieldDoubleNotNullIndex);
-            this.fieldDoubleNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldDoubleNull");
-            indicesMap.put("fieldDoubleNull", this.fieldDoubleNullIndex);
-            this.fieldDateNotNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldDateNotNull");
-            indicesMap.put("fieldDateNotNull", this.fieldDateNotNullIndex);
-            this.fieldDateNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldDateNull");
-            indicesMap.put("fieldDateNull", this.fieldDateNullIndex);
-            this.fieldObjectNullIndex = getValidColumnIndex(path, table, "NullTypes", "fieldObjectNull");
-            indicesMap.put("fieldObjectNull", this.fieldObjectNullIndex);
-
-            setIndicesMap(indicesMap);
+    static final class NullTypesColumnInfo extends ColumnInfo {
+        long fieldStringNotNullIndex;
+        long fieldStringNullIndex;
+        long fieldBooleanNotNullIndex;
+        long fieldBooleanNullIndex;
+        long fieldBytesNotNullIndex;
+        long fieldBytesNullIndex;
+        long fieldByteNotNullIndex;
+        long fieldByteNullIndex;
+        long fieldShortNotNullIndex;
+        long fieldShortNullIndex;
+        long fieldIntegerNotNullIndex;
+        long fieldIntegerNullIndex;
+        long fieldLongNotNullIndex;
+        long fieldLongNullIndex;
+        long fieldFloatNotNullIndex;
+        long fieldFloatNullIndex;
+        long fieldDoubleNotNullIndex;
+        long fieldDoubleNullIndex;
+        long fieldDateNotNullIndex;
+        long fieldDateNullIndex;
+        long fieldObjectNullIndex;
+        long fieldStringListNotNullIndex;
+        long fieldStringListNullIndex;
+        long fieldBinaryListNotNullIndex;
+        long fieldBinaryListNullIndex;
+        long fieldBooleanListNotNullIndex;
+        long fieldBooleanListNullIndex;
+        long fieldLongListNotNullIndex;
+        long fieldLongListNullIndex;
+        long fieldIntegerListNotNullIndex;
+        long fieldIntegerListNullIndex;
+        long fieldShortListNotNullIndex;
+        long fieldShortListNullIndex;
+        long fieldByteListNotNullIndex;
+        long fieldByteListNullIndex;
+        long fieldDoubleListNotNullIndex;
+        long fieldDoubleListNullIndex;
+        long fieldFloatListNotNullIndex;
+        long fieldFloatListNullIndex;
+        long fieldDateListNotNullIndex;
+        long fieldDateListNullIndex;
+
+        NullTypesColumnInfo(OsSchemaInfo schemaInfo) {
+            super(41);
+            OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo("NullTypes");
+            this.fieldStringNotNullIndex = addColumnDetails("fieldStringNotNull", objectSchemaInfo);
+            this.fieldStringNullIndex = addColumnDetails("fieldStringNull", objectSchemaInfo);
+            this.fieldBooleanNotNullIndex = addColumnDetails("fieldBooleanNotNull", objectSchemaInfo);
+            this.fieldBooleanNullIndex = addColumnDetails("fieldBooleanNull", objectSchemaInfo);
+            this.fieldBytesNotNullIndex = addColumnDetails("fieldBytesNotNull", objectSchemaInfo);
+            this.fieldBytesNullIndex = addColumnDetails("fieldBytesNull", objectSchemaInfo);
+            this.fieldByteNotNullIndex = addColumnDetails("fieldByteNotNull", objectSchemaInfo);
+            this.fieldByteNullIndex = addColumnDetails("fieldByteNull", objectSchemaInfo);
+            this.fieldShortNotNullIndex = addColumnDetails("fieldShortNotNull", objectSchemaInfo);
+            this.fieldShortNullIndex = addColumnDetails("fieldShortNull", objectSchemaInfo);
+            this.fieldIntegerNotNullIndex = addColumnDetails("fieldIntegerNotNull", objectSchemaInfo);
+            this.fieldIntegerNullIndex = addColumnDetails("fieldIntegerNull", objectSchemaInfo);
+            this.fieldLongNotNullIndex = addColumnDetails("fieldLongNotNull", objectSchemaInfo);
+            this.fieldLongNullIndex = addColumnDetails("fieldLongNull", objectSchemaInfo);
+            this.fieldFloatNotNullIndex = addColumnDetails("fieldFloatNotNull", objectSchemaInfo);
+            this.fieldFloatNullIndex = addColumnDetails("fieldFloatNull", objectSchemaInfo);
+            this.fieldDoubleNotNullIndex = addColumnDetails("fieldDoubleNotNull", objectSchemaInfo);
+            this.fieldDoubleNullIndex = addColumnDetails("fieldDoubleNull", objectSchemaInfo);
+            this.fieldDateNotNullIndex = addColumnDetails("fieldDateNotNull", objectSchemaInfo);
+            this.fieldDateNullIndex = addColumnDetails("fieldDateNull", objectSchemaInfo);
+            this.fieldObjectNullIndex = addColumnDetails("fieldObjectNull", objectSchemaInfo);
+            this.fieldStringListNotNullIndex = addColumnDetails("fieldStringListNotNull", objectSchemaInfo);
+            this.fieldStringListNullIndex = addColumnDetails("fieldStringListNull", objectSchemaInfo);
+            this.fieldBinaryListNotNullIndex = addColumnDetails("fieldBinaryListNotNull", objectSchemaInfo);
+            this.fieldBinaryListNullIndex = addColumnDetails("fieldBinaryListNull", objectSchemaInfo);
+            this.fieldBooleanListNotNullIndex = addColumnDetails("fieldBooleanListNotNull", objectSchemaInfo);
+            this.fieldBooleanListNullIndex = addColumnDetails("fieldBooleanListNull", objectSchemaInfo);
+            this.fieldLongListNotNullIndex = addColumnDetails("fieldLongListNotNull", objectSchemaInfo);
+            this.fieldLongListNullIndex = addColumnDetails("fieldLongListNull", objectSchemaInfo);
+            this.fieldIntegerListNotNullIndex = addColumnDetails("fieldIntegerListNotNull", objectSchemaInfo);
+            this.fieldIntegerListNullIndex = addColumnDetails("fieldIntegerListNull", objectSchemaInfo);
+            this.fieldShortListNotNullIndex = addColumnDetails("fieldShortListNotNull", objectSchemaInfo);
+            this.fieldShortListNullIndex = addColumnDetails("fieldShortListNull", objectSchemaInfo);
+            this.fieldByteListNotNullIndex = addColumnDetails("fieldByteListNotNull", objectSchemaInfo);
+            this.fieldByteListNullIndex = addColumnDetails("fieldByteListNull", objectSchemaInfo);
+            this.fieldDoubleListNotNullIndex = addColumnDetails("fieldDoubleListNotNull", objectSchemaInfo);
+            this.fieldDoubleListNullIndex = addColumnDetails("fieldDoubleListNull", objectSchemaInfo);
+            this.fieldFloatListNotNullIndex = addColumnDetails("fieldFloatListNotNull", objectSchemaInfo);
+            this.fieldFloatListNullIndex = addColumnDetails("fieldFloatListNull", objectSchemaInfo);
+            this.fieldDateListNotNullIndex = addColumnDetails("fieldDateListNotNull", objectSchemaInfo);
+            this.fieldDateListNullIndex = addColumnDetails("fieldDateListNull", objectSchemaInfo);
         }
 
-        @Override
-        public final void copyColumnInfoFrom(ColumnInfo other) {
-            final NullTypesColumnInfo otherInfo = (NullTypesColumnInfo) other;
-            this.fieldStringNotNullIndex = otherInfo.fieldStringNotNullIndex;
-            this.fieldStringNullIndex = otherInfo.fieldStringNullIndex;
-            this.fieldBooleanNotNullIndex = otherInfo.fieldBooleanNotNullIndex;
-            this.fieldBooleanNullIndex = otherInfo.fieldBooleanNullIndex;
-            this.fieldBytesNotNullIndex = otherInfo.fieldBytesNotNullIndex;
-            this.fieldBytesNullIndex = otherInfo.fieldBytesNullIndex;
-            this.fieldByteNotNullIndex = otherInfo.fieldByteNotNullIndex;
-            this.fieldByteNullIndex = otherInfo.fieldByteNullIndex;
-            this.fieldShortNotNullIndex = otherInfo.fieldShortNotNullIndex;
-            this.fieldShortNullIndex = otherInfo.fieldShortNullIndex;
-            this.fieldIntegerNotNullIndex = otherInfo.fieldIntegerNotNullIndex;
-            this.fieldIntegerNullIndex = otherInfo.fieldIntegerNullIndex;
-            this.fieldLongNotNullIndex = otherInfo.fieldLongNotNullIndex;
-            this.fieldLongNullIndex = otherInfo.fieldLongNullIndex;
-            this.fieldFloatNotNullIndex = otherInfo.fieldFloatNotNullIndex;
-            this.fieldFloatNullIndex = otherInfo.fieldFloatNullIndex;
-            this.fieldDoubleNotNullIndex = otherInfo.fieldDoubleNotNullIndex;
-            this.fieldDoubleNullIndex = otherInfo.fieldDoubleNullIndex;
-            this.fieldDateNotNullIndex = otherInfo.fieldDateNotNullIndex;
-            this.fieldDateNullIndex = otherInfo.fieldDateNullIndex;
-            this.fieldObjectNullIndex = otherInfo.fieldObjectNullIndex;
-
-            setIndicesMap(otherInfo.getIndicesMap());
+        NullTypesColumnInfo(ColumnInfo src, boolean mutable) {
+            super(src, mutable);
+            copy(src, this);
         }
 
         @Override
-        public final NullTypesColumnInfo clone() {
-            return (NullTypesColumnInfo) super.clone();
+        protected final ColumnInfo copy(boolean mutable) {
+            return new NullTypesColumnInfo(this, mutable);
         }
 
+        @Override
+        protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
+            final NullTypesColumnInfo src = (NullTypesColumnInfo) rawSrc;
+            final NullTypesColumnInfo dst = (NullTypesColumnInfo) rawDst;
+            dst.fieldStringNotNullIndex = src.fieldStringNotNullIndex;
+            dst.fieldStringNullIndex = src.fieldStringNullIndex;
+            dst.fieldBooleanNotNullIndex = src.fieldBooleanNotNullIndex;
+            dst.fieldBooleanNullIndex = src.fieldBooleanNullIndex;
+            dst.fieldBytesNotNullIndex = src.fieldBytesNotNullIndex;
+            dst.fieldBytesNullIndex = src.fieldBytesNullIndex;
+            dst.fieldByteNotNullIndex = src.fieldByteNotNullIndex;
+            dst.fieldByteNullIndex = src.fieldByteNullIndex;
+            dst.fieldShortNotNullIndex = src.fieldShortNotNullIndex;
+            dst.fieldShortNullIndex = src.fieldShortNullIndex;
+            dst.fieldIntegerNotNullIndex = src.fieldIntegerNotNullIndex;
+            dst.fieldIntegerNullIndex = src.fieldIntegerNullIndex;
+            dst.fieldLongNotNullIndex = src.fieldLongNotNullIndex;
+            dst.fieldLongNullIndex = src.fieldLongNullIndex;
+            dst.fieldFloatNotNullIndex = src.fieldFloatNotNullIndex;
+            dst.fieldFloatNullIndex = src.fieldFloatNullIndex;
+            dst.fieldDoubleNotNullIndex = src.fieldDoubleNotNullIndex;
+            dst.fieldDoubleNullIndex = src.fieldDoubleNullIndex;
+            dst.fieldDateNotNullIndex = src.fieldDateNotNullIndex;
+            dst.fieldDateNullIndex = src.fieldDateNullIndex;
+            dst.fieldObjectNullIndex = src.fieldObjectNullIndex;
+            dst.fieldStringListNotNullIndex = src.fieldStringListNotNullIndex;
+            dst.fieldStringListNullIndex = src.fieldStringListNullIndex;
+            dst.fieldBinaryListNotNullIndex = src.fieldBinaryListNotNullIndex;
+            dst.fieldBinaryListNullIndex = src.fieldBinaryListNullIndex;
+            dst.fieldBooleanListNotNullIndex = src.fieldBooleanListNotNullIndex;
+            dst.fieldBooleanListNullIndex = src.fieldBooleanListNullIndex;
+            dst.fieldLongListNotNullIndex = src.fieldLongListNotNullIndex;
+            dst.fieldLongListNullIndex = src.fieldLongListNullIndex;
+            dst.fieldIntegerListNotNullIndex = src.fieldIntegerListNotNullIndex;
+            dst.fieldIntegerListNullIndex = src.fieldIntegerListNullIndex;
+            dst.fieldShortListNotNullIndex = src.fieldShortListNotNullIndex;
+            dst.fieldShortListNullIndex = src.fieldShortListNullIndex;
+            dst.fieldByteListNotNullIndex = src.fieldByteListNotNullIndex;
+            dst.fieldByteListNullIndex = src.fieldByteListNullIndex;
+            dst.fieldDoubleListNotNullIndex = src.fieldDoubleListNotNullIndex;
+            dst.fieldDoubleListNullIndex = src.fieldDoubleListNullIndex;
+            dst.fieldFloatListNotNullIndex = src.fieldFloatListNotNullIndex;
+            dst.fieldFloatListNullIndex = src.fieldFloatListNullIndex;
+            dst.fieldDateListNotNullIndex = src.fieldDateListNotNullIndex;
+            dst.fieldDateListNullIndex = src.fieldDateListNullIndex;
+        }
     }
-    private NullTypesColumnInfo columnInfo;
-    private ProxyState<some.test.NullTypes> proxyState;
+
+    private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
     private static final List<String> FIELD_NAMES;
     static {
-        List<String> fieldNames = new ArrayList<String>();
+        List<String> fieldNames = new ArrayList<String>(41);
         fieldNames.add("fieldStringNotNull");
         fieldNames.add("fieldStringNull");
         fieldNames.add("fieldBooleanNotNull");
@@ -164,9 +207,52 @@ public final NullTypesColumnInfo clone() {
         fieldNames.add("fieldDateNotNull");
         fieldNames.add("fieldDateNull");
         fieldNames.add("fieldObjectNull");
+        fieldNames.add("fieldStringListNotNull");
+        fieldNames.add("fieldStringListNull");
+        fieldNames.add("fieldBinaryListNotNull");
+        fieldNames.add("fieldBinaryListNull");
+        fieldNames.add("fieldBooleanListNotNull");
+        fieldNames.add("fieldBooleanListNull");
+        fieldNames.add("fieldLongListNotNull");
+        fieldNames.add("fieldLongListNull");
+        fieldNames.add("fieldIntegerListNotNull");
+        fieldNames.add("fieldIntegerListNull");
+        fieldNames.add("fieldShortListNotNull");
+        fieldNames.add("fieldShortListNull");
+        fieldNames.add("fieldByteListNotNull");
+        fieldNames.add("fieldByteListNull");
+        fieldNames.add("fieldDoubleListNotNull");
+        fieldNames.add("fieldDoubleListNull");
+        fieldNames.add("fieldFloatListNotNull");
+        fieldNames.add("fieldFloatListNull");
+        fieldNames.add("fieldDateListNotNull");
+        fieldNames.add("fieldDateListNull");
         FIELD_NAMES = Collections.unmodifiableList(fieldNames);
     }
 
+    private NullTypesColumnInfo columnInfo;
+    private ProxyState<some.test.NullTypes> proxyState;
+    private RealmList<String> fieldStringListNotNullRealmList;
+    private RealmList<String> fieldStringListNullRealmList;
+    private RealmList<byte[]> fieldBinaryListNotNullRealmList;
+    private RealmList<byte[]> fieldBinaryListNullRealmList;
+    private RealmList<Boolean> fieldBooleanListNotNullRealmList;
+    private RealmList<Boolean> fieldBooleanListNullRealmList;
+    private RealmList<Long> fieldLongListNotNullRealmList;
+    private RealmList<Long> fieldLongListNullRealmList;
+    private RealmList<Integer> fieldIntegerListNotNullRealmList;
+    private RealmList<Integer> fieldIntegerListNullRealmList;
+    private RealmList<Short> fieldShortListNotNullRealmList;
+    private RealmList<Short> fieldShortListNullRealmList;
+    private RealmList<Byte> fieldByteListNotNullRealmList;
+    private RealmList<Byte> fieldByteListNullRealmList;
+    private RealmList<Double> fieldDoubleListNotNullRealmList;
+    private RealmList<Double> fieldDoubleListNullRealmList;
+    private RealmList<Float> fieldFloatListNotNullRealmList;
+    private RealmList<Float> fieldFloatListNullRealmList;
+    private RealmList<Date> fieldDateListNotNullRealmList;
+    private RealmList<Date> fieldDateListNullRealmList;
+
     NullTypesRealmProxy() {
         proxyState.setConstructionFinished();
     }
@@ -816,12 +902,7 @@ public final NullTypesColumnInfo clone() {
                 row.nullifyLink(columnInfo.fieldObjectNullIndex);
                 return;
             }
-            if (!RealmObject.isValid(value)) {
-                throw new IllegalArgumentException("'value' is not a valid managed object.");
-            }
-            if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
-                throw new IllegalArgumentException("'value' belongs to a different Realm.");
-            }
+            proxyState.checkValidObject(value);
             row.getTable().setLink(columnInfo.fieldObjectNullIndex, row.getIndex(), ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex(), true);
             return;
         }
@@ -831,273 +912,846 @@ public final NullTypesColumnInfo clone() {
             proxyState.getRow$realm().nullifyLink(columnInfo.fieldObjectNullIndex);
             return;
         }
-        if (!(RealmObject.isManaged(value) && RealmObject.isValid(value))) {
-            throw new IllegalArgumentException("'value' is not a valid managed object.");
-        }
-        if (((RealmObjectProxy)value).realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
-            throw new IllegalArgumentException("'value' belongs to a different Realm.");
+        proxyState.checkValidObject(value);
+        proxyState.getRow$realm().setLink(columnInfo.fieldObjectNullIndex, ((RealmObjectProxy) value).realmGet$proxyState().getRow$realm().getIndex());
+    }
+
+    @Override
+    public RealmList<String> realmGet$fieldStringListNotNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldStringListNotNullRealmList != null) {
+            return fieldStringListNotNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldStringListNotNullIndex, RealmFieldType.STRING_LIST);
+            fieldStringListNotNullRealmList = new RealmList<java.lang.String>(java.lang.String.class, osList, proxyState.getRealm$realm());
+            return fieldStringListNotNullRealmList;
         }
-        proxyState.getRow$realm().setLink(columnInfo.fieldObjectNullIndex, ((RealmObjectProxy)value).realmGet$proxyState().getRow$realm().getIndex());
     }
 
-    public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
-        if (!realmSchema.contains("NullTypes")) {
-            RealmObjectSchema realmObjectSchema = realmSchema.create("NullTypes");
-            realmObjectSchema.add("fieldStringNotNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-            realmObjectSchema.add("fieldStringNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-            realmObjectSchema.add("fieldBooleanNotNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-            realmObjectSchema.add("fieldBooleanNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-            realmObjectSchema.add("fieldBytesNotNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-            realmObjectSchema.add("fieldBytesNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-            realmObjectSchema.add("fieldByteNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-            realmObjectSchema.add("fieldByteNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-            realmObjectSchema.add("fieldShortNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-            realmObjectSchema.add("fieldShortNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-            realmObjectSchema.add("fieldIntegerNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-            realmObjectSchema.add("fieldIntegerNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-            realmObjectSchema.add("fieldLongNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-            realmObjectSchema.add("fieldLongNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-            realmObjectSchema.add("fieldFloatNotNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-            realmObjectSchema.add("fieldFloatNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-            realmObjectSchema.add("fieldDoubleNotNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-            realmObjectSchema.add("fieldDoubleNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-            realmObjectSchema.add("fieldDateNotNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-            realmObjectSchema.add("fieldDateNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-            if (!realmSchema.contains("NullTypes")) {
-                NullTypesRealmProxy.createRealmObjectSchema(realmSchema);
+    @Override
+    public void realmSet$fieldStringListNotNull(RealmList<String> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldStringListNotNull")) {
+                return;
             }
-            realmObjectSchema.add("fieldObjectNull", RealmFieldType.OBJECT, realmSchema.get("NullTypes"));
-            return realmObjectSchema;
         }
-        return realmSchema.get("NullTypes");
-    }
 
-    public static NullTypesColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
-        if (!sharedRealm.hasTable("class_NullTypes")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'NullTypes' class is missing from the schema for this Realm.");
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldStringListNotNullIndex, RealmFieldType.STRING_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        Table table = sharedRealm.getTable("class_NullTypes");
-        final long columnCount = table.getColumnCount();
-        if (columnCount != 21) {
-            if (columnCount < 21) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 21 but was " + columnCount);
-            }
-            if (allowExtraColumns) {
-                RealmLog.debug("Field count is more than expected - expected 21 but was %1$d", columnCount);
+        for (java.lang.String item : value) {
+            if (item == null) {
+                throw new IllegalArgumentException("Storing 'null' into fieldStringListNotNull' is not allowed by the schema.");
             } else {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 21 but was " + columnCount);
+                osList.addString(item);
             }
         }
-        Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
-        for (long i = 0; i < columnCount; i++) {
-            columnTypes.put(table.getColumnName(i), table.getColumnType(i));
-        }
-
-        final NullTypesColumnInfo columnInfo = new NullTypesColumnInfo(sharedRealm.getPath(), table);
+    }
 
-        if (table.hasPrimaryKey()) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key defined for field " + table.getColumnName(table.getPrimaryKey()) + " was removed.");
+    @Override
+    public RealmList<String> realmGet$fieldStringListNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldStringListNullRealmList != null) {
+            return fieldStringListNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldStringListNullIndex, RealmFieldType.STRING_LIST);
+            fieldStringListNullRealmList = new RealmList<java.lang.String>(java.lang.String.class, osList, proxyState.getRealm$realm());
+            return fieldStringListNullRealmList;
         }
+    }
 
-        if (!columnTypes.containsKey("fieldStringNotNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldStringNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("fieldStringNotNull") != RealmFieldType.STRING) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'fieldStringNotNull' in existing Realm file.");
-        }
-        if (table.isColumnNullable(columnInfo.fieldStringNotNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldStringNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldStringNotNull' or migrate using RealmObjectSchema.setNullable().");
+    @Override
+    public void realmSet$fieldStringListNull(RealmList<String> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldStringListNull")) {
+                return;
+            }
         }
-        if (!columnTypes.containsKey("fieldStringNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldStringNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldStringListNullIndex, RealmFieldType.STRING_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (columnTypes.get("fieldStringNull") != RealmFieldType.STRING) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'fieldStringNull' in existing Realm file.");
+        for (java.lang.String item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addString(item);
+            }
         }
-        if (!table.isColumnNullable(columnInfo.fieldStringNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldStringNull' is required. Either set @Required to field 'fieldStringNull' or migrate using RealmObjectSchema.setNullable().");
+    }
+
+    @Override
+    public RealmList<byte[]> realmGet$fieldBinaryListNotNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldBinaryListNotNullRealmList != null) {
+            return fieldBinaryListNotNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldBinaryListNotNullIndex, RealmFieldType.BINARY_LIST);
+            fieldBinaryListNotNullRealmList = new RealmList<byte[]>(byte[].class, osList, proxyState.getRealm$realm());
+            return fieldBinaryListNotNullRealmList;
         }
-        if (!columnTypes.containsKey("fieldBooleanNotNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBooleanNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+    }
+
+    @Override
+    public void realmSet$fieldBinaryListNotNull(RealmList<byte[]> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldBinaryListNotNull")) {
+                return;
+            }
         }
-        if (columnTypes.get("fieldBooleanNotNull") != RealmFieldType.BOOLEAN) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Boolean' for field 'fieldBooleanNotNull' in existing Realm file.");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldBinaryListNotNullIndex, RealmFieldType.BINARY_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (table.isColumnNullable(columnInfo.fieldBooleanNotNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldBooleanNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBooleanNotNull' or migrate using RealmObjectSchema.setNullable().");
+        for (byte[] item : value) {
+            if (item == null) {
+                throw new IllegalArgumentException("Storing 'null' into fieldBinaryListNotNull' is not allowed by the schema.");
+            } else {
+                osList.addBinary(item);
+            }
         }
-        if (!columnTypes.containsKey("fieldBooleanNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBooleanNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+    }
+
+    @Override
+    public RealmList<byte[]> realmGet$fieldBinaryListNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldBinaryListNullRealmList != null) {
+            return fieldBinaryListNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldBinaryListNullIndex, RealmFieldType.BINARY_LIST);
+            fieldBinaryListNullRealmList = new RealmList<byte[]>(byte[].class, osList, proxyState.getRealm$realm());
+            return fieldBinaryListNullRealmList;
         }
-        if (columnTypes.get("fieldBooleanNull") != RealmFieldType.BOOLEAN) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Boolean' for field 'fieldBooleanNull' in existing Realm file.");
+    }
+
+    @Override
+    public void realmSet$fieldBinaryListNull(RealmList<byte[]> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldBinaryListNull")) {
+                return;
+            }
         }
-        if (!table.isColumnNullable(columnInfo.fieldBooleanNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldBooleanNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldBooleanNull' or migrate using RealmObjectSchema.setNullable().");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldBinaryListNullIndex, RealmFieldType.BINARY_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (!columnTypes.containsKey("fieldBytesNotNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBytesNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        for (byte[] item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addBinary(item);
+            }
         }
-        if (columnTypes.get("fieldBytesNotNull") != RealmFieldType.BINARY) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'byte[]' for field 'fieldBytesNotNull' in existing Realm file.");
+    }
+
+    @Override
+    public RealmList<Boolean> realmGet$fieldBooleanListNotNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldBooleanListNotNullRealmList != null) {
+            return fieldBooleanListNotNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldBooleanListNotNullIndex, RealmFieldType.BOOLEAN_LIST);
+            fieldBooleanListNotNullRealmList = new RealmList<java.lang.Boolean>(java.lang.Boolean.class, osList, proxyState.getRealm$realm());
+            return fieldBooleanListNotNullRealmList;
         }
-        if (table.isColumnNullable(columnInfo.fieldBytesNotNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldBytesNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldBytesNotNull' or migrate using RealmObjectSchema.setNullable().");
+    }
+
+    @Override
+    public void realmSet$fieldBooleanListNotNull(RealmList<Boolean> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldBooleanListNotNull")) {
+                return;
+            }
         }
-        if (!columnTypes.containsKey("fieldBytesNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldBytesNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldBooleanListNotNullIndex, RealmFieldType.BOOLEAN_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (columnTypes.get("fieldBytesNull") != RealmFieldType.BINARY) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'byte[]' for field 'fieldBytesNull' in existing Realm file.");
+        for (java.lang.Boolean item : value) {
+            if (item == null) {
+                throw new IllegalArgumentException("Storing 'null' into fieldBooleanListNotNull' is not allowed by the schema.");
+            } else {
+                osList.addBoolean(item);
+            }
         }
-        if (!table.isColumnNullable(columnInfo.fieldBytesNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldBytesNull' is required. Either set @Required to field 'fieldBytesNull' or migrate using RealmObjectSchema.setNullable().");
+    }
+
+    @Override
+    public RealmList<Boolean> realmGet$fieldBooleanListNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldBooleanListNullRealmList != null) {
+            return fieldBooleanListNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldBooleanListNullIndex, RealmFieldType.BOOLEAN_LIST);
+            fieldBooleanListNullRealmList = new RealmList<java.lang.Boolean>(java.lang.Boolean.class, osList, proxyState.getRealm$realm());
+            return fieldBooleanListNullRealmList;
         }
-        if (!columnTypes.containsKey("fieldByteNotNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldByteNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+    }
+
+    @Override
+    public void realmSet$fieldBooleanListNull(RealmList<Boolean> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldBooleanListNull")) {
+                return;
+            }
         }
-        if (columnTypes.get("fieldByteNotNull") != RealmFieldType.INTEGER) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Byte' for field 'fieldByteNotNull' in existing Realm file.");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldBooleanListNullIndex, RealmFieldType.BOOLEAN_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (table.isColumnNullable(columnInfo.fieldByteNotNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldByteNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldByteNotNull' or migrate using RealmObjectSchema.setNullable().");
+        for (java.lang.Boolean item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addBoolean(item);
+            }
         }
-        if (!columnTypes.containsKey("fieldByteNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldByteNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+    }
+
+    @Override
+    public RealmList<Long> realmGet$fieldLongListNotNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldLongListNotNullRealmList != null) {
+            return fieldLongListNotNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldLongListNotNullIndex, RealmFieldType.INTEGER_LIST);
+            fieldLongListNotNullRealmList = new RealmList<java.lang.Long>(java.lang.Long.class, osList, proxyState.getRealm$realm());
+            return fieldLongListNotNullRealmList;
         }
-        if (columnTypes.get("fieldByteNull") != RealmFieldType.INTEGER) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Byte' for field 'fieldByteNull' in existing Realm file.");
+    }
+
+    @Override
+    public void realmSet$fieldLongListNotNull(RealmList<Long> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldLongListNotNull")) {
+                return;
+            }
         }
-        if (!table.isColumnNullable(columnInfo.fieldByteNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldByteNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldByteNull' or migrate using RealmObjectSchema.setNullable().");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldLongListNotNullIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (!columnTypes.containsKey("fieldShortNotNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldShortNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        for (java.lang.Long item : value) {
+            if (item == null) {
+                throw new IllegalArgumentException("Storing 'null' into fieldLongListNotNull' is not allowed by the schema.");
+            } else {
+                osList.addLong(item.longValue());
+            }
         }
-        if (columnTypes.get("fieldShortNotNull") != RealmFieldType.INTEGER) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Short' for field 'fieldShortNotNull' in existing Realm file.");
+    }
+
+    @Override
+    public RealmList<Long> realmGet$fieldLongListNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldLongListNullRealmList != null) {
+            return fieldLongListNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldLongListNullIndex, RealmFieldType.INTEGER_LIST);
+            fieldLongListNullRealmList = new RealmList<java.lang.Long>(java.lang.Long.class, osList, proxyState.getRealm$realm());
+            return fieldLongListNullRealmList;
         }
-        if (table.isColumnNullable(columnInfo.fieldShortNotNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldShortNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldShortNotNull' or migrate using RealmObjectSchema.setNullable().");
+    }
+
+    @Override
+    public void realmSet$fieldLongListNull(RealmList<Long> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldLongListNull")) {
+                return;
+            }
         }
-        if (!columnTypes.containsKey("fieldShortNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldShortNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldLongListNullIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (columnTypes.get("fieldShortNull") != RealmFieldType.INTEGER) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Short' for field 'fieldShortNull' in existing Realm file.");
+        for (java.lang.Long item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addLong(item.longValue());
+            }
         }
-        if (!table.isColumnNullable(columnInfo.fieldShortNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldShortNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldShortNull' or migrate using RealmObjectSchema.setNullable().");
+    }
+
+    @Override
+    public RealmList<Integer> realmGet$fieldIntegerListNotNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldIntegerListNotNullRealmList != null) {
+            return fieldIntegerListNotNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldIntegerListNotNullIndex, RealmFieldType.INTEGER_LIST);
+            fieldIntegerListNotNullRealmList = new RealmList<java.lang.Integer>(java.lang.Integer.class, osList, proxyState.getRealm$realm());
+            return fieldIntegerListNotNullRealmList;
         }
-        if (!columnTypes.containsKey("fieldIntegerNotNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldIntegerNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+    }
+
+    @Override
+    public void realmSet$fieldIntegerListNotNull(RealmList<Integer> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldIntegerListNotNull")) {
+                return;
+            }
         }
-        if (columnTypes.get("fieldIntegerNotNull") != RealmFieldType.INTEGER) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Integer' for field 'fieldIntegerNotNull' in existing Realm file.");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldIntegerListNotNullIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (table.isColumnNullable(columnInfo.fieldIntegerNotNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldIntegerNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldIntegerNotNull' or migrate using RealmObjectSchema.setNullable().");
+        for (java.lang.Integer item : value) {
+            if (item == null) {
+                throw new IllegalArgumentException("Storing 'null' into fieldIntegerListNotNull' is not allowed by the schema.");
+            } else {
+                osList.addLong(item.longValue());
+            }
         }
-        if (!columnTypes.containsKey("fieldIntegerNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldIntegerNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+    }
+
+    @Override
+    public RealmList<Integer> realmGet$fieldIntegerListNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldIntegerListNullRealmList != null) {
+            return fieldIntegerListNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldIntegerListNullIndex, RealmFieldType.INTEGER_LIST);
+            fieldIntegerListNullRealmList = new RealmList<java.lang.Integer>(java.lang.Integer.class, osList, proxyState.getRealm$realm());
+            return fieldIntegerListNullRealmList;
         }
-        if (columnTypes.get("fieldIntegerNull") != RealmFieldType.INTEGER) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Integer' for field 'fieldIntegerNull' in existing Realm file.");
+    }
+
+    @Override
+    public void realmSet$fieldIntegerListNull(RealmList<Integer> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldIntegerListNull")) {
+                return;
+            }
         }
-        if (!table.isColumnNullable(columnInfo.fieldIntegerNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldIntegerNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldIntegerNull' or migrate using RealmObjectSchema.setNullable().");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldIntegerListNullIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (!columnTypes.containsKey("fieldLongNotNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldLongNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        for (java.lang.Integer item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addLong(item.longValue());
+            }
         }
-        if (columnTypes.get("fieldLongNotNull") != RealmFieldType.INTEGER) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Long' for field 'fieldLongNotNull' in existing Realm file.");
+    }
+
+    @Override
+    public RealmList<Short> realmGet$fieldShortListNotNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldShortListNotNullRealmList != null) {
+            return fieldShortListNotNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldShortListNotNullIndex, RealmFieldType.INTEGER_LIST);
+            fieldShortListNotNullRealmList = new RealmList<java.lang.Short>(java.lang.Short.class, osList, proxyState.getRealm$realm());
+            return fieldShortListNotNullRealmList;
         }
-        if (table.isColumnNullable(columnInfo.fieldLongNotNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldLongNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldLongNotNull' or migrate using RealmObjectSchema.setNullable().");
+    }
+
+    @Override
+    public void realmSet$fieldShortListNotNull(RealmList<Short> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldShortListNotNull")) {
+                return;
+            }
         }
-        if (!columnTypes.containsKey("fieldLongNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldLongNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldShortListNotNullIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (columnTypes.get("fieldLongNull") != RealmFieldType.INTEGER) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Long' for field 'fieldLongNull' in existing Realm file.");
+        for (java.lang.Short item : value) {
+            if (item == null) {
+                throw new IllegalArgumentException("Storing 'null' into fieldShortListNotNull' is not allowed by the schema.");
+            } else {
+                osList.addLong(item.longValue());
+            }
         }
-        if (!table.isColumnNullable(columnInfo.fieldLongNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldLongNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldLongNull' or migrate using RealmObjectSchema.setNullable().");
+    }
+
+    @Override
+    public RealmList<Short> realmGet$fieldShortListNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldShortListNullRealmList != null) {
+            return fieldShortListNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldShortListNullIndex, RealmFieldType.INTEGER_LIST);
+            fieldShortListNullRealmList = new RealmList<java.lang.Short>(java.lang.Short.class, osList, proxyState.getRealm$realm());
+            return fieldShortListNullRealmList;
         }
-        if (!columnTypes.containsKey("fieldFloatNotNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldFloatNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+    }
+
+    @Override
+    public void realmSet$fieldShortListNull(RealmList<Short> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldShortListNull")) {
+                return;
+            }
         }
-        if (columnTypes.get("fieldFloatNotNull") != RealmFieldType.FLOAT) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Float' for field 'fieldFloatNotNull' in existing Realm file.");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldShortListNullIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (table.isColumnNullable(columnInfo.fieldFloatNotNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldFloatNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldFloatNotNull' or migrate using RealmObjectSchema.setNullable().");
+        for (java.lang.Short item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addLong(item.longValue());
+            }
         }
-        if (!columnTypes.containsKey("fieldFloatNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldFloatNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+    }
+
+    @Override
+    public RealmList<Byte> realmGet$fieldByteListNotNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldByteListNotNullRealmList != null) {
+            return fieldByteListNotNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldByteListNotNullIndex, RealmFieldType.INTEGER_LIST);
+            fieldByteListNotNullRealmList = new RealmList<java.lang.Byte>(java.lang.Byte.class, osList, proxyState.getRealm$realm());
+            return fieldByteListNotNullRealmList;
         }
-        if (columnTypes.get("fieldFloatNull") != RealmFieldType.FLOAT) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Float' for field 'fieldFloatNull' in existing Realm file.");
+    }
+
+    @Override
+    public void realmSet$fieldByteListNotNull(RealmList<Byte> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldByteListNotNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldByteListNotNullIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Byte item : value) {
+            if (item == null) {
+                throw new IllegalArgumentException("Storing 'null' into fieldByteListNotNull' is not allowed by the schema.");
+            } else {
+                osList.addLong(item.longValue());
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Byte> realmGet$fieldByteListNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldByteListNullRealmList != null) {
+            return fieldByteListNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldByteListNullIndex, RealmFieldType.INTEGER_LIST);
+            fieldByteListNullRealmList = new RealmList<java.lang.Byte>(java.lang.Byte.class, osList, proxyState.getRealm$realm());
+            return fieldByteListNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldByteListNull(RealmList<Byte> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldByteListNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldByteListNullIndex, RealmFieldType.INTEGER_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Byte item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addLong(item.longValue());
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Double> realmGet$fieldDoubleListNotNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldDoubleListNotNullRealmList != null) {
+            return fieldDoubleListNotNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldDoubleListNotNullIndex, RealmFieldType.DOUBLE_LIST);
+            fieldDoubleListNotNullRealmList = new RealmList<java.lang.Double>(java.lang.Double.class, osList, proxyState.getRealm$realm());
+            return fieldDoubleListNotNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldDoubleListNotNull(RealmList<Double> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldDoubleListNotNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldDoubleListNotNullIndex, RealmFieldType.DOUBLE_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
+        }
+        for (java.lang.Double item : value) {
+            if (item == null) {
+                throw new IllegalArgumentException("Storing 'null' into fieldDoubleListNotNull' is not allowed by the schema.");
+            } else {
+                osList.addDouble(item.doubleValue());
+            }
+        }
+    }
+
+    @Override
+    public RealmList<Double> realmGet$fieldDoubleListNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldDoubleListNullRealmList != null) {
+            return fieldDoubleListNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldDoubleListNullIndex, RealmFieldType.DOUBLE_LIST);
+            fieldDoubleListNullRealmList = new RealmList<java.lang.Double>(java.lang.Double.class, osList, proxyState.getRealm$realm());
+            return fieldDoubleListNullRealmList;
+        }
+    }
+
+    @Override
+    public void realmSet$fieldDoubleListNull(RealmList<Double> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldDoubleListNull")) {
+                return;
+            }
+        }
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldDoubleListNullIndex, RealmFieldType.DOUBLE_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (!table.isColumnNullable(columnInfo.fieldFloatNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldFloatNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldFloatNull' or migrate using RealmObjectSchema.setNullable().");
+        for (java.lang.Double item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addDouble(item.doubleValue());
+            }
         }
-        if (!columnTypes.containsKey("fieldDoubleNotNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDoubleNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+    }
+
+    @Override
+    public RealmList<Float> realmGet$fieldFloatListNotNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldFloatListNotNullRealmList != null) {
+            return fieldFloatListNotNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldFloatListNotNullIndex, RealmFieldType.FLOAT_LIST);
+            fieldFloatListNotNullRealmList = new RealmList<java.lang.Float>(java.lang.Float.class, osList, proxyState.getRealm$realm());
+            return fieldFloatListNotNullRealmList;
         }
-        if (columnTypes.get("fieldDoubleNotNull") != RealmFieldType.DOUBLE) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Double' for field 'fieldDoubleNotNull' in existing Realm file.");
+    }
+
+    @Override
+    public void realmSet$fieldFloatListNotNull(RealmList<Float> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldFloatListNotNull")) {
+                return;
+            }
         }
-        if (table.isColumnNullable(columnInfo.fieldDoubleNotNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldDoubleNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDoubleNotNull' or migrate using RealmObjectSchema.setNullable().");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldFloatListNotNullIndex, RealmFieldType.FLOAT_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (!columnTypes.containsKey("fieldDoubleNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDoubleNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+        for (java.lang.Float item : value) {
+            if (item == null) {
+                throw new IllegalArgumentException("Storing 'null' into fieldFloatListNotNull' is not allowed by the schema.");
+            } else {
+                osList.addFloat(item.floatValue());
+            }
         }
-        if (columnTypes.get("fieldDoubleNull") != RealmFieldType.DOUBLE) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Double' for field 'fieldDoubleNull' in existing Realm file.");
+    }
+
+    @Override
+    public RealmList<Float> realmGet$fieldFloatListNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldFloatListNullRealmList != null) {
+            return fieldFloatListNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldFloatListNullIndex, RealmFieldType.FLOAT_LIST);
+            fieldFloatListNullRealmList = new RealmList<java.lang.Float>(java.lang.Float.class, osList, proxyState.getRealm$realm());
+            return fieldFloatListNullRealmList;
         }
-        if (!table.isColumnNullable(columnInfo.fieldDoubleNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(),"Field 'fieldDoubleNull' does not support null values in the existing Realm file. Either set @Required, use the primitive type for field 'fieldDoubleNull' or migrate using RealmObjectSchema.setNullable().");
+    }
+
+    @Override
+    public void realmSet$fieldFloatListNull(RealmList<Float> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldFloatListNull")) {
+                return;
+            }
         }
-        if (!columnTypes.containsKey("fieldDateNotNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDateNotNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldFloatListNullIndex, RealmFieldType.FLOAT_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (columnTypes.get("fieldDateNotNull") != RealmFieldType.DATE) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Date' for field 'fieldDateNotNull' in existing Realm file.");
+        for (java.lang.Float item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addFloat(item.floatValue());
+            }
         }
-        if (table.isColumnNullable(columnInfo.fieldDateNotNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldDateNotNull' does support null values in the existing Realm file. Remove @Required or @PrimaryKey from field 'fieldDateNotNull' or migrate using RealmObjectSchema.setNullable().");
+    }
+
+    @Override
+    public RealmList<Date> realmGet$fieldDateListNotNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldDateListNotNullRealmList != null) {
+            return fieldDateListNotNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldDateListNotNullIndex, RealmFieldType.DATE_LIST);
+            fieldDateListNotNullRealmList = new RealmList<java.util.Date>(java.util.Date.class, osList, proxyState.getRealm$realm());
+            return fieldDateListNotNullRealmList;
         }
-        if (!columnTypes.containsKey("fieldDateNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldDateNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+    }
+
+    @Override
+    public void realmSet$fieldDateListNotNull(RealmList<Date> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldDateListNotNull")) {
+                return;
+            }
         }
-        if (columnTypes.get("fieldDateNull") != RealmFieldType.DATE) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'Date' for field 'fieldDateNull' in existing Realm file.");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldDateListNotNullIndex, RealmFieldType.DATE_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        if (!table.isColumnNullable(columnInfo.fieldDateNullIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'fieldDateNull' is required. Either set @Required to field 'fieldDateNull' or migrate using RealmObjectSchema.setNullable().");
+        for (java.util.Date item : value) {
+            if (item == null) {
+                throw new IllegalArgumentException("Storing 'null' into fieldDateListNotNull' is not allowed by the schema.");
+            } else {
+                osList.addDate(item);
+            }
         }
-        if (!columnTypes.containsKey("fieldObjectNull")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'fieldObjectNull' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
+    }
+
+    @Override
+    public RealmList<Date> realmGet$fieldDateListNull() {
+        proxyState.getRealm$realm().checkIfValid();
+        // use the cached value if available
+        if (fieldDateListNullRealmList != null) {
+            return fieldDateListNullRealmList;
+        } else {
+            OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldDateListNullIndex, RealmFieldType.DATE_LIST);
+            fieldDateListNullRealmList = new RealmList<java.util.Date>(java.util.Date.class, osList, proxyState.getRealm$realm());
+            return fieldDateListNullRealmList;
         }
-        if (columnTypes.get("fieldObjectNull") != RealmFieldType.OBJECT) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'NullTypes' for field 'fieldObjectNull'");
+    }
+
+    @Override
+    public void realmSet$fieldDateListNull(RealmList<Date> value) {
+        if (proxyState.isUnderConstruction()) {
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+            if (proxyState.getExcludeFields$realm().contains("fieldDateListNull")) {
+                return;
+            }
         }
-        if (!sharedRealm.hasTable("class_NullTypes")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing class 'class_NullTypes' for field 'fieldObjectNull'");
+
+        proxyState.getRealm$realm().checkIfValid();
+        OsList osList = proxyState.getRow$realm().getValueList(columnInfo.fieldDateListNullIndex, RealmFieldType.DATE_LIST);
+        osList.removeAll();
+        if (value == null) {
+            return;
         }
-        Table table_20 = sharedRealm.getTable("class_NullTypes");
-        if (!table.getLinkTarget(columnInfo.fieldObjectNullIndex).hasSameSchema(table_20)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid RealmObject for field 'fieldObjectNull': '" + table.getLinkTarget(columnInfo.fieldObjectNullIndex).getName() + "' expected - was '" + table_20.getName() + "'");
+        for (java.util.Date item : value) {
+            if (item == null) {
+                osList.addNull();
+            } else {
+                osList.addDate(item);
+            }
         }
+    }
+
+    private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
+        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("NullTypes", 41, 0);
+        builder.addPersistedProperty("fieldStringNotNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("fieldStringNull", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("fieldBooleanNotNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("fieldBooleanNull", RealmFieldType.BOOLEAN, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("fieldBytesNotNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("fieldBytesNull", RealmFieldType.BINARY, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("fieldByteNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("fieldByteNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("fieldShortNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("fieldShortNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("fieldIntegerNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("fieldIntegerNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("fieldLongNotNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("fieldLongNull", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("fieldFloatNotNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("fieldFloatNull", RealmFieldType.FLOAT, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("fieldDoubleNotNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("fieldDoubleNull", RealmFieldType.DOUBLE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("fieldDateNotNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        builder.addPersistedProperty("fieldDateNull", RealmFieldType.DATE, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedLinkProperty("fieldObjectNull", RealmFieldType.OBJECT, "NullTypes");
+        builder.addPersistedValueListProperty("fieldStringListNotNull", RealmFieldType.STRING_LIST, Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldStringListNull", RealmFieldType.STRING_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldBinaryListNotNull", RealmFieldType.BINARY_LIST, Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldBinaryListNull", RealmFieldType.BINARY_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldBooleanListNotNull", RealmFieldType.BOOLEAN_LIST, Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldBooleanListNull", RealmFieldType.BOOLEAN_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldLongListNotNull", RealmFieldType.INTEGER_LIST, Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldLongListNull", RealmFieldType.INTEGER_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldIntegerListNotNull", RealmFieldType.INTEGER_LIST, Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldIntegerListNull", RealmFieldType.INTEGER_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldShortListNotNull", RealmFieldType.INTEGER_LIST, Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldShortListNull", RealmFieldType.INTEGER_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldByteListNotNull", RealmFieldType.INTEGER_LIST, Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldByteListNull", RealmFieldType.INTEGER_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldDoubleListNotNull", RealmFieldType.DOUBLE_LIST, Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldDoubleListNull", RealmFieldType.DOUBLE_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldFloatListNotNull", RealmFieldType.FLOAT_LIST, Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldFloatListNull", RealmFieldType.FLOAT_LIST, !Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldDateListNotNull", RealmFieldType.DATE_LIST, Property.REQUIRED);
+        builder.addPersistedValueListProperty("fieldDateListNull", RealmFieldType.DATE_LIST, !Property.REQUIRED);
+        return builder.build();
+    }
+
+    public static OsObjectSchemaInfo getExpectedObjectSchemaInfo() {
+        return expectedObjectSchemaInfo;
+    }
 
-        return columnInfo;
+    public static NullTypesColumnInfo createColumnInfo(OsSchemaInfo schemaInfo) {
+        return new NullTypesColumnInfo(schemaInfo);
     }
 
-    public static String getTableName() {
-        return "class_NullTypes";
+    public static String getSimpleClassName() {
+        return "NullTypes";
     }
 
     public static List<String> getFieldNames() {
@@ -1107,169 +1761,251 @@ public static String getTableName() {
     @SuppressWarnings("cast")
     public static some.test.NullTypes createOrUpdateUsingJsonObject(Realm realm, JSONObject json, boolean update)
             throws JSONException {
-        final List<String> excludeFields = new ArrayList<String>(1);
+        final List<String> excludeFields = new ArrayList<String>(21);
         if (json.has("fieldObjectNull")) {
             excludeFields.add("fieldObjectNull");
         }
+        if (json.has("fieldStringListNotNull")) {
+            excludeFields.add("fieldStringListNotNull");
+        }
+        if (json.has("fieldStringListNull")) {
+            excludeFields.add("fieldStringListNull");
+        }
+        if (json.has("fieldBinaryListNotNull")) {
+            excludeFields.add("fieldBinaryListNotNull");
+        }
+        if (json.has("fieldBinaryListNull")) {
+            excludeFields.add("fieldBinaryListNull");
+        }
+        if (json.has("fieldBooleanListNotNull")) {
+            excludeFields.add("fieldBooleanListNotNull");
+        }
+        if (json.has("fieldBooleanListNull")) {
+            excludeFields.add("fieldBooleanListNull");
+        }
+        if (json.has("fieldLongListNotNull")) {
+            excludeFields.add("fieldLongListNotNull");
+        }
+        if (json.has("fieldLongListNull")) {
+            excludeFields.add("fieldLongListNull");
+        }
+        if (json.has("fieldIntegerListNotNull")) {
+            excludeFields.add("fieldIntegerListNotNull");
+        }
+        if (json.has("fieldIntegerListNull")) {
+            excludeFields.add("fieldIntegerListNull");
+        }
+        if (json.has("fieldShortListNotNull")) {
+            excludeFields.add("fieldShortListNotNull");
+        }
+        if (json.has("fieldShortListNull")) {
+            excludeFields.add("fieldShortListNull");
+        }
+        if (json.has("fieldByteListNotNull")) {
+            excludeFields.add("fieldByteListNotNull");
+        }
+        if (json.has("fieldByteListNull")) {
+            excludeFields.add("fieldByteListNull");
+        }
+        if (json.has("fieldDoubleListNotNull")) {
+            excludeFields.add("fieldDoubleListNotNull");
+        }
+        if (json.has("fieldDoubleListNull")) {
+            excludeFields.add("fieldDoubleListNull");
+        }
+        if (json.has("fieldFloatListNotNull")) {
+            excludeFields.add("fieldFloatListNotNull");
+        }
+        if (json.has("fieldFloatListNull")) {
+            excludeFields.add("fieldFloatListNull");
+        }
+        if (json.has("fieldDateListNotNull")) {
+            excludeFields.add("fieldDateListNotNull");
+        }
+        if (json.has("fieldDateListNull")) {
+            excludeFields.add("fieldDateListNull");
+        }
         some.test.NullTypes obj = realm.createObjectInternal(some.test.NullTypes.class, true, excludeFields);
+
+        final NullTypesRealmProxyInterface objProxy = (NullTypesRealmProxyInterface) obj;
         if (json.has("fieldStringNotNull")) {
             if (json.isNull("fieldStringNotNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNotNull(null);
+                objProxy.realmSet$fieldStringNotNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNotNull((String) json.getString("fieldStringNotNull"));
+                objProxy.realmSet$fieldStringNotNull((String) json.getString("fieldStringNotNull"));
             }
         }
         if (json.has("fieldStringNull")) {
             if (json.isNull("fieldStringNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNull(null);
+                objProxy.realmSet$fieldStringNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNull((String) json.getString("fieldStringNull"));
+                objProxy.realmSet$fieldStringNull((String) json.getString("fieldStringNull"));
             }
         }
         if (json.has("fieldBooleanNotNull")) {
             if (json.isNull("fieldBooleanNotNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNotNull(null);
+                objProxy.realmSet$fieldBooleanNotNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNotNull((boolean) json.getBoolean("fieldBooleanNotNull"));
+                objProxy.realmSet$fieldBooleanNotNull((boolean) json.getBoolean("fieldBooleanNotNull"));
             }
         }
         if (json.has("fieldBooleanNull")) {
             if (json.isNull("fieldBooleanNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNull(null);
+                objProxy.realmSet$fieldBooleanNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNull((boolean) json.getBoolean("fieldBooleanNull"));
+                objProxy.realmSet$fieldBooleanNull((boolean) json.getBoolean("fieldBooleanNull"));
             }
         }
         if (json.has("fieldBytesNotNull")) {
             if (json.isNull("fieldBytesNotNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNotNull(null);
+                objProxy.realmSet$fieldBytesNotNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNotNull(JsonUtils.stringToBytes(json.getString("fieldBytesNotNull")));
+                objProxy.realmSet$fieldBytesNotNull(JsonUtils.stringToBytes(json.getString("fieldBytesNotNull")));
             }
         }
         if (json.has("fieldBytesNull")) {
             if (json.isNull("fieldBytesNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNull(null);
+                objProxy.realmSet$fieldBytesNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNull(JsonUtils.stringToBytes(json.getString("fieldBytesNull")));
+                objProxy.realmSet$fieldBytesNull(JsonUtils.stringToBytes(json.getString("fieldBytesNull")));
             }
         }
         if (json.has("fieldByteNotNull")) {
             if (json.isNull("fieldByteNotNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNotNull(null);
+                objProxy.realmSet$fieldByteNotNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNotNull((byte) json.getInt("fieldByteNotNull"));
+                objProxy.realmSet$fieldByteNotNull((byte) json.getInt("fieldByteNotNull"));
             }
         }
         if (json.has("fieldByteNull")) {
             if (json.isNull("fieldByteNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNull(null);
+                objProxy.realmSet$fieldByteNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNull((byte) json.getInt("fieldByteNull"));
+                objProxy.realmSet$fieldByteNull((byte) json.getInt("fieldByteNull"));
             }
         }
         if (json.has("fieldShortNotNull")) {
             if (json.isNull("fieldShortNotNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNotNull(null);
+                objProxy.realmSet$fieldShortNotNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNotNull((short) json.getInt("fieldShortNotNull"));
+                objProxy.realmSet$fieldShortNotNull((short) json.getInt("fieldShortNotNull"));
             }
         }
         if (json.has("fieldShortNull")) {
             if (json.isNull("fieldShortNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNull(null);
+                objProxy.realmSet$fieldShortNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNull((short) json.getInt("fieldShortNull"));
+                objProxy.realmSet$fieldShortNull((short) json.getInt("fieldShortNull"));
             }
         }
         if (json.has("fieldIntegerNotNull")) {
             if (json.isNull("fieldIntegerNotNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNotNull(null);
+                objProxy.realmSet$fieldIntegerNotNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNotNull((int) json.getInt("fieldIntegerNotNull"));
+                objProxy.realmSet$fieldIntegerNotNull((int) json.getInt("fieldIntegerNotNull"));
             }
         }
         if (json.has("fieldIntegerNull")) {
             if (json.isNull("fieldIntegerNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNull(null);
+                objProxy.realmSet$fieldIntegerNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNull((int) json.getInt("fieldIntegerNull"));
+                objProxy.realmSet$fieldIntegerNull((int) json.getInt("fieldIntegerNull"));
             }
         }
         if (json.has("fieldLongNotNull")) {
             if (json.isNull("fieldLongNotNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNotNull(null);
+                objProxy.realmSet$fieldLongNotNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNotNull((long) json.getLong("fieldLongNotNull"));
+                objProxy.realmSet$fieldLongNotNull((long) json.getLong("fieldLongNotNull"));
             }
         }
         if (json.has("fieldLongNull")) {
             if (json.isNull("fieldLongNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNull(null);
+                objProxy.realmSet$fieldLongNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNull((long) json.getLong("fieldLongNull"));
+                objProxy.realmSet$fieldLongNull((long) json.getLong("fieldLongNull"));
             }
         }
         if (json.has("fieldFloatNotNull")) {
             if (json.isNull("fieldFloatNotNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNotNull(null);
+                objProxy.realmSet$fieldFloatNotNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNotNull((float) json.getDouble("fieldFloatNotNull"));
+                objProxy.realmSet$fieldFloatNotNull((float) json.getDouble("fieldFloatNotNull"));
             }
         }
         if (json.has("fieldFloatNull")) {
             if (json.isNull("fieldFloatNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNull(null);
+                objProxy.realmSet$fieldFloatNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNull((float) json.getDouble("fieldFloatNull"));
+                objProxy.realmSet$fieldFloatNull((float) json.getDouble("fieldFloatNull"));
             }
         }
         if (json.has("fieldDoubleNotNull")) {
             if (json.isNull("fieldDoubleNotNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNotNull(null);
+                objProxy.realmSet$fieldDoubleNotNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNotNull((double) json.getDouble("fieldDoubleNotNull"));
+                objProxy.realmSet$fieldDoubleNotNull((double) json.getDouble("fieldDoubleNotNull"));
             }
         }
         if (json.has("fieldDoubleNull")) {
             if (json.isNull("fieldDoubleNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNull(null);
+                objProxy.realmSet$fieldDoubleNull(null);
             } else {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNull((double) json.getDouble("fieldDoubleNull"));
+                objProxy.realmSet$fieldDoubleNull((double) json.getDouble("fieldDoubleNull"));
             }
         }
         if (json.has("fieldDateNotNull")) {
             if (json.isNull("fieldDateNotNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNotNull(null);
+                objProxy.realmSet$fieldDateNotNull(null);
             } else {
                 Object timestamp = json.get("fieldDateNotNull");
                 if (timestamp instanceof String) {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNotNull(JsonUtils.stringToDate((String) timestamp));
+                    objProxy.realmSet$fieldDateNotNull(JsonUtils.stringToDate((String) timestamp));
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNotNull(new Date(json.getLong("fieldDateNotNull")));
+                    objProxy.realmSet$fieldDateNotNull(new Date(json.getLong("fieldDateNotNull")));
                 }
             }
         }
         if (json.has("fieldDateNull")) {
             if (json.isNull("fieldDateNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNull(null);
+                objProxy.realmSet$fieldDateNull(null);
             } else {
                 Object timestamp = json.get("fieldDateNull");
                 if (timestamp instanceof String) {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNull(JsonUtils.stringToDate((String) timestamp));
+                    objProxy.realmSet$fieldDateNull(JsonUtils.stringToDate((String) timestamp));
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNull(new Date(json.getLong("fieldDateNull")));
+                    objProxy.realmSet$fieldDateNull(new Date(json.getLong("fieldDateNull")));
                 }
             }
         }
         if (json.has("fieldObjectNull")) {
             if (json.isNull("fieldObjectNull")) {
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldObjectNull(null);
+                objProxy.realmSet$fieldObjectNull(null);
             } else {
                 some.test.NullTypes fieldObjectNullObj = NullTypesRealmProxy.createOrUpdateUsingJsonObject(realm, json.getJSONObject("fieldObjectNull"), update);
-                ((NullTypesRealmProxyInterface) obj).realmSet$fieldObjectNull(fieldObjectNullObj);
+                objProxy.realmSet$fieldObjectNull(fieldObjectNullObj);
             }
         }
+        // TODO implement logic for value list fieldStringListNotNull.
+        // TODO implement logic for value list fieldStringListNull.
+        // TODO implement logic for value list fieldBinaryListNotNull.
+        // TODO implement logic for value list fieldBinaryListNull.
+        // TODO implement logic for value list fieldBooleanListNotNull.
+        // TODO implement logic for value list fieldBooleanListNull.
+        // TODO implement logic for value list fieldLongListNotNull.
+        // TODO implement logic for value list fieldLongListNull.
+        // TODO implement logic for value list fieldIntegerListNotNull.
+        // TODO implement logic for value list fieldIntegerListNull.
+        // TODO implement logic for value list fieldShortListNotNull.
+        // TODO implement logic for value list fieldShortListNull.
+        // TODO implement logic for value list fieldByteListNotNull.
+        // TODO implement logic for value list fieldByteListNull.
+        // TODO implement logic for value list fieldDoubleListNotNull.
+        // TODO implement logic for value list fieldDoubleListNull.
+        // TODO implement logic for value list fieldFloatListNotNull.
+        // TODO implement logic for value list fieldFloatListNull.
+        // TODO implement logic for value list fieldDateListNotNull.
+        // TODO implement logic for value list fieldDateListNull.
         return obj;
     }
 
@@ -1277,324 +2013,391 @@ public static String getTableName() {
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
     public static some.test.NullTypes createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        some.test.NullTypes obj = new some.test.NullTypes();
+        final some.test.NullTypes obj = new some.test.NullTypes();
+        final NullTypesRealmProxyInterface objProxy = (NullTypesRealmProxyInterface) obj;
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
             if (false) {
             } else if (name.equals("fieldStringNotNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNotNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldStringNotNull((String) reader.nextString());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNotNull((String) reader.nextString());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldStringNotNull(null);
                 }
             } else if (name.equals("fieldStringNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldStringNull((String) reader.nextString());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldStringNull((String) reader.nextString());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldStringNull(null);
                 }
             } else if (name.equals("fieldBooleanNotNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNotNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldBooleanNotNull((boolean) reader.nextBoolean());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNotNull((boolean) reader.nextBoolean());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldBooleanNotNull(null);
                 }
             } else if (name.equals("fieldBooleanNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldBooleanNull((boolean) reader.nextBoolean());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBooleanNull((boolean) reader.nextBoolean());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldBooleanNull(null);
                 }
             } else if (name.equals("fieldBytesNotNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNotNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldBytesNotNull(JsonUtils.stringToBytes(reader.nextString()));
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNotNull(JsonUtils.stringToBytes(reader.nextString()));
+                    reader.skipValue();
+                    objProxy.realmSet$fieldBytesNotNull(null);
                 }
             } else if (name.equals("fieldBytesNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldBytesNull(JsonUtils.stringToBytes(reader.nextString()));
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldBytesNull(JsonUtils.stringToBytes(reader.nextString()));
+                    reader.skipValue();
+                    objProxy.realmSet$fieldBytesNull(null);
                 }
             } else if (name.equals("fieldByteNotNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNotNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldByteNotNull((byte) reader.nextInt());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNotNull((byte) reader.nextInt());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldByteNotNull(null);
                 }
             } else if (name.equals("fieldByteNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldByteNull((byte) reader.nextInt());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldByteNull((byte) reader.nextInt());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldByteNull(null);
                 }
             } else if (name.equals("fieldShortNotNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNotNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldShortNotNull((short) reader.nextInt());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNotNull((short) reader.nextInt());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldShortNotNull(null);
                 }
             } else if (name.equals("fieldShortNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldShortNull((short) reader.nextInt());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldShortNull((short) reader.nextInt());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldShortNull(null);
                 }
             } else if (name.equals("fieldIntegerNotNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNotNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldIntegerNotNull((int) reader.nextInt());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNotNull((int) reader.nextInt());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldIntegerNotNull(null);
                 }
             } else if (name.equals("fieldIntegerNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldIntegerNull((int) reader.nextInt());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldIntegerNull((int) reader.nextInt());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldIntegerNull(null);
                 }
             } else if (name.equals("fieldLongNotNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNotNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldLongNotNull((long) reader.nextLong());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNotNull((long) reader.nextLong());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldLongNotNull(null);
                 }
             } else if (name.equals("fieldLongNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldLongNull((long) reader.nextLong());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldLongNull((long) reader.nextLong());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldLongNull(null);
                 }
             } else if (name.equals("fieldFloatNotNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNotNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldFloatNotNull((float) reader.nextDouble());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNotNull((float) reader.nextDouble());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldFloatNotNull(null);
                 }
             } else if (name.equals("fieldFloatNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldFloatNull((float) reader.nextDouble());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldFloatNull((float) reader.nextDouble());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldFloatNull(null);
                 }
             } else if (name.equals("fieldDoubleNotNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNotNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldDoubleNotNull((double) reader.nextDouble());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNotNull((double) reader.nextDouble());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldDoubleNotNull(null);
                 }
             } else if (name.equals("fieldDoubleNull")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNull(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$fieldDoubleNull((double) reader.nextDouble());
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDoubleNull((double) reader.nextDouble());
+                    reader.skipValue();
+                    objProxy.realmSet$fieldDoubleNull(null);
                 }
             } else if (name.equals("fieldDateNotNull")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNotNull(null);
+                    objProxy.realmSet$fieldDateNotNull(null);
                 } else if (reader.peek() == JsonToken.NUMBER) {
                     long timestamp = reader.nextLong();
                     if (timestamp > -1) {
-                        ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNotNull(new Date(timestamp));
+                        objProxy.realmSet$fieldDateNotNull(new Date(timestamp));
                     }
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNotNull(JsonUtils.stringToDate(reader.nextString()));
+                    objProxy.realmSet$fieldDateNotNull(JsonUtils.stringToDate(reader.nextString()));
                 }
             } else if (name.equals("fieldDateNull")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNull(null);
+                    objProxy.realmSet$fieldDateNull(null);
                 } else if (reader.peek() == JsonToken.NUMBER) {
                     long timestamp = reader.nextLong();
                     if (timestamp > -1) {
-                        ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNull(new Date(timestamp));
+                        objProxy.realmSet$fieldDateNull(new Date(timestamp));
                     }
                 } else {
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldDateNull(JsonUtils.stringToDate(reader.nextString()));
+                    objProxy.realmSet$fieldDateNull(JsonUtils.stringToDate(reader.nextString()));
                 }
             } else if (name.equals("fieldObjectNull")) {
                 if (reader.peek() == JsonToken.NULL) {
                     reader.skipValue();
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldObjectNull(null);
+                    objProxy.realmSet$fieldObjectNull(null);
                 } else {
                     some.test.NullTypes fieldObjectNullObj = NullTypesRealmProxy.createUsingJsonStream(realm, reader);
-                    ((NullTypesRealmProxyInterface) obj).realmSet$fieldObjectNull(fieldObjectNullObj);
+                    objProxy.realmSet$fieldObjectNull(fieldObjectNullObj);
                 }
+            } else if (name.equals("fieldStringListNotNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldStringListNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldBinaryListNotNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldBinaryListNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldBooleanListNotNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldBooleanListNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldLongListNotNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldLongListNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldIntegerListNotNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldIntegerListNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldShortListNotNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldShortListNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldByteListNotNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldByteListNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldDoubleListNotNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldDoubleListNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldFloatListNotNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldFloatListNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldDateListNotNull")) {
+                // TODO implement logic for value list.
+            } else if (name.equals("fieldDateListNull")) {
+                // TODO implement logic for value list.
             } else {
                 reader.skipValue();
             }
         }
         reader.endObject();
-        obj = realm.copyToRealm(obj);
-        return obj;
+        return realm.copyToRealm(obj);
     }
 
     public static some.test.NullTypes copyOrUpdate(Realm realm, some.test.NullTypes object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
-            throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
-        }
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-            return object;
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null) {
+            final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm();
+            if (otherRealm.threadId != realm.threadId) {
+                throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
+            }
+            if (otherRealm.getPath().equals(realm.getPath())) {
+                return object;
+            }
         }
         final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
         RealmObjectProxy cachedRealmObject = cache.get(object);
         if (cachedRealmObject != null) {
             return (some.test.NullTypes) cachedRealmObject;
-        } else {
-            return copy(realm, object, update, cache);
         }
+
+        return copy(realm, object, update, cache);
     }
 
     public static some.test.NullTypes copy(Realm realm, some.test.NullTypes newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
         RealmObjectProxy cachedRealmObject = cache.get(newObject);
         if (cachedRealmObject != null) {
             return (some.test.NullTypes) cachedRealmObject;
-        } else {
-            // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
-            some.test.NullTypes realmObject = realm.createObjectInternal(some.test.NullTypes.class, false, Collections.<String>emptyList());
-            cache.put(newObject, (RealmObjectProxy) realmObject);
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldStringNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldStringNotNull());
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldStringNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldStringNull());
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBooleanNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBooleanNotNull());
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBooleanNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBooleanNull());
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBytesNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBytesNotNull());
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldBytesNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldBytesNull());
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldByteNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldByteNotNull());
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldByteNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldByteNull());
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldShortNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldShortNotNull());
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldShortNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldShortNull());
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldIntegerNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldIntegerNotNull());
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldIntegerNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldIntegerNull());
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldLongNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldLongNotNull());
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldLongNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldLongNull());
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldFloatNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldFloatNotNull());
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldFloatNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldFloatNull());
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDoubleNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDoubleNotNull());
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDoubleNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDoubleNull());
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDateNotNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDateNotNull());
-            ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldDateNull(((NullTypesRealmProxyInterface) newObject).realmGet$fieldDateNull());
-
-            some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) newObject).realmGet$fieldObjectNull();
-            if (fieldObjectNullObj != null) {
-                some.test.NullTypes cachefieldObjectNull = (some.test.NullTypes) cache.get(fieldObjectNullObj);
-                if (cachefieldObjectNull != null) {
-                    ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(cachefieldObjectNull);
-                } else {
-                    ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(NullTypesRealmProxy.copyOrUpdate(realm, fieldObjectNullObj, update, cache));
-                }
+        }
+
+        // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
+        some.test.NullTypes realmObject = realm.createObjectInternal(some.test.NullTypes.class, false, Collections.<String>emptyList());
+        cache.put(newObject, (RealmObjectProxy) realmObject);
+
+        NullTypesRealmProxyInterface realmObjectSource = (NullTypesRealmProxyInterface) newObject;
+        NullTypesRealmProxyInterface realmObjectCopy = (NullTypesRealmProxyInterface) realmObject;
+
+        realmObjectCopy.realmSet$fieldStringNotNull(realmObjectSource.realmGet$fieldStringNotNull());
+        realmObjectCopy.realmSet$fieldStringNull(realmObjectSource.realmGet$fieldStringNull());
+        realmObjectCopy.realmSet$fieldBooleanNotNull(realmObjectSource.realmGet$fieldBooleanNotNull());
+        realmObjectCopy.realmSet$fieldBooleanNull(realmObjectSource.realmGet$fieldBooleanNull());
+        realmObjectCopy.realmSet$fieldBytesNotNull(realmObjectSource.realmGet$fieldBytesNotNull());
+        realmObjectCopy.realmSet$fieldBytesNull(realmObjectSource.realmGet$fieldBytesNull());
+        realmObjectCopy.realmSet$fieldByteNotNull(realmObjectSource.realmGet$fieldByteNotNull());
+        realmObjectCopy.realmSet$fieldByteNull(realmObjectSource.realmGet$fieldByteNull());
+        realmObjectCopy.realmSet$fieldShortNotNull(realmObjectSource.realmGet$fieldShortNotNull());
+        realmObjectCopy.realmSet$fieldShortNull(realmObjectSource.realmGet$fieldShortNull());
+        realmObjectCopy.realmSet$fieldIntegerNotNull(realmObjectSource.realmGet$fieldIntegerNotNull());
+        realmObjectCopy.realmSet$fieldIntegerNull(realmObjectSource.realmGet$fieldIntegerNull());
+        realmObjectCopy.realmSet$fieldLongNotNull(realmObjectSource.realmGet$fieldLongNotNull());
+        realmObjectCopy.realmSet$fieldLongNull(realmObjectSource.realmGet$fieldLongNull());
+        realmObjectCopy.realmSet$fieldFloatNotNull(realmObjectSource.realmGet$fieldFloatNotNull());
+        realmObjectCopy.realmSet$fieldFloatNull(realmObjectSource.realmGet$fieldFloatNull());
+        realmObjectCopy.realmSet$fieldDoubleNotNull(realmObjectSource.realmGet$fieldDoubleNotNull());
+        realmObjectCopy.realmSet$fieldDoubleNull(realmObjectSource.realmGet$fieldDoubleNull());
+        realmObjectCopy.realmSet$fieldDateNotNull(realmObjectSource.realmGet$fieldDateNotNull());
+        realmObjectCopy.realmSet$fieldDateNull(realmObjectSource.realmGet$fieldDateNull());
+
+        some.test.NullTypes fieldObjectNullObj = realmObjectSource.realmGet$fieldObjectNull();
+        if (fieldObjectNullObj == null) {
+            realmObjectCopy.realmSet$fieldObjectNull(null);
+        } else {
+            some.test.NullTypes cachefieldObjectNull = (some.test.NullTypes) cache.get(fieldObjectNullObj);
+            if (cachefieldObjectNull != null) {
+                realmObjectCopy.realmSet$fieldObjectNull(cachefieldObjectNull);
             } else {
-                ((NullTypesRealmProxyInterface) realmObject).realmSet$fieldObjectNull(null);
+                realmObjectCopy.realmSet$fieldObjectNull(NullTypesRealmProxy.copyOrUpdate(realm, fieldObjectNullObj, update, cache));
             }
-            return realmObject;
         }
+        realmObjectCopy.realmSet$fieldStringListNotNull(realmObjectSource.realmGet$fieldStringListNotNull());
+        realmObjectCopy.realmSet$fieldStringListNull(realmObjectSource.realmGet$fieldStringListNull());
+        realmObjectCopy.realmSet$fieldBinaryListNotNull(realmObjectSource.realmGet$fieldBinaryListNotNull());
+        realmObjectCopy.realmSet$fieldBinaryListNull(realmObjectSource.realmGet$fieldBinaryListNull());
+        realmObjectCopy.realmSet$fieldBooleanListNotNull(realmObjectSource.realmGet$fieldBooleanListNotNull());
+        realmObjectCopy.realmSet$fieldBooleanListNull(realmObjectSource.realmGet$fieldBooleanListNull());
+        realmObjectCopy.realmSet$fieldLongListNotNull(realmObjectSource.realmGet$fieldLongListNotNull());
+        realmObjectCopy.realmSet$fieldLongListNull(realmObjectSource.realmGet$fieldLongListNull());
+        realmObjectCopy.realmSet$fieldIntegerListNotNull(realmObjectSource.realmGet$fieldIntegerListNotNull());
+        realmObjectCopy.realmSet$fieldIntegerListNull(realmObjectSource.realmGet$fieldIntegerListNull());
+        realmObjectCopy.realmSet$fieldShortListNotNull(realmObjectSource.realmGet$fieldShortListNotNull());
+        realmObjectCopy.realmSet$fieldShortListNull(realmObjectSource.realmGet$fieldShortListNull());
+        realmObjectCopy.realmSet$fieldByteListNotNull(realmObjectSource.realmGet$fieldByteListNotNull());
+        realmObjectCopy.realmSet$fieldByteListNull(realmObjectSource.realmGet$fieldByteListNull());
+        realmObjectCopy.realmSet$fieldDoubleListNotNull(realmObjectSource.realmGet$fieldDoubleListNotNull());
+        realmObjectCopy.realmSet$fieldDoubleListNull(realmObjectSource.realmGet$fieldDoubleListNull());
+        realmObjectCopy.realmSet$fieldFloatListNotNull(realmObjectSource.realmGet$fieldFloatListNotNull());
+        realmObjectCopy.realmSet$fieldFloatListNull(realmObjectSource.realmGet$fieldFloatListNull());
+        realmObjectCopy.realmSet$fieldDateListNotNull(realmObjectSource.realmGet$fieldDateListNotNull());
+        realmObjectCopy.realmSet$fieldDateListNull(realmObjectSource.realmGet$fieldDateListNull());
+        return realmObject;
     }
 
     public static long insert(Realm realm, some.test.NullTypes object, Map<RealmModel,Long> cache) {
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-            return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+            return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex();
         }
         Table table = realm.getTable(some.test.NullTypes.class);
-        long tableNativePtr = table.getNativeTablePointer();
-        NullTypesColumnInfo columnInfo = (NullTypesColumnInfo) realm.schema.getColumnInfo(some.test.NullTypes.class);
-        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+        long tableNativePtr = table.getNativePtr();
+        NullTypesColumnInfo columnInfo = (NullTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.NullTypes.class);
+        long rowIndex = OsObject.createRow(table);
         cache.put(object, rowIndex);
-        String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNotNull();
+        String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringNotNull();
         if (realmGet$fieldStringNotNull != null) {
             Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull, false);
         }
-        String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNull();
+        String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringNull();
         if (realmGet$fieldStringNull != null) {
             Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull, false);
         }
-        Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNotNull();
+        Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanNotNull();
         if (realmGet$fieldBooleanNotNull != null) {
             Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull, false);
         }
-        Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNull();
+        Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanNull();
         if (realmGet$fieldBooleanNull != null) {
             Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull, false);
         }
-        byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNotNull();
+        byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldBytesNotNull();
         if (realmGet$fieldBytesNotNull != null) {
             Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull, false);
         }
-        byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNull();
+        byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldBytesNull();
         if (realmGet$fieldBytesNull != null) {
             Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull, false);
         }
-        Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNotNull();
+        Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteNotNull();
         if (realmGet$fieldByteNotNull != null) {
             Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue(), false);
         }
-        Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNull();
+        Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteNull();
         if (realmGet$fieldByteNull != null) {
             Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue(), false);
         }
-        Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNotNull();
+        Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortNotNull();
         if (realmGet$fieldShortNotNull != null) {
             Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue(), false);
         }
-        Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNull();
+        Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortNull();
         if (realmGet$fieldShortNull != null) {
             Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue(), false);
         }
-        Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNotNull();
+        Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerNotNull();
         if (realmGet$fieldIntegerNotNull != null) {
             Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue(), false);
         }
-        Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNull();
+        Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerNull();
         if (realmGet$fieldIntegerNull != null) {
             Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue(), false);
         }
-        Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNotNull();
+        Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongNotNull();
         if (realmGet$fieldLongNotNull != null) {
             Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue(), false);
         }
-        Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNull();
+        Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongNull();
         if (realmGet$fieldLongNull != null) {
             Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue(), false);
         }
-        Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNotNull();
+        Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatNotNull();
         if (realmGet$fieldFloatNotNull != null) {
             Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull, false);
         }
-        Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNull();
+        Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatNull();
         if (realmGet$fieldFloatNull != null) {
             Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull, false);
         }
-        Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNotNull();
+        Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleNotNull();
         if (realmGet$fieldDoubleNotNull != null) {
             Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull, false);
         }
-        Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNull();
+        Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleNull();
         if (realmGet$fieldDoubleNull != null) {
             Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull, false);
         }
-        java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNotNull();
+        java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateNotNull();
         if (realmGet$fieldDateNotNull != null) {
             Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime(), false);
         }
-        java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNull();
+        java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateNull();
         if (realmGet$fieldDateNull != null) {
             Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime(), false);
         }
@@ -1607,240 +2410,721 @@ public static long insert(Realm realm, some.test.NullTypes object, Map<RealmMode
             }
             Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull, false);
         }
+
+        RealmList<java.lang.String> fieldStringListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringListNotNull();
+        if (fieldStringListNotNullList != null) {
+            OsList fieldStringListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldStringListNotNullIndex);
+            for (java.lang.String fieldStringListNotNullItem : fieldStringListNotNullList) {
+                if (fieldStringListNotNullItem == null) {
+                    fieldStringListNotNullOsList.addNull();
+                } else {
+                    fieldStringListNotNullOsList.addString(fieldStringListNotNullItem);
+                }
+            }
+        }
+
+        RealmList<java.lang.String> fieldStringListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringListNull();
+        if (fieldStringListNullList != null) {
+            OsList fieldStringListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldStringListNullIndex);
+            for (java.lang.String fieldStringListNullItem : fieldStringListNullList) {
+                if (fieldStringListNullItem == null) {
+                    fieldStringListNullOsList.addNull();
+                } else {
+                    fieldStringListNullOsList.addString(fieldStringListNullItem);
+                }
+            }
+        }
+
+        RealmList<byte[]> fieldBinaryListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBinaryListNotNull();
+        if (fieldBinaryListNotNullList != null) {
+            OsList fieldBinaryListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBinaryListNotNullIndex);
+            for (byte[] fieldBinaryListNotNullItem : fieldBinaryListNotNullList) {
+                if (fieldBinaryListNotNullItem == null) {
+                    fieldBinaryListNotNullOsList.addNull();
+                } else {
+                    fieldBinaryListNotNullOsList.addBinary(fieldBinaryListNotNullItem);
+                }
+            }
+        }
+
+        RealmList<byte[]> fieldBinaryListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBinaryListNull();
+        if (fieldBinaryListNullList != null) {
+            OsList fieldBinaryListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBinaryListNullIndex);
+            for (byte[] fieldBinaryListNullItem : fieldBinaryListNullList) {
+                if (fieldBinaryListNullItem == null) {
+                    fieldBinaryListNullOsList.addNull();
+                } else {
+                    fieldBinaryListNullOsList.addBinary(fieldBinaryListNullItem);
+                }
+            }
+        }
+
+        RealmList<java.lang.Boolean> fieldBooleanListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanListNotNull();
+        if (fieldBooleanListNotNullList != null) {
+            OsList fieldBooleanListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBooleanListNotNullIndex);
+            for (java.lang.Boolean fieldBooleanListNotNullItem : fieldBooleanListNotNullList) {
+                if (fieldBooleanListNotNullItem == null) {
+                    fieldBooleanListNotNullOsList.addNull();
+                } else {
+                    fieldBooleanListNotNullOsList.addBoolean(fieldBooleanListNotNullItem);
+                }
+            }
+        }
+
+        RealmList<java.lang.Boolean> fieldBooleanListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanListNull();
+        if (fieldBooleanListNullList != null) {
+            OsList fieldBooleanListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBooleanListNullIndex);
+            for (java.lang.Boolean fieldBooleanListNullItem : fieldBooleanListNullList) {
+                if (fieldBooleanListNullItem == null) {
+                    fieldBooleanListNullOsList.addNull();
+                } else {
+                    fieldBooleanListNullOsList.addBoolean(fieldBooleanListNullItem);
+                }
+            }
+        }
+
+        RealmList<java.lang.Long> fieldLongListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongListNotNull();
+        if (fieldLongListNotNullList != null) {
+            OsList fieldLongListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldLongListNotNullIndex);
+            for (java.lang.Long fieldLongListNotNullItem : fieldLongListNotNullList) {
+                if (fieldLongListNotNullItem == null) {
+                    fieldLongListNotNullOsList.addNull();
+                } else {
+                    fieldLongListNotNullOsList.addLong(fieldLongListNotNullItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Long> fieldLongListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongListNull();
+        if (fieldLongListNullList != null) {
+            OsList fieldLongListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldLongListNullIndex);
+            for (java.lang.Long fieldLongListNullItem : fieldLongListNullList) {
+                if (fieldLongListNullItem == null) {
+                    fieldLongListNullOsList.addNull();
+                } else {
+                    fieldLongListNullOsList.addLong(fieldLongListNullItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Integer> fieldIntegerListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerListNotNull();
+        if (fieldIntegerListNotNullList != null) {
+            OsList fieldIntegerListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldIntegerListNotNullIndex);
+            for (java.lang.Integer fieldIntegerListNotNullItem : fieldIntegerListNotNullList) {
+                if (fieldIntegerListNotNullItem == null) {
+                    fieldIntegerListNotNullOsList.addNull();
+                } else {
+                    fieldIntegerListNotNullOsList.addLong(fieldIntegerListNotNullItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Integer> fieldIntegerListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerListNull();
+        if (fieldIntegerListNullList != null) {
+            OsList fieldIntegerListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldIntegerListNullIndex);
+            for (java.lang.Integer fieldIntegerListNullItem : fieldIntegerListNullList) {
+                if (fieldIntegerListNullItem == null) {
+                    fieldIntegerListNullOsList.addNull();
+                } else {
+                    fieldIntegerListNullOsList.addLong(fieldIntegerListNullItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Short> fieldShortListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortListNotNull();
+        if (fieldShortListNotNullList != null) {
+            OsList fieldShortListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldShortListNotNullIndex);
+            for (java.lang.Short fieldShortListNotNullItem : fieldShortListNotNullList) {
+                if (fieldShortListNotNullItem == null) {
+                    fieldShortListNotNullOsList.addNull();
+                } else {
+                    fieldShortListNotNullOsList.addLong(fieldShortListNotNullItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Short> fieldShortListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortListNull();
+        if (fieldShortListNullList != null) {
+            OsList fieldShortListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldShortListNullIndex);
+            for (java.lang.Short fieldShortListNullItem : fieldShortListNullList) {
+                if (fieldShortListNullItem == null) {
+                    fieldShortListNullOsList.addNull();
+                } else {
+                    fieldShortListNullOsList.addLong(fieldShortListNullItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Byte> fieldByteListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteListNotNull();
+        if (fieldByteListNotNullList != null) {
+            OsList fieldByteListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldByteListNotNullIndex);
+            for (java.lang.Byte fieldByteListNotNullItem : fieldByteListNotNullList) {
+                if (fieldByteListNotNullItem == null) {
+                    fieldByteListNotNullOsList.addNull();
+                } else {
+                    fieldByteListNotNullOsList.addLong(fieldByteListNotNullItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Byte> fieldByteListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteListNull();
+        if (fieldByteListNullList != null) {
+            OsList fieldByteListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldByteListNullIndex);
+            for (java.lang.Byte fieldByteListNullItem : fieldByteListNullList) {
+                if (fieldByteListNullItem == null) {
+                    fieldByteListNullOsList.addNull();
+                } else {
+                    fieldByteListNullOsList.addLong(fieldByteListNullItem.longValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Double> fieldDoubleListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleListNotNull();
+        if (fieldDoubleListNotNullList != null) {
+            OsList fieldDoubleListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDoubleListNotNullIndex);
+            for (java.lang.Double fieldDoubleListNotNullItem : fieldDoubleListNotNullList) {
+                if (fieldDoubleListNotNullItem == null) {
+                    fieldDoubleListNotNullOsList.addNull();
+                } else {
+                    fieldDoubleListNotNullOsList.addDouble(fieldDoubleListNotNullItem.doubleValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Double> fieldDoubleListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleListNull();
+        if (fieldDoubleListNullList != null) {
+            OsList fieldDoubleListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDoubleListNullIndex);
+            for (java.lang.Double fieldDoubleListNullItem : fieldDoubleListNullList) {
+                if (fieldDoubleListNullItem == null) {
+                    fieldDoubleListNullOsList.addNull();
+                } else {
+                    fieldDoubleListNullOsList.addDouble(fieldDoubleListNullItem.doubleValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Float> fieldFloatListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatListNotNull();
+        if (fieldFloatListNotNullList != null) {
+            OsList fieldFloatListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldFloatListNotNullIndex);
+            for (java.lang.Float fieldFloatListNotNullItem : fieldFloatListNotNullList) {
+                if (fieldFloatListNotNullItem == null) {
+                    fieldFloatListNotNullOsList.addNull();
+                } else {
+                    fieldFloatListNotNullOsList.addFloat(fieldFloatListNotNullItem.floatValue());
+                }
+            }
+        }
+
+        RealmList<java.lang.Float> fieldFloatListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatListNull();
+        if (fieldFloatListNullList != null) {
+            OsList fieldFloatListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldFloatListNullIndex);
+            for (java.lang.Float fieldFloatListNullItem : fieldFloatListNullList) {
+                if (fieldFloatListNullItem == null) {
+                    fieldFloatListNullOsList.addNull();
+                } else {
+                    fieldFloatListNullOsList.addFloat(fieldFloatListNullItem.floatValue());
+                }
+            }
+        }
+
+        RealmList<java.util.Date> fieldDateListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateListNotNull();
+        if (fieldDateListNotNullList != null) {
+            OsList fieldDateListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDateListNotNullIndex);
+            for (java.util.Date fieldDateListNotNullItem : fieldDateListNotNullList) {
+                if (fieldDateListNotNullItem == null) {
+                    fieldDateListNotNullOsList.addNull();
+                } else {
+                    fieldDateListNotNullOsList.addDate(fieldDateListNotNullItem);
+                }
+            }
+        }
+
+        RealmList<java.util.Date> fieldDateListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateListNull();
+        if (fieldDateListNullList != null) {
+            OsList fieldDateListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDateListNullIndex);
+            for (java.util.Date fieldDateListNullItem : fieldDateListNullList) {
+                if (fieldDateListNullItem == null) {
+                    fieldDateListNullOsList.addNull();
+                } else {
+                    fieldDateListNullOsList.addDate(fieldDateListNullItem);
+                }
+            }
+        }
         return rowIndex;
     }
 
     public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
         Table table = realm.getTable(some.test.NullTypes.class);
-        long tableNativePtr = table.getNativeTablePointer();
-        NullTypesColumnInfo columnInfo = (NullTypesColumnInfo) realm.schema.getColumnInfo(some.test.NullTypes.class);
+        long tableNativePtr = table.getNativePtr();
+        NullTypesColumnInfo columnInfo = (NullTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.NullTypes.class);
         some.test.NullTypes object = null;
         while (objects.hasNext()) {
             object = (some.test.NullTypes) objects.next();
-            if(!cache.containsKey(object)) {
-                if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-                    cache.put(object, ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex());
-                    continue;
-                }
-                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
-                cache.put(object, rowIndex);
-                String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNotNull();
-                if (realmGet$fieldStringNotNull != null) {
-                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull, false);
-                }
-                String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNull();
-                if (realmGet$fieldStringNull != null) {
-                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull, false);
-                }
-                Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNotNull();
-                if (realmGet$fieldBooleanNotNull != null) {
-                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull, false);
-                }
-                Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNull();
-                if (realmGet$fieldBooleanNull != null) {
-                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull, false);
-                }
-                byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNotNull();
-                if (realmGet$fieldBytesNotNull != null) {
-                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull, false);
-                }
-                byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNull();
-                if (realmGet$fieldBytesNull != null) {
-                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull, false);
-                }
-                Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNotNull();
-                if (realmGet$fieldByteNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue(), false);
-                }
-                Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNull();
-                if (realmGet$fieldByteNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue(), false);
-                }
-                Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNotNull();
-                if (realmGet$fieldShortNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue(), false);
-                }
-                Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNull();
-                if (realmGet$fieldShortNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue(), false);
-                }
-                Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNotNull();
-                if (realmGet$fieldIntegerNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue(), false);
-                }
-                Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNull();
-                if (realmGet$fieldIntegerNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue(), false);
-                }
-                Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNotNull();
-                if (realmGet$fieldLongNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue(), false);
-                }
-                Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNull();
-                if (realmGet$fieldLongNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue(), false);
-                }
-                Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNotNull();
-                if (realmGet$fieldFloatNotNull != null) {
-                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull, false);
-                }
-                Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNull();
-                if (realmGet$fieldFloatNull != null) {
-                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull, false);
-                }
-                Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNotNull();
-                if (realmGet$fieldDoubleNotNull != null) {
-                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull, false);
-                }
-                Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNull();
-                if (realmGet$fieldDoubleNull != null) {
-                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull, false);
-                }
-                java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNotNull();
-                if (realmGet$fieldDateNotNull != null) {
-                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime(), false);
-                }
-                java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNull();
-                if (realmGet$fieldDateNull != null) {
-                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime(), false);
-                }
-
-                some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
-                if (fieldObjectNullObj != null) {
-                    Long cachefieldObjectNull = cache.get(fieldObjectNullObj);
-                    if (cachefieldObjectNull == null) {
-                        cachefieldObjectNull = NullTypesRealmProxy.insert(realm, fieldObjectNullObj, cache);
+            if (cache.containsKey(object)) {
+                continue;
+            }
+            if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex());
+                continue;
+            }
+            long rowIndex = OsObject.createRow(table);
+            cache.put(object, rowIndex);
+            String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringNotNull();
+            if (realmGet$fieldStringNotNull != null) {
+                Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull, false);
+            }
+            String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringNull();
+            if (realmGet$fieldStringNull != null) {
+                Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull, false);
+            }
+            Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanNotNull();
+            if (realmGet$fieldBooleanNotNull != null) {
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull, false);
+            }
+            Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanNull();
+            if (realmGet$fieldBooleanNull != null) {
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull, false);
+            }
+            byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldBytesNotNull();
+            if (realmGet$fieldBytesNotNull != null) {
+                Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull, false);
+            }
+            byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldBytesNull();
+            if (realmGet$fieldBytesNull != null) {
+                Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull, false);
+            }
+            Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteNotNull();
+            if (realmGet$fieldByteNotNull != null) {
+                Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue(), false);
+            }
+            Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteNull();
+            if (realmGet$fieldByteNull != null) {
+                Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue(), false);
+            }
+            Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortNotNull();
+            if (realmGet$fieldShortNotNull != null) {
+                Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue(), false);
+            }
+            Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortNull();
+            if (realmGet$fieldShortNull != null) {
+                Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue(), false);
+            }
+            Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerNotNull();
+            if (realmGet$fieldIntegerNotNull != null) {
+                Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue(), false);
+            }
+            Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerNull();
+            if (realmGet$fieldIntegerNull != null) {
+                Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue(), false);
+            }
+            Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongNotNull();
+            if (realmGet$fieldLongNotNull != null) {
+                Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue(), false);
+            }
+            Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongNull();
+            if (realmGet$fieldLongNull != null) {
+                Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue(), false);
+            }
+            Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatNotNull();
+            if (realmGet$fieldFloatNotNull != null) {
+                Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull, false);
+            }
+            Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatNull();
+            if (realmGet$fieldFloatNull != null) {
+                Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull, false);
+            }
+            Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleNotNull();
+            if (realmGet$fieldDoubleNotNull != null) {
+                Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull, false);
+            }
+            Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleNull();
+            if (realmGet$fieldDoubleNull != null) {
+                Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull, false);
+            }
+            java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateNotNull();
+            if (realmGet$fieldDateNotNull != null) {
+                Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime(), false);
+            }
+            java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateNull();
+            if (realmGet$fieldDateNull != null) {
+                Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime(), false);
+            }
+
+            some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
+            if (fieldObjectNullObj != null) {
+                Long cachefieldObjectNull = cache.get(fieldObjectNullObj);
+                if (cachefieldObjectNull == null) {
+                    cachefieldObjectNull = NullTypesRealmProxy.insert(realm, fieldObjectNullObj, cache);
+                }
+                table.setLink(columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull, false);
+            }
+
+            RealmList<java.lang.String> fieldStringListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringListNotNull();
+            if (fieldStringListNotNullList != null) {
+                OsList fieldStringListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldStringListNotNullIndex);
+                for (java.lang.String fieldStringListNotNullItem : fieldStringListNotNullList) {
+                    if (fieldStringListNotNullItem == null) {
+                        fieldStringListNotNullOsList.addNull();
+                    } else {
+                        fieldStringListNotNullOsList.addString(fieldStringListNotNullItem);
+                    }
+                }
+            }
+
+            RealmList<java.lang.String> fieldStringListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringListNull();
+            if (fieldStringListNullList != null) {
+                OsList fieldStringListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldStringListNullIndex);
+                for (java.lang.String fieldStringListNullItem : fieldStringListNullList) {
+                    if (fieldStringListNullItem == null) {
+                        fieldStringListNullOsList.addNull();
+                    } else {
+                        fieldStringListNullOsList.addString(fieldStringListNullItem);
+                    }
+                }
+            }
+
+            RealmList<byte[]> fieldBinaryListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBinaryListNotNull();
+            if (fieldBinaryListNotNullList != null) {
+                OsList fieldBinaryListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBinaryListNotNullIndex);
+                for (byte[] fieldBinaryListNotNullItem : fieldBinaryListNotNullList) {
+                    if (fieldBinaryListNotNullItem == null) {
+                        fieldBinaryListNotNullOsList.addNull();
+                    } else {
+                        fieldBinaryListNotNullOsList.addBinary(fieldBinaryListNotNullItem);
+                    }
+                }
+            }
+
+            RealmList<byte[]> fieldBinaryListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBinaryListNull();
+            if (fieldBinaryListNullList != null) {
+                OsList fieldBinaryListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBinaryListNullIndex);
+                for (byte[] fieldBinaryListNullItem : fieldBinaryListNullList) {
+                    if (fieldBinaryListNullItem == null) {
+                        fieldBinaryListNullOsList.addNull();
+                    } else {
+                        fieldBinaryListNullOsList.addBinary(fieldBinaryListNullItem);
+                    }
+                }
+            }
+
+            RealmList<java.lang.Boolean> fieldBooleanListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanListNotNull();
+            if (fieldBooleanListNotNullList != null) {
+                OsList fieldBooleanListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBooleanListNotNullIndex);
+                for (java.lang.Boolean fieldBooleanListNotNullItem : fieldBooleanListNotNullList) {
+                    if (fieldBooleanListNotNullItem == null) {
+                        fieldBooleanListNotNullOsList.addNull();
+                    } else {
+                        fieldBooleanListNotNullOsList.addBoolean(fieldBooleanListNotNullItem);
+                    }
+                }
+            }
+
+            RealmList<java.lang.Boolean> fieldBooleanListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanListNull();
+            if (fieldBooleanListNullList != null) {
+                OsList fieldBooleanListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBooleanListNullIndex);
+                for (java.lang.Boolean fieldBooleanListNullItem : fieldBooleanListNullList) {
+                    if (fieldBooleanListNullItem == null) {
+                        fieldBooleanListNullOsList.addNull();
+                    } else {
+                        fieldBooleanListNullOsList.addBoolean(fieldBooleanListNullItem);
+                    }
+                }
+            }
+
+            RealmList<java.lang.Long> fieldLongListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongListNotNull();
+            if (fieldLongListNotNullList != null) {
+                OsList fieldLongListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldLongListNotNullIndex);
+                for (java.lang.Long fieldLongListNotNullItem : fieldLongListNotNullList) {
+                    if (fieldLongListNotNullItem == null) {
+                        fieldLongListNotNullOsList.addNull();
+                    } else {
+                        fieldLongListNotNullOsList.addLong(fieldLongListNotNullItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Long> fieldLongListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongListNull();
+            if (fieldLongListNullList != null) {
+                OsList fieldLongListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldLongListNullIndex);
+                for (java.lang.Long fieldLongListNullItem : fieldLongListNullList) {
+                    if (fieldLongListNullItem == null) {
+                        fieldLongListNullOsList.addNull();
+                    } else {
+                        fieldLongListNullOsList.addLong(fieldLongListNullItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Integer> fieldIntegerListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerListNotNull();
+            if (fieldIntegerListNotNullList != null) {
+                OsList fieldIntegerListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldIntegerListNotNullIndex);
+                for (java.lang.Integer fieldIntegerListNotNullItem : fieldIntegerListNotNullList) {
+                    if (fieldIntegerListNotNullItem == null) {
+                        fieldIntegerListNotNullOsList.addNull();
+                    } else {
+                        fieldIntegerListNotNullOsList.addLong(fieldIntegerListNotNullItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Integer> fieldIntegerListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerListNull();
+            if (fieldIntegerListNullList != null) {
+                OsList fieldIntegerListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldIntegerListNullIndex);
+                for (java.lang.Integer fieldIntegerListNullItem : fieldIntegerListNullList) {
+                    if (fieldIntegerListNullItem == null) {
+                        fieldIntegerListNullOsList.addNull();
+                    } else {
+                        fieldIntegerListNullOsList.addLong(fieldIntegerListNullItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Short> fieldShortListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortListNotNull();
+            if (fieldShortListNotNullList != null) {
+                OsList fieldShortListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldShortListNotNullIndex);
+                for (java.lang.Short fieldShortListNotNullItem : fieldShortListNotNullList) {
+                    if (fieldShortListNotNullItem == null) {
+                        fieldShortListNotNullOsList.addNull();
+                    } else {
+                        fieldShortListNotNullOsList.addLong(fieldShortListNotNullItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Short> fieldShortListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortListNull();
+            if (fieldShortListNullList != null) {
+                OsList fieldShortListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldShortListNullIndex);
+                for (java.lang.Short fieldShortListNullItem : fieldShortListNullList) {
+                    if (fieldShortListNullItem == null) {
+                        fieldShortListNullOsList.addNull();
+                    } else {
+                        fieldShortListNullOsList.addLong(fieldShortListNullItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Byte> fieldByteListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteListNotNull();
+            if (fieldByteListNotNullList != null) {
+                OsList fieldByteListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldByteListNotNullIndex);
+                for (java.lang.Byte fieldByteListNotNullItem : fieldByteListNotNullList) {
+                    if (fieldByteListNotNullItem == null) {
+                        fieldByteListNotNullOsList.addNull();
+                    } else {
+                        fieldByteListNotNullOsList.addLong(fieldByteListNotNullItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Byte> fieldByteListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteListNull();
+            if (fieldByteListNullList != null) {
+                OsList fieldByteListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldByteListNullIndex);
+                for (java.lang.Byte fieldByteListNullItem : fieldByteListNullList) {
+                    if (fieldByteListNullItem == null) {
+                        fieldByteListNullOsList.addNull();
+                    } else {
+                        fieldByteListNullOsList.addLong(fieldByteListNullItem.longValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Double> fieldDoubleListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleListNotNull();
+            if (fieldDoubleListNotNullList != null) {
+                OsList fieldDoubleListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDoubleListNotNullIndex);
+                for (java.lang.Double fieldDoubleListNotNullItem : fieldDoubleListNotNullList) {
+                    if (fieldDoubleListNotNullItem == null) {
+                        fieldDoubleListNotNullOsList.addNull();
+                    } else {
+                        fieldDoubleListNotNullOsList.addDouble(fieldDoubleListNotNullItem.doubleValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Double> fieldDoubleListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleListNull();
+            if (fieldDoubleListNullList != null) {
+                OsList fieldDoubleListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDoubleListNullIndex);
+                for (java.lang.Double fieldDoubleListNullItem : fieldDoubleListNullList) {
+                    if (fieldDoubleListNullItem == null) {
+                        fieldDoubleListNullOsList.addNull();
+                    } else {
+                        fieldDoubleListNullOsList.addDouble(fieldDoubleListNullItem.doubleValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Float> fieldFloatListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatListNotNull();
+            if (fieldFloatListNotNullList != null) {
+                OsList fieldFloatListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldFloatListNotNullIndex);
+                for (java.lang.Float fieldFloatListNotNullItem : fieldFloatListNotNullList) {
+                    if (fieldFloatListNotNullItem == null) {
+                        fieldFloatListNotNullOsList.addNull();
+                    } else {
+                        fieldFloatListNotNullOsList.addFloat(fieldFloatListNotNullItem.floatValue());
+                    }
+                }
+            }
+
+            RealmList<java.lang.Float> fieldFloatListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatListNull();
+            if (fieldFloatListNullList != null) {
+                OsList fieldFloatListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldFloatListNullIndex);
+                for (java.lang.Float fieldFloatListNullItem : fieldFloatListNullList) {
+                    if (fieldFloatListNullItem == null) {
+                        fieldFloatListNullOsList.addNull();
+                    } else {
+                        fieldFloatListNullOsList.addFloat(fieldFloatListNullItem.floatValue());
+                    }
+                }
+            }
+
+            RealmList<java.util.Date> fieldDateListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateListNotNull();
+            if (fieldDateListNotNullList != null) {
+                OsList fieldDateListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDateListNotNullIndex);
+                for (java.util.Date fieldDateListNotNullItem : fieldDateListNotNullList) {
+                    if (fieldDateListNotNullItem == null) {
+                        fieldDateListNotNullOsList.addNull();
+                    } else {
+                        fieldDateListNotNullOsList.addDate(fieldDateListNotNullItem);
+                    }
+                }
+            }
+
+            RealmList<java.util.Date> fieldDateListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateListNull();
+            if (fieldDateListNullList != null) {
+                OsList fieldDateListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDateListNullIndex);
+                for (java.util.Date fieldDateListNullItem : fieldDateListNullList) {
+                    if (fieldDateListNullItem == null) {
+                        fieldDateListNullOsList.addNull();
+                    } else {
+                        fieldDateListNullOsList.addDate(fieldDateListNullItem);
                     }
-                    table.setLink(columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull, false);
                 }
             }
         }
     }
 
     public static long insertOrUpdate(Realm realm, some.test.NullTypes object, Map<RealmModel,Long> cache) {
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-            return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+            return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex();
         }
         Table table = realm.getTable(some.test.NullTypes.class);
-        long tableNativePtr = table.getNativeTablePointer();
-        NullTypesColumnInfo columnInfo = (NullTypesColumnInfo) realm.schema.getColumnInfo(some.test.NullTypes.class);
-        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+        long tableNativePtr = table.getNativePtr();
+        NullTypesColumnInfo columnInfo = (NullTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.NullTypes.class);
+        long rowIndex = OsObject.createRow(table);
         cache.put(object, rowIndex);
-        String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNotNull();
+        String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringNotNull();
         if (realmGet$fieldStringNotNull != null) {
             Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull, false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, false);
         }
-        String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNull();
+        String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringNull();
         if (realmGet$fieldStringNull != null) {
             Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull, false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, false);
         }
-        Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNotNull();
+        Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanNotNull();
         if (realmGet$fieldBooleanNotNull != null) {
             Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull, false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, false);
         }
-        Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNull();
+        Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanNull();
         if (realmGet$fieldBooleanNull != null) {
             Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull, false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, false);
         }
-        byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNotNull();
+        byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldBytesNotNull();
         if (realmGet$fieldBytesNotNull != null) {
             Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull, false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, false);
         }
-        byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNull();
+        byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldBytesNull();
         if (realmGet$fieldBytesNull != null) {
             Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull, false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, false);
         }
-        Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNotNull();
+        Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteNotNull();
         if (realmGet$fieldByteNotNull != null) {
             Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue(), false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, false);
         }
-        Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNull();
+        Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteNull();
         if (realmGet$fieldByteNull != null) {
             Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue(), false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, false);
         }
-        Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNotNull();
+        Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortNotNull();
         if (realmGet$fieldShortNotNull != null) {
             Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue(), false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, false);
         }
-        Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNull();
+        Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortNull();
         if (realmGet$fieldShortNull != null) {
             Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue(), false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, false);
         }
-        Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNotNull();
+        Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerNotNull();
         if (realmGet$fieldIntegerNotNull != null) {
             Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue(), false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, false);
         }
-        Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNull();
+        Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerNull();
         if (realmGet$fieldIntegerNull != null) {
             Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue(), false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, false);
         }
-        Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNotNull();
+        Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongNotNull();
         if (realmGet$fieldLongNotNull != null) {
             Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue(), false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, false);
         }
-        Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNull();
+        Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongNull();
         if (realmGet$fieldLongNull != null) {
             Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue(), false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, false);
         }
-        Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNotNull();
+        Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatNotNull();
         if (realmGet$fieldFloatNotNull != null) {
             Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull, false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, false);
         }
-        Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNull();
+        Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatNull();
         if (realmGet$fieldFloatNull != null) {
             Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull, false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, false);
         }
-        Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNotNull();
+        Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleNotNull();
         if (realmGet$fieldDoubleNotNull != null) {
             Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull, false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, false);
         }
-        Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNull();
+        Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleNull();
         if (realmGet$fieldDoubleNull != null) {
             Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull, false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, false);
         }
-        java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNotNull();
+        java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateNotNull();
         if (realmGet$fieldDateNotNull != null) {
             Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime(), false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, false);
         }
-        java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNull();
+        java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateNull();
         if (realmGet$fieldDateNull != null) {
             Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime(), false);
         } else {
@@ -1857,156 +3141,717 @@ public static long insertOrUpdate(Realm realm, some.test.NullTypes object, Map<R
         } else {
             Table.nativeNullifyLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex);
         }
-        return rowIndex;
-    }
 
-    public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
-        Table table = realm.getTable(some.test.NullTypes.class);
-        long tableNativePtr = table.getNativeTablePointer();
-        NullTypesColumnInfo columnInfo = (NullTypesColumnInfo) realm.schema.getColumnInfo(some.test.NullTypes.class);
-        some.test.NullTypes object = null;
-        while (objects.hasNext()) {
-            object = (some.test.NullTypes) objects.next();
-            if(!cache.containsKey(object)) {
-                if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-                    cache.put(object, ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex());
-                    continue;
-                }
-                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
-                cache.put(object, rowIndex);
-                String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNotNull();
-                if (realmGet$fieldStringNotNull != null) {
-                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull, false);
-                } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, false);
-                }
-                String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldStringNull();
-                if (realmGet$fieldStringNull != null) {
-                    Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull, false);
+        OsList fieldStringListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldStringListNotNullIndex);
+        fieldStringListNotNullOsList.removeAll();
+        RealmList<java.lang.String> fieldStringListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringListNotNull();
+        if (fieldStringListNotNullList != null) {
+            for (java.lang.String fieldStringListNotNullItem : fieldStringListNotNullList) {
+                if (fieldStringListNotNullItem == null) {
+                    fieldStringListNotNullOsList.addNull();
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, false);
+                    fieldStringListNotNullOsList.addString(fieldStringListNotNullItem);
                 }
-                Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNotNull();
-                if (realmGet$fieldBooleanNotNull != null) {
-                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull, false);
+            }
+        }
+
+
+        OsList fieldStringListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldStringListNullIndex);
+        fieldStringListNullOsList.removeAll();
+        RealmList<java.lang.String> fieldStringListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringListNull();
+        if (fieldStringListNullList != null) {
+            for (java.lang.String fieldStringListNullItem : fieldStringListNullList) {
+                if (fieldStringListNullItem == null) {
+                    fieldStringListNullOsList.addNull();
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, false);
+                    fieldStringListNullOsList.addString(fieldStringListNullItem);
                 }
-                Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBooleanNull();
-                if (realmGet$fieldBooleanNull != null) {
-                    Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull, false);
+            }
+        }
+
+
+        OsList fieldBinaryListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBinaryListNotNullIndex);
+        fieldBinaryListNotNullOsList.removeAll();
+        RealmList<byte[]> fieldBinaryListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBinaryListNotNull();
+        if (fieldBinaryListNotNullList != null) {
+            for (byte[] fieldBinaryListNotNullItem : fieldBinaryListNotNullList) {
+                if (fieldBinaryListNotNullItem == null) {
+                    fieldBinaryListNotNullOsList.addNull();
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, false);
+                    fieldBinaryListNotNullOsList.addBinary(fieldBinaryListNotNullItem);
                 }
-                byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNotNull();
-                if (realmGet$fieldBytesNotNull != null) {
-                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull, false);
+            }
+        }
+
+
+        OsList fieldBinaryListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBinaryListNullIndex);
+        fieldBinaryListNullOsList.removeAll();
+        RealmList<byte[]> fieldBinaryListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBinaryListNull();
+        if (fieldBinaryListNullList != null) {
+            for (byte[] fieldBinaryListNullItem : fieldBinaryListNullList) {
+                if (fieldBinaryListNullItem == null) {
+                    fieldBinaryListNullOsList.addNull();
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, false);
+                    fieldBinaryListNullOsList.addBinary(fieldBinaryListNullItem);
                 }
-                byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldBytesNull();
-                if (realmGet$fieldBytesNull != null) {
-                    Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull, false);
+            }
+        }
+
+
+        OsList fieldBooleanListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBooleanListNotNullIndex);
+        fieldBooleanListNotNullOsList.removeAll();
+        RealmList<java.lang.Boolean> fieldBooleanListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanListNotNull();
+        if (fieldBooleanListNotNullList != null) {
+            for (java.lang.Boolean fieldBooleanListNotNullItem : fieldBooleanListNotNullList) {
+                if (fieldBooleanListNotNullItem == null) {
+                    fieldBooleanListNotNullOsList.addNull();
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, false);
+                    fieldBooleanListNotNullOsList.addBoolean(fieldBooleanListNotNullItem);
                 }
-                Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNotNull();
-                if (realmGet$fieldByteNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue(), false);
+            }
+        }
+
+
+        OsList fieldBooleanListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBooleanListNullIndex);
+        fieldBooleanListNullOsList.removeAll();
+        RealmList<java.lang.Boolean> fieldBooleanListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanListNull();
+        if (fieldBooleanListNullList != null) {
+            for (java.lang.Boolean fieldBooleanListNullItem : fieldBooleanListNullList) {
+                if (fieldBooleanListNullItem == null) {
+                    fieldBooleanListNullOsList.addNull();
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, false);
+                    fieldBooleanListNullOsList.addBoolean(fieldBooleanListNullItem);
                 }
-                Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldByteNull();
-                if (realmGet$fieldByteNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue(), false);
+            }
+        }
+
+
+        OsList fieldLongListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldLongListNotNullIndex);
+        fieldLongListNotNullOsList.removeAll();
+        RealmList<java.lang.Long> fieldLongListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongListNotNull();
+        if (fieldLongListNotNullList != null) {
+            for (java.lang.Long fieldLongListNotNullItem : fieldLongListNotNullList) {
+                if (fieldLongListNotNullItem == null) {
+                    fieldLongListNotNullOsList.addNull();
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, false);
+                    fieldLongListNotNullOsList.addLong(fieldLongListNotNullItem.longValue());
                 }
-                Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNotNull();
-                if (realmGet$fieldShortNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue(), false);
+            }
+        }
+
+
+        OsList fieldLongListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldLongListNullIndex);
+        fieldLongListNullOsList.removeAll();
+        RealmList<java.lang.Long> fieldLongListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongListNull();
+        if (fieldLongListNullList != null) {
+            for (java.lang.Long fieldLongListNullItem : fieldLongListNullList) {
+                if (fieldLongListNullItem == null) {
+                    fieldLongListNullOsList.addNull();
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, false);
+                    fieldLongListNullOsList.addLong(fieldLongListNullItem.longValue());
                 }
-                Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldShortNull();
-                if (realmGet$fieldShortNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue(), false);
+            }
+        }
+
+
+        OsList fieldIntegerListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldIntegerListNotNullIndex);
+        fieldIntegerListNotNullOsList.removeAll();
+        RealmList<java.lang.Integer> fieldIntegerListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerListNotNull();
+        if (fieldIntegerListNotNullList != null) {
+            for (java.lang.Integer fieldIntegerListNotNullItem : fieldIntegerListNotNullList) {
+                if (fieldIntegerListNotNullItem == null) {
+                    fieldIntegerListNotNullOsList.addNull();
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, false);
+                    fieldIntegerListNotNullOsList.addLong(fieldIntegerListNotNullItem.longValue());
                 }
-                Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNotNull();
-                if (realmGet$fieldIntegerNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue(), false);
+            }
+        }
+
+
+        OsList fieldIntegerListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldIntegerListNullIndex);
+        fieldIntegerListNullOsList.removeAll();
+        RealmList<java.lang.Integer> fieldIntegerListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerListNull();
+        if (fieldIntegerListNullList != null) {
+            for (java.lang.Integer fieldIntegerListNullItem : fieldIntegerListNullList) {
+                if (fieldIntegerListNullItem == null) {
+                    fieldIntegerListNullOsList.addNull();
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, false);
+                    fieldIntegerListNullOsList.addLong(fieldIntegerListNullItem.longValue());
                 }
-                Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldIntegerNull();
-                if (realmGet$fieldIntegerNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue(), false);
+            }
+        }
+
+
+        OsList fieldShortListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldShortListNotNullIndex);
+        fieldShortListNotNullOsList.removeAll();
+        RealmList<java.lang.Short> fieldShortListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortListNotNull();
+        if (fieldShortListNotNullList != null) {
+            for (java.lang.Short fieldShortListNotNullItem : fieldShortListNotNullList) {
+                if (fieldShortListNotNullItem == null) {
+                    fieldShortListNotNullOsList.addNull();
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, false);
+                    fieldShortListNotNullOsList.addLong(fieldShortListNotNullItem.longValue());
                 }
-                Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNotNull();
-                if (realmGet$fieldLongNotNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue(), false);
+            }
+        }
+
+
+        OsList fieldShortListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldShortListNullIndex);
+        fieldShortListNullOsList.removeAll();
+        RealmList<java.lang.Short> fieldShortListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortListNull();
+        if (fieldShortListNullList != null) {
+            for (java.lang.Short fieldShortListNullItem : fieldShortListNullList) {
+                if (fieldShortListNullItem == null) {
+                    fieldShortListNullOsList.addNull();
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, false);
+                    fieldShortListNullOsList.addLong(fieldShortListNullItem.longValue());
                 }
-                Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldLongNull();
-                if (realmGet$fieldLongNull != null) {
-                    Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue(), false);
+            }
+        }
+
+
+        OsList fieldByteListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldByteListNotNullIndex);
+        fieldByteListNotNullOsList.removeAll();
+        RealmList<java.lang.Byte> fieldByteListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteListNotNull();
+        if (fieldByteListNotNullList != null) {
+            for (java.lang.Byte fieldByteListNotNullItem : fieldByteListNotNullList) {
+                if (fieldByteListNotNullItem == null) {
+                    fieldByteListNotNullOsList.addNull();
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, false);
+                    fieldByteListNotNullOsList.addLong(fieldByteListNotNullItem.longValue());
                 }
-                Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNotNull();
-                if (realmGet$fieldFloatNotNull != null) {
-                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull, false);
+            }
+        }
+
+
+        OsList fieldByteListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldByteListNullIndex);
+        fieldByteListNullOsList.removeAll();
+        RealmList<java.lang.Byte> fieldByteListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteListNull();
+        if (fieldByteListNullList != null) {
+            for (java.lang.Byte fieldByteListNullItem : fieldByteListNullList) {
+                if (fieldByteListNullItem == null) {
+                    fieldByteListNullOsList.addNull();
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, false);
+                    fieldByteListNullOsList.addLong(fieldByteListNullItem.longValue());
                 }
-                Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldFloatNull();
-                if (realmGet$fieldFloatNull != null) {
-                    Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull, false);
+            }
+        }
+
+
+        OsList fieldDoubleListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDoubleListNotNullIndex);
+        fieldDoubleListNotNullOsList.removeAll();
+        RealmList<java.lang.Double> fieldDoubleListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleListNotNull();
+        if (fieldDoubleListNotNullList != null) {
+            for (java.lang.Double fieldDoubleListNotNullItem : fieldDoubleListNotNullList) {
+                if (fieldDoubleListNotNullItem == null) {
+                    fieldDoubleListNotNullOsList.addNull();
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, false);
+                    fieldDoubleListNotNullOsList.addDouble(fieldDoubleListNotNullItem.doubleValue());
                 }
-                Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNotNull();
-                if (realmGet$fieldDoubleNotNull != null) {
-                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull, false);
+            }
+        }
+
+
+        OsList fieldDoubleListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDoubleListNullIndex);
+        fieldDoubleListNullOsList.removeAll();
+        RealmList<java.lang.Double> fieldDoubleListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleListNull();
+        if (fieldDoubleListNullList != null) {
+            for (java.lang.Double fieldDoubleListNullItem : fieldDoubleListNullList) {
+                if (fieldDoubleListNullItem == null) {
+                    fieldDoubleListNullOsList.addNull();
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, false);
+                    fieldDoubleListNullOsList.addDouble(fieldDoubleListNullItem.doubleValue());
                 }
-                Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDoubleNull();
-                if (realmGet$fieldDoubleNull != null) {
-                    Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull, false);
+            }
+        }
+
+
+        OsList fieldFloatListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldFloatListNotNullIndex);
+        fieldFloatListNotNullOsList.removeAll();
+        RealmList<java.lang.Float> fieldFloatListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatListNotNull();
+        if (fieldFloatListNotNullList != null) {
+            for (java.lang.Float fieldFloatListNotNullItem : fieldFloatListNotNullList) {
+                if (fieldFloatListNotNullItem == null) {
+                    fieldFloatListNotNullOsList.addNull();
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, false);
+                    fieldFloatListNotNullOsList.addFloat(fieldFloatListNotNullItem.floatValue());
                 }
-                java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNotNull();
-                if (realmGet$fieldDateNotNull != null) {
-                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime(), false);
+            }
+        }
+
+
+        OsList fieldFloatListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldFloatListNullIndex);
+        fieldFloatListNullOsList.removeAll();
+        RealmList<java.lang.Float> fieldFloatListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatListNull();
+        if (fieldFloatListNullList != null) {
+            for (java.lang.Float fieldFloatListNullItem : fieldFloatListNullList) {
+                if (fieldFloatListNullItem == null) {
+                    fieldFloatListNullOsList.addNull();
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, false);
+                    fieldFloatListNullOsList.addFloat(fieldFloatListNullItem.floatValue());
                 }
-                java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface)object).realmGet$fieldDateNull();
-                if (realmGet$fieldDateNull != null) {
-                    Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime(), false);
+            }
+        }
+
+
+        OsList fieldDateListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDateListNotNullIndex);
+        fieldDateListNotNullOsList.removeAll();
+        RealmList<java.util.Date> fieldDateListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateListNotNull();
+        if (fieldDateListNotNullList != null) {
+            for (java.util.Date fieldDateListNotNullItem : fieldDateListNotNullList) {
+                if (fieldDateListNotNullItem == null) {
+                    fieldDateListNotNullOsList.addNull();
                 } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, false);
+                    fieldDateListNotNullOsList.addDate(fieldDateListNotNullItem);
                 }
+            }
+        }
 
-                some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
-                if (fieldObjectNullObj != null) {
-                    Long cachefieldObjectNull = cache.get(fieldObjectNullObj);
-                    if (cachefieldObjectNull == null) {
-                        cachefieldObjectNull = NullTypesRealmProxy.insertOrUpdate(realm, fieldObjectNullObj, cache);
-                    }
-                    Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull, false);
+
+        OsList fieldDateListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDateListNullIndex);
+        fieldDateListNullOsList.removeAll();
+        RealmList<java.util.Date> fieldDateListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateListNull();
+        if (fieldDateListNullList != null) {
+            for (java.util.Date fieldDateListNullItem : fieldDateListNullList) {
+                if (fieldDateListNullItem == null) {
+                    fieldDateListNullOsList.addNull();
                 } else {
-                    Table.nativeNullifyLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex);
+                    fieldDateListNullOsList.addDate(fieldDateListNullItem);
                 }
             }
         }
+
+        return rowIndex;
+    }
+
+    public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
+        Table table = realm.getTable(some.test.NullTypes.class);
+        long tableNativePtr = table.getNativePtr();
+        NullTypesColumnInfo columnInfo = (NullTypesColumnInfo) realm.getSchema().getColumnInfo(some.test.NullTypes.class);
+        some.test.NullTypes object = null;
+        while (objects.hasNext()) {
+            object = (some.test.NullTypes) objects.next();
+            if (cache.containsKey(object)) {
+                continue;
+            }
+            if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex());
+                continue;
+            }
+            long rowIndex = OsObject.createRow(table);
+            cache.put(object, rowIndex);
+            String realmGet$fieldStringNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringNotNull();
+            if (realmGet$fieldStringNotNull != null) {
+                Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, realmGet$fieldStringNotNull, false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNotNullIndex, rowIndex, false);
+            }
+            String realmGet$fieldStringNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringNull();
+            if (realmGet$fieldStringNull != null) {
+                Table.nativeSetString(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, realmGet$fieldStringNull, false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.fieldStringNullIndex, rowIndex, false);
+            }
+            Boolean realmGet$fieldBooleanNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanNotNull();
+            if (realmGet$fieldBooleanNotNull != null) {
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, realmGet$fieldBooleanNotNull, false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNotNullIndex, rowIndex, false);
+            }
+            Boolean realmGet$fieldBooleanNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanNull();
+            if (realmGet$fieldBooleanNull != null) {
+                Table.nativeSetBoolean(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, realmGet$fieldBooleanNull, false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.fieldBooleanNullIndex, rowIndex, false);
+            }
+            byte[] realmGet$fieldBytesNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldBytesNotNull();
+            if (realmGet$fieldBytesNotNull != null) {
+                Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, realmGet$fieldBytesNotNull, false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNotNullIndex, rowIndex, false);
+            }
+            byte[] realmGet$fieldBytesNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldBytesNull();
+            if (realmGet$fieldBytesNull != null) {
+                Table.nativeSetByteArray(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, realmGet$fieldBytesNull, false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.fieldBytesNullIndex, rowIndex, false);
+            }
+            Number realmGet$fieldByteNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteNotNull();
+            if (realmGet$fieldByteNotNull != null) {
+                Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, realmGet$fieldByteNotNull.longValue(), false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNotNullIndex, rowIndex, false);
+            }
+            Number realmGet$fieldByteNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteNull();
+            if (realmGet$fieldByteNull != null) {
+                Table.nativeSetLong(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, realmGet$fieldByteNull.longValue(), false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.fieldByteNullIndex, rowIndex, false);
+            }
+            Number realmGet$fieldShortNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortNotNull();
+            if (realmGet$fieldShortNotNull != null) {
+                Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, realmGet$fieldShortNotNull.longValue(), false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNotNullIndex, rowIndex, false);
+            }
+            Number realmGet$fieldShortNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortNull();
+            if (realmGet$fieldShortNull != null) {
+                Table.nativeSetLong(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, realmGet$fieldShortNull.longValue(), false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.fieldShortNullIndex, rowIndex, false);
+            }
+            Number realmGet$fieldIntegerNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerNotNull();
+            if (realmGet$fieldIntegerNotNull != null) {
+                Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, realmGet$fieldIntegerNotNull.longValue(), false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNotNullIndex, rowIndex, false);
+            }
+            Number realmGet$fieldIntegerNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerNull();
+            if (realmGet$fieldIntegerNull != null) {
+                Table.nativeSetLong(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, realmGet$fieldIntegerNull.longValue(), false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.fieldIntegerNullIndex, rowIndex, false);
+            }
+            Number realmGet$fieldLongNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongNotNull();
+            if (realmGet$fieldLongNotNull != null) {
+                Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, realmGet$fieldLongNotNull.longValue(), false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNotNullIndex, rowIndex, false);
+            }
+            Number realmGet$fieldLongNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongNull();
+            if (realmGet$fieldLongNull != null) {
+                Table.nativeSetLong(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, realmGet$fieldLongNull.longValue(), false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.fieldLongNullIndex, rowIndex, false);
+            }
+            Float realmGet$fieldFloatNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatNotNull();
+            if (realmGet$fieldFloatNotNull != null) {
+                Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, realmGet$fieldFloatNotNull, false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNotNullIndex, rowIndex, false);
+            }
+            Float realmGet$fieldFloatNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatNull();
+            if (realmGet$fieldFloatNull != null) {
+                Table.nativeSetFloat(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, realmGet$fieldFloatNull, false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.fieldFloatNullIndex, rowIndex, false);
+            }
+            Double realmGet$fieldDoubleNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleNotNull();
+            if (realmGet$fieldDoubleNotNull != null) {
+                Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, realmGet$fieldDoubleNotNull, false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNotNullIndex, rowIndex, false);
+            }
+            Double realmGet$fieldDoubleNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleNull();
+            if (realmGet$fieldDoubleNull != null) {
+                Table.nativeSetDouble(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, realmGet$fieldDoubleNull, false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.fieldDoubleNullIndex, rowIndex, false);
+            }
+            java.util.Date realmGet$fieldDateNotNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateNotNull();
+            if (realmGet$fieldDateNotNull != null) {
+                Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, realmGet$fieldDateNotNull.getTime(), false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNotNullIndex, rowIndex, false);
+            }
+            java.util.Date realmGet$fieldDateNull = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateNull();
+            if (realmGet$fieldDateNull != null) {
+                Table.nativeSetTimestamp(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, realmGet$fieldDateNull.getTime(), false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.fieldDateNullIndex, rowIndex, false);
+            }
+
+            some.test.NullTypes fieldObjectNullObj = ((NullTypesRealmProxyInterface) object).realmGet$fieldObjectNull();
+            if (fieldObjectNullObj != null) {
+                Long cachefieldObjectNull = cache.get(fieldObjectNullObj);
+                if (cachefieldObjectNull == null) {
+                    cachefieldObjectNull = NullTypesRealmProxy.insertOrUpdate(realm, fieldObjectNullObj, cache);
+                }
+                Table.nativeSetLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex, cachefieldObjectNull, false);
+            } else {
+                Table.nativeNullifyLink(tableNativePtr, columnInfo.fieldObjectNullIndex, rowIndex);
+            }
+
+            OsList fieldStringListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldStringListNotNullIndex);
+            fieldStringListNotNullOsList.removeAll();
+            RealmList<java.lang.String> fieldStringListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringListNotNull();
+            if (fieldStringListNotNullList != null) {
+                for (java.lang.String fieldStringListNotNullItem : fieldStringListNotNullList) {
+                    if (fieldStringListNotNullItem == null) {
+                        fieldStringListNotNullOsList.addNull();
+                    } else {
+                        fieldStringListNotNullOsList.addString(fieldStringListNotNullItem);
+                    }
+                }
+            }
+
+
+            OsList fieldStringListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldStringListNullIndex);
+            fieldStringListNullOsList.removeAll();
+            RealmList<java.lang.String> fieldStringListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldStringListNull();
+            if (fieldStringListNullList != null) {
+                for (java.lang.String fieldStringListNullItem : fieldStringListNullList) {
+                    if (fieldStringListNullItem == null) {
+                        fieldStringListNullOsList.addNull();
+                    } else {
+                        fieldStringListNullOsList.addString(fieldStringListNullItem);
+                    }
+                }
+            }
+
+
+            OsList fieldBinaryListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBinaryListNotNullIndex);
+            fieldBinaryListNotNullOsList.removeAll();
+            RealmList<byte[]> fieldBinaryListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBinaryListNotNull();
+            if (fieldBinaryListNotNullList != null) {
+                for (byte[] fieldBinaryListNotNullItem : fieldBinaryListNotNullList) {
+                    if (fieldBinaryListNotNullItem == null) {
+                        fieldBinaryListNotNullOsList.addNull();
+                    } else {
+                        fieldBinaryListNotNullOsList.addBinary(fieldBinaryListNotNullItem);
+                    }
+                }
+            }
+
+
+            OsList fieldBinaryListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBinaryListNullIndex);
+            fieldBinaryListNullOsList.removeAll();
+            RealmList<byte[]> fieldBinaryListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBinaryListNull();
+            if (fieldBinaryListNullList != null) {
+                for (byte[] fieldBinaryListNullItem : fieldBinaryListNullList) {
+                    if (fieldBinaryListNullItem == null) {
+                        fieldBinaryListNullOsList.addNull();
+                    } else {
+                        fieldBinaryListNullOsList.addBinary(fieldBinaryListNullItem);
+                    }
+                }
+            }
+
+
+            OsList fieldBooleanListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBooleanListNotNullIndex);
+            fieldBooleanListNotNullOsList.removeAll();
+            RealmList<java.lang.Boolean> fieldBooleanListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanListNotNull();
+            if (fieldBooleanListNotNullList != null) {
+                for (java.lang.Boolean fieldBooleanListNotNullItem : fieldBooleanListNotNullList) {
+                    if (fieldBooleanListNotNullItem == null) {
+                        fieldBooleanListNotNullOsList.addNull();
+                    } else {
+                        fieldBooleanListNotNullOsList.addBoolean(fieldBooleanListNotNullItem);
+                    }
+                }
+            }
+
+
+            OsList fieldBooleanListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldBooleanListNullIndex);
+            fieldBooleanListNullOsList.removeAll();
+            RealmList<java.lang.Boolean> fieldBooleanListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldBooleanListNull();
+            if (fieldBooleanListNullList != null) {
+                for (java.lang.Boolean fieldBooleanListNullItem : fieldBooleanListNullList) {
+                    if (fieldBooleanListNullItem == null) {
+                        fieldBooleanListNullOsList.addNull();
+                    } else {
+                        fieldBooleanListNullOsList.addBoolean(fieldBooleanListNullItem);
+                    }
+                }
+            }
+
+
+            OsList fieldLongListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldLongListNotNullIndex);
+            fieldLongListNotNullOsList.removeAll();
+            RealmList<java.lang.Long> fieldLongListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongListNotNull();
+            if (fieldLongListNotNullList != null) {
+                for (java.lang.Long fieldLongListNotNullItem : fieldLongListNotNullList) {
+                    if (fieldLongListNotNullItem == null) {
+                        fieldLongListNotNullOsList.addNull();
+                    } else {
+                        fieldLongListNotNullOsList.addLong(fieldLongListNotNullItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList fieldLongListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldLongListNullIndex);
+            fieldLongListNullOsList.removeAll();
+            RealmList<java.lang.Long> fieldLongListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldLongListNull();
+            if (fieldLongListNullList != null) {
+                for (java.lang.Long fieldLongListNullItem : fieldLongListNullList) {
+                    if (fieldLongListNullItem == null) {
+                        fieldLongListNullOsList.addNull();
+                    } else {
+                        fieldLongListNullOsList.addLong(fieldLongListNullItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList fieldIntegerListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldIntegerListNotNullIndex);
+            fieldIntegerListNotNullOsList.removeAll();
+            RealmList<java.lang.Integer> fieldIntegerListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerListNotNull();
+            if (fieldIntegerListNotNullList != null) {
+                for (java.lang.Integer fieldIntegerListNotNullItem : fieldIntegerListNotNullList) {
+                    if (fieldIntegerListNotNullItem == null) {
+                        fieldIntegerListNotNullOsList.addNull();
+                    } else {
+                        fieldIntegerListNotNullOsList.addLong(fieldIntegerListNotNullItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList fieldIntegerListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldIntegerListNullIndex);
+            fieldIntegerListNullOsList.removeAll();
+            RealmList<java.lang.Integer> fieldIntegerListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldIntegerListNull();
+            if (fieldIntegerListNullList != null) {
+                for (java.lang.Integer fieldIntegerListNullItem : fieldIntegerListNullList) {
+                    if (fieldIntegerListNullItem == null) {
+                        fieldIntegerListNullOsList.addNull();
+                    } else {
+                        fieldIntegerListNullOsList.addLong(fieldIntegerListNullItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList fieldShortListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldShortListNotNullIndex);
+            fieldShortListNotNullOsList.removeAll();
+            RealmList<java.lang.Short> fieldShortListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortListNotNull();
+            if (fieldShortListNotNullList != null) {
+                for (java.lang.Short fieldShortListNotNullItem : fieldShortListNotNullList) {
+                    if (fieldShortListNotNullItem == null) {
+                        fieldShortListNotNullOsList.addNull();
+                    } else {
+                        fieldShortListNotNullOsList.addLong(fieldShortListNotNullItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList fieldShortListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldShortListNullIndex);
+            fieldShortListNullOsList.removeAll();
+            RealmList<java.lang.Short> fieldShortListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldShortListNull();
+            if (fieldShortListNullList != null) {
+                for (java.lang.Short fieldShortListNullItem : fieldShortListNullList) {
+                    if (fieldShortListNullItem == null) {
+                        fieldShortListNullOsList.addNull();
+                    } else {
+                        fieldShortListNullOsList.addLong(fieldShortListNullItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList fieldByteListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldByteListNotNullIndex);
+            fieldByteListNotNullOsList.removeAll();
+            RealmList<java.lang.Byte> fieldByteListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteListNotNull();
+            if (fieldByteListNotNullList != null) {
+                for (java.lang.Byte fieldByteListNotNullItem : fieldByteListNotNullList) {
+                    if (fieldByteListNotNullItem == null) {
+                        fieldByteListNotNullOsList.addNull();
+                    } else {
+                        fieldByteListNotNullOsList.addLong(fieldByteListNotNullItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList fieldByteListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldByteListNullIndex);
+            fieldByteListNullOsList.removeAll();
+            RealmList<java.lang.Byte> fieldByteListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldByteListNull();
+            if (fieldByteListNullList != null) {
+                for (java.lang.Byte fieldByteListNullItem : fieldByteListNullList) {
+                    if (fieldByteListNullItem == null) {
+                        fieldByteListNullOsList.addNull();
+                    } else {
+                        fieldByteListNullOsList.addLong(fieldByteListNullItem.longValue());
+                    }
+                }
+            }
+
+
+            OsList fieldDoubleListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDoubleListNotNullIndex);
+            fieldDoubleListNotNullOsList.removeAll();
+            RealmList<java.lang.Double> fieldDoubleListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleListNotNull();
+            if (fieldDoubleListNotNullList != null) {
+                for (java.lang.Double fieldDoubleListNotNullItem : fieldDoubleListNotNullList) {
+                    if (fieldDoubleListNotNullItem == null) {
+                        fieldDoubleListNotNullOsList.addNull();
+                    } else {
+                        fieldDoubleListNotNullOsList.addDouble(fieldDoubleListNotNullItem.doubleValue());
+                    }
+                }
+            }
+
+
+            OsList fieldDoubleListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDoubleListNullIndex);
+            fieldDoubleListNullOsList.removeAll();
+            RealmList<java.lang.Double> fieldDoubleListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDoubleListNull();
+            if (fieldDoubleListNullList != null) {
+                for (java.lang.Double fieldDoubleListNullItem : fieldDoubleListNullList) {
+                    if (fieldDoubleListNullItem == null) {
+                        fieldDoubleListNullOsList.addNull();
+                    } else {
+                        fieldDoubleListNullOsList.addDouble(fieldDoubleListNullItem.doubleValue());
+                    }
+                }
+            }
+
+
+            OsList fieldFloatListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldFloatListNotNullIndex);
+            fieldFloatListNotNullOsList.removeAll();
+            RealmList<java.lang.Float> fieldFloatListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatListNotNull();
+            if (fieldFloatListNotNullList != null) {
+                for (java.lang.Float fieldFloatListNotNullItem : fieldFloatListNotNullList) {
+                    if (fieldFloatListNotNullItem == null) {
+                        fieldFloatListNotNullOsList.addNull();
+                    } else {
+                        fieldFloatListNotNullOsList.addFloat(fieldFloatListNotNullItem.floatValue());
+                    }
+                }
+            }
+
+
+            OsList fieldFloatListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldFloatListNullIndex);
+            fieldFloatListNullOsList.removeAll();
+            RealmList<java.lang.Float> fieldFloatListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldFloatListNull();
+            if (fieldFloatListNullList != null) {
+                for (java.lang.Float fieldFloatListNullItem : fieldFloatListNullList) {
+                    if (fieldFloatListNullItem == null) {
+                        fieldFloatListNullOsList.addNull();
+                    } else {
+                        fieldFloatListNullOsList.addFloat(fieldFloatListNullItem.floatValue());
+                    }
+                }
+            }
+
+
+            OsList fieldDateListNotNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDateListNotNullIndex);
+            fieldDateListNotNullOsList.removeAll();
+            RealmList<java.util.Date> fieldDateListNotNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateListNotNull();
+            if (fieldDateListNotNullList != null) {
+                for (java.util.Date fieldDateListNotNullItem : fieldDateListNotNullList) {
+                    if (fieldDateListNotNullItem == null) {
+                        fieldDateListNotNullOsList.addNull();
+                    } else {
+                        fieldDateListNotNullOsList.addDate(fieldDateListNotNullItem);
+                    }
+                }
+            }
+
+
+            OsList fieldDateListNullOsList = new OsList(table.getUncheckedRow(rowIndex), columnInfo.fieldDateListNullIndex);
+            fieldDateListNullOsList.removeAll();
+            RealmList<java.util.Date> fieldDateListNullList = ((NullTypesRealmProxyInterface) object).realmGet$fieldDateListNull();
+            if (fieldDateListNullList != null) {
+                for (java.util.Date fieldDateListNullItem : fieldDateListNullList) {
+                    if (fieldDateListNullItem == null) {
+                        fieldDateListNullOsList.addNull();
+                    } else {
+                        fieldDateListNullOsList.addDate(fieldDateListNullItem);
+                    }
+                }
+            }
+
+        }
     }
 
     public static some.test.NullTypes createDetachedCopy(some.test.NullTypes realmObject, int currentDepth, int maxDepth, Map<RealmModel, CacheData<RealmModel>> cache) {
@@ -2015,41 +3860,103 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
         }
         CacheData<RealmModel> cachedObject = cache.get(realmObject);
         some.test.NullTypes unmanagedObject;
-        if (cachedObject != null) {
+        if (cachedObject == null) {
+            unmanagedObject = new some.test.NullTypes();
+            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject));
+        } else {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
             if (currentDepth >= cachedObject.minDepth) {
-                return (some.test.NullTypes)cachedObject.object;
-            } else {
-                unmanagedObject = (some.test.NullTypes)cachedObject.object;
-                cachedObject.minDepth = currentDepth;
+                return (some.test.NullTypes) cachedObject.object;
             }
-        } else {
-            unmanagedObject = new some.test.NullTypes();
-            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject));
-        }
-        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldStringNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldStringNotNull());
-        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldStringNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldStringNull());
-        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldBooleanNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBooleanNotNull());
-        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldBooleanNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBooleanNull());
-        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldBytesNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBytesNotNull());
-        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldBytesNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldBytesNull());
-        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldByteNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldByteNotNull());
-        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldByteNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldByteNull());
-        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldShortNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldShortNotNull());
-        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldShortNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldShortNull());
-        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldIntegerNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldIntegerNotNull());
-        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldIntegerNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldIntegerNull());
-        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldLongNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldLongNotNull());
-        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldLongNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldLongNull());
-        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldFloatNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldFloatNotNull());
-        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldFloatNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldFloatNull());
-        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldDoubleNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDoubleNotNull());
-        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldDoubleNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDoubleNull());
-        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldDateNotNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDateNotNull());
-        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldDateNull(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldDateNull());
+            unmanagedObject = (some.test.NullTypes) cachedObject.object;
+            cachedObject.minDepth = currentDepth;
+        }
+        NullTypesRealmProxyInterface unmanagedCopy = (NullTypesRealmProxyInterface) unmanagedObject;
+        NullTypesRealmProxyInterface realmSource = (NullTypesRealmProxyInterface) realmObject;
+        unmanagedCopy.realmSet$fieldStringNotNull(realmSource.realmGet$fieldStringNotNull());
+        unmanagedCopy.realmSet$fieldStringNull(realmSource.realmGet$fieldStringNull());
+        unmanagedCopy.realmSet$fieldBooleanNotNull(realmSource.realmGet$fieldBooleanNotNull());
+        unmanagedCopy.realmSet$fieldBooleanNull(realmSource.realmGet$fieldBooleanNull());
+        unmanagedCopy.realmSet$fieldBytesNotNull(realmSource.realmGet$fieldBytesNotNull());
+        unmanagedCopy.realmSet$fieldBytesNull(realmSource.realmGet$fieldBytesNull());
+        unmanagedCopy.realmSet$fieldByteNotNull(realmSource.realmGet$fieldByteNotNull());
+        unmanagedCopy.realmSet$fieldByteNull(realmSource.realmGet$fieldByteNull());
+        unmanagedCopy.realmSet$fieldShortNotNull(realmSource.realmGet$fieldShortNotNull());
+        unmanagedCopy.realmSet$fieldShortNull(realmSource.realmGet$fieldShortNull());
+        unmanagedCopy.realmSet$fieldIntegerNotNull(realmSource.realmGet$fieldIntegerNotNull());
+        unmanagedCopy.realmSet$fieldIntegerNull(realmSource.realmGet$fieldIntegerNull());
+        unmanagedCopy.realmSet$fieldLongNotNull(realmSource.realmGet$fieldLongNotNull());
+        unmanagedCopy.realmSet$fieldLongNull(realmSource.realmGet$fieldLongNull());
+        unmanagedCopy.realmSet$fieldFloatNotNull(realmSource.realmGet$fieldFloatNotNull());
+        unmanagedCopy.realmSet$fieldFloatNull(realmSource.realmGet$fieldFloatNull());
+        unmanagedCopy.realmSet$fieldDoubleNotNull(realmSource.realmGet$fieldDoubleNotNull());
+        unmanagedCopy.realmSet$fieldDoubleNull(realmSource.realmGet$fieldDoubleNull());
+        unmanagedCopy.realmSet$fieldDateNotNull(realmSource.realmGet$fieldDateNotNull());
+        unmanagedCopy.realmSet$fieldDateNull(realmSource.realmGet$fieldDateNull());
 
         // Deep copy of fieldObjectNull
-        ((NullTypesRealmProxyInterface) unmanagedObject).realmSet$fieldObjectNull(NullTypesRealmProxy.createDetachedCopy(((NullTypesRealmProxyInterface) realmObject).realmGet$fieldObjectNull(), currentDepth + 1, maxDepth, cache));
+        unmanagedCopy.realmSet$fieldObjectNull(NullTypesRealmProxy.createDetachedCopy(realmSource.realmGet$fieldObjectNull(), currentDepth + 1, maxDepth, cache));
+
+        unmanagedCopy.realmSet$fieldStringListNotNull(new RealmList<java.lang.String>());
+        unmanagedCopy.realmGet$fieldStringListNotNull().addAll(realmSource.realmGet$fieldStringListNotNull());
+
+        unmanagedCopy.realmSet$fieldStringListNull(new RealmList<java.lang.String>());
+        unmanagedCopy.realmGet$fieldStringListNull().addAll(realmSource.realmGet$fieldStringListNull());
+
+        unmanagedCopy.realmSet$fieldBinaryListNotNull(new RealmList<byte[]>());
+        unmanagedCopy.realmGet$fieldBinaryListNotNull().addAll(realmSource.realmGet$fieldBinaryListNotNull());
+
+        unmanagedCopy.realmSet$fieldBinaryListNull(new RealmList<byte[]>());
+        unmanagedCopy.realmGet$fieldBinaryListNull().addAll(realmSource.realmGet$fieldBinaryListNull());
+
+        unmanagedCopy.realmSet$fieldBooleanListNotNull(new RealmList<java.lang.Boolean>());
+        unmanagedCopy.realmGet$fieldBooleanListNotNull().addAll(realmSource.realmGet$fieldBooleanListNotNull());
+
+        unmanagedCopy.realmSet$fieldBooleanListNull(new RealmList<java.lang.Boolean>());
+        unmanagedCopy.realmGet$fieldBooleanListNull().addAll(realmSource.realmGet$fieldBooleanListNull());
+
+        unmanagedCopy.realmSet$fieldLongListNotNull(new RealmList<java.lang.Long>());
+        unmanagedCopy.realmGet$fieldLongListNotNull().addAll(realmSource.realmGet$fieldLongListNotNull());
+
+        unmanagedCopy.realmSet$fieldLongListNull(new RealmList<java.lang.Long>());
+        unmanagedCopy.realmGet$fieldLongListNull().addAll(realmSource.realmGet$fieldLongListNull());
+
+        unmanagedCopy.realmSet$fieldIntegerListNotNull(new RealmList<java.lang.Integer>());
+        unmanagedCopy.realmGet$fieldIntegerListNotNull().addAll(realmSource.realmGet$fieldIntegerListNotNull());
+
+        unmanagedCopy.realmSet$fieldIntegerListNull(new RealmList<java.lang.Integer>());
+        unmanagedCopy.realmGet$fieldIntegerListNull().addAll(realmSource.realmGet$fieldIntegerListNull());
+
+        unmanagedCopy.realmSet$fieldShortListNotNull(new RealmList<java.lang.Short>());
+        unmanagedCopy.realmGet$fieldShortListNotNull().addAll(realmSource.realmGet$fieldShortListNotNull());
+
+        unmanagedCopy.realmSet$fieldShortListNull(new RealmList<java.lang.Short>());
+        unmanagedCopy.realmGet$fieldShortListNull().addAll(realmSource.realmGet$fieldShortListNull());
+
+        unmanagedCopy.realmSet$fieldByteListNotNull(new RealmList<java.lang.Byte>());
+        unmanagedCopy.realmGet$fieldByteListNotNull().addAll(realmSource.realmGet$fieldByteListNotNull());
+
+        unmanagedCopy.realmSet$fieldByteListNull(new RealmList<java.lang.Byte>());
+        unmanagedCopy.realmGet$fieldByteListNull().addAll(realmSource.realmGet$fieldByteListNull());
+
+        unmanagedCopy.realmSet$fieldDoubleListNotNull(new RealmList<java.lang.Double>());
+        unmanagedCopy.realmGet$fieldDoubleListNotNull().addAll(realmSource.realmGet$fieldDoubleListNotNull());
+
+        unmanagedCopy.realmSet$fieldDoubleListNull(new RealmList<java.lang.Double>());
+        unmanagedCopy.realmGet$fieldDoubleListNull().addAll(realmSource.realmGet$fieldDoubleListNull());
+
+        unmanagedCopy.realmSet$fieldFloatListNotNull(new RealmList<java.lang.Float>());
+        unmanagedCopy.realmGet$fieldFloatListNotNull().addAll(realmSource.realmGet$fieldFloatListNotNull());
+
+        unmanagedCopy.realmSet$fieldFloatListNull(new RealmList<java.lang.Float>());
+        unmanagedCopy.realmGet$fieldFloatListNull().addAll(realmSource.realmGet$fieldFloatListNull());
+
+        unmanagedCopy.realmSet$fieldDateListNotNull(new RealmList<java.util.Date>());
+        unmanagedCopy.realmGet$fieldDateListNotNull().addAll(realmSource.realmGet$fieldDateListNotNull());
+
+        unmanagedCopy.realmSet$fieldDateListNull(new RealmList<java.util.Date>());
+        unmanagedCopy.realmGet$fieldDateListNull().addAll(realmSource.realmGet$fieldDateListNull());
+
         return unmanagedObject;
     }
 
@@ -2059,7 +3966,7 @@ public String toString() {
         if (!RealmObject.isValid(this)) {
             return "Invalid object";
         }
-        StringBuilder stringBuilder = new StringBuilder("NullTypes = [");
+        StringBuilder stringBuilder = new StringBuilder("NullTypes = proxy[");
         stringBuilder.append("{fieldStringNotNull:");
         stringBuilder.append(realmGet$fieldStringNotNull());
         stringBuilder.append("}");
@@ -2143,6 +4050,86 @@ public String toString() {
         stringBuilder.append("{fieldObjectNull:");
         stringBuilder.append(realmGet$fieldObjectNull() != null ? "NullTypes" : "null");
         stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldStringListNotNull:");
+        stringBuilder.append("RealmList<String>[").append(realmGet$fieldStringListNotNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldStringListNull:");
+        stringBuilder.append("RealmList<String>[").append(realmGet$fieldStringListNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldBinaryListNotNull:");
+        stringBuilder.append("RealmList<byte[]>[").append(realmGet$fieldBinaryListNotNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldBinaryListNull:");
+        stringBuilder.append("RealmList<byte[]>[").append(realmGet$fieldBinaryListNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldBooleanListNotNull:");
+        stringBuilder.append("RealmList<Boolean>[").append(realmGet$fieldBooleanListNotNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldBooleanListNull:");
+        stringBuilder.append("RealmList<Boolean>[").append(realmGet$fieldBooleanListNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldLongListNotNull:");
+        stringBuilder.append("RealmList<Long>[").append(realmGet$fieldLongListNotNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldLongListNull:");
+        stringBuilder.append("RealmList<Long>[").append(realmGet$fieldLongListNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldIntegerListNotNull:");
+        stringBuilder.append("RealmList<Integer>[").append(realmGet$fieldIntegerListNotNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldIntegerListNull:");
+        stringBuilder.append("RealmList<Integer>[").append(realmGet$fieldIntegerListNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldShortListNotNull:");
+        stringBuilder.append("RealmList<Short>[").append(realmGet$fieldShortListNotNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldShortListNull:");
+        stringBuilder.append("RealmList<Short>[").append(realmGet$fieldShortListNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldByteListNotNull:");
+        stringBuilder.append("RealmList<Byte>[").append(realmGet$fieldByteListNotNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldByteListNull:");
+        stringBuilder.append("RealmList<Byte>[").append(realmGet$fieldByteListNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldDoubleListNotNull:");
+        stringBuilder.append("RealmList<Double>[").append(realmGet$fieldDoubleListNotNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldDoubleListNull:");
+        stringBuilder.append("RealmList<Double>[").append(realmGet$fieldDoubleListNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldFloatListNotNull:");
+        stringBuilder.append("RealmList<Float>[").append(realmGet$fieldFloatListNotNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldFloatListNull:");
+        stringBuilder.append("RealmList<Float>[").append(realmGet$fieldFloatListNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldDateListNotNull:");
+        stringBuilder.append("RealmList<Date>[").append(realmGet$fieldDateListNotNull().size()).append("]");
+        stringBuilder.append("}");
+        stringBuilder.append(",");
+        stringBuilder.append("{fieldDateListNull:");
+        stringBuilder.append("RealmList<Date>[").append(realmGet$fieldDateListNull().size()).append("]");
+        stringBuilder.append("}");
         stringBuilder.append("]");
         return stringBuilder.toString();
     }
@@ -2183,5 +4170,4 @@ public boolean equals(Object o) {
 
         return true;
     }
-
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
index 4460594efa..c8f0dc1849 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/RealmDefaultModuleMediator.java
@@ -2,13 +2,13 @@
 
 
 import android.util.JsonReader;
-import io.realm.RealmObjectSchema;
 import io.realm.internal.ColumnInfo;
+import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.OsSchemaInfo;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
-import io.realm.internal.Table;
 import java.io.IOException;
 import java.util.Collection;
 import java.util.Collections;
@@ -26,27 +26,25 @@
 
     private static final Set<Class<? extends RealmModel>> MODEL_CLASSES;
     static {
-        Set<Class<? extends RealmModel>> modelClasses = new HashSet<Class<? extends RealmModel>>();
+        Set<Class<? extends RealmModel>> modelClasses = new HashSet<Class<? extends RealmModel>>(1);
         modelClasses.add(some.test.AllTypes.class);
         MODEL_CLASSES = Collections.unmodifiableSet(modelClasses);
     }
 
     @Override
-    public RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema realmSchema) {
-        checkClass(clazz);
-
-        if (clazz.equals(some.test.AllTypes.class)) {
-            return io.realm.AllTypesRealmProxy.createRealmObjectSchema(realmSchema);
-        }
-        throw getMissingProxyClassException(clazz);
+    public Map<Class<? extends RealmModel>, OsObjectSchemaInfo> getExpectedObjectSchemaInfoMap() {
+        Map<Class<? extends RealmModel>, OsObjectSchemaInfo> infoMap =
+                    new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>(1);
+        infoMap.put(some.test.AllTypes.class, io.realm.AllTypesRealmProxy.getExpectedObjectSchemaInfo());
+        return infoMap;
     }
 
     @Override
-    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm, boolean allowExtraColumns) {
+    public ColumnInfo createColumnInfo(Class<? extends RealmModel> clazz, OsSchemaInfo schemaInfo) {
         checkClass(clazz);
 
         if (clazz.equals(some.test.AllTypes.class)) {
-            return io.realm.AllTypesRealmProxy.validateTable(sharedRealm, allowExtraColumns);
+            return io.realm.AllTypesRealmProxy.createColumnInfo(schemaInfo);
         }
         throw getMissingProxyClassException(clazz);
     }
@@ -62,11 +60,11 @@ public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm s
     }
 
     @Override
-    public String getTableName(Class<? extends RealmModel> clazz) {
+    public String getSimpleClassNameImpl(Class<? extends RealmModel> clazz) {
         checkClass(clazz);
 
         if (clazz.equals(some.test.AllTypes.class)) {
-            return io.realm.AllTypesRealmProxy.getTableName();
+            return io.realm.AllTypesRealmProxy.getSimpleClassName();
         }
         throw getMissingProxyClassException(clazz);
     }
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index 030081db38..150ca08c9c 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -5,11 +5,14 @@
 import android.os.Build;
 import android.util.JsonReader;
 import android.util.JsonToken;
-import io.realm.RealmObjectSchema;
-import io.realm.RealmSchema;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.LinkView;
+import io.realm.internal.OsList;
+import io.realm.internal.OsObject;
+import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.OsSchemaInfo;
+import io.realm.internal.Property;
+import io.realm.internal.ProxyUtils;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
@@ -28,50 +31,52 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 
+@SuppressWarnings("all")
 public class SimpleRealmProxy extends some.test.Simple
         implements RealmObjectProxy, SimpleRealmProxyInterface {
 
-    static final class SimpleColumnInfo extends ColumnInfo
-            implements Cloneable {
+    static final class SimpleColumnInfo extends ColumnInfo {
+        long nameIndex;
+        long ageIndex;
 
-        public long nameIndex;
-        public long ageIndex;
-
-        SimpleColumnInfo(String path, Table table) {
-            final Map<String, Long> indicesMap = new HashMap<String, Long>(2);
-            this.nameIndex = getValidColumnIndex(path, table, "Simple", "name");
-            indicesMap.put("name", this.nameIndex);
-            this.ageIndex = getValidColumnIndex(path, table, "Simple", "age");
-            indicesMap.put("age", this.ageIndex);
+        SimpleColumnInfo(OsSchemaInfo schemaInfo) {
+            super(2);
+            OsObjectSchemaInfo objectSchemaInfo = schemaInfo.getObjectSchemaInfo("Simple");
+            this.nameIndex = addColumnDetails("name", objectSchemaInfo);
+            this.ageIndex = addColumnDetails("age", objectSchemaInfo);
+        }
 
-            setIndicesMap(indicesMap);
+        SimpleColumnInfo(ColumnInfo src, boolean mutable) {
+            super(src, mutable);
+            copy(src, this);
         }
 
         @Override
-        public final void copyColumnInfoFrom(ColumnInfo other) {
-            final SimpleColumnInfo otherInfo = (SimpleColumnInfo) other;
-            this.nameIndex = otherInfo.nameIndex;
-            this.ageIndex = otherInfo.ageIndex;
-
-            setIndicesMap(otherInfo.getIndicesMap());
+        protected final ColumnInfo copy(boolean mutable) {
+            return new SimpleColumnInfo(this, mutable);
         }
 
         @Override
-        public final SimpleColumnInfo clone() {
-            return (SimpleColumnInfo) super.clone();
+        protected final void copy(ColumnInfo rawSrc, ColumnInfo rawDst) {
+            final SimpleColumnInfo src = (SimpleColumnInfo) rawSrc;
+            final SimpleColumnInfo dst = (SimpleColumnInfo) rawDst;
+            dst.nameIndex = src.nameIndex;
+            dst.ageIndex = src.ageIndex;
         }
-
     }
-    private SimpleColumnInfo columnInfo;
-    private ProxyState<some.test.Simple> proxyState;
+
+    private static final OsObjectSchemaInfo expectedObjectSchemaInfo = createExpectedObjectSchemaInfo();
     private static final List<String> FIELD_NAMES;
     static {
-        List<String> fieldNames = new ArrayList<String>();
+        List<String> fieldNames = new ArrayList<String>(2);
         fieldNames.add("name");
         fieldNames.add("age");
         FIELD_NAMES = Collections.unmodifiableList(fieldNames);
     }
 
+    private SimpleColumnInfo columnInfo;
+    private ProxyState<some.test.Simple> proxyState;
+
     SimpleRealmProxy() {
         proxyState.setConstructionFinished();
     }
@@ -142,67 +147,23 @@ public final SimpleColumnInfo clone() {
         proxyState.getRow$realm().setLong(columnInfo.ageIndex, value);
     }
 
-    public static RealmObjectSchema createRealmObjectSchema(RealmSchema realmSchema) {
-        if (!realmSchema.contains("Simple")) {
-            RealmObjectSchema realmObjectSchema = realmSchema.create("Simple");
-            realmObjectSchema.add("name", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
-            realmObjectSchema.add("age", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
-            return realmObjectSchema;
-        }
-        return realmSchema.get("Simple");
+    private static OsObjectSchemaInfo createExpectedObjectSchemaInfo() {
+        OsObjectSchemaInfo.Builder builder = new OsObjectSchemaInfo.Builder("Simple", 2, 0);
+        builder.addPersistedProperty("name", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED);
+        builder.addPersistedProperty("age", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED);
+        return builder.build();
     }
 
-    public static SimpleColumnInfo validateTable(SharedRealm sharedRealm, boolean allowExtraColumns) {
-        if (!sharedRealm.hasTable("class_Simple")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "The 'Simple' class is missing from the schema for this Realm.");
-        }
-        Table table = sharedRealm.getTable("class_Simple");
-        final long columnCount = table.getColumnCount();
-        if (columnCount != 2) {
-            if (columnCount < 2) {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is less than expected - expected 2 but was " + columnCount);
-            }
-            if (allowExtraColumns) {
-                RealmLog.debug("Field count is more than expected - expected 2 but was %1$d", columnCount);
-            } else {
-                throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field count is more than expected - expected 2 but was " + columnCount);
-            }
-        }
-        Map<String, RealmFieldType> columnTypes = new HashMap<String, RealmFieldType>();
-        for (long i = 0; i < columnCount; i++) {
-            columnTypes.put(table.getColumnName(i), table.getColumnType(i));
-        }
-
-        final SimpleColumnInfo columnInfo = new SimpleColumnInfo(sharedRealm.getPath(), table);
-
-        if (table.hasPrimaryKey()) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Primary Key defined for field " + table.getColumnName(table.getPrimaryKey()) + " was removed.");
-        }
-
-        if (!columnTypes.containsKey("name")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'name' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("name") != RealmFieldType.STRING) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'String' for field 'name' in existing Realm file.");
-        }
-        if (!table.isColumnNullable(columnInfo.nameIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'name' is required. Either set @Required to field 'name' or migrate using RealmObjectSchema.setNullable().");
-        }
-        if (!columnTypes.containsKey("age")) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Missing field 'age' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().");
-        }
-        if (columnTypes.get("age") != RealmFieldType.INTEGER) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Invalid type 'int' for field 'age' in existing Realm file.");
-        }
-        if (table.isColumnNullable(columnInfo.ageIndex)) {
-            throw new RealmMigrationNeededException(sharedRealm.getPath(), "Field 'age' does support null values in the existing Realm file. Use corresponding boxed type for field 'age' or migrate using RealmObjectSchema.setNullable().");
-        }
+    public static OsObjectSchemaInfo getExpectedObjectSchemaInfo() {
+        return expectedObjectSchemaInfo;
+    }
 
-        return columnInfo;
+    public static SimpleColumnInfo createColumnInfo(OsSchemaInfo schemaInfo) {
+        return new SimpleColumnInfo(schemaInfo);
     }
 
-    public static String getTableName() {
-        return "class_Simple";
+    public static String getSimpleClassName() {
+        return "Simple";
     }
 
     public static List<String> getFieldNames() {
@@ -214,18 +175,20 @@ public static String getTableName() {
             throws JSONException {
         final List<String> excludeFields = Collections.<String> emptyList();
         some.test.Simple obj = realm.createObjectInternal(some.test.Simple.class, true, excludeFields);
+
+        final SimpleRealmProxyInterface objProxy = (SimpleRealmProxyInterface) obj;
         if (json.has("name")) {
             if (json.isNull("name")) {
-                ((SimpleRealmProxyInterface) obj).realmSet$name(null);
+                objProxy.realmSet$name(null);
             } else {
-                ((SimpleRealmProxyInterface) obj).realmSet$name((String) json.getString("name"));
+                objProxy.realmSet$name((String) json.getString("name"));
             }
         }
         if (json.has("age")) {
             if (json.isNull("age")) {
                 throw new IllegalArgumentException("Trying to set non-nullable field 'age' to null.");
             } else {
-                ((SimpleRealmProxyInterface) obj).realmSet$age((int) json.getInt("age"));
+                objProxy.realmSet$age((int) json.getInt("age"));
             }
         }
         return obj;
@@ -235,145 +198,154 @@ public static String getTableName() {
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
     public static some.test.Simple createUsingJsonStream(Realm realm, JsonReader reader)
             throws IOException {
-        some.test.Simple obj = new some.test.Simple();
+        final some.test.Simple obj = new some.test.Simple();
+        final SimpleRealmProxyInterface objProxy = (SimpleRealmProxyInterface) obj;
         reader.beginObject();
         while (reader.hasNext()) {
             String name = reader.nextName();
             if (false) {
             } else if (name.equals("name")) {
-                if (reader.peek() == JsonToken.NULL) {
-                    reader.skipValue();
-                    ((SimpleRealmProxyInterface) obj).realmSet$name(null);
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$name((String) reader.nextString());
                 } else {
-                    ((SimpleRealmProxyInterface) obj).realmSet$name((String) reader.nextString());
+                    reader.skipValue();
+                    objProxy.realmSet$name(null);
                 }
             } else if (name.equals("age")) {
-                if (reader.peek() == JsonToken.NULL) {
+                if (reader.peek() != JsonToken.NULL) {
+                    objProxy.realmSet$age((int) reader.nextInt());
+                } else {
                     reader.skipValue();
                     throw new IllegalArgumentException("Trying to set non-nullable field 'age' to null.");
-                } else {
-                    ((SimpleRealmProxyInterface) obj).realmSet$age((int) reader.nextInt());
                 }
             } else {
                 reader.skipValue();
             }
         }
         reader.endObject();
-        obj = realm.copyToRealm(obj);
-        return obj;
+        return realm.copyToRealm(obj);
     }
 
     public static some.test.Simple copyOrUpdate(Realm realm, some.test.Simple object, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().threadId != realm.threadId) {
-            throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
-        }
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-            return object;
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null) {
+            final BaseRealm otherRealm = ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm();
+            if (otherRealm.threadId != realm.threadId) {
+                throw new IllegalArgumentException("Objects which belong to Realm instances in other threads cannot be copied into this Realm instance.");
+            }
+            if (otherRealm.getPath().equals(realm.getPath())) {
+                return object;
+            }
         }
         final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
         RealmObjectProxy cachedRealmObject = cache.get(object);
         if (cachedRealmObject != null) {
             return (some.test.Simple) cachedRealmObject;
-        } else {
-            return copy(realm, object, update, cache);
         }
+
+        return copy(realm, object, update, cache);
     }
 
     public static some.test.Simple copy(Realm realm, some.test.Simple newObject, boolean update, Map<RealmModel,RealmObjectProxy> cache) {
         RealmObjectProxy cachedRealmObject = cache.get(newObject);
         if (cachedRealmObject != null) {
             return (some.test.Simple) cachedRealmObject;
-        } else {
-            // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
-            some.test.Simple realmObject = realm.createObjectInternal(some.test.Simple.class, false, Collections.<String>emptyList());
-            cache.put(newObject, (RealmObjectProxy) realmObject);
-            ((SimpleRealmProxyInterface) realmObject).realmSet$name(((SimpleRealmProxyInterface) newObject).realmGet$name());
-            ((SimpleRealmProxyInterface) realmObject).realmSet$age(((SimpleRealmProxyInterface) newObject).realmGet$age());
-            return realmObject;
         }
+
+        // rejecting default values to avoid creating unexpected objects from RealmModel/RealmList fields.
+        some.test.Simple realmObject = realm.createObjectInternal(some.test.Simple.class, false, Collections.<String>emptyList());
+        cache.put(newObject, (RealmObjectProxy) realmObject);
+
+        SimpleRealmProxyInterface realmObjectSource = (SimpleRealmProxyInterface) newObject;
+        SimpleRealmProxyInterface realmObjectCopy = (SimpleRealmProxyInterface) realmObject;
+
+        realmObjectCopy.realmSet$name(realmObjectSource.realmGet$name());
+        realmObjectCopy.realmSet$age(realmObjectSource.realmGet$age());
+        return realmObject;
     }
 
     public static long insert(Realm realm, some.test.Simple object, Map<RealmModel,Long> cache) {
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-            return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+            return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex();
         }
         Table table = realm.getTable(some.test.Simple.class);
-        long tableNativePtr = table.getNativeTablePointer();
-        SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.schema.getColumnInfo(some.test.Simple.class);
-        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+        long tableNativePtr = table.getNativePtr();
+        SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.getSchema().getColumnInfo(some.test.Simple.class);
+        long rowIndex = OsObject.createRow(table);
         cache.put(object, rowIndex);
-        String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
+        String realmGet$name = ((SimpleRealmProxyInterface) object).realmGet$name();
         if (realmGet$name != null) {
             Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name, false);
         }
-        Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age(), false);
+        Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface) object).realmGet$age(), false);
         return rowIndex;
     }
 
     public static void insert(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
         Table table = realm.getTable(some.test.Simple.class);
-        long tableNativePtr = table.getNativeTablePointer();
-        SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.schema.getColumnInfo(some.test.Simple.class);
+        long tableNativePtr = table.getNativePtr();
+        SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.getSchema().getColumnInfo(some.test.Simple.class);
         some.test.Simple object = null;
         while (objects.hasNext()) {
             object = (some.test.Simple) objects.next();
-            if(!cache.containsKey(object)) {
-                if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-                    cache.put(object, ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex());
-                    continue;
-                }
-                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
-                cache.put(object, rowIndex);
-                String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
-                if (realmGet$name != null) {
-                    Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name, false);
-                }
-                Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age(), false);
+            if (cache.containsKey(object)) {
+                continue;
+            }
+            if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex());
+                continue;
             }
+            long rowIndex = OsObject.createRow(table);
+            cache.put(object, rowIndex);
+            String realmGet$name = ((SimpleRealmProxyInterface) object).realmGet$name();
+            if (realmGet$name != null) {
+                Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name, false);
+            }
+            Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface) object).realmGet$age(), false);
         }
     }
 
     public static long insertOrUpdate(Realm realm, some.test.Simple object, Map<RealmModel,Long> cache) {
-        if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-            return ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex();
+        if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+            return ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex();
         }
         Table table = realm.getTable(some.test.Simple.class);
-        long tableNativePtr = table.getNativeTablePointer();
-        SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.schema.getColumnInfo(some.test.Simple.class);
-        long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
+        long tableNativePtr = table.getNativePtr();
+        SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.getSchema().getColumnInfo(some.test.Simple.class);
+        long rowIndex = OsObject.createRow(table);
         cache.put(object, rowIndex);
-        String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
+        String realmGet$name = ((SimpleRealmProxyInterface) object).realmGet$name();
         if (realmGet$name != null) {
             Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name, false);
         } else {
             Table.nativeSetNull(tableNativePtr, columnInfo.nameIndex, rowIndex, false);
         }
-        Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age(), false);
+        Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface) object).realmGet$age(), false);
         return rowIndex;
     }
 
     public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> objects, Map<RealmModel,Long> cache) {
         Table table = realm.getTable(some.test.Simple.class);
-        long tableNativePtr = table.getNativeTablePointer();
-        SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.schema.getColumnInfo(some.test.Simple.class);
+        long tableNativePtr = table.getNativePtr();
+        SimpleColumnInfo columnInfo = (SimpleColumnInfo) realm.getSchema().getColumnInfo(some.test.Simple.class);
         some.test.Simple object = null;
         while (objects.hasNext()) {
             object = (some.test.Simple) objects.next();
-            if(!cache.containsKey(object)) {
-                if (object instanceof RealmObjectProxy && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy)object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-                    cache.put(object, ((RealmObjectProxy)object).realmGet$proxyState().getRow$realm().getIndex());
-                    continue;
-                }
-                long rowIndex = Table.nativeAddEmptyRow(tableNativePtr, 1);
-                cache.put(object, rowIndex);
-                String realmGet$name = ((SimpleRealmProxyInterface)object).realmGet$name();
-                if (realmGet$name != null) {
-                    Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name, false);
-                } else {
-                    Table.nativeSetNull(tableNativePtr, columnInfo.nameIndex, rowIndex, false);
-                }
-                Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface)object).realmGet$age(), false);
+            if (cache.containsKey(object)) {
+                continue;
             }
+            if (object instanceof RealmObjectProxy && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm() != null && ((RealmObjectProxy) object).realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                cache.put(object, ((RealmObjectProxy) object).realmGet$proxyState().getRow$realm().getIndex());
+                continue;
+            }
+            long rowIndex = OsObject.createRow(table);
+            cache.put(object, rowIndex);
+            String realmGet$name = ((SimpleRealmProxyInterface) object).realmGet$name();
+            if (realmGet$name != null) {
+                Table.nativeSetString(tableNativePtr, columnInfo.nameIndex, rowIndex, realmGet$name, false);
+            } else {
+                Table.nativeSetNull(tableNativePtr, columnInfo.nameIndex, rowIndex, false);
+            }
+            Table.nativeSetLong(tableNativePtr, columnInfo.ageIndex, rowIndex, ((SimpleRealmProxyInterface) object).realmGet$age(), false);
         }
     }
 
@@ -383,20 +355,22 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
         }
         CacheData<RealmModel> cachedObject = cache.get(realmObject);
         some.test.Simple unmanagedObject;
-        if (cachedObject != null) {
+        if (cachedObject == null) {
+            unmanagedObject = new some.test.Simple();
+            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject));
+        } else {
             // Reuse cached object or recreate it because it was encountered at a lower depth.
             if (currentDepth >= cachedObject.minDepth) {
-                return (some.test.Simple)cachedObject.object;
-            } else {
-                unmanagedObject = (some.test.Simple)cachedObject.object;
-                cachedObject.minDepth = currentDepth;
+                return (some.test.Simple) cachedObject.object;
             }
-        } else {
-            unmanagedObject = new some.test.Simple();
-            cache.put(realmObject, new RealmObjectProxy.CacheData<RealmModel>(currentDepth, unmanagedObject));
+            unmanagedObject = (some.test.Simple) cachedObject.object;
+            cachedObject.minDepth = currentDepth;
         }
-        ((SimpleRealmProxyInterface) unmanagedObject).realmSet$name(((SimpleRealmProxyInterface) realmObject).realmGet$name());
-        ((SimpleRealmProxyInterface) unmanagedObject).realmSet$age(((SimpleRealmProxyInterface) realmObject).realmGet$age());
+        SimpleRealmProxyInterface unmanagedCopy = (SimpleRealmProxyInterface) unmanagedObject;
+        SimpleRealmProxyInterface realmSource = (SimpleRealmProxyInterface) realmObject;
+        unmanagedCopy.realmSet$name(realmSource.realmGet$name());
+        unmanagedCopy.realmSet$age(realmSource.realmGet$age());
+
         return unmanagedObject;
     }
 
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java b/realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java
index 80d74d91b9..4539db1355 100644
--- a/realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/AllTypes.java
@@ -18,6 +18,7 @@
 
 import java.util.Date;
 
+import io.realm.MutableRealmInteger;
 import io.realm.RealmList;
 import io.realm.RealmObject;
 import io.realm.RealmResults;
@@ -32,16 +33,36 @@
 
     @PrimaryKey
     private String columnString;
+
     private long columnLong;
     private float columnFloat;
     private double columnDouble;
     private boolean columnBoolean;
+
     @Required
     private Date columnDate;
+
     @Required
     private byte[] columnBinary;
+
+    private final MutableRealmInteger columnMutableRealmInteger = MutableRealmInteger.valueOf(0);
+
     private AllTypes columnObject;
+
     private RealmList<AllTypes> columnRealmList;
+
+    private RealmList<String> columnStringList;
+    private RealmList<byte[]> columnBinaryList;
+    private RealmList<Boolean> columnBooleanList;
+    private RealmList<Long> columnLongList;
+    private RealmList<Integer> columnIntegerList;
+    private RealmList<Short> columnShortList;
+    private RealmList<Byte> columnByteList;
+    private RealmList<Double> columnDoubleList;
+    private RealmList<Float> columnFloatList;
+    private RealmList<Date> columnDateList;
+
+
     @LinkingObjects(FIELD_PARENTS)
     private final RealmResults<AllTypes> parentObjects = null;
 
@@ -189,4 +210,11 @@ public void setColumnRealmList(RealmList<AllTypes> columnRealmList) {
         this.columnRealmList = columnRealmList;
     }
 
+    public MutableRealmInteger getColumnMutableRealmInteger() {
+        return realmGet$columnMutableRealmInteger();
+    }
+
+    public MutableRealmInteger realmGet$columnMutableRealmInteger() {
+        return columnMutableRealmInteger;
+    }
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_Ignored.java b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_Ignored.java
deleted file mode 100644
index acceae1ffb..0000000000
--- a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_Ignored.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package some.test;
-
-import io.realm.RealmObject;
-import io.realm.RealmResults;
-import io.realm.annotations.LinkingObjects;
-import io.realm.annotations.Ignore;
-
-public class Backlinks_Ignored extends RealmObject {
-    private int id;
-
-    // An  @Ignored, backlinked field is completely ignored
-    @Ignore
-    @LinkingObjects("foo")
-    private int parents = 0;
-}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_InvalidFieldType.java b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_InvalidFieldType.java
deleted file mode 100644
index 4c6afb1098..0000000000
--- a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_InvalidFieldType.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package some.test;
-
-import io.realm.RealmObject;
-import io.realm.RealmResults;
-import io.realm.annotations.LinkingObjects;
-
-public class Backlinks_InvalidFieldType extends RealmObject {
-    private int id;
-
-    // Backlinks must be RealmResults
-    @LinkingObjects("child")
-    private final BacklinkTarget parents = null;
-}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_LinkedFields.java b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_LinkedFields.java
deleted file mode 100644
index d2522269e4..0000000000
--- a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_LinkedFields.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package some.test;
-
-import io.realm.RealmObject;
-import io.realm.RealmResults;
-import io.realm.annotations.LinkingObjects;
-
-public class Backlinks_LinkedFields extends RealmObject {
-    private int id;
-
-    // Defining a backlink more than one levels back is not supported.
-    // It can be queried though: `equalTo("selectedFieldParents.selectedFieldParents")
-    @LinkingObjects("child.id")
-    private final RealmResults<BacklinkTarget> parents = null;
-}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_MissingGeneric.java b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_MissingGeneric.java
deleted file mode 100644
index ababc626a7..0000000000
--- a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_MissingGeneric.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package some.test;
-
-import io.realm.RealmObject;
-import io.realm.RealmResults;
-import io.realm.annotations.LinkingObjects;
-
-public class Backlinks_MissingGeneric extends RealmObject {
-    private int id;
-
-    // Forgot to specify the backlink generic param
-    @LinkingObjects("child")
-    private final RealmResults parents = null;
-}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_MissingParameter.java b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_MissingParameter.java
deleted file mode 100644
index dec9d6a6ec..0000000000
--- a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_MissingParameter.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package some.test;
-
-import io.realm.RealmObject;
-import io.realm.RealmResults;
-import io.realm.annotations.LinkingObjects;
-
-public class Backlinks_MissingParameter extends RealmObject {
-    private int id;
-
-    // Forgot to specify the backlinked field
-    @LinkingObjects
-    private final RealmResults<BacklinkTarget> parents = null;
-}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_Required.java b/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_Required.java
deleted file mode 100644
index 5f70fcbbfc..0000000000
--- a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_Required.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package some.test;
-
-import io.realm.RealmObject;
-import io.realm.RealmResults;
-import io.realm.annotations.LinkingObjects;
-import io.realm.annotations.Required;
-
-public class Backlinks_Required extends RealmObject {
-    private int id;
-
-    // A backlinked field may not be @Required
-    @Required
-    @LinkingObjects("child")
-    private final RealmResults<BacklinkTarget> parents = null;
-}
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/ConflictingFieldName.java b/realm/realm-annotations-processor/src/test/resources/some/test/ConflictingFieldName.java
index d0f94eeeea..6cb9137fe3 100644
--- a/realm/realm-annotations-processor/src/test/resources/some/test/ConflictingFieldName.java
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/ConflictingFieldName.java
@@ -29,11 +29,11 @@
     private String isCompleted;
     private String currentTableVersion;
 
-    public String getRealm() {
+    public String getRealmString() {
         return realm;
     }
 
-    public void setRealm(String realm) {
+    public void setRealmString(String realm) {
         this.realm = realm;
     }
 
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_NotFound.java b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidListElementType.java
similarity index 73%
rename from realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_NotFound.java
rename to realm/realm-annotations-processor/src/test/resources/some/test/InvalidListElementType.java
index 05692a71fb..217aee5523 100644
--- a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_NotFound.java
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidListElementType.java
@@ -16,14 +16,13 @@
 
 package some.test;
 
+import java.math.BigInteger;
+
+import io.realm.RealmList;
 import io.realm.RealmObject;
 import io.realm.RealmResults;
 import io.realm.annotations.LinkingObjects;
 
-public class Backlinks_NotFound extends RealmObject {
-    private int id;
-
-    // The argument to the @LinkingObjects annotation must name a field in the target class
-    @LinkingObjects("xxx")
-    private final RealmResults<BacklinkTarget> parents = null;
+public class InvalidListElementType extends RealmObject {
+    public RealmList<BigInteger> bigIntegerList;
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_NotFinal.java b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidResultsElementType.java
similarity index 77%
rename from realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_NotFinal.java
rename to realm/realm-annotations-processor/src/test/resources/some/test/InvalidResultsElementType.java
index 97c406b82d..dd832054d8 100644
--- a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_NotFinal.java
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/InvalidResultsElementType.java
@@ -16,14 +16,16 @@
 
 package some.test;
 
+import java.math.BigInteger;
+
+import io.realm.RealmList;
 import io.realm.RealmObject;
 import io.realm.RealmResults;
 import io.realm.annotations.LinkingObjects;
 
-public class Backlinks_NotFinal extends RealmObject {
-    private int id;
+public class InvalidResultsElementType extends RealmObject {
+    public InvalidResultsElementType child;
 
-    // The field named in the @LinkingObjects annotation must be final
     @LinkingObjects("child")
-    private RealmResults<BacklinkTarget> simpleParents = null;
+    public RealmResults<BigInteger> bigIntegerBacklinks;
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/NullTypes.java b/realm/realm-annotations-processor/src/test/resources/some/test/NullTypes.java
index 1904076340..45bc47aae6 100644
--- a/realm/realm-annotations-processor/src/test/resources/some/test/NullTypes.java
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/NullTypes.java
@@ -66,6 +66,45 @@
 
     private NullTypes fieldObjectNull;
 
+    @Required
+    private RealmList<String> fieldStringListNotNull;
+    private RealmList<String> fieldStringListNull;
+
+    @Required
+    private RealmList<byte[]> fieldBinaryListNotNull;
+    private RealmList<byte[]> fieldBinaryListNull;
+
+    @Required
+    private RealmList<Boolean> fieldBooleanListNotNull;
+    private RealmList<Boolean> fieldBooleanListNull;
+
+    @Required
+    private RealmList<Long> fieldLongListNotNull;
+    private RealmList<Long> fieldLongListNull;
+
+    @Required
+    private RealmList<Integer> fieldIntegerListNotNull;
+    private RealmList<Integer> fieldIntegerListNull;
+
+    @Required
+    private RealmList<Short> fieldShortListNotNull;
+    private RealmList<Short> fieldShortListNull;
+
+    @Required
+    private RealmList<Byte> fieldByteListNotNull;
+    private RealmList<Byte> fieldByteListNull;
+
+    @Required
+    private RealmList<Double> fieldDoubleListNotNull;
+    private RealmList<Double> fieldDoubleListNull;
+
+    @Required
+    private RealmList<Float> fieldFloatListNotNull;
+    private RealmList<Float> fieldFloatListNull;
+
+    @Required
+    private RealmList<Date> fieldDateListNotNull;
+    private RealmList<Date> fieldDateListNull;
 
     public String getFieldStringNotNull() {
         return realmGet$fieldStringNotNull();
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Transient.java b/realm/realm-annotations-processor/src/test/resources/some/test/Transient.java
index c130b20f7f..e54e4a26d4 100644
--- a/realm/realm-annotations-processor/src/test/resources/some/test/Transient.java
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/Transient.java
@@ -23,18 +23,10 @@
     private int age;
 
     public String getName() {
-        return realmGet$name();
-    }
-
-    public void setName(String name) {
-        realmSet$name(name);
-    }
-
-    public String realmGet$name() {
         return name;
     }
 
-    public void realmSet$name(String name) {
+    public void setName(String name) {
         this.name = name;
     }
 
@@ -53,32 +45,4 @@ public void setAge(int age) {
     public void realmSet$age(int age) {
         this.age = age;
     }
-
-    @Override
-    public String toString() {
-        return "Simple{" +
-                "name='" + name + '\'' +
-                ", age=" + age +
-                '}';
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-
-        Simple simple = (Simple) o;
-
-        if (age != simple.age) return false;
-        if (name != null ? !name.equals(simple.name) : simple.name != null) return false;
-
-        return true;
-    }
-
-    @Override
-    public int hashCode() {
-        int result = name != null ? name.hashCode() : 0;
-        result = 31 * result + age;
-        return result;
-    }
 }
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/ValueList.java b/realm/realm-annotations-processor/src/test/resources/some/test/ValueList.java
new file mode 100644
index 0000000000..33d615fc8e
--- /dev/null
+++ b/realm/realm-annotations-processor/src/test/resources/some/test/ValueList.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package some.test;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
+
+public class ValueList extends RealmObject {
+    public RealmList<String> stringList;
+    public RealmList<byte[]> binaryList;
+    public RealmList<Boolean> booleanList;
+    public RealmList<Long> longList;
+    public RealmList<Integer> integerList;
+    public RealmList<Short> shortList;
+    public RealmList<Byte> byteList;
+    public RealmList<Double> doubleList;
+    public RealmList<Float> floatList;
+    public RealmList<Date> integerList;
+}
diff --git a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/model/CounterOperation.java "b/realm/realm-annotations-processor/src/test/resources/some/test/\303\201rv\303\255zt\305\261r\305\221T\303\274k\303\266rf\303\272r\303\263g\303\251p.java"
similarity index 68%
rename from examples/objectServerExample/src/main/java/io/realm/examples/objectserver/model/CounterOperation.java
rename to "realm/realm-annotations-processor/src/test/resources/some/test/\303\201rv\303\255zt\305\261r\305\221T\303\274k\303\266rf\303\272r\303\263g\303\251p.java"
index 53342f648d..0cf6fe08d5 100644
--- a/examples/objectServerExample/src/main/java/io/realm/examples/objectserver/model/CounterOperation.java
+++ "b/realm/realm-annotations-processor/src/test/resources/some/test/\303\201rv\303\255zt\305\261r\305\221T\303\274k\303\266rf\303\272r\303\263g\303\251p.java"
@@ -1,5 +1,5 @@
 /*
- * Copyright 2016 Realm Inc.
+ * Copyright 2017 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,14 +14,17 @@
  * limitations under the License.
  */
 
-package io.realm.examples.objectserver.model;
+package some.test;
 
 import io.realm.RealmObject;
 
-public class CounterOperation extends RealmObject {
-    public long adjustment;
-    public CounterOperation() {};
-    public CounterOperation(long adjustment) {
-        this.adjustment = adjustment;
-    }
+
+/**
+ * A model class to test non latin class name.
+ */
+public class ÁrvíztűrőTükörfúrógép extends RealmObject {
+    public String name;
+    public long 델타;
+    public long Δέλτα;
+    public float 貸借対照表;
 }
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index 8d8616a30d..34c1c257c8 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -1,6 +1,8 @@
 import java.security.MessageDigest
 
 apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+apply plugin: 'kotlin-kapt'
 apply plugin: 'com.github.dcendents.android-maven'
 apply plugin: 'maven-publish'
 apply plugin: 'com.jfrog.artifactory'
@@ -34,10 +36,12 @@ ext.coreDir = file(project.coreSourcePath ?
         "${project.coreDistributionDir.getAbsolutePath()}/core-${project.coreVersion}")
 ext.ccachePath = project.findProperty('ccachePath') ?: System.getenv('NDK_CCACHE')
 ext.lcachePath = project.findProperty('lcachePath') ?: System.getenv('NDK_LCACHE')
+// Set to true to enable linking with debug core.
+ext.enableDebugCore = project.hasProperty('enableDebugCore') ? project.getProperty('enableDebugCore') : false //FIXME Use 'false' as default until https://github.com/realm/realm-java/issues/5354 is fixed
 
 android {
-    compileSdkVersion 25
-    buildToolsVersion '25.0.3'
+    compileSdkVersion 26
+    buildToolsVersion '26.0.2'
 
     defaultConfig {
         minSdkVersion 9
@@ -53,9 +57,11 @@ android {
                         // because of the android.toolchain.cmake shipped with Android SDK CMake 3.6 doesn't work with our
                         // JNI build currently (lack of lto linking support).
                         // This file should be removed and use the one from Android SDK cmake package when it supports lto.
-                        "-DCMAKE_TOOLCHAIN_FILE=${project.file('src/main/cpp/android.toolchain.cmake').path}"
+                        "-DCMAKE_TOOLCHAIN_FILE=${project.file('src/main/cpp/android.toolchain.cmake').path}",
+                        "-DENABLE_DEBUG_CORE=$project.enableDebugCore"
                 if (project.ccachePath) arguments "-DNDK_CCACHE=$project.ccachePath"
                 if (project.lcachePath) arguments "-DNDK_LCACHE=$project.lcachePath"
+                if (project.coreSourcePath) arguments "-DCORE_SOURCE_PATH=$project.coreSourcePath"
                 if (project.hasProperty('buildTargetABIs') && !project.getProperty('buildTargetABIs').trim().isEmpty()) {
                     abiFilters(*project.getProperty('buildTargetABIs').trim().split('\\s*,\\s*'))
                 } else {
@@ -64,6 +70,16 @@ android {
                 }
             }
         }
+
+        buildTypes {
+            debug {
+                javaCompileOptions {
+                    annotationProcessorOptions {
+                        arguments += [ 'realm.suppressWarnings' : 'false' ]
+                    }
+                }
+            }
+        }
     }
 
     externalNativeBuild {
@@ -80,24 +96,36 @@ android {
 
     sourceSets {
         androidTest {
-            java.srcDirs += 'src/benchmarks/java'
+            java.srcDirs += 'src/androidTest/kotlin'
         }
         androidTestObjectServer {
             java.srcDirs += 'src/syncIntegrationTest/java'
+            assets.srcDirs += ['src/syncIntegrationTest/assets/']
         }
     }
 
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_7
+        targetCompatibility JavaVersion.VERSION_1_7
+    }
+
     packagingOptions {
         exclude 'META-INF/NOTICE.txt'
         exclude 'META-INF/LICENSE.txt'
+        // We did strip with cmake for release build.
+        // Please, Gradle, you are not that smart! Pleas DO NOT strip debug symbols for debug build!
+        doNotStrip "*/*/*.so"
     }
 
     lintOptions {
         abortOnError false
     }
 
+    flavorDimensions 'api'
+
     productFlavors {
         base {
+            dimension 'api'
             externalNativeBuild {
                 cmake {
                     arguments "-DREALM_FLAVOR=base"
@@ -106,6 +134,7 @@ android {
             consumerProguardFiles 'proguard-rules-common.pro', 'proguard-rules-base.pro'
         }
         objectServer {
+            dimension 'api'
             externalNativeBuild {
                 cmake {
                     arguments "-DREALM_FLAVOR=objectServer"
@@ -129,6 +158,21 @@ project.afterEvaluate {
     tasks.withType(JavaCompile) {
         options.compilerArgs << '-Werror'
     }
+
+    tasks.all { task ->
+        android.productFlavors.all { flavor ->
+            if (task.name == "publish${flavor.name.capitalize()}PublicationPublicationToMavenLocal") {
+                task.dependsOn "assemble${flavor.name.capitalize()}"
+            }
+        }
+    }
+}
+
+// enable @ParametersAreNonnullByDefault annotation. See https://blog.jetbrains.com/kotlin/2017/08/kotlin-1-1-4-is-out/
+tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
+    kotlinOptions {
+        freeCompilerArgs = ["-Xjsr305=strict"]
+    }
 }
 
 coveralls.jacocoReportPath = "${buildDir}/reports/coverage/debug/report.xml"
@@ -139,30 +183,34 @@ android.registerTransform(new RealmTransformer())
 
 repositories {
     maven { url "https://jitpack.io" }
+    mavenCentral()
 }
 
 dependencies {
 
-    provided 'io.reactivex:rxjava:1.1.0'
-    provided 'com.google.code.findbugs:findbugs-annotations:3.0.1'
-
-    compile "io.realm:realm-annotations:${version}"
-    compile 'com.getkeepsafe.relinker:relinker:1.2.2'
-
-    objectServerAnnotationProcessor project(':realm-annotations-processor')
-    objectServerCompile 'com.squareup.okhttp3:okhttp:3.4.1'
-
-    androidTestAnnotationProcessor project(':realm-annotations-processor')
-    androidTestCompile fileTree(dir: 'testLibs', include: ['*.jar'])
-    androidTestCompile 'io.reactivex:rxjava:1.1.0'
-    androidTestCompile 'com.android.support:support-annotations:25.2.0'
-    androidTestCompile 'com.android.support.test:runner:0.5'
-    androidTestCompile 'com.android.support.test:rules:0.5'
-    androidTestCompile 'com.google.dexmaker:dexmaker:1.2'
-    androidTestCompile 'com.google.dexmaker:dexmaker-mockito:1.2'
-    androidTestCompile 'org.hamcrest:hamcrest-library:1.3'
-    androidTestCompile 'com.opencsv:opencsv:3.4'
-    androidTestCompile 'dk.ilios:spanner:0.6.0'
+    compileOnly 'io.reactivex.rxjava2:rxjava:2.1.4'
+    compileOnly 'com.google.code.findbugs:findbugs-annotations:3.0.1'
+
+    api "io.realm:realm-annotations:${version}"
+    implementation 'com.google.code.findbugs:jsr305:3.0.2'
+    implementation 'com.getkeepsafe.relinker:relinker:1.2.2'
+
+    kaptObjectServer project(':realm-annotations-processor')
+    objectServerImplementation 'com.squareup.okhttp3:okhttp:3.9.0'
+
+    kaptAndroidTest project(':realm-annotations-processor')
+    androidTestImplementation fileTree(dir: 'testLibs', include: ['*.jar'])
+    androidTestImplementation 'io.reactivex.rxjava2:rxjava:2.1.4'
+    androidTestImplementation 'com.android.support.test:runner:1.0.1'
+    androidTestImplementation 'com.android.support.test:rules:1.0.1'
+    androidTestImplementation 'com.google.dexmaker:dexmaker:1.2'
+    androidTestImplementation 'com.google.dexmaker:dexmaker-mockito:1.2'
+    androidTestImplementation 'org.hamcrest:hamcrest-library:1.3'
+    androidTestImplementation "org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version"
+    androidTestImplementation "org.jetbrains.kotlin:kotlin-reflect:$kotlin_version"
+
+    // specify error prone version to prevent sudden failure
+    errorprone 'com.google.errorprone:error_prone_core:2.0.21'
 }
 
 task sourcesJar(type: Jar) {
@@ -227,10 +275,10 @@ task findbugs(type: FindBugs) {
         xml.enabled = false
         html.enabled = true
         xml {
-            destination "$project.buildDir/findbugs/findbugs-output.xml"
+            destination file("$project.buildDir/findbugs/findbugs-output.xml")
         }
         html {
-            destination "$project.buildDir/findbugs/findbugs-output.html"
+            destination file("$project.buildDir/findbugs/findbugs-output.html")
         }
     }
 }
@@ -254,8 +302,7 @@ task checkstyle(type: Checkstyle) {
 
     source 'src'
     include '*/java/**/*.java'
-    exclude 'benchmarks/**'
-    // Ingore tests for now.
+    // Ignore tests for now.
     exclude '*Test*/**'
 
     // empty classpath
@@ -274,24 +321,6 @@ checkstyle {
 }
 check.dependsOn tasks.checkstyle
 
-// Configuration options can be found here:
-// http://developer.android.com/reference/android/support/test/runner/AndroidJUnitRunner.html
-task connectedBenchmarks(type: GradleBuild) {
-    description = 'Run all benchmarks on connected devices'
-    group = 'Verification'
-    buildFile = file("${projectDir}/build.gradle")
-    startParameter.getProjectProperties().put('android.testInstrumentationRunnerArguments.package', 'io.realm.benchmarks')
-    tasks = ['connectedCheck']
-}
-
-task connectedUnitTests(type: GradleBuild) {
-    description = 'Run all unit tests on connected devices'
-    group = 'Verification'
-    buildFile = file("${projectDir}/build.gradle")
-    startParameter.getProjectProperties().put('android.testInstrumentationRunnerArguments.notPackage', 'io.realm.benchmarks')
-    tasks = ['connectedAndroidTest']
-}
-
 install {
     repositories.mavenInstaller {
         pom {
@@ -363,7 +392,7 @@ publishing {
             artifact sourcesJar
             artifact javadocJar
 
-            pom.withXml(createPomDependencies(["baseCompile", "compile"]))
+            pom.withXml(createPomDependencies(["baseImplementation", "implementation", "baseApi", "api"]))
         }
 
         objectServerPublication(MavenPublication) {
@@ -374,7 +403,7 @@ publishing {
             artifact sourcesJar
             artifact javadocJar
 
-            pom.withXml(createPomDependencies(["objectServerCompile", "compile"]))
+            pom.withXml(createPomDependencies(["objectServerImplementation", "implementation", "objectServerApi", "api"]))
         }
     }
     repositories {
@@ -476,35 +505,9 @@ task downloadCore() {
     }
 }
 
-task compileCore(group: 'build setup', description: 'Compile the core library from source code') {
-    // Build the library from core source code
-    doFirst {
-        if (!coreSourcePath) {
-            throw new GradleException('The coreSourcePath is not set.')
-        }
-        exec {
-            workingDir = coreSourcePath
-            commandLine = [
-                    "bash",
-                    "build.sh",
-                    "build-android"
-            ]
-        }
-    }
-
-    // Copy the core tar ball
-    doLast {
-        copy {
-            from "${coreSourcePath}/realm-core-android-${coreVersion}.tar.gz"
-            into project.coreArchiveFile.parent
-            rename "realm-core-android-${coreVersion}.tar.gz", "realm-sync-android-${coreVersion}.tar.gz"
-        }
-    }
-}
-
 task deployCore(group: 'build setup', description: 'Deploy the latest version of Realm Core') {
     dependsOn {
-        coreSourcePath ? compileCore : downloadCore
+        downloadCore
     }
 
     // Build with the output from core source dir. No need to deploy anything.
@@ -563,6 +566,17 @@ project.afterEvaluate {
         if (project.hasProperty('buildTargetABIs') && project.getProperty('buildTargetABIs').trim().isEmpty()) {
             variant.externalNativeBuildTasks[0].enabled = false
         }
+
+        // all Java files must be compiled before native build
+        android.libraryVariants.all { anotherVariant ->
+            if (variant.flavorName == anotherVariant.flavorName) {
+                variant.externalNativeBuildTasks[0].dependsOn("compile${anotherVariant.name.capitalize()}JavaWithJavac")
+            }
+        }
+        // as of android gradle plugin 3.0.0-alpha5, generateJsonModel* triggers native build. Java files must be compiled before them.
+        android.buildTypes.all { buildType ->
+            tasks["generateJsonModel${variant.name.capitalize()}"].dependsOn "compile${variant.flavorName.capitalize()}${buildType.name.capitalize()}JavaWithJavac"
+        }
     }
 }
 
diff --git a/realm/realm-library/latest b/realm/realm-library/latest
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/realm/realm-library/src/androidTest/AndroidManifest.xml b/realm/realm-library/src/androidTest/AndroidManifest.xml
index d9e252dce4..f706bfdeae 100644
--- a/realm/realm-library/src/androidTest/AndroidManifest.xml
+++ b/realm/realm-library/src/androidTest/AndroidManifest.xml
@@ -7,13 +7,15 @@
     <uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
     <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
+    <uses-permission android:name="android.permission.SET_DEBUG_APP"/>
 
-    <uses-sdk tools:overrideLibrary="dk.ilios.spanner"/>
     <uses-sdk
         android:minSdkVersion="9"
         android:targetSdkVersion="22"/>
 
-    <application>
+    <application
+        android:debuggable="true"
+        android:largeHeap="true">
         <uses-library android:name="android.test.runner"/>
         <service
             android:name=".services.RemoteProcessService"
@@ -27,13 +29,13 @@
           Figure out why. For now place services here
           -->
         <service
-            android:name="io.realm.objectserver.service.SendOneCommit"
+            android:name="io.realm.objectserver.ProcessCommitTests$SimpleCommitRemoteService"
             android:enabled="true"
             android:exported="true"
             android:process=":remote">
         </service>
         <service
-            android:name="io.realm.objectserver.service.SendsALot"
+            android:name="io.realm.objectserver.ProcessCommitTests$ALotCommitsRemoteService"
             android:enabled="true"
             android:exported="true"
             android:process=":remote">
diff --git a/realm/realm-library/src/androidTest/assets/default-before-migration.realm b/realm/realm-library/src/androidTest/assets/default-before-migration.realm
deleted file mode 100644
index 7a9ae6075f..0000000000
Binary files a/realm/realm-library/src/androidTest/assets/default-before-migration.realm and /dev/null differ
diff --git a/realm/realm-library/src/androidTest/assets/empty.json b/realm/realm-library/src/androidTest/assets/empty.json
new file mode 100644
index 0000000000..ffcd4415b0
--- /dev/null
+++ b/realm/realm-library/src/androidTest/assets/empty.json
@@ -0,0 +1 @@
+{ }
diff --git a/realm/realm-library/src/androidTest/assets/encrypted.realm b/realm/realm-library/src/androidTest/assets/encrypted.realm
deleted file mode 100644
index d61e5677e0..0000000000
Binary files a/realm/realm-library/src/androidTest/assets/encrypted.realm and /dev/null differ
diff --git a/realm/realm-library/src/androidTest/assets/mutablerealminteger-int.json b/realm/realm-library/src/androidTest/assets/mutablerealminteger-int.json
new file mode 100644
index 0000000000..69fd08edf2
--- /dev/null
+++ b/realm/realm-library/src/androidTest/assets/mutablerealminteger-int.json
@@ -0,0 +1,3 @@
+{
+  "columnNullableMutableRealmInteger": 22
+}
diff --git a/realm/realm-library/src/androidTest/assets/mutablerealminteger-long.json b/realm/realm-library/src/androidTest/assets/mutablerealminteger-long.json
new file mode 100644
index 0000000000..d1343186bb
--- /dev/null
+++ b/realm/realm-library/src/androidTest/assets/mutablerealminteger-long.json
@@ -0,0 +1,3 @@
+{
+  "columnNullableMutableRealmInteger": 8589934592
+}
diff --git a/realm/realm-library/src/androidTest/assets/mutablerealminteger-null.json b/realm/realm-library/src/androidTest/assets/mutablerealminteger-null.json
new file mode 100644
index 0000000000..82ae58d9b5
--- /dev/null
+++ b/realm/realm-library/src/androidTest/assets/mutablerealminteger-null.json
@@ -0,0 +1,3 @@
+{
+  "columnNullableMutableRealmInteger": null
+}
diff --git a/realm/realm-library/src/androidTest/assets/mutablerealminteger-required-null.json b/realm/realm-library/src/androidTest/assets/mutablerealminteger-required-null.json
new file mode 100644
index 0000000000..f083d01921
--- /dev/null
+++ b/realm/realm-library/src/androidTest/assets/mutablerealminteger-required-null.json
@@ -0,0 +1,3 @@
+{
+  "columnNonNullableMutableRealmInteger": null
+}
diff --git a/realm/realm-library/src/androidTest/assets/backlinks-sourceFieldWrongType.realm b/realm/realm-library/src/androidTest/assets/readonly.realm
similarity index 68%
rename from realm/realm-library/src/androidTest/assets/backlinks-sourceFieldWrongType.realm
rename to realm/realm-library/src/androidTest/assets/readonly.realm
index 0cc76c03f2..d2d3637a8f 100644
Binary files a/realm/realm-library/src/androidTest/assets/backlinks-sourceFieldWrongType.realm and b/realm/realm-library/src/androidTest/assets/readonly.realm differ
diff --git a/realm/realm-library/src/androidTest/assets/backlinks-missingSourceClass.realm b/realm/realm-library/src/androidTest/assets/string-only-pre-null-0.82.2.realm
similarity index 81%
rename from realm/realm-library/src/androidTest/assets/backlinks-missingSourceClass.realm
rename to realm/realm-library/src/androidTest/assets/string-only-pre-null-0.82.2.realm
index 34a6e03968..9995d001ea 100644
Binary files a/realm/realm-library/src/androidTest/assets/backlinks-missingSourceClass.realm and b/realm/realm-library/src/androidTest/assets/string-only-pre-null-0.82.2.realm differ
diff --git a/realm/realm-library/src/androidTest/assets/backlinks-missingSourceField.realm b/realm/realm-library/src/androidTest/assets/string-only-required-pre-null-0.82.2.realm
similarity index 65%
rename from realm/realm-library/src/androidTest/assets/backlinks-missingSourceField.realm
rename to realm/realm-library/src/androidTest/assets/string-only-required-pre-null-0.82.2.realm
index 6fe07400b3..dbeb9e429c 100644
Binary files a/realm/realm-library/src/androidTest/assets/backlinks-missingSourceField.realm and b/realm/realm-library/src/androidTest/assets/string-only-required-pre-null-0.82.2.realm differ
diff --git a/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
index f79aacad6f..42ece9c78d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
@@ -505,7 +505,7 @@ public void execute(Realm realm) {
     public void insert_emptyListWithFilterableMediator() {
         //noinspection unchecked
         final RealmConfiguration config = configFactory.createConfigurationBuilder()
-                .schema(CatOwner.class, Cat.class)
+                .schema(CatOwner.class, Cat.class, Owner.class, DogPrimaryKey.class, Dog.class)
                 .name("filterable.realm")
                 .build();
         Realm.deleteRealm(config);
@@ -601,7 +601,7 @@ public void execute(Realm realm) {
     public void insertOrUpdate_emptyListWithFilterableMediator() {
         //noinspection unchecked
         final RealmConfiguration config = configFactory.createConfigurationBuilder()
-                .schema(CatOwner.class, Cat.class)
+                .schema(CatOwner.class, Cat.class, Owner.class, DogPrimaryKey.class, Dog.class)
                 .name("filterable.realm")
                 .build();
         Realm.deleteRealm(config);
@@ -912,6 +912,27 @@ public void insertOrUpdate_shouldNotClearRealmList() {
         assertEquals(1, allTypes.getColumnRealmList().size());
     }
 
+    @Test
+    public void insertOrUpdate_ownList() {
+        realm.beginTransaction();
+        AllJavaTypes managedObj = realm.createObject(AllJavaTypes.class, 1);
+        managedObj.getFieldList().add(managedObj);
+        AllJavaTypes unmanagedObj = realm.copyFromRealm(managedObj);
+        unmanagedObj.setFieldList(managedObj.getFieldList());
+
+        // Check single object insert
+        realm.insertOrUpdate(unmanagedObj);
+        managedObj = realm.where(AllJavaTypes.class).findFirst();
+        assertEquals(1, managedObj.getFieldList().size());
+        assertEquals(1, managedObj.getFieldList().first().getFieldId());
+
+        // Check collection insert
+        realm.insertOrUpdate(Arrays.asList(unmanagedObj));
+        managedObj = realm.where(AllJavaTypes.class).findFirst();
+        assertEquals(1, managedObj.getFieldList().size());
+        assertEquals(1, managedObj.getFieldList().first().getFieldId());
+    }
+
     @Test
     public void insert_collectionOfManagedObjects() {
         realm.beginTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
index 9a38ec50b1..c45a8cd2b9 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
@@ -84,7 +84,7 @@
     protected void populateRealm(Realm realm, int objects) {
         realm.beginTransaction();
         realm.delete(AllJavaTypes.class);
-        realm.delete(NonLatinFieldNames.class);
+         realm.delete(NonLatinFieldNames.class);
         if (objects > 0) {
             for (int i = 0; i < objects; i++) {
                 AllJavaTypes obj = realm.createObject(AllJavaTypes.class, i);
@@ -239,4 +239,8 @@ boolean isSnapshot(CollectionClass collectionClass) {
         return collectionClass == CollectionClass.REALMRESULTS_SNAPSHOT_LIST_BASE ||
                 collectionClass == CollectionClass.REALMRESULTS_SNAPSHOT_RESULTS_BASE;
     }
+
+    boolean isRealmList(ManagedCollection collectionClass) {
+        return collectionClass == ManagedCollection.MANAGED_REALMLIST;
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java b/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java
deleted file mode 100644
index d8cfe9972b..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/ColumnIndicesTests.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm;
-
-import android.support.annotation.NonNull;
-import android.support.test.runner.AndroidJUnit4;
-
-import com.google.common.collect.ImmutableMap;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.ExpectedException;
-import org.junit.runner.RunWith;
-
-import io.realm.entities.Cat;
-import io.realm.entities.Dog;
-import io.realm.internal.ColumnIndices;
-import io.realm.internal.ColumnInfo;
-import io.realm.internal.RealmProxyMediator;
-import io.realm.rule.TestRealmConfigurationFactory;
-
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertNotSame;
-import static junit.framework.Assert.assertSame;
-import static org.junit.Assert.assertNotEquals;
-
-@RunWith(AndroidJUnit4.class)
-public class ColumnIndicesTests {
-    @Rule
-    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
-    @Rule
-    public final ExpectedException thrown = ExpectedException.none();
-
-    private Realm realm;
-    private RealmProxyMediator mediator;
-
-    @Before
-    public void setUp() {
-        RealmConfiguration config = configFactory.createConfiguration();
-        realm = Realm.getInstance(config);
-        mediator = config.getSchemaMediator();
-    }
-
-    @After
-    public void tearDown() {
-        if (realm != null) {
-            realm.close();
-        }
-    }
-
-    @NonNull
-    private ColumnIndices create(long schemaVersion) {
-        final CatRealmProxy.CatColumnInfo catColumnInfo;
-        final DogRealmProxy.DogColumnInfo dogColumnInfo;
-        catColumnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
-        dogColumnInfo = (DogRealmProxy.DogColumnInfo) mediator.validateTable(Dog.class, realm.sharedRealm, false);
-
-        return new ColumnIndices(schemaVersion,
-                ImmutableMap.<Class<? extends RealmModel>, ColumnInfo>of(
-                        Cat.class, catColumnInfo,
-                        Dog.class, dogColumnInfo));
-    }
-
-    @Test
-    public void copyDeeply() {
-        final long schemaVersion = 100;
-
-        final ColumnIndices columnIndices = create(schemaVersion);
-        final ColumnIndices deepCopy = columnIndices.clone();
-
-        assertEquals(schemaVersion, deepCopy.getSchemaVersion());
-        assertEquals(columnIndices.getColumnIndex(Cat.class, Cat.FIELD_NAME),
-                deepCopy.getColumnIndex(Cat.class, Cat.FIELD_NAME));
-        assertEquals(columnIndices.getColumnIndex(Dog.class, Dog.FIELD_AGE),
-                deepCopy.getColumnIndex(Dog.class, Dog.FIELD_AGE));
-
-        // Checks if those are different instance.
-        assertNotSame(columnIndices, deepCopy);
-        assertNotSame(columnIndices.getColumnInfo(Cat.class), deepCopy.getColumnInfo(Cat.class));
-        assertNotSame(columnIndices.getColumnInfo(Dog.class), deepCopy.getColumnInfo(Dog.class));
-    }
-
-    @Test
-    public void copyFrom() {
-        final long sourceSchemaVersion = 101;
-        final long targetSchemaVersion = 100;
-
-        final ColumnIndices source = create(sourceSchemaVersion);
-        final ColumnIndices target = create(targetSchemaVersion);
-
-        final CatRealmProxy.CatColumnInfo catColumnInfoInSource = (CatRealmProxy.CatColumnInfo) source.getColumnInfo(Cat.class);
-        final CatRealmProxy.CatColumnInfo catColumnInfoInTarget = (CatRealmProxy.CatColumnInfo) target.getColumnInfo(Cat.class);
-
-        catColumnInfoInSource.nameIndex++;
-
-        // Checks preconditions.
-        assertNotEquals(catColumnInfoInSource.nameIndex, catColumnInfoInTarget.nameIndex);
-        assertNotSame(catColumnInfoInSource.getIndicesMap(), catColumnInfoInTarget.getIndicesMap());
-
-        target.copyFrom(source,  mediator);
-
-        assertEquals(sourceSchemaVersion, target.getSchemaVersion());
-        assertEquals(catColumnInfoInSource.nameIndex, catColumnInfoInTarget.nameIndex);
-        assertSame(catColumnInfoInSource.getIndicesMap(), catColumnInfoInTarget.getIndicesMap());
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java b/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java
index 618c54d588..01b6920726 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ColumnInfoTests.java
@@ -30,7 +30,8 @@
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertNotSame;
-import static junit.framework.Assert.assertSame;
+import static junit.framework.Assert.fail;
+
 
 @RunWith(AndroidJUnit4.class)
 public class ColumnInfoTests {
@@ -40,11 +41,13 @@
     public final ExpectedException thrown = ExpectedException.none();
 
     private Realm realm;
+    private RealmProxyMediator mediator;
 
     @Before
     public void setUp() {
         RealmConfiguration config = configFactory.createConfiguration();
         realm = Realm.getInstance(config);
+        mediator = realm.getConfiguration().getSchemaMediator();
     }
 
     @After
@@ -56,10 +59,10 @@ public void tearDown() {
 
     @Test
     public void copyColumnInfoFrom_checkIndex() {
-        final RealmProxyMediator mediator = realm.getConfiguration().getSchemaMediator();
-        final CatRealmProxy.CatColumnInfo sourceColumnInfo, targetColumnInfo;
-        sourceColumnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
-        targetColumnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+        CatRealmProxy.CatColumnInfo sourceColumnInfo
+                = (CatRealmProxy.CatColumnInfo) mediator.createColumnInfo(Cat.class, realm.sharedRealm.getSchemaInfo());
+        CatRealmProxy.CatColumnInfo targetColumnInfo
+                = (CatRealmProxy.CatColumnInfo) mediator.createColumnInfo(Cat.class, realm.sharedRealm.getSchemaInfo());
 
         // Checks precondition.
         assertNotSame(sourceColumnInfo, targetColumnInfo);
@@ -83,26 +86,22 @@ public void copyColumnInfoFrom_checkIndex() {
         targetColumnInfo.ownerIndex = 0;
         targetColumnInfo.scaredOfDogIndex = 0;
 
-        targetColumnInfo.copyColumnInfoFrom(sourceColumnInfo);
-
-        assertEquals(1, targetColumnInfo.nameIndex);
-        assertEquals(2, targetColumnInfo.ageIndex);
-        assertEquals(3, targetColumnInfo.heightIndex);
-        assertEquals(4, targetColumnInfo.weightIndex);
-        assertEquals(5, targetColumnInfo.hasTailIndex);
-        assertEquals(6, targetColumnInfo.birthdayIndex);
-        assertEquals(7, targetColumnInfo.ownerIndex);
-        assertEquals(8, targetColumnInfo.scaredOfDogIndex);
+        targetColumnInfo.copyFrom(sourceColumnInfo);
 
-        // Current implementation shares the indices map.
-        assertSame(sourceColumnInfo.getIndicesMap(), targetColumnInfo.getIndicesMap());
+        assertEquals(sourceColumnInfo.nameIndex, targetColumnInfo.nameIndex);
+        assertEquals(sourceColumnInfo.ageIndex, targetColumnInfo.ageIndex);
+        assertEquals(sourceColumnInfo.heightIndex, targetColumnInfo.heightIndex);
+        assertEquals(sourceColumnInfo.weightIndex, targetColumnInfo.weightIndex);
+        assertEquals(sourceColumnInfo.hasTailIndex, targetColumnInfo.hasTailIndex);
+        assertEquals(sourceColumnInfo.birthdayIndex, targetColumnInfo.birthdayIndex);
+        assertEquals(sourceColumnInfo.ownerIndex, targetColumnInfo.ownerIndex);
+        assertEquals(sourceColumnInfo.scaredOfDogIndex, targetColumnInfo.scaredOfDogIndex);
     }
 
     @Test
-    public void clone_hasSameValue() {
-        final RealmProxyMediator mediator = realm.getConfiguration().getSchemaMediator();
-        final CatRealmProxy.CatColumnInfo columnInfo;
-        columnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+    public void copy_differentInstanceSameValues() {
+        final CatRealmProxy.CatColumnInfo columnInfo
+                = (CatRealmProxy.CatColumnInfo) mediator.createColumnInfo(Cat.class, realm.sharedRealm.getSchemaInfo());
 
         columnInfo.nameIndex = 1;
         columnInfo.ageIndex = 2;
@@ -113,9 +112,21 @@ public void clone_hasSameValue() {
         columnInfo.ownerIndex = 7;
         columnInfo.scaredOfDogIndex = 8;
 
-        CatRealmProxy.CatColumnInfo copy = columnInfo.clone();
+        CatRealmProxy.CatColumnInfo copy = (CatRealmProxy.CatColumnInfo) columnInfo.copy(true);
 
-        // Modifies original object.
+        // verify that the copy is identical
+        assertNotSame(columnInfo, copy);
+        assertEquals(columnInfo.getIndicesMap(), copy.getIndicesMap());
+        assertEquals(columnInfo.nameIndex, copy.nameIndex);
+        assertEquals(columnInfo.ageIndex, copy.ageIndex);
+        assertEquals(columnInfo.heightIndex, copy.heightIndex);
+        assertEquals(columnInfo.weightIndex, copy.weightIndex);
+        assertEquals(columnInfo.hasTailIndex, copy.hasTailIndex);
+        assertEquals(columnInfo.birthdayIndex, copy.birthdayIndex);
+        assertEquals(columnInfo.ownerIndex, copy.ownerIndex);
+        assertEquals(columnInfo.scaredOfDogIndex, copy.scaredOfDogIndex);
+
+        // Modify original object
         columnInfo.nameIndex = 0;
         columnInfo.ageIndex = 0;
         columnInfo.heightIndex = 0;
@@ -125,8 +136,7 @@ public void clone_hasSameValue() {
         columnInfo.ownerIndex = 0;
         columnInfo.scaredOfDogIndex = 0;
 
-        assertNotSame(columnInfo, copy);
-
+        // the copy should not change
         assertEquals(1, copy.nameIndex);
         assertEquals(2, copy.ageIndex);
         assertEquals(3, copy.heightIndex);
@@ -135,8 +145,18 @@ public void clone_hasSameValue() {
         assertEquals(6, copy.birthdayIndex);
         assertEquals(7, copy.ownerIndex);
         assertEquals(8, copy.scaredOfDogIndex);
+    }
 
-        // Current implementation shares the indices map between copies.
-        assertSame(columnInfo.getIndicesMap(), copy.getIndicesMap());
+    @Test
+    public void copy_immutableThrows() {
+        final CatRealmProxy.CatColumnInfo original
+                = (CatRealmProxy.CatColumnInfo) mediator.createColumnInfo(Cat.class, realm.sharedRealm.getSchemaInfo());
+
+        CatRealmProxy.CatColumnInfo copy = (CatRealmProxy.CatColumnInfo) original.copy(false);
+        try {
+            copy.copyFrom(original);
+            fail("Attempt to copy to an immutable ColumnInfo should throwS");
+        } catch (UnsupportedOperationException ignore) {
+        }
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
index cdd594baf3..3ac4e327db 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
@@ -18,6 +18,7 @@
 
 import android.support.test.runner.AndroidJUnit4;
 
+import org.hamcrest.Matchers;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -56,6 +57,8 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -92,6 +95,13 @@ public void setUp() {
         typedObj.setFieldDate(new Date(1000));
         typedObj.setFieldObject(typedObj);
         typedObj.getFieldList().add(typedObj);
+        typedObj.getFieldIntegerList().add(1);
+        typedObj.getFieldStringList().add("str");
+        typedObj.getFieldBooleanList().add(true);
+        typedObj.getFieldFloatList().add(1.23F);
+        typedObj.getFieldDoubleList().add(1.234D);
+        typedObj.getFieldBinaryList().add(new byte[] {1, 2, 3});
+        typedObj.getFieldDateList().add(new Date(1000));
         dObjTyped = new DynamicRealmObject(typedObj);
         realm.commitTransaction();
 
@@ -111,15 +121,16 @@ public void tearDown() {
 
     // Types supported by the DynamicRealmObject.
     private enum SupportedType {
-        BOOLEAN, SHORT, INT, LONG, BYTE, FLOAT, DOUBLE, STRING, BINARY, DATE, OBJECT, LIST
+        BOOLEAN, SHORT, INT, LONG, BYTE, FLOAT, DOUBLE, STRING, BINARY, DATE, OBJECT, LIST,
+        LIST_INTEGER, LIST_STRING, LIST_BOOLEAN, LIST_FLOAT, LIST_DOUBLE, LIST_BINARY, LIST_DATE
     }
 
     private enum ThreadConfinedMethods {
         GET_BOOLEAN, GET_BYTE, GET_SHORT, GET_INT, GET_LONG, GET_FLOAT, GET_DOUBLE,
-        GET_BLOB, GET_STRING, GET_DATE, GET_OBJECT, GET_LIST, GET,
+        GET_BLOB, GET_STRING, GET_DATE, GET_OBJECT, GET_LIST, GET_PRIMITIVE_LIST, GET,
 
         SET_BOOLEAN, SET_BYTE, SET_SHORT, SET_INT, SET_LONG, SET_FLOAT, SET_DOUBLE,
-        SET_BLOB, SET_STRING, SET_DATE, SET_OBJECT, SET_LIST, SET,
+        SET_BLOB, SET_STRING, SET_DATE, SET_OBJECT, SET_LIST, SET_PRIMITIVE_LIST, SET,
 
         IS_NULL, SET_NULL,
 
@@ -131,33 +142,35 @@ public void tearDown() {
     @SuppressWarnings({"ResultOfMethodCallIgnored", "EqualsWithItself", "SelfEquals"})
     private static void callThreadConfinedMethod(DynamicRealmObject obj, ThreadConfinedMethods method) {
         switch (method) {
-            case GET_BOOLEAN: obj.getBoolean(AllJavaTypes.FIELD_BOOLEAN); break;
-            case GET_BYTE:    obj.getByte(AllJavaTypes.FIELD_BYTE);       break;
-            case GET_SHORT:   obj.getShort(AllJavaTypes.FIELD_SHORT);     break;
-            case GET_INT:     obj.getInt(AllJavaTypes.FIELD_INT);         break;
-            case GET_LONG:    obj.getLong(AllJavaTypes.FIELD_LONG);       break;
-            case GET_FLOAT:   obj.getFloat(AllJavaTypes.FIELD_FLOAT);     break;
-            case GET_DOUBLE:  obj.getDouble(AllJavaTypes.FIELD_DOUBLE);   break;
-            case GET_BLOB:    obj.getBlob(AllJavaTypes.FIELD_BINARY);     break;
-            case GET_STRING:  obj.getString(AllJavaTypes.FIELD_STRING);   break;
-            case GET_DATE:    obj.getDate(AllJavaTypes.FIELD_DATE);       break;
-            case GET_OBJECT:  obj.getObject(AllJavaTypes.FIELD_OBJECT);   break;
-            case GET_LIST:    obj.getList(AllJavaTypes.FIELD_LIST);       break;
-            case GET:         obj.get(AllJavaTypes.FIELD_LONG);           break;
-
-            case SET_BOOLEAN: obj.setBoolean(AllJavaTypes.FIELD_BOOLEAN, true);                 break;
-            case SET_BYTE:    obj.setByte(AllJavaTypes.FIELD_BYTE,       (byte) 1);             break;
-            case SET_SHORT:   obj.setShort(AllJavaTypes.FIELD_SHORT,     (short) 1);            break;
-            case SET_INT:     obj.setInt(AllJavaTypes.FIELD_INT,         1);                    break;
-            case SET_LONG:    obj.setLong(AllJavaTypes.FIELD_LONG,       1L);                   break;
-            case SET_FLOAT:   obj.setFloat(AllJavaTypes.FIELD_FLOAT,     1F);                   break;
-            case SET_DOUBLE:  obj.setDouble(AllJavaTypes.FIELD_DOUBLE,   1D);                   break;
-            case SET_BLOB:    obj.setBlob(AllJavaTypes.FIELD_BINARY,     new byte[] {1, 2, 3}); break;
-            case SET_STRING:  obj.setString(AllJavaTypes.FIELD_STRING,   "12345");              break;
-            case SET_DATE:    obj.setDate(AllJavaTypes.FIELD_DATE,       new Date(1L));         break;
-            case SET_OBJECT:  obj.setObject(AllJavaTypes.FIELD_OBJECT,   obj);                  break;
-            case SET_LIST:    obj.setList(AllJavaTypes.FIELD_LIST,       new RealmList<>(obj)); break;
-            case SET:         obj.set(AllJavaTypes.FIELD_LONG,           1L);                   break;
+            case GET_BOOLEAN:           obj.getBoolean(AllJavaTypes.FIELD_BOOLEAN);                 break;
+            case GET_BYTE:              obj.getByte(AllJavaTypes.FIELD_BYTE);                       break;
+            case GET_SHORT:             obj.getShort(AllJavaTypes.FIELD_SHORT);                     break;
+            case GET_INT:               obj.getInt(AllJavaTypes.FIELD_INT);                         break;
+            case GET_LONG:              obj.getLong(AllJavaTypes.FIELD_LONG);                       break;
+            case GET_FLOAT:             obj.getFloat(AllJavaTypes.FIELD_FLOAT);                     break;
+            case GET_DOUBLE:            obj.getDouble(AllJavaTypes.FIELD_DOUBLE);                   break;
+            case GET_BLOB:              obj.getBlob(AllJavaTypes.FIELD_BINARY);                     break;
+            case GET_STRING:            obj.getString(AllJavaTypes.FIELD_STRING);                   break;
+            case GET_DATE:              obj.getDate(AllJavaTypes.FIELD_DATE);                       break;
+            case GET_OBJECT:            obj.getObject(AllJavaTypes.FIELD_OBJECT);                   break;
+            case GET_LIST:              obj.getList(AllJavaTypes.FIELD_LIST);                       break;
+            case GET_PRIMITIVE_LIST:    obj.getList(AllJavaTypes.FIELD_STRING_LIST, String.class);  break;
+            case GET:                   obj.get(AllJavaTypes.FIELD_LONG);                           break;
+
+            case SET_BOOLEAN:           obj.setBoolean(AllJavaTypes.FIELD_BOOLEAN, true);                           break;
+            case SET_BYTE:              obj.setByte(AllJavaTypes.FIELD_BYTE,       (byte) 1);                       break;
+            case SET_SHORT:             obj.setShort(AllJavaTypes.FIELD_SHORT,     (short) 1);                      break;
+            case SET_INT:               obj.setInt(AllJavaTypes.FIELD_INT,         1);                              break;
+            case SET_LONG:              obj.setLong(AllJavaTypes.FIELD_LONG,       1L);                             break;
+            case SET_FLOAT:             obj.setFloat(AllJavaTypes.FIELD_FLOAT,     1F);                             break;
+            case SET_DOUBLE:            obj.setDouble(AllJavaTypes.FIELD_DOUBLE,   1D);                             break;
+            case SET_BLOB:              obj.setBlob(AllJavaTypes.FIELD_BINARY,     new byte[] {1, 2, 3});           break;
+            case SET_STRING:            obj.setString(AllJavaTypes.FIELD_STRING,   "12345");                        break;
+            case SET_DATE:              obj.setDate(AllJavaTypes.FIELD_DATE,       new Date(1L));                   break;
+            case SET_OBJECT:            obj.setObject(AllJavaTypes.FIELD_OBJECT,   obj);                            break;
+            case SET_LIST:              obj.setList(AllJavaTypes.FIELD_LIST,       new RealmList<>(obj));           break;
+            case SET_PRIMITIVE_LIST:    obj.setList(AllJavaTypes.FIELD_STRING_LIST,new RealmList<String>("foo"));   break;
+            case SET:                   obj.set(AllJavaTypes.FIELD_LONG,           1L);                             break;
 
             case IS_NULL:     obj.isNull(AllJavaTypes.FIELD_OBJECT);           break;
             case SET_NULL:    obj.setNull(AllJavaTypes.FIELD_OBJECT);          break;
@@ -323,7 +336,16 @@ private static void callGetter(DynamicRealmObject target, SupportedType type, Li
                 case BINARY: target.getBlob(fieldName); break;
                 case DATE: target.getDate(fieldName); break;
                 case OBJECT: target.getObject(fieldName); break;
-                case LIST: target.getList(fieldName); break;
+                case LIST:
+                case LIST_INTEGER:
+                case LIST_STRING:
+                case LIST_BOOLEAN:
+                case LIST_FLOAT:
+                case LIST_DOUBLE:
+                case LIST_BINARY:
+                case LIST_DATE:
+                    target.getList(fieldName);
+                    break;
                 default:
                     fail();
             }
@@ -447,6 +469,13 @@ private static void callSetter(DynamicRealmObject target, SupportedType type, Li
                 case DATE: target.getDate(fieldName); break;
                 case OBJECT: target.setObject(fieldName, null); target.setObject(fieldName, target); break;
                 case LIST: target.setList(fieldName, new RealmList<DynamicRealmObject>()); break;
+                case LIST_INTEGER: target.setList(fieldName, new RealmList<Integer>(1)); break;
+                case LIST_STRING: target.setList(fieldName, new RealmList<String>("foo")); break;
+                case LIST_BOOLEAN: target.setList(fieldName, new RealmList<Boolean>(true)); break;
+                case LIST_FLOAT: target.setList(fieldName, new RealmList<Float>(1.23F)); break;
+                case LIST_DOUBLE: target.setList(fieldName, new RealmList<Double>(1.234D)); break;
+                case LIST_BINARY: target.setList(fieldName, new RealmList<byte[]>(new byte[]{})); break;
+                case LIST_DATE: target.setList(fieldName, new RealmList<Date>(new Date())); break;
                 default:
                     fail();
             }
@@ -506,6 +535,27 @@ public void typedGettersAndSetters() {
                         dObj.setObject(AllJavaTypes.FIELD_OBJECT, dObj);
                         assertEquals(dObj, dObj.getObject(AllJavaTypes.FIELD_OBJECT));
                         break;
+                    case LIST_INTEGER:
+                        checkSetGetValueList(dObj, AllJavaTypes.FIELD_INTEGER_LIST, Integer.class, new RealmList<>(null, 1));
+                        break;
+                    case LIST_STRING:
+                        checkSetGetValueList(dObj, AllJavaTypes.FIELD_STRING_LIST, String.class, new RealmList<>(null, "foo"));
+                        break;
+                    case LIST_BOOLEAN:
+                        checkSetGetValueList(dObj, AllJavaTypes.FIELD_BOOLEAN_LIST, Boolean.class, new RealmList<>(null, true));
+                        break;
+                    case LIST_FLOAT:
+                        checkSetGetValueList(dObj, AllJavaTypes.FIELD_FLOAT_LIST, Float.class, new RealmList<>(null, 1.23F));
+                        break;
+                    case LIST_DOUBLE:
+                        checkSetGetValueList(dObj, AllJavaTypes.FIELD_DOUBLE_LIST, Double.class, new RealmList<>(null, 1.234D));
+                        break;
+                    case LIST_BINARY:
+                        checkSetGetValueList(dObj, AllJavaTypes.FIELD_BINARY_LIST, byte[].class, new RealmList<>(null, new byte[] {1, 2, 3}));
+                        break;
+                    case LIST_DATE:
+                        checkSetGetValueList(dObj, AllJavaTypes.FIELD_DATE_LIST, Date.class, new RealmList<>(null, new Date(1000)));
+                        break;
                     case LIST:
                         // Ignores. See testGetList/testSetList.
                         break;
@@ -518,6 +568,11 @@ public void typedGettersAndSetters() {
         }
     }
 
+    private <E> void checkSetGetValueList(DynamicRealmObject obj, String fieldName, Class<E> primitiveType, RealmList<E> list) {
+        obj.set(fieldName, list);
+        assertArrayEquals(list.toArray(), obj.getList(fieldName, primitiveType).toArray());
+    }
+
     @Test
     public void setter_null() {
         realm.beginTransaction();
@@ -542,6 +597,55 @@ public void setter_null() {
                         } catch (IllegalArgumentException ignored) {
                         }
                         break;
+                    case LIST_INTEGER:
+                        try {
+                            dObj.setNull(NullTypes.FIELD_INTEGER_LIST_NULL);
+                            fail();
+                        } catch (IllegalArgumentException ignored) {
+                        }
+                        break;
+                    case LIST_STRING:
+                        try {
+                            dObj.setNull(NullTypes.FIELD_STRING_LIST_NULL);
+                            fail();
+                        } catch (IllegalArgumentException ignored) {
+                        }
+                        break;
+                    case LIST_BOOLEAN:
+                        try {
+                            dObj.setNull(NullTypes.FIELD_BOOLEAN_LIST_NULL);
+                            fail();
+                        } catch (IllegalArgumentException ignored) {
+                        }
+                        break;
+                    case LIST_FLOAT:
+                        try {
+                            dObj.setNull(NullTypes.FIELD_FLOAT_LIST_NULL);
+                            fail();
+                        } catch (IllegalArgumentException ignored) {
+                        }
+                        break;
+                    case LIST_DOUBLE:
+                        try {
+                            dObj.setNull(NullTypes.FIELD_DOUBLE_LIST_NULL);
+                            fail();
+                        } catch (IllegalArgumentException ignored) {
+                        }
+                        break;
+                    case LIST_BINARY:
+                        try {
+                            dObj.setNull(NullTypes.FIELD_BINARY_LIST_NULL);
+                            fail();
+                        } catch (IllegalArgumentException ignored) {
+                        }
+                        break;
+                    case LIST_DATE:
+                        try {
+                            dObj.setNull(NullTypes.FIELD_DATE_LIST_NULL);
+                            fail();
+                        } catch (IllegalArgumentException ignored) {
+                        }
+                        break;
                     case BOOLEAN:
                         dObj.setNull(NullTypes.FIELD_BOOLEAN_NULL);
                         assertTrue(dObj.isNull(NullTypes.FIELD_BOOLEAN_NULL));
@@ -603,6 +707,13 @@ public void setter_nullOnRequiredFieldsThrows() {
                     switch (type) {
                         case OBJECT: continue; // Ignore
                         case LIST: fieldName = NullTypes.FIELD_LIST_NULL; break;
+                        case LIST_INTEGER: fieldName = NullTypes.FIELD_INTEGER_LIST_NULL; break;
+                        case LIST_STRING: fieldName = NullTypes.FIELD_STRING_LIST_NULL; break;
+                        case LIST_BOOLEAN: fieldName = NullTypes.FIELD_BOOLEAN_LIST_NULL; break;
+                        case LIST_FLOAT: fieldName = NullTypes.FIELD_FLOAT_LIST_NULL; break;
+                        case LIST_DOUBLE: fieldName = NullTypes.FIELD_DATE_LIST_NULL; break;
+                        case LIST_BINARY: fieldName = NullTypes.FIELD_BINARY_LIST_NULL; break;
+                        case LIST_DATE: fieldName = NullTypes.FIELD_DATE_LIST_NULL; break;
                         case BOOLEAN: fieldName = NullTypes.FIELD_BOOLEAN_NOT_NULL; break;
                         case BYTE: fieldName = NullTypes.FIELD_BYTE_NOT_NULL; break;
                         case SHORT: fieldName = NullTypes.FIELD_SHORT_NOT_NULL; break;
@@ -648,6 +759,55 @@ public void typedSetter_null() {
                         } catch (IllegalArgumentException ignored) {
                         }
                         break;
+                    case LIST_INTEGER:
+                        try {
+                            dObj.setList(NullTypes.FIELD_INTEGER_LIST_NULL, null);
+                            fail();
+                        } catch (IllegalArgumentException ignored) {
+                        }
+                        break;
+                    case LIST_STRING:
+                        try {
+                            dObj.setList(NullTypes.FIELD_STRING_LIST_NULL, null);
+                            fail();
+                        } catch (IllegalArgumentException ignored) {
+                        }
+                        break;
+                    case LIST_BOOLEAN:
+                        try {
+                            dObj.setList(NullTypes.FIELD_BOOLEAN_LIST_NULL, null);
+                            fail();
+                        } catch (IllegalArgumentException ignored) {
+                        }
+                        break;
+                    case LIST_FLOAT:
+                        try {
+                            dObj.setList(NullTypes.FIELD_FLOAT_LIST_NULL, null);
+                            fail();
+                        } catch (IllegalArgumentException ignored) {
+                        }
+                        break;
+                    case LIST_DOUBLE:
+                        try {
+                            dObj.setList(NullTypes.FIELD_DOUBLE_LIST_NULL, null);
+                            fail();
+                        } catch (IllegalArgumentException ignored) {
+                        }
+                        break;
+                    case LIST_BINARY:
+                        try {
+                            dObj.setList(NullTypes.FIELD_BINARY_LIST_NULL, null);
+                            fail();
+                        } catch (IllegalArgumentException ignored) {
+                        }
+                        break;
+                    case LIST_DATE:
+                        try {
+                            dObj.setList(NullTypes.FIELD_DATE_LIST_NULL, null);
+                            fail();
+                        } catch (IllegalArgumentException ignored) {
+                        }
+                        break;
                     case DATE:
                         dObj.setDate(NullTypes.FIELD_DATE_NULL, null);
                         assertNull(dObj.getDate(NullTypes.FIELD_DATE_NULL));
@@ -750,7 +910,7 @@ public void run() {
                             .setObject(AllJavaTypes.FIELD_OBJECT, dObjDynamic);
                     fail();
                 } catch (IllegalArgumentException expected) {
-                    assertEquals(expected.getMessage(), "Cannot add an object from another Realm instance.");
+                    assertEquals("Cannot add an object from another Realm instance.", expected.getMessage());
                 }
 
                 dynamicRealm.cancelTransaction();
@@ -861,8 +1021,7 @@ public void run() {
                     dynamicRealm.where(AllJavaTypes.CLASS_NAME).findFirst().setList(AllJavaTypes.FIELD_LIST, list);
                     fail();
                 } catch (IllegalArgumentException expected) {
-                    assertEquals(expected.getMessage(),
-                            "Each element in 'list' must belong to the same Realm instance.");
+                    assertEquals("Each element in 'list' must belong to the same Realm instance.", expected.getMessage());
                 }
 
                 dynamicRealm.cancelTransaction();
@@ -883,6 +1042,32 @@ public void setList_wrongTypeThrows() {
         dObjTyped.setList(AllJavaTypes.FIELD_LIST, wrongDynamicList);
     }
 
+    @Test
+    public void setList_javaModelClassesThrowProperErrorMessage() {
+        dynamicRealm.beginTransaction();
+        try {
+            dObjDynamic.setList(AllJavaTypes.FIELD_LIST, new RealmList<>(typedObj));
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertTrue(e.getMessage().contains("RealmList must contain `DynamicRealmObject's, not Java model classes."));
+        }
+    }
+
+    @Test
+    public void setList_objectsOwnList() {
+        dynamicRealm.beginTransaction();
+
+        // Test model classes
+        int originalSize = dObjDynamic.getList(AllJavaTypes.FIELD_LIST).size();
+        dObjDynamic.setList(AllJavaTypes.FIELD_LIST, dObjDynamic.getList(AllJavaTypes.FIELD_LIST));
+        assertEquals(originalSize, dObjDynamic.getList(AllJavaTypes.FIELD_LIST).size());
+
+        // Smoke test value lists
+        originalSize = dObjDynamic.getList(AllJavaTypes.FIELD_STRING_LIST, String.class).size();
+        dObjDynamic.setList(AllJavaTypes.FIELD_STRING_LIST, dObjDynamic.getList(AllJavaTypes.FIELD_STRING_LIST, String.class));
+        assertEquals(originalSize, dObjDynamic.getList(AllJavaTypes.FIELD_STRING_LIST, String.class).size());
+    }
+
     @Test
     public void untypedSetter_listWrongTypeThrows() {
         realm.beginTransaction();
@@ -923,6 +1108,7 @@ public void getList() {
         assertEquals("fido", listObject.getString(Dog.FIELD_NAME));
     }
 
+
     @Test
     public void untypedGetterSetter() {
         realm.beginTransaction();
@@ -937,27 +1123,27 @@ public void untypedGetterSetter() {
                         break;
                     case SHORT:
                         dObj.set(AllJavaTypes.FIELD_SHORT, (short) 42);
-                        assertEquals(Long.parseLong("42"), dObj.get(AllJavaTypes.FIELD_SHORT));
+                        assertEquals(Long.parseLong("42"), dObj.<Long> get(AllJavaTypes.FIELD_SHORT).longValue());
                         break;
                     case INT:
                         dObj.set(AllJavaTypes.FIELD_INT, 42);
-                        assertEquals(Long.parseLong("42"), dObj.get(AllJavaTypes.FIELD_INT));
+                        assertEquals(Long.parseLong("42"), dObj.<Long> get(AllJavaTypes.FIELD_INT).longValue());
                         break;
                     case LONG:
                         dObj.set(AllJavaTypes.FIELD_LONG, 42L);
-                        assertEquals(Long.parseLong("42"), dObj.get(AllJavaTypes.FIELD_LONG));
+                        assertEquals(Long.parseLong("42"), dObj.<Long> get(AllJavaTypes.FIELD_LONG).longValue());
                         break;
                     case BYTE:
                         dObj.set(AllJavaTypes.FIELD_BYTE, (byte) 4);
-                        assertEquals(Long.parseLong("4"), dObj.get(AllJavaTypes.FIELD_BYTE));
+                        assertEquals(Long.parseLong("4"), dObj.<Long> get(AllJavaTypes.FIELD_BYTE).longValue());
                         break;
                     case FLOAT:
                         dObj.set(AllJavaTypes.FIELD_FLOAT, 1.23f);
-                        assertEquals(Float.parseFloat("1.23"), dObj.get(AllJavaTypes.FIELD_FLOAT));
+                        assertEquals(Float.parseFloat("1.23"), dObj.<Float> get(AllJavaTypes.FIELD_FLOAT), Float.MIN_NORMAL);
                         break;
                     case DOUBLE:
                         dObj.set(AllJavaTypes.FIELD_DOUBLE, 1.234d);
-                        assertEquals(Double.parseDouble("1.234"), dObj.get(AllJavaTypes.FIELD_DOUBLE));
+                        assertEquals(Double.parseDouble("1.234"), dObj.<Double>get(AllJavaTypes.FIELD_DOUBLE), Double.MIN_NORMAL);
                         break;
                     case STRING:
                         dObj.set(AllJavaTypes.FIELD_STRING, "str");
@@ -975,7 +1161,7 @@ public void untypedGetterSetter() {
                         dObj.set(AllJavaTypes.FIELD_OBJECT, dObj);
                         assertEquals(dObj, dObj.get(AllJavaTypes.FIELD_OBJECT));
                         break;
-                    case LIST:
+                    case LIST: {
                         RealmList<DynamicRealmObject> newList = new RealmList<DynamicRealmObject>();
                         newList.add(dObj);
                         dObj.set(AllJavaTypes.FIELD_LIST, newList);
@@ -983,6 +1169,63 @@ public void untypedGetterSetter() {
                         assertEquals(1, list.size());
                         assertEquals(dObj, list.get(0));
                         break;
+                    }
+                    case LIST_INTEGER: {
+                        RealmList<Integer> newList = new RealmList<>(null, 1);
+                        dObj.set(AllJavaTypes.FIELD_INTEGER_LIST, newList);
+                        RealmList<Integer> list = dObj.getList(AllJavaTypes.FIELD_INTEGER_LIST, Integer.class);
+                        assertEquals(2, list.size());
+                        assertArrayEquals(newList.toArray(), list.toArray());
+                        break;
+                    }
+                    case LIST_STRING: {
+                        RealmList<String> newList = new RealmList<>(null, "Foo");
+                        dObj.set(AllJavaTypes.FIELD_STRING_LIST, newList);
+                        RealmList<String> list = dObj.getList(AllJavaTypes.FIELD_STRING_LIST, String.class);
+                        assertEquals(2, list.size());
+                        assertArrayEquals(newList.toArray(), list.toArray());
+                        break;
+                    }
+                    case LIST_BOOLEAN: {
+                        RealmList<Boolean> newList = new RealmList<>(null, true);
+                        dObj.set(AllJavaTypes.FIELD_BOOLEAN_LIST, newList);
+                        RealmList<Boolean> list = dObj.getList(AllJavaTypes.FIELD_BOOLEAN_LIST, Boolean.class);
+                        assertEquals(2, list.size());
+                        assertArrayEquals(newList.toArray(), list.toArray());
+                        break;
+                    }
+                    case LIST_FLOAT: {
+                        RealmList<Float> newList = new RealmList<>(null, 1.23F);
+                        dObj.set(AllJavaTypes.FIELD_FLOAT_LIST, newList);
+                        RealmList<Float> list = dObj.getList(AllJavaTypes.FIELD_FLOAT_LIST, Float.class);
+                        assertEquals(2, list.size());
+                        assertArrayEquals(newList.toArray(), list.toArray());
+                        break;
+                    }
+                    case LIST_DOUBLE: {
+                        RealmList<Double> newList = new RealmList<>(null, 1.24D);
+                        dObj.set(AllJavaTypes.FIELD_DOUBLE_LIST, newList);
+                        RealmList<Double> list = dObj.getList(AllJavaTypes.FIELD_DOUBLE_LIST, Double.class);
+                        assertEquals(2, list.size());
+                        assertArrayEquals(newList.toArray(), list.toArray());
+                        break;
+                    }
+                    case LIST_BINARY: {
+                        RealmList<byte[]> newList = new RealmList<>(null, new byte[] {1, 2, 3});
+                        dObj.set(AllJavaTypes.FIELD_BINARY_LIST, newList);
+                        RealmList<byte[]> list = dObj.getList(AllJavaTypes.FIELD_BINARY_LIST, byte[].class);
+                        assertEquals(2, list.size());
+                        assertArrayEquals(newList.toArray(), list.toArray());
+                        break;
+                    }
+                    case LIST_DATE: {
+                        RealmList<Date> newList = new RealmList<>(null, new Date(1000));
+                        dObj.set(AllJavaTypes.FIELD_DATE_LIST, newList);
+                        RealmList<Date> list = dObj.getList(AllJavaTypes.FIELD_DATE_LIST, Date.class);
+                        assertEquals(2, list.size());
+                        assertArrayEquals(newList.toArray(), list.toArray());
+                        break;
+                    }
                     default:
                         fail();
                 }
@@ -1031,11 +1274,17 @@ public void untypedSetter_usingStringConversion() {
                     // These types don't have a string representation that can be parsed.
                     case OBJECT:
                     case LIST:
+                    case LIST_INTEGER:
+                    case LIST_STRING:
+                    case LIST_BOOLEAN:
+                    case LIST_FLOAT:
+                    case LIST_DOUBLE:
+                    case LIST_BINARY:
+                    case LIST_DATE:
                     case STRING:
                     case BINARY:
                     case BYTE:
                         break;
-
                     default:
                         fail("Unknown type: " + type);
                         break;
@@ -1079,6 +1328,13 @@ public void untypedSetter_illegalImplicitConversionThrows() {
                         case BYTE:
                         case OBJECT:
                         case LIST:
+                        case LIST_INTEGER:
+                        case LIST_STRING:
+                        case LIST_BOOLEAN:
+                        case LIST_FLOAT:
+                        case LIST_DOUBLE:
+                        case LIST_BINARY:
+                        case LIST_DATE:
                         case STRING:
                         case BINARY:
                             continue;
@@ -1157,9 +1413,17 @@ public void getFieldNames() {
         String[] expectedKeys = {AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_ID, AllJavaTypes.FIELD_LONG,
                 AllJavaTypes.FIELD_SHORT, AllJavaTypes.FIELD_INT, AllJavaTypes.FIELD_BYTE, AllJavaTypes.FIELD_FLOAT,
                 AllJavaTypes.FIELD_DOUBLE, AllJavaTypes.FIELD_BOOLEAN, AllJavaTypes.FIELD_DATE,
-                AllJavaTypes.FIELD_BINARY, AllJavaTypes.FIELD_OBJECT, AllJavaTypes.FIELD_LIST};
+                AllJavaTypes.FIELD_BINARY, AllJavaTypes.FIELD_OBJECT, AllJavaTypes.FIELD_LIST,
+                AllJavaTypes.FIELD_STRING_LIST, AllJavaTypes.FIELD_BINARY_LIST, AllJavaTypes.FIELD_BOOLEAN_LIST,
+                AllJavaTypes.FIELD_LONG_LIST, AllJavaTypes.FIELD_INTEGER_LIST, AllJavaTypes.FIELD_SHORT_LIST,
+                AllJavaTypes.FIELD_BYTE_LIST, AllJavaTypes.FIELD_DOUBLE_LIST, AllJavaTypes.FIELD_FLOAT_LIST,
+                AllJavaTypes.FIELD_DATE_LIST};
         String[] keys = dObjTyped.getFieldNames();
-        assertArrayEquals(expectedKeys, keys);
+        // After the stable ID support, primary key field will be inserted first before others. So even FIELD_STRING is
+        // the first defined field in the class, it will be inserted after FIELD_ID.
+        // See ObjectStore::add_initial_columns #if REALM_HAVE_SYNC_STABLE_IDS branch.
+        assertEquals(expectedKeys.length, keys.length);
+        assertThat(Arrays.asList(expectedKeys), Matchers.hasItems(keys));
     }
 
     @Test
@@ -1190,6 +1454,13 @@ public void getFieldType() {
         assertEquals(RealmFieldType.INTEGER, dObjTyped.getFieldType(AllJavaTypes.FIELD_SHORT));
         assertEquals(RealmFieldType.INTEGER, dObjTyped.getFieldType(AllJavaTypes.FIELD_INT));
         assertEquals(RealmFieldType.INTEGER, dObjTyped.getFieldType(AllJavaTypes.FIELD_LONG));
+        assertEquals(RealmFieldType.INTEGER_LIST, dObjTyped.getFieldType(AllJavaTypes.FIELD_INTEGER_LIST));
+        assertEquals(RealmFieldType.STRING_LIST, dObjTyped.getFieldType(AllJavaTypes.FIELD_STRING_LIST));
+        assertEquals(RealmFieldType.BOOLEAN_LIST, dObjTyped.getFieldType(AllJavaTypes.FIELD_BOOLEAN_LIST));
+        assertEquals(RealmFieldType.FLOAT_LIST, dObjTyped.getFieldType(AllJavaTypes.FIELD_FLOAT_LIST));
+        assertEquals(RealmFieldType.DOUBLE_LIST, dObjTyped.getFieldType(AllJavaTypes.FIELD_DOUBLE_LIST));
+        assertEquals(RealmFieldType.BINARY_LIST, dObjTyped.getFieldType(AllJavaTypes.FIELD_BINARY_LIST));
+        assertEquals(RealmFieldType.DATE_LIST, dObjTyped.getFieldType(AllJavaTypes.FIELD_DATE_LIST));
     }
 
     @Test
@@ -1220,7 +1491,7 @@ public void toString_test() {
         // Checks that toString() doesn't crash, and does simple formatting checks. We cannot compare to a set String as
         // eg. the byte array will be allocated each time it is accessed.
         String str = dObjTyped.toString();
-        assertTrue(str.startsWith("AllJavaTypes = ["));
+        assertTrue(str.startsWith("AllJavaTypes = dynamic["));
         assertTrue(str.endsWith("}]"));
     }
 
@@ -1243,6 +1514,13 @@ public void toString_nullValues() {
         assertTrue(str.contains(NullTypes.FIELD_DATE_NULL + ":null"));
         assertTrue(str.contains(NullTypes.FIELD_OBJECT_NULL + ":null"));
         assertTrue(str.contains(NullTypes.FIELD_LIST_NULL + ":RealmList<NullTypes>[0]"));
+        assertTrue(str.contains(NullTypes.FIELD_INTEGER_LIST_NULL + ":RealmList<Long>[0]"));
+        assertTrue(str.contains(NullTypes.FIELD_STRING_LIST_NULL + ":RealmList<String>[0]"));
+        assertTrue(str.contains(NullTypes.FIELD_BOOLEAN_LIST_NULL + ":RealmList<Boolean>[0]"));
+        assertTrue(str.contains(NullTypes.FIELD_FLOAT_LIST_NULL + ":RealmList<Float>[0]"));
+        assertTrue(str.contains(NullTypes.FIELD_DOUBLE_LIST_NULL + ":RealmList<Double>[0]"));
+        assertTrue(str.contains(NullTypes.FIELD_BINARY_LIST_NULL + ":RealmList<byte[]>[0]"));
+        assertTrue(str.contains(NullTypes.FIELD_DATE_LIST_NULL + ":RealmList<Date>[0]"));
     }
 
     @Test
@@ -1260,4 +1538,102 @@ public void testExceptionMessage() {
             assertEquals("Illegal Argument: Field not found: nonExisting", e.getMessage());
         }
     }
+
+    @Test
+    public void getDynamicRealm() {
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        dynamicRealm.refresh();
+        final DynamicRealmObject object = dynamicRealm.where(AllTypes.CLASS_NAME).findFirst();
+
+        assertSame(dynamicRealm, object.getDynamicRealm());
+    }
+
+    @Test
+    public void getRealm() {
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        dynamicRealm.refresh();
+        final DynamicRealmObject object = dynamicRealm.where(AllTypes.CLASS_NAME).findFirst();
+
+        thrown.expect(IllegalStateException.class);
+        object.getRealm();
+    }
+
+    @Test
+    public void getRealm_closedObjectThrows() {
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        dynamicRealm.refresh();
+        final DynamicRealmObject object = dynamicRealm.where(AllTypes.CLASS_NAME).findFirst();
+        dynamicRealm.close();
+        dynamicRealm = null;
+
+        try {
+            object.getDynamicRealm();
+            fail();
+        } catch (IllegalStateException e) {
+            assertEquals(BaseRealm.CLOSED_REALM_MESSAGE, e.getMessage());
+        }
+    }
+
+    @Test
+    public void getRealmConfiguration_deletedObjectThrows() {
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        dynamicRealm.refresh();
+        final DynamicRealmObject object = dynamicRealm.where(AllTypes.CLASS_NAME).findFirst();
+        dynamicRealm.beginTransaction();
+        object.deleteFromRealm();
+        dynamicRealm.commitTransaction();
+
+        try {
+            object.getDynamicRealm();
+            fail();
+        } catch (IllegalStateException e) {
+            assertEquals(RealmObject.MSG_DELETED_OBJECT, e.getMessage());
+        }
+    }
+
+    @Test
+    public void getRealm_illegalThreadThrows() throws Throwable {
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        dynamicRealm.refresh();
+        final DynamicRealmObject object = dynamicRealm.where(AllTypes.CLASS_NAME).findFirst();
+
+        final CountDownLatch threadFinished = new CountDownLatch(1);
+        final AtomicReference<Throwable> throwable = new AtomicReference<>();
+        final Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    object.getDynamicRealm();
+                    fail();
+                } catch (Throwable t) {
+                    throwable.set(t);
+                } finally {
+                    threadFinished.countDown();
+                }
+            }
+        });
+        thread.start();
+        TestHelper.awaitOrFail(threadFinished);
+
+        final Throwable thrownInTheThread = throwable.get();
+        if (!(thrownInTheThread instanceof IllegalStateException)) {
+            throw thrownInTheThread;
+        }
+        assertEquals(BaseRealm.INCORRECT_THREAD_MESSAGE, thrownInTheThread.getMessage());
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
index 5d5b6ed371..7e8d36dd75 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
@@ -332,7 +332,7 @@ public void execute(DynamicRealm realm) {
             });
         } catch (RuntimeException ignored) {
             // Ensures that we pass a valuable error message to the logger for developers.
-            assertEquals(testLogger.message, "Could not cancel transaction, not currently in a transaction.");
+            assertEquals("Could not cancel transaction, not currently in a transaction.", testLogger.message);
         } finally {
             RealmLog.remove(testLogger);
         }
@@ -476,27 +476,27 @@ public void run() {
             @Override
             public void onChange(RealmResults<DynamicRealmObject> object) {
                 assertEquals("data 0", realmResults1.get(0).get(AllTypes.FIELD_STRING));
-                assertEquals(3L, realmResults1.get(0).get(AllTypes.FIELD_LONG));
+                assertEquals(3L, realmResults1.get(0).<Long> get(AllTypes.FIELD_LONG).longValue());
                 assertEquals("data 0", realmResults1.get(1).get(AllTypes.FIELD_STRING));
-                assertEquals(2L, realmResults1.get(1).get(AllTypes.FIELD_LONG));
+                assertEquals(2L, realmResults1.get(1).<Long> get(AllTypes.FIELD_LONG).longValue());
                 assertEquals("data 0", realmResults1.get(2).get(AllTypes.FIELD_STRING));
-                assertEquals(0L, realmResults1.get(2).get(AllTypes.FIELD_LONG));
+                assertEquals(0L, realmResults1.get(2).<Long> get(AllTypes.FIELD_LONG).longValue());
 
                 assertEquals("data 1", realmResults1.get(3).get(AllTypes.FIELD_STRING));
-                assertEquals(4L, realmResults1.get(3).get(AllTypes.FIELD_LONG));
+                assertEquals(4L, realmResults1.get(3).<Long> get(AllTypes.FIELD_LONG).longValue());
                 assertEquals("data 1", realmResults1.get(4).get(AllTypes.FIELD_STRING));
-                assertEquals(3L, realmResults1.get(4).get(AllTypes.FIELD_LONG));
+                assertEquals(3L, realmResults1.get(4).<Long> get(AllTypes.FIELD_LONG).longValue());
                 assertEquals("data 1", realmResults1.get(5).get(AllTypes.FIELD_STRING));
-                assertEquals(1L, realmResults1.get(5).get(AllTypes.FIELD_LONG));
+                assertEquals(1L, realmResults1.get(5).<Long> get(AllTypes.FIELD_LONG).longValue());
                 assertEquals("data 1", realmResults1.get(6).get(AllTypes.FIELD_STRING));
-                assertEquals(0L, realmResults1.get(6).get(AllTypes.FIELD_LONG));
+                assertEquals(0L, realmResults1.get(6).<Long> get(AllTypes.FIELD_LONG).longValue());
 
                 assertEquals("data 2", realmResults1.get(7).get(AllTypes.FIELD_STRING));
-                assertEquals(4L, realmResults1.get(7).get(AllTypes.FIELD_LONG));
+                assertEquals(4L, realmResults1.get(7).<Long> get(AllTypes.FIELD_LONG).longValue());
                 assertEquals("data 2", realmResults1.get(8).get(AllTypes.FIELD_STRING));
-                assertEquals(2L, realmResults1.get(8).get(AllTypes.FIELD_LONG));
+                assertEquals(2L, realmResults1.get(8).<Long> get(AllTypes.FIELD_LONG).longValue());
                 assertEquals("data 2", realmResults1.get(9).get(AllTypes.FIELD_STRING));
-                assertEquals(1L, realmResults1.get(9).get(AllTypes.FIELD_LONG));
+                assertEquals(1L, realmResults1.get(9).<Long> get(AllTypes.FIELD_LONG).longValue());
 
                 signalCallbackDone.run();
             }
@@ -506,27 +506,27 @@ public void onChange(RealmResults<DynamicRealmObject> object) {
             @Override
             public void onChange(RealmResults<DynamicRealmObject> object) {
                 assertEquals("data 2", realmResults2.get(0).get(AllTypes.FIELD_STRING));
-                assertEquals(1L, realmResults2.get(0).get(AllTypes.FIELD_LONG));
+                assertEquals(1L, realmResults2.get(0).<Long> get(AllTypes.FIELD_LONG).longValue());
                 assertEquals("data 2", realmResults2.get(1).get(AllTypes.FIELD_STRING));
-                assertEquals(2L, realmResults2.get(1).get(AllTypes.FIELD_LONG));
+                assertEquals(2L, realmResults2.get(1).<Long> get(AllTypes.FIELD_LONG).longValue());
                 assertEquals("data 2", realmResults2.get(2).get(AllTypes.FIELD_STRING));
-                assertEquals(4L, realmResults2.get(2).get(AllTypes.FIELD_LONG));
+                assertEquals(4L, realmResults2.get(2).<Long> get(AllTypes.FIELD_LONG).longValue());
 
                 assertEquals("data 1", realmResults2.get(3).get(AllTypes.FIELD_STRING));
-                assertEquals(0L, realmResults2.get(3).get(AllTypes.FIELD_LONG));
+                assertEquals(0L, realmResults2.get(3).<Long> get(AllTypes.FIELD_LONG).longValue());
                 assertEquals("data 1", realmResults2.get(4).get(AllTypes.FIELD_STRING));
-                assertEquals(1L, realmResults2.get(4).get(AllTypes.FIELD_LONG));
+                assertEquals(1L, realmResults2.get(4).<Long> get(AllTypes.FIELD_LONG).longValue());
                 assertEquals("data 1", realmResults2.get(5).get(AllTypes.FIELD_STRING));
-                assertEquals(3L, realmResults2.get(5).get(AllTypes.FIELD_LONG));
+                assertEquals(3L, realmResults2.get(5).<Long> get(AllTypes.FIELD_LONG).longValue());
                 assertEquals("data 1", realmResults2.get(6).get(AllTypes.FIELD_STRING));
-                assertEquals(4L, realmResults2.get(6).get(AllTypes.FIELD_LONG));
+                assertEquals(4L, realmResults2.get(6).<Long> get(AllTypes.FIELD_LONG).longValue());
 
                 assertEquals("data 0", realmResults2.get(7).get(AllTypes.FIELD_STRING));
-                assertEquals(0L, realmResults2.get(7).get(AllTypes.FIELD_LONG));
+                assertEquals(0L, realmResults2.get(7).<Long> get(AllTypes.FIELD_LONG).longValue());
                 assertEquals("data 0", realmResults2.get(8).get(AllTypes.FIELD_STRING));
-                assertEquals(2L, realmResults2.get(8).get(AllTypes.FIELD_LONG));
+                assertEquals(2L, realmResults2.get(8).<Long> get(AllTypes.FIELD_LONG).longValue());
                 assertEquals("data 0", realmResults2.get(9).get(AllTypes.FIELD_STRING));
-                assertEquals(3L, realmResults2.get(9).get(AllTypes.FIELD_LONG));
+                assertEquals(3L, realmResults2.get(9).<Long> get(AllTypes.FIELD_LONG).longValue());
 
                 signalCallbackDone.run();
             }
@@ -675,7 +675,36 @@ public void equalTo_noFieldObjectShouldThrow() {
         dynamicRealm.commitTransaction();
 
         thrown.expect(IllegalArgumentException.class);
-        thrown.expectMessage("Invalid query: field 'nonExisting' does not exist in table 'NoField'.");
+        thrown.expectMessage("Invalid query: field 'nonExisting' not found in table 'NoField'.");
         dynamicRealm.where(className).equalTo("nonExisting", 1);
     }
+
+    @Test(expected = IllegalStateException.class)
+    public void getInstanceAsync_nonLooperThreadShouldThrow() {
+        DynamicRealm.getInstanceAsync(defaultConfig, new DynamicRealm.Callback() {
+            @Override
+            public void onSuccess(DynamicRealm realm) {
+                fail();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void getInstanceAsync_nullConfigShouldThrow() {
+        thrown.expect(IllegalArgumentException.class);
+        DynamicRealm.getInstanceAsync(null, new DynamicRealm.Callback() {
+            @Override
+            public void onSuccess(DynamicRealm realm) {
+                fail();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void getInstanceAsync_nullCallbackShouldThrow() {
+        thrown.expect(IllegalArgumentException.class);
+        DynamicRealm.getInstanceAsync(defaultConfig, null);
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
index 0ec3cd03fe..5b8cf56418 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
@@ -31,6 +31,7 @@
 
 import io.realm.entities.IOSAllTypes;
 import io.realm.entities.IOSChild;
+import io.realm.internal.OsObjectStore;
 import io.realm.internal.Table;
 import io.realm.rule.TestRealmConfigurationFactory;
 
@@ -59,7 +60,6 @@ public void setUp() {
         RealmConfiguration defaultConfiguration = configFactory.createConfigurationBuilder()
                 .name(REALM_NAME)
                 .schema(IOSAllTypes.class, IOSChild.class)
-                .deleteRealmIfMigrationNeeded()
                 .build();
         Realm.setDefaultConfiguration(defaultConfiguration);
         context = InstrumentationRegistry.getInstrumentation().getContext();
@@ -82,7 +82,7 @@ public void iOSDataTypes() throws IOException {
             RealmResults<IOSAllTypes> result = realm.where(IOSAllTypes.class).findAllSorted("id", Sort.ASCENDING);
             // Verifies metadata.
             Table table = realm.getTable(IOSAllTypes.class);
-            assertTrue(table.hasPrimaryKey());
+            assertEquals("id", OsObjectStore.getPrimaryKeyForObject(realm.getSharedRealm(), IOSAllTypes.CLASS_NAME));
             assertTrue(table.hasSearchIndex(table.getColumnIndex("id")));
             // Iterative check.
             for (int i = 0; i < 10; i++) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java
index 766d85799e..9d881dd773 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsDynamicTests.java
@@ -22,22 +22,46 @@
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
+import java.util.Locale;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.entities.BacklinksSource;
+import io.realm.entities.BacklinksTarget;
+import io.realm.entities.Cat;
+import io.realm.entities.Owner;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+
 @RunWith(AndroidJUnit4.class)
 public class LinkingObjectsDynamicTests {
 
     @Rule
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
 
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
     private Realm realm;
+    private DynamicRealm dynamicRealm;
 
     @Before
     public void setUp() {
         RealmConfiguration realmConfig = configFactory.createConfiguration();
         realm = Realm.getInstance(realmConfig);
+        dynamicRealm = DynamicRealm.getInstance(realmConfig);
     }
 
     @After
@@ -45,17 +69,472 @@ public void tearDown() {
         if (realm != null) {
             realm.close();
         }
+
+        if (dynamicRealm != null) {
+            dynamicRealm.close();
+        }
+    }
+
+    @Test
+    public void linkingObjects_classIsNull() throws Exception {
+        dynamicRealm.beginTransaction();
+        final DynamicRealmObject object = dynamicRealm.createObject(AllJavaTypes.CLASS_NAME, 1L);
+        dynamicRealm.commitTransaction();
+
+        try {
+            object.linkingObjects(null, AllJavaTypes.FIELD_INT);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals(RealmSchema.EMPTY_STRING_MSG, expected.getMessage());
+        }
+    }
+
+    @Test
+    public void linkingObjects_fieldIsNull() throws Exception {
+        dynamicRealm.beginTransaction();
+        final DynamicRealmObject object = dynamicRealm.createObject(AllJavaTypes.CLASS_NAME, 1L);
+        dynamicRealm.commitTransaction();
+
+        try {
+            object.linkingObjects(AllJavaTypes.CLASS_NAME, null);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Non-null 'srcFieldName' required.", expected.getMessage());
+        }
+    }
+
+    @Test
+    public void linkingObjects_nonExistentClass() {
+        dynamicRealm.beginTransaction();
+        final DynamicRealmObject object = dynamicRealm.createObject(AllJavaTypes.CLASS_NAME, 1L);
+        dynamicRealm.commitTransaction();
+
+        try {
+            object.linkingObjects("ThisClassDoesNotExist", AllJavaTypes.FIELD_INT);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertTrue(expected.getMessage().startsWith("Class not found"));
+        }
+    }
+
+    @Test
+    public void linkingObjects_nonExistentField() {
+        dynamicRealm.beginTransaction();
+        final DynamicRealmObject object = dynamicRealm.createObject(AllJavaTypes.CLASS_NAME, 1L);
+        dynamicRealm.commitTransaction();
+
+        try {
+            object.linkingObjects(AllJavaTypes.CLASS_NAME, "fieldNotExist");
+            fail();
+        } catch (IllegalArgumentException expected) {
+            final String expectedMessage = String.format(Locale.ENGLISH,
+                    "Field name '%s' does not exist on schema for '%s'",
+                    "fieldNotExist", AllJavaTypes.CLASS_NAME);
+            assertEquals(expectedMessage, expected.getMessage());
+        }
+    }
+
+    @Test
+    public void linkingObjects_ignoredExistentField() {
+        dynamicRealm.beginTransaction();
+        final DynamicRealmObject object = dynamicRealm.createObject(AllJavaTypes.CLASS_NAME, 1L);
+        dynamicRealm.commitTransaction();
+
+        try {
+            object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_IGNORED);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            final String expectedMessage = String.format(Locale.ENGLISH,
+                    "Field name '%s' does not exist on schema for '%s'",
+                    AllJavaTypes.FIELD_IGNORED, AllJavaTypes.CLASS_NAME);
+            assertEquals(expectedMessage, expected.getMessage());
+        }
+    }
+
+    @Test
+    public void linkingObjects_linkQueryNotSupported() throws Exception {
+        dynamicRealm.beginTransaction();
+        final DynamicRealmObject object = dynamicRealm.createObject(AllJavaTypes.CLASS_NAME, 1L);
+        dynamicRealm.commitTransaction();
+
+        try {
+            object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_OBJECT);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals(DynamicRealmObject.MSG_LINK_QUERY_NOT_SUPPORTED, expected.getMessage());
+        }
+    }
+
+    @Test
+    public void linkingObjects_invalidFieldType() {
+        dynamicRealm.beginTransaction();
+        final DynamicRealmObject object = dynamicRealm.createObject(AllJavaTypes.CLASS_NAME, 1L);
+        dynamicRealm.commitTransaction();
+
+        for (RealmFieldType fieldType : RealmFieldType.values()) {
+            try {
+                switch (fieldType) {
+                    // skip valid types
+                    case OBJECT: // fall-through
+                    case LIST:
+                        continue;
+                    // skip special case
+                    case LINKING_OBJECTS:
+                        continue;
+                    case INTEGER:
+                        object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_INT);
+                        break;
+                    case BOOLEAN:
+                        object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_BOOLEAN);
+                        break;
+                    case STRING:
+                        object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_STRING);
+                        break;
+                    case BINARY:
+                        object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_BINARY);
+                        break;
+                    case DATE:
+                        object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_DATE);
+                        break;
+                    case FLOAT:
+                        object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_FLOAT);
+                        break;
+                    case DOUBLE:
+                        object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_DOUBLE);
+                        break;
+                    case INTEGER_LIST:
+                        // FIXME zaki50 enable this once Primitive List is implemented
+                        //object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_INT_LIST);
+                        //break;
+                        throw new IllegalArgumentException("Unexpected field type");
+                    case BOOLEAN_LIST:
+                        // FIXME zaki50 enable this once Primitive List is implemented
+                        //object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_BOOLEAN_LIST);
+                        //break;
+                        throw new IllegalArgumentException("Unexpected field type");
+                    case STRING_LIST:
+                        // FIXME zaki50 enable this once Primitive List is implemented
+                        //object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_STRING_LIST);
+                        //break;
+                        throw new IllegalArgumentException("Unexpected field type");
+                    case BINARY_LIST:
+                        // FIXME zaki50 enable this once Primitive List is implemented
+                        //object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_BINARY_LIST);
+                        //break;
+                        throw new IllegalArgumentException("Unexpected field type");
+                    case DATE_LIST:
+                        // FIXME zaki50 enable this once Primitive List is implemented
+                        //object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_DATE_LIST);
+                        //break;
+                        throw new IllegalArgumentException("Unexpected field type");
+                    case FLOAT_LIST:
+                        // FIXME zaki50 enable this once Primitive List is implemented
+                        //object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_FLOAT_LIST);
+                        //break;
+                        throw new IllegalArgumentException("Unexpected field type");
+                    case DOUBLE_LIST:
+                        // FIXME zaki50 enable this once Primitive List is implemented
+                        //object.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_DOUBLE_LIST);
+                        //break;
+                        throw new IllegalArgumentException("Unexpected field type");
+                    default:
+                        fail("unknown type: " + fieldType);
+                        break;
+                }
+                fail();
+            } catch (IllegalArgumentException expected) {
+                assertTrue(expected.getMessage().startsWith("Unexpected field type"));
+            }
+        }
+
+        // Linking Object fields are implicit and do not exist.
+        for (String field : new String[] {AllJavaTypes.FIELD_LO_OBJECT, AllJavaTypes.FIELD_LO_LIST}) {
+            try {
+                object.linkingObjects(AllJavaTypes.CLASS_NAME, field);
+                fail();
+            } catch (IllegalArgumentException expected) {
+                assertTrue(expected.getMessage().contains("does not exist"));
+            }
+        }
+    }
+
+    @Test
+    public void linkingObjects_linkedByOBJECT_backlinksDefinedInModel() {
+        final int numSourceOfTarget1 = 3;
+        final int numSourceOfTarget2 = 2;
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final BacklinksTarget target1 = realm.createObject(BacklinksTarget.class);
+                target1.setId(1);
+
+                // create sources of target1
+                for (int i = 0; i < numSourceOfTarget1; i++) {
+                    final BacklinksSource source = realm.createObject(BacklinksSource.class);
+                    source.setName("source" + i + "_target1");
+                    source.setChild(target1);
+                }
+
+                final BacklinksTarget target2 = realm.createObject(BacklinksTarget.class);
+                target2.setId(2);
+
+                // create sources of target2
+                for (int i = 0; i < numSourceOfTarget2; i++) {
+                    final BacklinksSource source = realm.createObject(BacklinksSource.class);
+                    source.setName("source" + i + "_target2");
+                    source.setChild(target2);
+                }
+
+                // target3 has no owner
+                final BacklinksTarget target3 = realm.createObject(BacklinksTarget.class);
+                target3.setId(3);
+            }
+        });
+
+        final DynamicRealmObject target1 = dynamicRealm.where(BacklinksTarget.CLASS_NAME).equalTo(BacklinksTarget.FIELD_ID, 1).findFirst();
+        final RealmResults<DynamicRealmObject> target1Sources = target1.linkingObjects(BacklinksSource.CLASS_NAME, BacklinksSource.FIELD_CHILD);
+        assertNotNull(target1Sources);
+        assertEquals(numSourceOfTarget1, target1Sources.size());
+        for (DynamicRealmObject target1Source : target1Sources) {
+            assertEquals(BacklinksSource.CLASS_NAME, target1Source.getType());
+            assertTrue(target1Source.getString(BacklinksSource.FIELD_NAME).endsWith("_target1"));
+            assertEquals(target1, target1Source.getObject(BacklinksSource.FIELD_CHILD));
+        }
+
+        final DynamicRealmObject target2 = dynamicRealm.where(BacklinksTarget.CLASS_NAME).equalTo(BacklinksTarget.FIELD_ID, 2).findFirst();
+        final RealmResults<DynamicRealmObject> target2Sources = target2.linkingObjects(BacklinksSource.CLASS_NAME, BacklinksSource.FIELD_CHILD);
+        assertNotNull(target2Sources);
+        assertEquals(numSourceOfTarget2, target2Sources.size());
+        for (DynamicRealmObject target2Source : target2Sources) {
+            assertEquals(BacklinksSource.CLASS_NAME, target2Source.getType());
+            assertTrue(target2Source.getString(BacklinksSource.FIELD_NAME).endsWith("_target2"));
+            assertEquals(target2, target2Source.getObject(BacklinksSource.FIELD_CHILD));
+        }
+
+        final DynamicRealmObject target3 = dynamicRealm.where(BacklinksTarget.CLASS_NAME).equalTo(BacklinksTarget.FIELD_ID, 3).findFirst();
+        final RealmResults<DynamicRealmObject> target3Sources = target3.linkingObjects(BacklinksSource.CLASS_NAME, BacklinksSource.FIELD_CHILD);
+        assertNotNull(target3Sources);
+        assertTrue(target3Sources.isEmpty());
+    }
+
+    @Test
+    public void linkingObjects_linkedByOBJECT_backlinksNotDefinedInModel() {
+        final int numOwnersOfCat1 = 3;
+        final int numOwnersOfCat2 = 2;
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final Cat cat1 = realm.createObject(Cat.class);
+                cat1.setName("cat1");
+
+                // create owners of cat1
+                for (int i = 0; i < numOwnersOfCat1; i++) {
+                    final Owner owner = realm.createObject(Owner.class);
+                    owner.setName("owner" + i + "_cat1");
+                    owner.setCat(cat1);
+                }
+
+                final Cat cat2 = realm.createObject(Cat.class);
+                cat2.setName("cat2");
+
+                // create owners of cat2
+                for (int i = 0; i < numOwnersOfCat2; i++) {
+                    final Owner owner = realm.createObject(Owner.class);
+                    owner.setName("owner" + i + "_cat2");
+                    owner.setCat(cat2);
+                }
+
+                // cat3 has no owner
+                final Cat cat3 = realm.createObject(Cat.class);
+                cat3.setName("cat3");
+            }
+        });
+
+        final DynamicRealmObject cat1 = dynamicRealm.where(Cat.CLASS_NAME).equalTo(Cat.FIELD_NAME, "cat1").findFirst();
+        final RealmResults<DynamicRealmObject> cat1Owners = cat1.linkingObjects(Owner.CLASS_NAME, Owner.FIELD_CAT);
+        assertNotNull(cat1Owners);
+        assertEquals(numOwnersOfCat1, cat1Owners.size());
+        for (DynamicRealmObject cat1Owner : cat1Owners) {
+            assertEquals(Owner.CLASS_NAME, cat1Owner.getType());
+            assertTrue(cat1Owner.getString(Owner.FIELD_NAME).endsWith("_cat1"));
+            assertEquals(cat1, cat1Owner.getObject(Owner.FIELD_CAT));
+        }
+
+        final DynamicRealmObject cat2 = dynamicRealm.where(Cat.CLASS_NAME).equalTo(Cat.FIELD_NAME, "cat2").findFirst();
+        final RealmResults<DynamicRealmObject> cat2Owners = cat2.linkingObjects(Owner.CLASS_NAME, Owner.FIELD_CAT);
+        assertNotNull(cat2Owners);
+        assertEquals(numOwnersOfCat2, cat2Owners.size());
+        for (DynamicRealmObject cat2Owner : cat2Owners) {
+            assertEquals(Owner.CLASS_NAME, cat2Owner.getType());
+            assertTrue(cat2Owner.getString(Owner.FIELD_NAME).endsWith("_cat2"));
+            assertEquals(cat2, cat2Owner.getObject(Owner.FIELD_CAT));
+        }
+
+        final DynamicRealmObject cat3 = dynamicRealm.where(Cat.CLASS_NAME).equalTo(Cat.FIELD_NAME, "cat3").findFirst();
+        final RealmResults<DynamicRealmObject> cat3Owners = cat3.linkingObjects(Owner.CLASS_NAME, Owner.FIELD_CAT);
+        assertNotNull(cat3Owners);
+        assertTrue(cat3Owners.isEmpty());
+    }
+
+    @Test
+    public void linkingObjects_linkedByLIST() {
+        //           source100          source200        source300
+        //            //    \\          \\ || //
+        //        target1   target2     target2
+        //
+        //  // = list ref
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final AllJavaTypes target1 = realm.createObject(AllJavaTypes.class, 1L);
+                final AllJavaTypes target2 = realm.createObject(AllJavaTypes.class, 2L);
+                final AllJavaTypes target3 = realm.createObject(AllJavaTypes.class, 3L);
+
+                final AllJavaTypes source100 = realm.createObject(AllJavaTypes.class, 100L);
+                source100.getFieldList().add(target1);
+                source100.getFieldList().add(target2);
+
+                // list contains three target2s
+                final AllJavaTypes source200 = realm.createObject(AllJavaTypes.class, 200L);
+                source200.getFieldList().add(target2);
+                source200.getFieldList().add(target2);
+                source200.getFieldList().add(target2);
+            }
+        });
+
+        final DynamicRealmObject target1 = dynamicRealm.where(AllJavaTypes.CLASS_NAME).equalTo(AllJavaTypes.FIELD_ID, 1L).findFirst();
+        final DynamicRealmObject target2 = dynamicRealm.where(AllJavaTypes.CLASS_NAME).equalTo(AllJavaTypes.FIELD_ID, 2L).findFirst();
+        final DynamicRealmObject target3 = dynamicRealm.where(AllJavaTypes.CLASS_NAME).equalTo(AllJavaTypes.FIELD_ID, 3L).findFirst();
+
+        // tests sources of target1
+        final RealmResults<DynamicRealmObject> target1Sources = target1.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_LIST);
+        assertNotNull(target1Sources);
+        assertEquals(1, target1Sources.size());
+        assertEquals(AllJavaTypes.CLASS_NAME, target1Sources.first().getType());
+        assertEquals(100L, target1Sources.first().getLong(AllJavaTypes.FIELD_ID));
+        assertTrue(target1Sources.first().getList(AllJavaTypes.FIELD_LIST).contains(target1));
+        assertTrue(target1Sources.first().getList(AllJavaTypes.FIELD_LIST).contains(target2));
+        assertFalse(target1Sources.first().getList(AllJavaTypes.FIELD_LIST).contains(target3));
+
+        // tests sources of target2
+        final RealmResults<DynamicRealmObject> target2Sources = target2.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_LIST);
+        assertNotNull(target2Sources);
+        // if a source (in this test, source200) contains multiple references to a target in one RealmList, those must not be aggregated.
+        assertEquals(4, target2Sources.size());
+        boolean source100Found = false;
+        boolean source200Found = false;
+        for (DynamicRealmObject target2Source : target2Sources) {
+            final long idValue = target2Source.getLong(AllJavaTypes.FIELD_ID);
+            if (idValue == 100L) {
+                source100Found = true;
+            } else if (idValue == 200L) {
+                source200Found = true;
+            } else {
+                fail("unexpected id value: " + idValue);
+            }
+
+            assertEquals(AllJavaTypes.CLASS_NAME, target2Source.getType());
+            assertTrue(target2Source.getList(AllJavaTypes.FIELD_LIST).contains(target2));
+            assertFalse(target2Source.getList(AllJavaTypes.FIELD_LIST).contains(target3));
+        }
+        assertTrue(source100Found);
+        assertTrue(source200Found);
+
+        // tests sources of target3
+        final RealmResults<DynamicRealmObject> target3Sources = target3.linkingObjects(AllJavaTypes.CLASS_NAME, AllJavaTypes.FIELD_LIST);
+        assertNotNull(target3Sources);
+        assertTrue(target3Sources.isEmpty());
+
+        dynamicRealm.executeTransaction(new DynamicRealm.Transaction() {
+            @Override
+            public void execute(DynamicRealm realm) {
+                final DynamicRealmObject source200 = dynamicRealm.where(AllJavaTypes.CLASS_NAME).equalTo(AllJavaTypes.FIELD_ID, 200L).findFirst();
+                // remove last reference in the list
+                source200.getList(AllJavaTypes.FIELD_LIST).remove(2);
+            }
+        });
+
+        // backlinks are also updated
+        assertEquals(3, target2Sources.size());
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void linkingObjects_IllegalStateException_ifNotYetLoaded() {
+        final Realm realm = looperThread.getRealm();
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final BacklinksTarget target1 = realm.createObject(BacklinksTarget.class);
+                target1.setId(1);
+
+                final BacklinksSource source = realm.createObject(BacklinksSource.class);
+                source.setChild(target1);
+            }
+        });
+
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.getConfiguration());
+        try {
+            final DynamicRealmObject targetAsync = dynamicRealm.where(BacklinksTarget.CLASS_NAME)
+                    .equalTo(BacklinksTarget.FIELD_ID, 1L).findFirstAsync();
+            // precondition
+            assertFalse(targetAsync.isLoaded());
+
+            thrown.expect(IllegalStateException.class);
+            targetAsync.linkingObjects(BacklinksSource.CLASS_NAME, BacklinksSource.FIELD_CHILD);
+        } finally {
+            dynamicRealm.close();
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void linkingObjects_IllegalStateException_ifDeleted() {
+        final Realm realm = looperThread.getRealm();
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final BacklinksTarget target1 = realm.createObject(BacklinksTarget.class);
+                target1.setId(1);
+
+                final BacklinksSource source = realm.createObject(BacklinksSource.class);
+                source.setChild(target1);
+            }
+        });
+
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.getConfiguration());
+        try {
+            final DynamicRealmObject target = dynamicRealm.where(BacklinksTarget.CLASS_NAME)
+                    .equalTo(BacklinksTarget.FIELD_ID, 1L).findFirst();
+
+            dynamicRealm.executeTransaction(new DynamicRealm.Transaction() {
+                @Override
+                public void execute(DynamicRealm realm) {
+                    target.deleteFromRealm();
+                }
+            });
+
+            // precondition
+            assertFalse(target.isValid());
+
+            thrown.expect(IllegalStateException.class);
+            target.linkingObjects(BacklinksSource.CLASS_NAME, BacklinksSource.FIELD_CHILD);
+        } finally {
+            dynamicRealm.close();
+        }
     }
 
     @Test
     public void dynamicQuery_invalidSyntax() {
         String[] invalidBacklinks = new String[] {
-            "linkingObject(x",
-            "linkingObject(x.y",
-            "linkingObject(x.y)",
-            "linkingObject(x.y).",
-            "linkingObject(x.y)..z",
-            "linkingObject(x.y).linkingObjects(x1.y1).z"
+                "linkingObject(x",
+                "linkingObject(x.y",
+                "linkingObject(x.y)",
+                "linkingObject(x.y).",
+                "linkingObject(x.y)..z",
+                "linkingObject(x.y).linkingObjects(x1.y1).z"
         };
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
index b729034259..d690a3fb44 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
@@ -20,27 +20,27 @@
 import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 
+import org.hamcrest.CoreMatchers;
 import org.junit.After;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
 import java.io.IOException;
-import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.entities.AllJavaTypes;
-import io.realm.entities.BacklinksMissingFieldSourceModule;
-import io.realm.entities.BacklinksMissingFieldTargetModule;
 import io.realm.entities.BacklinksSource;
 import io.realm.entities.BacklinksTarget;
-import io.realm.entities.BacklinksWrongTypeSourceModule;
-import io.realm.entities.BacklinksWrongTypeTargetModule;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.Property;
+import io.realm.internal.RealmProxyMediator;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -48,8 +48,12 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
+
 
 @RunWith(AndroidJUnit4.class)
 public class LinkingObjectsManagedTests {
@@ -148,6 +152,7 @@ public void basic_multipleReferencesFromParentList() {
         // One entry for each reference, so two references from a LinkList will
         // result in two backlinks.
         assertEquals(2, child.getListParents().size());
+
         assertEquals(parent, child.getListParents().first());
         assertEquals(parent, child.getListParents().last());
     }
@@ -193,14 +198,15 @@ public void onChange(AllJavaTypes object) {
         looperThreadRealm.commitTransaction();
 
         verifyPostConditions(
-            looperThreadRealm,
-            new PostConditions() {
-                @Override
-                public void run(Realm realm) {
-                    assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
-                }
-            },
-            child, parent);
+                looperThreadRealm,
+                new PostConditions() {
+                    @Override
+                    public void run(Realm realm) {
+                        assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
+                    }
+                },
+                child,
+                parent);
     }
 
     // A listener registered on the backlinked field should be called when a commit adds a backlink
@@ -228,15 +234,16 @@ public void onChange(RealmResults<AllJavaTypes> object) {
         looperThreadRealm.commitTransaction();
 
         verifyPostConditions(
-            looperThreadRealm,
-            new PostConditions() {
-                @Override
-                public void run(Realm realm) {
-                    assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
-                    assertEquals(1, counter.get());
-                }
-            },
-            child, parent);
+                looperThreadRealm,
+                new PostConditions() {
+                    @Override
+                    public void run(Realm realm) {
+                        assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
+                        assertEquals(1, counter.get());
+                    }
+                },
+                child,
+                parent);
     }
 
     // A listener registered on the backlinked field should not be called after the listener is removed
@@ -265,14 +272,15 @@ public void onChange(RealmResults<AllJavaTypes> object) {
         looperThreadRealm.commitTransaction();
 
         verifyPostConditions(
-            looperThreadRealm,
-            new PostConditions() {
-                @Override
-                public void run(Realm realm) {
-                    assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
-                }
-            },
-            child, parent);
+                looperThreadRealm,
+                new PostConditions() {
+                    @Override
+                    public void run(Realm realm) {
+                        assertEquals(2, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
+                    }
+                },
+                child,
+                parent);
     }
 
     // A listener registered on the backlinked object should be called when a backlinked object is deleted
@@ -301,15 +309,16 @@ public void onChange(RealmResults<AllJavaTypes> object) {
         looperThreadRealm.commitTransaction();
 
         verifyPostConditions(
-            looperThreadRealm,
-            new PostConditions() {
-                @Override
-                public void run(Realm realm) {
-                    assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
-                    assertEquals(1, counter.get());
-                }
-            },
-            child, parent);
+                looperThreadRealm,
+                new PostConditions() {
+                    @Override
+                    public void run(Realm realm) {
+                        assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
+                        assertEquals(1, counter.get());
+                    }
+                },
+                child,
+                parent);
     }
 
     // A listener registered on the backlinked object should not called for an unrelated change
@@ -336,14 +345,15 @@ public void onChange(RealmResults<AllJavaTypes> object) {
         looperThreadRealm.commitTransaction();
 
         verifyPostConditions(
-            looperThreadRealm,
-            new PostConditions() {
-                @Override
-                public void run(Realm realm) {
-                    assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
-                }
-            },
-            child, parent);
+                looperThreadRealm,
+                new PostConditions() {
+                    @Override
+                    public void run(Realm realm) {
+                        assertEquals(1, looperThreadRealm.where(AllJavaTypes.class).findAll().size());
+                    }
+                },
+                child,
+                parent);
     }
 
     // Fields annotated with @LinkingObjects should not be affected by JSON updates
@@ -449,6 +459,8 @@ public void execute(Realm realm) {
         final BacklinksTarget target = realm.where(BacklinksTarget.class)
                 .equalTo(BacklinksTarget.FIELD_ID, 1L).findFirst();
 
+        assertNotNull(target);
+
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
@@ -492,6 +504,8 @@ public void execute(Realm realm) {
             }
         });
 
+        assertNotNull(target);
+
         // precondition
         assertFalse(target.isValid());
 
@@ -502,23 +516,28 @@ public void execute(Realm realm) {
     }
 
     /**
-     * Table validation should fail if the backinked column already exists in the target table.
+     * Table validation should fail if the backlinked column already exists in the target table.
      * The realm `backlinks-fieldInUse.realm` contains the classes `BacklinksSource` and `BacklinksTarget`
-     * except that in the definition of `BacklinksTarget`, the field parent is defined as:
+     * except that in the definition of {@code BacklinksTarget}, the field parent is defined as:
      * <pre>
      * {@code
      *     private RealmList<BacklinksSource> parents;
      * }
      * </pre>
+     *
+     * <p/>
+     * The backlinked field does exist but it is list of links to {@code BacklinksSource} children
+     * not a list of backlinks to  {@code BacklinksSource} parents of which the {@code BacklinksTarget}
+     * is a child.
      */
     @Test
     public void migration_backlinkedFieldInUse() {
         final String realmName = "backlinks-fieldInUse.realm";
 
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
-            .name(realmName)
-            .schema(BacklinksSource.class, BacklinksTarget.class)
-            .build();
+                .name(realmName)
+                .schema(BacklinksSource.class, BacklinksTarget.class)
+                .build();
 
         try {
             configFactory.copyRealmFromAssets(context, realmName, realmName);
@@ -529,128 +548,121 @@ public void migration_backlinkedFieldInUse() {
         } catch (IOException e) {
             fail("Failed copying realm");
         } catch (RealmMigrationNeededException expected) {
-            assertTrue(expected.getMessage().contains("Field count is"));
+            assertThat(expected.getMessage(),
+                    CoreMatchers.allOf(
+                            CoreMatchers.containsString("Property 'BacklinksSource.name' has been added"),
+                            CoreMatchers.containsString("Property 'BacklinksTarget.parents' has been removed")));
         } finally {
             Realm.deleteRealm(realmConfig);
         }
     }
 
     /**
-     * Table validation should fail if the backinked column points to a non-existent class.
-     * The realm `backlinks-missingSourceClass.realm` contains two tables very like those
-     * defined by `BacklinksSource` and `BacklinksTarget`.  In it, though, the source class
-     * is named XXXBacklinksSource, like so:
-     * <pre>
-     * {@code
-     * @LinkingObjects("child")
-     *     private final RealmResults<XXXBacklinksSource> parents = null;
-     * }
-     * </pre>
-     * If the both classes were used in the configuration, the test would fail because of the
-     * missing class.  Since the configuration contains only the single class `BacklinksTarget`,
-     * basic validation passes.  Backlink validation, however, should fail, seeking the
-     * `BacklinksSource` table.
+     * Schema validation should fail if the backlinked column points to a non-existent class.
+     * Since the configuration contains only the single class `BacklinksTarget`, basic validation passes.
+     * The computed property validation, however, should fail, seeking the `BacklinksSource` table.
      */
     @Test
     public void migration_backlinkedSourceClassDoesntExist() throws IOException {
         final String realmName = "backlinks-missingSourceClass.realm";
-
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
-            .name(realmName)
-            .schema(BacklinksTarget.class)
-            .build();
+                .name(realmName)
+                .schema(BacklinksTarget.class)
+                .build();
 
         try {
-            configFactory.copyRealmFromAssets(context, realmName, realmName);
-
             Realm localRealm = Realm.getInstance(realmConfig);
             localRealm.close();
-            fail("A migration should have been required");
-        } catch (IOException e) {
-            fail("Failed copying realm");
-        } catch (RealmMigrationNeededException expected) {
-            assertTrue(expected.getMessage().contains("Cannot find source class"));
-        } finally {
-            Realm.deleteRealm(realmConfig);
+            fail();
+        } catch (IllegalStateException expected) {
+            assertThat(expected.getMessage(), CoreMatchers.containsString(
+                    "Property 'BacklinksTarget.parents' of type 'linking objects' has unknown object type 'BacklinksSource'"));
         }
     }
 
     /**
-     * Table validation should fail if the backlinked column points to a non-existent field in the source class.
-     * This test is quite a chore to construct!
-     * The realm `backlinks-missingSourceField.realm` was constructed with classes `BacklinksMissingFieldTarget`
-     * and `BacklinksMissingFieldSource`.  They are identical in their definitions to `BacklinkSource` and
-     * `BacklinkTarget` except for their names.  The library `backlinks-missing-field-source.jar` contains
-     * the class `BacklinksMissingFieldSource` and all of its annotation generated code.  The library
-     * `backlinks-missing-field-target.jar` however, contains a version of `BacklinksMissingFieldTarget` that
-     * was compiled with its backlink field referring to a field in `BacklinksMissingFieldSource`, called
-     * `xxxchild`.  Clearly, in order to compile successfully, the definition of `BacklinksMissingFieldSource`
-     * had to be changed accordingly.  The modified version, however, is *NOT* the version that is in
-     * `backlinks-missing-field-source.jar`!
-     * So, now, the proxy in `backlinks-missing-field-source.jar` will correctly validate the its table
-     * (it generated it!). Similarly, the proxy in `backlinks-missing-field-target.jar` will successfully
-     * validate its table.  If we have been living clean lives, though, the validator for
-     * `BacklinksMissingFieldTarget` should notice that there is no field named `BacklinksMissingFieldSource.xxxchild`.
+     * Schema validation should fail if the backlinked column points to a non-existent field in the source class.
      */
     @Test
-    public void migration_backlinkedSourceFieldDoesntExist() {
+    public void migration_backlinkedSourceFieldDoesntExist() throws ClassNotFoundException {
         final String realmName = "backlinks-missingSourceField.realm";
-
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
-            .name(realmName)
-            .modules(new BacklinksMissingFieldSourceModule(), new BacklinksMissingFieldTargetModule())
-            .build();
+                .name(realmName)
+                .schema(BacklinksTarget.class, BacklinksSource.class)
+                .build();
+
+        // Mock the schema info so the only difference compared with the original schema is that the LinkingObject field
+        // points to BacklinksSource.childNotExist.
+        OsObjectSchemaInfo targetSchemaInfo = new OsObjectSchemaInfo.Builder("BacklinksTarget", 1, 1)
+                .addPersistedProperty("id", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED)
+                .addComputedLinkProperty("parents", "BacklinksSource", "childNotExist" /*"child" is the original value*/)
+                .build();
+        OsObjectSchemaInfo sourceSchemaInfo = new OsObjectSchemaInfo.Builder("BacklinksSource", 2, 0)
+                .addPersistedProperty("name", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED)
+                .addPersistedLinkProperty("child", RealmFieldType.OBJECT, "BacklinksTarget")
+                .build();
+        Map<Class<? extends RealmModel>, OsObjectSchemaInfo> infoMap =
+                new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>();
+        infoMap.put(BacklinksTarget.class, targetSchemaInfo);
+        infoMap.put(BacklinksSource.class, sourceSchemaInfo);
+
+        RealmProxyMediator mediator = spy(realmConfig.getSchemaMediator());
+        when(mediator.getExpectedObjectSchemaInfoMap()).thenReturn(infoMap);
+        RealmConfiguration spyConfig = spy(realmConfig);
+        when(spyConfig.getSchemaMediator()).thenReturn(mediator);
 
         try {
-            configFactory.copyRealmFromAssets(context, realmName, realmName);
-
-            Realm localRealm = Realm.getInstance(realmConfig);
+            Realm localRealm = Realm.getInstance(spyConfig);
             localRealm.close();
-            fail("A migration should have been required");
-        } catch (IOException e) {
-            fail("Failed copying realm");
-        } catch (RealmMigrationNeededException expected) {
-            assertTrue(expected.getMessage().contains("Cannot find source field"));
-        } finally {
-            Realm.deleteRealm(realmConfig);
+            fail();
+        } catch (IllegalStateException expected) {
+            assertThat(expected.getMessage(), CoreMatchers.containsString(
+                    "Property 'BacklinksSource.childNotExist' declared as origin of linking objects property 'BacklinksTarget.parents' does not exist"
+            ));
         }
     }
 
     /**
-     * Table validation should fail if the backinked column points to a field of the wrong type.
-     * This test is built in almost exactly the way as was `migration_backlinkedSourceFieldDoesntExist`
-     * The realm `backlinks-sourceFieldWrongType.realm` was constructed with classes `BacklinksWrongTypeTarget`
-     * and `BacklinksWrongTypeSource`.  Again, these two classes are nearly identical in their counterparts
-     * `BacklinkSource` and `BacklinkTarget` except for their names.  Unlike `BacklinkSource`,
-     * `BacklinksWrongTypeSource` has two fields, `child` and `childId`. The first is exactly as it is in
-     * `BacklinkSource`, the second is of type `Integer`.  To construct `backlinks-wrong-type-target.jar`
-     * I reversed the names of the two fields in `BacklinkSource`, and made then adjusted `parents` in
-     * `BacklinkTarget` to point to `childId`.
-     * All of the proxies in in the two jars should correctly validate their tables.  The backlink validation
-     * for `BacklinksWrongTypeTarget` should notice, though, that its `parents` field points to an object
-     * of the wrong type, `Integer`, instead of `BacklinksWrongTypeSource`.
+     * Table validation should fail if the backlinked column points to a field of the wrong type.
      */
     @Test
     public void migration_backlinkedSourceFieldWrongType() {
         final String realmName = "backlinks-sourceFieldWrongType.realm";
 
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
-            .name(realmName)
-            .modules(new BacklinksWrongTypeSourceModule(), new BacklinksWrongTypeTargetModule())
-            .build();
+                .name(realmName)
+                .schema(BacklinksTarget.class, BacklinksSource.class)
+                .build();
+
+        // Mock the schema info so the only difference compared with the original schema is that BacklinksSource.child
+        // type is changed to BacklinksSource from BacklinksTarget.
+        OsObjectSchemaInfo targetSchemaInfo = new OsObjectSchemaInfo.Builder("BacklinksTarget", 1, 1)
+                .addPersistedProperty("id", RealmFieldType.INTEGER, !Property.PRIMARY_KEY, !Property.INDEXED, Property.REQUIRED)
+                .addComputedLinkProperty("parents", "BacklinksSource", "child")
+                .build();
+        OsObjectSchemaInfo sourceSchemaInfo = new OsObjectSchemaInfo.Builder("BacklinksSource", 2, 0)
+                .addPersistedProperty("name", RealmFieldType.STRING, !Property.PRIMARY_KEY, !Property.INDEXED, !Property.REQUIRED)
+                .addPersistedLinkProperty("child", RealmFieldType.OBJECT,
+                        "BacklinksSource"/*"BacklinksTarget" is the original value*/)
+                .build();
+        Map<Class<? extends RealmModel>, OsObjectSchemaInfo> infoMap =
+                new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>();
+        infoMap.put(BacklinksTarget.class, targetSchemaInfo);
+        infoMap.put(BacklinksSource.class, sourceSchemaInfo);
+
+        RealmProxyMediator mediator = spy(realmConfig.getSchemaMediator());
+        when(mediator.getExpectedObjectSchemaInfoMap()).thenReturn(infoMap);
+        RealmConfiguration spyConfig = spy(realmConfig);
+        when(spyConfig.getSchemaMediator()).thenReturn(mediator);
 
         try {
-            configFactory.copyRealmFromAssets(context, realmName, realmName);
-
-            Realm localRealm = Realm.getInstance(realmConfig);
+            Realm localRealm = Realm.getInstance(spyConfig);
             localRealm.close();
-            fail("A migration should have been required");
-        } catch (IOException e) {
-            fail("Failed copying realm");
-        } catch (RealmMigrationNeededException expected) {
-            assertTrue(expected.getMessage().contains("is not a RealmObject type"));
-        } finally {
-            Realm.deleteRealm(realmConfig);
+            fail();
+        } catch (IllegalStateException expected) {
+            assertThat(expected.getMessage(), CoreMatchers.containsString(
+                    "Property 'BacklinksSource.child' declared as origin of linking objects property 'BacklinksTarget.parents' links to type 'BacklinksSource'"
+            ));
         }
     }
 
@@ -671,111 +683,6 @@ public void query_multipleReferencesWithDistinct() {
         assertTrue(child.getListParents().contains(parent));
     }
 
-    // Query on a field descriptor starting with a backlink
-    // The test objects are:
-    //             gen1
-    //             / \
-    //         gen2A gen2B
-    //           \\   //
-    //            gen3
-    //  /  = object ref
-    //  // = list ref
-    @Test
-    @Ignore
-    public void query_startWithBacklink() {
-        realm.beginTransaction();
-        AllJavaTypes gen1 = realm.createObject(AllJavaTypes.class, 10);
-
-        AllJavaTypes gen2A = realm.createObject(AllJavaTypes.class, 1);
-        gen2A.setFieldObject(gen1);
-
-        AllJavaTypes gen2B = realm.createObject(AllJavaTypes.class, 2);
-        gen2B.setFieldObject(gen1);
-
-        AllJavaTypes gen3 = realm.createObject(AllJavaTypes.class, 3);
-        RealmList<AllJavaTypes> parents = gen3.getFieldList();
-        parents.add(gen2A);
-        parents.add(gen2B);
-
-        realm.commitTransaction();
-
-        RealmResults<AllJavaTypes> result = realm.where(AllJavaTypes.class)
-            .greaterThan("objectParents.fieldId", 1)
-            .findAll();
-        assertEquals(1, result.size());
-        assertTrue(result.contains(gen2B));
-    }
-
-    // Query on a field descriptor that ends with a backlink
-    // The test objects are:
-    //             gen1
-    //             / \
-    //         gen2A gen2B
-    //           \\   //
-    //            gen3
-    //  /  = object ref
-    //  // = list ref
-    @Test
-    @Ignore
-    public void query_endWithBacklink() {
-        realm.beginTransaction();
-        AllJavaTypes gen1 = realm.createObject(AllJavaTypes.class, 10);
-
-        AllJavaTypes gen2A = realm.createObject(AllJavaTypes.class, 1);
-        gen2A.setFieldObject(gen1);
-
-        AllJavaTypes gen2B = realm.createObject(AllJavaTypes.class, 2);
-        gen2B.setFieldObject(gen1);
-
-        AllJavaTypes gen3 = realm.createObject(AllJavaTypes.class, 3);
-        RealmList<AllJavaTypes> parents = gen3.getFieldList();
-        parents.add(gen2A);
-        parents.add(gen2B);
-
-        realm.commitTransaction();
-
-        RealmResults<AllJavaTypes> result = realm.where(AllJavaTypes.class)
-            .isNotNull("objectParents.listParents")
-            .findAll();
-        assertEquals(2, result.size());
-        assertTrue(result.contains(gen2A));
-        assertTrue(result.contains(gen2B));
-    }
-
-    // Query on a field descriptor that has a backlink in the middle
-    // The test objects are:
-    //             gen1
-    //             / \
-    //         gen2A gen2B
-    //           \\   //
-    //            gen3
-    //  /  = object ref
-    //  // = list ref
-    @Test
-    @Ignore
-    public void query_backlinkInMiddle() {
-        realm.beginTransaction();
-        AllJavaTypes gen1 = realm.createObject(AllJavaTypes.class, 10);
-
-        AllJavaTypes gen2A = realm.createObject(AllJavaTypes.class, 1);
-        gen2A.setFieldObject(gen1);
-
-        AllJavaTypes gen2B = realm.createObject(AllJavaTypes.class, 2);
-        gen2B.setFieldObject(gen1);
-
-        AllJavaTypes gen3 = realm.createObject(AllJavaTypes.class, 3);
-        RealmList<AllJavaTypes> parents = gen3.getFieldList();
-        parents.add(gen2A);
-        parents.add(gen2B);
-
-        realm.commitTransaction();
-
-        RealmResults<AllJavaTypes> result = realm.where(AllJavaTypes.class)
-            .lessThan("objectParents.listParents.fieldId", 4)
-            .findAll();
-        assertEquals(2, result.size());
-    }
-
     // Based on a quick conversation with Christian Melchior and Mark Rowe,
     // it appears that notifications are enqueued, briefly, on a non-Java
     // thread.  That makes their delivery onto the looper thread unpredictable.
@@ -798,13 +705,13 @@ private void verifyPostConditions(final Realm realm, final PostConditions test,
             looperThread.keepStrongReference(ref);
         }
         looperThread.postRunnable(
-            new Runnable() {
-                @Override
-                public void run() {
-                    test.run(realm);
-                    looperThread.testComplete();
-                }
-            });
+                new Runnable() {
+                    @Override
+                    public void run() {
+                        test.run(realm);
+                        looperThread.testComplete();
+                    }
+                });
     }
 }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsQueryTests.java
new file mode 100644
index 0000000000..4b2d657c55
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsQueryTests.java
@@ -0,0 +1,644 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Date;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.entities.BacklinksTarget;
+import io.realm.entities.NullTypes;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class LinkingObjectsQueryTests extends QueryTests {
+
+    // All the basic tests for is[Not](Equal|Null) are in RealmQueryTests
+
+
+    // Query on a field descriptor starting with a backlink
+    // Build a simple object graph.
+    // The test objects are:
+    //             gen1
+    //             / \
+    //         gen2A gen2B
+    //           \\   //
+    //            gen3
+    //  /  = object ref
+    //  // = list ref
+    @Test
+    public void query_startWithBacklink() {
+        realm.beginTransaction();
+        AllJavaTypes gen1 = realm.createObject(AllJavaTypes.class, 10);
+
+        AllJavaTypes gen2A = realm.createObject(AllJavaTypes.class, 1);
+        gen2A.setFieldObject(gen1);
+
+        AllJavaTypes gen2B = realm.createObject(AllJavaTypes.class, 2);
+        gen2B.setFieldObject(gen1);
+
+        AllJavaTypes gen3 = realm.createObject(AllJavaTypes.class, 3);
+        RealmList<AllJavaTypes> parents = gen3.getFieldList();
+        parents.add(gen2A);
+        parents.add(gen2B);
+
+        realm.commitTransaction();
+
+        // row 0: backlink to rows 1 and 2; row 1 link to row 0, included
+        // row 1: no backlink, not included
+        // row 2: no backlink, not included
+        // row 3: no backlink, not included
+        // summary: 1 row (gen1)
+        RealmResults<AllJavaTypes> result = realm.where(AllJavaTypes.class)
+                .greaterThan(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_ID, 1)
+                .findAll();
+        assertEquals(1, result.size());
+        assertTrue(result.contains(gen1));
+    }
+
+    // Query on a field descriptor that has a backlink in the middle
+    // Build a simple object graph.
+    // The test objects are:
+    //             gen1
+    //             / \
+    //         gen2A gen2B
+    //           \\   //
+    //            gen3
+    //  /  = object ref
+    //  // = list ref
+    @Test
+    public void query_backlinkInMiddle() {
+        realm.beginTransaction();
+        AllJavaTypes gen1 = realm.createObject(AllJavaTypes.class, 10);
+
+        AllJavaTypes gen2A = realm.createObject(AllJavaTypes.class, 1);
+        gen2A.setFieldObject(gen1);
+
+        AllJavaTypes gen2B = realm.createObject(AllJavaTypes.class, 2);
+        gen2B.setFieldObject(gen1);
+
+        AllJavaTypes gen3 = realm.createObject(AllJavaTypes.class, 3);
+        RealmList<AllJavaTypes> parents = gen3.getFieldList();
+        parents.add(gen2A);
+        parents.add(gen2B);
+
+        realm.commitTransaction();
+
+        // row 0: no link, not included
+        // row 1: link to row 0, backlink to rows 1 and 2, row 2 has id < 2, included
+        // row 2: link to row 0, backlink to rows 1 and 2, row 2 has id < 2, included
+        // row 3: no link, not included
+        // summary: 2 rows (gen2A and gen2B)
+        RealmResults<AllJavaTypes> result = realm.where(AllJavaTypes.class)
+                .lessThan(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_ID, 2)
+                .findAll();
+        assertEquals(2, result.size());
+        assertTrue(result.contains(gen2A));
+        assertTrue(result.contains(gen2B));
+    }
+
+    // Tests isNotNull on link's nullable field.
+    @Test
+    public void isNull_object() {
+        populateTestRealmForNullTests(realm);
+
+        // 1 String
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_STRING_NULL).count());
+        // 2 Bytes
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_BYTES_NULL).count());
+        // 3 Boolean
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_BOOLEAN_NULL).count());
+        // 4 Byte
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_BYTE_NULL).count());
+        // 5 Short
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_SHORT_NULL).count());
+        // 6 Integer
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_INTEGER_NULL).count());
+        // 7 Long
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_LONG_NULL).count());
+        // 8 Float
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_FLOAT_NULL).count());
+        // 9 Double
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_DOUBLE_NULL).count());
+        // 10 Date
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_DATE_NULL).count());
+    }
+
+    // Tests isNull on link's nullable field.
+    @Test
+    public void isNull_list() {
+        populateTestRealmForNullTests(realm);
+
+        // 1 String
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_STRING_NULL).count());
+        // 2 Bytes
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_BYTES_NULL).count());
+        // 3 Boolean
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_BOOLEAN_NULL).count());
+        // 4 Byte
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_BYTE_NULL).count());
+        // 5 Short
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_SHORT_NULL).count());
+        // 6 Integer
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_INTEGER_NULL).count());
+        // 7 Long
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_LONG_NULL).count());
+        // 8 Float
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_FLOAT_NULL).count());
+        // 9 Double
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_DOUBLE_NULL).count());
+        // 10 Date
+        assertEquals(1, realm.where(NullTypes.class).isNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_DATE_NULL).count());
+    }
+
+    @Test
+    public void isNull_unsupported() {
+        long result;
+
+        // Tests for other unsupported null types are in RealmQueryTests
+
+        try {
+            result = realm.where(NullTypes.class).isNull(NullTypes.FIELD_LO_OBJECT).count();
+            fail("isNull should throw on type LINKING_OBJECT(14) targeting an OBJECT");
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Illegal Argument: LinkingObject from field fieldObjectNull is not nullable.", expected.getMessage());
+        }
+        try {
+            result = realm.where(NullTypes.class).isNull(NullTypes.FIELD_LO_LIST).count();
+            fail("isNull should throw on type LINKING_OBJECT(14) targeting a LIST");
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Illegal Argument: LinkingObject from field fieldListNull is not nullable.", expected.getMessage());
+        }
+    }
+
+    @Test
+    public void isNull_unsupportedLinkedTypes() {
+        RealmQuery<NullTypes> result;
+
+        // Tests for other unsupported null types are in RealmQueryTests
+
+        try {
+            result = realm.where(NullTypes.class).isNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_LO_OBJECT);
+            fail("isNull should throw on nested linked fields (LINKING_OBJECT => OBJECT)");
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Illegal Argument: LinkingObject from field fieldObjectNull is not nullable.", expected.getMessage());
+        }
+        try {
+            result = realm.where(NullTypes.class).isNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_LO_LIST);
+            fail("isNull should throw on nested linked fields (LINKING_OBJECT => LIST)");
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Illegal Argument: LinkingObject from field fieldListNull is not nullable.", expected.getMessage());
+        }
+    }
+
+    // Tests isNotNull on link's nullable field.
+    @Test
+    public void isNotNull_object() {
+        populateTestRealmForNullTests(realm);
+
+        // 1 String
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_STRING_NULL).count());
+        // 2 Bytes
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_BYTES_NULL).count());
+        // 3 Boolean
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_BOOLEAN_NULL).count());
+        // 4 Byte
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_BYTE_NULL).count());
+        // 5 Short
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_SHORT_NULL).count());
+        // 6 Integer
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_INTEGER_NULL).count());
+        // 7 Long
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_LONG_NULL).count());
+        // 8 Float
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_FLOAT_NULL).count());
+        // 9 Double
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_DOUBLE_NULL).count());
+        // 10 Date
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_OBJECT + "." + NullTypes.FIELD_DATE_NULL).count());
+    }
+
+    // Tests isNotNull on link's nullable field.
+    @Test
+    public void isNotNull_list() {
+        populateTestRealmForNullTests(realm);
+
+        // 1 String
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_STRING_NULL).count());
+        // 2 Bytes
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_BYTES_NULL).count());
+        // 3 Boolean
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_BOOLEAN_NULL).count());
+        // 4 Byte
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_BYTE_NULL).count());
+        // 5 Short
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_SHORT_NULL).count());
+        // 6 Integer
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_INTEGER_NULL).count());
+        // 7 Long
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_LONG_NULL).count());
+        // 8 Float
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_FLOAT_NULL).count());
+        // 9 Double
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_DOUBLE_NULL).count());
+        // 10 Date
+        assertEquals(1, realm.where(NullTypes.class).isNotNull(
+                NullTypes.FIELD_LO_LIST + "." + NullTypes.FIELD_DATE_NULL).count());
+    }
+
+    @Test
+    public void isNotNull_unsupported() {
+        long result;
+
+        // Tests for other unsupported not null types are in RealmQueryTests
+
+        try {
+            result = realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_LO_OBJECT).count();
+            fail("isNotNull should throw on type LINKING_OBJECT(14) targeting an OBJECT");
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Illegal Argument: LinkingObject from field fieldObjectNull is not nullable.", expected.getMessage());
+        }
+        try {
+            result = realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_LO_LIST).count();
+            fail("isNotNull should throw on type LINKING_OBJECT(14) targeting a LIST");
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Illegal Argument: LinkingObject from field fieldListNull is not nullable.", expected.getMessage());
+        }
+    }
+
+    @Test
+    public void isNotNull_unsupportedLinkedTypes() {
+        RealmQuery<NullTypes> result;
+
+        // Tests for other unsupported not null types are in RealmQueryTests
+
+        try {
+            result = realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_LO_OBJECT);
+            fail("isNotNull should throw on nested linked fields (LINKING_OBJECT => OBJECT)");
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Illegal Argument: LinkingObject from field fieldObjectNull is not nullable.", expected.getMessage());
+        }
+        try {
+            result = realm.where(NullTypes.class).isNotNull(NullTypes.FIELD_OBJECT_NULL + "." + NullTypes.FIELD_LO_LIST);
+            fail("isNotNull should throw on nested linked fields (LINKING_OBJECT => LIST)");
+        } catch (IllegalArgumentException expected) {
+            assertEquals("Illegal Argument: LinkingObject from field fieldListNull is not nullable.", expected.getMessage());
+        }
+    }
+
+    @Test
+    public void isEmpty_linkingObjects() {
+        createIsEmptyDataSet(realm);
+        for (RealmFieldType type : SUPPORTED_IS_EMPTY_TYPES) {
+            switch (type) {
+                case LINKING_OBJECTS:
+                    // Row 0: backlink to row 0; not included
+                    // Row 1: backlink to row 1; not included
+                    // Row 2: no backlink; included
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT).count());
+                    // Only row 1 has a linklist (and a backlink)
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST).count());
+                    break;
+                default:
+                    // tested in RealmQueryTests
+            }
+        }
+    }
+
+    @Test
+    public void isEmpty_multipleModelClasses() {
+        createLinkedDataSet(realm);
+        assertEquals(1, realm.where(BacklinksTarget.class).isEmpty(BacklinksTarget.FIELD_PARENTS).count());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void equalTo_linkingObjectLast() {
+        createLinkedDataSet(realm);
+        realm.where(BacklinksTarget.class).equalTo(BacklinksTarget.FIELD_PARENTS, "parents");
+    }
+
+    @Test
+    public void isEmpty_acrossLink() {
+        createIsEmptyDataSet(realm);
+        for (RealmFieldType type : SUPPORTED_IS_EMPTY_TYPES) {
+            switch (type) {
+                case LINKING_OBJECTS:
+                    // Rows 0 and 1 are not included as they are linked to another row through FIELD_OBJECT
+                    // Row 2 is included (no link)
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
+                    // Row 0 has link to row 0 which has a backlink (list); not included
+                    // Row 1 has link to row 1 which has a backlink (list); not included
+                    // Row 2 has no link; included
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_LIST).count());
+                    break;
+                default:
+                    // tested in RealmQueryTests
+            }
+        }
+    }
+
+    @Test
+    public void isEmpty_acrossLinkingObjectObjectLink() {
+        createIsEmptyDataSet(realm);
+        for (RealmFieldType type : SUPPORTED_IS_EMPTY_TYPES) {
+            switch (type) {
+                case STRING:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_STRING).count());
+                    break;
+                case BINARY:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_BINARY).count());
+                    break;
+                case LIST:
+                    // Row 0: backlink to row 0, linklist is empty; included
+                    // Row 1: backlink to row 1, linklist to row 0; not included
+                    // Row 2: no backlink; included
+                    assertEquals(2, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_LIST).count());
+                    break;
+                case LINKING_OBJECTS:
+                    // Both row 0 and 1 have a link/backlink; not included
+                    // row 2 has no link/backlink and an empty list; included
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_LO_LIST).count());
+                    break;
+                default:
+                    fail("Unknown type: " + type);
+            }
+        }
+    }
+
+    @Test
+    public void isEmpty_acrossLinkingObjectListLink() {
+        createIsEmptyDataSet(realm);
+        assertEquals(3, realm.where(AllJavaTypes.class).findAll().size());
+        for (RealmFieldType type : SUPPORTED_IS_EMPTY_TYPES) {
+            switch (type) {
+                case STRING:
+                    // Row 2 included (has no backlink)
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_STRING).count());
+                    break;
+                case BINARY:
+                    // Row 2 included (has no backlink)
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_BINARY).count());
+                    break;
+                case LIST:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_LIST).count());
+                    break;
+                case LINKING_OBJECTS:
+                    // Row 0: Backlink (list) to row 1, row 1 backlink to row 1; not included
+                    // Row 1: Backlink (list) to row 2, row 2 no backlink; included
+                    // Row 2: No backlink (list); included
+                    assertEquals(2, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
+
+                    // Step 1:
+                    //  Row 0 skipped; FIELD_LO_LIST.count > 0
+                    //  Row 1 included; FIELD_LO_LIST.count() == 0
+                    //
+                    // Step 2: now checking Row 2
+                    // Row 0 included: goes to Row 1 where FIELD_LO_LIST.count() == 0
+                    assertEquals(2, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_LO_LIST).count());
+                    break;
+                default:
+                    fail("Unknown type: " + type);
+            }
+        }
+    }
+
+    @Test
+    public void isNotEmpty() {
+        createIsNotEmptyDataSet(realm);
+        for (RealmFieldType type : SUPPORTED_IS_NOT_EMPTY_TYPES) {
+            switch (type) {
+                case LINKING_OBJECTS:
+                    // Row 0 and 1 have a link/backlink so no row is empty
+                    assertEquals(0, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT).count());
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST).count());
+                    break;
+                default:
+                    // tested in RealmQueryTests
+            }
+        }
+    }
+
+    @Test
+    public void isNotEmpty_acrossLink() {
+        createIsNotEmptyDataSet(realm);
+        for (RealmFieldType type : SUPPORTED_IS_NOT_EMPTY_TYPES) {
+            switch (type) {
+                case LINKING_OBJECTS:
+                    // tested in LinkingObjectsQueryTests;
+                    // Row 0 and Row 1 have link/backlink - no empty
+                    assertEquals(0, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_LIST).count());
+                    break;
+                default:
+                    // tested in RealmQueryTests
+            }
+        }
+    }
+
+    @Test
+    public void isNotEmpty_acrossLinkingObjectObjectLink() {
+        createIsEmptyDataSet(realm);
+        for (RealmFieldType type : SUPPORTED_IS_EMPTY_TYPES) {
+            switch (type) {
+                case STRING:
+                    // Row 0: Follow link to row 0, and FIELD_STRING is empty ("")
+                    // Row 1: Follow link to row 1, and FIELD_STRING is not empty ("Foo")
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_STRING).count());
+                    break;
+                case BINARY:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_BINARY).count());
+                    break;
+                case LIST:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_LIST).count());
+                    break;
+                case LINKING_OBJECTS:
+                    // Both row 0 and 1 have a link/backlink
+                    assertEquals(2, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
+
+                    // Row 0: Backlink to row 0, backlink list to row 1; included
+                    // Row 1: Backlink to row 1, backlink list to row 2; included
+                    // Row 2: No backlink; not empty
+                    assertEquals(2, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_OBJECT + "." + AllJavaTypes.FIELD_LO_LIST).count());
+                    break;
+                default:
+                    fail("Unknown type: " + type);
+            }
+        }
+    }
+
+    @Test
+    public void isNotEmpty_acrossLinkingObjectListLink() {
+        createIsEmptyDataSet(realm);
+        assertEquals(3, realm.where(AllJavaTypes.class).findAll().size());
+        for (RealmFieldType type : SUPPORTED_IS_EMPTY_TYPES) {
+            switch (type) {
+                case STRING:
+                    // Row 0: Backlink list to row 1, string not empty ("Foo"); included
+                    // Row 1: Backlink list to row 2, string is empty; not included
+                    // Row 2: No backlink list; not included
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_STRING).count());
+                    break;
+                case BINARY:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_BINARY).count());
+                    break;
+                case LIST:
+                    // Row 0: Backlink list to row 1, list to row 0; included
+                    // Row 1: Backlink list to row 2, list to row 1; included
+                    // Row 2: No backlink list; not included
+                    assertEquals(2, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_LIST).count());
+                    break;
+                case LINKING_OBJECTS:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
+
+                    // Row 0: Backlink list to row 1, backlink list to row 2; included
+                    // Row 1: Backlink list to row 2, empty backlink list; not included
+                    // Row 2: Empty backlink list; not included
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_LIST + "." + AllJavaTypes.FIELD_LO_LIST).count());
+                    break;
+                default:
+                    fail("Unknown type: " + type);
+            }
+        }
+    }
+
+    // Similar to the version in TestHelper, but with more Backlinks
+    // Creates 3 NullTypes objects. The objects are self-referenced (link) in
+    // order to test link queries.
+    //
+    // +-+--------+------+---------+--------+--------------------+----------+
+    // | | string | link | numeric | binary | numeric (not null) | linklist |
+    // +-+--------+------+---------+--------+--------------------+----------+
+    // |0| Fish   |    0 |       1 |    {0} |                  1 |      [0] |
+    // |1| null   |    2 |    null |   null |                  0 |      [2] |
+    // |2| Horse  | null |       3 |  {1,2} |                  3 |     null |
+    // +-+--------+------+---------+--------+--------------------+----------+
+    private void populateTestRealmForNullTests(Realm testRealm) {
+        // 1 String
+        String[] words = {"Fish", null, "Horse"};
+        // 2 Bytes
+        byte[][] binaries = {new byte[]{0}, null, new byte[]{1, 2}};
+        // 3 Boolean
+        Boolean[] booleans = {false, null, true};
+        // Numeric fields will be 1, 0/null, 3
+        // 10 Date
+        Date[] dates = {new Date(0), null, new Date(10000)};
+        NullTypes[] nullTypesArray = new NullTypes[3];
+
+        testRealm.beginTransaction();
+        for (int i = 0; i < 3; i++) {
+            NullTypes nullTypes = new NullTypes();
+            nullTypes.setId(i + 1);
+            // 1 String
+            nullTypes.setFieldStringNull(words[i]);
+            if (words[i] != null) {
+                nullTypes.setFieldStringNotNull(words[i]);
+            }
+            // 2 Bytes
+            nullTypes.setFieldBytesNull(binaries[i]);
+            if (binaries[i] != null) {
+                nullTypes.setFieldBytesNotNull(binaries[i]);
+            }
+            // 3 Boolean
+            nullTypes.setFieldBooleanNull(booleans[i]);
+            if (booleans[i] != null) {
+                nullTypes.setFieldBooleanNotNull(booleans[i]);
+            }
+            if (i != 1) {
+                int n = i + 1;
+                // 4 Byte
+                nullTypes.setFieldByteNull((byte) n);
+                nullTypes.setFieldByteNotNull((byte) n);
+                // 5 Short
+                nullTypes.setFieldShortNull((short) n);
+                nullTypes.setFieldShortNotNull((short) n);
+                // 6 Integer
+                nullTypes.setFieldIntegerNull(n);
+                nullTypes.setFieldIntegerNotNull(n);
+                // 7 Long
+                nullTypes.setFieldLongNull((long) n);
+                nullTypes.setFieldLongNotNull((long) n);
+                // 8 Float
+                nullTypes.setFieldFloatNull((float) n);
+                nullTypes.setFieldFloatNotNull((float) n);
+                // 9 Double
+                nullTypes.setFieldDoubleNull((double) n);
+                nullTypes.setFieldDoubleNotNull((double) n);
+            }
+            // 10 Date
+            nullTypes.setFieldDateNull(dates[i]);
+            if (dates[i] != null) {
+                nullTypes.setFieldDateNotNull(dates[i]);
+            }
+
+            nullTypesArray[i] = testRealm.copyToRealm(nullTypes);
+        }
+        nullTypesArray[0].setFieldObjectNull(nullTypesArray[0]);
+        nullTypesArray[1].setFieldObjectNull(nullTypesArray[2]);
+        nullTypesArray[2].setFieldObjectNull(null);
+
+        nullTypesArray[0].getFieldListNull().add(nullTypesArray[1]);
+        nullTypesArray[1].getFieldListNull().add(nullTypesArray[2]);
+        nullTypesArray[2].getFieldListNull().clear(); // just to be sure
+        testRealm.commitTransaction();
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsUnmanagedTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsUnmanagedTests.java
index 94fc826d44..633184a5d8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsUnmanagedTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsUnmanagedTests.java
@@ -24,7 +24,6 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import dk.ilios.spanner.All;
 import io.realm.entities.AllJavaTypes;
 import io.realm.rule.TestRealmConfigurationFactory;
 
@@ -65,45 +64,22 @@ public void copyFromRealm() {
         assertEquals(parent, child.getObjectParents().first());
 
         AllJavaTypes unmanagedChild = realm.copyFromRealm(child);
-        assertEquals(new AllJavaTypes().getObjectParents(), unmanagedChild.getObjectParents());
-    }
-
-    // When managed, an object's backlinks fields get live.
-    @Test
-    public void copyToRealm() {
-        AllJavaTypes unmanagedChild = new AllJavaTypes(1);
-
-        realm.beginTransaction();
-        AllJavaTypes parent = realm.createObject(AllJavaTypes.class, 2);
-        realm.commitTransaction();
-        assertEquals(new AllJavaTypes().getObjectParents(), unmanagedChild.getObjectParents());
-
-        realm.beginTransaction();
-        AllJavaTypes child = realm.copyToRealm(unmanagedChild);
-        parent.setFieldObject(child);
-        realm.commitTransaction();
-
-        RealmResults<AllJavaTypes> parents = child.getObjectParents();
-        assertNotNull(parents);
-        assertEquals(1, parents.size());
-        assertEquals(parent, parents.first());
+        assertNull(unmanagedChild.getObjectParents());
     }
 
     // Test round-trip
     @Test
     public void copyToAndFromRealm() {
         AllJavaTypes unmanagedChild = new AllJavaTypes(1);
+        assertNull(unmanagedChild.getObjectParents());
 
         realm.beginTransaction();
         AllJavaTypes parent = realm.createObject(AllJavaTypes.class, 2);
-        realm.commitTransaction();
-        assertEquals(new AllJavaTypes().getObjectParents(), unmanagedChild.getObjectParents());
-
-        realm.beginTransaction();
         AllJavaTypes child = realm.copyToRealm(unmanagedChild);
         parent.setFieldObject(child);
         realm.commitTransaction();
 
+        // When managed, an object's backlinks fields get live.
         RealmResults<AllJavaTypes> parents = child.getObjectParents();
         assertNotNull(parents);
         assertEquals(1, parents.size());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
index 8e81f62878..c50e59cc54 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
@@ -34,6 +34,7 @@
 import java.util.concurrent.Future;
 
 import io.realm.entities.AllJavaTypes;
+import io.realm.entities.AllTypes;
 import io.realm.entities.Dog;
 import io.realm.entities.NullTypes;
 import io.realm.entities.Owner;
@@ -613,15 +614,25 @@ public void sort_long() {
     public void deleteFromRealm() {
         OrderedRealmCollection<Dog> collection = createNonCyclicCollection(realm, collectionClass);
         assertEquals(1, collection.get(1).getAge());
-        realm.beginTransaction();
-        collection.deleteFromRealm(0);
-        realm.commitTransaction();
-        if (isSnapshot(collectionClass)) {
-            assertEquals(TEST_SIZE, collection.size());
-            assertFalse(collection.get(0).isValid());
-        } else {
-            assertEquals(TEST_SIZE - 1, collection.size());
-            assertEquals(2, collection.get(1).getAge());
+
+        int[] indexToDelete = {TEST_SIZE/2, TEST_SIZE - 2, 0};
+        int currentSize = TEST_SIZE;
+
+        for (int i = 0; i < indexToDelete.length; i++) {
+            int index = indexToDelete[i];
+            realm.beginTransaction();
+            Dog dog = collection.get(index);
+            collection.deleteFromRealm(index);
+            realm.commitTransaction();
+            if (isSnapshot(collectionClass)) {
+                assertEquals(TEST_SIZE, collection.size());
+                assertFalse(collection.get(index).isValid());
+            } else {
+                assertEquals(currentSize- 1, collection.size());
+            }
+            assertFalse(dog.isValid());
+            assertEquals(currentSize- 1, realm.where(Dog.class).count());
+            currentSize -= 1;
         }
     }
 
@@ -646,6 +657,7 @@ public void deleteFirstFromRealm() {
         assertEquals(0, collection.get(0).getAge());
 
         realm.beginTransaction();
+        Dog dog = collection.first();
         assertTrue(collection.deleteFirstFromRealm());
         realm.commitTransaction();
         if (isSnapshot(collectionClass)) {
@@ -655,6 +667,8 @@ public void deleteFirstFromRealm() {
             assertEquals(TEST_SIZE - 1, collection.size());
             assertEquals(1, collection.get(0).getAge());
         }
+        assertFalse(dog.isValid());
+        assertEquals(TEST_SIZE - 1, realm.where(Dog.class).count());
     }
 
     private OrderedRealmCollection<Dog> createNonCyclicCollection(Realm realm, ManagedCollection collectionClass) {
@@ -709,6 +723,7 @@ public void deleteFirstFromRealm_emptyCollection() {
     public void deleteLastFromRealm() {
         assertEquals(TEST_SIZE - 1, collection.last().getFieldLong());
         realm.beginTransaction();
+        AllJavaTypes allJavaTypes = collection.last();
         assertTrue(collection.deleteLastFromRealm());
         realm.commitTransaction();
         if (isSnapshot(collectionClass)) {
@@ -718,6 +733,8 @@ public void deleteLastFromRealm() {
             assertEquals(TEST_SIZE - 1, collection.size());
             assertEquals(TEST_SIZE - 2, collection.last().getFieldLong());
         }
+        assertFalse(allJavaTypes.isValid());
+        assertEquals(TEST_SIZE - 1, realm.where(AllJavaTypes.class).count());
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
index 387920dc58..96fc619417 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
@@ -16,8 +16,10 @@
 
 package io.realm;
 
+import org.hamcrest.CoreMatchers;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -671,6 +673,12 @@ public void deleteAllFromRealm() {
         } else {
             assertEquals(0, collection.size());
         }
+        if (isRealmList(collectionClass)) {
+            // The parent object was not deleted
+            assertEquals(1, realm.where(AllJavaTypes.class).count());
+        } else {
+            assertEquals(0, realm.where(AllJavaTypes.class).count());
+        }
     }
 
     @Test(expected = IllegalStateException.class)
@@ -691,11 +699,10 @@ public void deleteAllFromRealm_emptyList() {
     @Test
     public void deleteAllFromRealm_invalidList() {
         realm.close();
-        try {
-            collection.deleteAllFromRealm();
-            fail();
-        } catch (IllegalStateException ignored) {
-        }
+        thrown.expect(IllegalStateException.class);
+        thrown.expectMessage(CoreMatchers.containsString(
+                "This Realm instance has already been closed, making it unusable."));
+        collection.deleteAllFromRealm();
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmListForValueTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmListForValueTests.java
new file mode 100644
index 0000000000..3518becf0a
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmListForValueTests.java
@@ -0,0 +1,1563 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import javax.annotation.Nullable;
+
+import io.realm.entities.NullTypes;
+import io.realm.internal.Table;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static io.realm.ManagedRealmListForValueTests.ListType.BINARY_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.BOOLEAN_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.BYTE_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.DATE_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.DOUBLE_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.FLOAT_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.INTEGER_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.LONG_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.SHORT_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.STRING_LIST;
+import static org.hamcrest.CoreMatchers.is;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+
+/**
+ * Unit tests specific for RealmList with value elements.
+ */
+@RunWith(Parameterized.class)
+public class ManagedRealmListForValueTests extends CollectionTests {
+
+    static final int NON_NULL_TEST_SIZE = 10;
+    static final int NULLABLE_TEST_SIZE = NON_NULL_TEST_SIZE * 2;
+
+    enum ListType {
+        STRING_LIST(String.class.getName()),
+        BOOLEAN_LIST(Boolean.class.getName()),
+        BINARY_LIST(byte[].class.getSimpleName()/* using simple name since array class is a bit special */),
+        LONG_LIST(Long.class.getName()),
+        INTEGER_LIST(Integer.class.getName()),
+        SHORT_LIST(Short.class.getName()),
+        BYTE_LIST(Byte.class.getName()),
+        DOUBLE_LIST(Double.class.getName()),
+        FLOAT_LIST(Float.class.getName()),
+        DATE_LIST(Date.class.getName());
+
+        private final String valueTypeName;
+
+        ListType(String valueTypeName) {
+            this.valueTypeName = valueTypeName;
+        }
+
+        public String getValueTypeName() {
+            return valueTypeName;
+        }
+    }
+
+    @Parameterized.Parameters(name = "{index}: Type: {0}, Nullable?: {1}")
+    public static Collection<Object[]> parameters() {
+        final List<Object[]> paramsList = new ArrayList<>();
+        for (ListType listType : ListType.values()) {
+            paramsList.add(new Object[] {listType, Boolean.TRUE});
+            paramsList.add(new Object[] {listType, Boolean.FALSE});
+        }
+        return paramsList;
+    }
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public ExpectedException thrown = ExpectedException.none();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    @Parameterized.Parameter
+    public ListType listType;
+
+    @Parameterized.Parameter(1)
+    public Boolean isTypeNullable;
+
+    private Realm realm;
+    private NullTypes object;
+    private RealmList list;
+
+    @SuppressWarnings("unchecked")
+    @Before
+    public void setUp() throws Exception {
+        final RealmConfiguration.Builder configurationBuilder = configFactory.createConfigurationBuilder();
+        configurationBuilder.schema(NullTypes.class);
+        RealmConfiguration realmConfig = configurationBuilder.build();
+
+        realm = Realm.getInstance(realmConfig);
+
+        realm.beginTransaction();
+        object = realm.createObject(NullTypes.class, 0);
+        for (ListType type : ListType.values()) {
+            for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+                switch (type) {
+                    case STRING_LIST: {
+                        final RealmList nonnull = object.getFieldStringListNotNull();
+                        nonnull.add(generateValue(STRING_LIST, i));
+                        final RealmList nullable = object.getFieldStringListNull();
+                        nullable.add("" + i);
+                        nullable.add(null);
+                    }
+                    break;
+                    case BOOLEAN_LIST: {
+                        final RealmList nonnull = object.getFieldBooleanListNotNull();
+                        nonnull.add(generateValue(BOOLEAN_LIST, i));
+                        final RealmList nullable = object.getFieldBooleanListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case BINARY_LIST: {
+                        final RealmList nonnull = object.getFieldBinaryListNotNull();
+                        nonnull.add(generateValue(BINARY_LIST, i));
+                        final RealmList nullable = object.getFieldBinaryListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case LONG_LIST: {
+                        final RealmList nonnull = object.getFieldLongListNotNull();
+                        nonnull.add(generateValue(LONG_LIST, i));
+                        final RealmList nullable = object.getFieldLongListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case INTEGER_LIST: {
+                        final RealmList nonnull = object.getFieldIntegerListNotNull();
+                        nonnull.add(generateValue(INTEGER_LIST, i));
+                        final RealmList nullable = object.getFieldIntegerListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case SHORT_LIST: {
+                        final RealmList nonnull = object.getFieldShortListNotNull();
+                        nonnull.add(generateValue(SHORT_LIST, i));
+                        final RealmList nullable = object.getFieldShortListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case BYTE_LIST: {
+                        final RealmList nonnull = object.getFieldByteListNotNull();
+                        nonnull.add(generateValue(BYTE_LIST, i));
+                        final RealmList nullable = object.getFieldByteListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case DOUBLE_LIST: {
+                        final RealmList nonnull = object.getFieldDoubleListNotNull();
+                        nonnull.add(generateValue(DOUBLE_LIST, i));
+                        final RealmList nullable = object.getFieldDoubleListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case FLOAT_LIST: {
+                        final RealmList nonnull = object.getFieldFloatListNotNull();
+                        nonnull.add(generateValue(FLOAT_LIST, i));
+                        final RealmList nullable = object.getFieldFloatListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case DATE_LIST: {
+                        final RealmList nonnull = object.getFieldDateListNotNull();
+                        nonnull.add(generateValue(DATE_LIST, i));
+                        final RealmList nullable = object.getFieldDateListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    default:
+                        throw new AssertionError("unexpected value type: " + listType.name());
+                }
+            }
+        }
+        realm.commitTransaction();
+
+        list = getListFor(object, listType, isTypeNullable);
+    }
+
+    static RealmList<?> getListFor(NullTypes object, ListType listType, boolean nullable) {
+        switch (listType) {
+            case STRING_LIST:
+                return nullable ? object.getFieldStringListNull() : object.getFieldStringListNotNull();
+            case BOOLEAN_LIST:
+                return nullable ? object.getFieldBooleanListNull() : object.getFieldBooleanListNotNull();
+            case BINARY_LIST:
+                return nullable ? object.getFieldBinaryListNull() : object.getFieldBinaryListNotNull();
+            case LONG_LIST:
+                return nullable ? object.getFieldLongListNull() : object.getFieldLongListNotNull();
+            case INTEGER_LIST:
+                return nullable ? object.getFieldIntegerListNull() : object.getFieldIntegerListNotNull();
+            case SHORT_LIST:
+                return nullable ? object.getFieldShortListNull() : object.getFieldShortListNotNull();
+            case BYTE_LIST:
+                return nullable ? object.getFieldByteListNull() : object.getFieldByteListNotNull();
+            case DOUBLE_LIST:
+                return nullable ? object.getFieldDoubleListNull() : object.getFieldDoubleListNotNull();
+            case FLOAT_LIST:
+                return nullable ? object.getFieldFloatListNull() : object.getFieldFloatListNotNull();
+            case DATE_LIST:
+                return nullable ? object.getFieldDateListNull() : object.getFieldDateListNotNull();
+            default:
+                throw new AssertionError("unexpected value type: " + listType.name());
+        }
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    static Object generateValue(ListType listType, int i) {
+        switch (listType) {
+            case STRING_LIST:
+                return "" + i;
+            case BOOLEAN_LIST:
+                return i % 2 == 0 ? Boolean.FALSE : Boolean.TRUE;
+            case BINARY_LIST:
+                return new byte[] {(byte) i};
+            case LONG_LIST:
+                return (long) i;
+            case INTEGER_LIST:
+                return i;
+            case SHORT_LIST:
+                return (short) i;
+            case BYTE_LIST:
+                return (byte) i;
+            case DOUBLE_LIST:
+                return (double) i;
+            case FLOAT_LIST:
+                return (float) i;
+            case DATE_LIST:
+                return new Date(i);
+            default:
+                throw new AssertionError("unexpected value type: " + listType.name());
+        }
+    }
+
+    private static Object generateHugeValue(ListType listType, int size) {
+        final byte[] bytes = new byte[size];
+        switch (listType) {
+            case STRING_LIST:
+                Arrays.fill(bytes, (byte) 'a');
+                return new String(bytes, Charset.forName("US-ASCII"));
+            case BINARY_LIST:
+                return bytes;
+            default:
+                throw new AssertionError("'generateHugeValue' does not support this type: " + listType.name());
+        }
+    }
+
+    private void assertValueEquals(@Nullable Object expected, @Nullable Object actual) {
+        assertValueEquals(null, expected, actual);
+    }
+
+    private void assertValueEquals(@SuppressWarnings("SameParameterValue") @Nullable String message, @Nullable Object expected, @Nullable Object actual) {
+        if (listType == BINARY_LIST) {
+            assertArrayEquals(message, (byte[]) expected, (byte[]) actual);
+        } else {
+            assertEquals(message, expected, actual);
+        }
+    }
+
+    @Test
+    public void readValues() {
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            switch (listType) {
+                case STRING_LIST: {
+                    assertEquals(generateValue(STRING_LIST, i), list.get(isTypeNullable ? (i * 2) : i));
+                }
+                break;
+                case BOOLEAN_LIST: {
+                    assertEquals(generateValue(BOOLEAN_LIST, i), list.get(isTypeNullable ? (i * 2) : i));
+                }
+                break;
+                case BINARY_LIST: {
+                    assertArrayEquals((byte[]) generateValue(BINARY_LIST, i), (byte[]) list.get(isTypeNullable ? (i * 2) : i));
+                }
+                break;
+                case LONG_LIST: {
+                    //noinspection UnnecessaryBoxing
+                    assertEquals(generateValue(LONG_LIST, i), list.get(isTypeNullable ? (i * 2) : i));
+                }
+                break;
+                case INTEGER_LIST: {
+                    //noinspection UnnecessaryBoxing
+                    assertEquals(generateValue(INTEGER_LIST, i), list.get(isTypeNullable ? (i * 2) : i));
+                }
+                break;
+                case SHORT_LIST: {
+                    //noinspection UnnecessaryBoxing
+                    assertEquals(generateValue(SHORT_LIST, i), list.get(isTypeNullable ? (i * 2) : i));
+                }
+                break;
+                case BYTE_LIST: {
+                    //noinspection UnnecessaryBoxing
+                    assertEquals(generateValue(BYTE_LIST, i), list.get(isTypeNullable ? (i * 2) : i));
+                }
+                break;
+                case DOUBLE_LIST: {
+                    //noinspection UnnecessaryBoxing
+                    assertEquals(generateValue(DOUBLE_LIST, i), list.get(isTypeNullable ? (i * 2) : i));
+                }
+                break;
+                case FLOAT_LIST: {
+                    //noinspection UnnecessaryBoxing
+                    assertEquals(generateValue(FLOAT_LIST, i), list.get(isTypeNullable ? (i * 2) : i));
+                }
+                break;
+                case DATE_LIST: {
+                    assertEquals(generateValue(DATE_LIST, i), list.get(isTypeNullable ? (i * 2) : i));
+                }
+                break;
+                default:
+                    throw new AssertionError("unexpected value type: " + listType.name());
+            }
+            if (isTypeNullable) {
+                assertNull(list.get(i * 2 + 1));
+            }
+        }
+    }
+
+    @Test
+    public void isValid() {
+        assertTrue(list.isValid());
+
+        realm.close();
+
+        assertFalse(list.isValid());
+    }
+
+    @Test
+    public void isValid_whenParentRemoved() {
+        realm.beginTransaction();
+        object.deleteFromRealm();
+        realm.commitTransaction();
+
+        // RealmList contained in removed object is invalid.
+        assertFalse(list.isValid());
+    }
+
+    @Test
+    public void add_exceedingSizeLimitValueThrows() {
+        if (listType != STRING_LIST && listType != BINARY_LIST) {
+            return;
+        }
+
+        final int sizeLimit;
+        switch (listType) {
+            case STRING_LIST:
+                sizeLimit = Table.MAX_STRING_SIZE;
+                break;
+            case BINARY_LIST:
+                sizeLimit = Table.MAX_BINARY_SIZE;
+                break;
+            default:
+                throw new AssertionError("Unexpected list type: " + listType.name());
+        }
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                //noinspection unchecked
+                list.add(generateHugeValue(listType, sizeLimit));
+            }
+        });
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final long sizeBeforeException = list.size();
+                thrown.expect(IllegalArgumentException.class);
+                try {
+                    //noinspection unchecked
+                    list.add(generateHugeValue(listType, sizeLimit + 1));
+                } finally {
+                    // FIXME This assertion fails now. Code will be fixed in master branch first.
+                    assertEquals(sizeBeforeException, list.size());
+                }
+            }
+        });
+    }
+
+    @Test
+    public void move_outOfBoundsLowerThrows() {
+        realm.beginTransaction();
+        try {
+            list.move(0, -1);
+            fail("Indexes < 0 should throw an exception");
+        } catch (IndexOutOfBoundsException ignored) {
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void move_outOfBoundsHigherThrows() {
+        realm.beginTransaction();
+        try {
+            list.move(list.size() - 1, list.size());
+            fail("Indexes >= size() should throw an exception");
+        } catch (IndexOutOfBoundsException ignored) {
+            ignored.printStackTrace();
+        } finally {
+            realm.cancelTransaction();
+        }
+    }
+
+    @Test
+    public void clear_then_add() {
+        realm.beginTransaction();
+        list.clear();
+
+        assertTrue(list.isEmpty());
+
+        //noinspection unchecked
+        list.add(generateValue(listType, -100));
+
+        realm.commitTransaction();
+
+        assertEquals(1, list.size());
+    }
+
+    @Test
+    public void size() {
+        assertEquals(isTypeNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE, list.size());
+    }
+
+    @Test
+    public void remove_nonNullByIndex() {
+        final int targetIndex = 6;
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final Object removed = list.remove(targetIndex);
+                final int dataIndex = isTypeNullable ? targetIndex / 2 : targetIndex;
+                assertValueEquals(generateValue(listType, dataIndex), removed);
+            }
+        });
+
+        assertEquals(isTypeNullable ? (NULLABLE_TEST_SIZE - 1) : (NON_NULL_TEST_SIZE - 1), list.size());
+        for (int i = 0; i < list.size(); i++) {
+            final int originalIndex = i < targetIndex ? i : i + 1;
+            if (isTypeNullable) {
+                if (originalIndex % 2 == 1) {
+                    assertNull(list.get(i));
+                } else {
+                    assertValueEquals(generateValue(listType, originalIndex / 2), list.get(i));
+                }
+            } else {
+                assertValueEquals(generateValue(listType, originalIndex), list.get(i));
+            }
+        }
+    }
+
+    @Test
+    public void remove_nullByIndex() {
+        if (!isTypeNullable) {
+            return;
+        }
+
+        final int targetIndex = 7;
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                assertNull(list.remove(targetIndex));
+                assertEquals(NULLABLE_TEST_SIZE - 1, list.size());
+            }
+        });
+
+        for (int i = 0; i < list.size(); i++) {
+            final int originalIndex = i < targetIndex ? i : i + 1;
+            if (originalIndex % 2 == 1) {
+                assertNull(list.get(i));
+            } else {
+                assertValueEquals(generateValue(listType, originalIndex / 2), list.get(i));
+            }
+        }
+    }
+
+    @Test
+    public void remove_first() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final Object removed = list.remove(0);
+                assertValueEquals(generateValue(listType, 0), removed);
+            }
+        });
+
+        assertEquals((isTypeNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE) - 1, list.size());
+    }
+
+    @Test
+    public void remove_last() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                final Object removed = list.remove((isTypeNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE) - 1);
+                if (isTypeNullable) {
+                    assertNull(removed);
+                } else {
+                    assertValueEquals(generateValue(listType, NON_NULL_TEST_SIZE - 1), removed);
+                }
+            }
+        });
+
+        assertEquals((isTypeNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE) - 1, list.size());
+    }
+
+    @Test
+    public void remove_fromEmptyListThrows() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                list.clear();
+                thrown.expect(IndexOutOfBoundsException.class);
+                list.remove(0);
+            }
+        });
+    }
+
+    @Test
+    public void remove_byObject() {
+        final Object value = list.get(0);
+        final int initialSize = list.size();
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                if (listType == BINARY_LIST) {
+                    assertFalse(list.remove(value));  // since 'equals()' never return true against binary array.
+                } else {
+                    assertTrue(list.remove(value));
+                }
+            }
+        });
+
+        assertEquals((listType == BINARY_LIST) ? initialSize : (initialSize - 1), list.size());
+    }
+
+    @Test
+    public void remove_byNull() {
+        final int initialSize = list.size();
+
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                if (isTypeNullable) {
+                    assertTrue(list.remove(null));
+                } else {
+                    assertFalse(list.remove(null));
+                }
+            }
+        });
+
+        assertEquals(isTypeNullable ? (initialSize - 1) : initialSize, list.size());
+    }
+
+    @Test
+    public void deleteFirst() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                assertTrue(list.deleteFirstFromRealm());
+            }
+        });
+
+        assertEquals(isTypeNullable ? (NULLABLE_TEST_SIZE - 1) : (NON_NULL_TEST_SIZE - 1), list.size());
+        for (int i = 0; i < list.size(); i++) {
+            final int originalIndex = i + 1;
+            if (isTypeNullable) {
+                if (originalIndex % 2 == 1) {
+                    assertNull(list.get(i));
+                } else {
+                    assertValueEquals(generateValue(listType, originalIndex / 2), list.get(i));
+                }
+            } else {
+                assertValueEquals(generateValue(listType, originalIndex), list.get(i));
+            }
+        }
+    }
+
+    @Test
+    public void deleteLast() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                assertTrue(list.deleteLastFromRealm());
+            }
+        });
+
+        assertEquals(isTypeNullable ? (NULLABLE_TEST_SIZE - 1) : (NON_NULL_TEST_SIZE - 1), list.size());
+        for (int i = 0; i < list.size(); i++) {
+            if (isTypeNullable) {
+                if (i % 2 == 1) {
+                    assertNull(list.get(i));
+                } else {
+                    assertValueEquals(generateValue(listType, i / 2), list.get(i));
+                }
+            } else {
+                assertValueEquals(generateValue(listType, i), list.get(i));
+            }
+        }
+    }
+
+    @Test
+    public void addAt_afterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        //noinspection unchecked
+        list.add(generateValue(listType, 100));
+    }
+
+    @Test
+    public void addAt_invalidIndex() {
+        final int initialSize = list.size();
+        try {
+            realm.beginTransaction();
+            //noinspection unchecked
+            list.add(initialSize + 1, generateValue(listType, 1000));
+            fail();
+        } catch (IndexOutOfBoundsException e) {
+            // make sure that the size is not changed
+            assertEquals(initialSize, list.size());
+        }
+    }
+
+    @Test
+    public void set_afterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        //noinspection unchecked
+        list.set(0, generateValue(listType, 100));
+    }
+
+    @Test
+    public void set_invalidIndex() {
+        final int initialSize = list.size();
+        try {
+            realm.beginTransaction();
+            //noinspection unchecked
+            list.set(initialSize, generateValue(listType, 1000));
+            fail();
+        } catch (IndexOutOfBoundsException e) {
+            // make sure that the size is not changed
+            assertEquals(initialSize, list.size());
+        }
+    }
+
+    @Test
+    public void move_afterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        list.move(0, 1);
+    }
+
+    @Test
+    public void clear_afterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        list.clear();
+    }
+
+    @Test
+    public void remove_atAfterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        list.remove(0);
+    }
+
+    @Test
+    public void remove_objectAfterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        list.remove(generateValue(listType, 4));
+    }
+
+    @Test
+    public void remove_unsupportedTypeIgnored() {
+        final int initialSize = list.size();
+
+        final List<Object> unsupportedValues = Arrays.<Object>asList(
+                new int[] {0},
+                new StringBuilder("0")
+        );
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                for (Object unsupportedValue : unsupportedValues) {
+                    //noinspection UseBulkOperation
+                    assertFalse(list.remove(unsupportedValue));
+                }
+            }
+        });
+
+        assertEquals(initialSize, list.size());
+    }
+
+    @Test
+    public void removeAll() {
+        final List<Object> toBeRemoved = Arrays.asList(
+                null,
+                generateValue(listType, 2),
+                generateValue(listType, 4));
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                if (!isTypeNullable && listType == BINARY_LIST) {
+                    //noinspection unchecked
+                    assertFalse(list.removeAll(toBeRemoved)); // since 'equals()' never return true against binary array.
+                } else {
+                    //noinspection unchecked
+                    assertTrue(list.removeAll(toBeRemoved));
+                }
+            }
+        });
+
+        switch (listType) {
+            case BINARY_LIST:
+                assertEquals(NON_NULL_TEST_SIZE, list.size());
+                break;
+            case BOOLEAN_LIST:
+                assertEquals(NON_NULL_TEST_SIZE / 2, list.size());
+                break;
+            default:
+                assertEquals(NON_NULL_TEST_SIZE - 2, list.size());
+                break;
+        }
+    }
+
+    @Test
+    public void removeAll_unsupportedTypeIgnored() {
+        final int initialSize = list.size();
+
+        final List<Object> unsupportedValues = Arrays.<Object>asList(
+                new int[] {0},
+                new StringBuilder("0")
+        );
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                //noinspection unchecked
+                assertFalse(list.removeAll(unsupportedValues));
+            }
+        });
+
+        assertEquals(initialSize, list.size());
+    }
+
+    @Test
+    public void removeAll_afterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        //noinspection unchecked
+        list.removeAll(Collections.emptyList());
+    }
+
+    @Test
+    public void get_afterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        list.get(0);
+    }
+
+    @Test
+    public void first_afterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        list.first();
+    }
+
+    @Test
+    public void last_afterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        list.last();
+    }
+
+    @Test
+    public void size_afterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+
+        thrown.expect(IllegalStateException.class);
+        list.size();
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void where() {
+        list.where();
+    }
+
+    @Test
+    public void toString_() {
+        final StringBuilder sb = new StringBuilder("RealmList<").append(listType.getValueTypeName()).append(">@[");
+        final String separator = ",";
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            final Object value = generateValue(listType, i);
+
+            if (value instanceof byte[]) {
+                sb.append("byte[").append(((byte[]) value).length).append("]");
+            } else {
+                sb.append(value);
+            }
+            sb.append(separator);
+            if (isTypeNullable) {
+                sb.append("null").append(separator);
+            }
+        }
+        sb.setLength(sb.length() - separator.length());
+        sb.append("]");
+
+        assertEquals(sb.toString(), list.toString());
+    }
+
+    @Test
+    public void toString_AfterContainerObjectRemoved() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object.deleteFromRealm();
+            }
+        });
+        assertEquals("RealmList<" + listType.getValueTypeName() + ">@[invalid]", list.toString());
+    }
+
+    @Test
+    public void deleteAllFromRealm() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                list.deleteAllFromRealm();
+            }
+        });
+
+        assertEquals(0, list.size());
+    }
+
+    @Test
+    public void deleteAllFromRealm_outsideTransaction() {
+        try {
+            list.deleteAllFromRealm();
+            fail();
+        } catch (IllegalStateException e) {
+            assertTrue(e.getMessage().contains("Cannot modify managed objects outside of a write transaction"));
+        }
+    }
+
+    @Test
+    public void deleteAllFromRealm_emptyList() {
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                list.deleteAllFromRealm();
+            }
+        });
+        assertEquals(0, list.size());
+
+        // The dogs is empty now.
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                list.deleteAllFromRealm();
+            }
+        });
+        assertEquals(0, list.size());
+    }
+
+    @Test
+    public void deleteAllFromRealm_invalidListShouldThrow() {
+        realm.close();
+        realm = null;
+
+        thrown.expect(IllegalStateException.class);
+        thrown.expectMessage(is("This Realm instance has already been closed, making it unusable."));
+        list.deleteAllFromRealm();
+    }
+
+    @Test
+    public void add_null_nonNullableListThrows() {
+        if (isTypeNullable) {
+            return;
+        }
+
+        realm.beginTransaction();
+        final int initialSize = list.size();
+        try {
+            thrown.expect(IllegalArgumentException.class);
+            //noinspection unchecked
+            list.add(null);
+        } finally {
+            assertEquals(initialSize, list.size());
+        }
+    }
+
+    @Test
+    public void addAt_null_nonNullableListThrows() {
+        if (isTypeNullable) {
+            return;
+        }
+
+        realm.beginTransaction();
+        final int initialSize = list.size();
+        try {
+            thrown.expect(IllegalArgumentException.class);
+            //noinspection unchecked
+            list.add(1, null);
+        } finally {
+            assertEquals(initialSize, list.size());
+        }
+    }
+
+    @Test
+    public void set_null_nonNullableListThrows() {
+        if (isTypeNullable) {
+            return;
+        }
+
+        realm.beginTransaction();
+        final int initialSize = list.size();
+        try {
+            thrown.expect(IllegalArgumentException.class);
+            //noinspection unchecked
+            list.set(0, null);
+        } finally {
+            assertEquals(initialSize, list.size());
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changeListener_forAddObject() {
+        Realm realm = looperThread.getRealm();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object = realm.createObject(NullTypes.class, 1000);
+                list = getListFor(object, listType, isTypeNullable);
+
+                // add 3 elements as an initial data
+                //noinspection unchecked
+                list.add(generateValue(listType, 0));
+                //noinspection unchecked
+                list.add(generateValue(listType, 100));
+                //noinspection unchecked
+                list.add(generateValue(listType, 200));
+            }
+        });
+
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        //noinspection unchecked
+        list.addChangeListener(new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                assertEquals(0, listenerCalledCount.getAndIncrement());
+            }
+        });
+        //noinspection unchecked
+        list.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> collection, @Nullable OrderedCollectionChangeSet changes) {
+                assertNotNull(changes);
+                assertEquals(1, changes.getInsertions().length);
+                assertEquals(0, changes.getDeletions().length);
+                assertEquals(0, changes.getChanges().length);
+                assertEquals(3, changes.getInsertions()[0]);
+                assertEquals(1, listenerCalledCount.getAndIncrement());
+            }
+        });
+
+        realm.beginTransaction();
+        //noinspection unchecked
+        list.add(generateValue(listType, 100));
+        realm.commitTransaction();
+
+        assertEquals(2, listenerCalledCount.get());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changeListener_forAddAt() {
+        Realm realm = looperThread.getRealm();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object = realm.createObject(NullTypes.class, 1000);
+                list = getListFor(object, listType, isTypeNullable);
+
+                // add 3 elements as an initial data
+                //noinspection unchecked
+                list.add(generateValue(listType, 0));
+                //noinspection unchecked
+                list.add(generateValue(listType, 100));
+                //noinspection unchecked
+                list.add(generateValue(listType, 200));
+            }
+        });
+
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        //noinspection unchecked
+        list.addChangeListener(new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                assertEquals(0, listenerCalledCount.getAndIncrement());
+            }
+        });
+        //noinspection unchecked
+        list.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> collection, @Nullable OrderedCollectionChangeSet changes) {
+                assertNotNull(changes);
+                assertEquals(1, changes.getInsertions().length);
+                assertEquals(0, changes.getDeletions().length);
+                assertEquals(0, changes.getChanges().length);
+                assertEquals(1, changes.getInsertions()[0]);
+                assertEquals(1, listenerCalledCount.getAndIncrement());
+            }
+        });
+
+        realm.beginTransaction();
+        //noinspection unchecked
+        list.add(1, generateValue(listType, 500));
+        realm.commitTransaction();
+
+        assertEquals(2, listenerCalledCount.get());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changeListener_forSet() {
+        Realm realm = looperThread.getRealm();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object = realm.createObject(NullTypes.class, 1000);
+                list = getListFor(object, listType, isTypeNullable);
+
+                // add 3 elements as an initial data
+                //noinspection unchecked
+                list.add(generateValue(listType, 0));
+                //noinspection unchecked
+                list.add(generateValue(listType, 100));
+                //noinspection unchecked
+                list.add(generateValue(listType, 200));
+            }
+        });
+
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        //noinspection unchecked
+        list.addChangeListener(new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                assertEquals(0, listenerCalledCount.getAndIncrement());
+            }
+        });
+        //noinspection unchecked
+        list.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> collection, @Nullable OrderedCollectionChangeSet changes) {
+                assertNotNull(changes);
+                assertEquals(0, changes.getInsertions().length);
+                assertEquals(0, changes.getDeletions().length);
+                assertEquals(1, changes.getChanges().length);
+                assertEquals(1, changes.getChanges()[0]);
+                assertEquals(1, listenerCalledCount.getAndIncrement());
+            }
+        });
+
+        realm.beginTransaction();
+        //noinspection unchecked
+        list.set(1, generateValue(listType, 500));
+        realm.commitTransaction();
+
+        assertEquals(2, listenerCalledCount.get());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changeListener_forRemoveAt() {
+        Realm realm = looperThread.getRealm();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object = realm.createObject(NullTypes.class, 1000);
+                list = getListFor(object, listType, isTypeNullable);
+
+                // add 3 elements as an initial data
+                //noinspection unchecked
+                list.add(generateValue(listType, 0));
+                //noinspection unchecked
+                list.add(generateValue(listType, 100));
+                //noinspection unchecked
+                list.add(generateValue(listType, 200));
+            }
+        });
+
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        //noinspection unchecked
+        list.addChangeListener(new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                assertEquals(0, listenerCalledCount.getAndIncrement());
+            }
+        });
+        //noinspection unchecked
+        list.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> collection, @Nullable OrderedCollectionChangeSet changes) {
+                assertNotNull(changes);
+                assertEquals(0, changes.getInsertions().length);
+                assertEquals(1, changes.getDeletions().length);
+                assertEquals(0, changes.getChanges().length);
+                assertEquals(1, changes.getDeletions()[0]);
+                assertEquals(1, listenerCalledCount.getAndIncrement());
+            }
+        });
+
+        realm.beginTransaction();
+        //noinspection unchecked
+        if (listType == BINARY_LIST) {
+            assertArrayEquals((byte[]) generateValue(listType, 100), (byte[]) list.remove(1));
+        } else {
+            assertEquals(generateValue(listType, 100), list.remove(1));
+        }
+        realm.commitTransaction();
+
+        assertEquals(2, listenerCalledCount.get());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changeListener_forRemoveObject() {
+        if (listType == BINARY_LIST) {
+            // 'removeAll()' never remove byte array element since 'equals()' never return true against byte array.
+            looperThread.testComplete();
+            return;
+        }
+
+        Realm realm = looperThread.getRealm();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object = realm.createObject(NullTypes.class, 1000);
+                list = getListFor(object, listType, isTypeNullable);
+
+                // add 3 elements as an initial data
+                //noinspection unchecked
+                list.add(generateValue(listType, 0));
+                //noinspection unchecked
+                list.add(generateValue(listType, 101));
+                //noinspection unchecked
+                list.add(generateValue(listType, 200));
+            }
+        });
+
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        //noinspection unchecked
+        list.addChangeListener(new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                assertEquals(0, listenerCalledCount.getAndIncrement());
+            }
+        });
+        //noinspection unchecked
+        list.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> collection, @Nullable OrderedCollectionChangeSet changes) {
+                assertNotNull(changes);
+                assertEquals(0, changes.getInsertions().length);
+                assertEquals(1, changes.getDeletions().length);
+                assertEquals(0, changes.getChanges().length);
+                assertEquals(1, changes.getDeletions()[0]);
+                assertEquals(1, listenerCalledCount.getAndIncrement());
+            }
+        });
+
+        realm.beginTransaction();
+        //noinspection unchecked
+        assertTrue(list.remove(generateValue(listType, 101)));
+        realm.commitTransaction();
+
+        assertEquals(2, listenerCalledCount.get());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changeListener_forRemoveAll() {
+        if (listType == BINARY_LIST) {
+            // 'removeAll()' never remove byte array element since 'equals()' never return true against byte array.
+            looperThread.testComplete();
+            return;
+        }
+
+        Realm realm = looperThread.getRealm();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object = realm.createObject(NullTypes.class, 1000);
+                list = getListFor(object, listType, isTypeNullable);
+
+                // add 3 elements as an initial data
+                //noinspection unchecked
+                list.add(generateValue(listType, 0));
+                //noinspection unchecked
+                list.add(generateValue(listType, 100));
+                //noinspection unchecked
+                list.add(generateValue(listType, 200));
+            }
+        });
+
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        //noinspection unchecked
+        list.addChangeListener(new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                assertEquals(0, listenerCalledCount.getAndIncrement());
+            }
+        });
+        //noinspection unchecked
+        list.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> collection, @Nullable OrderedCollectionChangeSet changes) {
+                assertNotNull(changes);
+                assertEquals(0, changes.getInsertions().length);
+                assertEquals(listType == BOOLEAN_LIST ? 3 : 2, changes.getDeletions().length);
+                assertEquals(0, changes.getChanges().length);
+                assertEquals(1, changes.getDeletionRanges().length);
+                assertEquals(listType == BOOLEAN_LIST ? 0 : 1, changes.getDeletionRanges()[0].startIndex);
+                assertEquals(listType == BOOLEAN_LIST ? 3 : 2, changes.getDeletionRanges()[0].length);
+                assertEquals(1, listenerCalledCount.getAndIncrement());
+            }
+        });
+
+        realm.beginTransaction();
+        //noinspection unchecked
+
+        final boolean removed = list.removeAll(Arrays.asList(generateValue(listType, 100), generateValue(listType, 200), generateValue(listType, 300)));
+        assertTrue(removed);
+        realm.commitTransaction();
+
+        assertEquals(2, listenerCalledCount.get());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changeListener_forDeleteAt() {
+        Realm realm = looperThread.getRealm();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object = realm.createObject(NullTypes.class, 1000);
+                list = getListFor(object, listType, isTypeNullable);
+
+                // add 3 elements as an initial data
+                //noinspection unchecked
+                list.add(generateValue(listType, 0));
+                //noinspection unchecked
+                list.add(generateValue(listType, 100));
+                //noinspection unchecked
+                list.add(generateValue(listType, 200));
+            }
+        });
+
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        //noinspection unchecked
+        list.addChangeListener(new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                assertEquals(0, listenerCalledCount.getAndIncrement());
+            }
+        });
+        //noinspection unchecked
+        list.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> collection, @Nullable OrderedCollectionChangeSet changes) {
+                assertNotNull(changes);
+                assertEquals(0, changes.getInsertions().length);
+                assertEquals(1, changes.getDeletions().length);
+                assertEquals(0, changes.getChanges().length);
+                assertEquals(1, changes.getDeletions()[0]);
+                assertEquals(1, listenerCalledCount.getAndIncrement());
+            }
+        });
+
+        realm.beginTransaction();
+        //noinspection unchecked
+        list.deleteFromRealm(1);
+        realm.commitTransaction();
+
+        assertEquals(2, listenerCalledCount.get());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changeListener_forDeleteAll() {
+        Realm realm = looperThread.getRealm();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object = realm.createObject(NullTypes.class, 1000);
+                list = getListFor(object, listType, isTypeNullable);
+
+                // add 3 elements as an initial data
+                //noinspection unchecked
+                list.add(generateValue(listType, 0));
+                //noinspection unchecked
+                list.add(generateValue(listType, 100));
+                //noinspection unchecked
+                list.add(generateValue(listType, 200));
+            }
+        });
+
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        //noinspection unchecked
+        list.addChangeListener(new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                assertEquals(0, listenerCalledCount.getAndIncrement());
+            }
+        });
+        //noinspection unchecked
+        list.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> collection, @Nullable OrderedCollectionChangeSet changes) {
+                assertNotNull(changes);
+                assertEquals(0, changes.getInsertions().length);
+                assertEquals(3, changes.getDeletions().length);
+                assertEquals(0, changes.getChanges().length);
+                assertEquals(1, changes.getDeletionRanges().length);
+                assertEquals(0, changes.getDeletionRanges()[0].startIndex);
+                assertEquals(3, changes.getDeletionRanges()[0].length);
+                assertEquals(1, listenerCalledCount.getAndIncrement());
+            }
+        });
+
+        realm.beginTransaction();
+        //noinspection unchecked
+        list.deleteAllFromRealm();
+        realm.commitTransaction();
+
+        assertEquals(2, listenerCalledCount.get());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void removeAllChangeListeners() {
+        Realm realm = looperThread.getRealm();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object = realm.createObject(NullTypes.class, 1000);
+                list = getListFor(object, listType, isTypeNullable);
+            }
+        });
+
+        //noinspection unchecked
+        list.addChangeListener(new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                fail();
+            }
+        });
+        //noinspection unchecked
+        list.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> collection, @Nullable OrderedCollectionChangeSet changes) {
+                fail();
+            }
+        });
+
+        list.removeAllChangeListeners();
+
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        // This one is added after removal, so it should be triggered.
+        //noinspection unchecked
+        list.addChangeListener(new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                listenerCalledCount.incrementAndGet();
+                looperThread.testComplete();
+            }
+        });
+
+        // This should trigger the listener if there is any.
+        realm.beginTransaction();
+        //noinspection unchecked
+        list.add(generateValue(listType, 500));
+        realm.commitTransaction();
+
+        assertEquals(1, listenerCalledCount.get());
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    @RunTestInLooperThread
+    public void removeChangeListener() {
+        Realm realm = looperThread.getRealm();
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                object = realm.createObject(NullTypes.class, 1000);
+                list = getListFor(object, listType, isTypeNullable);
+            }
+        });
+
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        RealmChangeListener<RealmList<Object>> listener1 = new RealmChangeListener<RealmList<Object>>() {
+            @Override
+            public void onChange(RealmList<Object> element) {
+                fail();
+            }
+        };
+        OrderedRealmCollectionChangeListener<RealmList<Object>> listener2 =
+                new OrderedRealmCollectionChangeListener<RealmList<Object>>() {
+                    @Override
+                    public void onChange(RealmList<Object> collection, @Nullable OrderedCollectionChangeSet changes) {
+                        assertEquals(0, listenerCalledCount.getAndIncrement());
+                        looperThread.testComplete();
+                    }
+                };
+
+        list.addChangeListener(listener1);
+        list.addChangeListener(listener2);
+
+        list.removeChangeListener(listener1);
+
+        // This should trigger the listener if there is any.
+        realm.beginTransaction();
+        list.add(generateValue(listType, 500));
+        realm.commitTransaction();
+        assertEquals(1, listenerCalledCount.get());
+    }
+
+    @Test
+    public void createSnapshot() {
+        thrown.expect(UnsupportedOperationException.class);
+        thrown.expectMessage(is(RealmList.ALLOWED_ONLY_FOR_REALM_MODEL_ELEMENT_MESSAGE));
+        list.createSnapshot();
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmListForValue_toArrayTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmListForValue_toArrayTests.java
new file mode 100644
index 0000000000..1d7dc8b403
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmListForValue_toArrayTests.java
@@ -0,0 +1,467 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Date;
+import java.util.List;
+
+import io.realm.ManagedRealmListForValueTests.ListType;
+import io.realm.entities.NullTypes;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static io.realm.ManagedRealmListForValueTests.ListType.BINARY_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.BOOLEAN_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.BYTE_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.DATE_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.DOUBLE_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.FLOAT_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.INTEGER_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.LONG_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.SHORT_LIST;
+import static io.realm.ManagedRealmListForValueTests.ListType.STRING_LIST;
+import static io.realm.ManagedRealmListForValueTests.NON_NULL_TEST_SIZE;
+import static io.realm.ManagedRealmListForValueTests.NULLABLE_TEST_SIZE;
+import static io.realm.ManagedRealmListForValueTests.generateValue;
+import static io.realm.ManagedRealmListForValueTests.getListFor;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+
+/**
+ * Unit tests specific for RealmList with value elements.
+ */
+@RunWith(Parameterized.class)
+public class ManagedRealmListForValue_toArrayTests extends CollectionTests {
+
+    @Parameterized.Parameters(name = "{index}: Type: {0}, Nullable?: {1}")
+    public static Collection<Object[]> parameters() {
+        final List<Object[]> paramsList = new ArrayList<>();
+        for (ListType listType : ListType.values()) {
+            paramsList.add(new Object[] {listType, Boolean.TRUE});
+            paramsList.add(new Object[] {listType, Boolean.FALSE});
+        }
+        return paramsList;
+    }
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public ExpectedException thrown = ExpectedException.none();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    @Parameterized.Parameter
+    public ListType listType;
+
+    @Parameterized.Parameter(1)
+    public Boolean typeIsNullable;
+
+    private Realm realm;
+    private RealmList list;
+
+    @SuppressWarnings("unchecked")
+    @Before
+    public void setUp() throws Exception {
+        final RealmConfiguration.Builder configurationBuilder = configFactory.createConfigurationBuilder();
+        configurationBuilder.schema(NullTypes.class);
+        RealmConfiguration realmConfig = configurationBuilder.build();
+
+        realm = Realm.getInstance(realmConfig);
+
+        realm.beginTransaction();
+        final NullTypes object = realm.createObject(NullTypes.class, 0);
+        for (ListType type : ListType.values()) {
+            for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+                switch (type) {
+                    case STRING_LIST: {
+                        final RealmList nonnull = object.getFieldStringListNotNull();
+                        nonnull.add(generateValue(STRING_LIST, i));
+                        final RealmList nullable = object.getFieldStringListNull();
+                        nullable.add("" + i);
+                        nullable.add(null);
+                    }
+                    break;
+                    case BOOLEAN_LIST: {
+                        final RealmList nonnull = object.getFieldBooleanListNotNull();
+                        nonnull.add(generateValue(BOOLEAN_LIST, i));
+                        final RealmList nullable = object.getFieldBooleanListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case BINARY_LIST: {
+                        final RealmList nonnull = object.getFieldBinaryListNotNull();
+                        nonnull.add(generateValue(BINARY_LIST, i));
+                        final RealmList nullable = object.getFieldBinaryListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case LONG_LIST: {
+                        final RealmList nonnull = object.getFieldLongListNotNull();
+                        nonnull.add(generateValue(LONG_LIST, i));
+                        final RealmList nullable = object.getFieldLongListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case INTEGER_LIST: {
+                        final RealmList nonnull = object.getFieldIntegerListNotNull();
+                        nonnull.add(generateValue(INTEGER_LIST, i));
+                        final RealmList nullable = object.getFieldIntegerListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case SHORT_LIST: {
+                        final RealmList nonnull = object.getFieldShortListNotNull();
+                        nonnull.add(generateValue(SHORT_LIST, i));
+                        final RealmList nullable = object.getFieldShortListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case BYTE_LIST: {
+                        final RealmList nonnull = object.getFieldByteListNotNull();
+                        nonnull.add(generateValue(BYTE_LIST, i));
+                        final RealmList nullable = object.getFieldByteListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case DOUBLE_LIST: {
+                        final RealmList nonnull = object.getFieldDoubleListNotNull();
+                        nonnull.add(generateValue(DOUBLE_LIST, i));
+                        final RealmList nullable = object.getFieldDoubleListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case FLOAT_LIST: {
+                        final RealmList nonnull = object.getFieldFloatListNotNull();
+                        nonnull.add(generateValue(FLOAT_LIST, i));
+                        final RealmList nullable = object.getFieldFloatListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    case DATE_LIST: {
+                        final RealmList nonnull = object.getFieldDateListNotNull();
+                        nonnull.add(generateValue(DATE_LIST, i));
+                        final RealmList nullable = object.getFieldDateListNull();
+                        nullable.add(nonnull.last());
+                        nullable.add(null);
+                    }
+                    break;
+                    default:
+                        throw new AssertionError("unexpected value type: " + listType.name());
+                }
+            }
+        }
+        realm.commitTransaction();
+
+        list = getListFor(object, listType, typeIsNullable);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void toArray() {
+        final Object[] expected = new Object[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = generateValue(listType, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = generateValue(listType, i);
+            }
+        }
+
+        if (listType != BINARY_LIST) {
+            assertArrayEquals(expected, list.toArray());
+        } else {
+            final Object[] array = list.toArray();
+            assertEquals(expected.length, array.length);
+            for (int i = 0; i < expected.length; i++) {
+                if (expected[i] == null) {
+                    assertNull(array[i]);
+                } else {
+                    assertTrue(array[i] instanceof byte[]);
+                    assertArrayEquals((byte[]) expected[i], (byte[]) array[i]);
+                }
+            }
+        }
+    }
+
+    @Test
+    public void toArray_withStringArray() {
+        if (listType != STRING_LIST) {
+            thrown.expect(ArrayStoreException.class);
+            list.toArray(new String[0]);
+            // should not reach here
+            return;
+        }
+
+        final String[] expected = new String[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = (String) generateValue(STRING_LIST, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = (String) generateValue(STRING_LIST, i);
+            }
+        }
+        final Object[] returnedArray = list.toArray(new String[0]);
+        assertEquals(String.class, returnedArray.getClass().getComponentType());
+        assertArrayEquals(expected, returnedArray);
+    }
+
+    @Test
+    public void toArray_withBooleanArray() {
+        if (listType != BOOLEAN_LIST) {
+            thrown.expect(ArrayStoreException.class);
+            list.toArray(new Boolean[0]);
+            // should not reach here
+            return;
+        }
+
+        final Boolean[] expected = new Boolean[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = (Boolean) generateValue(BOOLEAN_LIST, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = (Boolean) generateValue(BOOLEAN_LIST, i);
+            }
+        }
+
+        final Object[] returnedArray = list.toArray(new Boolean[0]);
+        assertEquals(Boolean.class, returnedArray.getClass().getComponentType());
+        assertArrayEquals(expected, returnedArray);
+    }
+
+    @Test
+    public void toArray_withBinaryArray() {
+        if (listType != BINARY_LIST) {
+            thrown.expect(ArrayStoreException.class);
+            list.toArray(new byte[0][]);
+            // should not reach here
+            return;
+        }
+
+        final byte[][] expected = new byte[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE][];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = (byte[]) generateValue(BINARY_LIST, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = (byte[]) generateValue(BINARY_LIST, i);
+            }
+        }
+        final Object[] returnedArray = list.toArray(new byte[0][]);
+        assertEquals(byte[].class, returnedArray.getClass().getComponentType());
+
+        assertEquals(expected.length, returnedArray.length);
+        for (int i = 0; i < expected.length; i++) {
+            if (expected[i] == null) {
+                assertNull(returnedArray[i]);
+            } else {
+                assertTrue(returnedArray[i] instanceof byte[]);
+                assertArrayEquals(expected[i], (byte[]) returnedArray[i]);
+            }
+        }
+    }
+
+    @Test
+    public void toArray_withLongArray() {
+        if (listType != LONG_LIST) {
+            thrown.expect(ArrayStoreException.class);
+            list.toArray(new Long[0]);
+            // should not reach here
+            return;
+        }
+
+        final Long[] expected = new Long[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = (Long) generateValue(LONG_LIST, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = (Long) generateValue(LONG_LIST, i);
+            }
+        }
+        final Object[] returnedArray = list.toArray(new Long[0]);
+        assertEquals(Long.class, returnedArray.getClass().getComponentType());
+        assertArrayEquals(expected, returnedArray);
+    }
+
+    @Test
+    public void toArray_withIntegerArray() {
+        if (listType != INTEGER_LIST) {
+            thrown.expect(ArrayStoreException.class);
+            list.toArray(new Integer[0]);
+            // should not reach here
+            return;
+        }
+
+        final Integer[] expected = new Integer[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = (Integer) generateValue(INTEGER_LIST, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = (Integer) generateValue(INTEGER_LIST, i);
+            }
+        }
+        final Object[] returnedArray = list.toArray(new Integer[0]);
+        assertEquals(Integer.class, returnedArray.getClass().getComponentType());
+        assertArrayEquals(expected, returnedArray);
+    }
+
+    @Test
+    public void toArray_withShortArray() {
+        if (listType != SHORT_LIST) {
+            thrown.expect(ArrayStoreException.class);
+            list.toArray(new Short[0]);
+            // should not reach here
+            return;
+        }
+
+        final Short[] expected = new Short[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = (Short) generateValue(SHORT_LIST, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = (Short) generateValue(SHORT_LIST, i);
+            }
+        }
+        final Object[] returnedArray = list.toArray(new Short[0]);
+        assertEquals(Short.class, returnedArray.getClass().getComponentType());
+        assertArrayEquals(expected, returnedArray);
+    }
+
+    @Test
+    public void toArray_withByteArray() {
+        if (listType != BYTE_LIST) {
+            thrown.expect(ArrayStoreException.class);
+            list.toArray(new Byte[0]);
+            // should not reach here
+            return;
+        }
+
+        final Byte[] expected = new Byte[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = (Byte) generateValue(BYTE_LIST, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = (Byte) generateValue(BYTE_LIST, i);
+            }
+        }
+        final Object[] returnedArray = list.toArray(new Byte[0]);
+        assertEquals(Byte.class, returnedArray.getClass().getComponentType());
+        assertArrayEquals(expected, returnedArray);
+    }
+
+    @Test
+    public void toArray_withDoubleArray() {
+        if (listType != DOUBLE_LIST) {
+            thrown.expect(ArrayStoreException.class);
+            list.toArray(new Double[0]);
+            // should not reach here
+            return;
+        }
+
+        final Double[] expected = new Double[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = (Double) generateValue(DOUBLE_LIST, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = (Double) generateValue(DOUBLE_LIST, i);
+            }
+        }
+        final Object[] returnedArray = list.toArray(new Double[0]);
+        assertEquals(Double.class, returnedArray.getClass().getComponentType());
+        assertArrayEquals(expected, returnedArray);
+    }
+
+    @Test
+    public void toArray_withFloatArray() {
+        if (listType != FLOAT_LIST) {
+            thrown.expect(ArrayStoreException.class);
+            list.toArray(new Float[0]);
+            // should not reach here
+            return;
+        }
+
+        final Float[] expected = new Float[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = (Float) generateValue(FLOAT_LIST, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = (Float) generateValue(FLOAT_LIST, i);
+            }
+        }
+        final Object[] returnedArray = list.toArray(new Float[0]);
+        assertEquals(Float.class, returnedArray.getClass().getComponentType());
+        assertArrayEquals(expected, returnedArray);
+    }
+
+    @Test
+    public void toArray_withDateArray() {
+        if (listType != DATE_LIST) {
+            thrown.expect(ArrayStoreException.class);
+            list.toArray(new Date[0]);
+            // should not reach here
+            return;
+        }
+
+        final Date[] expected = new Date[typeIsNullable ? NULLABLE_TEST_SIZE : NON_NULL_TEST_SIZE];
+        for (int i = 0; i < NON_NULL_TEST_SIZE; i++) {
+            if (typeIsNullable) {
+                expected[i * 2] = (Date) generateValue(DATE_LIST, i);
+                expected[i * 2 + 1] = null;
+            } else {
+                expected[i] = (Date) generateValue(DATE_LIST, i);
+            }
+        }
+        final Object[] returnedArray = list.toArray(new Date[0]);
+        assertEquals(Date.class, returnedArray.getClass().getComponentType());
+        assertArrayEquals(expected, returnedArray);
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/MutableRealmIntegerTests.java b/realm/realm-library/src/androidTest/java/io/realm/MutableRealmIntegerTests.java
new file mode 100644
index 0000000000..ae1c0c78f0
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/MutableRealmIntegerTests.java
@@ -0,0 +1,564 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+import io.realm.entities.MutableRealmIntegerTypes;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertFalse;
+import static junit.framework.Assert.assertTrue;
+import static junit.framework.Assert.fail;
+
+
+@RunWith(AndroidJUnit4.class)
+public class MutableRealmIntegerTests {
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    private Realm realm;
+
+    @Before
+    public void setUp() throws Exception {
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        if (realm != null) {
+            if (realm.isInTransaction()) {
+                realm.cancelTransaction();
+            }
+            realm.close();
+        }
+    }
+
+    /**
+     * Validate basic functions: set, increment and decrement.
+     */
+    @Test
+    public void basic_unmanaged() {
+        testBasic(MutableRealmInteger.ofNull(), MutableRealmInteger.ofNull());
+    }
+
+    /**
+     * Validate basic equality semantics.
+     */
+    @Test
+    public void equality_unmanaged() {
+        testEquality(new MutableRealmIntegerTypes(), new MutableRealmIntegerTypes());
+    }
+
+    /**
+     * Validate basic nullability semantics.
+     */
+    @Test
+    public void nullability_unmanaged() {
+        testNullability(new MutableRealmIntegerTypes());
+    }
+
+    /**
+     * Validate basic validity/managed semantics.
+     */
+    @Test
+    public void validAndManaged_unmanaged() {
+        testValidityAndManagement(new MutableRealmIntegerTypes());
+    }
+
+    /**
+     * Validate basic functions: set, increment and decrement.
+     */
+    @Test
+    public void basic_managed() {
+        realm.beginTransaction();
+        MutableRealmIntegerTypes c1 = realm.createObject(MutableRealmIntegerTypes.class);
+        MutableRealmIntegerTypes c2 = realm.createObject(MutableRealmIntegerTypes.class);
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+        testBasic(c1.columnNullableMutableRealmInteger, c2.columnNullableMutableRealmInteger);
+        realm.commitTransaction();
+    }
+
+    /**
+     * Validate basic equality semantics.
+     */
+    @Test
+    public void equality_managed() {
+        realm.beginTransaction();
+        MutableRealmIntegerTypes c1 = realm.createObject(MutableRealmIntegerTypes.class);
+        MutableRealmIntegerTypes c2 = realm.createObject(MutableRealmIntegerTypes.class);
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+        testEquality(c1, c2);
+        realm.commitTransaction();
+    }
+
+    /**
+     * Validate basic nullability semantics.
+     */
+    @Test
+    public void nullability_managed() {
+        realm.beginTransaction();
+        MutableRealmIntegerTypes c1 = realm.createObject(MutableRealmIntegerTypes.class);
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+        testNullability(c1);
+        realm.commitTransaction();
+    }
+
+    /**
+     * Validate basic validity/managed semantics.
+     */
+    @Test
+    public void validAndManaged_managed() {
+        realm.beginTransaction();
+        MutableRealmIntegerTypes c1 = realm.createObject(MutableRealmIntegerTypes.class);
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+        testValidityAndManagement(c1);
+        realm.commitTransaction();
+    }
+
+    /**
+     * {@literal @}Required MutableRealmIntegers should not be nullable.
+     * There are other tests testing nullabilty: just need to test @Required here.
+     * There is no attempt to control the nullability of an unmanaged MutableRealmInteger.
+     * An attempt to copy an unmanaged model object with a null-valued MutableRealmInteger
+     * into an @Required field should fail.
+     */
+    @Test
+    public void required() {
+        realm.beginTransaction();
+        MutableRealmIntegerTypes c1 = realm.createObject(MutableRealmIntegerTypes.class);
+        realm.commitTransaction();
+
+        assertFalse(
+                realm.getSchema().get("MutableRealmIntegerTypes")
+                        .isNullable(MutableRealmIntegerTypes.FIELD_NONNULLABLE_MUTABLEREALMINTEGER));
+
+        realm.beginTransaction();
+        try {
+            c1.columnNonNullableMutableRealmInteger.set(null);
+            fail("should not be able to set an @Required MutableRealmInteger null");
+        } catch(IllegalArgumentException ignore) {
+            checkException(ignore, "is not nullable");
+        }
+        realm.commitTransaction();
+
+        c1 = new MutableRealmIntegerTypes();
+        c1.columnNonNullableMutableRealmInteger.set(null);
+        realm.beginTransaction();
+        try {
+            MutableRealmIntegerTypes c2 = realm.copyToRealm(c1);
+            fail("should not be able to copy a null value to a @Required MutableRealmInteger");
+        } catch(IllegalArgumentException ignore) {
+            checkException(ignore, "is not nullable");
+        }
+        realm.commitTransaction();
+    }
+
+
+    /**
+     * MutableRealmIntegers annotated with {@literal @}Index should have indices.
+     * Without {@literal @}Index they should not.
+     */
+    @Test
+    public void indexed() {
+        realm.beginTransaction();
+        MutableRealmIntegerTypes c1 = realm.createObject(MutableRealmIntegerTypes.class);
+        realm.commitTransaction();
+
+        assertTrue(
+                realm.getSchema().get("MutableRealmIntegerTypes")
+                        .hasIndex(MutableRealmIntegerTypes.FIELD_INDEXED_MUTABLEREALMINTEGER));
+        assertFalse(
+                realm.getSchema().get("MutableRealmIntegerTypes")
+                        .hasIndex(MutableRealmIntegerTypes.FIELD_NULLABLE_MUTABLEEALMINTEGER));
+    }
+
+    /**
+     * Be absolutely certain that we can actually compare two longs.
+     */
+    @Test
+    public void compareTo_unmanaged() {
+        MutableRealmInteger ri1 = MutableRealmInteger.valueOf(0);
+        MutableRealmInteger ri2 = MutableRealmInteger.valueOf(Long.MAX_VALUE);
+        assertEquals(-1, ri1.compareTo(ri2));
+
+        ri2.decrement(Long.MAX_VALUE);
+        assertEquals(0, ri1.compareTo(ri2));
+
+        ri2.decrement(Long.MAX_VALUE);
+        assertEquals(1, ri1.compareTo(ri2));
+    }
+
+    /**
+     * Be absolutely certain that we can actually compare two longs.
+     */
+    @Test
+    public void compareTo_managed() {
+        realm.beginTransaction();
+        MutableRealmInteger ri1 = realm.createObject(MutableRealmIntegerTypes.class).getColumnNullableMutableRealmInteger();
+        ri1.set(0);
+        MutableRealmInteger ri2 = realm.createObject(MutableRealmIntegerTypes.class).getColumnNullableMutableRealmInteger();
+        ri2.set(Long.MAX_VALUE);
+        realm.commitTransaction();
+        assertEquals(-1, ri1.compareTo(ri2));
+
+        realm.beginTransaction();
+        ri2.decrement(Long.MAX_VALUE);
+        realm.commitTransaction();
+        assertEquals(0, ri1.compareTo(ri2));
+
+        realm.beginTransaction();
+        ri2.decrement(Long.MAX_VALUE);
+        realm.commitTransaction();
+        assertEquals(1, ri1.compareTo(ri2));
+    }
+
+    /**
+     * Assure that an attempt to change the value of a managed MutableRealmInteger, outside a transaction, fails.
+     */
+    @Test
+    public void updateOutsideTransactionThrows() {
+        realm.beginTransaction();
+        realm.createObject(MutableRealmIntegerTypes.class).getColumnNullableMutableRealmInteger().set(42);
+        realm.commitTransaction();
+
+        MutableRealmInteger managedRI = realm.where(MutableRealmIntegerTypes.class).findFirst().getColumnNullableMutableRealmInteger();
+        try {
+            managedRI.set(1);
+            fail("Setting a managed MutableRealmInteger outside a transaction should fail");
+        } catch (IllegalStateException e) {
+            checkTransactionException(e);
+        }
+
+        try {
+            managedRI.increment(1);
+            fail("Incrementing a managed MutableRealmInteger outside a transaction should fail");
+        } catch (IllegalStateException e) {
+            checkTransactionException(e);
+        }
+
+        try {
+            managedRI.decrement(1);
+            fail("Decrementing a managed MutableRealmInteger outside a transaction should fail");
+        } catch (IllegalStateException e) {
+            checkTransactionException(e);
+        }
+    }
+
+    /**
+     * Assure that changes to a MutableRealmInteger acquired from a managed object are reflected in the object.
+     */
+    @Test
+    public void isLive() {
+        realm.beginTransaction();
+        realm.createObject(MutableRealmIntegerTypes.class).getColumnNullableMutableRealmInteger().set(42);
+        realm.commitTransaction();
+
+        MutableRealmInteger managedRI = realm.where(MutableRealmIntegerTypes.class).findFirst().getColumnNullableMutableRealmInteger();
+
+        realm.beginTransaction();
+        MutableRealmInteger ri = realm.where(MutableRealmIntegerTypes.class).findFirst().getColumnNullableMutableRealmInteger();
+        ri.set(37);
+        ri.increment(17);
+        ri.decrement(7);
+        realm.commitTransaction();
+
+        assertEquals(Long.valueOf(47), managedRI.get());
+    }
+
+    /**
+     * Assure that changes to a MutableRealmInteger acquired from a managed object are reflected in the object.
+     */
+    @Test
+    public void copyToIsLive() {
+        MutableRealmIntegerTypes obj = new MutableRealmIntegerTypes();
+        MutableRealmInteger unmanagedRI = obj.getColumnNullableMutableRealmInteger();
+        unmanagedRI.set(42L);
+
+        realm.beginTransaction();
+        MutableRealmInteger managedRI = realm.copyToRealm(obj).getColumnNullableMutableRealmInteger();
+        realm.commitTransaction();
+
+        realm.beginTransaction();
+        MutableRealmInteger ri = realm.where(MutableRealmIntegerTypes.class).findFirst().getColumnNullableMutableRealmInteger();
+        ri.set(37);
+        ri.increment(17);
+        ri.decrement(7);
+        realm.commitTransaction();
+
+        assertEquals(Long.valueOf(42L), unmanagedRI.get());
+        assertEquals(Long.valueOf(47L), managedRI.get());
+    }
+
+    /**
+     * Assure that a MutableRealmInteger acquired from an unmanaged object is not affected by changes in the Realm.
+     */
+    @Test
+    public void copyFromIsNotLive() {
+        realm.beginTransaction();
+        realm.createObject(MutableRealmIntegerTypes.class).getColumnNullableMutableRealmInteger().set(42L);
+        realm.commitTransaction();
+
+        MutableRealmIntegerTypes obj = realm.where(MutableRealmIntegerTypes.class).findFirst();
+        MutableRealmInteger managedRI = obj.getColumnNullableMutableRealmInteger();
+        MutableRealmInteger unmanagedRI = realm.copyFromRealm(obj).getColumnNullableMutableRealmInteger();
+
+        realm.beginTransaction();
+        MutableRealmInteger ri = realm.where(MutableRealmIntegerTypes.class).findFirst().getColumnNullableMutableRealmInteger();
+        ri.set(37);
+        ri.increment(17);
+        ri.decrement(7);
+        realm.commitTransaction();
+
+        assertEquals(Long.valueOf(42L), unmanagedRI.get());
+        assertEquals(Long.valueOf(47L), managedRI.get());
+    }
+
+    @Test
+    public void testJSON() throws JSONException {
+        JSONObject json = new JSONObject();
+        realm.beginTransaction();
+        MutableRealmIntegerTypes obj = realm.createObjectFromJson(MutableRealmIntegerTypes.class, json);
+        realm.commitTransaction();
+        assertTrue(obj.columnNullableMutableRealmInteger.isNull());
+
+        json = new JSONObject();
+        json.put("columnNullableMutableRealmInteger", 8589934592L);
+        realm.beginTransaction();
+        obj = realm.createObjectFromJson(MutableRealmIntegerTypes.class, json);
+        realm.commitTransaction();
+        assertEquals(Long.valueOf(8589934592L), obj.columnNullableMutableRealmInteger.get());
+
+        json = new JSONObject();
+        json.put("columnNullableMutableRealmInteger", 22);
+        realm.beginTransaction();
+        obj = realm.createObjectFromJson(MutableRealmIntegerTypes.class, json);
+        realm.commitTransaction();
+        assertEquals(Long.valueOf(22), obj.columnNullableMutableRealmInteger.get());
+
+        json = new JSONObject();
+        json.put("columnNullableMutableRealmInteger", JSONObject.NULL);
+        realm.beginTransaction();
+        obj = realm.createObjectFromJson(MutableRealmIntegerTypes.class, json);
+        realm.commitTransaction();
+        assertTrue(obj.columnNullableMutableRealmInteger.isNull());
+
+        json = new JSONObject();
+        json.put("columnNonNullableMutableRealmInteger", JSONObject.NULL);
+        realm.beginTransaction();
+        try {
+            obj = realm.createObjectFromJson(MutableRealmIntegerTypes.class, json);
+            fail("Attempt to set @Required Mutable Realm Integer null, from JSON, should fail");
+        } catch (IllegalArgumentException ignore) {
+            checkException(ignore, "is not nullable");
+        }
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void testStream() throws IOException {
+        Context context = InstrumentationRegistry.getTargetContext();
+
+        InputStream in = TestHelper.loadJsonFromAssets(context, "empty.json");
+        realm.beginTransaction();
+        MutableRealmIntegerTypes obj = realm.createObjectFromJson(MutableRealmIntegerTypes.class, in);
+        realm.commitTransaction();
+        assertTrue(obj.columnNullableMutableRealmInteger.isNull());
+
+        in = TestHelper.loadJsonFromAssets(context, "mutablerealminteger-long.json");
+        realm.beginTransaction();
+        obj = realm.createObjectFromJson(MutableRealmIntegerTypes.class, in);
+        realm.commitTransaction();
+        assertEquals(Long.valueOf(8589934592L), obj.columnNullableMutableRealmInteger.get());
+
+        in = TestHelper.loadJsonFromAssets(context, "mutablerealminteger-int.json");
+        realm.beginTransaction();
+        obj = realm.createObjectFromJson(MutableRealmIntegerTypes.class, in);
+        realm.commitTransaction();
+        assertEquals(Long.valueOf(22), obj.columnNullableMutableRealmInteger.get());
+
+        in = TestHelper.loadJsonFromAssets(context, "mutablerealminteger-null.json");
+        realm.beginTransaction();
+        obj = realm.createObjectFromJson(MutableRealmIntegerTypes.class, in);
+        realm.commitTransaction();
+        assertTrue(obj.columnNullableMutableRealmInteger.isNull());
+
+        in = TestHelper.loadJsonFromAssets(context, "mutablerealminteger-required-null.json");
+        realm.beginTransaction();
+        try {
+            obj = realm.createObjectFromJson(MutableRealmIntegerTypes.class, in);
+            fail("Attempt to set @Required Mutable Realm Integer null, from JSON, should fail");
+        } catch (IllegalArgumentException ignore) {
+            checkException(ignore, "is not nullable");
+        }
+        realm.commitTransaction();
+    }
+
+    private void checkTransactionException(Exception e) {
+        checkException(e, "only be done from inside a transaction");
+    }
+
+    private void checkException(Exception e, String expected) {
+        assertTrue(e.getMessage().contains(expected));
+    }
+
+    /**
+     * Test basic arithmetic: set, increment, decrement and equals.
+     * Since the implementations of managed and unmanaged MutableRealmIntegers are completely
+     * different these tests should be run on both implementations.
+     *
+     * @param r1 a MutableRealmInteger
+     * @param r2 another MutableRealmInteger
+     */
+    @SuppressWarnings({"ReferenceEquality", "EqualsIncompatibleType"})
+    private void testBasic(MutableRealmInteger r1, MutableRealmInteger r2) {
+        assertFalse(r1 == r2);
+
+        r1.set(10);
+        r2.set(Long.valueOf(10));
+        assertEquals(r1, r2);
+        assertEquals(r2, r1);
+
+        r1.set(15);
+        r1.decrement(2);
+        r2.increment(3);
+        assertEquals(r1, r2);
+
+        MutableRealmInteger r3 = r1;
+        r1.set(19);
+        assertEquals(19, r3.get().intValue());
+
+        assertFalse(r2.equals(r3));
+        assertFalse(r3.equals(r2));
+    }
+
+    /**
+     * Thorough tests of equality, as defined <a href="https://github.com/realm/realm-java/issues/4266#issuecomment-308772718">here</a>
+     * and in subsequent comments.  The general principles are:
+     * <ul>
+     *     <li>MutableRealmInteger.equals tests the value of the wrapped integer<./li>
+     *     <li>All references to a single MutableRealmInteger must be {@code .equals} to the same thing.</li>
+     *     <li>Except when set to {@code null} MutableRealmInteger does not distinguish boxed and primitive types.</li>
+     * </ul>
+     * Since the implementations of managed and unmanaged MutableRealmIntegers are completely
+     * different these tests should be run on both implementations.
+     *
+     * @param c1 a MutableRealmIntegerTypes
+     * @param c2 another MutableRealmIntegerTypes
+     */
+    @SuppressWarnings({"ReferenceEquality", "EqualsIncompatibleType"})
+    private void testEquality(MutableRealmIntegerTypes c1, MutableRealmIntegerTypes c2) {
+        assertFalse(c1 == c2);
+
+        c1.columnNullableMutableRealmInteger.set(7);
+        c2.columnNullableMutableRealmInteger.set(Long.valueOf(7));
+        assertTrue(c1.columnNullableMutableRealmInteger != c2.columnNullableMutableRealmInteger);
+        assertTrue(c1.columnNullableMutableRealmInteger.equals(c2.columnNullableMutableRealmInteger));
+
+        MutableRealmInteger r1 = c1.columnNullableMutableRealmInteger;
+        r1.increment(1);
+        assertTrue(r1.equals(c1.columnNullableMutableRealmInteger));
+        assertTrue(r1 == c1.columnNullableMutableRealmInteger);
+        assertTrue(c1.columnNullableMutableRealmInteger.get().equals(8L));
+        assertFalse(c1.columnNullableMutableRealmInteger.get().equals(c2.columnNullableMutableRealmInteger.get()));
+        assertTrue(c1.columnNullableMutableRealmInteger.get().intValue() == 8);
+
+        Long n = c1.columnNullableMutableRealmInteger.get();
+        assertTrue(n.equals(Long.valueOf(8)));
+        assertTrue(n.equals(c1.columnNullableMutableRealmInteger.get()));
+        assertTrue(n.intValue() == c1.columnNullableMutableRealmInteger.get().intValue());
+
+        c1.columnNullableMutableRealmInteger.increment(1);
+        assertFalse(n.intValue() == c1.columnNullableMutableRealmInteger.get().intValue());
+        assertFalse(n.intValue() == r1.get().intValue());
+    }
+
+    /**
+     * Thorough tests of nullability, as defined <a href="https://github.com/realm/realm-java/issues/4266#issuecomment-308772718">here</a>
+     * and in subsequent comments.  The general principles are:
+     * <ul>
+     *     <li>Unless @Required, MutableRealmIntegers are nullable.</li>
+     *     <li>0L and null are distinct values.</li>
+     *     <li>All references to a single MutableRealmInteger must be {@code null} if any are./li>
+     *     <li>A null value cannot be incremented or decremented/li>
+     * </ul>
+     * Since the implementations of managed and unmanaged MutableRealmIntegers are completely
+     * different these tests should be run on both implementations.
+     *
+     * @param c1 a MutableRealmIntegerTypes
+     */
+    private void testNullability(MutableRealmIntegerTypes c1) {
+        MutableRealmInteger r1 = c1.columnNullableMutableRealmInteger;
+
+        c1.columnNullableMutableRealmInteger.set(0L);
+        assertFalse(c1.columnNullableMutableRealmInteger.isNull());
+        assertFalse(r1.isNull());
+
+        c1.columnNullableMutableRealmInteger.set(null);
+        assertFalse(c1.columnNullableMutableRealmInteger == null);
+        assertTrue(c1.columnNullableMutableRealmInteger.isNull());
+        assertTrue(r1.isNull());
+
+        assertTrue(c1.columnNullableMutableRealmInteger.get() == null);
+        assertTrue(r1.get() == null);
+
+        try {
+            c1.columnNullableMutableRealmInteger.increment(5);
+            fail("Attempt to increment a null valued MutableRealmInteger should throw ISE");
+        } catch (IllegalStateException ignore) {
+            checkException(ignore, "Set its value first");
+        }
+        try {
+            c1.columnNullableMutableRealmInteger.decrement(5);
+            fail("Attempt to decrement a null valued MutableRealmInteger should throw ISE");
+        } catch (IllegalStateException ignore) {
+            checkException(ignore, "Set its value first");
+        }
+    }
+
+    private void testValidityAndManagement(MutableRealmIntegerTypes c1) {
+        MutableRealmInteger r1 = c1.columnNullableMutableRealmInteger;
+        assertTrue(r1.isManaged() == c1.isManaged());
+        assertTrue(r1.isValid() == c1.isValid());
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java
index f05ca4163a..ca5fe29fc6 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java
@@ -25,7 +25,6 @@
 
 import java.util.Arrays;
 import java.util.List;
-import java.util.concurrent.CountDownLatch;
 
 import io.realm.entities.Dog;
 import io.realm.entities.Owner;
@@ -40,6 +39,7 @@
 import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertArrayEquals;
 
+
 // Tests for the ordered collection fine grained notifications for both RealmResults and RealmList.
 @RunWith(Parameterized.class)
 public class OrderedCollectionChangeSetTests {
@@ -94,7 +94,7 @@ private void populateData(Realm realm, int testSize) {
 
     // The args should be [startIndex1, length1, startIndex2, length2, ...]
     private void checkRanges(OrderedCollectionChangeSet.Range[] ranges, int... indexAndLen) {
-        if ((indexAndLen.length % 2 != 0))  {
+        if ((indexAndLen.length % 2 != 0)) {
             fail("The 'indexAndLen' array length is not an even number.");
         }
         if (ranges.length != indexAndLen.length / 2) {
@@ -191,7 +191,7 @@ public void check(OrderedCollectionChangeSet changeSet) {
                         0, 1,
                         2, 3,
                         8, 2);
-                assertArrayEquals(changeSet.getDeletions(), new int[]{0, 2, 3, 4, 8, 9});
+                assertArrayEquals(changeSet.getDeletions(), new int[] {0, 2, 3, 4, 8, 9});
                 assertEquals(0, changeSet.getChangeRanges().length);
                 assertEquals(0, changeSet.getInsertionRanges().length);
                 assertEquals(0, changeSet.getChanges().length);
@@ -226,7 +226,7 @@ public void check(OrderedCollectionChangeSet changeSet) {
                         1, 1,
                         3, 2,
                         8, 1);
-                assertArrayEquals(changeSet.getInsertions(), new int[]{1, 3, 4, 8});
+                assertArrayEquals(changeSet.getInsertions(), new int[] {1, 3, 4, 8});
                 assertEquals(0, changeSet.getChangeRanges().length);
                 assertEquals(0, changeSet.getDeletionRanges().length);
                 assertEquals(0, changeSet.getChanges().length);
@@ -256,7 +256,7 @@ public void check(OrderedCollectionChangeSet changeSet) {
                         0, 1,
                         2, 3,
                         8, 2);
-                assertArrayEquals(changeSet.getChanges(), new int[]{0, 2, 3, 4, 8, 9});
+                assertArrayEquals(changeSet.getChanges(), new int[] {0, 2, 3, 4, 8, 9});
                 assertEquals(0, changeSet.getInsertionRanges().length);
                 assertEquals(0, changeSet.getDeletionRanges().length);
                 assertEquals(0, changeSet.getInsertions().length);
@@ -286,11 +286,11 @@ public void check(OrderedCollectionChangeSet changeSet) {
                 checkRanges(changeSet.getDeletionRanges(),
                         0, 1,
                         9, 1);
-                assertArrayEquals(changeSet.getDeletions(), new int[]{0, 9});
+                assertArrayEquals(changeSet.getDeletions(), new int[] {0, 9});
                 checkRanges(changeSet.getInsertionRanges(),
                         0, 1,
                         9, 1);
-                assertArrayEquals(changeSet.getInsertions(), new int[]{0, 9});
+                assertArrayEquals(changeSet.getInsertions(), new int[] {0, 9});
                 assertEquals(0, changeSet.getChangeRanges().length);
                 assertEquals(0, changeSet.getChanges().length);
                 looperThread.testComplete();
@@ -315,17 +315,17 @@ public void check(OrderedCollectionChangeSet changeSet) {
                 checkRanges(changeSet.getDeletionRanges(),
                         0, 2,
                         5, 1);
-                assertArrayEquals(changeSet.getDeletions(), new int[]{0, 1, 5});
+                assertArrayEquals(changeSet.getDeletions(), new int[] {0, 1, 5});
 
                 checkRanges(changeSet.getInsertionRanges(),
                         0, 2,
                         9, 2);
-                assertArrayEquals(changeSet.getInsertions(), new int[]{0, 1, 9, 10});
+                assertArrayEquals(changeSet.getInsertions(), new int[] {0, 1, 9, 10});
 
                 checkRanges(changeSet.getChangeRanges(),
                         3, 2,
                         8, 1);
-                assertArrayEquals(changeSet.getChanges(), new int[]{3, 4, 8});
+                assertArrayEquals(changeSet.getChanges(), new int[] {3, 4, 8});
 
                 looperThread.testComplete();
             }
@@ -355,7 +355,7 @@ public void check(OrderedCollectionChangeSet changeSet) {
                 checkRanges(changeSet.getDeletionRanges(),
                         0, 2,
                         5, 1);
-                assertArrayEquals(changeSet.getDeletions(), new int[]{0, 1, 5});
+                assertArrayEquals(changeSet.getDeletions(), new int[] {0, 1, 5});
 
                 assertEquals(0, changeSet.getInsertionRanges().length);
                 assertEquals(0, changeSet.getInsertions().length);
@@ -401,10 +401,10 @@ public void run() {
         realm.commitTransaction();
     }
 
-    // The change set should empty when the async query returns at the first time.
+    // The change set should be empty when the async query returns at the first time.
     @Test
     @RunTestInLooperThread
-    public void emptyChangeSet_findAllAsync(){
+    public void emptyChangeSet_findAllAsync() {
         if (type == ObservablesType.REALM_LIST) {
             looperThread.testComplete();
             return;
@@ -413,31 +413,15 @@ public void emptyChangeSet_findAllAsync(){
         Realm realm = looperThread.getRealm();
         populateData(realm, 10);
         final RealmResults<Dog> results = realm.where(Dog.class).findAllSortedAsync(Dog.FIELD_AGE);
+        looperThread.keepStrongReference(results);
         results.addChangeListener(new OrderedRealmCollectionChangeListener<RealmResults<Dog>>() {
             @Override
             public void onChange(RealmResults<Dog> collection, OrderedCollectionChangeSet changeSet) {
                 assertSame(collection, results);
-                assertEquals(9, collection.size());
+                assertEquals(10, collection.size());
                 assertNull(changeSet);
                 looperThread.testComplete();
             }
         });
-
-        final CountDownLatch bgDeletionLatch = new CountDownLatch(1);
-        // beginTransaction() will make the async query return immediately. So we have to create an object in another
-        // thread. Also, the latch has to be counted down after transaction committed so the async query results can
-        // contain the modification in the background transaction.
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                Realm realm = Realm.getInstance(looperThread.getConfiguration())      ;
-                realm.beginTransaction();
-                realm.where(Dog.class).equalTo(Dog.FIELD_AGE, 0).findFirst().deleteFromRealm();
-                realm.commitTransaction();
-                realm.close();
-                bgDeletionLatch.countDown();
-            }
-        }).start();
-        TestHelper.awaitOrFail(bgDeletionLatch);
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
index 534730bb58..d7e705a0fd 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
@@ -642,16 +642,21 @@ public void listIterator_unsupportedMethods() {
             fail();
         } catch (UnsupportedOperationException e) {
             assertResultsOrSnapshot();
-        } catch (IllegalStateException e) {
+        } catch (IllegalStateException e) { // since next() was never called.
             assertRealmList();
         }
 
         try {
             it.add(null);
-            fail();
+            if (collectionClass != CollectionClass.UNMANAGED_REALMLIST) {
+                fail();
+            }
         } catch (UnsupportedOperationException e) {
             assertResultsOrSnapshot();
         } catch (IllegalArgumentException e) {
+            if (collectionClass == CollectionClass.UNMANAGED_REALMLIST) {
+                fail();
+            }
             assertRealmList();
         }
 
@@ -660,7 +665,7 @@ public void listIterator_unsupportedMethods() {
             fail();
         } catch (UnsupportedOperationException e) {
             assertResultsOrSnapshot();
-        } catch (IllegalStateException e) {
+        } catch (IllegalStateException e) { // since the collection is empty
             assertRealmList();
         }
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/QueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/QueryTests.java
new file mode 100644
index 0000000000..5ef1233760
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/QueryTests.java
@@ -0,0 +1,179 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.rules.ExpectedException;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+import io.realm.entities.AllJavaTypes;
+import io.realm.entities.BacklinksSource;
+import io.realm.entities.BacklinksTarget;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+
+public abstract class QueryTests {
+    public static final int TEST_DATA_SIZE = 10;
+    public static final int TEST_NO_PRIMARY_KEY_NULL_TYPES_SIZE = 200;
+
+    public static final long DECADE_MILLIS = 10 * TimeUnit.DAYS.toMillis(365);
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    protected static final List<RealmFieldType> SUPPORTED_IS_EMPTY_TYPES;
+    protected static final List<RealmFieldType> NOT_SUPPORTED_IS_EMPTY_TYPES;
+    protected static final List<RealmFieldType> SUPPORTED_IS_NOT_EMPTY_TYPES;
+    protected static final List<RealmFieldType> NOT_SUPPORTED_IS_NOT_EMPTY_TYPES;
+
+    static {
+        ArrayList<RealmFieldType> list = new ArrayList<>(Arrays.asList(
+                RealmFieldType.STRING,
+                RealmFieldType.BINARY,
+                RealmFieldType.LIST,
+                RealmFieldType.LINKING_OBJECTS));
+        SUPPORTED_IS_EMPTY_TYPES = Collections.unmodifiableList(list);
+        SUPPORTED_IS_NOT_EMPTY_TYPES = Collections.unmodifiableList(list);
+
+        list = new ArrayList<>(Arrays.asList(RealmFieldType.values()));
+        list.removeAll(SUPPORTED_IS_EMPTY_TYPES);
+
+        // FIXME zaki50 revisit once we implement query for Primitive List
+        list.remove(RealmFieldType.STRING_LIST);
+        list.remove(RealmFieldType.BINARY_LIST);
+        list.remove(RealmFieldType.BOOLEAN_LIST);
+        list.remove(RealmFieldType.INTEGER_LIST);
+        list.remove(RealmFieldType.DOUBLE_LIST);
+        list.remove(RealmFieldType.FLOAT_LIST);
+        list.remove(RealmFieldType.DATE_LIST);
+
+        NOT_SUPPORTED_IS_EMPTY_TYPES = Collections.unmodifiableList(list);
+        NOT_SUPPORTED_IS_NOT_EMPTY_TYPES = Collections.unmodifiableList(list);
+    }
+
+    protected Realm realm;
+
+    @Before
+    public void setUp() throws Exception {
+        RealmConfiguration realmConfig = configFactory.createConfiguration();
+        realm = Realm.getInstance(realmConfig);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        if (realm != null) {
+            realm.close();
+        }
+    }
+
+    protected final void createIsEmptyDataSet(Realm realm) {
+        realm.beginTransaction();
+
+        AllJavaTypes emptyValues = new AllJavaTypes();
+        emptyValues.setFieldId(1);
+        emptyValues.setFieldString("");
+        emptyValues.setFieldBinary(new byte[0]);
+        emptyValues.setFieldObject(emptyValues);
+        emptyValues.setFieldList(new RealmList<AllJavaTypes>());
+        AllJavaTypes emptyValuesManaged = realm.copyToRealm(emptyValues);
+
+        AllJavaTypes nonEmpty = new AllJavaTypes();
+        nonEmpty.setFieldId(2);
+        nonEmpty.setFieldString("Foo");
+        nonEmpty.setFieldBinary(new byte[] {1, 2, 3});
+        nonEmpty.setFieldObject(nonEmpty);
+        nonEmpty.setFieldList(new RealmList<AllJavaTypes>(emptyValuesManaged));
+        AllJavaTypes nonEmptyManaged = realm.copyToRealmOrUpdate(nonEmpty);
+
+        AllJavaTypes emptyValues2 = new AllJavaTypes();
+        emptyValues2.setFieldId(3);
+        emptyValues2.setFieldString("");
+        emptyValues2.setFieldBinary(new byte[0]);
+        emptyValues2.setFieldObject(null);
+        emptyValues2.setFieldList(new RealmList<AllJavaTypes>(nonEmptyManaged));
+        realm.copyToRealm(emptyValues2);
+
+        realm.commitTransaction();
+    }
+
+    protected final void createLinkedDataSet(Realm realm) {
+        realm.beginTransaction();
+
+        realm.delete(BacklinksSource.class);
+        realm.delete(BacklinksTarget.class);
+
+        BacklinksTarget target1 = realm.createObject(BacklinksTarget.class);
+        target1.setId(1);
+
+        BacklinksTarget target2 = realm.createObject(BacklinksTarget.class);
+        target2.setId(2);
+
+        BacklinksTarget target3 = realm.createObject(BacklinksTarget.class);
+        target3.setId(3);
+
+
+        BacklinksSource source1 = realm.createObject(BacklinksSource.class);
+        source1.setName("1");
+        source1.setChild(target1);
+
+        BacklinksSource source2 = realm.createObject(BacklinksSource.class);
+        source2.setName("2");
+        source2.setChild(target2);
+
+        BacklinksSource source3 = realm.createObject(BacklinksSource.class);
+        source3.setName("3");
+
+        BacklinksSource source4 = realm.createObject(BacklinksSource.class);
+        source4.setName("4");
+        source4.setChild(target1);
+
+        realm.commitTransaction();
+    }
+
+    protected final void createIsNotEmptyDataSet(Realm realm) {
+        realm.beginTransaction();
+
+        AllJavaTypes emptyValues = new AllJavaTypes();
+        emptyValues.setFieldId(1);
+        emptyValues.setFieldString("");
+        emptyValues.setFieldBinary(new byte[0]);
+        emptyValues.setFieldObject(emptyValues);
+        emptyValues.setFieldList(new RealmList<AllJavaTypes>());
+        realm.copyToRealm(emptyValues);
+
+        AllJavaTypes notEmpty = new AllJavaTypes();
+        notEmpty.setFieldId(2);
+        notEmpty.setFieldString("Foo");
+        notEmpty.setFieldBinary(new byte[] {1, 2, 3});
+        notEmpty.setFieldObject(notEmpty);
+        notEmpty.setFieldList(new RealmList<AllJavaTypes>(emptyValues));
+        realm.copyToRealmOrUpdate(notEmpty);
+
+        realm.commitTransaction();
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
index 5b5084f004..e2d0a4b959 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAnnotationTests.java
@@ -30,11 +30,13 @@
 import io.realm.entities.PrimaryKeyAsLong;
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.exceptions.RealmPrimaryKeyConstraintException;
+import io.realm.internal.OsObjectStore;
 import io.realm.internal.Table;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -54,6 +56,7 @@ public void setUp() {
         object.setNotIndexString("String 1");
         object.setIndexString("String 2");
         object.setIgnoreString("String 3");
+        object.setTransientString("String 4");
         realm.commitTransaction();
     }
 
@@ -67,7 +70,8 @@ public void tearDown() {
     @Test
     public void ignore() {
         Table table = realm.getTable(AnnotationTypes.class);
-        assertEquals(-1, table.getColumnIndex("ignoreString"));
+        assertEquals(-1, table.getColumnIndex(AnnotationTypes.FIELD_IGNORE_STRING));
+        assertEquals(-1, table.getColumnIndex(AnnotationTypes.FIELD_TRANSIENT_STRING));
     }
 
     // Tests if "index" annotation works with supported types.
@@ -97,76 +101,6 @@ public void index() {
         assertFalse(table.hasSearchIndex(table.getColumnIndex("notIndexDate")));
     }
 
-    // Tests migrating primary key from string to long with existing data.
-    @Test
-    public void primaryKey_migration_long() {
-        realm.beginTransaction();
-        for (int i = 1; i <= 2; i++) {
-            PrimaryKeyAsString obj = realm.createObject(PrimaryKeyAsString.class, "String" + i);
-            obj.setId(i);
-        }
-
-        Table table = realm.getTable(PrimaryKeyAsString.class);
-        table.setPrimaryKey("id");
-        assertEquals(1, table.getPrimaryKey());
-        realm.cancelTransaction();
-    }
-
-    // Tests migrating primary key from string to long with existing data.
-    @Test
-    public void primaryKey_migration_longDuplicateValues() {
-        realm.beginTransaction();
-        for (int i = 1; i <= 2; i++) {
-            PrimaryKeyAsString obj = realm.createObject(PrimaryKeyAsString.class, "String" + i);
-            obj.setId(1); // Creates duplicate values.
-        }
-
-        Table table = realm.getTable(PrimaryKeyAsString.class);
-        try {
-            table.setPrimaryKey("id");
-            fail("It should not be possible to set a primary key column which already contains duplicate values.");
-        } catch (IllegalArgumentException ignored) {
-            assertEquals(0, table.getPrimaryKey());
-        } finally {
-            realm.cancelTransaction();
-        }
-    }
-
-    // Tests migrating primary key from long to str with existing data.
-    @Test
-    public void primaryKey_migration_string() {
-        realm.beginTransaction();
-        for (int i = 1; i <= 2; i++) {
-            PrimaryKeyAsLong obj = realm.createObject(PrimaryKeyAsLong.class, i);
-            obj.setName("String" + i);
-        }
-
-        Table table = realm.getTable(PrimaryKeyAsLong.class);
-        table.setPrimaryKey("name");
-        assertEquals(1, table.getPrimaryKey());
-        realm.cancelTransaction();
-    }
-
-    // Tests migrating primary key from long to str with existing data.
-    @Test
-    public void primaryKey_migration_stringDuplicateValues() {
-        realm.beginTransaction();
-        for (int i = 1; i <= 2; i++) {
-            PrimaryKeyAsLong obj = realm.createObject(PrimaryKeyAsLong.class, i);
-            obj.setName("String"); // Creates duplicate values.
-        }
-
-        Table table = realm.getTable(PrimaryKeyAsLong.class);
-        try {
-            table.setPrimaryKey("name");
-            fail("It should not be possible to set a primary key column which already contains duplicate values.");
-        } catch (IllegalArgumentException ignored) {
-            assertEquals(0, table.getPrimaryKey());
-        } finally {
-            realm.cancelTransaction();
-        }
-    }
-
     @Test
     public void primaryKey_checkPrimaryKeyOnCreate() {
         realm.beginTransaction();
@@ -195,11 +129,11 @@ public void primaryKey_errorOnInsertingSameObject() {
     @Test
     public void primaryKey_isIndexed() {
         Table table = realm.getTable(PrimaryKeyAsString.class);
-        assertTrue(table.hasPrimaryKey());
+        assertNotNull(OsObjectStore.getPrimaryKeyForObject(realm.getSharedRealm(), PrimaryKeyAsString.CLASS_NAME));
         assertTrue(table.hasSearchIndex(table.getColumnIndex("name")));
 
         table = realm.getTable(PrimaryKeyAsLong.class);
-        assertTrue(table.hasPrimaryKey());
+        assertNotNull(OsObjectStore.getPrimaryKeyForObject(realm.getSharedRealm(), PrimaryKeyAsLong.CLASS_NAME));
         assertTrue(table.hasSearchIndex(table.getColumnIndex("id")));
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index 6bd6945524..770337505e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -20,6 +20,7 @@
 import android.support.test.rule.UiThreadTestRule;
 import android.support.test.runner.AndroidJUnit4;
 
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -37,6 +38,7 @@
 import io.realm.entities.Dog;
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.Owner;
+import io.realm.internal.async.RealmThreadPoolExecutor;
 import io.realm.log.LogLevel;
 import io.realm.log.RealmLog;
 import io.realm.rule.RunInLooperThread;
@@ -411,10 +413,14 @@ public void onError(Throwable error) {
     // callbacks, the callback should be cleared.
     @Test
     @RunTestInLooperThread
-    public void executeTransactionAsync_callbacksShouldBeClearedBeforeCalling() {
+    public void executeTransactionAsync_callbacksShouldBeClearedBeforeCalling()
+            throws NoSuchFieldException, IllegalAccessException {
         final AtomicInteger callbackCounter = new AtomicInteger(0);
         final Realm foregroundRealm = looperThread.getRealm();
 
+        // Use single thread executor
+        TestHelper.replaceRealmThreadExecutor(RealmThreadPoolExecutor.newSingleThreadExecutor());
+
         // To reproduce the issue, the posted callback needs to arrived before the Object Store did_change called.
         // We just disable the auto refresh here then the did_change won't be called.
         foregroundRealm.setAutoRefresh(false);
@@ -440,15 +446,6 @@ public void onSuccess() {
             @Override
             public void execute(Realm realm) {
                 realm.createObject(AllTypes.class);
-                // Delay to post this to ensure the async transaction posted callback will arrive first.
-                looperThread.postRunnableDelayed(new Runnable() {
-                    @Override
-                    public void run() {
-                        // Manually call refresh, so the did_change will be triggered.
-                        foregroundRealm.sharedRealm.refresh();
-                        foregroundRealm.setAutoRefresh(true);
-                    }
-                }, 50);
             }
         }, new Realm.Transaction.OnSuccess() {
             @Override
@@ -458,6 +455,17 @@ public void onSuccess() {
                 looperThread.testComplete();
             }
         });
+
+        // Wait for all async tasks finish to ensure the async transaction posted callback will arrive first.
+        TestHelper.resetRealmThreadExecutor();
+        looperThread.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                // Manually call refresh, so the did_change will be triggered.
+                foregroundRealm.sharedRealm.refresh();
+                foregroundRealm.setAutoRefresh(true);
+            }
+        });
     }
 
     // ************************************
@@ -728,6 +736,7 @@ public void findFirstAsync_twoListenersOnSameInvalidObjectsCauseNPE() {
         final Realm realm = looperThread.getRealm();
         final AllTypes allTypes = realm.where(AllTypes.class).findFirstAsync();
         final AtomicBoolean firstListenerCalled = new AtomicBoolean(false);
+        looperThread.keepStrongReference(allTypes);
 
         allTypes.addChangeListener(new RealmChangeListener<AllTypes>() {
             @Override
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
index b0ca7ffce1..252dc083a6 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmCacheTests.java
@@ -28,22 +28,29 @@
 import java.io.File;
 import java.io.IOException;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.StringOnly;
 import io.realm.exceptions.RealmFileException;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
 public class RealmCacheTests {
 
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
     @Rule
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
 
@@ -108,7 +115,7 @@ public void getInstanceClearsCacheWhenFailed() {
             Realm.getInstance(configB); // Tries to open with key 2.
             fail();
         } catch (RealmFileException expected) {
-            assertEquals(expected.getKind(), RealmFileException.Kind.ACCESS_ERROR);
+            assertEquals(RealmFileException.Kind.ACCESS_ERROR, expected.getKind());
             // Deletes Realm so key 2 works. This should work as a Realm shouldn't be cached
             // if initialization failed.
             assertTrue(Realm.deleteRealm(configA));
@@ -134,29 +141,30 @@ public void realmCache() {
     public void dontCacheWrongConfigurations() throws IOException {
         Realm testRealm;
         String REALM_NAME = "encrypted.realm";
-        configFactory.copyRealmFromAssets(context, REALM_NAME, REALM_NAME);
-        RealmMigration realmMigration = TestHelper.prepareMigrationToNullSupportStep();
 
         RealmConfiguration wrongConfig = configFactory.createConfigurationBuilder()
                 .name(REALM_NAME)
                 .encryptionKey(TestHelper.SHA512("foo"))
-                .migration(realmMigration)
                 .schema(StringOnly.class)
                 .build();
 
         RealmConfiguration rightConfig = configFactory.createConfigurationBuilder()
                 .name(REALM_NAME)
                 .encryptionKey(TestHelper.SHA512("realm"))
-                .migration(realmMigration)
                 .schema(StringOnly.class)
                 .build();
 
+        // Create the realm with proper key.
+        testRealm = Realm.getInstance(rightConfig);
+        assertNotNull(testRealm);
+        testRealm.close();
+
         // Opens Realm with wrong key.
         try {
             Realm.getInstance(wrongConfig);
             fail();
         } catch (RealmFileException expected) {
-            assertEquals(expected.getKind(), RealmFileException.Kind.ACCESS_ERROR);
+            assertEquals(RealmFileException.Kind.ACCESS_ERROR, expected.getKind());
         }
 
         // Tries again with proper key.
@@ -171,13 +179,9 @@ public void deletingRealmAlsoClearsConfigurationCache() throws IOException {
         byte[] oldPassword = TestHelper.SHA512("realm");
         byte[] newPassword = TestHelper.SHA512("realm-copy");
 
-        configFactory.copyRealmFromAssets(context, REALM_NAME, REALM_NAME);
-        RealmMigration realmMigration = TestHelper.prepareMigrationToNullSupportStep();
-
         RealmConfiguration config = configFactory.createConfigurationBuilder()
                 .name(REALM_NAME)
                 .encryptionKey(oldPassword)
-                .migration(realmMigration)
                 .schema(StringOnly.class)
                 .build();
 
@@ -191,7 +195,7 @@ public void deletingRealmAlsoClearsConfigurationCache() throws IOException {
         testRealm.close();
 
         // 2. Deletes the old Realm.
-        Realm.deleteRealm(config);
+        assertTrue(Realm.deleteRealm(config));
 
         // 3. Renames the new file to the old file name.
         assertTrue(copiedRealm.renameTo(new File(config.getRealmDirectory(), REALM_NAME)));
@@ -202,7 +206,6 @@ public void deletingRealmAlsoClearsConfigurationCache() throws IOException {
         RealmConfiguration newConfig = configFactory.createConfigurationBuilder()
                 .name(REALM_NAME)
                 .encryptionKey(newPassword)
-                .migration(realmMigration)
                 .schema(StringOnly.class)
                 .build();
 
@@ -261,36 +264,285 @@ public void run() {
         RealmCache.invokeWithGlobalRefCount(defaultConfig, new TestHelper.ExpectedCountCallback(0));
     }
 
+    @Test
+    public void getInstance_differentConfigurationsShouldNotBlockEachOther() throws InterruptedException {
+        final CountDownLatch bgThreadStarted = new CountDownLatch(1);
+        final CountDownLatch realm2CreatedLatch = new CountDownLatch(1);
+
+        final RealmConfiguration config1 = configFactory.createConfigurationBuilder()
+                .name("config1.realm")
+                .initialData(new Realm.Transaction() {
+                    @Override
+                    public void execute(Realm realm) {
+                        bgThreadStarted.countDown();
+                        TestHelper.awaitOrFail(realm2CreatedLatch);
+                    }
+                })
+                .build();
+
+        RealmConfiguration config2 = configFactory.createConfigurationBuilder()
+                .name("config2.realm")
+                .build();
+
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(config1);
+                realm.close();
+            }
+        });
+        thread.start();
+
+        TestHelper.awaitOrFail(bgThreadStarted);
+        Realm realm = Realm.getInstance(config2);
+        realm2CreatedLatch.countDown();
+        realm.close();
+        thread.join();
+    }
+
     @Test
     public void releaseCacheInOneThread() {
         // Tests release typed Realm instance.
         Realm realmA = RealmCache.createRealmOrGetFromCache(defaultConfig, Realm.class);
         Realm realmB = RealmCache.createRealmOrGetFromCache(defaultConfig, Realm.class);
-        RealmCache.release(realmA);
+        realmA.close();
         assertNotNull(realmA.sharedRealm);
-        RealmCache.release(realmB);
+        realmB.close();
         assertNull(realmB.sharedRealm);
         // No crash but warning in the log.
-        RealmCache.release(realmB);
+        realmB.close();
 
         // Tests release dynamic Realm instance.
         DynamicRealm dynamicRealmA = RealmCache.createRealmOrGetFromCache(defaultConfig,
                 DynamicRealm.class);
         DynamicRealm dynamicRealmB = RealmCache.createRealmOrGetFromCache(defaultConfig,
                 DynamicRealm.class);
-        RealmCache.release(dynamicRealmA);
+        dynamicRealmA.close();
         assertNotNull(dynamicRealmA.sharedRealm);
-        RealmCache.release(dynamicRealmB);
+        dynamicRealmB.close();
         assertNull(dynamicRealmB.sharedRealm);
         // No crash but warning in the log.
-        RealmCache.release(dynamicRealmB);
+        dynamicRealmB.close();
 
         // Tests both typed Realm and dynamic Realm in same thread.
         realmA = RealmCache.createRealmOrGetFromCache(defaultConfig, Realm.class);
         dynamicRealmA = RealmCache.createRealmOrGetFromCache(defaultConfig, DynamicRealm.class);
-        RealmCache.release(realmA);
+        realmA.close();
         assertNull(realmA.sharedRealm);
-        RealmCache.release(dynamicRealmA);
+        dynamicRealmA.close();
         assertNull(realmA.sharedRealm);
     }
+
+    @Test
+    @RunTestInLooperThread
+    public void getInstanceAsync_typedRealm() {
+        final RealmConfiguration configuration = looperThread.createConfiguration();
+        final AtomicBoolean realmCreated = new AtomicBoolean(false);
+        Realm.getInstanceAsync(configuration, new Realm.Callback() {
+            @Override
+            public void onSuccess(Realm realm) {
+                realmCreated.set(true);
+                assertEquals(1, Realm.getLocalInstanceCount(configuration));
+                realm.close();
+                looperThread.testComplete();
+            }
+        });
+        assertFalse(realmCreated.get());
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void getInstanceAsync_dynamicRealm() {
+        final RealmConfiguration configuration = looperThread.createConfiguration();
+        final AtomicBoolean realmCreated = new AtomicBoolean(false);
+        DynamicRealm.getInstanceAsync(configuration, new DynamicRealm.Callback() {
+            @Override
+            public void onSuccess(DynamicRealm realm) {
+                realmCreated.set(true);
+                assertEquals(1, Realm.getLocalInstanceCount(configuration));
+                realm.close();
+                looperThread.testComplete();
+            }
+        });
+        assertFalse(realmCreated.get());
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void getInstanceAsync_callbackDeliveredInFollowingEventLoopWhenLocalCacheExist() {
+        final RealmConfiguration configuration = looperThread.createConfiguration();
+        final AtomicBoolean realmCreated = new AtomicBoolean(false);
+        final Realm localRealm = Realm.getInstance(configuration);
+        Realm.getInstanceAsync(configuration, new Realm.Callback() {
+            @Override
+            public void onSuccess(Realm realm) {
+                realmCreated.set(true);
+                assertEquals(2, Realm.getLocalInstanceCount(configuration));
+                assertSame(realm, localRealm);
+                realm.close();
+                localRealm.close();
+                looperThread.testComplete();
+            }
+        });
+        assertFalse(realmCreated.get());
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void getInstanceAsync_callbackDeliveredInFollowingEventLoopWhenGlobalCacheExist() throws InterruptedException {
+        final RealmConfiguration configuration = looperThread.createConfiguration();
+        final AtomicBoolean realmCreated = new AtomicBoolean(false);
+        final CountDownLatch globalRealmCreated = new CountDownLatch(1);
+        final CountDownLatch getAsyncFinishedLatch = new CountDownLatch(1);
+
+        final Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(configuration);
+                globalRealmCreated.countDown();
+                TestHelper.awaitOrFail(getAsyncFinishedLatch);
+                realm.close();
+            }
+        });
+        thread.start();
+
+        TestHelper.awaitOrFail(globalRealmCreated);
+        Realm.getInstanceAsync(configuration, new Realm.Callback() {
+            @Override
+            public void onSuccess(Realm realm) {
+                realmCreated.set(true);
+                assertEquals(1, Realm.getLocalInstanceCount(configuration));
+                realm.close();
+                getAsyncFinishedLatch.countDown();
+                try {
+                    thread.join();
+                } catch (InterruptedException e) {
+                    fail();
+                }
+                looperThread.testComplete();
+            }
+        });
+        assertFalse(realmCreated.get());
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void getInstanceAsync_typedRealmShouldStillBeInitializedInBGIfOnlyDynamicRealmExists() {
+        final RealmConfiguration configuration = looperThread.createConfiguration();
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(configuration);
+        final AtomicBoolean realmCreated = new AtomicBoolean(false);
+
+        Realm.getInstanceAsync(configuration, new Realm.Callback() {
+            @Override
+            public void onSuccess(Realm realm) {
+                realmCreated.set(false);
+                assertEquals(2, Realm.getLocalInstanceCount(configuration));
+                dynamicRealm.close();
+                realm.close();
+                looperThread.testComplete();
+            }
+        });
+        // Callback should not be called immediately since we need to create column indices cache in bg thread.
+        // Only a local dynamic Realm instance existing at this time.
+        assertFalse(realmCreated.get());
+        assertEquals(1, Realm.getLocalInstanceCount(configuration));
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void getInstanceAsync_onError() {
+        final RealmConfiguration configuration =
+                looperThread.createConfigurationBuilder()
+                .assetFile("NotExistingFile")
+                .build();
+        Realm.getInstanceAsync(configuration, new Realm.Callback() {
+            @Override
+            public void onSuccess(Realm realm) {
+                fail();
+            }
+
+            @Override
+            public void onError(Throwable exception) {
+                assertTrue(exception instanceof RealmFileException);
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    // If the async task is canceled before the posted event to create Realm instance in caller thread, the event should
+    // just be ignored.
+    @Test
+    @RunTestInLooperThread
+    public void getInstanceAsync_cancelBeforePostShouldNotCreateRealmInstanceOnTheCallerThread() {
+        final AtomicReference<RealmAsyncTask> realmAsyncTasks = new AtomicReference<>();
+        final Runnable finishedRunnable = new Runnable() {
+            @Override
+            public void run() {
+                looperThread.testComplete();
+            }
+        };
+        final RealmConfiguration configuration = looperThread.createConfigurationBuilder()
+                .name("will_be_canceled")
+                .initialData(new Realm.Transaction() {
+                    @Override
+                    public void execute(Realm realm) {
+                        // The BG thread started to initial the first Realm instance. Post an event to the caller's
+                        // queue to cancel the task before the event to create the Realm instance in caller thread.
+                        looperThread.postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                assertNotNull(realmAsyncTasks.get());
+                                realmAsyncTasks.get().cancel();
+                                // Wait the async task to be terminated.
+                                TestHelper.waitRealmThreadExecutorFinish();
+                                // Finish the test.
+                                looperThread.postRunnable(finishedRunnable);
+                            }
+                        });
+                    }
+                })
+                .build();
+
+        realmAsyncTasks.set(Realm.getInstanceAsync(configuration, new Realm.Callback() {
+            @Override
+            public void onSuccess(Realm realm) {
+                fail();
+            }
+        }));
+    }
+
+    // The DynamicRealm and Realm with the same Realm path should share the same RealmCache
+    @Test
+    public void typedRealmAndDynamicRealmShareTheSameCache() {
+        final String DB_NAME = "same_name.realm";
+        RealmConfiguration config1 = configFactory.createConfigurationBuilder()
+                .name(DB_NAME)
+                .build();
+
+        RealmConfiguration config2 = configFactory.createConfigurationBuilder()
+                .name(DB_NAME)
+                .initialData(new Realm.Transaction() {
+                    @Override
+                    public void execute(Realm realm) {
+                        // Because of config1 doesn't have initialData block, these two configurations are not the same.
+                        // So if a Realm is created with config1, then create another Realm with config2 should just
+                        // fail before executing this block.
+                        fail();
+                    }
+                })
+                .build();
+
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(config1);
+        Realm realm = null;
+        try {
+            realm = Realm.getInstance(config2);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        } finally {
+            dynamicRealm.close();
+            if (realm != null) {
+                realm.close();
+            }
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java
index b44bcc868f..4ac5b1521a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmChangeListenerTests.java
@@ -26,6 +26,8 @@
 import org.junit.runner.RunWith;
 
 import io.realm.entities.AllTypes;
+import io.realm.entities.BacklinksSource;
+import io.realm.entities.BacklinksTarget;
 import io.realm.entities.Cat;
 import io.realm.entities.pojo.AllTypesRealmModel;
 import io.realm.rule.RunInLooperThread;
@@ -35,6 +37,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
 
 @RunWith(AndroidJUnit4.class)
 public class RealmChangeListenerTests {
@@ -225,4 +228,75 @@ public void onChange(RealmResults<DynamicRealmObject> result) {
         allTypes.setString(AllTypes.FIELD_STRING, "test data 1");
         dynamicRealm.commitTransaction();
     }
+
+    // 1. adding a listener on the children
+    // 2. modify parent
+    // 3. at least one child is modified
+    // 4. listener is not triggered (backlink)
+    // FIXME: will break when https://github.com/realm/realm-java/issues/4875 is solved
+    @Test
+    @RunTestInLooperThread
+    public void listenerOnChildChangeParent() {
+        final long[] nCalls = {0};
+        final Realm realm = Realm.getInstance(looperThread.getConfiguration());
+        TestHelper.populateLinkedDataSet(realm);
+
+        RealmResults<BacklinksTarget> backlinksTargets = realm.where(BacklinksTarget.class).findAll();
+        assertEquals(3, backlinksTargets.size());
+        assertTrue(backlinksTargets.last().getParents().isEmpty());
+        assertEquals(2, backlinksTargets.first().getParents().size());
+
+        looperThread.keepStrongReference(backlinksTargets);
+
+        backlinksTargets.addChangeListener(new RealmChangeListener<RealmResults<BacklinksTarget>>() {
+            @Override
+            public void onChange(RealmResults<BacklinksTarget> backlinksTargets) {
+                nCalls[0]++;
+            }
+        });
+
+        realm.beginTransaction();
+        BacklinksTarget target = backlinksTargets.last();
+        realm.where(BacklinksSource.class).findFirst().setChild(target);
+        realm.commitTransaction();
+
+        // backlinks are updated
+        assertEquals(1, backlinksTargets.last().getParents().size());
+        assertEquals(1, backlinksTargets.first().getParents().size());
+        assertEquals(0, nCalls[0]);
+        realm.close();
+        looperThread.testComplete();
+    }
+
+    // 1. adding a listener if on the parent
+    // 2. modify child
+    // 3. listener is triggered (forward link)
+    @Test@RunTestInLooperThread
+    public void listenerOnParentChangeChild() {
+        final long[] nCalls = {0};
+        final Realm realm = Realm.getInstance(looperThread.getConfiguration());
+        TestHelper.populateLinkedDataSet(realm);
+
+        RealmResults<BacklinksSource> backlinksSources = realm.where(BacklinksSource.class).findAll();
+        assertEquals(4, backlinksSources.size());
+
+        looperThread.keepStrongReference(backlinksSources);
+        backlinksSources.addChangeListener(new RealmChangeListener<RealmResults<BacklinksSource>>() {
+            @Override
+            public void onChange(RealmResults<BacklinksSource> backlinksSources) {
+                nCalls[0]++;
+            }
+        });
+
+        realm.beginTransaction();
+        BacklinksTarget backlinksTarget = realm.where(BacklinksTarget.class).findFirst();
+        backlinksTarget.setId(42);
+        realm.commitTransaction();
+
+        assertEquals(42, backlinksSources.first().getChild().getId());
+        assertEquals(1, nCalls[0]);
+
+        realm.close();
+        looperThread.testComplete();
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
index 7b191920be..633cbe6e64 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmConfigurationTests.java
@@ -16,42 +16,46 @@
 
 package io.realm;
 
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+import android.test.MoreAsserts;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
-
-import android.content.Context;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
-import android.test.MoreAsserts;
+import org.mockito.Mockito;
 
 import java.io.File;
 import java.io.IOException;
-import java.lang.reflect.Field;
 import java.util.Set;
 
+import io.reactivex.Flowable;
+import io.reactivex.Observable;
+import io.reactivex.Single;
 import io.realm.entities.AllTypes;
-import io.realm.entities.AllTypesPrimaryKey;
 import io.realm.entities.AnimalModule;
 import io.realm.entities.AssetFileModule;
 import io.realm.entities.Cat;
 import io.realm.entities.CatOwner;
-import io.realm.entities.CyclicType;
 import io.realm.entities.Dog;
 import io.realm.entities.HumanModule;
 import io.realm.entities.Owner;
+import io.realm.entities.StringAndInt;
+import io.realm.entities.StringOnly;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.modules.CompositeMediator;
 import io.realm.internal.modules.FilterableMediator;
 import io.realm.rule.TestRealmConfigurationFactory;
+import io.realm.rx.CollectionChange;
+import io.realm.rx.ObjectChange;
 import io.realm.rx.RealmObservableFactory;
 import io.realm.rx.RxObservableFactory;
-import rx.Observable;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -59,6 +63,7 @@
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Mockito.mock;
@@ -91,15 +96,8 @@ public void tearDown() throws Exception {
         }
     }
 
-    private void clearDefaultConfiguration() throws NoSuchFieldException, IllegalAccessException {
-        final Field field = Realm.class.getDeclaredField("defaultConfiguration");
-        field.setAccessible(true);
-        field.set(null, null);
-    }
-
     @Test
-    public void setDefaultConfiguration_nullThrows() throws NoSuchFieldException, IllegalAccessException {
-        clearDefaultConfiguration();
+    public void setDefaultConfiguration_nullThrows() {
         try {
             Realm.setDefaultConfiguration(null);
             fail();
@@ -107,6 +105,26 @@ public void setDefaultConfiguration_nullThrows() throws NoSuchFieldException, Il
         }
     }
 
+    @Test
+    public void getDefaultConfiguration_returnsTheSameObjectThatSetDefaultConfigurationSet() {
+        final RealmConfiguration config = new RealmConfiguration.Builder().build();
+        Realm.setDefaultConfiguration(config);
+
+        assertSame(config, Realm.getDefaultConfiguration());
+    }
+
+    @Test
+    public void getDefaultConfiguration_returnsNullAfterRemoveDefaultConfiguration() {
+        final RealmConfiguration defaultConfiguration = Realm.getDefaultConfiguration();
+        try {
+            Realm.removeDefaultConfiguration();
+
+            assertNull(Realm.getDefaultConfiguration());
+        } finally {
+            Realm.setDefaultConfiguration(defaultConfiguration);
+        }
+    }
+
     @Test
     public void getInstance_nullConfigThrows() {
         try {
@@ -229,7 +247,7 @@ public void constructBuilder_versionEqualWhenSchemaChangesThrows() {
         RealmConfiguration config = new RealmConfiguration.Builder(context)
                 .directory(configFactory.getRoot())
                 .schemaVersion(42)
-                .schema(Dog.class)
+                .schema(StringOnly.class)
                 .build();
         Realm.getInstance(config).close();
 
@@ -238,7 +256,7 @@ public void constructBuilder_versionEqualWhenSchemaChangesThrows() {
             config = new RealmConfiguration.Builder(context)
                     .directory(configFactory.getRoot())
                     .schemaVersion(42)
-                    .schema(AllTypesPrimaryKey.class)
+                    .schema(StringAndInt.class)
                     .build();
             realm = Realm.getInstance(config);
             fail("A migration should be required");
@@ -246,18 +264,15 @@ public void constructBuilder_versionEqualWhenSchemaChangesThrows() {
         }
     }
 
+    // Only Dog is included in the schema definition, but in order to create Dog, the Owner has to be defined as well.
     @Test
-    public void customSchemaDontIncludeLinkedClasses() {
+    public void schemaDoesNotContainAllDefinedObjectShouldThrow() {
         RealmConfiguration config = new RealmConfiguration.Builder(context)
                 .directory(configFactory.getRoot())
                 .schema(Dog.class)
                 .build();
+        thrown.expect(IllegalStateException.class);
         realm = Realm.getInstance(config);
-        try {
-            assertEquals(3, realm.getTable(Owner.class).getColumnCount());
-            fail("Owner should to be part of the schema");
-        } catch (IllegalArgumentException ignored) {
-        }
     }
 
     @Test
@@ -297,17 +312,16 @@ public void modules() {
     }
 
     @Test
-    public void setDefaultConfiguration() throws NoSuchFieldException, IllegalAccessException {
-        clearDefaultConfiguration();
+    public void setDefaultConfiguration() {
         Realm.setDefaultConfiguration(defaultConfig);
         realm = Realm.getDefaultInstance();
-        assertEquals(realm.getPath(), defaultConfig.getPath());
+        assertEquals(defaultConfig, realm.getConfiguration());
     }
 
     @Test
     public void getInstance() {
         realm = Realm.getInstance(defaultConfig);
-        assertEquals(realm.getPath(), defaultConfig.getPath());
+        assertEquals(defaultConfig, realm.getConfiguration());
     }
 
     @Test
@@ -337,26 +351,26 @@ public void deleteRealmIfMigrationNeeded() {
         // Populates v0 of a Realm with an object.
         RealmConfiguration config = new RealmConfiguration.Builder(context)
                 .directory(configFactory.getRoot())
-                .schema(Dog.class)
+                .schema(StringOnly.class)
                 .schemaVersion(0)
                 .build();
         Realm.deleteRealm(config);
         realm = Realm.getInstance(config);
         realm.beginTransaction();
-        realm.copyToRealm(new Dog("Foo"));
+        realm.copyToRealm(new StringOnly());
         realm.commitTransaction();
-        assertEquals(1, realm.where(Dog.class).count());
+        assertEquals(1, realm.where(StringOnly.class).count());
         realm.close();
 
         // Changes schema and verifies that Realm has been cleared.
         config = new RealmConfiguration.Builder(context)
                 .directory(configFactory.getRoot())
-                .schema(Owner.class, Dog.class)
+                .schema(StringOnly.class, StringAndInt.class)
                 .schemaVersion(1)
                 .deleteRealmIfMigrationNeeded()
                 .build();
         realm = Realm.getInstance(config);
-        assertEquals(0, realm.where(Dog.class).count());
+        assertEquals(0, realm.where(StringOnly.class).count());
     }
 
     @Test
@@ -382,17 +396,13 @@ public void upgradeVersionWithNoMigration() {
         assertEquals(0, realm.getVersion());
         realm.close();
 
-        // Version upgrades should always require a migration.
-        try {
-            realm = Realm.getInstance(new RealmConfiguration.Builder(context)
-                    .directory(configFactory.getRoot())
-                    .schemaVersion(42)
-                    .build());
-            fail();
-        } catch (RealmMigrationNeededException expected) {
-            // And it should come with a cause.
-            assertEquals("Realm on disk need to migrate from v0 to v42", expected.getMessage());
-        }
+        // Version upgrades only without any actual schema changes will just succeed, and the schema version will be
+        // set to the new one.
+        realm = Realm.getInstance(new RealmConfiguration.Builder(context)
+                .directory(configFactory.getRoot())
+                .schemaVersion(42)
+                .build());
+        assertEquals(42, realm.getVersion());
     }
 
     @Test
@@ -402,6 +412,13 @@ public void equals() {
         assertTrue(config1.equals(config2));
     }
 
+    @Test
+    public void equals_respectReadOnly() {
+        RealmConfiguration config1 = new RealmConfiguration.Builder(context).assetFile("foo").build();
+        RealmConfiguration config2 = new RealmConfiguration.Builder(context).assetFile("foo").readOnly().build();
+        assertFalse(config1.equals(config2));
+    }
+
     @Test
     public void equalsWhenRxJavaUnavailable() {
         // Test for https://github.com/realm/realm-java/issues/2416
@@ -519,11 +536,11 @@ public void encryptionKey_differentEncryptionKeysThrows() {
     public void schema_differentSchemasThrows() {
         RealmConfiguration config1 = new RealmConfiguration.Builder(context)
                 .directory(configFactory.getRoot())
-                .schema(AllTypes.class)
+                .schema(StringOnly.class)
                 .build();
         RealmConfiguration config2 = new RealmConfiguration.Builder(context)
                 .directory(configFactory.getRoot())
-                .schema(CyclicType.class).build();
+                .schema(StringAndInt.class).build();
 
         Realm realm1 = Realm.getInstance(config1);
         try {
@@ -688,52 +705,82 @@ public void modelClasses_forFilterableMediator() throws Exception {
     public void rxFactory() {
         final RxObservableFactory dummyFactory = new RxObservableFactory() {
             @Override
-            public Observable<Realm> from(Realm realm) {
+            public Flowable<Realm> from(Realm realm) {
+                return null;
+            }
+
+            @Override
+            public Flowable<DynamicRealm> from(DynamicRealm realm) {
+                return null;
+            }
+
+            @Override
+            public <E> Flowable<RealmResults<E>> from(Realm realm, RealmResults<E> results) {
                 return null;
             }
 
             @Override
-            public Observable<DynamicRealm> from(DynamicRealm realm) {
+            public <E> Observable<CollectionChange<RealmResults<E>>> changesetsFrom(Realm realm, RealmResults<E> results) {
                 return null;
             }
 
             @Override
-            public <E extends RealmModel> Observable<RealmResults<E>> from(Realm realm, RealmResults<E> results) {
+            public <E> Flowable<RealmResults<E>> from(DynamicRealm realm, RealmResults<E> results) {
                 return null;
             }
 
             @Override
-            public Observable<RealmResults<DynamicRealmObject>> from(DynamicRealm realm, RealmResults<DynamicRealmObject> results) {
+            public <E> Observable<CollectionChange<RealmResults<E>>> changesetsFrom(DynamicRealm realm, RealmResults<E> results) {
                 return null;
             }
 
             @Override
-            public <E extends RealmModel> Observable<RealmList<E>> from(Realm realm, RealmList<E> list) {
+            public <E> Flowable<RealmList<E>> from(Realm realm, RealmList<E> list) {
                 return null;
             }
 
             @Override
-            public Observable<RealmList<DynamicRealmObject>> from(DynamicRealm realm, RealmList<DynamicRealmObject> list) {
+            public <E> Observable<CollectionChange<RealmList<E>>> changesetsFrom(Realm realm, RealmList<E> list) {
                 return null;
             }
 
             @Override
-            public <E extends RealmModel> Observable<E> from(Realm realm, E object) {
+            public <E> Flowable<RealmList<E>> from(DynamicRealm realm, RealmList<E> list) {
                 return null;
             }
 
             @Override
-            public Observable<DynamicRealmObject> from(DynamicRealm realm, DynamicRealmObject object) {
+            public <E> Observable<CollectionChange<RealmList<E>>> changesetsFrom(DynamicRealm realm, RealmList<E> list) {
                 return null;
             }
 
             @Override
-            public <E extends RealmModel> Observable<RealmQuery<E>> from(Realm realm, RealmQuery<E> query) {
+            public <E extends RealmModel> Flowable<E> from(Realm realm, E object) {
                 return null;
             }
 
             @Override
-            public Observable<RealmQuery<DynamicRealmObject>> from(DynamicRealm realm, RealmQuery<DynamicRealmObject> query) {
+            public <E extends RealmModel> Observable<ObjectChange<E>> changesetsFrom(Realm realm, E object) {
+                return null;
+            }
+
+            @Override
+            public Flowable<DynamicRealmObject> from(DynamicRealm realm, DynamicRealmObject object) {
+                return null;
+            }
+
+            @Override
+            public Observable<ObjectChange<DynamicRealmObject>> changesetsFrom(DynamicRealm realm, DynamicRealmObject object) {
+                return null;
+            }
+
+            @Override
+            public <E> Single<RealmQuery<E>> from(Realm realm, RealmQuery<E> query) {
+                return null;
+            }
+
+            @Override
+            public <E> Single<RealmQuery<E>> from(DynamicRealm realm, RealmQuery<E> query) {
                 return null;
             }
         };
@@ -819,7 +866,7 @@ public void initialDataTransactionExecutionCount() {
 
         realm = Realm.getInstance(configuration);
         realm.close();
-        verify(transaction, times(1)).execute(realm);
+        verify(transaction, times(1)).execute(Mockito.any(Realm.class));
 
         realm = Realm.getInstance(configuration);
         realm.close();
@@ -846,6 +893,41 @@ public void initialDataTransactionAssetFile() throws IOException {
         verify(transaction, never()).execute(realm);
     }
 
+    @Test
+    public void initialDataTransactionThrows() {
+        final RuntimeException exception = new RuntimeException();
+
+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()
+                .initialData(new Realm.Transaction() {
+                    @Override
+                    public void execute(final Realm realm) {
+                        throw exception;
+                    }
+                }).build();
+
+        assertFalse(new File(configuration.getPath()).exists());
+
+        Realm realm = null;
+        try {
+            realm = Realm.getInstance(configuration);
+            fail();
+        } catch (RuntimeException expected) {
+            assertSame(exception, expected);
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+        }
+
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(configuration);
+        try {
+            // The schema should not be initialized.
+            assertNull(dynamicRealm.getSchema().get(StringOnly.CLASS_NAME));
+        } finally {
+            dynamicRealm.close();
+        }
+    }
+
     @Test
     public void assetFileNullAndEmptyFileName() {
         try {
@@ -883,7 +965,7 @@ public void assetFileFakeFile() {
             Realm.getInstance(configuration);
             fail();
         } catch (RealmFileException expected) {
-            assertEquals(expected.getKind(), RealmFileException.Kind.ACCESS_ERROR);
+            assertEquals(RealmFileException.Kind.ACCESS_ERROR, expected.getKind());
         }
     }
 
@@ -959,4 +1041,58 @@ public void detectMissingEqualsInCustomMigration() {
             realm.close();
         }
     }
+
+    @Test
+    public void readOnly_initialTransaction_throws() {
+        // Check assetFile(), then initialTransaction();
+        RealmConfiguration.Builder config = new RealmConfiguration.Builder()
+                .assetFile("foo")
+                .readOnly()
+                .initialData(new Realm.Transaction() {
+                    @Override
+                    public void execute(Realm realm) {
+                        // Do nothing
+                    }
+                });
+
+        try {
+            config.build();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+    }
+
+    @Test
+    public void readOnly_deleteRealmIfMigrationRequired_throws() {
+        try {
+            // This test doesn't actually fail on 'deleteRealmIfMigrationNeeded' + 'readOnly' but on
+            // 'assetFile' + 'deleteRealmIfMigrationNeed()'. This test is primarely here to prevent this
+            // case from accidentally parsing in the future.
+            new RealmConfiguration.Builder()
+                    .assetFile("foo")
+                    .readOnly()
+                    .deleteRealmIfMigrationNeeded()
+                    .build();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+    }
+
+    @Test
+    public void readOnly_compactOnLaunch_throws() {
+        try {
+            new RealmConfiguration.Builder()
+                    .assetFile("foo")
+                    .readOnly()
+                    .compactOnLaunch(new CompactOnLaunchCallback() {
+                        @Override
+                        public boolean shouldCompact(long totalBytes, long usedBytes) {
+                            return false;
+                        }
+                    })
+                    .build();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java b/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
index 1b41af1114..9f7f26123d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmInMemoryTest.java
@@ -81,14 +81,14 @@ public void inMemoryRealm() {
         dog.setName("DinoDog");
         testRealm.commitTransaction();
 
-        assertEquals(testRealm.where(Dog.class).count(), 1);
-        assertEquals(testRealm.where(Dog.class).findFirst().getName(), "DinoDog");
+        assertEquals(1, testRealm.where(Dog.class).count());
+        assertEquals("DinoDog", testRealm.where(Dog.class).findFirst().getName());
 
         testRealm.close();
         // After all references to the in-mem-realm closed,
         // in-mem-realm with same identifier should create a fresh new instance.
         testRealm = Realm.getInstance(inMemConf);
-        assertEquals(testRealm.where(Dog.class).count(), 0);
+        assertEquals(0, testRealm.where(Dog.class).count());
     }
 
     // Two in-memory Realms with different names should not affect each other.
@@ -110,12 +110,12 @@ public void inMemoryRealmWithDifferentNames() {
         dog2.setName("UFODog");
         testRealm2.commitTransaction();
 
-        assertEquals(testRealm.where(Dog.class).count(), 1);
+        assertEquals(1, testRealm.where(Dog.class).count());
         //noinspection ConstantConditions
-        assertEquals(testRealm.where(Dog.class).findFirst().getName(), "DinoDog");
-        assertEquals(testRealm2.where(Dog.class).count(), 1);
+        assertEquals("DinoDog", testRealm.where(Dog.class).findFirst().getName());
+        assertEquals(1, testRealm2.where(Dog.class).count());
         //noinspection ConstantConditions
-        assertEquals(testRealm2.where(Dog.class).findFirst().getName(), "UFODog");
+        assertEquals("UFODog", testRealm2.where(Dog.class).findFirst().getName());
 
         testRealm2.close();
     }
@@ -161,13 +161,13 @@ public void writeCopyTo() {
         // Tests a normal Realm file.
         testRealm.writeCopyTo(new File(configFactory.getRoot(), fileName));
         Realm onDiskRealm = Realm.getInstance(conf);
-        assertEquals(onDiskRealm.where(Dog.class).count(), 1);
+        assertEquals(1, onDiskRealm.where(Dog.class).count());
         onDiskRealm.close();
 
         // Tests a encrypted Realm file.
         testRealm.writeEncryptedCopyTo(new File(configFactory.getRoot(), encFileName), key);
         onDiskRealm = Realm.getInstance(encConf);
-        assertEquals(onDiskRealm.where(Dog.class).count(), 1);
+        assertEquals(1, onDiskRealm.where(Dog.class).count());
         onDiskRealm.close();
         // Tests with a wrong key to see if it fails as expected.
         try {
@@ -178,7 +178,7 @@ public void writeCopyTo() {
             Realm.getInstance(wrongKeyConf);
             fail("Realm.getInstance should fail with RealmFileException");
         } catch (RealmFileException expected) {
-            assertEquals(expected.getKind(), RealmFileException.Kind.ACCESS_ERROR);
+            assertEquals(RealmFileException.Kind.ACCESS_ERROR, expected.getKind());
         }
     }
 
@@ -207,7 +207,7 @@ public void run() {
                 realm.commitTransaction();
 
                 try {
-                    assertEquals(realm.where(Dog.class).count(), 1);
+                    assertEquals(1, realm.where(Dog.class).count());
                 } catch (AssertionFailedError afe) {
                     threadError[0] = afe;
                     realm.close();
@@ -237,7 +237,7 @@ public void run() {
 
         // Refreshes will be ran in the next loop, manually refreshes it here.
         testRealm.waitForChange();
-        assertEquals(testRealm.where(Dog.class).count(), 1);
+        assertEquals(1, testRealm.where(Dog.class).count());
 
         // Step 3.
         // Releases the main thread Realm reference, and the worker thread holds the reference still.
@@ -246,7 +246,7 @@ public void run() {
         // Step 4.
         // Creates a new Realm reference in main thread and checks the data.
         testRealm = Realm.getInstance(inMemConf);
-        assertEquals(testRealm.where(Dog.class).count(), 1);
+        assertEquals(1, testRealm.where(Dog.class).count());
         testRealm.close();
 
         // Let the worker thread continue.
@@ -258,6 +258,6 @@ public void run() {
 
         // Since all previous Realm instances has been closed before, below will create a fresh new in-mem-realm instance.
         testRealm = Realm.getInstance(inMemConf);
-        assertEquals(testRealm.where(Dog.class).count(), 0);
+        assertEquals(0, testRealm.where(Dog.class).count());
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java b/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
index 76c5c4c377..56649a1cf1 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmInterprocessTest.java
@@ -282,7 +282,7 @@ public void testCreateInitialRealm() throws InterruptedException {
             public void run() {
                 // Step 1
                 testRealm = Realm.getInstance(new RealmConfiguration.Builder(getContext()).build());
-                assertEquals(testRealm.where(AllTypes.class).count(), 0);
+                assertEquals(0, testRealm.where(AllTypes.class).count());
                 testRealm.beginTransaction();
                 testRealm.createObject(AllTypes.class);
                 testRealm.commitTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
index 2d50dacb12..c5ea5c07a1 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmJsonTests.java
@@ -20,11 +20,8 @@
 import android.os.Build;
 import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
-import android.text.TextUtils;
 import android.util.Base64;
 
-import com.google.gson.internal.bind.util.ISO8601Utils;
-
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -38,6 +35,8 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.charset.Charset;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
 import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Date;
@@ -54,6 +53,7 @@
 import io.realm.entities.OwnerPrimaryKey;
 import io.realm.entities.RandomPrimaryKey;
 import io.realm.exceptions.RealmException;
+import io.realm.internal.Util;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static io.realm.internal.test.ExtraTests.assertArrayEquals;
@@ -391,7 +391,7 @@ public void createFromJson_respectDefaultValues() throws JSONException {
         assertEquals(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE,
                 managedObj.getFieldIgnored());
         assertEquals(DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE, managedObj.getFieldString());
-        assertFalse(TextUtils.isEmpty(managedObj.getFieldRandomString()));
+        assertFalse(Util.isEmptyString(managedObj.getFieldRandomString()));
         assertEquals(DefaultValueOfField.FIELD_SHORT_DEFAULT_VALUE, managedObj.getFieldShort());
         assertEquals(DefaultValueOfField.FIELD_INT_DEFAULT_VALUE, managedObj.getFieldInt());
         assertEquals(fieldLongPrimaryKeyValue, managedObj.getFieldLongPrimaryKey());
@@ -442,7 +442,7 @@ public void createFromJson_defaultValuesAreIgnored() throws JSONException {
         json.put(DefaultValueOfField.FIELD_FLOAT, fieldFloatValue);
         json.put(DefaultValueOfField.FIELD_DOUBLE, fieldDoubleValue);
         json.put(DefaultValueOfField.FIELD_BOOLEAN, fieldBooleanValue);
-        json.put(DefaultValueOfField.FIELD_DATE, ISO8601Utils.format(fieldDateValue, true));
+        json.put(DefaultValueOfField.FIELD_DATE, getISO8601Date(fieldDateValue));
         json.put(DefaultValueOfField.FIELD_BINARY, Base64.encodeToString(fieldBinaryValue, Base64.DEFAULT));
         // Value for 'fieldObject'
         final JSONObject fieldObjectJson = new JSONObject();
@@ -496,6 +496,13 @@ public void createFromJson_defaultValuesAreIgnored() throws JSONException {
         assertEquals(3, realm.where(RandomPrimaryKey.class).count());
     }
 
+    private String getISO8601Date(Date date) {
+        TimeZone tz = TimeZone.getTimeZone("UTC");
+        DateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"); // Quoted "Z" to indicate UTC, no timezone offset
+        df.setTimeZone(tz);
+        return df.format(date);
+    }
+
     @Test
     public void updateFromJson_defaultValuesAreIgnored() throws JSONException {
         final long fieldLongPrimaryKeyValue = DefaultValueOfField.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE + 1;
@@ -535,7 +542,7 @@ public void updateFromJson_defaultValuesAreIgnored() throws JSONException {
         json.put(DefaultValueOfField.FIELD_FLOAT, fieldFloatValue);
         json.put(DefaultValueOfField.FIELD_DOUBLE, fieldDoubleValue);
         json.put(DefaultValueOfField.FIELD_BOOLEAN, fieldBooleanValue);
-        json.put(DefaultValueOfField.FIELD_DATE, ISO8601Utils.format(fieldDateValue, true));
+        json.put(DefaultValueOfField.FIELD_DATE, getISO8601Date(fieldDateValue));
         json.put(DefaultValueOfField.FIELD_BINARY, Base64.encodeToString(fieldBinaryValue, Base64.DEFAULT));
         // value for 'fieldObject'
         final JSONObject fieldObjectJson = new JSONObject();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
index 2e802eb7f2..e9c94fb610 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmLinkTests.java
@@ -534,6 +534,9 @@ public void linkIsNull() {
 
         RealmResults<Owner> owners2 = testRealm.where(Owner.class).isNull("cat").findAll();
         assertEquals(1, owners2.size());
+
+        RealmResults<Owner> owners3 = testRealm.where(Owner.class).isNull("dogs.birthday").findAll();
+        assertEquals(0, owners3.size());
     }
 
     @Test
@@ -547,6 +550,27 @@ public void linkIsNotNull() {
 
         RealmResults<Owner> owners2 = testRealm.where(Owner.class).isNotNull("cat").findAll();
         assertEquals(0, owners2.size());
+
+        RealmResults<Owner> owners3 = testRealm.where(Owner.class).isNotNull("dogs.birthday").findAll();
+        assertEquals(1, owners3.size());
+    }
+
+    @Test
+    public void isEmpty() {
+        RealmResults<Owner> owners1 = testRealm.where(Owner.class).isEmpty("cat.name").findAll();
+        assertEquals(0, owners1.size());
+
+        RealmResults<Owner> owners2 = testRealm.where(Owner.class).isEmpty("dogs.name").findAll();
+        assertEquals(0, owners2.size());
+    }
+
+    @Test
+    public void isNotEmpty() {
+        RealmResults<Owner> owners1 = testRealm.where(Owner.class).isNotEmpty("cat.name").findAll();
+        assertEquals(1, owners1.size());
+
+        RealmResults<Owner> owners2 = testRealm.where(Owner.class).isNotEmpty("dogs.name").findAll();
+        assertEquals(1, owners2.size());
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
index 038ccc905d..6547300fed 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
@@ -18,6 +18,7 @@
 
 import android.support.test.runner.AndroidJUnit4;
 
+import org.hamcrest.CoreMatchers;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -28,8 +29,8 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.Cat;
@@ -38,7 +39,6 @@
 import io.realm.entities.Dog;
 import io.realm.entities.Owner;
 import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.Table;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -46,6 +46,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -102,6 +103,7 @@ public void tearDown() throws Exception {
 
     private RealmList<Dog> createDeletedRealmList() {
         Owner owner = realm.where(Owner.class).findFirst();
+        //noinspection ConstantConditions
         RealmList<Dog> dogs = owner.getDogs();
 
         realm.beginTransaction();
@@ -139,9 +141,11 @@ public void add_unmanagedMode() {
         assertEquals(object, list.get(0));
     }
 
-    @Test (expected = IllegalArgumentException.class)
+    @Test
     public void add_nullInUnmanagedMode() {
-        new RealmList<AllTypes>().add(null);
+        final RealmList<AllTypes> list = new RealmList<>();
+        assertTrue(list.add(null));
+        assertEquals(1, list.size());
     }
 
     @Test
@@ -187,9 +191,25 @@ public void add_objectAtIndexInManagedMode() {
         assertEquals("Dog 42", collection.get(0).getName());
     }
 
-    @Test (expected = IllegalArgumentException.class)
+    @Test
+    public void add_objectAtInvalidIndexInManagedModeThrows() {
+        final int initialDogCount = realm.where(Dog.class).findAll().size();
+
+        realm.beginTransaction();
+        try {
+            final int invalidIndex = collection.size() + 1;
+            collection.add(invalidIndex, new Dog("Dog 42"));
+            fail();
+        } catch (IndexOutOfBoundsException e) {
+            assertEquals(initialDogCount, realm.where(Dog.class).findAll().size());
+        }
+    }
+
+    @Test
     public void add_nullAtIndexInUnmanagedMode() {
-        new RealmList<AllTypes>().add(0, null);
+        final RealmList<AllTypes> list = new RealmList<>();
+        list.add(0, null);
+        assertEquals(1, list.size());
     }
 
     @Test
@@ -221,11 +241,9 @@ public void set_managedMode() {
 
     @Test
     public void set_nullInUnmanagedMode() {
-        @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
-        RealmList<AllTypes> list = new RealmList<AllTypes>();
+        RealmList<AllTypes> list = new RealmList<>();
         list.add(new AllTypes());
-        thrown.expect(IllegalArgumentException.class);
-        list.set(0, null);
+        assertNotNull(list.set(0, null));
     }
 
     @Test
@@ -471,6 +489,20 @@ public void remove_byIndex() {
 
         assertEquals(dog5, removedDog);
         assertEquals(TEST_SIZE - 1, dogs.size());
+        assertEquals(TEST_SIZE, realm.where(Dog.class).count());
+    }
+
+    @Test
+    public void remove_first() {
+        Owner owner = realm.where(Owner.class).findFirst();
+        RealmList<Dog> dogs = owner.getDogs();
+
+        realm.beginTransaction();
+        dogs.remove(0);
+        realm.commitTransaction();
+
+        assertEquals(TEST_SIZE - 1, dogs.size());
+        assertEquals(TEST_SIZE, realm.where(Dog.class).count());
     }
 
     @Test
@@ -483,6 +515,7 @@ public void remove_last() {
         realm.commitTransaction();
 
         assertEquals(TEST_SIZE - 1, dogs.size());
+        assertEquals(TEST_SIZE, realm.where(Dog.class).count());
     }
 
     @Test
@@ -508,6 +541,7 @@ public void remove_byObject() {
 
         assertTrue(result);
         assertEquals(TEST_SIZE - 1, dogs.size());
+        assertEquals(TEST_SIZE, realm.where(Dog.class).count());
     }
 
     @Test
@@ -608,7 +642,7 @@ public void removeAll_unmanaged_wrongClass() {
     }
 
     @Test
-    public void remove_allAfterContainerObjectRemoved() {
+    public void removeAll_afterContainerObjectRemoved() {
         RealmList<Dog> dogs = createDeletedRealmList();
 
         realm.beginTransaction();
@@ -616,6 +650,14 @@ public void remove_allAfterContainerObjectRemoved() {
         dogs.removeAll(Collections.<Dog>emptyList());
     }
 
+    @Test
+    public void removeAll_outsideTransaction() {
+        List<Dog> objectsToRemove = Collections.singletonList(collection.get(0));
+        thrown.expect(IllegalStateException.class);
+        thrown.expectMessage(CoreMatchers.containsString("Objects can only be removed from inside a write transaction"));
+        collection.removeAll(objectsToRemove);
+    }
+
     @Test
     public void get_afterContainerObjectRemoved() {
         RealmList<Dog> dogs = createDeletedRealmList();
@@ -658,12 +700,12 @@ public void where_afterContainerObjectRemoved() {
     @Test
     public void toString_AfterContainerObjectRemoved() {
         RealmList<Dog> dogs = createDeletedRealmList();
-        assertEquals("Dog@[invalid]", dogs.toString());
+        assertEquals("RealmList<Dog>@[invalid]", dogs.toString());
     }
 
     @Test
     public void toString_managedMode() {
-        StringBuilder sb = new StringBuilder("Dog@[");
+        StringBuilder sb = new StringBuilder("RealmList<Dog>@[");
         for (int i = 0; i < collection.size() - 1; i++) {
             sb.append(((RealmObjectProxy) (collection.get(i))).realmGet$proxyState().getRow$realm().getIndex());
             sb.append(",");
@@ -760,66 +802,6 @@ public void realmMethods_onDeletedLinkView() {
         }
     }
 
-    @Test
-    public void removeAllFromRealm() {
-        Owner owner = realm.where(Owner.class).findFirst();
-        RealmList<Dog> dogs = owner.getDogs();
-        assertEquals(TEST_SIZE, dogs.size());
-
-        realm.beginTransaction();
-        dogs.deleteAllFromRealm();
-        realm.commitTransaction();
-        assertEquals(0, dogs.size());
-        assertEquals(0, realm.where(Dog.class).count());
-    }
-
-    @Test
-    public void removeAllFromRealm_outsideTransaction() {
-        Owner owner = realm.where(Owner.class).findFirst();
-        RealmList<Dog> dogs = owner.getDogs();
-        try {
-            dogs.deleteAllFromRealm();
-            fail("removeAllFromRealm should be called in a transaction.");
-        } catch (IllegalStateException e) {
-            assertEquals("Changing Realm data can only be done from inside a write transaction.", e.getMessage());
-        }
-    }
-
-    @Test
-    public void removeAllFromRealm_emptyList() {
-        RealmList<Dog> dogs = realm.where(Owner.class).findFirst().getDogs();
-        assertEquals(TEST_SIZE, dogs.size());
-
-        realm.beginTransaction();
-        dogs.deleteAllFromRealm();
-        realm.commitTransaction();
-        assertEquals(0, dogs.size());
-        assertEquals(0, realm.where(Dog.class).count());
-
-        // The dogs is empty now.
-        realm.beginTransaction();
-        dogs.deleteAllFromRealm();
-        realm.commitTransaction();
-        assertEquals(0, dogs.size());
-        assertEquals(0, realm.where(Dog.class).count());
-
-    }
-
-    @Test
-    public void removeAllFromRealm_invalidListShouldThrow() {
-        RealmList<Dog> dogs = realm.where(Owner.class).findFirst().getDogs();
-        assertEquals(TEST_SIZE, dogs.size());
-        realm.close();
-        realm = null;
-
-        try {
-            dogs.deleteAllFromRealm();
-            fail("dogs is invalid and it should throw an exception");
-        } catch (IllegalStateException e) {
-            assertEquals("This Realm instance has already been closed, making it unusable.", e.getMessage());
-        }
-    }
-
     @Test
     public void add_set_objectFromOtherThread() {
         final CountDownLatch finishedLatch = new CountDownLatch(1);
@@ -869,7 +851,7 @@ public void add_set_dynamicObjectFromOtherThread() throws Throwable {
         final DynamicRealmObject dynDog = dynamicRealm.where(Dog.CLASS_NAME).findFirst();
         final String expectedMsg = "Cannot copy an object to a Realm instance created in another thread.";
 
-        final AtomicReference<Throwable> thrownErrorRef = new AtomicReference<Throwable>();
+        final AtomicReference<Throwable> thrownErrorRef = new AtomicReference<>();
 
         new Thread(new Runnable() {
             @Override
@@ -928,6 +910,7 @@ public void add_set_withWrongDynamicObjectType() {
         dynamicRealm.beginTransaction();
         RealmList<DynamicRealmObject> list = dynamicRealm.createObject(Owner.CLASS_NAME)
                 .getList(Owner.FIELD_DOGS);
+        list.add(dynamicRealm.createObject(Dog.CLASS_NAME));
         DynamicRealmObject dynCat = dynamicRealm.createObject(Cat.CLASS_NAME);
 
         try {
@@ -961,12 +944,14 @@ public void add_set_withWrongDynamicObjectType() {
     @Test
     public void add_set_dynamicObjectCreatedFromTypedRealm() {
         final String expectedMsg = "Cannot copy DynamicRealmObject between Realm instances.";
+        //noinspection ConstantConditions
         DynamicRealmObject dynDog = new DynamicRealmObject(realm.where(Dog.class).findFirst());
         DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
 
         dynamicRealm.beginTransaction();
         RealmList<DynamicRealmObject> list = dynamicRealm.createObject(Owner.CLASS_NAME)
                 .getList(Owner.FIELD_DOGS);
+        list.add(dynamicRealm.createObject(Dog.CLASS_NAME));
 
         try {
             list.add(dynDog);
@@ -1117,7 +1102,7 @@ public void createSnapshot_shouldUseTargetTable() {
         realm.commitTransaction();
         assertEquals(sizeBefore - 1, collection.size());
 
-        assertNotNull(collection.view);
-        assertEquals(collection.view.getTargetTable().getName(), snapshot.getTable().getName());
+        assertNotNull(collection.getOsList());
+        assertEquals(collection.getOsList().getTargetTable().getName(), snapshot.getTable().getName());
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
index 1e04dca3e3..91e0d6945b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -20,6 +20,7 @@
 import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 
+import org.hamcrest.CoreMatchers;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -31,10 +32,13 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.util.Date;
+import java.util.Locale;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.AnnotationTypes;
+import io.realm.entities.CatOwner;
+import io.realm.entities.Dog;
 import io.realm.entities.FieldOrder;
 import io.realm.entities.NullTypes;
 import io.realm.entities.PrimaryKeyAsBoxedByte;
@@ -47,6 +51,7 @@
 import io.realm.entities.PrimaryKeyAsShort;
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.entities.StringOnly;
+import io.realm.entities.StringOnlyRequired;
 import io.realm.entities.Thread;
 import io.realm.entities.migration.MigrationClassRenamed;
 import io.realm.entities.migration.MigrationFieldRenameAndAdd;
@@ -57,13 +62,17 @@
 import io.realm.entities.migration.MigrationPosteriorIndexOnly;
 import io.realm.entities.migration.MigrationPriorIndexOnly;
 import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.OsObjectStore;
 import io.realm.internal.Table;
 import io.realm.migration.MigrationPrimaryKey;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -90,6 +99,18 @@ public void tearDown() {
         }
     }
 
+    private void assertPKField(Realm realm, String className, String expectedName, long expectedIndex) {
+        String pkField = OsObjectStore.getPrimaryKeyForObject(realm.sharedRealm, className);
+        assertNotNull(pkField);
+        RealmObjectSchema objectSchema = realm.getSchema().get(className);
+        assertNotNull(objectSchema);
+        assertTrue(objectSchema.hasField(expectedName));
+        assertEquals(expectedName, pkField);
+        //noinspection ConstantConditions
+        assertEquals(expectedIndex,
+                realm.sharedRealm.getTable(Table.getTableNameForClass(className)).getColumnIndex(pkField));
+    }
+
     @Test
     public void getInstance_realmClosedAfterMigrationException() throws IOException {
         String REALM_NAME = "default0.realm";
@@ -121,7 +142,7 @@ public void localColumnIndices() throws IOException {
         // V1 config
         RealmConfiguration v1Config = configFactory.createConfigurationBuilder()
                 .name(MIGRATED_REALM)
-                .schema(AllTypes.class)
+                .schema(StringOnly.class)
                 .schemaVersion(1)
                 .build();
         Realm oldRealm = Realm.getInstance(v1Config);
@@ -140,7 +161,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
 
         RealmConfiguration v2Config = configFactory.createConfigurationBuilder()
                 .name(MIGRATED_REALM)
-                .schema(AllTypes.class, FieldOrder.class)
+                .schema(StringOnly.class, FieldOrder.class)
                 .schemaVersion(2)
                 .migration(migration)
                 .build();
@@ -151,7 +172,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         RealmConfiguration newConfig = configFactory.createConfigurationBuilder()
                 .name(NEW_REALM)
                 .schemaVersion(2)
-                .schema(AllTypes.class, FieldOrder.class)
+                .schema(StringOnly.class, FieldOrder.class)
                 .build();
         Realm newRealm = Realm.getInstance(newConfig);
         newRealm.close();
@@ -166,7 +187,7 @@ public void notSettingIndexThrows() {
 
         // Creates v0 of the Realm.
         RealmConfiguration originalConfig = configFactory.createConfigurationBuilder()
-                .schema(AllTypes.class)
+                .schema(StringOnly.class)
                 .build();
         Realm.getInstance(originalConfig).close();
 
@@ -184,7 +205,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
 
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
                 .schemaVersion(1)
-                .schema(AllTypes.class, AnnotationTypes.class)
+                .schema(StringOnly.class, AnnotationTypes.class)
                 .migration(migration)
                 .build();
         try {
@@ -228,9 +249,8 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
             realm = Realm.getInstance(realmConfig);
             fail();
         } catch (RealmMigrationNeededException e) {
-            if (!e.getMessage().equals("Primary key not defined for field 'id' in existing Realm file. @PrimaryKey was added.")) {
-                fail(e.toString());
-            }
+            assertThat(e.getMessage(), CoreMatchers.containsString(
+                    "Primary Key for class 'AnnotationTypes' has been added"));
         } finally {
             if (realm != null) {
                 realm.close();
@@ -266,9 +286,8 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
             realm = Realm.getInstance(realmConfig);
             fail();
         } catch (RealmMigrationNeededException e) {
-            if (!e.getMessage().equals("Primary Key defined for field chars was removed.")) {
-                fail(e.toString());
-            }
+            assertThat(e.getMessage(),
+                    CoreMatchers.containsString("Primary Key for class 'StringOnly' has been removed."));
         } finally {
             if (realm != null) {
                 realm.close();
@@ -305,9 +324,8 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
             realm = Realm.getInstance(realmConfig);
             fail();
         } catch (RealmMigrationNeededException e) {
-            if (!e.getMessage().equals("Primary Key annotation definition was changed, from field id to field name")) {
-                fail(e.toString());
-            }
+            assertThat(e.getMessage(), CoreMatchers.containsString(
+                    "Primary Key for class 'PrimaryKeyAsString' has changed from 'id' to 'name'."));
         } finally {
             if (realm != null) {
                 realm.close();
@@ -326,22 +344,23 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
      * @param createBase create a schema named "MigrationPrimaryKey" instead of {@code className} if {@code true}
      */
     private void buildInitialMigrationSchema(final String className, final boolean createBase) {
-        Realm realm = Realm.getInstance(configFactory.createConfigurationBuilder().build());
-        realm.executeTransaction(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                // First, removes an existing schema.
-                realm.getSchema().remove(className);
-                // Then recreates the deleted schema or builds a base schema.
-                realm.getSchema()
-                        .create(createBase ? MigrationPrimaryKey.CLASS_NAME : className)
-                        .addField(MigrationPrimaryKey.FIELD_FIRST,   Byte.class)
-                        .addField(MigrationPrimaryKey.FIELD_SECOND,  Short.class)
-                        .addField(MigrationPrimaryKey.FIELD_PRIMARY, String.class, FieldAttribute.PRIMARY_KEY)
-                        .addField(MigrationPrimaryKey.FIELD_FOURTH,  Integer.class)
-                        .addField(MigrationPrimaryKey.FIELD_FIFTH,   Long.class);
-            }
-        });
+        RealmConfiguration config = configFactory.createConfigurationBuilder().build();
+        // Init the schema
+        Realm.getInstance(config).close();
+
+        DynamicRealm realm = DynamicRealm.getInstance(config);
+        realm.beginTransaction();
+        // First, removes an existing schema.
+        realm.getSchema().remove(className);
+        // Then recreates the deleted schema or builds a base schema.
+        realm.getSchema()
+                .create(createBase ? MigrationPrimaryKey.CLASS_NAME : className)
+                .addField(MigrationPrimaryKey.FIELD_FIRST,   Byte.class)
+                .addField(MigrationPrimaryKey.FIELD_SECOND,  Short.class)
+                .addField(MigrationPrimaryKey.FIELD_PRIMARY, String.class, FieldAttribute.PRIMARY_KEY)
+                .addField(MigrationPrimaryKey.FIELD_FOURTH,  Integer.class)
+                .addField(MigrationPrimaryKey.FIELD_FIFTH,   Long.class);
+        realm.commitTransaction();
         realm.close();
     }
 
@@ -365,10 +384,9 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         Realm realm = Realm.getInstance(realmConfig);
 
         Table table = realm.getSchema().getTable(MigrationClassRenamed.class);
-        assertTrue(table.hasPrimaryKey());
         assertEquals(MigrationClassRenamed.DEFAULT_FIELDS_COUNT, table.getColumnCount());
-        assertEquals(MigrationClassRenamed.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
-        assertEquals(MigrationClassRenamed.FIELD_PRIMARY, table.getColumnName(table.getPrimaryKey()));
+        assertPKField(realm, MigrationClassRenamed.CLASS_NAME, MigrationClassRenamed.FIELD_PRIMARY,
+                MigrationClassRenamed.DEFAULT_PRIMARY_INDEX);
         // Old schema does not exist.
         assertNull(realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME));
     }
@@ -400,10 +418,17 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                 .schema(MigrationClassRenamed.class)
                 .migration(migration)
                 .build();
+        // Trigger migration
         Realm realm = Realm.getInstance(realmConfig);
+        realm.close();
 
-        assertTrue(realm.getSchema().get(MigrationClassRenamed.CLASS_NAME).hasPrimaryKey());
-        assertFalse(realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME).hasPrimaryKey());
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(realmConfig);
+        try {
+            assertTrue(dynamicRealm.getSchema().get(MigrationClassRenamed.CLASS_NAME).hasPrimaryKey());
+            assertFalse(dynamicRealm.getSchema().get(MigrationPrimaryKey.CLASS_NAME).hasPrimaryKey());
+        } finally {
+            dynamicRealm.close();
+        }
     }
 
     // Test to show that renaming a class does not effect the primary key.
@@ -427,10 +452,9 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         Realm realm = Realm.getInstance(realmConfig);
 
         Table table = realm.getSchema().getTable(MigrationClassRenamed.class);
-        assertTrue(table.hasPrimaryKey());
         assertEquals(MigrationClassRenamed.DEFAULT_FIELDS_COUNT, table.getColumnCount());
-        assertEquals(MigrationClassRenamed.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
-        assertEquals(MigrationClassRenamed.FIELD_PRIMARY, table.getColumnName(table.getPrimaryKey()));
+        assertPKField(realm, MigrationClassRenamed.CLASS_NAME, MigrationClassRenamed.FIELD_PRIMARY,
+                MigrationClassRenamed.DEFAULT_PRIMARY_INDEX);
         // Old schema does not exist.
         assertNull(realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME));
     }
@@ -464,31 +488,39 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                 .migration(migration)
                 .build();
         Realm realm = Realm.getInstance(realmConfig);
+        realm.close();
 
-        assertTrue(realm.getSchema().get(MigrationClassRenamed.CLASS_NAME).hasPrimaryKey());
-        assertFalse(realm.getSchema().get(MigrationPrimaryKey.CLASS_NAME).hasPrimaryKey());
+        // We cannot access 'MigrationPrimaryKey' from a typed Realm since it is not part of the pre-defined schema.
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(realmConfig);
+        try {
+            assertTrue(dynamicRealm.getSchema().get(MigrationClassRenamed.CLASS_NAME).hasPrimaryKey());
+            assertFalse(dynamicRealm.getSchema().get(MigrationPrimaryKey.CLASS_NAME).hasPrimaryKey());
+        } finally {
+            dynamicRealm.close();
+        }
     }
 
     @Test
     public void setClassName_throwOnLongClassName() {
+        RealmConfiguration config = configFactory.createConfigurationBuilder().build();
         // Creates the first version of schema.
-        Realm realm = Realm.getInstance(configFactory.createConfigurationBuilder().build());
-        realm.executeTransaction(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                realm.getSchema().create(MigrationPrimaryKey.CLASS_NAME);
-            }
-        });
+        Realm.getInstance(config).close();
+        DynamicRealm realm = DynamicRealm.getInstance(config);
+        realm.beginTransaction();
+        realm.getSchema().create(MigrationPrimaryKey.CLASS_NAME);
+        realm.commitTransaction();
         realm.close();
 
+        final String tooLongClassName = "MigrationNameIsLongerThan57Char_ThisShouldThrowAnException";
+        assertEquals(58, tooLongClassName.length());
+
         // Gets ready for the 2nd version migration.
         RealmMigration migration = new RealmMigration() {
             @Override
             public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                 realm.getSchema()
                         .get(MigrationPrimaryKey.CLASS_NAME)
-                        // 57 characters
-                        .setClassName("MigrationNameIsLongerThan56CharThisShouldThrowAnException");
+                        .setClassName(tooLongClassName);
             }
         };
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
@@ -501,7 +533,12 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
             Realm.getInstance(realmConfig);
             fail();
         } catch (IllegalArgumentException expected) {
-            assertEquals("Class name is too long. Limit is 56 characters: 'MigrationNameIsLongerThan56CharThisShouldThrowAnException' (57)",
+            assertEquals(
+                    String.format(Locale.US,
+                            "Class name is too long. Limit is %1$d characters: '%2$s' (%3$d)",
+                            tooLongClassName.length() - 1,
+                            tooLongClassName,
+                            tooLongClassName.length()),
                     expected.getMessage());
         }
     }
@@ -527,10 +564,9 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         Realm realm = Realm.getInstance(realmConfig);
         Table table = realm.getSchema().getTable(MigrationPosteriorIndexOnly.class);
 
-        assertTrue(table.hasPrimaryKey());
         assertEquals(MigrationPosteriorIndexOnly.DEFAULT_FIELDS_COUNT, table.getColumnCount());
-        assertEquals(MigrationPosteriorIndexOnly.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
-        assertEquals(MigrationPosteriorIndexOnly.FIELD_PRIMARY, table.getColumnName(table.getPrimaryKey()));
+        assertPKField(realm, MigrationPosteriorIndexOnly.CLASS_NAME, MigrationPosteriorIndexOnly.FIELD_PRIMARY
+                , MigrationPosteriorIndexOnly.DEFAULT_PRIMARY_INDEX);
     }
 
     // Removing fields after a pk field does not affect the pk.
@@ -554,10 +590,9 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         Realm realm = Realm.getInstance(realmConfig);
         Table table = realm.getSchema().getTable(MigrationPriorIndexOnly.class);
 
-        assertTrue(table.hasPrimaryKey());
         assertEquals(MigrationPriorIndexOnly.DEFAULT_FIELDS_COUNT, table.getColumnCount());
-        assertEquals(MigrationPriorIndexOnly.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
-        assertEquals(MigrationPriorIndexOnly.FIELD_PRIMARY, table.getColumnName(table.getPrimaryKey()));
+        assertPKField(realm, MigrationPriorIndexOnly.CLASS_NAME, MigrationPriorIndexOnly.FIELD_PRIMARY
+                , MigrationPriorIndexOnly.DEFAULT_PRIMARY_INDEX);
     }
 
     // Renaming the class should also rename the the class entry in the pk metadata table that tracks primary keys.
@@ -580,13 +615,9 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         Realm realm = Realm.getInstance(realmConfig);
 
         Table table = realm.getSchema().getTable(MigrationFieldRenamed.class);
-        assertTrue(table.hasPrimaryKey());
         assertEquals(MigrationFieldRenamed.DEFAULT_FIELDS_COUNT, table.getColumnCount());
-        assertEquals(MigrationFieldRenamed.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
-
-        RealmObjectSchema objectSchema = realm.getSchema().getSchemaForClass(MigrationFieldRenamed.class);
-        assertFalse(objectSchema.hasField(MigrationPrimaryKey.FIELD_PRIMARY));
-        assertEquals(MigrationFieldRenamed.FIELD_PRIMARY, objectSchema.getPrimaryKey());
+        assertPKField(realm, MigrationFieldRenamed.CLASS_NAME, MigrationFieldRenamed.FIELD_PRIMARY,
+                MigrationFieldRenamed.DEFAULT_PRIMARY_INDEX);
     }
 
     private void createObjectsWithOldPrimaryKey(final String className, final boolean insertNullValue) {
@@ -646,13 +677,10 @@ public void apply(DynamicRealmObject obj) {
         Realm realm = Realm.getInstance(realmConfig);
 
         Table table = realm.getSchema().getTable(MigrationFieldTypeToInt.class);
-        assertTrue(table.hasPrimaryKey());
         assertEquals(MigrationFieldTypeToInt.DEFAULT_FIELDS_COUNT, table.getColumnCount());
-        assertEquals(MigrationFieldTypeToInt.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
+        assertPKField(realm, MigrationFieldTypeToInt.CLASS_NAME, MigrationFieldTypeToInt.FIELD_PRIMARY,
+                MigrationFieldTypeToInt.DEFAULT_PRIMARY_INDEX);
 
-        RealmObjectSchema objectSchema = realm.getSchema().getSchemaForClass(MigrationFieldTypeToInt.class);
-        assertFalse(objectSchema.hasField(MigrationPrimaryKey.FIELD_PRIMARY));
-        assertEquals(MigrationFieldTypeToInt.FIELD_PRIMARY, objectSchema.getPrimaryKey());
         assertEquals(1, realm.where(MigrationFieldTypeToInt.class).count());
         assertEquals(12, realm.where(MigrationFieldTypeToInt.class).findFirst().fieldIntPrimary);
     }
@@ -694,13 +722,10 @@ public void apply(DynamicRealmObject obj) {
         Realm realm = Realm.getInstance(realmConfig);
 
         Table table = realm.getSchema().getTable(MigrationFieldTypeToInteger.class);
-        assertTrue(table.hasPrimaryKey());
         assertEquals(MigrationFieldTypeToInteger.DEFAULT_FIELDS_COUNT, table.getColumnCount());
-        assertEquals(MigrationFieldTypeToInteger.DEFAULT_PRIMARY_INDEX, table.getPrimaryKey());
+        assertPKField(realm, MigrationFieldTypeToInteger.CLASS_NAME, MigrationFieldTypeToInteger.FIELD_PRIMARY,
+                MigrationFieldTypeToInteger.DEFAULT_PRIMARY_INDEX);
 
-        RealmObjectSchema objectSchema = realm.getSchema().getSchemaForClass(MigrationFieldTypeToInteger.class);
-        assertFalse(objectSchema.hasField(MigrationPrimaryKey.FIELD_PRIMARY));
-        assertEquals(MigrationFieldTypeToInteger.FIELD_PRIMARY, objectSchema.getPrimaryKey());
         assertEquals(2, realm.where(MigrationFieldTypeToInteger.class).count());
 
         // not-null value
@@ -714,11 +739,100 @@ public void apply(DynamicRealmObject obj) {
                              .count());
     }
 
+    @Test
+    public void modifyPrimaryKeyFieldTypeFromIntToStringInMigration() {
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                RealmObjectSchema objectSchema  = realm.getSchema().get(PrimaryKeyAsString.CLASS_NAME);
+                assertNotNull(objectSchema);
+                assertEquals(PrimaryKeyAsString.FIELD_ID, objectSchema.getPrimaryKey());
+                objectSchema.removePrimaryKey().addPrimaryKey(PrimaryKeyAsString.FIELD_PRIMARY_KEY);
+            }
+        };
+
+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()
+                .schema(PrimaryKeyAsString.class)
+                .schemaVersion(1)
+                .migration(migration)
+                .build();
+
+        // Create the schema and set the int field as primary key
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(configuration);
+        dynamicRealm.beginTransaction();
+        RealmSchema schema = dynamicRealm.getSchema();
+        schema.create(PrimaryKeyAsString.CLASS_NAME)
+                .addField(PrimaryKeyAsString.FIELD_ID, long.class, FieldAttribute.PRIMARY_KEY)
+                .addField(PrimaryKeyAsString.FIELD_PRIMARY_KEY, String.class);
+        dynamicRealm.createObject(PrimaryKeyAsString.CLASS_NAME, 0)
+                .setString(PrimaryKeyAsString.FIELD_PRIMARY_KEY, "string0");
+        dynamicRealm.createObject(PrimaryKeyAsString.CLASS_NAME, 1)
+                .setString(PrimaryKeyAsString.FIELD_PRIMARY_KEY, "string1");
+        dynamicRealm.setVersion(0);
+        dynamicRealm.commitTransaction();
+
+        // Run migration
+        realm = Realm.getInstance(configuration);
+        RealmObjectSchema objectSchema = realm.getSchema().get(PrimaryKeyAsString.CLASS_NAME);
+        assertNotNull(objectSchema);
+        assertEquals(PrimaryKeyAsString.FIELD_PRIMARY_KEY, objectSchema.getPrimaryKey());
+        RealmResults<PrimaryKeyAsString> results = realm.where(PrimaryKeyAsString.class)
+                .findAllSorted(PrimaryKeyAsString.FIELD_ID);
+        assertEquals(2, results.size());
+        assertEquals("string0", results.get(0).getName());
+        assertEquals("string1", results.get(1).getName());
+    }
+
+    @Test
+    public void modifyPrimaryKeyFieldTypeFromStringToInt() {
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                RealmObjectSchema objectSchema  = realm.getSchema().get(PrimaryKeyAsInteger.CLASS_NAME);
+                assertNotNull(objectSchema);
+                assertEquals(PrimaryKeyAsInteger.FIELD_NAME, objectSchema.getPrimaryKey());
+                objectSchema.removePrimaryKey().addPrimaryKey(PrimaryKeyAsInteger.FIELD_ID);
+            }
+        };
+
+        RealmConfiguration configuration = configFactory.createConfigurationBuilder()
+                .schema(PrimaryKeyAsInteger.class)
+                .schemaVersion(1)
+                .migration(migration)
+                .build();
+
+        // Create the schema and set the String field as primary key
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(configuration);
+        dynamicRealm.beginTransaction();
+        RealmSchema schema = dynamicRealm.getSchema();
+        schema.create(PrimaryKeyAsInteger.CLASS_NAME)
+                .addField(PrimaryKeyAsInteger.FIELD_ID, int.class)
+                .addField(PrimaryKeyAsInteger.FIELD_NAME, String.class, FieldAttribute.PRIMARY_KEY);
+        dynamicRealm.createObject(PrimaryKeyAsInteger.CLASS_NAME, "string0")
+                .setInt(PrimaryKeyAsInteger.FIELD_ID, 0);
+        dynamicRealm.createObject(PrimaryKeyAsInteger.CLASS_NAME, "string1")
+                .setInt(PrimaryKeyAsInteger.FIELD_ID, 1);
+        dynamicRealm.setVersion(0);
+        dynamicRealm.commitTransaction();
+
+        // Run migration
+        realm = Realm.getInstance(configuration);
+
+        RealmObjectSchema objectSchema = realm.getSchema().get(PrimaryKeyAsInteger.CLASS_NAME);
+        assertNotNull(objectSchema);
+        assertEquals(PrimaryKeyAsInteger.FIELD_ID, objectSchema.getPrimaryKey());
+        RealmResults<PrimaryKeyAsInteger> results = realm.where(PrimaryKeyAsInteger.class)
+                .findAllSorted(PrimaryKeyAsInteger.FIELD_ID);
+        assertEquals(2, results.size());
+        assertEquals(0, results.get(0).getId());
+        assertEquals(1, results.get(1).getId());
+    }
+
     @Test
     public void settingPrimaryKeyWithObjectSchema() {
         // Creates v0 of the Realm.
         RealmConfiguration originalConfig = configFactory.createConfigurationBuilder()
-                .schema(AllTypes.class)
+                .schema(StringOnly.class)
                 .build();
         Realm.getInstance(originalConfig).close();
 
@@ -738,7 +852,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         // Creates v1 of the Realm.
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
                 .schemaVersion(1)
-                .schema(AllTypes.class, AnnotationTypes.class)
+                .schema(StringOnly.class, AnnotationTypes.class)
                 .migration(migration)
                 .build();
 
@@ -749,47 +863,12 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         realm.close();
     }
 
-    // Adding search index is idempotent.
-    @Test
-    public void addingSearchIndexTwice() throws IOException {
-        final Class[] classes = {PrimaryKeyAsLong.class, PrimaryKeyAsString.class};
-
-        for (final Class clazz : classes) {
-            final AtomicBoolean didMigrate = new AtomicBoolean(false);
-
-            RealmMigration migration = new RealmMigration() {
-                @Override
-                public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
-                    RealmObjectSchema schema = realm.getSchema().getSchemaForClass(clazz.getSimpleName());
-                    schema.addIndex("id");
-                    // @PrimaryKey fields in PrimaryKeyAsLong and PrimaryKeyAsString.class should be set 'nullable'.
-                    schema.setNullable("name", true);
-                    didMigrate.set(true);
-                }
-            };
-            RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
-                    .schemaVersion(42)
-                    .schema(clazz)
-                    .migration(migration)
-                    .build();
-            Realm.deleteRealm(realmConfig);
-            configFactory.copyRealmFromAssets(context, "default-before-migration.realm", Realm.DEFAULT_REALM_NAME);
-            Realm.migrateRealm(realmConfig);
-            realm = Realm.getInstance(realmConfig);
-            assertEquals(42, realm.getVersion());
-            assertTrue(didMigrate.get());
-            Table table = realm.getTable(clazz);
-            assertEquals(true, table.hasSearchIndex(table.getColumnIndex("id")));
-            realm.close();
-        }
-    }
-
     @Test
     public void setAnnotations() {
 
         // Creates v0 of the Realm.
         RealmConfiguration originalConfig = configFactory.createConfigurationBuilder()
-                .schema(AllTypes.class)
+                .schema(StringOnly.class)
                 .build();
         Realm.getInstance(originalConfig).close();
 
@@ -806,14 +885,14 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
 
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
                 .schemaVersion(1)
-                .schema(AllTypes.class, AnnotationTypes.class)
+                .schema(StringOnly.class, AnnotationTypes.class)
                 .migration(migration)
                 .build();
 
         realm = Realm.getInstance(realmConfig);
         Table table = realm.getTable(AnnotationTypes.class);
         assertEquals(3, table.getColumnCount());
-        assertTrue(table.hasPrimaryKey());
+        assertEquals("id", OsObjectStore.getPrimaryKeyForObject(realm.getSharedRealm(), "AnnotationTypes"));
         assertTrue(table.hasSearchIndex(table.getColumnIndex("id")));
         assertTrue(table.hasSearchIndex(table.getColumnIndex("indexString")));
     }
@@ -830,16 +909,29 @@ public void migrationException_getPath() throws IOException {
         }
     }
 
-    // In default-before-migration.realm, CatOwner has a RealmList<Dog> field.
-    // This is changed to RealmList<Cat> and getInstance() must throw an exception.
+    // Check if the RealmList type change can trigger a RealmMigrationNeededException.
     @Test
     public void migrationException_realmListChanged() throws IOException {
-        configFactory.copyRealmFromAssets(context,
-                "default-before-migration.realm", Realm.DEFAULT_REALM_NAME);
+        RealmConfiguration config = configFactory.createConfiguration();
+        // Initialize the schema with RealmList<Cat>
+        Realm.getInstance(configFactory.createConfiguration()).close();
+
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);
+        dynamicRealm.beginTransaction();
+        // Change the RealmList type to RealmList<Dog>
+        RealmObjectSchema dogSchema = dynamicRealm.getSchema().get(Dog.CLASS_NAME);
+        RealmObjectSchema ownerSchema = dynamicRealm.getSchema().get(CatOwner.CLASS_NAME);
+        ownerSchema.removeField(CatOwner.FIELD_CATS);
+        ownerSchema.addRealmListField(CatOwner.FIELD_CATS, dogSchema);
+        dynamicRealm.commitTransaction();
+        dynamicRealm.close();
+
         try {
-            realm = Realm.getInstance(configFactory.createConfiguration());
+            realm = Realm.getInstance(config);
             fail();
         } catch (RealmMigrationNeededException ignored) {
+            assertThat(ignored.getMessage(),
+                    CoreMatchers.containsString("Property 'CatOwner.cats' has been changed from 'array<Dog>' to 'array<Cat>'"));
         }
     }
 
@@ -849,7 +941,7 @@ public void migrationException_realmListChanged() throws IOException {
     @Test
     public void openPreNullRealmRequiredMissing() throws IOException {
         configFactory.copyRealmFromAssets(context,
-                "default-before-migration.realm", Realm.DEFAULT_REALM_NAME);
+                "string-only-pre-null-0.82.2.realm", Realm.DEFAULT_REALM_NAME);
         RealmMigration realmMigration = new RealmMigration() {
             @Override
             public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
@@ -867,8 +959,8 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
             realm.close();
             fail();
         } catch (RealmMigrationNeededException e) {
-            assertEquals("Field 'chars' is required. Either set @Required to field 'chars' or migrate using RealmObjectSchema.setNullable().",
-                    e.getMessage());
+            assertThat(e.getMessage(), CoreMatchers.containsString(
+                    "Property 'StringOnly.chars' has been made optional"));
         }
     }
 
@@ -877,13 +969,15 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
     // old class (without @Required) can be used,
     @Test
     public void migratePreNull() throws IOException {
+        final AtomicBoolean migrationCalled = new AtomicBoolean(false);
         configFactory.copyRealmFromAssets(context,
-                "default-before-migration.realm", Realm.DEFAULT_REALM_NAME);
+                "string-only-pre-null-0.82.2.realm", Realm.DEFAULT_REALM_NAME);
         RealmMigration migration = new RealmMigration() {
             @Override
             public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
-                Table table = realm.schema.getTable(StringOnly.class);
-                table.convertColumnToNullable(table.getColumnIndex("chars"));
+                RealmObjectSchema objectSchema = realm.getSchema().get(StringOnly.CLASS_NAME);
+                objectSchema.setRequired(StringOnly.FIELD_CHARS, false);
+                migrationCalled.set(true);
             }
         };
 
@@ -893,8 +987,13 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                 .migration(migration)
                 .build();
         Realm realm = Realm.getInstance(realmConfig);
+        assertTrue(migrationCalled.get());
+
+        StringOnly stringOnly = realm.where(StringOnly.class).findFirst();
+        assertNotNull(stringOnly);
+        // This object was created with 0.82.2
+        assertEquals("String_set_with_0.82.2", stringOnly.getChars());
         realm.beginTransaction();
-        StringOnly stringOnly = realm.createObject(StringOnly.class);
         stringOnly.setChars(null);
         realm.commitTransaction();
         realm.close();
@@ -905,20 +1004,25 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
     // change the schema version, no migration is needed. But then, null cannot be used as a value.
     @Test
     public void openPreNullWithRequired() throws IOException {
-        configFactory.copyRealmFromAssets(context,
-                "default-before-migration.realm", Realm.DEFAULT_REALM_NAME);
+        configFactory.copyRealmFromAssets(context, "string-only-required-pre-null-0.82.2.realm", Realm.DEFAULT_REALM_NAME);
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
                 .schemaVersion(0)
-                .schema(AllTypes.class)
+                .schema(StringOnlyRequired.class)
                 .build();
         Realm realm = Realm.getInstance(realmConfig);
 
+        StringOnlyRequired stringOnlyRequired = realm.where(StringOnlyRequired.class).findFirst();
+        assertNotNull(stringOnlyRequired);
+        // This object was created with 0.82.2
+        assertEquals("String_set_with_0.82.2", stringOnlyRequired.getChars());
+
         realm.beginTransaction();
         try {
-            AllTypes allTypes = realm.createObject(AllTypes.class);
-            allTypes.setColumnString(null);
+            stringOnlyRequired.setChars(null);
             fail();
-        } catch (IllegalArgumentException ignored) {
+        } catch (IllegalArgumentException expected) {
+            assertThat(expected.getMessage(),
+                    CoreMatchers.containsString("Trying to set non-nullable field 'chars' to null."));
         }
         realm.cancelTransaction();
 
@@ -938,7 +1042,7 @@ public void notSettingRequiredForNotNullableThrows() {
                 public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                     if (oldVersion == 0) { // 0 after initNullTypesTableExcludes
                         // No @Required for not nullable field
-                        RealmObjectSchema nullTypesSchema = realm.getSchema().getSchemaForClass(NullTypes.CLASS_NAME);
+                        RealmObjectSchema nullTypesSchema = realm.getSchema().get(NullTypes.CLASS_NAME);
                         if (field.equals(NullTypes.FIELD_STRING_NOT_NULL)) {
                             // 1 String
                             nullTypesSchema.addField(field, String.class);
@@ -973,6 +1077,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
             @SuppressWarnings("unchecked")
             RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
                     .schemaVersion(1)
+                    .name(field)
                     .schema(NullTypes.class)
                     .migration(migration)
                     .build();
@@ -986,10 +1091,8 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                 realm = Realm.getInstance(realmConfig);
                 fail("Failed on " + field);
             } catch (RealmMigrationNeededException e) {
-                assertEquals("Field '" + field + "' does support null values in the existing Realm file." +
-                        " Remove @Required or @PrimaryKey from field '" + field + "' " +
-                        "or migrate using RealmObjectSchema.setNullable().",
-                        e.getMessage());
+                assertThat(e.getMessage(), CoreMatchers.containsString(
+                        String.format(Locale.US, "Property 'NullTypes.%s' has been made required", field)));
             }
         }
     }
@@ -1007,7 +1110,7 @@ public void settingRequiredForNullableThrows() {
                 public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                     if (oldVersion == 0) { // 0 after initNullTypesTableExcludes
                         // No @Required for not nullable field
-                        RealmObjectSchema nullTypesSchema = realm.getSchema().getSchemaForClass(NullTypes.CLASS_NAME);
+                        RealmObjectSchema nullTypesSchema = realm.getSchema().get(NullTypes.CLASS_NAME);
                         if (field.equals(NullTypes.FIELD_STRING_NULL)) {
                             // 1 String
                             nullTypesSchema.addField(field, String.class, FieldAttribute.REQUIRED);
@@ -1041,6 +1144,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
             @SuppressWarnings("unchecked")
             RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
                     .schemaVersion(1)
+                    .name(field)
                     .schema(NullTypes.class)
                     .migration(migration)
                     .build();
@@ -1054,16 +1158,8 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                 realm = Realm.getInstance(realmConfig);
                 fail("Failed on " + field);
             } catch (RealmMigrationNeededException e) {
-                if (field.equals(NullTypes.FIELD_STRING_NULL) || field.equals(NullTypes.FIELD_BYTES_NULL) ||
-                        field.equals(NullTypes.FIELD_DATE_NULL)) {
-                    assertEquals("Field '" + field + "' is required. Either set @Required to field '" +
-                            field + "' " +
-                            "or migrate using RealmObjectSchema.setNullable().", e.getMessage());
-                } else {
-                    assertEquals("Field '" + field + "' does not support null values in the existing Realm file."
-                                    + " Either set @Required, use the primitive type for field '"
-                                    + field + "' or migrate using RealmObjectSchema.setNullable().",  e.getMessage());
-                }
+                assertThat(e.getMessage(), CoreMatchers.containsString(
+                        String.format(Locale.US, "Property 'NullTypes.%s' has been made optional", field)));
             }
         }
     }
@@ -1078,7 +1174,7 @@ public void settingNullableToPrimaryKey() throws IOException {
             RealmMigration migration = new RealmMigration() {
                 @Override
                 public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
-                    RealmObjectSchema schema = realm.getSchema().getSchemaForClass(clazz.getSimpleName());
+                    RealmObjectSchema schema = realm.getSchema().get(clazz.getSimpleName());
                     if (clazz == PrimaryKeyAsString.class) {
                         schema.setNullable("name", true);
                     } else {
@@ -1096,7 +1192,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
             configFactory.copyRealmFromAssets(context, "default-notnullable-primarykey.realm", Realm.DEFAULT_REALM_NAME);
             Realm.migrateRealm(realmConfig);
             realm = Realm.getInstance(realmConfig);
-            RealmObjectSchema schema = realm.getSchema().getSchemaForClass(clazz);
+            RealmObjectSchema schema = realm.getSchema().get(clazz.getSimpleName());
             assertEquals(SCHEMA_VERSION, realm.getVersion());
             assertTrue(didMigrate.get());
             if (clazz == PrimaryKeyAsString.class) {
@@ -1129,13 +1225,12 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
                 realm.close();
                 fail();
             } catch (RealmMigrationNeededException expected) {
+                String pkFieldName = "id";
                 if (clazz == PrimaryKeyAsString.class) {
-                    assertEquals("@PrimaryKey field 'name' does not support null values in the existing Realm file. Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.",
-                            expected.getMessage());
-                } else {
-                    assertEquals("@PrimaryKey field 'id' does not support null values in the existing Realm file. Migrate using RealmObjectSchema.setNullable(), or mark the field as @Required.",
-                            expected.getMessage());
+                    pkFieldName = "name";
                 }
+                assertThat(expected.getMessage(), CoreMatchers.containsString(String.format(Locale.US,
+                        "Property '%s.%s' has been made optional", clazz.getSimpleName(), pkFieldName)));
             }
         }
     }
@@ -1148,21 +1243,14 @@ public void migrating_nullableField_toward_notNullable_PrimaryKeyThrows() throws
         for (final Class clazz : classes) {
             try {
                 RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
-                        .schemaVersion(0)
                         .schema(clazz)
-                        .migration(new RealmMigration() {
-                            @Override
-                            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
-                                // intentionally lefts empty to demonstrate incompatibilities between nullable/not-nullable PrimaryKeys.
-                            }
-                        })
                         .build();
                 Realm realm = Realm.getInstance(realmConfig);
                 realm.close();
                 fail();
-            } catch (IllegalStateException expected) {
-                assertEquals("Cannot migrate an object with null value in field 'id'. Either maintain the same type for primary key field 'id', or remove the object with null value before migration.",
-                        expected.getMessage());
+            } catch (RealmMigrationNeededException expected) {
+                assertThat(expected.getMessage(), CoreMatchers.containsString(
+                        String.format("Property '%s.%s' has been made required", clazz.getSimpleName(), "id")));
             }
         }
     }
@@ -1301,6 +1389,57 @@ public void migrationRequired_throwsOriginalException() {
         }
     }
 
+    private void createEmptyRealmVersion0(RealmConfiguration configuration)  {
+        assertFalse(new File(configuration.getPath()).exists());
+
+        DynamicRealm realm = DynamicRealm.getInstance(configuration);
+        realm.beginTransaction();
+        realm.setVersion(0);
+        realm.commitTransaction();
+        realm.close();
+    }
+
+    @Test
+    public void migrationRequired_throwsExceptionInTheMigrationBlock() {
+        final RuntimeException exception = new RuntimeException("TEST");
+
+        RealmMigration migration = new RealmMigration() {
+            @Override
+            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                // The transaction should be canceled and this model should not be created.
+                RealmObjectSchema objectSchema = realm.getSchema().create(StringOnly.CLASS_NAME);
+                objectSchema.addField(StringOnly.FIELD_CHARS, String.class);
+                throw exception;
+            }
+        };
+        RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .migration(migration)
+                .schemaVersion(1)
+                .schema(StringOnly.class)
+                .build();
+        createEmptyRealmVersion0(config);
+
+        Realm realm = null;
+        try {
+            realm = Realm.getInstance(config);
+            fail();
+        } catch (RuntimeException expected) {
+            assertSame(exception, expected);
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+        }
+
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);
+        try {
+            assertEquals(0, dynamicRealm.getVersion());
+            assertNull(dynamicRealm.getSchema().get(StringOnly.CLASS_NAME));
+        } finally {
+            dynamicRealm.close();
+        }
+    }
+
     // TODO Add unit tests for default nullability
     // TODO Add unit tests for default Indexing for Primary keys
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmNullPrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmNullPrimaryKeyTests.java
index dc37e6c8ad..5ad88f013c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmNullPrimaryKeyTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmNullPrimaryKeyTests.java
@@ -36,6 +36,7 @@
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 @RunWith(Parameterized.class)
@@ -202,7 +203,8 @@ public void createObject_duplicatedNullPrimaryKeyThrows() throws NoSuchMethodExc
             realm.createObject(testClazz, null);
             fail("Null value as primary key already exists.");
         } catch (RealmPrimaryKeyConstraintException expected) {
-            assertEquals("Value already exists: null", expected.getMessage());
+            assertTrue("Exception message is: " + expected.getMessage(),
+                    expected.getMessage().contains("Primary key value already exists: 'null' ."));
         } finally {
             realm.cancelTransaction();
         }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
index d89911896d..6615bffa9b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -16,54 +16,91 @@
 
 package io.realm;
 
-import android.support.test.runner.AndroidJUnit4;
-
+import org.hamcrest.CoreMatchers;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 
+import java.util.Arrays;
 import java.util.Date;
+import java.util.List;
 import java.util.Set;
 
 import io.realm.entities.AllJavaTypes;
+import io.realm.entities.Dog;
+import io.realm.entities.NonLatinFieldNames;
+import io.realm.internal.Table;
 import io.realm.rule.TestRealmConfigurationFactory;
 
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-@RunWith(AndroidJUnit4.class)
+@RunWith(Parameterized.class)
 public class RealmObjectSchemaTests {
 
+    private enum ObjectSchemaType {
+        MUTABLE, IMMUTABLE
+    }
+
     @Rule
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
     @Rule
     public final ExpectedException thrown = ExpectedException.none();
 
     private RealmObjectSchema DOG_SCHEMA;
-    private DynamicRealm realm;
+    private BaseRealm realm;
     private RealmObjectSchema schema;
     private RealmSchema realmSchema;
+    private ObjectSchemaType type;
+
+    @Parameterized.Parameters(name = "{0}")
+    public static List<ObjectSchemaType> data() {
+        return Arrays.asList(ObjectSchemaType.values());
+    }
+
+    public RealmObjectSchemaTests(ObjectSchemaType type) {
+        this.type = type;
+    }
 
     @Before
     public void setUp() {
         RealmConfiguration realmConfig = configFactory.createConfiguration();
         Realm.getInstance(realmConfig).close(); // Creates Schema.
+
         realm = DynamicRealm.getInstance(realmConfig);
-        realmSchema = realm.getSchema();
-        DOG_SCHEMA = realmSchema.get("Dog");
         realm.beginTransaction();
-        schema = realmSchema.create("NewClass");
+        realm.getSchema().create("NewClass");
+        realm.commitTransaction();
+        realm.close();
+
+        if (type == ObjectSchemaType.MUTABLE)  {
+            realm = DynamicRealm.getInstance(realmConfig);
+            realmSchema = realm.getSchema();
+            DOG_SCHEMA = realmSchema.get("Dog");
+            schema = realmSchema.get("NewClass");
+        } else {
+            realm = Realm.getInstance(realmConfig);
+            realmSchema = realm.getSchema();
+            DOG_SCHEMA = realmSchema.get("Dog");
+            schema = realmSchema.get("Dog");
+        }
+        realm.beginTransaction();
     }
 
     @After
     public void tearDown() {
-        realm.cancelTransaction();
+        if (realm.isInTransaction()) {
+            realm.cancelTransaction();
+        }
         realm.close();
     }
 
@@ -71,6 +108,7 @@ public void tearDown() {
         SIMPLE, OBJECT, LIST
     }
 
+    // Enumerate all standard field types
     public enum FieldType {
         STRING(String.class, true),
         SHORT(Short.class, true), PRIMITIVE_SHORT(short.class, false),
@@ -82,8 +120,7 @@ public void tearDown() {
         DOUBLE(Double.class, true), PRIMITIVE_DOUBLE(double.class, false),
         BLOB(byte[].class, true),
         DATE(Date.class, true),
-        OBJECT(RealmObject.class, false),
-        LIST(RealmList.class, false);
+        OBJECT(RealmObject.class, false);
 
         final Class<?> clazz;
         final boolean defaultNullable;
@@ -102,23 +139,60 @@ public boolean isNullable() {
         }
     }
 
+    // Enumerate all list types
+    public enum FieldListType {
+        STRING_LIST(String.class, true),
+        SHORT_LIST(Short.class, true), PRIMITIVE_SHORT_LIST(short.class, false),
+        INT_LIST(Integer.class, true), PRIMITIVE_INT_LIST(int.class, false),
+        LONG_LIST(Long.class, true), PRIMITIVE_LONG_LIST(long.class, false),
+        BYTE_LIST(Byte.class, true), PRIMITIVE_BYTE_LIST(byte.class, false),
+        BOOLEAN_LIST(Boolean.class, true), PRIMITIVE_BOOLEAN_LIST(boolean.class, false),
+        FLOAT_LIST(Float.class, true), PRIMITIVE_FLOAT_LIST(float.class, false),
+        DOUBLE_LIST(Double.class, true), PRIMITIVE_DOUBLE_LIST(double.class, false),
+        BLOB_LIST(byte[].class, true),
+        DATE_LIST(Date.class, true),
+        LIST(RealmList.class, false); // List of Realm Objects
+
+        final Class<?> clazz;
+        final boolean defaultNullable;
+
+        FieldListType(Class<?> clazz, boolean defaultNullable) {
+            this.clazz = clazz;
+            this.defaultNullable = defaultNullable;
+        }
+
+        public Class<?> getType() {
+            return clazz;
+        }
+
+        public boolean isNullable() {
+            return defaultNullable;
+        }
+    }
+
     public enum IndexFieldType {
-        STRING(String.class),
-        SHORT(Short.class), PRIMITIVE_SHORT(short.class),
-        INT(Integer.class), PRIMITIVE_INT(int.class),
-        LONG(Long.class), PRIMITIVE_LONG(long.class),
-        BYTE(Byte.class), PRIMITIVE_BYTE(byte.class),
-        BOOLEAN(Boolean.class), PRIMITIVE_BOOLEAN(boolean.class),
-        DATE(Date.class);
+        STRING(String.class, true),
+        SHORT(Short.class, true), PRIMITIVE_SHORT(short.class, false),
+        INT(Integer.class, true), PRIMITIVE_INT(int.class, false),
+        LONG(Long.class, true), PRIMITIVE_LONG(long.class, false),
+        BYTE(Byte.class, true), PRIMITIVE_BYTE(byte.class, false),
+        BOOLEAN(Boolean.class, true), PRIMITIVE_BOOLEAN(boolean.class, false),
+        DATE(Date.class, true);
 
         private final Class<?> clazz;
+        private final boolean nullable;
 
         public Class<?> getType() {
             return clazz;
         }
 
-        IndexFieldType(Class<?> clazz) {
+        public boolean isNullable() {
+            return nullable;
+        }
+
+        IndexFieldType(Class<?> clazz, boolean nullable) {
             this.clazz = clazz;
+            this.nullable = nullable;
         }
     }
 
@@ -142,20 +216,26 @@ public boolean isNullable() {
 
     // TODO These should also be allowed? BOOLEAN, DATE
     public enum PrimaryKeyFieldType {
-        STRING(String.class),
-        SHORT(Short.class), PRIMITIVE_SHORT(short.class),
-        INT(Integer.class), PRIMITIVE_INT(int.class),
-        LONG(Long.class), PRIMITIVE_LONG(long.class),
-        BYTE(Byte.class), PRIMITIVE_BYTE(byte.class);
+        STRING(String.class, true),
+        SHORT(Short.class, true), PRIMITIVE_SHORT(short.class, false),
+        INT(Integer.class, true), PRIMITIVE_INT(int.class, false),
+        LONG(Long.class, true), PRIMITIVE_LONG(long.class, false),
+        BYTE(Byte.class, true), PRIMITIVE_BYTE(byte.class, false);
 
         private final Class<?> clazz;
+        private final boolean nullable;
 
         public Class<?> getType() {
             return clazz;
         }
 
-        PrimaryKeyFieldType(Class<?> clazz) {
+        public boolean isNullable() {
+            return nullable;
+        }
+
+        PrimaryKeyFieldType(Class<?> clazz, boolean nullable) {
             this.clazz = clazz;
+            this.nullable = nullable;
         }
     }
 
@@ -181,20 +261,52 @@ public boolean isNullable() {
 
     @Test
     public void addRemoveField() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            try {
+                schema.addField("test", int.class);
+                fail();
+            } catch (UnsupportedOperationException ignore) {
+            }
+            try {
+                schema.addRealmObjectField("test", DOG_SCHEMA);
+                fail();
+            } catch (UnsupportedOperationException ignore) {
+            }
+            try {
+                schema.addRealmListField("test", DOG_SCHEMA);
+                fail();
+            } catch (UnsupportedOperationException ignore) {
+            }
+
+            try {
+                schema.removeField("test");
+                fail();
+            } catch (UnsupportedOperationException ignore) {
+            }
+            return;
+        }
+        String fieldName = "foo";
         for (FieldType fieldType : FieldType.values()) {
-            String fieldName = "foo";
             switch (fieldType) {
                 case OBJECT:
                     schema.addRealmObjectField(fieldName, DOG_SCHEMA);
                     checkAddedAndRemovable(fieldName);
                     break;
+                default:
+                    // All simple fields
+                    schema.addField(fieldName, fieldType.getType());
+                    checkAddedAndRemovable(fieldName);
+            }
+        }
+        for (FieldListType fieldType : FieldListType.values()) {
+            switch (fieldType) {
                 case LIST:
                     schema.addRealmListField(fieldName, DOG_SCHEMA);
                     checkAddedAndRemovable(fieldName);
                     break;
                 default:
-                    // All simple fields
-                    schema.addField(fieldName, fieldType.getType());
+                    // All primitive lists
+                    schema.addRealmListField(fieldName, fieldType.getType());
                     checkAddedAndRemovable(fieldName);
             }
         }
@@ -209,6 +321,9 @@ private void checkAddedAndRemovable(String fieldName) {
 
     @Test
     public void addField_nameAlreadyExistsThrows() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
         for (SchemaFieldType schemaFieldType : SchemaFieldType.values()) {
             switch (schemaFieldType) {
                 case SIMPLE:
@@ -253,6 +368,9 @@ private void checkAddFieldTwice(String fieldName, FieldRunnable runnable) {
 
     @Test
     public void addField_illegalFieldNameThrows() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
         String[] fieldNames = new String[] { null, "", "foo.bar", TestHelper.getRandomString(65) };
         for (SchemaFieldType schemaFieldType : SchemaFieldType.values()) {
             for (String fieldName : fieldNames) {
@@ -273,11 +391,13 @@ public void addField_illegalFieldNameThrows() {
 
     @Test
     public void requiredFieldAttribute() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
+        String fieldName = "foo";
         for (FieldType fieldType : FieldType.values()) {
-            String fieldName = "foo";
             switch (fieldType) {
                 case OBJECT: continue; // Not possible.
-                case LIST: continue; // Not possible.
                 default:
                     // All simple types
                     schema.addField(fieldName, fieldType.getType(), FieldAttribute.REQUIRED);
@@ -285,10 +405,27 @@ public void requiredFieldAttribute() {
                     schema.removeField(fieldName);
             }
         }
+        for (FieldListType fieldType : FieldListType.values()) {
+            switch(fieldType) {
+                case LIST:
+                    continue; // Not possible.
+                default:
+                    // All simple list types
+                    schema.addRealmListField(fieldName, fieldType.getType());
+                    if (fieldType.isNullable()) {
+                        schema.setRequired(fieldName, true);
+                    }
+                    assertTrue(fieldName + " should be required", schema.isRequired(fieldName));
+                    schema.removeField(fieldName);
+            }
+        }
     }
 
     @Test
     public void indexedFieldAttribute() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
         for (IndexFieldType fieldType : IndexFieldType.values()) {
             String fieldName = "foo";
             switch (fieldType) {
@@ -302,6 +439,9 @@ public void indexedFieldAttribute() {
 
     @Test
     public void invalidIndexedFieldAttributeThrows() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
         for (InvalidIndexFieldType fieldType : InvalidIndexFieldType.values()) {
             String fieldName = "foo";
             try {
@@ -310,10 +450,19 @@ public void invalidIndexedFieldAttributeThrows() {
             } catch (IllegalArgumentException ignored) {
             }
         }
+
+        // Probe for all variants of primitive lists
+        try {
+            schema.addRealmListField("foo", String.class);
+        } catch (IllegalArgumentException ignored) {
+        }
     }
 
     @Test
     public void primaryKeyFieldAttribute() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
         for (PrimaryKeyFieldType fieldType : PrimaryKeyFieldType.values()) {
             String fieldName = "foo";
             schema.addField(fieldName, fieldType.getType(), FieldAttribute.PRIMARY_KEY);
@@ -337,6 +486,9 @@ public void primaryKeyFieldAttribute() {
 
     @Test
     public void invalidPrimaryKeyFieldAttributeThrows() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
         for (InvalidPrimaryKeyFieldType fieldType : InvalidPrimaryKeyFieldType.values()) {
             String fieldName = "foo";
             try {
@@ -345,10 +497,24 @@ public void invalidPrimaryKeyFieldAttributeThrows() {
             } catch (IllegalArgumentException ignored) {
             }
         }
+
+        try {
+            schema.addRealmListField("foo", schema);
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        // Probe for all variants of primitive lists
+        try {
+            schema.addRealmListField("foo", String.class);
+        } catch (IllegalArgumentException ignored) {
+        }
     }
 
     @Test
     public void addPrimaryKeyFieldModifier_alreadyExistsThrows() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
         for (PrimaryKeyFieldType fieldType : PrimaryKeyFieldType.values()) {
             String fieldName = "foo";
             schema.addField(fieldName, fieldType.getType());
@@ -365,6 +531,9 @@ public void addPrimaryKeyFieldModifier_alreadyExistsThrows() {
 
     @Test
     public void addPrimaryKeyFieldModifier_illegalFieldTypeThrows() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
         String fieldName = "foo";
         for (InvalidPrimaryKeyFieldType fieldType : InvalidPrimaryKeyFieldType.values()) {
             switch (fieldType) {
@@ -383,20 +552,23 @@ public void addPrimaryKeyFieldModifier_illegalFieldTypeThrows() {
 
     @Test
     public void addPrimaryKeyFieldModifier_duplicateValues() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
         for (PrimaryKeyFieldType fieldType : PrimaryKeyFieldType.values()) {
             final String fieldName = "foo";
             schema.addField(fieldName, fieldType.getType());
 
             // Creates multiple objects with same values.
-            realm.createObject(schema.getClassName());
-            realm.createObject(schema.getClassName());
+            ((DynamicRealm)realm).createObject(schema.getClassName());
+            ((DynamicRealm)realm).createObject(schema.getClassName());
 
             try {
                 schema.addPrimaryKey(fieldName);
                 fail();
             } catch (IllegalArgumentException e) {
                 // Checks if message reports correct field name.
-                assertTrue(e.getMessage().contains("\"" + fieldName + "\""));
+                assertThat(e.getMessage(), CoreMatchers.containsString(fieldName));
             }
             schema.removeField(fieldName);
         }
@@ -404,6 +576,9 @@ public void addPrimaryKeyFieldModifier_duplicateValues() {
 
     @Test
     public void addIndexFieldModifier_illegalFieldTypeThrows() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
         String fieldName = "foo";
         for (InvalidIndexFieldType fieldType : InvalidIndexFieldType.values()) {
             switch (fieldType) {
@@ -422,6 +597,9 @@ public void addIndexFieldModifier_illegalFieldTypeThrows() {
 
     @Test
     public void addIndexFieldModifier_alreadyIndexedThrows() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
         for (IndexFieldType fieldType : IndexFieldType.values()) {
             String fieldName = "foo";
             schema.addField(fieldName, fieldType.getType());
@@ -436,9 +614,14 @@ public void addIndexFieldModifier_alreadyIndexedThrows() {
     }
 
     @Test
-    public void setRemoveNullable() {
+    public void setNullable_trueAndFalse() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            thrown.expect(UnsupportedOperationException.class);
+            schema.setNullable("test", true);
+            return;
+        }
+        String fieldName = "foo";
         for (FieldType fieldType : FieldType.values()) {
-            String fieldName = "foo";
             switch (fieldType) {
                 case OBJECT:
                     // Objects are always nullable and cannot be changed.
@@ -450,6 +633,17 @@ public void setRemoveNullable() {
                     } catch (IllegalArgumentException ignored) {
                     }
                     break;
+                default:
+                    // All simple types.
+                    schema.addField(fieldName, fieldType.getType());
+                    assertEquals(fieldType.isNullable(), schema.isNullable(fieldName));
+                    schema.setNullable(fieldName, !fieldType.isNullable());
+                    assertEquals(!fieldType.isNullable(), schema.isNullable(fieldName));
+            }
+            schema.removeField(fieldName);
+        }
+        for (FieldListType fieldType : FieldListType.values()) {
+            switch (fieldType) {
                 case LIST:
                     // Lists are not nullable and cannot be configured to be so.
                     schema.addRealmListField(fieldName, schema);
@@ -461,20 +655,25 @@ public void setRemoveNullable() {
                     }
                     break;
                 default:
-                    // All simple types.
-                    schema.addField(fieldName, fieldType.getType());
-                    assertEquals(fieldType.isNullable(), schema.isNullable(fieldName));
+                    // All simple list types.
+                    schema.addRealmListField(fieldName, fieldType.getType());
+                    assertEquals("Type: " + fieldType, fieldType.isNullable(), schema.isNullable(fieldName));
                     schema.setNullable(fieldName, !fieldType.isNullable());
-                    assertEquals(!fieldType.isNullable(), schema.isNullable(fieldName));
+                    assertEquals("Type: " + fieldType, !fieldType.isNullable(), schema.isNullable(fieldName));
             }
             schema.removeField(fieldName);
         }
     }
 
     @Test
-    public void setRemoveRequired() {
+    public void setRequired_trueAndFalse() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            thrown.expect(UnsupportedOperationException.class);
+            schema.setRequired("test", true);
+            return;
+        }
+        String fieldName = "foo";
         for (FieldType fieldType : FieldType.values()) {
-            String fieldName = "foo";
             switch (fieldType) {
                 case OBJECT:
                     // Objects are always nullable and cannot be configured otherwise.
@@ -486,6 +685,17 @@ public void setRemoveRequired() {
                     } catch (IllegalArgumentException ignored) {
                     }
                     break;
+                default:
+                    // All simple types.
+                    schema.addField(fieldName, fieldType.getType());
+                    assertEquals(!fieldType.isNullable(), schema.isRequired(fieldName));
+                    schema.setRequired(fieldName, fieldType.isNullable());
+                    assertEquals(fieldType.isNullable(), schema.isRequired(fieldName));
+            }
+            schema.removeField(fieldName);
+        }
+        for (FieldListType fieldType : FieldListType.values()) {
+            switch (fieldType) {
                 case LIST:
                     // Lists are always non-nullable and cannot be configured otherwise.
                     schema.addRealmListField(fieldName, schema);
@@ -497,8 +707,8 @@ public void setRemoveRequired() {
                     }
                     break;
                 default:
-                    // All simple types.
-                    schema.addField(fieldName, fieldType.getType());
+                    // All simple list types.
+                    schema.addRealmListField(fieldName, fieldType.getType());
                     assertEquals(!fieldType.isNullable(), schema.isRequired(fieldName));
                     schema.setRequired(fieldName, fieldType.isNullable());
                     assertEquals(fieldType.isNullable(), schema.isRequired(fieldName));
@@ -507,8 +717,287 @@ public void setRemoveRequired() {
         }
     }
 
+    // When converting a nullable field to required, the null values of the field will be set to the default value
+    // according to the field type.
+    @Test
+    public void setRequired_nullValueBecomesDefaultValue() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
+        for (FieldType fieldType : FieldType.values()) {
+            String fieldName = fieldType.name();
+            switch (fieldType) {
+                case OBJECT:
+                    // Skip always nullable fields
+                    break;
+                default:
+                    // Skip not-nullable fields .
+                    if (!fieldType.isNullable()) {
+                        break;
+                    }
+                    schema.addField(fieldName, fieldType.getType());
+                    DynamicRealmObject object = ((DynamicRealm)realm).createObject(schema.getClassName());
+                    assertTrue(object.isNull(fieldName));
+                    schema.setRequired(fieldName, true);
+                    assertFalse(object.isNull(fieldName));
+                    if (fieldType == FieldType.BLOB) {
+                        assertEquals(0, object.getBlob(fieldName).length);
+                    } else if (fieldType == FieldType.BOOLEAN) {
+                        assertFalse(object.getBoolean(fieldName));
+                    } else if (fieldType == FieldType.STRING) {
+                        assertEquals(0, object.getString(fieldName).length());
+                    } else if (fieldType == FieldType.FLOAT) {
+                        assertEquals(0.0F, object.getFloat(fieldName), 0F);
+                    } else if (fieldType == FieldType.DOUBLE) {
+                        assertEquals(0.0D, object.getDouble(fieldName), 0D);
+                    } else if (fieldType == FieldType.DATE) {
+                        assertEquals(new Date(0), object.getDate(fieldName));
+                    } else {
+                        assertEquals(0, object.getInt(fieldName));
+                    }
+                    break;
+            }
+        }
+        for (FieldListType fieldType : FieldListType.values()) {
+            switch(fieldType) {
+                case LIST:
+                    // Skip always non-nullable fields.
+                    break;
+                case STRING_LIST:
+                    checkListValueConversionToDefaultValue(String.class, "");
+                    break;
+                case SHORT_LIST:
+                    checkListValueConversionToDefaultValue(Short.class, (short) 0);
+                    break;
+                case INT_LIST:
+                    checkListValueConversionToDefaultValue(Integer.class, 0);
+                    break;
+                case LONG_LIST:
+                    checkListValueConversionToDefaultValue(Long.class, 0L);
+                    break;
+                case BYTE_LIST:
+                    checkListValueConversionToDefaultValue(Byte.class, (byte) 0);
+                    break;
+                case BOOLEAN_LIST:
+                    checkListValueConversionToDefaultValue(Boolean.class, false);
+                    break;
+                case FLOAT_LIST:
+                    checkListValueConversionToDefaultValue(Float.class, 0.0F);
+                    break;
+                case DOUBLE_LIST:
+                    checkListValueConversionToDefaultValue(Double.class, 0.0D);
+                    break;
+                case BLOB_LIST:
+                    checkListValueConversionToDefaultValue(byte[].class, new byte[0]);
+                    break;
+                case DATE_LIST:
+                    checkListValueConversionToDefaultValue(Date.class, new Date(0));
+                    break;
+                case PRIMITIVE_INT_LIST:
+                case PRIMITIVE_LONG_LIST:
+                case PRIMITIVE_BYTE_LIST:
+                case PRIMITIVE_BOOLEAN_LIST:
+                case PRIMITIVE_FLOAT_LIST:
+                case PRIMITIVE_DOUBLE_LIST:
+                case PRIMITIVE_SHORT_LIST:
+                    // Skip not-nullable fields
+                    break;
+                default:
+                    throw new IllegalArgumentException("Unknown type: " + fieldType);
+            }
+        }
+    }
+
+    // Checks that null values in a value list are correctly converted to default values
+    // when field is set to required.
+    private <E> void checkListValueConversionToDefaultValue(Class<E> type, Object defaultValue) {
+        schema.addRealmListField("foo", type);
+        DynamicRealmObject obj = ((DynamicRealm) realm).createObject(schema.getClassName());
+        RealmList<E> list = new RealmList<>();
+        list.add(null);
+        obj.setList("foo", list);
+        assertNull(obj.getList("foo", type).first());
+
+        // Convert from nullable to required
+        schema.setRequired("foo", true);
+        if (defaultValue instanceof byte[]) {
+            assertArrayEquals((byte[]) defaultValue, (byte[]) obj.getList("foo", type).first());
+        } else {
+            assertEquals(defaultValue, obj.getList("foo", type).first());
+        }
+
+        // Convert back again
+        schema.setRequired("foo", false);
+        if (defaultValue instanceof byte[]) {
+            //noinspection ConstantConditions
+            assertArrayEquals((byte[]) defaultValue, (byte[]) obj.getList("foo", type).first());
+        } else {
+            assertEquals(defaultValue, obj.getList("foo", type).first());
+        }
+
+        // Cleanup
+        schema.removeField("foo");
+    }
+
+    // Special test for making sure that binary data in all forms are transformed correctly
+    // when moving between nullable and required states.
     @Test
-    public void setRemovePrimaryKey() {
+    public void binaryData_nullabilityConversions() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
+        schema.addRealmListField("foo", byte[].class);
+
+        DynamicRealmObject obj = ((DynamicRealm) realm).createObject(schema.getClassName());
+        RealmList<byte[]> list = obj.getList("foo", byte[].class);
+        assertTrue(list.size() == 0);
+
+        // Initial content (nullable)
+        list.add(null);
+        list.add(new byte[] {1, 2, 3});
+        assertNull(list.get(0));
+        assertArrayEquals(new byte[] {1, 2, 3}, list.get(1));
+
+        // Transform to required
+        schema.setRequired("foo", true);
+        list = obj.getList("foo", byte[].class);
+        assertEquals(0, list.get(0).length);
+        assertArrayEquals(new byte[] {1, 2, 3}, list.get(1));
+
+        // Transform back to nullable
+        schema.setRequired("foo", false);
+        list = obj.getList("foo", byte[].class);
+        assertEquals(0, list.get(0).length);
+        assertArrayEquals(new byte[] {1, 2, 3}, list.get(1));
+    }
+    
+    @Test
+    public void setRequired_true_onPrimaryKeyField_containsNullValues_shouldThrow() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
+        for (PrimaryKeyFieldType fieldType : PrimaryKeyFieldType.values()) {
+            String className = fieldType.getType().getSimpleName() + "Class";
+            String fieldName = "primaryKey";
+            schema = realmSchema.create(className);
+            if (!fieldType.isNullable()) {
+                continue;
+            }
+            schema.addField(fieldName, fieldType.getType(), FieldAttribute.PRIMARY_KEY);
+            DynamicRealmObject object = ((DynamicRealm)realm).createObject(schema.getClassName(), null);
+            assertTrue(object.isNull(fieldName));
+            try {
+                schema.setRequired(fieldName, true);
+                fail();
+            } catch (IllegalStateException expected) {
+                assertThat(expected.getMessage(),
+                        CoreMatchers.containsString("The primary key field 'primaryKey' has 'null' values stored."));
+            }
+            realmSchema.remove(className);
+        }
+    }
+
+    private void setRequired_onPrimaryKeyField(boolean isRequired) {
+        for (PrimaryKeyFieldType fieldType : PrimaryKeyFieldType.values()) {
+            String className = fieldType.getType().getSimpleName() + "Class";
+            String fieldName = "primaryKey";
+            schema = realmSchema.create(className);
+            if (!fieldType.isNullable()) {
+                continue;
+            }
+            if (isRequired) {
+                schema.addField(fieldName, fieldType.getType(), FieldAttribute.PRIMARY_KEY);
+            } else {
+                schema.addField(fieldName, fieldType.getType(), FieldAttribute.PRIMARY_KEY, FieldAttribute.REQUIRED);
+            }
+            ((DynamicRealm)realm).createObject(schema.getClassName(), "1");
+            ((DynamicRealm)realm).createObject(schema.getClassName(), "2");
+            assertTrue(schema.hasPrimaryKey());
+            assertTrue(schema.hasIndex(fieldName));
+
+            schema.setRequired(fieldName, isRequired);
+            assertTrue(schema.hasPrimaryKey());
+            assertTrue(schema.hasIndex(fieldName));
+
+            RealmResults<DynamicRealmObject> results = ((DynamicRealm)realm).where(className).findAllSorted(fieldName);
+            assertEquals(2, results.size());
+            if (fieldType == PrimaryKeyFieldType.STRING) {
+                assertEquals("1", results.get(0).getString(fieldName));
+                assertEquals("2", results.get(1).getString(fieldName));
+            } else {
+                assertEquals(1, results.get(0).getLong(fieldName));
+                assertEquals(2, results.get(1).getLong(fieldName));
+            }
+            realmSchema.remove(className);
+        }
+    }
+
+    @Test
+    public void setRequired_true_onPrimaryKeyField() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
+        setRequired_onPrimaryKeyField(true);
+    }
+
+    @Test
+    public void setRequired_false_onPrimaryKeyField() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
+        setRequired_onPrimaryKeyField(false);
+    }
+
+    private void setRequired_onIndexedField(boolean toRequired) {
+        String fieldName = "IndexedField";
+        for (IndexFieldType fieldType : IndexFieldType.values()) {
+            if (!fieldType.isNullable()) {
+                continue;
+            }
+            if (toRequired) {
+                schema.addField(fieldName, fieldType.getType(), FieldAttribute.INDEXED);
+            } else {
+                schema.addField(fieldName, fieldType.getType(), FieldAttribute.INDEXED, FieldAttribute.REQUIRED);
+            }
+            assertTrue(schema.hasIndex(fieldName));
+            schema.setRequired(fieldName, toRequired);
+            assertTrue(schema.hasIndex(fieldName));
+            schema.removeField(fieldName);
+        }
+    }
+
+    @Test
+    public void setRequired_true_onIndexedField() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
+        setRequired_onIndexedField(true);
+    }
+
+    @Test
+    public void setRequired_false_onIndexedField() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
+        setRequired_onIndexedField(false);
+    }
+
+    @Test
+    public void setPrimaryKey_trueAndFalse() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            try {
+                schema.addPrimaryKey("test");
+                fail();
+            } catch (UnsupportedOperationException ignore){
+
+            }
+            try {
+                schema.removePrimaryKey();
+                fail();
+            } catch (UnsupportedOperationException ignore){
+            }
+            return;
+        }
         for (PrimaryKeyFieldType fieldType : PrimaryKeyFieldType.values()) {
             String fieldName = "foo";
             schema.addField(fieldName, fieldType.getType());
@@ -526,6 +1015,9 @@ public void setRemovePrimaryKey() {
 
     @Test
     public void removeNonExistingPrimaryKeyThrows() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
         String fieldName = "foo";
         schema.addField(fieldName, String.class);
 
@@ -534,7 +1026,20 @@ public void removeNonExistingPrimaryKeyThrows() {
     }
 
     @Test
-    public void setRemoveIndex() {
+    public void setIndex_trueAndFalse() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            try {
+                schema.addIndex("test");
+                fail();
+            } catch (UnsupportedOperationException ignore) {
+            }
+            try {
+                schema.removeIndex("test");
+                fail();
+            } catch (UnsupportedOperationException ignore) {
+            }
+            return;
+        }
         for (IndexFieldType fieldType : IndexFieldType.values()) {
             String fieldName = "foo";
             schema.addField(fieldName, fieldType.getType(), FieldAttribute.INDEXED);
@@ -547,6 +1052,9 @@ public void setRemoveIndex() {
 
     @Test
     public void removeNonExistingIndexThrows() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
         String fieldName = "foo";
         schema.addField(fieldName, String.class);
 
@@ -556,6 +1064,11 @@ public void removeNonExistingIndexThrows() {
 
     @Test
     public void removeField() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            thrown.expect(UnsupportedOperationException.class);
+            DOG_SCHEMA.removeField(Dog.FIELD_HEIGHT);
+            return;
+        }
         String fieldName = "foo";
         schema.addField(fieldName, String.class);
         assertTrue(schema.hasField(fieldName));
@@ -565,6 +1078,9 @@ public void removeField() {
 
     @Test
     public void removeField_withPrimaryKey() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
         String fieldName = "foo";
         schema.addField(fieldName, String.class, FieldAttribute.PRIMARY_KEY);
         assertTrue(schema.hasField(fieldName));
@@ -576,6 +1092,9 @@ public void removeField_withPrimaryKey() {
 
     @Test
     public void removeField_nonExistingFieldThrows() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
         String fieldName = "foo";
 
         thrown.expect(IllegalStateException.class);
@@ -584,6 +1103,11 @@ public void removeField_nonExistingFieldThrows() {
 
     @Test
     public void renameField() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            thrown.expect(UnsupportedOperationException.class);
+            schema.renameField("test", "test1");
+            return;
+        }
         String oldFieldName = "old";
         String newFieldName = "new";
         schema.addField(oldFieldName, String.class);
@@ -596,6 +1120,9 @@ public void renameField() {
 
     @Test
     public void renameField_nonExistingFieldThrows() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
         String oldFieldName = "old";
         String newFieldName = "new";
 
@@ -605,6 +1132,9 @@ public void renameField_nonExistingFieldThrows() {
 
     @Test
     public void renameField_toIllegalNameThrows() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
         String oldFieldName = "old";
         String newFieldName = "";
         schema.addField(oldFieldName, String.class);
@@ -615,6 +1145,9 @@ public void renameField_toIllegalNameThrows() {
 
     @Test
     public void renameField_withPrimaryKey() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
         String fieldName = "foo";
         schema.addField(fieldName, String.class, FieldAttribute.PRIMARY_KEY);
         assertTrue(schema.hasField(fieldName));
@@ -629,19 +1162,41 @@ public void renameField_withPrimaryKey() {
 
     @Test
     public void setGetClassName() {
+        final String[] validClassNames = {
+                TestHelper.getRandomString(1),
+                "Darby",
+                TestHelper.getRandomString(Table.CLASS_NAME_MAX_LENGTH)
+        };
+
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            thrown.expect(UnsupportedOperationException.class);
+            DOG_SCHEMA.setClassName(validClassNames[0]);
+            return;
+        }
+
         assertEquals("Dog", DOG_SCHEMA.getClassName());
-        String newClassName = "Darby";
-        DOG_SCHEMA.setClassName(newClassName);
-        assertEquals(newClassName, DOG_SCHEMA.getClassName());
-        assertTrue(realmSchema.contains(newClassName));
+        for (String validClassName : validClassNames) {
+            DOG_SCHEMA.setClassName(validClassName);
+            assertEquals(validClassName, DOG_SCHEMA.getClassName());
+            assertTrue(realmSchema.contains(validClassName));
+        }
     }
 
     @Test
     public void transform() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            thrown.expect(UnsupportedOperationException.class);
+            DOG_SCHEMA.transform(new RealmObjectSchema.Function() {
+                @Override
+                public void apply(DynamicRealmObject obj) {
+                }
+            });
+            return;
+        }
         String className = DOG_SCHEMA.getClassName();
-        DynamicRealmObject dog1 = realm.createObject(className);
+        DynamicRealmObject dog1 = ((DynamicRealm)realm).createObject(className);
         dog1.setInt("age", 1);
-        DynamicRealmObject dog2 = realm.createObject(className);
+        DynamicRealmObject dog2 = ((DynamicRealm)realm).createObject(className);
         dog2.setInt("age", 2);
 
         DOG_SCHEMA.transform(new RealmObjectSchema.Function() {
@@ -650,25 +1205,28 @@ public void apply(DynamicRealmObject obj) {
                 obj.setInt("age", obj.getInt("age") + 1);
             }
         });
-        assertEquals(5, realm.where("Dog").sum("age").intValue());
+        assertEquals(5, ((DynamicRealm)realm).where("Dog").sum("age").intValue());
     }
 
     @Test
     public void transformObjectReferences() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
         String className = DOG_SCHEMA.getClassName();
-        DynamicRealmObject dog1 = realm.createObject(className);
+        DynamicRealmObject dog1 = ((DynamicRealm)realm).createObject(className);
         dog1.setInt("age", 1);
 
         DOG_SCHEMA.transform(new RealmObjectSchema.Function() {
             @Override
             public void apply(DynamicRealmObject dog) {
-                DynamicRealmObject owner = realm.createObject("Owner");
+                DynamicRealmObject owner = ((DynamicRealm)realm).createObject("Owner");
                 owner.setString("name", "John");
                 dog.setObject("owner", owner);
             }
         });
         //noinspection ConstantConditions
-        assertEquals("John", realm.where("Dog").findFirst().getObject("owner").getString("name"));
+        assertEquals("John", ((DynamicRealm)realm).where("Dog").findFirst().getObject("owner").getString("name"));
     }
 
     @Test
@@ -686,7 +1244,7 @@ public void getFieldNames() {
 
     @Test
     public void getFieldType() {
-        schema = realmSchema.getSchemaForClass("AllJavaTypes");
+        schema = realmSchema.get("AllJavaTypes");
         assertEquals(RealmFieldType.STRING, schema.getFieldType(AllJavaTypes.FIELD_STRING));
         assertEquals(RealmFieldType.BINARY, schema.getFieldType(AllJavaTypes.FIELD_BINARY));
         assertEquals(RealmFieldType.BOOLEAN, schema.getFieldType(AllJavaTypes.FIELD_BOOLEAN));
@@ -738,21 +1296,42 @@ public void getFieldIndex() {
         RealmConfiguration emptyConfig = configFactory.createConfiguration("empty");
         DynamicRealm dynamicRealm = DynamicRealm.getInstance(emptyConfig);
         dynamicRealm.beginTransaction();
-        StandardRealmObjectSchema objectSchema = (StandardRealmObjectSchema) dynamicRealm.getSchema().create(className);
+        RealmObjectSchema objectSchema = dynamicRealm.getSchema().create(className);
 
-        assertNull(objectSchema.getFieldIndex(fieldName));
+        assertTrue(objectSchema.getFieldIndex(fieldName) < 0);
 
         objectSchema.addField(fieldName, long.class);
         //noinspection ConstantConditions
         assertTrue(objectSchema.getFieldIndex(fieldName) >= 0);
 
         objectSchema.removeField(fieldName);
-        assertNull(objectSchema.getFieldIndex(fieldName));
+        assertTrue(objectSchema.getFieldIndex(fieldName) < 0);
 
         dynamicRealm.cancelTransaction();
         dynamicRealm.close();
     }
 
+    @Test
+    public void getFieldType_nonLatinName() {
+        RealmObjectSchema objSchema = realm.getSchema().get(NonLatinFieldNames.class.getSimpleName());
+        assertEquals(RealmFieldType.INTEGER, objSchema.getFieldType(NonLatinFieldNames.FIELD_LONG_GREEK_CHAR));
+    }
+
+    @Test
+    public void addList_modelClassThrowsWithProperError() {
+        if (type == ObjectSchemaType.IMMUTABLE) {
+            return;
+        }
+
+        try {
+            schema.addRealmListField("field", AllJavaTypes.class);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertTrue(e.getMessage().contains("Use 'addRealmListField(String name, RealmObjectSchema schema)' instead"));
+        }
+    }
+
+
     private interface FieldRunnable {
         void run(String fieldName);
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
index f99ae25334..667336ce69 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
@@ -19,14 +19,18 @@
 import android.support.test.rule.UiThreadTestRule;
 import android.support.test.runner.AndroidJUnit4;
 
+import org.hamcrest.CoreMatchers;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
 import java.io.FileNotFoundException;
+import java.nio.charset.Charset;
+import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.concurrent.Callable;
@@ -45,8 +49,10 @@
 import io.realm.entities.CustomMethods;
 import io.realm.entities.CyclicType;
 import io.realm.entities.Dog;
+import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.NullTypes;
 import io.realm.entities.StringAndInt;
+import io.realm.entities.pojo.AllTypesRealmModel;
 import io.realm.exceptions.RealmException;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
@@ -61,6 +67,8 @@
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -113,7 +121,7 @@ public void row_isValid() {
         realm.commitTransaction();
 
         assertNotNull("RealmObject.realmGetRow returns zero ", row);
-        assertEquals(9, row.getColumnCount());
+        assertEquals(17, row.getColumnCount());
     }
 
     @Test
@@ -456,8 +464,9 @@ public void toString_cyclicObject() {
         realm.beginTransaction();
         CyclicType foo = createCyclicData();
         realm.commitTransaction();
-        String expected = "CyclicType = [{id:0},{name:Foo},{date:null},{object:CyclicType},{otherObject:null},{objects:RealmList<CyclicType>[0]}]";
-        assertEquals(expected, foo.toString());
+        assertEquals(
+                "CyclicType = proxy[{id:0},{name:Foo},{date:null},{object:CyclicType},{otherObject:null},{objects:RealmList<CyclicType>[0]}]",
+                foo.toString());
     }
 
     @Test
@@ -899,6 +908,37 @@ public void run() {
         thread.join();
     }
 
+    @Test
+    public void setter_list_ownList() {
+        // Create initial list
+        realm.beginTransaction();
+        RealmList<AllJavaTypes> allTypesRealmModels = new RealmList<>();
+        for (int i = 0; i < 2; i++) {
+            allTypesRealmModels.add(new AllJavaTypes(i));
+        }
+        AllJavaTypes model = new AllJavaTypes(2);
+        model.setFieldList(allTypesRealmModels);
+        model = realm.copyToRealm(model);
+        realm.commitTransaction();
+        assertEquals(2, model.getFieldList().size());
+
+        // Check that setting own list does not clear it by accident.
+        realm.beginTransaction();
+        model.setFieldList(model.getFieldList());
+        realm.commitTransaction();
+        assertEquals(2, model.getFieldList().size());
+
+        // Check that a unmanaged list throws the correct exception
+        realm.beginTransaction();
+        RealmList<AllJavaTypes> unmanagedList = new RealmList<>();
+        unmanagedList.addAll(realm.copyFromRealm(model.getFieldList()));
+        try {
+            model.setFieldList(unmanagedList);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
     @Test
     public void classNameConflictsWithFrameworkClass() {
         // The model class' name (Thread) clashed with a common Java class.
@@ -1313,7 +1353,7 @@ private RealmConfiguration prepareColumnSwappedRealm() throws FileNotFoundExcept
                 .migration(new RealmMigration() {
                     @Override
                     public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
-                        final Table table = realm.schema.getTable(StringAndInt.class);
+                        final Table table = realm.getSchema().getTable(StringAndInt.class);
                         final long strIndex = table.getColumnIndex("str");
                         final long numberIndex = table.getColumnIndex("number");
 
@@ -1376,7 +1416,7 @@ public void execute(Realm realm) {
     @Test
     public void conflictingFieldName_readAndUpdate() {
         final ConflictingFieldName unmanaged = new ConflictingFieldName();
-        unmanaged.setRealm("realm");
+        unmanaged.setRealmString("realm");
         unmanaged.setRow("row");
         unmanaged.setIsCompleted("isCompleted");
         unmanaged.setListeners("listeners");
@@ -1392,7 +1432,7 @@ public void execute(Realm realm) {
 
         // Tests those values are persisted.
         final ConflictingFieldName managed = realm.where(ConflictingFieldName.class).findFirst();
-        assertEquals("realm", managed.getRealm());
+        assertEquals("realm", managed.getRealmString());
         assertEquals("row", managed.getRow());
         assertEquals("isCompleted", managed.getIsCompleted());
         assertEquals("listeners", managed.getListeners());
@@ -1403,7 +1443,7 @@ public void execute(Realm realm) {
         realm.executeTransaction(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
-                managed.setRealm("realm_updated");
+                managed.setRealmString("realm_updated");
                 managed.setRow("row_updated");
                 managed.setIsCompleted("isCompleted_updated");
                 managed.setListeners("listeners_updated");
@@ -1412,7 +1452,7 @@ public void execute(Realm realm) {
             }
         });
 
-        assertEquals("realm_updated", managed.getRealm());
+        assertEquals("realm_updated", managed.getRealmString());
         assertEquals("row_updated", managed.getRow());
         assertEquals("isCompleted_updated", managed.getIsCompleted());
         assertEquals("listeners_updated", managed.getListeners());
@@ -1922,4 +1962,204 @@ public void execute(Realm realm) {
             }
         });
     }
+
+    @Test
+    public void getRealm_managedRealmObject() {
+        realm.beginTransaction();
+        AllTypes object = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        assertSame(realm, object.getRealm());
+        assertSame(realm, RealmObject.getRealm(object));
+    }
+
+    @Test
+    public void getRealm_managedRealmModel() {
+        realm.beginTransaction();
+        AllTypesRealmModel object = realm.createObject(AllTypesRealmModel.class, 1L);
+        realm.commitTransaction();
+
+        assertSame(realm, RealmObject.getRealm(object));
+    }
+
+    @Test
+    public void getRealm_DynamicRealmObject() {
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realmConfig);
+        //noinspection TryFinallyCanBeTryWithResources
+        try {
+            dynamicRealm.beginTransaction();
+            DynamicRealmObject object = dynamicRealm.createObject("AllTypesRealmModel", 1L);
+            dynamicRealm.commitTransaction();
+
+            try {
+                object.getRealm();
+                fail();
+            } catch (IllegalStateException expected) {
+                assertEquals(RealmObject.MSG_DYNAMIC_OBJECT, expected.getMessage());
+            }
+            try {
+                RealmObject.getRealm(object);
+                fail();
+            } catch (IllegalStateException expected) {
+                assertEquals(RealmObject.MSG_DYNAMIC_OBJECT, expected.getMessage());
+            }
+        } finally {
+            dynamicRealm.close();
+        }
+    }
+
+    @Test
+    public void getRealm_unmanagedRealmObjectReturnsNull() {
+        assertNull(new AllTypes().getRealm());
+        assertNull(RealmObject.getRealm(new AllTypes()));
+    }
+
+    @Test
+    public void getRealm_unmanagedRealmModelReturnsNull() {
+        assertNull(RealmObject.getRealm(new AllTypesRealmModel()));
+    }
+
+    @Test
+    public void getRealm_null() {
+        try {
+            RealmObject.getRealm(null);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertEquals(RealmObject.MSG_NULL_OBJECT, expected.getMessage());
+        }
+    }
+
+    @Test
+    public void getRealm_closedObjectThrows() {
+        realm.beginTransaction();
+        AllTypes object = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        realm.close();
+        realm = null;
+
+        try {
+            object.getRealm();
+            fail();
+        } catch (IllegalStateException e) {
+            assertEquals(BaseRealm.CLOSED_REALM_MESSAGE, e.getMessage());
+        }
+        try {
+            RealmObject.getRealm(object);
+            fail();
+        } catch (IllegalStateException e) {
+            assertEquals(BaseRealm.CLOSED_REALM_MESSAGE, e.getMessage());
+        }
+    }
+
+    @Test
+    public void getRealmConfiguration_deletedObjectThrows() {
+        realm.beginTransaction();
+        AllTypes object = realm.createObject(AllTypes.class);
+        object.deleteFromRealm();
+        realm.commitTransaction();
+
+        try {
+            object.getRealm();
+            fail();
+        } catch (IllegalStateException e) {
+            assertEquals(RealmObject.MSG_DELETED_OBJECT, e.getMessage());
+        }
+        try {
+            RealmObject.getRealm(object);
+            fail();
+        } catch (IllegalStateException e) {
+            assertEquals(RealmObject.MSG_DELETED_OBJECT, e.getMessage());
+        }
+    }
+
+    @Test
+    public void getRealm_illegalThreadThrows() throws Throwable {
+        realm.beginTransaction();
+        final AllTypes object = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        final CountDownLatch threadFinished = new CountDownLatch(1);
+        final AtomicReference<Throwable> throwable = new AtomicReference<>();
+        final Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    object.getRealm();
+                    fail();
+                } catch (Throwable t) {
+                    throwable.set(t);
+                    threadFinished.countDown();
+                    return;
+                }
+                try {
+                    RealmObject.getRealm(object);
+                    fail();
+                } catch (Throwable t) {
+                    throwable.set(t);
+                } finally {
+                    threadFinished.countDown();
+                }
+            }
+        });
+        thread.start();
+        TestHelper.awaitOrFail(threadFinished);
+
+        final Throwable thrownInTheThread = throwable.get();
+        if (!(thrownInTheThread instanceof IllegalStateException)) {
+            throw thrownInTheThread;
+        }
+        assertEquals(BaseRealm.INCORRECT_THREAD_MESSAGE, thrownInTheThread.getMessage());
+    }
+
+    @Test
+    public void setter_binary_long_values() {
+        byte[] longBinary = new byte[Table.MAX_BINARY_SIZE];
+        byte[] tooLongBinary = new byte[Table.MAX_BINARY_SIZE + 1];
+
+        realm.beginTransaction();
+        AllTypes allTypes = realm.createObject(AllTypes.class);
+        allTypes.setColumnBinary(longBinary);
+        realm.commitTransaction();
+        assertEquals(longBinary.length, allTypes.getColumnBinary().length);
+
+        realm.beginTransaction();
+        try {
+            allTypes.setColumnBinary(tooLongBinary);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertThat(expected.getMessage(), CoreMatchers.containsString("which exceeds the max binary size"));
+        }
+    }
+
+    @Test
+    public void setter_string_long_values() {
+        byte[] tooLongBinary = new byte[Table.MAX_STRING_SIZE + 1];
+        Arrays.fill(tooLongBinary, (byte) 'a');
+        String longString = new String(tooLongBinary, 0, Table.MAX_STRING_SIZE, Charset.forName("US-ASCII"));
+        String tooLongString = new String(tooLongBinary, 0, Table.MAX_STRING_SIZE + 1, Charset.forName("US-ASCII"));
+
+        realm.beginTransaction();
+        AllTypes allTypes = realm.createObject(AllTypes.class);
+        allTypes.setColumnString(longString);
+        realm.commitTransaction();
+        assertEquals(longString.length(), allTypes.getColumnString().length());
+
+        realm.beginTransaction();
+        try {
+            allTypes.setColumnString(tooLongString);
+            fail();
+        } catch (IllegalArgumentException expected) {
+            assertThat(expected.getMessage(), CoreMatchers.containsString("which exceeds the max string length"));
+        }
+    }
+
+    @Test
+    public void setter_nonLatinFieldName() {
+        // Reproduces https://github.com/realm/realm-java/pull/5346
+        realm.beginTransaction();
+        NonLatinFieldNames obj = realm.createObject(NonLatinFieldNames.class);
+        obj.setΔέλτα(42);
+        realm.commitTransaction();
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java
index 023cca9f73..7646e91645 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmProxyMediatorTests.java
@@ -58,10 +58,9 @@ public void tearDown() {
     }
 
     @Test
-    public void validateTable_noDuplicateIndexInIndexFields() {
+    public void createColumnInfo_noDuplicateIndexInIndexFields() {
         RealmProxyMediator mediator = realm.getConfiguration().getSchemaMediator();
-        CatRealmProxy.CatColumnInfo columnInfo;
-        columnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+        CatRealmProxy.CatColumnInfo columnInfo = (CatRealmProxy.CatColumnInfo) mediator.createColumnInfo(Cat.class, realm.sharedRealm.getSchemaInfo());
 
         final Set<Long> indexSet = new HashSet<Long>();
         int indexCount = 0;
@@ -87,10 +86,10 @@ public void validateTable_noDuplicateIndexInIndexFields() {
     }
 
     @Test
-    public void validateTable_noDuplicateIndexInIndicesMap() {
+    public void createColumnInfo_noDuplicateIndexInIndicesMap() {
         RealmProxyMediator mediator = realm.getConfiguration().getSchemaMediator();
         CatRealmProxy.CatColumnInfo columnInfo;
-        columnInfo = (CatRealmProxy.CatColumnInfo) mediator.validateTable(Cat.class, realm.sharedRealm, false);
+        columnInfo = (CatRealmProxy.CatColumnInfo) mediator.createColumnInfo(Cat.class, realm.sharedRealm.getSchemaInfo());
 
         final Set<Long> indexSet = new HashSet<Long>();
         int indexCount = 0;
@@ -100,7 +99,7 @@ public void validateTable_noDuplicateIndexInIndicesMap() {
             if (Modifier.isStatic(field.getModifiers())) {
                 continue;
             }
-            indexSet.add(columnInfo.getIndicesMap().get(field.getName()));
+            indexSet.add(columnInfo.getColumnIndex(field.getName()));
             indexCount++;
         }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index 8be7cc00fa..35456d248c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -18,20 +18,14 @@
 
 import android.support.test.runner.AndroidJUnit4;
 
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
+import org.junit.Ignore;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
 import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Date;
-import java.util.List;
+import java.util.Locale;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
@@ -41,6 +35,7 @@
 import io.realm.entities.Cat;
 import io.realm.entities.CatOwner;
 import io.realm.entities.Dog;
+import io.realm.entities.IndexedFields;
 import io.realm.entities.NoPrimaryKeyNullTypes;
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.NullTypes;
@@ -51,9 +46,7 @@
 import io.realm.entities.PrimaryKeyAsBoxedShort;
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.entities.StringOnly;
-import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
-import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -62,33 +55,7 @@
 import static org.junit.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
-public class RealmQueryTests {
-    @Rule
-    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
-    @Rule
-    public final ExpectedException thrown = ExpectedException.none();
-    @Rule
-    public final RunInLooperThread looperThread = new RunInLooperThread();
-
-    private final static int TEST_DATA_SIZE = 10;
-    private final static int TEST_NO_PRIMARY_KEY_NULL_TYPES_SIZE = 200;
-
-    private final static long DECADE_MILLIS = 10 * TimeUnit.DAYS.toMillis(365);
-
-    private Realm realm;
-
-    @Before
-    public void setUp() throws Exception {
-        RealmConfiguration realmConfig = configFactory.createConfiguration();
-        realm = Realm.getInstance(realmConfig);
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        if (realm != null) {
-            realm.close();
-        }
-    }
+public class RealmQueryTests extends QueryTests {
 
     private void populateTestRealm(Realm testRealm, int dataSize) {
         testRealm.beginTransaction();
@@ -1228,7 +1195,7 @@ public void like_caseSensitiveWithNonLatinCharacters() {
         realm.commitTransaction();
 
         RealmResults<AllTypes> resultList = realm.where(AllTypes.class).like("columnString", "*Α*").findAll();
-         assertEquals(1, resultList.size());
+        assertEquals(1, resultList.size());
 
         resultList = realm.where(AllTypes.class).like("columnString", "*λ*").findAll();
         assertEquals(2, resultList.size());
@@ -2587,46 +2554,6 @@ public void isNotNull_listFieldThrows() {
         }
     }
 
-    // @Test Disabled because of time consuming.
-    public void largeRealmMultipleThreads() throws InterruptedException {
-        final int nObjects = 500000;
-        final int nThreads = 3;
-        final CountDownLatch latch = new CountDownLatch(nThreads);
-
-        realm.beginTransaction();
-        realm.delete(StringOnly.class);
-        for (int i = 0; i < nObjects; i++) {
-            StringOnly stringOnly = realm.createObject(StringOnly.class);
-            stringOnly.setChars(String.format("string %d", i));
-        }
-        realm.commitTransaction();
-
-
-        for (int i = 0; i < nThreads; i++) {
-            Thread thread = new Thread(
-                    new Runnable() {
-                        @Override
-                        @SuppressWarnings("ElementsCountedInLoop")
-                        public void run() {
-                            RealmConfiguration realmConfig = configFactory.createConfiguration();
-                            Realm realm = Realm.getInstance(realmConfig);
-                            RealmResults<StringOnly> realmResults = realm.where(StringOnly.class).findAll();
-                            int n = 0;
-                            for (StringOnly ignored : realmResults) {
-                                n = n + 1;
-                            }
-                            assertEquals(nObjects, n);
-                            realm.close();
-                            latch.countDown();
-                        }
-                    }
-            );
-            thread.start();
-        }
-
-        TestHelper.awaitOrFail(latch);
-    }
-
     @Test
     public void isValid_tableQuery() {
         final RealmQuery<AllTypes> query = realm.where(AllTypes.class);
@@ -2706,58 +2633,25 @@ public void isValid_removedParent() {
         assertFalse(query.isValid());
     }
 
-
-    private static final List<RealmFieldType> SUPPORTED_IS_EMPTY_TYPES = Arrays.asList(
-            RealmFieldType.STRING,
-            RealmFieldType.BINARY,
-            RealmFieldType.LIST);
-
-    private static final List<RealmFieldType> NOT_SUPPORTED_IS_EMPTY_TYPES;
-    static {
-        final ArrayList<RealmFieldType> list = new ArrayList<RealmFieldType>(Arrays.asList(RealmFieldType.values()));
-        list.removeAll(SUPPORTED_IS_EMPTY_TYPES);
-        list.remove(RealmFieldType.UNSUPPORTED_MIXED);
-        list.remove(RealmFieldType.UNSUPPORTED_TABLE);
-        list.remove(RealmFieldType.UNSUPPORTED_DATE);
-        NOT_SUPPORTED_IS_EMPTY_TYPES = list;
-    }
-
-    private void createIsEmptyDataSet(Realm realm) {
-        realm.beginTransaction();
-
-        AllJavaTypes emptyValues = new AllJavaTypes();
-        emptyValues.setFieldId(1);
-        emptyValues.setFieldString("");
-        emptyValues.setFieldBinary(new byte[0]);
-        emptyValues.setFieldObject(emptyValues);
-        emptyValues.setFieldList(new RealmList<AllJavaTypes>());
-        realm.copyToRealm(emptyValues);
-
-        AllJavaTypes nonEmpty = new AllJavaTypes();
-        nonEmpty.setFieldId(2);
-        nonEmpty.setFieldString("Foo");
-        nonEmpty.setFieldBinary(new byte[]{1, 2, 3});
-        nonEmpty.setFieldObject(nonEmpty);
-        nonEmpty.setFieldList(new RealmList<AllJavaTypes>(emptyValues));
-        realm.copyToRealmOrUpdate(nonEmpty);
-
-        realm.commitTransaction();
-    }
-
     @Test
     public void isEmpty() {
         createIsEmptyDataSet(realm);
         for (RealmFieldType type : SUPPORTED_IS_EMPTY_TYPES) {
             switch (type) {
                 case STRING:
-                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_STRING).count());
+                    assertEquals(2, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_STRING).count());
                     break;
                 case BINARY:
-                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_BINARY).count());
+                    assertEquals(2, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_BINARY).count());
                     break;
                 case LIST:
                     assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LIST).count());
                     break;
+                case LINKING_OBJECTS:
+                    // Row 2 does not have a backlink
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_OBJECT).count());
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_LO_LIST).count());
+                    break;
                 default:
                     fail("Unknown type: " + type);
             }
@@ -2776,7 +2670,18 @@ public void isEmpty_acrossLink() {
                     assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY).count());
                     break;
                 case LIST:
-                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LIST).count());
+                    // Row 0: Backlink list to row 1, list to row 0; included
+                    // Row 1: Backlink list to row 2, list to row 1; included
+                    // Row 2: No backlink list; not included
+                    assertEquals(2, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LIST).count());
+                    break;
+                case LINKING_OBJECTS:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_LIST).count());
+
+                    // Row 0: Link to row 0, backlink to row 0; not included
+                    // Row 1: Link to row 1m backlink to row 1; not included
+                    // Row 2: Empty link; included
+                    assertEquals(1, realm.where(AllJavaTypes.class).isEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
                     break;
                 default:
                     fail("Unknown type: " + type);
@@ -2829,42 +2734,24 @@ public void isEmpty_invalidFieldNameThrows() {
         }
     }
 
-    // Not-empty test harnesses.
-    private static final List<RealmFieldType> SUPPORTED_IS_NOT_EMPTY_TYPES = Arrays.asList(
-            RealmFieldType.STRING,
-            RealmFieldType.BINARY,
-            RealmFieldType.LIST);
-
-    private static final List<RealmFieldType> NOT_SUPPORTED_IS_NOT_EMPTY_TYPES;
-    static {
-        final ArrayList<RealmFieldType> list = new ArrayList<RealmFieldType>(Arrays.asList(RealmFieldType.values()));
-        list.removeAll(SUPPORTED_IS_NOT_EMPTY_TYPES);
-        list.remove(RealmFieldType.UNSUPPORTED_MIXED);
-        list.remove(RealmFieldType.UNSUPPORTED_TABLE);
-        list.remove(RealmFieldType.UNSUPPORTED_DATE);
-        NOT_SUPPORTED_IS_NOT_EMPTY_TYPES = list;
-    }
-
-    private void createIsNotEmptyDataSet(Realm realm) {
-        realm.beginTransaction();
-
-        AllJavaTypes emptyValues = new AllJavaTypes();
-        emptyValues.setFieldId(1);
-        emptyValues.setFieldString("");
-        emptyValues.setFieldBinary(new byte[0]);
-        emptyValues.setFieldObject(emptyValues);
-        emptyValues.setFieldList(new RealmList<AllJavaTypes>());
-        realm.copyToRealm(emptyValues);
-
-        AllJavaTypes notEmpty = new AllJavaTypes();
-        notEmpty.setFieldId(2);
-        notEmpty.setFieldString("Foo");
-        notEmpty.setFieldBinary(new byte[]{1, 2, 3});
-        notEmpty.setFieldObject(notEmpty);
-        notEmpty.setFieldList(new RealmList<AllJavaTypes>(emptyValues));
-        realm.copyToRealmOrUpdate(notEmpty);
+    @Test
+    public void isEmpty_acrossLink_wrongTypeThrows() {
+        for (RealmFieldType type : RealmFieldType.values()) {
+            if (SUPPORTED_IS_EMPTY_TYPES.contains(type)) {
+                continue;
+            }
 
-        realm.commitTransaction();
+            RealmQuery<Owner> query = realm.where(Owner.class);
+            try {
+                query.isEmpty(Owner.FIELD_CAT + "." + Cat.FIELD_AGE);
+                fail();
+            } catch (IllegalArgumentException expected) {
+                assertEquals(String.format(Locale.US,
+                        "Invalid query: field '%s' in class '%s' is of invalid type '%s'.",
+                        Cat.FIELD_AGE, Cat.CLASS_NAME, RealmFieldType.INTEGER.name()),
+                        expected.getMessage());
+            }
+        }
     }
 
     @Test
@@ -2881,6 +2768,10 @@ public void isNotEmpty() {
                 case LIST:
                     assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LIST).count());
                     break;
+                case LINKING_OBJECTS:
+                    assertEquals(2, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_OBJECT).count());
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_LO_LIST).count());
+                    break;
                 default:
                     fail("Unknown type: " + type);
             }
@@ -2901,6 +2792,10 @@ public void isNotEmpty_acrossLink() {
                 case LIST:
                     assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LIST).count());
                     break;
+                case LINKING_OBJECTS:
+                    assertEquals(1, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_LIST).count());
+                    assertEquals(2, realm.where(AllJavaTypes.class).isNotEmpty(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LO_OBJECT).count());
+                    break;
                 default:
                     fail("Unknown type: " + type);
             }
@@ -3009,6 +2904,20 @@ public void onChange(RealmResults<AllTypes> results) {
         });
     }
 
+    @Test
+    public void findAll_indexedCaseInsensitiveFields() {
+        // Catches https://github.com/realm/realm-java/issues/4788
+        realm.beginTransaction();
+        realm.createObject(IndexedFields.class).indexedString = "ROVER";
+        realm.createObject(IndexedFields.class).indexedString = "Rover";
+        realm.commitTransaction();
+
+        RealmResults<IndexedFields> results = realm.where(IndexedFields.class)
+                .equalTo(IndexedFields.FIELD_INDEXED_STRING, "rover", Case.INSENSITIVE)
+                .findAll();
+        assertEquals(2, results.size());
+    }
+
     @Test
     public void findAllSorted_listOnSubObjectField() {
         String[] fieldNames = new String[2];
@@ -3084,8 +2993,8 @@ private void populateForDistinctInvalidTypesLinked(Realm realm) {
 
     @Test
     public void distinct() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // Must be greater than 1
+        final long numberOfBlocks = 3;
+        final long numberOfObjects = 3; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL);
@@ -3098,8 +3007,8 @@ public void distinct() {
 
     @Test
     public void distinct_withNullValues() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
+        final long numberOfBlocks = 3;
+        final long numberOfObjects = 3;
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
 
         for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
@@ -3110,8 +3019,8 @@ public void distinct_withNullValues() {
 
     @Test
     public void distinct_notIndexedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
+        final long numberOfBlocks = 3;
+        final long numberOfObjects = 3;
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class)
@@ -3126,8 +3035,8 @@ public void distinct_notIndexedFields() {
 
     @Test
     public void distinct_doesNotExist() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // Must be greater than 1
+        final long numberOfBlocks = 3;
+        final long numberOfObjects = 3; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         try {
@@ -3151,8 +3060,8 @@ public void distinct_invalidTypes() {
 
     @Test
     public void distinct_indexedLinkedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
+        final long numberOfBlocks = 3;
+        final long numberOfObjects = 3;
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
 
         for (String field : AnnotationIndexTypes.INDEX_FIELDS) {
@@ -3166,8 +3075,8 @@ public void distinct_indexedLinkedFields() {
 
     @Test
     public void distinct_notIndexedLinkedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
+        final long numberOfBlocks = 3;
+        final long numberOfObjects = 3;
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
 
         for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
@@ -3194,8 +3103,8 @@ public void distinct_invalidTypesLinkedFields() {
     public void distinctAsync() throws Throwable {
         final AtomicInteger changeListenerCalled = new AtomicInteger(4);
         final Realm realm = looperThread.getRealm();
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // Must be greater than 1
+        final long numberOfBlocks = 3;
+        final long numberOfObjects = 3; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_INDEX_BOOL);
@@ -3270,8 +3179,8 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
     public void distinctAsync_withNullValues() throws Throwable {
         final AtomicInteger changeListenerCalled = new AtomicInteger(2);
         final Realm realm = looperThread.getRealm();
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // must be greater than 1
+        final long numberOfBlocks = 3;
+        final long numberOfObjects = 3; // must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
 
         final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class)
@@ -3311,8 +3220,8 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
     @Test
     @RunTestInLooperThread
     public void distinctAsync_doesNotExist() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
+        final long numberOfBlocks = 3;
+        final long numberOfObjects = 3;
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         try {
@@ -3339,8 +3248,8 @@ public void distinctAsync_invalidTypes() {
     @Test
     @RunTestInLooperThread
     public void distinctAsync_indexedLinkedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
+        final long numberOfBlocks = 3;
+        final long numberOfObjects = 3;
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         for (String field : AnnotationIndexTypes.INDEX_FIELDS) {
@@ -3367,8 +3276,8 @@ public void distinctAsync_notIndexedLinkedFields() {
 
     @Test
     public void distinctMultiArgs() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // Must be greater than 1
+        final long numberOfBlocks = 3;
+        final long numberOfObjects = 3; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
@@ -3378,7 +3287,7 @@ public void distinctMultiArgs() {
 
     @Test
     public void distinctMultiArgs_switchedFieldsOrder() {
-        final long numberOfBlocks = 25;
+        final long numberOfBlocks = 3;
         TestHelper.populateForDistinctFieldsOrder(realm, numberOfBlocks);
 
         // Regardless of the block size defined above, the output size is expected to be the same, 4 in this case, due to receiving unique combinations of tuples.
@@ -3392,8 +3301,8 @@ public void distinctMultiArgs_switchedFieldsOrder() {
 
     @Test
     public void distinctMultiArgs_emptyField() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
+        final long numberOfBlocks = 3;
+        final long numberOfObjects = 3;
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
@@ -3446,8 +3355,8 @@ public void distinctMultiArgs_emptyField() {
 
     @Test
     public void distinctMultiArgs_withNullValues() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
+        final long numberOfBlocks = 3;
+        final long numberOfObjects = 3;
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
@@ -3457,8 +3366,8 @@ public void distinctMultiArgs_withNullValues() {
 
     @Test
     public void distinctMultiArgs_notIndexedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
+        final long numberOfBlocks = 3;
+        final long numberOfObjects = 3;
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
@@ -3470,8 +3379,8 @@ public void distinctMultiArgs_notIndexedFields() {
 
     @Test
     public void distinctMultiArgs_doesNotExistField() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
+        final long numberOfBlocks = 3;
+        final long numberOfObjects = 3;
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
@@ -3494,8 +3403,8 @@ public void distinctMultiArgs_invalidTypesFields() {
 
     @Test
     public void distinctMultiArgs_indexedLinkedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
+        final long numberOfBlocks = 3;
+        final long numberOfObjects = 3;
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
@@ -3507,8 +3416,8 @@ public void distinctMultiArgs_indexedLinkedFields() {
 
     @Test
     public void distinctMultiArgs_notIndexedLinkedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
+        final long numberOfBlocks = 3;
+        final long numberOfObjects = 3;
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
index b4ead0c1bf..8ab8c830a9 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
@@ -34,22 +34,19 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
-import io.realm.entities.AnnotationIndexTypes;
 import io.realm.entities.DefaultValueOfField;
 import io.realm.entities.Dog;
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.Owner;
 import io.realm.entities.RandomPrimaryKey;
 import io.realm.entities.StringOnly;
-import io.realm.internal.Collection;
+import io.realm.internal.OsResults;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -102,15 +99,15 @@ public void findFirst() {
 
     @Test
     public void size_returns_Integer_MAX_VALUE_for_huge_results() {
-        final Collection collection = Mockito.mock(Collection.class);
-        final RealmResults<AllTypes> targetResult = TestHelper.newRealmResults(realm, collection, AllTypes.class);
+        final OsResults osResults = Mockito.mock(OsResults.class);
+        final RealmResults<AllTypes> targetResult = TestHelper.newRealmResults(realm, osResults, AllTypes.class);
 
-        Mockito.when(collection.isLoaded()).thenReturn(true);
-        Mockito.when(collection.size()).thenReturn(((long) Integer.MAX_VALUE) - 1);
+        Mockito.when(osResults.isLoaded()).thenReturn(true);
+        Mockito.when(osResults.size()).thenReturn(((long) Integer.MAX_VALUE) - 1);
         assertEquals(Integer.MAX_VALUE - 1, targetResult.size());
-        Mockito.when(collection.size()).thenReturn(((long) Integer.MAX_VALUE));
+        Mockito.when(osResults.size()).thenReturn(((long) Integer.MAX_VALUE));
         assertEquals(Integer.MAX_VALUE, targetResult.size());
-        Mockito.when(collection.size()).thenReturn(((long) Integer.MAX_VALUE) + 1);
+        Mockito.when(osResults.size()).thenReturn(((long) Integer.MAX_VALUE) + 1);
         assertEquals(Integer.MAX_VALUE, targetResult.size());
     }
 
@@ -185,166 +182,6 @@ public void verifyArmComparisons() {
         assertEquals(10, realm.where(AllTypes.class).lessThan(AllTypes.FIELD_LONG, 0).findAll().size());
     }
 
-    // RealmResults.distinct(): requires indexing, and type = boolean, integer, date, string.
-    private void populateForDistinct(Realm realm, long numberOfBlocks, long numberOfObjects, boolean withNull) {
-        realm.beginTransaction();
-        for (int i = 0; i < numberOfObjects * numberOfBlocks; i++) {
-            for (int j = 0; j < numberOfBlocks; j++) {
-                AnnotationIndexTypes obj = realm.createObject(AnnotationIndexTypes.class);
-                obj.setIndexBoolean(j % 2 == 0);
-                obj.setIndexLong(j);
-                obj.setIndexDate(withNull ? null : new Date(1000 * (long) j));
-                obj.setIndexString(withNull ? null : "Test " + j);
-                obj.setNotIndexBoolean(j % 2 == 0);
-                obj.setNotIndexLong(j);
-                obj.setNotIndexDate(withNull ? null : new Date(1000 * (long) j));
-                obj.setNotIndexString(withNull ? null : "Test " + j);
-            }
-        }
-        realm.commitTransaction();
-    }
-
-    private void populateForDistinctInvalidTypesLinked(Realm realm) {
-        realm.beginTransaction();
-        AllJavaTypes notEmpty = new AllJavaTypes();
-        notEmpty.setFieldBinary(new byte[]{1, 2, 3});
-        notEmpty.setFieldObject(notEmpty);
-        notEmpty.setFieldList(new RealmList<AllJavaTypes>(notEmpty));
-        realm.copyToRealm(notEmpty);
-        realm.commitTransaction();
-    }
-
-    @Test
-    public void distinct() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // Must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).findAll().distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL);
-        assertEquals(2, distinctBool.size());
-        for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
-            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).findAll().distinct(field);
-            assertEquals(field, numberOfBlocks, distinct.size());
-        }
-    }
-
-    @Test
-    @SuppressWarnings("ReferenceEquality")
-    public void distinct_restrictedByPreviousDistinct() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        // All objects
-        RealmResults<AnnotationIndexTypes> allResults = realm.where(AnnotationIndexTypes.class).findAll();
-        assertEquals("All Objects Count", numberOfBlocks * numberOfBlocks * numberOfObjects, allResults.size());
-        // Distinctive dates
-        RealmResults<AnnotationIndexTypes> distinctDates = allResults.distinct(AnnotationIndexTypes.FIELD_INDEX_DATE);
-        assertEquals("Distinctive Dates", numberOfBlocks, distinctDates.size());
-        // Distinctive Booleans
-        RealmResults<AnnotationIndexTypes> distinctBooleans = distinctDates.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL);
-        assertEquals("Distinctive Booleans", 2, distinctBooleans.size());
-        // distinct results are not the same object
-        assertTrue(allResults != distinctDates);
-        assertTrue(allResults != distinctBooleans);
-    }
-
-    @Test
-    public void distinct_withNullValues() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // Must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
-
-        for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
-            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).findAll().distinct(field);
-            assertEquals(field, 1, distinct.size());
-        }
-    }
-
-    @Test
-    public void distinct_notIndexedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // Must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class)
-                .findAll().distinct(AnnotationIndexTypes.FIELD_NOT_INDEX_BOOL);
-        assertEquals(2, distinctBool.size());
-        for (String field : new String[]{AnnotationIndexTypes.FIELD_NOT_INDEX_LONG,
-                AnnotationIndexTypes.FIELD_NOT_INDEX_DATE, AnnotationIndexTypes.FIELD_NOT_INDEX_STRING}) {
-            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).findAll()
-                    .distinct(field);
-            assertEquals(field, numberOfBlocks, distinct.size());
-        }
-    }
-
-    @Test
-    public void distinct_noneExistingField() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // Must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        try {
-            realm.where(AnnotationIndexTypes.class).findAll().distinct("doesNotExist");
-            fail();
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinct_invalidTypes() {
-        populateTestRealm();
-
-        for (String field : new String[]{AllTypes.FIELD_REALMOBJECT, AllTypes.FIELD_REALMLIST, AllTypes.FIELD_DOUBLE, AllTypes.FIELD_FLOAT}) {
-            try {
-                realm.where(AllTypes.class).findAll().distinct(field);
-                fail(field);
-            } catch (IllegalArgumentException ignored) {
-            }
-        }
-    }
-
-    @Test
-    public void distinct_indexedLinkedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // Must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
-
-        for (String field : AnnotationIndexTypes.INDEX_FIELDS) {
-            try {
-                realm.where(AnnotationIndexTypes.class).findAll().distinct(AnnotationIndexTypes.FIELD_OBJECT + "." + field);
-                fail("Unsupported Index" + field + " linked field");
-            } catch (IllegalArgumentException ignored) {
-            }
-        }
-    }
-
-    @Test
-    public void distinct_notIndexedLinkedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // Must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
-
-        for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
-            try {
-                realm.where(AnnotationIndexTypes.class).findAll().distinct(AnnotationIndexTypes.FIELD_OBJECT + "." + field);
-                fail("Unsupported notIndex" + field + " linked field");
-            } catch (IllegalArgumentException ignored) {
-            }
-        }
-    }
-
-    @Test
-    public void distinct_invalidTypesLinkedFields() {
-        populateForDistinctInvalidTypesLinked(realm);
-
-        try {
-            realm.where(AllJavaTypes.class).findAll().distinct(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY);
-            fail("Unsupported columnBinary linked field");
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
     @Test
     @RunTestInLooperThread
     public void changeListener_syncIfNeeded_updatedFromOtherThread() {
@@ -417,430 +254,6 @@ private void populateTestRealm(Realm testRealm, int objects) {
         testRealm.commitTransaction();
     }
 
-    @Test
-    @RunTestInLooperThread
-    public void distinctAsync() throws Throwable {
-        final AtomicInteger changeListenerCalled = new AtomicInteger(4);
-        final Realm realm = looperThread.getRealm();
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // Must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).findAll().distinctAsync(AnnotationIndexTypes.FIELD_INDEX_BOOL);
-        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class).findAll().distinctAsync(AnnotationIndexTypes.FIELD_INDEX_LONG);
-        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).findAll().distinctAsync(AnnotationIndexTypes.FIELD_INDEX_DATE);
-        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).findAll().distinctAsync(AnnotationIndexTypes.FIELD_INDEX_STRING);
-
-        assertFalse(distinctBool.isLoaded());
-        assertTrue(distinctBool.isValid());
-        assertTrue(distinctBool.isEmpty());
-
-        assertFalse(distinctLong.isLoaded());
-        assertTrue(distinctLong.isValid());
-        assertTrue(distinctLong.isEmpty());
-
-        assertFalse(distinctDate.isLoaded());
-        assertTrue(distinctDate.isValid());
-        assertTrue(distinctDate.isEmpty());
-
-        assertFalse(distinctString.isLoaded());
-        assertTrue(distinctString.isValid());
-        assertTrue(distinctString.isEmpty());
-
-        final Runnable endTest = new Runnable() {
-            @Override
-            public void run() {
-                if (changeListenerCalled.decrementAndGet() == 0) {
-                    looperThread.testComplete();
-                }
-            }
-        };
-
-        looperThread.keepStrongReference(distinctBool);
-        looperThread.keepStrongReference(distinctLong);
-        looperThread.keepStrongReference(distinctDate);
-        looperThread.keepStrongReference(distinctString);
-        distinctBool.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
-            @Override
-            public void onChange(RealmResults<AnnotationIndexTypes> object) {
-                assertEquals(2, distinctBool.size());
-                endTest.run();
-            }
-        });
-
-        distinctLong.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
-            @Override
-            public void onChange(RealmResults<AnnotationIndexTypes> object) {
-                assertEquals(numberOfBlocks, distinctLong.size());
-                endTest.run();
-            }
-        });
-
-        distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
-            @Override
-            public void onChange(RealmResults<AnnotationIndexTypes> object) {
-                assertEquals(numberOfBlocks, distinctDate.size());
-                endTest.run();
-            }
-        });
-
-        distinctString.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
-            @Override
-            public void onChange(RealmResults<AnnotationIndexTypes> object) {
-                assertEquals(numberOfBlocks, distinctString.size());
-                endTest.run();
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread
-    public void distinctAsync_withNullValues() throws Throwable {
-        final AtomicInteger changeListenerCalled = new AtomicInteger(2);
-        final Realm realm = looperThread.getRealm();
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // Must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
-
-        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).findAll().distinctAsync(AnnotationIndexTypes.FIELD_INDEX_DATE);
-        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).findAll().distinctAsync(AnnotationIndexTypes.FIELD_INDEX_STRING);
-
-        assertFalse(distinctDate.isLoaded());
-        assertTrue(distinctDate.isValid());
-        assertTrue(distinctDate.isEmpty());
-
-        assertFalse(distinctString.isLoaded());
-        assertTrue(distinctString.isValid());
-        assertTrue(distinctString.isEmpty());
-
-        final Runnable endTest = new Runnable() {
-            @Override
-            public void run() {
-                if (changeListenerCalled.decrementAndGet() == 0) {
-                    looperThread.testComplete();
-                }
-            }
-        };
-
-        looperThread.keepStrongReference(distinctDate);
-        looperThread.keepStrongReference(distinctString);
-        distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
-            @Override
-            public void onChange(RealmResults<AnnotationIndexTypes> object) {
-                assertEquals("distinctDate", 1, distinctDate.size());
-                endTest.run();
-            }
-        });
-
-        distinctString.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
-            @Override
-            public void onChange(RealmResults<AnnotationIndexTypes> object) {
-                assertEquals("distinctString", 1, distinctString.size());
-                endTest.run();
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread
-    public void distinctAsync_notIndexedFields() {
-        final AtomicInteger changeListenerCalled = new AtomicInteger(4);
-        Realm realm = looperThread.getRealm();
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).findAll()
-                .distinctAsync(AnnotationIndexTypes.FIELD_INDEX_BOOL);
-        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class).findAll()
-                .distinctAsync(AnnotationIndexTypes.FIELD_NOT_INDEX_LONG);
-        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).findAll()
-                .distinctAsync(AnnotationIndexTypes.FIELD_NOT_INDEX_DATE);
-        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).findAll()
-                .distinctAsync(AnnotationIndexTypes.FIELD_NOT_INDEX_STRING);
-
-        assertFalse(distinctBool.isLoaded());
-        assertTrue(distinctBool.isValid());
-        assertTrue(distinctBool.isEmpty());
-
-        assertFalse(distinctLong.isLoaded());
-        assertTrue(distinctLong.isValid());
-        assertTrue(distinctLong.isEmpty());
-
-        assertFalse(distinctDate.isLoaded());
-        assertTrue(distinctDate.isValid());
-        assertTrue(distinctDate.isEmpty());
-
-        assertFalse(distinctString.isLoaded());
-        assertTrue(distinctString.isValid());
-        assertTrue(distinctString.isEmpty());
-
-        final Runnable endTest = new Runnable() {
-            @Override
-            public void run() {
-                if (changeListenerCalled.decrementAndGet() == 0) {
-                    looperThread.testComplete();
-                }
-            }
-        };
-
-        looperThread.keepStrongReference(distinctBool);
-        looperThread.keepStrongReference(distinctLong);
-        looperThread.keepStrongReference(distinctDate);
-        looperThread.keepStrongReference(distinctString);
-        distinctBool.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
-            @Override
-            public void onChange(RealmResults<AnnotationIndexTypes> object) {
-                assertEquals(2, distinctBool.size());
-                endTest.run();
-            }
-        });
-
-        distinctLong.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
-            @Override
-            public void onChange(RealmResults<AnnotationIndexTypes> object) {
-                assertEquals(numberOfBlocks, distinctLong.size());
-                endTest.run();
-            }
-        });
-
-        distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
-            @Override
-            public void onChange(RealmResults<AnnotationIndexTypes> object) {
-                assertEquals(numberOfBlocks, distinctDate.size());
-                endTest.run();
-            }
-        });
-
-        distinctString.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
-            @Override
-            public void onChange(RealmResults<AnnotationIndexTypes> object) {
-                assertEquals(numberOfBlocks, distinctString.size());
-                endTest.run();
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread
-    public void distinctAsync_doesNotExist() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        try {
-            realm.where(AnnotationIndexTypes.class).findAll().distinctAsync("doesNotExist");
-        } catch (IllegalArgumentException ignored) {
-        }
-        looperThread.testComplete();
-    }
-
-    @Test
-    @RunTestInLooperThread
-    public void distinctAsync_invalidTypes() {
-        populateTestRealm(realm, TEST_DATA_SIZE);
-
-        for (String field : new String[]{AllTypes.FIELD_REALMOBJECT, AllTypes.FIELD_REALMLIST, AllTypes.FIELD_DOUBLE, AllTypes.FIELD_FLOAT}) {
-            try {
-                realm.where(AllTypes.class).findAll().distinctAsync(field);
-            } catch (IllegalArgumentException ignored) {
-            }
-        }
-        looperThread.testComplete();
-    }
-
-    @Test
-    @RunTestInLooperThread
-    public void distinctAsync_indexedLinkedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        for (String field : AnnotationIndexTypes.INDEX_FIELDS) {
-            try {
-                realm.where(AnnotationIndexTypes.class).findAll().distinctAsync(AnnotationIndexTypes.FIELD_OBJECT + "." + field);
-                fail("Unsupported " + field + " linked field");
-            } catch (IllegalArgumentException ignored) {
-            }
-        }
-        looperThread.testComplete();
-    }
-
-    @Test
-    @RunTestInLooperThread
-    public void distinctAsync_notIndexedLinkedFields() {
-        populateForDistinctInvalidTypesLinked(realm);
-
-        try {
-            realm.where(AllJavaTypes.class).findAll().distinctAsync(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY);
-        } catch (IllegalArgumentException ignored) {
-        }
-        looperThread.testComplete();
-    }
-
-    @Test
-    public void distinctMultiArgs() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10; // Must be greater than 1
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
-        RealmResults<AnnotationIndexTypes> distinctMulti = results.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.INDEX_FIELDS);
-        assertEquals(numberOfBlocks, distinctMulti.size());
-    }
-
-    @Test
-    public void distinctMultiArgs_switchedFieldsOrder() {
-        final long numberOfBlocks = 25;
-        TestHelper.populateForDistinctFieldsOrder(realm, numberOfBlocks);
-
-        // Regardless of the block size defined above, the output size is expected to be the same, 4 in this case, due to receiving unique combinations of tuples.
-        RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
-        RealmResults<AnnotationIndexTypes> distinctStringLong = results.distinct(AnnotationIndexTypes.FIELD_INDEX_STRING, AnnotationIndexTypes.FIELD_INDEX_LONG);
-        RealmResults<AnnotationIndexTypes> distinctLongString = results.distinct(AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_STRING);
-        assertEquals(4, distinctStringLong.size());
-        assertEquals(4, distinctLongString.size());
-        assertEquals(distinctStringLong.size(), distinctLongString.size());
-    }
-
-    @Test
-    public void distinctMultiArgs_emptyField() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
-        // An empty string field in the middle.
-        try {
-            results.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, "", AnnotationIndexTypes.FIELD_INDEX_INT);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // An empty string field at the end.
-        try {
-            results.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, "");
-        } catch (IllegalArgumentException ignored) {
-        }
-        // A null string field in the middle.
-        try {
-            results.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, null, AnnotationIndexTypes.FIELD_INDEX_INT);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // A null string field at the end.
-        try {
-            results.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, null);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // (String) Null makes varargs a null array.
-        try {
-            results.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String)null);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // Two (String) null for first and varargs fields.
-        try {
-            results.distinct(null, (String) null);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // "" & (String)null combination.
-        try {
-            results.distinct("", (String) null);
-        } catch (IllegalArgumentException ignored) {
-        }
-        // "" & (String)null combination.
-        try {
-            results.distinct(null, "");
-        } catch (IllegalArgumentException ignored) {
-        }
-        // Two empty fields tests.
-        try {
-            results.distinct("", "");
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_withNullValues() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
-
-        RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
-        RealmResults<AnnotationIndexTypes> distinctMulti = results.distinct(AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING);
-        assertEquals(1, distinctMulti.size());
-    }
-
-    @Test
-    public void distinctMultiArgs_notIndexedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
-        try {
-            results.distinct(AnnotationIndexTypes.FIELD_NOT_INDEX_STRING, AnnotationIndexTypes.NOT_INDEX_FIELDS);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_doesNotExistField() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
-
-        RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
-        try {
-            results.distinct(AnnotationIndexTypes.FIELD_INDEX_INT, AnnotationIndexTypes.NONEXISTANT_MIX_FIELDS);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_invalidTypesFields() {
-        populateTestRealm();
-
-        RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
-        try {
-            results.distinct(AllTypes.FIELD_REALMOBJECT, AllTypes.INVALID_TYPES_FIELDS_FOR_DISTINCT);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_indexedLinkedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
-
-        RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
-        try {
-            results.distinct(AnnotationIndexTypes.INDEX_LINKED_FIELD_STRING, AnnotationIndexTypes.INDEX_LINKED_FIELDS);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_notIndexedLinkedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
-
-        RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
-        try {
-            results.distinct(AnnotationIndexTypes.NOT_INDEX_LINKED_FILED_STRING, AnnotationIndexTypes.NOT_INDEX_LINKED_FIELDS);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
-
-    @Test
-    public void distinctMultiArgs_invalidTypesLinkedFields() {
-        populateForDistinctInvalidTypesLinked(realm);
-
-        RealmResults<AnnotationIndexTypes> results = realm.where(AnnotationIndexTypes.class).findAll();
-        try {
-            results.distinct(AllJavaTypes.INVALID_LINKED_BINARY_FIELD_FOR_DISTINCT, AllJavaTypes.INVALID_LINKED_TYPES_FIELDS_FOR_DISTINCT);
-        } catch (IllegalArgumentException ignored) {
-        }
-    }
 
     private RealmResults<Dog> populateRealmResultsOnLinkView(Realm realm) {
         realm.beginTransaction();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
index da49a66229..7c12ddba71 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmSchemaTests.java
@@ -16,94 +16,361 @@
 
 package io.realm;
 
-import android.support.test.runner.AndroidJUnit4;
 
+import org.hamcrest.CoreMatchers;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 import io.realm.entities.AllJavaTypes;
+import io.realm.entities.Cat;
+import io.realm.entities.Dog;
+import io.realm.entities.DogPrimaryKey;
+import io.realm.entities.NullTypes;
 import io.realm.entities.Owner;
 import io.realm.entities.PrimaryKeyAsString;
+import io.realm.internal.Table;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-@RunWith(AndroidJUnit4.class)
+@RunWith(Parameterized.class)
 public class RealmSchemaTests {
 
+    private enum SchemaType {
+        MUTABLE(MutableRealmObjectSchema.class),
+        IMMUTABLE(ImmutableRealmObjectSchema.class);
+
+        final Class<? extends RealmObjectSchema> objectSchemaClass;
+
+        SchemaType(Class<? extends RealmObjectSchema> objectSchemaClass) {
+            this.objectSchemaClass = objectSchemaClass;
+        }
+    }
+
     @Rule
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
 
-    private DynamicRealm realm;
+    private BaseRealm realm;
     private RealmSchema realmSchema;
+    private SchemaType type;
+
+    @Parameterized.Parameters(name = "{0}")
+    public static List<SchemaType> data() {
+        return Arrays.asList(SchemaType.values());
+    }
+
+    public RealmSchemaTests(SchemaType type) {
+        this.type = type;
+    }
 
     @Before
     public void setUp() {
         RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
-                .schema(AllJavaTypes.class, Owner.class, PrimaryKeyAsString.class)
+                .schema(AllJavaTypes.class, Owner.class, PrimaryKeyAsString.class, Cat.class, Dog.class,
+                        DogPrimaryKey.class, NullTypes.class)
                 .build();
         Realm.getInstance(realmConfig).close(); // create Schema
-        realm = DynamicRealm.getInstance(realmConfig);
+        if (type == SchemaType.MUTABLE) {
+            realm = DynamicRealm.getInstance(realmConfig);
+        } else {
+            realm = Realm.getInstance(realmConfig);
+        }
         realmSchema = this.realm.getSchema();
         realm.beginTransaction();
     }
 
     @After
     public void tearDown() {
-        realm.cancelTransaction();
         realm.close();
     }
 
     @Test
     public void getAll() {
         Set<RealmObjectSchema> objectSchemas = realmSchema.getAll();
-        assertEquals(6, objectSchemas.size());
+        assertEquals(7, objectSchemas.size());
 
-        List<String> expectedTables = Arrays.asList(
-                AllJavaTypes.CLASS_NAME, "Owner", "Cat", "Dog", "DogPrimaryKey", "PrimaryKeyAsString");
+        List<String> expectedTables = new ArrayList<>(Arrays.asList(
+                AllJavaTypes.CLASS_NAME, "Owner", "Cat", "Dog", "DogPrimaryKey", "PrimaryKeyAsString", NullTypes.CLASS_NAME));
         for (RealmObjectSchema objectSchema : objectSchemas) {
-            if (!expectedTables.contains(objectSchema.getClassName())) {
-                fail(objectSchema.getClassName() + " was not found");
+            assertThat(objectSchema, CoreMatchers.instanceOf(type.objectSchemaClass));
+            if (!expectedTables.remove(objectSchema.getClassName())) {
+                fail(objectSchema.getClassName() + " is not expected");
             }
         }
+        assertTrue("expected class is not contained in schema: " + (expectedTables.isEmpty() ? "" : expectedTables.get(0)),
+                expectedTables.isEmpty());
     }
 
     @Test
     public void create() {
-        realmSchema.create("Foo");
-        assertTrue(realmSchema.contains("Foo"));
+        final String[] validClassNames = {
+                TestHelper.getRandomString(1),
+                "Darby",
+                TestHelper.getRandomString(Table.CLASS_NAME_MAX_LENGTH)
+        };
+
+        if (type == SchemaType.IMMUTABLE) {
+            thrown.expect(UnsupportedOperationException.class);
+            realmSchema.create(validClassNames[0]);
+            return;
+        }
+
+        for (String validClassName : validClassNames) {
+            realmSchema.create(validClassName);
+            assertTrue(realmSchema.contains(validClassName));
+        }
     }
 
     @Test
     public void create_invalidNameThrows() {
-        String[] names = { null, "", TestHelper.getRandomString(57) };
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+
+        String[] names = { null, "", TestHelper.getRandomString(58) };
 
         for (String name : names) {
             try {
                 realmSchema.create(name);
+                fail();
             } catch (IllegalArgumentException ignored) {
             }
             assertFalse(String.format("'%s' failed", name), realmSchema.contains(name));
         }
     }
 
+    @Test
+    public void create_duplicatedNameThrows() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+
+        realmSchema.create("Foo");
+        thrown.expect(IllegalArgumentException.class);
+        realmSchema.create("Foo");
+    }
+
+    @Test
+    public void createWithPrimaryKeyField_string() {
+        final String[] validClassNames = {
+                TestHelper.getRandomString(1),
+                "Darby",
+                TestHelper.getRandomString(Table.CLASS_NAME_MAX_LENGTH)
+        };
+
+        if (type == SchemaType.IMMUTABLE) {
+            thrown.expect(UnsupportedOperationException.class);
+            realmSchema.createWithPrimaryKeyField(validClassNames[0], "pkField", String.class);
+            return;
+        }
+
+        for (String validClassName : validClassNames) {
+            // Not nullable
+            RealmObjectSchema objectSchema = realmSchema.createWithPrimaryKeyField(validClassName,
+                    "pkField", String.class, FieldAttribute.REQUIRED);
+            assertEquals("pkField", objectSchema.getPrimaryKey());
+            assertEquals(RealmFieldType.STRING, objectSchema.getFieldType("pkField"));
+            assertFalse(objectSchema.isNullable("pkField"));
+            assertTrue(objectSchema.hasIndex("pkField"));
+
+            realmSchema.remove(validClassName);
+
+            // Nullable
+            objectSchema = realmSchema.createWithPrimaryKeyField(validClassName,
+                    "pkField", String.class);
+            assertEquals("pkField", objectSchema.getPrimaryKey());
+            assertEquals(RealmFieldType.STRING, objectSchema.getFieldType("pkField"));
+            assertTrue(objectSchema.isNullable("pkField"));
+            assertTrue(objectSchema.hasIndex("pkField"));
+        }
+    }
+
+    @Test
+    public void createWithPrimaryKeyField_boxedInteger() {
+        final String[] validClassNames = {
+                TestHelper.getRandomString(1),
+                "Darby",
+                TestHelper.getRandomString(Table.CLASS_NAME_MAX_LENGTH)
+        };
+
+        if (type == SchemaType.IMMUTABLE) {
+            thrown.expect(UnsupportedOperationException.class);
+            realmSchema.createWithPrimaryKeyField(validClassNames[0], "pkField", Integer.class);
+            return;
+        }
+
+        for (String validClassName : validClassNames) {
+            // Not nullable
+
+            RealmObjectSchema objectSchema = realmSchema.createWithPrimaryKeyField(validClassName,
+                    "pkField", Integer.class, FieldAttribute.REQUIRED);
+            assertEquals("pkField", objectSchema.getPrimaryKey());
+            assertEquals(RealmFieldType.INTEGER, objectSchema.getFieldType("pkField"));
+            assertFalse(objectSchema.isNullable("pkField"));
+            assertTrue(objectSchema.hasIndex("pkField"));
+
+            realmSchema.remove(validClassName);
+
+            // Nullable
+
+            objectSchema = realmSchema.createWithPrimaryKeyField(validClassName, "pkField", Integer.class);
+            assertEquals("pkField", objectSchema.getPrimaryKey());
+            assertEquals(RealmFieldType.INTEGER, objectSchema.getFieldType("pkField"));
+            assertTrue(objectSchema.isNullable("pkField"));
+            assertTrue(objectSchema.hasIndex("pkField"));
+        }
+    }
+
+    @Test
+    public void createWithPrimaryKeyField_int() {
+        final String[] validClassNames = {
+                TestHelper.getRandomString(1),
+                "Darby",
+                TestHelper.getRandomString(Table.CLASS_NAME_MAX_LENGTH)
+        };
+
+        if (type == SchemaType.IMMUTABLE) {
+            thrown.expect(UnsupportedOperationException.class);
+            realmSchema.createWithPrimaryKeyField(validClassNames[0], "pkField", int.class);
+            return;
+        }
+
+        for (String validClassName : validClassNames) {
+            // Not nullable
+
+            RealmObjectSchema objectSchema = realmSchema.createWithPrimaryKeyField(validClassName,
+                    "pkField", int.class, FieldAttribute.REQUIRED);
+            assertEquals("pkField", objectSchema.getPrimaryKey());
+            assertEquals(RealmFieldType.INTEGER, objectSchema.getFieldType("pkField"));
+            assertFalse(objectSchema.isNullable("pkField"));
+            assertTrue(objectSchema.hasIndex("pkField"));
+
+            realmSchema.remove(validClassName);
+
+            // Nullable
+
+            objectSchema = realmSchema.createWithPrimaryKeyField(validClassName, "pkField", int.class);
+            assertEquals("pkField", objectSchema.getPrimaryKey());
+            assertEquals(RealmFieldType.INTEGER, objectSchema.getFieldType("pkField"));
+            assertFalse(objectSchema.isNullable("pkField"));
+            assertTrue(objectSchema.hasIndex("pkField"));
+        }
+    }
+
+    @Test
+    public void createWithPrimaryKeyField_explicitIndexed() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+        realmSchema.createWithPrimaryKeyField("Foo", "pkField", int.class,
+                FieldAttribute.INDEXED);
+        RealmObjectSchema objectSchema = realmSchema.getSchemaForClass("Foo");
+        assertEquals("pkField", objectSchema.getPrimaryKey());
+        assertEquals(RealmFieldType.INTEGER, objectSchema.getFieldType("pkField"));
+        assertFalse(objectSchema.isNullable("pkField"));
+        assertTrue(objectSchema.hasIndex("pkField"));
+    }
+
+    @Test
+    public void createWithPrimaryKeyField_explicitPrimaryKey() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+        realmSchema.createWithPrimaryKeyField("Foo", "pkField", int.class,
+                FieldAttribute.PRIMARY_KEY);
+        RealmObjectSchema objectSchema = realmSchema.getSchemaForClass("Foo");
+        assertEquals("pkField", objectSchema.getPrimaryKey());
+        assertEquals(RealmFieldType.INTEGER, objectSchema.getFieldType("pkField"));
+        assertFalse(objectSchema.isNullable("pkField"));
+        assertTrue(objectSchema.hasIndex("pkField"));
+    }
+
+    @Test
+    public void createWithPrimaryKeyField_invalidClassNameThrows() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+        String[] invalidNames = { null, "", TestHelper.getRandomString(Table.CLASS_NAME_MAX_LENGTH + 1) };
+
+        for (String name : invalidNames) {
+            try {
+                realmSchema.createWithPrimaryKeyField(name, "pkField", int.class);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+            assertFalse(String.format("'%s' failed", name), realmSchema.contains(name));
+        }
+    }
+
+    @Test
+    public void createWithPrimaryKeyField_invalidFieldNameThrows() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+        String[] invalidFieldNames = new String[] { null, "", "foo.bar", TestHelper.getRandomString(65) };
+        for (String fieldName : invalidFieldNames) {
+            try {
+                realmSchema.createWithPrimaryKeyField("Foo", fieldName, int.class);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void createWithPrimaryKeyField_invalidFieldTypeThrows() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+        Class<?>[] fieldTypes = new Class<?>[] {float.class, Float.class, Double.class, double.class, RealmObject.class,
+                RealmList.class, Object.class};
+        for (Class<?> fieldType : fieldTypes) {
+            try {
+                realmSchema.createWithPrimaryKeyField("Foo", "pkField", fieldType);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+            }
+        }
+    }
+
+    @Test
+    public void createWithPrimaryKeyField_duplicatedNameThrows() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+        realmSchema.createWithPrimaryKeyField("Foo", "pkField", int.class);
+        thrown.expect(IllegalArgumentException.class);
+        realmSchema.createWithPrimaryKeyField("Foo", "pkField", int.class);
+    }
+
     @Test
     public void get() {
         RealmObjectSchema objectSchema = realmSchema.get(AllJavaTypes.CLASS_NAME);
         assertNotNull(objectSchema);
         assertEquals(AllJavaTypes.CLASS_NAME, objectSchema.getClassName());
+        assertThat(objectSchema, CoreMatchers.instanceOf(type.objectSchemaClass));
     }
 
     @Test
@@ -113,13 +380,22 @@ public void get_unknownClass() {
 
     @Test
     public void rename() {
-        realmSchema.rename("Owner", "Owner2");
-        assertFalse(realmSchema.contains("Owner"));
-        assertTrue(realmSchema.contains("Owner2"));
+        if (type == SchemaType.MUTABLE) {
+            realmSchema.rename("Owner", "Owner2");
+            assertFalse(realmSchema.contains("Owner"));
+            assertTrue(realmSchema.contains("Owner2"));
+        } else {
+            thrown.expect(UnsupportedOperationException.class);
+            realmSchema.rename("Owner", "Owner2");
+        }
     }
 
     @Test
     public void rename_invalidArgumentThrows() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+
         String[] illegalNames = new String[] { null, "" };
 
         // Tests as first parameter.
@@ -143,12 +419,16 @@ public void rename_invalidArgumentThrows() {
 
     @Test
     public void rename_shouldChangeInfoInPKTable() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+
         final String NEW_NAME = "NewPrimaryKeyAsString";
         assertTrue(realmSchema.contains(PrimaryKeyAsString.CLASS_NAME));
         realmSchema.rename(PrimaryKeyAsString.CLASS_NAME, NEW_NAME);
         assertFalse(realmSchema.contains(PrimaryKeyAsString.CLASS_NAME));
         assertTrue(realmSchema.contains(NEW_NAME));
-        RealmObjectSchema objectSchema = realmSchema.getSchemaForClass(NEW_NAME);
+        RealmObjectSchema objectSchema = realmSchema.get(NEW_NAME);
 
         assertEquals(PrimaryKeyAsString.FIELD_PRIMARY_KEY, objectSchema.getPrimaryKey());
 
@@ -169,12 +449,21 @@ public void rename_shouldChangeInfoInPKTable() {
 
     @Test
     public void remove() {
-        realmSchema.remove(AllJavaTypes.CLASS_NAME);
-        assertFalse(realmSchema.contains(AllJavaTypes.CLASS_NAME));
+        if (type == SchemaType.IMMUTABLE) {
+            thrown.expect(UnsupportedOperationException.class);
+            realmSchema.remove(AllJavaTypes.CLASS_NAME);
+        } else {
+            realmSchema.remove(AllJavaTypes.CLASS_NAME);
+            assertFalse(realmSchema.contains(AllJavaTypes.CLASS_NAME));
+        }
     }
 
     @Test
     public void remove_invalidArgumentThrows() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+
         try {
             realmSchema.remove("Foo");
             fail();
@@ -190,9 +479,12 @@ public void remove_invalidArgumentThrows() {
 
     // Test that it if { A -> B  && B -> A } you should remove the individual fields first before removing the entire
     // class. This also include transitive dependencies.
-    // FIXME: Disabled until https://github.com/realm/realm-core/pull/1475#issuecomment-185192434 is fixed.
-    // @Test
+    @Test
     public void remove_classWithReferencesThrows() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+
         try {
             realmSchema.remove("Cat");
             fail();
@@ -209,6 +501,10 @@ public void remove_classWithReferencesThrows() {
 
     @Test
     public void remove_shouldRemoveInfoFromPKTable() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+
         assertTrue(realmSchema.contains(PrimaryKeyAsString.CLASS_NAME));
         realmSchema.remove(PrimaryKeyAsString.CLASS_NAME);
         assertFalse(realmSchema.contains(PrimaryKeyAsString.CLASS_NAME));
@@ -226,4 +522,132 @@ public void remove_shouldRemoveInfoFromPKTable() {
         objectSchema.addPrimaryKey(PrimaryKeyAsString.FIELD_PRIMARY_KEY);
         assertEquals(PrimaryKeyAsString.FIELD_PRIMARY_KEY, objectSchema.getPrimaryKey());
     }
+
+    @Test
+    public void remove_shouldClearDynamicCache() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+
+        realmSchema.create("foo");
+        // getSchemaForClass is an internal method, but used from DynamicRealmObject and RealmQuery
+        final RealmObjectSchema previousFoo = realmSchema.getSchemaForClass("foo");
+
+        realmSchema.remove("foo");
+
+        realmSchema.create("foo");
+        final RealmObjectSchema newFoo = realmSchema.getSchemaForClass("foo");
+
+        assertNotSame(previousFoo, newFoo);
+
+        try {
+            previousFoo.getClassName();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+
+        assertEquals("foo", newFoo.getClassName());
+    }
+
+    @Test
+    public void rename_shouldUpdateDynamicCache() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+
+        realmSchema.create("foo");
+        // getSchemaForClass is an internal method, but used from DynamicRealmObject and RealmQuery
+        final RealmObjectSchema foo = realmSchema.getSchemaForClass("foo");
+
+        realmSchema.rename("foo", "bar");
+
+        final RealmObjectSchema bar = realmSchema.getSchemaForClass("bar");
+
+        assertSame(foo, bar);
+        assertEquals("bar", bar.getClassName());
+    }
+
+    @Test
+    public void schemaInformationOfPrimitiveLists() {
+        Map<String, RealmFieldType> fieldNameToType = new HashMap<>();
+        fieldNameToType.put(NullTypes.FIELD_STRING_LIST_NULL, RealmFieldType.STRING_LIST);
+        fieldNameToType.put(NullTypes.FIELD_STRING_LIST_NOT_NULL, RealmFieldType.STRING_LIST);
+        fieldNameToType.put(NullTypes.FIELD_BINARY_LIST_NULL, RealmFieldType.BINARY_LIST);
+        fieldNameToType.put(NullTypes.FIELD_BINARY_LIST_NOT_NULL, RealmFieldType.BINARY_LIST);
+        fieldNameToType.put(NullTypes.FIELD_BOOLEAN_LIST_NULL, RealmFieldType.BOOLEAN_LIST);
+        fieldNameToType.put(NullTypes.FIELD_BOOLEAN_LIST_NOT_NULL, RealmFieldType.BOOLEAN_LIST);
+        fieldNameToType.put(NullTypes.FIELD_DATE_LIST_NULL, RealmFieldType.DATE_LIST);
+        fieldNameToType.put(NullTypes.FIELD_DATE_LIST_NOT_NULL, RealmFieldType.DATE_LIST);
+        fieldNameToType.put(NullTypes.FIELD_DOUBLE_LIST_NULL, RealmFieldType.DOUBLE_LIST);
+        fieldNameToType.put(NullTypes.FIELD_DOUBLE_LIST_NOT_NULL, RealmFieldType.DOUBLE_LIST);
+        fieldNameToType.put(NullTypes.FIELD_FLOAT_LIST_NULL, RealmFieldType.FLOAT_LIST);
+        fieldNameToType.put(NullTypes.FIELD_FLOAT_LIST_NOT_NULL, RealmFieldType.FLOAT_LIST);
+        fieldNameToType.put(NullTypes.FIELD_LONG_LIST_NULL, RealmFieldType.INTEGER_LIST);
+        fieldNameToType.put(NullTypes.FIELD_LONG_LIST_NOT_NULL, RealmFieldType.INTEGER_LIST);
+        fieldNameToType.put(NullTypes.FIELD_INTEGER_LIST_NULL, RealmFieldType.INTEGER_LIST);
+        fieldNameToType.put(NullTypes.FIELD_INTEGER_LIST_NOT_NULL, RealmFieldType.INTEGER_LIST);
+        fieldNameToType.put(NullTypes.FIELD_SHORT_LIST_NULL, RealmFieldType.INTEGER_LIST);
+        fieldNameToType.put(NullTypes.FIELD_SHORT_LIST_NOT_NULL, RealmFieldType.INTEGER_LIST);
+        fieldNameToType.put(NullTypes.FIELD_BYTE_LIST_NULL, RealmFieldType.INTEGER_LIST);
+        fieldNameToType.put(NullTypes.FIELD_BYTE_LIST_NOT_NULL, RealmFieldType.INTEGER_LIST);
+
+        final RealmObjectSchema objectSchema = realmSchema.get(NullTypes.CLASS_NAME);
+        assertNotNull(objectSchema);
+
+        for (Map.Entry<String, RealmFieldType> entry : fieldNameToType.entrySet()) {
+            final String fieldName = entry.getKey();
+            final RealmFieldType expectedType = entry.getValue();
+
+            assertEquals(expectedType, objectSchema.getFieldType(fieldName));
+            assertEquals("isNullable('" + fieldName + "')",
+                    !fieldName.endsWith("NotNull"), objectSchema.isNullable(fieldName));
+            assertEquals("isRequired('" + fieldName + "')",
+                    fieldName.endsWith("NotNull"), objectSchema.isRequired(fieldName));
+            assertFalse(objectSchema.isPrimaryKey(fieldName));
+        }
+    }
+
+    @Test
+    public void rename_newNameExists() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+        thrown.expect(IllegalArgumentException.class);
+        thrown.expectMessage(
+                CoreMatchers.containsString("Cat cannot be renamed because the new class already exists"));
+        realmSchema.rename("Cat", "Dog");
+    }
+
+    @Test
+    public void mutableMethodsCalled_notInTransaction() {
+        if (type == SchemaType.IMMUTABLE) {
+            return;
+        }
+
+        realm.cancelTransaction();
+
+        try {
+            realmSchema.create("Foo");
+        } catch (IllegalStateException expected) {
+            assertThat(expected.getMessage(), CoreMatchers.containsString("transaction"));
+        }
+
+        try {
+            realmSchema.createWithPrimaryKeyField("Foo", "PK", String.class);
+        } catch (IllegalStateException expected) {
+            assertThat(expected.getMessage(), CoreMatchers.containsString("transaction"));
+        }
+
+        try {
+            realmSchema.remove("Cat");
+        } catch (IllegalStateException expected) {
+            assertThat(expected.getMessage(), CoreMatchers.containsString("transaction"));
+        }
+
+        try {
+            realmSchema.rename("Cat", "Foo1");
+        } catch (IllegalStateException expected) {
+            assertThat(expected.getMessage(), CoreMatchers.containsString("transaction"));
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index b4bce17087..48d43d74d0 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -18,8 +18,6 @@
 
 import android.content.Context;
 import android.os.Build;
-import android.os.Handler;
-import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.SystemClock;
 import android.support.test.InstrumentationRegistry;
@@ -28,13 +26,13 @@
 
 import junit.framework.AssertionFailedError;
 
+import org.hamcrest.CoreMatchers;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
 import org.junit.After;
 import org.junit.Assume;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -48,7 +46,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Date;
@@ -63,6 +60,7 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
@@ -82,6 +80,7 @@
 import io.realm.entities.NoPrimaryKeyNullTypes;
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.NullTypes;
+import io.realm.entities.Object4957;
 import io.realm.entities.Owner;
 import io.realm.entities.OwnerPrimaryKey;
 import io.realm.entities.PrimaryKeyAsBoxedByte;
@@ -98,11 +97,14 @@
 import io.realm.entities.PrimaryKeyRequiredAsString;
 import io.realm.entities.RandomPrimaryKey;
 import io.realm.entities.StringOnly;
+import io.realm.entities.StringOnlyReadOnly;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmFileException;
+import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.exceptions.RealmPrimaryKeyConstraintException;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
+import io.realm.internal.util.Pair;
 import io.realm.log.RealmLog;
 import io.realm.objectid.NullPrimaryKey;
 import io.realm.rule.RunInLooperThread;
@@ -116,10 +118,11 @@
 import static io.realm.internal.test.ExtraTests.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Mockito.mock;
@@ -177,18 +180,18 @@ private void populateTestRealm(Realm realm, int objects) {
         for (int i = 0; i < objects; ++i) {
             AllTypes allTypes = realm.createObject(AllTypes.class);
             allTypes.setColumnBoolean((i % 3) == 0);
-            allTypes.setColumnBinary(new byte[]{1, 2, 3});
+            allTypes.setColumnBinary(new byte[] {1, 2, 3});
             allTypes.setColumnDate(new Date());
             allTypes.setColumnDouble(Math.PI);
-            allTypes.setColumnFloat(1.234567f + i);
+            allTypes.setColumnFloat(1.234567F + i);
 
             allTypes.setColumnString("test data " + i);
             allTypes.setColumnLong(i);
             NonLatinFieldNames nonLatinFieldNames = realm.createObject(NonLatinFieldNames.class);
             nonLatinFieldNames.set델타(i);
             nonLatinFieldNames.setΔέλτα(i);
-            nonLatinFieldNames.set베타(1.234567f + i);
-            nonLatinFieldNames.setΒήτα(1.234567f + i);
+            nonLatinFieldNames.set베타(1.234567F + i);
+            nonLatinFieldNames.setΒήτα(1.234567F + i);
         }
         realm.commitTransaction();
     }
@@ -213,7 +216,7 @@ public void getInstance_writeProtectedFile() throws IOException {
                     .build());
             fail();
         } catch (RealmFileException expected) {
-            assertEquals(expected.getKind(), RealmFileException.Kind.PERMISSION_DENIED);
+            assertEquals(RealmFileException.Kind.PERMISSION_DENIED, expected.getKind());
         }
     }
 
@@ -230,7 +233,7 @@ public void getInstance_writeProtectedFileWithContext() throws IOException {
             Realm.getInstance(new RealmConfiguration.Builder(context).directory(folder).name(REALM_FILE).build());
             fail();
         } catch (RealmFileException expected) {
-            assertEquals(expected.getKind(), RealmFileException.Kind.PERMISSION_DENIED);
+            assertEquals(RealmFileException.Kind.PERMISSION_DENIED, expected.getKind());
         }
     }
 
@@ -326,7 +329,7 @@ public void where_equalTo_wrongFieldTypeAsInput() throws IOException {
             }
 
             try {
-                realm.where(AllTypes.class).equalTo(columnData.get(i), 13.37d).findAll();
+                realm.where(AllTypes.class).equalTo(columnData.get(i), 13.37D).findAll();
                 if (i != 2) {
                     fail("Realm.where should fail with illegal argument");
                 }
@@ -334,7 +337,7 @@ public void where_equalTo_wrongFieldTypeAsInput() throws IOException {
             }
 
             try {
-                realm.where(AllTypes.class).equalTo(columnData.get(i), 13.3711f).findAll();
+                realm.where(AllTypes.class).equalTo(columnData.get(i), 13.3711F).findAll();
                 if (i != 3) {
                     fail("Realm.where should fail with illegal argument");
                 }
@@ -708,7 +711,7 @@ public void execute(Realm realm) {
             });
         } catch (RuntimeException ignored) {
             // Ensures that we pass a valuable error message to the logger for developers.
-            assertEquals(testLogger.message, "Could not cancel transaction, not currently in a transaction.");
+            assertEquals("Could not cancel transaction, not currently in a transaction.", testLogger.message);
         } finally {
             RealmLog.remove(testLogger);
         }
@@ -800,10 +803,9 @@ public void utf8Tests() {
                 o.setColumnLong(i);
                 o.setColumnString(codePoint);
 
-                AllTypes realmType = realm.where(AllTypes.class).equalTo("columnLong", i).findFirst();
                 if (i > 1) {
                     assertEquals("Codepoint: " + i + " / " + currentUnicode, codePoint,
-                            realmType.getColumnString()); // codepoint 0 is NULL, ignore for now.
+                            o.getColumnString()); // codepoint 0 is NULL, ignore for now.
                 }
                 i++;
             }
@@ -833,39 +835,34 @@ public void utf8Tests() {
         return chars_array;
     }
 
-    // This test is slow. Move it to another testsuite that runs once a day on Jenkins.
     // The test writes and reads random Strings.
-    // @Test TODO AndroidJUnit4 runner doesn't seem to respect the @Ignore annotation?
-    @Ignore
+    @Test
     public void unicodeStrings() {
-        List<String> chars_array = getCharacterArray();
+        List<String> charsArray = getCharacterArray();
         // Change seed value for new random values.
         long seed = 20;
         Random random = new Random(seed);
 
-        int random_value = 0;
-
-        String test_char = "";
-        String test_char_old = "";
-
+        StringBuilder testChar = new StringBuilder();
+        realm.beginTransaction();
         for (int i = 0; i < 1000; i++) {
-            random_value = random.nextInt(25);
+            testChar.setLength(0);
+            int length = random.nextInt(25);
 
-            for (int j = 0; j < random_value; j++) {
-                test_char = test_char_old + chars_array.get(random.nextInt(27261));
-                test_char_old = test_char;
+            for (int j = 0; j < length; j++) {
+                testChar.append(charsArray.get(random.nextInt(27261)));
             }
-            realm.beginTransaction();
             StringOnly stringOnly = realm.createObject(StringOnly.class);
-            stringOnly.setChars(test_char);
-            realm.commitTransaction();
 
+            // tests setter
+            stringOnly.setChars(testChar.toString());
+
+            // tests getter
             realm.where(StringOnly.class).findFirst().getChars();
 
-            realm.beginTransaction();
             realm.delete(StringOnly.class);
-            realm.commitTransaction();
         }
+        realm.cancelTransaction();
     }
 
     @Test
@@ -887,7 +884,7 @@ public void getInstance_referenceCounting() {
         try {
             realm = Realm.getInstance(configFactory.createConfiguration());
         } finally {
-            if (realm != null) realm.close();
+            if (realm != null) { realm.close(); }
         }
 
         try {
@@ -1061,6 +1058,185 @@ public void compactRealm_onExternalStorage() {
         Realm.deleteRealm(config);
     }
 
+    private void populateTestRealmForCompact(Realm realm, int sizeInMB) {
+        byte[] oneMBData = new byte[1024 * 1024];
+        realm.beginTransaction();
+        for (int i = 0; i < sizeInMB; i++) {
+            realm.createObject(AllTypes.class).setColumnBinary(oneMBData);
+        }
+        realm.commitTransaction();
+    }
+
+    private Pair<Long, Long> populateTestRealmAndCompactOnLaunch(CompactOnLaunchCallback compactOnLaunch) {
+        return populateTestRealmAndCompactOnLaunch(compactOnLaunch, 1);
+    }
+
+    private Pair<Long, Long> populateTestRealmAndCompactOnLaunch(CompactOnLaunchCallback compactOnLaunch, int sizeInMB) {
+        final String REALM_NAME = "test.realm";
+        RealmConfiguration realmConfig = configFactory.createConfiguration(REALM_NAME);
+        Realm realm = Realm.getInstance(realmConfig);
+        populateTestRealmForCompact(realm, sizeInMB);
+        realm.beginTransaction();
+        realm.deleteAll();
+        realm.commitTransaction();
+        realm.close();
+        long before = new File(realmConfig.getPath()).length();
+        if (compactOnLaunch != null) {
+            realmConfig = configFactory.createConfigurationBuilder()
+                    .name(REALM_NAME)
+                    .compactOnLaunch(compactOnLaunch)
+                    .build();
+        } else {
+            realmConfig = configFactory.createConfigurationBuilder()
+                    .name(REALM_NAME)
+                    .compactOnLaunch()
+                    .build();
+        }
+        realm = Realm.getInstance(realmConfig);
+        realm.close();
+        long after = new File(realmConfig.getPath()).length();
+        return new Pair(before, after);
+    }
+
+    @Test
+    public void compactOnLaunch_shouldCompact() throws IOException {
+        Pair<Long, Long> results = populateTestRealmAndCompactOnLaunch(new CompactOnLaunchCallback() {
+            @Override
+            public boolean shouldCompact(long totalBytes, long usedBytes) {
+                assertTrue(totalBytes > usedBytes);
+                return true;
+            }
+        });
+        assertTrue(results.first > results.second);
+    }
+
+    @Test
+    public void compactOnLaunch_shouldNotCompact() throws IOException {
+        Pair<Long, Long> results = populateTestRealmAndCompactOnLaunch(new CompactOnLaunchCallback() {
+            @Override
+            public boolean shouldCompact(long totalBytes, long usedBytes) {
+                assertTrue(totalBytes > usedBytes);
+                return false;
+            }
+        });
+        assertEquals(results.first, results.second);
+    }
+
+    @Test
+    public void compactOnLaunch_multipleThread() throws IOException {
+        final String REALM_NAME = "test.realm";
+        final AtomicInteger compactOnLaunchCount = new AtomicInteger(0);
+
+        final RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .name(REALM_NAME)
+                .compactOnLaunch(new CompactOnLaunchCallback() {
+                    @Override
+                    public boolean shouldCompact(long totalBytes, long usedBytes) {
+                        compactOnLaunchCount.incrementAndGet();
+                        return true;
+                    }
+                })
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+        realm.close();
+        // WARNING: We need to init the schema first and close the Realm to make sure the relevant logic works in Object
+        // Store. See https://github.com/realm/realm-object-store/blob/master/src/shared_realm.cpp#L58
+        // Called once.
+        assertEquals(1, compactOnLaunchCount.get());
+
+        realm = Realm.getInstance(realmConfig);
+        // Called 2 more times. The PK table migration logic (the old PK bug) needs to open/close the Realm once.
+        assertEquals(3, compactOnLaunchCount.get());
+
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm bgRealm = Realm.getInstance(realmConfig);
+                bgRealm.close();
+                // compactOnLaunch should not be called anymore!
+                assertEquals(3, compactOnLaunchCount.get());
+            }
+        });
+        thread.start();
+
+        try {
+            thread.join();
+        } catch (InterruptedException e) {
+            fail();
+        }
+
+        realm.close();
+
+        assertEquals(3, compactOnLaunchCount.get());
+    }
+
+    @Test
+    public void compactOnLaunch_insufficientAmount() throws IOException {
+        Pair<Long, Long> results = populateTestRealmAndCompactOnLaunch(new CompactOnLaunchCallback() {
+            @Override
+            public boolean shouldCompact(long totalBytes, long usedBytes) {
+                final long thresholdSize = 50 * 1024 * 1024;
+                return (totalBytes > thresholdSize) && (((double) usedBytes / (double) totalBytes) < 0.5);
+            }
+        }, 1);
+        final long thresholdSize = 50 * 1024 * 1024;
+        assertTrue(results.first < thresholdSize);
+        assertEquals(results.first, results.second);
+    }
+
+    @Test
+    public void compactOnLaunch_throwsInTheCallback() {
+        final RuntimeException exception = new RuntimeException();
+        final RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .name("compactThrowsTest")
+                .compactOnLaunch(new CompactOnLaunchCallback() {
+                    @Override
+                    public boolean shouldCompact(long totalBytes, long usedBytes) {
+                        throw exception;
+                    }
+                })
+                .build();
+        Realm realm = null;
+        try {
+            realm = Realm.getInstance(realmConfig);
+            fail();
+        } catch (RuntimeException expected) {
+            assertSame(exception, expected);
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+        }
+    }
+
+    @Test
+    public void defaultCompactOnLaunch() throws IOException {
+        Pair<Long, Long> results = populateTestRealmAndCompactOnLaunch(null, 50);
+        final long thresholdSize = 50 * 1024 * 1024;
+        assertTrue(results.first > thresholdSize);
+        assertTrue(results.first > results.second);
+    }
+
+    @Test
+    public void defaultCompactOnLaunch_onlyCallback() {
+        DefaultCompactOnLaunchCallback callback = new DefaultCompactOnLaunchCallback();
+        final long thresholdSize = 50 * 1024 * 1024;
+        final long big = thresholdSize + 1024;
+        assertFalse(callback.shouldCompact(big, (long) (big * 0.6)));
+        assertTrue(callback.shouldCompact(big, (long) (big * 0.3)));
+        final long small = thresholdSize - 1024;
+        assertFalse(callback.shouldCompact(small, (long) (small * 0.6)));
+        assertFalse(callback.shouldCompact(small, (long) (small * 0.3)));
+    }
+
+    @Test
+    public void defaultCompactOnLaunch_insufficientAmount() throws IOException {
+        Pair<Long, Long> results = populateTestRealmAndCompactOnLaunch(null, 1);
+        final long thresholdSize = 50 * 1024 * 1024;
+        assertTrue(results.first < thresholdSize);
+        assertEquals(results.first, results.second);
+    }
+
     @Test
     public void copyToRealm_null() {
         realm.beginTransaction();
@@ -1115,15 +1291,23 @@ public void copyToRealm() {
 
         AllTypes allTypes = new AllTypes();
         allTypes.setColumnString("String");
-        allTypes.setColumnLong(1l);
-        allTypes.setColumnFloat(1f);
-        allTypes.setColumnDouble(1d);
+        allTypes.setColumnLong(1L);
+        allTypes.setColumnFloat(1F);
+        allTypes.setColumnDouble(1D);
         allTypes.setColumnBoolean(true);
         allTypes.setColumnDate(date);
-        allTypes.setColumnBinary(new byte[]{1, 2, 3});
+        allTypes.setColumnBinary(new byte[] {1, 2, 3});
         allTypes.setColumnRealmObject(dog);
         allTypes.setColumnRealmList(list);
 
+        allTypes.setColumnStringList(new RealmList<String>("1"));
+        allTypes.setColumnBinaryList(new RealmList<byte[]>(new byte[] {1}));
+        allTypes.setColumnBooleanList(new RealmList<Boolean>(true));
+        allTypes.setColumnLongList(new RealmList<Long>(1L));
+        allTypes.setColumnDoubleList(new RealmList<Double>(1D));
+        allTypes.setColumnFloatList(new RealmList<Float>(1F));
+        allTypes.setColumnDateList(new RealmList<Date>(new Date(1L)));
+
         realm.beginTransaction();
         AllTypes realmTypes = realm.copyToRealm(allTypes);
         realm.commitTransaction();
@@ -1138,7 +1322,22 @@ public void copyToRealm() {
         assertArrayEquals(allTypes.getColumnBinary(), realmTypes.getColumnBinary());
         assertEquals(allTypes.getColumnRealmObject().getName(), dog.getName());
         assertEquals(list.size(), realmTypes.getColumnRealmList().size());
+        //noinspection ConstantConditions
         assertEquals(list.get(0).getName(), realmTypes.getColumnRealmList().get(0).getName());
+        assertEquals(1, realmTypes.getColumnStringList().size());
+        assertEquals("1", realmTypes.getColumnStringList().get(0));
+        assertEquals(1, realmTypes.getColumnBooleanList().size());
+        assertEquals(true, realmTypes.getColumnBooleanList().get(0));
+        assertEquals(1, realmTypes.getColumnBinaryList().size());
+        assertArrayEquals(new byte[] {1}, realmTypes.getColumnBinaryList().get(0));
+        assertEquals(1, realmTypes.getColumnLongList().size());
+        assertEquals((Long) 1L, realmTypes.getColumnLongList().get(0));
+        assertEquals(1, realmTypes.getColumnDoubleList().size());
+        assertEquals((Double) 1D, realmTypes.getColumnDoubleList().get(0));
+        assertEquals(1, realmTypes.getColumnFloatList().size());
+        assertEquals((Float) 1F, realmTypes.getColumnFloatList().get(0));
+        assertEquals(1, realmTypes.getColumnDateList().size());
+        assertEquals(new Date(1), realmTypes.getColumnDateList().get(0));
     }
 
     @Test
@@ -1213,8 +1412,8 @@ public void copyToRealm_cyclicListReferences() {
         oneCyclicType.setName("One");
         CyclicType anotherCyclicType = new CyclicType();
         anotherCyclicType.setName("Two");
-        oneCyclicType.setObjects(new RealmList(anotherCyclicType));
-        anotherCyclicType.setObjects(new RealmList(oneCyclicType));
+        oneCyclicType.setObjects(new RealmList<>(anotherCyclicType));
+        anotherCyclicType.setObjects(new RealmList<>(oneCyclicType));
 
         realm.beginTransaction();
         CyclicType realmObject = realm.copyToRealm(oneCyclicType);
@@ -1234,6 +1433,15 @@ public void copyToRealm_convertsNullToDefaultValue() {
         assertEquals("", realmTypes.getColumnString());
         assertEquals(new Date(0), realmTypes.getColumnDate());
         assertArrayEquals(new byte[0], realmTypes.getColumnBinary());
+
+        assertNotNull(realmTypes.getColumnRealmList());
+        assertNotNull(realmTypes.getColumnStringList());
+        assertNotNull(realmTypes.getColumnBinaryList());
+        assertNotNull(realmTypes.getColumnBooleanList());
+        assertNotNull(realmTypes.getColumnLongList());
+        assertNotNull(realmTypes.getColumnDoubleList());
+        assertNotNull(realmTypes.getColumnFloatList());
+        assertNotNull(realmTypes.getColumnDateList());
     }
 
     // Check that using copyToRealm will set the primary key directly instead of first setting
@@ -1263,16 +1471,16 @@ public void copyToRealm_boxedNumberPrimaryKeyIsNull() {
         final String SECONDARY_FIELD_VALUE = "nullNumberPrimaryKeyObj";
         final Class[] CLASSES = {PrimaryKeyAsBoxedByte.class, PrimaryKeyAsBoxedShort.class, PrimaryKeyAsBoxedInteger.class, PrimaryKeyAsBoxedLong.class};
 
-        TestHelper.addBytePrimaryKeyObjectToTestRealm(realm,    (Byte) null,    SECONDARY_FIELD_VALUE);
-        TestHelper.addShortPrimaryKeyObjectToTestRealm(realm,   (Short) null,   SECONDARY_FIELD_VALUE);
+        TestHelper.addBytePrimaryKeyObjectToTestRealm(realm, (Byte) null, SECONDARY_FIELD_VALUE);
+        TestHelper.addShortPrimaryKeyObjectToTestRealm(realm, (Short) null, SECONDARY_FIELD_VALUE);
         TestHelper.addIntegerPrimaryKeyObjectToTestRealm(realm, (Integer) null, SECONDARY_FIELD_VALUE);
-        TestHelper.addLongPrimaryKeyObjectToTestRealm(realm,    (Long) null,    SECONDARY_FIELD_VALUE);
+        TestHelper.addLongPrimaryKeyObjectToTestRealm(realm, (Long) null, SECONDARY_FIELD_VALUE);
 
         for (Class clazz : CLASSES) {
             RealmResults results = realm.where(clazz).findAll();
             assertEquals(1, results.size());
-            assertEquals(null, ((NullPrimaryKey)results.first()).getId());
-            assertEquals(SECONDARY_FIELD_VALUE, ((NullPrimaryKey)results.first()).getName());
+            assertEquals(null, ((NullPrimaryKey) results.first()).getId());
+            assertEquals(SECONDARY_FIELD_VALUE, ((NullPrimaryKey) results.first()).getName());
         }
     }
 
@@ -1280,11 +1488,11 @@ public void copyToRealm_boxedNumberPrimaryKeyIsNull() {
     public void copyToRealm_duplicatedNullPrimaryKeyThrows() {
         final String[] PRIMARY_KEY_TYPES = {"String", "BoxedByte", "BoxedShort", "BoxedInteger", "BoxedLong"};
 
-        TestHelper.addStringPrimaryKeyObjectToTestRealm(realm,  (String) null,  0);
-        TestHelper.addBytePrimaryKeyObjectToTestRealm(realm,    (Byte) null,    (String) null);
-        TestHelper.addShortPrimaryKeyObjectToTestRealm(realm,   (Short) null,   (String) null);
+        TestHelper.addStringPrimaryKeyObjectToTestRealm(realm, (String) null, 0);
+        TestHelper.addBytePrimaryKeyObjectToTestRealm(realm, (Byte) null, (String) null);
+        TestHelper.addShortPrimaryKeyObjectToTestRealm(realm, (Short) null, (String) null);
         TestHelper.addIntegerPrimaryKeyObjectToTestRealm(realm, (Integer) null, (String) null);
-        TestHelper.addLongPrimaryKeyObjectToTestRealm(realm,    (Long) null,    (String) null);
+        TestHelper.addLongPrimaryKeyObjectToTestRealm(realm, (Long) null, (String) null);
 
         for (String className : PRIMARY_KEY_TYPES) {
             try {
@@ -1309,7 +1517,8 @@ public void copyToRealm_duplicatedNullPrimaryKeyThrows() {
                 }
                 fail("Null value as primary key already exists.");
             } catch (RealmPrimaryKeyConstraintException expected) {
-                assertEquals("Value already exists: null", expected.getMessage());
+                assertTrue("Exception message is: " + expected.getMessage(),
+                        expected.getMessage().contains("Primary key value already exists: 'null' ."));
             } finally {
                 realm.cancelTransaction();
             }
@@ -1527,11 +1736,18 @@ public void execute(Realm realm) {
                 obj.setColumnFloat(1.23F);
                 obj.setColumnDouble(1.234D);
                 obj.setColumnBoolean(false);
-                obj.setColumnBinary(new byte[]{1, 2, 3});
+                obj.setColumnBinary(new byte[] {1, 2, 3});
                 obj.setColumnDate(new Date(1000));
                 obj.setColumnRealmObject(new DogPrimaryKey(1, "Dog1"));
                 obj.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(2, "Dog2")));
                 obj.setColumnBoxedBoolean(true);
+                obj.setColumnStringList(new RealmList<>("1"));
+                obj.setColumnBooleanList(new RealmList<>(false));
+                obj.setColumnBinaryList(new RealmList<>(new byte[] {1}));
+                obj.setColumnLongList(new RealmList<>(1L));
+                obj.setColumnDoubleList(new RealmList<>(1D));
+                obj.setColumnFloatList(new RealmList<>(1F));
+                obj.setColumnDateList(new RealmList<>(new Date(1L)));
                 realm.copyToRealm(obj);
 
                 AllTypesPrimaryKey obj2 = new AllTypesPrimaryKey();
@@ -1540,11 +1756,18 @@ public void execute(Realm realm) {
                 obj2.setColumnFloat(2.23F);
                 obj2.setColumnDouble(2.234D);
                 obj2.setColumnBoolean(true);
-                obj2.setColumnBinary(new byte[]{2, 3, 4});
+                obj2.setColumnBinary(new byte[] {2, 3, 4});
                 obj2.setColumnDate(new Date(2000));
                 obj2.setColumnRealmObject(new DogPrimaryKey(3, "Dog3"));
                 obj2.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(4, "Dog4")));
                 obj2.setColumnBoxedBoolean(false);
+                obj2.setColumnStringList(new RealmList<>("2", "3"));
+                obj2.setColumnBooleanList(new RealmList<>(true, false));
+                obj2.setColumnBinaryList(new RealmList<>(new byte[] {2}, new byte[] {3}));
+                obj2.setColumnLongList(new RealmList<>(2L, 3L));
+                obj2.setColumnDoubleList(new RealmList<>(2D, 3D));
+                obj2.setColumnFloatList(new RealmList<>(2F, 3F));
+                obj2.setColumnDateList(new RealmList<>(new Date(2L), new Date(3L)));
                 realm.copyToRealmOrUpdate(obj2);
             }
         });
@@ -1558,12 +1781,46 @@ public void execute(Realm realm) {
         assertEquals(2.23F, obj.getColumnFloat(), 0);
         assertEquals(2.234D, obj.getColumnDouble(), 0);
         assertEquals(true, obj.isColumnBoolean());
-        assertArrayEquals(new byte[]{2, 3, 4}, obj.getColumnBinary());
+        assertArrayEquals(new byte[] {2, 3, 4}, obj.getColumnBinary());
         assertEquals(new Date(2000), obj.getColumnDate());
         assertEquals("Dog3", obj.getColumnRealmObject().getName());
         assertEquals(1, obj.getColumnRealmList().size());
         assertEquals("Dog4", obj.getColumnRealmList().get(0).getName());
         assertFalse(obj.getColumnBoxedBoolean());
+        assertEquals(2, obj.getColumnStringList().size());
+        assertEquals("2", obj.getColumnStringList().get(0));
+        assertEquals("3", obj.getColumnStringList().get(1));
+        assertEquals(2, obj.getColumnBooleanList().size());
+        assertEquals(true, obj.getColumnBooleanList().get(0));
+        assertEquals(false, obj.getColumnBooleanList().get(1));
+        assertEquals(2, obj.getColumnBinaryList().size());
+        assertArrayEquals(new byte[] {2}, obj.getColumnBinaryList().get(0));
+        assertArrayEquals(new byte[] {3}, obj.getColumnBinaryList().get(1));
+        assertEquals(2, obj.getColumnLongList().size());
+        assertEquals((Long) 2L, obj.getColumnLongList().get(0));
+        assertEquals((Long) 3L, obj.getColumnLongList().get(1));
+        assertEquals(2, obj.getColumnDoubleList().size());
+        assertEquals((Double) 2D, obj.getColumnDoubleList().get(0));
+        assertEquals((Double) 3D, obj.getColumnDoubleList().get(1));
+        assertEquals(2, obj.getColumnFloatList().size());
+        assertEquals((Float) 2F, obj.getColumnFloatList().get(0));
+        assertEquals((Float) 3F, obj.getColumnFloatList().get(1));
+        assertEquals(2, obj.getColumnDateList().size());
+        assertEquals(new Date(2L), obj.getColumnDateList().get(0));
+        assertEquals(new Date(3L), obj.getColumnDateList().get(1));
+    }
+
+    @Test
+    public void copyToRealmOrUpdate_overrideOwnList() {
+        realm.beginTransaction();
+        AllJavaTypes managedObj = realm.createObject(AllJavaTypes.class, 1);
+        managedObj.getFieldList().add(managedObj);
+        AllJavaTypes unmanagedObj = realm.copyFromRealm(managedObj);
+        unmanagedObj.setFieldList(managedObj.getFieldList());
+
+        managedObj = realm.copyToRealmOrUpdate(unmanagedObj);
+        assertEquals(1, managedObj.getFieldList().size());
+        assertEquals(1, managedObj.getFieldList().first().getFieldId());
     }
 
     @Test
@@ -1602,7 +1859,7 @@ public void execute(Realm realm) {
                 obj.setColumnFloat(1.23F);
                 obj.setColumnDouble(1.234D);
                 obj.setColumnBoolean(false);
-                obj.setColumnBinary(new byte[]{1, 2, 3});
+                obj.setColumnBinary(new byte[] {1, 2, 3});
                 obj.setColumnDate(new Date(1000));
                 obj.setColumnRealmObject(new DogPrimaryKey(1, "Dog1"));
                 obj.setColumnRealmList(new RealmList<DogPrimaryKey>(new DogPrimaryKey(2, "Dog2")));
@@ -1791,6 +2048,41 @@ public void run() {
         TestHelper.awaitOrFail(bgThreadDoneLatch);
     }
 
+    // Test to reproduce issue https://github.com/realm/realm-java/issues/4957
+    @Test
+    public void copyToRealmOrUpdate_bug4957() {
+        Object4957 listElement = new Object4957();
+        listElement.setId(1);
+
+        Object4957 parent = new Object4957();
+        parent.setId(0);
+        parent.getChildList().add(listElement);
+
+        // parentCopy has same fields as the parent does. But they are not the same object.
+        Object4957 parentCopy = new Object4957();
+        parentCopy.setId(0);
+        parentCopy.getChildList().add(listElement);
+
+        parent.setChild(parentCopy);
+        parentCopy.setChild(parentCopy);
+
+        realm.beginTransaction();
+        Object4957 managedParent = realm.copyToRealmOrUpdate(parent);
+        realm.commitTransaction();
+        // The original bug fails here. It resulted the listElement has been added to the list twice.
+        // Because of the parent and parentCopy are not the same object, proxy will miss the cache to know the object
+        // has been created before. But it does know they share the same PK value.
+        assertEquals(1, managedParent.getChildList().size());
+
+        // insertOrUpdate doesn't have the problem!
+        realm.beginTransaction();
+        realm.deleteAll();
+        realm.insertOrUpdate(parent);
+        realm.commitTransaction();
+        managedParent = realm.where(Object4957.class).findFirst();
+        assertEquals(1, managedParent.getChildList().size());
+    }
+
     @Test
     public void getInstance_differentEncryptionKeys() {
         byte[] key1 = TestHelper.getRandomKey(42);
@@ -1897,7 +2189,7 @@ public void writeEncryptedCopyTo() throws Exception {
 
     @Test
     public void writeEncryptedCopyTo_wrongKeyLength() {
-        byte[]  wrongLengthKey = new byte[42];
+        byte[] wrongLengthKey = new byte[42];
         File destination = new File(configFactory.getRoot(), "wrong_key.realm");
         thrown.expect(IllegalArgumentException.class);
         realm.writeEncryptedCopyTo(destination, wrongLengthKey);
@@ -2009,8 +2301,11 @@ public void run() {
 
         assertTrue(Realm.deleteRealm(configuration));
 
-        // Directory should be empty now.
-        assertEquals(0, tempDir.listFiles().length);
+        assertEquals(1, tempDir.listFiles().length);
+
+        // Lock file should never be deleted
+        File lockFile = new File(configuration.getPath() + ".lock");
+        assertTrue(lockFile.exists());
     }
 
     // Tests that all methods that require a transaction. (ie. any function that mutates Realm data)
@@ -2033,34 +2328,91 @@ public void callMutableMethodOutsideTransaction() throws JSONException, IOExcept
         InputStream jsonArrStream2 = TestHelper.stringToStream(jsonArrStr);
 
         // Tests all methods that should require a transaction.
-        try { realm.createObject(AllTypes.class);   fail(); } catch (IllegalStateException expected) {}
-        try { realm.copyToRealm(t);                 fail(); } catch (IllegalStateException expected) {}
-        try { realm.copyToRealm(ts);                fail(); } catch (IllegalStateException expected) {}
-        try { realm.copyToRealmOrUpdate(t);         fail(); } catch (IllegalStateException expected) {}
-        try { realm.copyToRealmOrUpdate(ts);        fail(); } catch (IllegalStateException expected) {}
-        try { realm.delete(AllTypes.class);         fail(); } catch (IllegalStateException expected) {}
-        try { realm.deleteAll();                    fail(); } catch (IllegalStateException expected) {}
-
-        try { realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObj);                fail(); } catch (IllegalStateException expected) {}
-        try { realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);             fail(); } catch (IllegalStateException expected) {}
+        try {
+            realm.createObject(AllTypes.class);
+            fail();
+        } catch (IllegalStateException expected) {}
+        try {
+            realm.copyToRealm(t);
+            fail();
+        } catch (IllegalStateException expected) {}
+        try {
+            realm.copyToRealm(ts);
+            fail();
+        } catch (IllegalStateException expected) {}
+        try {
+            realm.copyToRealmOrUpdate(t);
+            fail();
+        } catch (IllegalStateException expected) {}
+        try {
+            realm.copyToRealmOrUpdate(ts);
+            fail();
+        } catch (IllegalStateException expected) {}
+        try {
+            realm.delete(AllTypes.class);
+            fail();
+        } catch (IllegalStateException expected) {}
+        try {
+            realm.deleteAll();
+            fail();
+        } catch (IllegalStateException expected) {}
+
+        try {
+            realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObj);
+            fail();
+        } catch (IllegalStateException expected) {}
+        try {
+            realm.createObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);
+            fail();
+        } catch (IllegalStateException expected) {}
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-            try { realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, jsonObjStream);   fail(); } catch (IllegalStateException expected) {}
+            try {
+                realm.createObjectFromJson(NoPrimaryKeyNullTypes.class, jsonObjStream);
+                fail();
+            } catch (IllegalStateException expected) {}
         }
-        try { realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObj);        fail(); } catch (IllegalStateException expected) {}
-        try { realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);     fail(); } catch (IllegalStateException expected) {}
+        try {
+            realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObj);
+            fail();
+        } catch (IllegalStateException expected) {}
+        try {
+            realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObjStr);
+            fail();
+        } catch (IllegalStateException expected) {}
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-            try { realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObjStream2); fail(); } catch (IllegalStateException expected) {}
+            try {
+                realm.createOrUpdateObjectFromJson(AllTypesPrimaryKey.class, jsonObjStream2);
+                fail();
+            } catch (IllegalStateException expected) {}
         }
 
-        try { realm.createAllFromJson(AllTypesPrimaryKey.class, jsonArr);                   fail(); } catch (IllegalStateException expected) {}
-        try { realm.createAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);                fail(); } catch (IllegalStateException expected) {}
+        try {
+            realm.createAllFromJson(AllTypesPrimaryKey.class, jsonArr);
+            fail();
+        } catch (IllegalStateException expected) {}
+        try {
+            realm.createAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);
+            fail();
+        } catch (IllegalStateException expected) {}
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-            try { realm.createAllFromJson(NoPrimaryKeyNullTypes.class, jsonArrStream);      fail(); } catch (IllegalStateException expected) {}
+            try {
+                realm.createAllFromJson(NoPrimaryKeyNullTypes.class, jsonArrStream);
+                fail();
+            } catch (IllegalStateException expected) {}
         }
-        try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArr);           fail(); } catch (IllegalStateException expected) {}
-        try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);        fail(); } catch (IllegalStateException expected) {}
+        try {
+            realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArr);
+            fail();
+        } catch (IllegalStateException expected) {}
+        try {
+            realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStr);
+            fail();
+        } catch (IllegalStateException expected) {}
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-            try { realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStream2);fail(); } catch (IllegalStateException expected) {}
+            try {
+                realm.createOrUpdateAllFromJson(AllTypesPrimaryKey.class, jsonArrStream2);
+                fail();
+            } catch (IllegalStateException expected) {}
         }
     }
 
@@ -2263,7 +2615,7 @@ public void execute(Realm realm) {
                 DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE);
         testOneObjectFound(realm, DefaultValueOfField.class,
                 DefaultValueOfField.FIELD_RANDOM_STRING, createdRandomString);
-        testOneObjectFound(realm, DefaultValueOfField.class,DefaultValueOfField.FIELD_SHORT,
+        testOneObjectFound(realm, DefaultValueOfField.class, DefaultValueOfField.FIELD_SHORT,
                 DefaultValueOfField.FIELD_SHORT_DEFAULT_VALUE);
         testOneObjectFound(realm, DefaultValueOfField.class,
                 DefaultValueOfField.FIELD_INT,
@@ -2337,14 +2689,14 @@ public void execute(Realm realm) {
                 DefaultValueConstructor.FIELD_SHORT_DEFAULT_VALUE);
         testOneObjectFound(realm, DefaultValueConstructor.class,
                 DefaultValueConstructor.FIELD_INT,
-                DefaultValueConstructor.FIELD_INT_DEFAULT_VALUE);;
+                DefaultValueConstructor.FIELD_INT_DEFAULT_VALUE);
         // Default value for pk must be ignored.
         testNoObjectFound(realm, DefaultValueConstructor.class,
                 DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY,
-                        DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE);
+                DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE);
         testOneObjectFound(realm, DefaultValueConstructor.class,
                 DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY,
-                        DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
+                DefaultValueConstructor.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
         testOneObjectFound(realm, DefaultValueConstructor.class,
                 DefaultValueConstructor.FIELD_LONG,
                 DefaultValueConstructor.FIELD_LONG_DEFAULT_VALUE);
@@ -2367,10 +2719,10 @@ public void execute(Realm realm) {
                 DefaultValueConstructor.FIELD_BINARY_DEFAULT_VALUE);
         testOneObjectFound(realm, DefaultValueConstructor.class,
                 DefaultValueConstructor.FIELD_OBJECT + "." + RandomPrimaryKey.FIELD_INT,
-                        RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
+                RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
         testOneObjectFound(realm, DefaultValueConstructor.class,
                 DefaultValueConstructor.FIELD_LIST + "." + RandomPrimaryKey.FIELD_INT,
-                        RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
+                RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
     }
 
     @Test
@@ -2400,10 +2752,10 @@ public void execute(Realm realm) {
         // Default value for pk must be ignored.
         testNoObjectFound(realm, DefaultValueSetter.class,
                 DefaultValueSetter.FIELD_LONG_PRIMARY_KEY,
-                        DefaultValueSetter.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE);
+                DefaultValueSetter.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE);
         testOneObjectFound(realm, DefaultValueSetter.class,
                 DefaultValueSetter.FIELD_LONG_PRIMARY_KEY,
-                        DefaultValueSetter.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
+                DefaultValueSetter.FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE * 3);
         testOneObjectFound(realm, DefaultValueSetter.class,
                 DefaultValueSetter.FIELD_LONG,
                 DefaultValueSetter.FIELD_LONG_DEFAULT_VALUE);
@@ -2427,13 +2779,13 @@ public void execute(Realm realm) {
                 DefaultValueSetter.FIELD_BINARY_DEFAULT_VALUE);
         testOneObjectFound(realm, DefaultValueSetter.class,
                 DefaultValueSetter.FIELD_OBJECT + "." + RandomPrimaryKey.FIELD_INT,
-                        RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
+                RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
         testOneObjectFound(realm, DefaultValueSetter.class,
                 DefaultValueSetter.FIELD_LIST + "." + RandomPrimaryKey.FIELD_INT,
-                        RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
+                RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE);
         testOneObjectFound(realm, DefaultValueSetter.class,
-                DefaultValueSetter.FIELD_LIST+ "." + RandomPrimaryKey.FIELD_INT,
-                        RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 1);
+                DefaultValueSetter.FIELD_LIST + "." + RandomPrimaryKey.FIELD_INT,
+                RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 1);
     }
 
     @Test
@@ -2464,7 +2816,8 @@ public void copyToRealm_defaultValuesAreIgnored() {
         final int fieldListIntValue = RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 2;
 
         final DefaultValueOfField managedObj;
-        realm.beginTransaction(); {
+        realm.beginTransaction();
+        {
             final DefaultValueOfField obj = new DefaultValueOfField();
             obj.setFieldIgnored(fieldIgnoredValue);
             obj.setFieldString(fieldStringValue);
@@ -2490,6 +2843,17 @@ public void copyToRealm_defaultValuesAreIgnored() {
             list.add(listItem);
             obj.setFieldList(list);
 
+            obj.setFieldStringList(new RealmList<>("2", "3"));
+            obj.setFieldBooleanList(new RealmList<>(true, false));
+            obj.setFieldBinaryList(new RealmList<>(new byte[] {2}, new byte[] {3}));
+            obj.setFieldLongList(new RealmList<>(2L, 3L));
+            obj.setFieldIntegerList(new RealmList<>(2, 3));
+            obj.setFieldShortList(new RealmList<>((short) 2, (short) 3));
+            obj.setFieldByteList(new RealmList<>((byte) 2, (byte) 3));
+            obj.setFieldDoubleList(new RealmList<>(2D, 3D));
+            obj.setFieldFloatList(new RealmList<>(2F, 3F));
+            obj.setFieldDateList(new RealmList<>(new Date(2L), new Date(3L)));
+
             managedObj = realm.copyToRealm(obj);
         }
         realm.commitTransaction();
@@ -2503,15 +2867,46 @@ public void copyToRealm_defaultValuesAreIgnored() {
         assertEquals(fieldLongPrimaryKeyValue, managedObj.getFieldLongPrimaryKey());
         assertEquals(fieldLongValue, managedObj.getFieldLong());
         assertEquals(fieldByteValue, managedObj.getFieldByte());
-        assertEquals(fieldFloatValue, managedObj.getFieldFloat(), 0f);
-        assertEquals(fieldDoubleValue, managedObj.getFieldDouble(), 0d);
+        assertEquals(fieldFloatValue, managedObj.getFieldFloat(), 0F);
+        assertEquals(fieldDoubleValue, managedObj.getFieldDouble(), 0D);
         assertEquals(fieldBooleanValue, managedObj.isFieldBoolean());
         assertEquals(fieldDateValue, managedObj.getFieldDate());
-        assertTrue(Arrays.equals(fieldBinaryValue, managedObj.getFieldBinary()));
+        assertArrayEquals(fieldBinaryValue, managedObj.getFieldBinary());
         assertEquals(fieldObjectIntValue, managedObj.getFieldObject().getFieldInt());
         assertEquals(1, managedObj.getFieldList().size());
         assertEquals(fieldListIntValue, managedObj.getFieldList().first().getFieldInt());
 
+        assertEquals(2, managedObj.getFieldStringList().size());
+        assertEquals("2", managedObj.getFieldStringList().get(0));
+        assertEquals("3", managedObj.getFieldStringList().get(1));
+        assertEquals(2, managedObj.getFieldBooleanList().size());
+        assertEquals(true, managedObj.getFieldBooleanList().get(0));
+        assertEquals(false, managedObj.getFieldBooleanList().get(1));
+        assertEquals(2, managedObj.getFieldBinaryList().size());
+        assertArrayEquals(new byte[] {2}, managedObj.getFieldBinaryList().get(0));
+        assertArrayEquals(new byte[] {3}, managedObj.getFieldBinaryList().get(1));
+        assertEquals(2, managedObj.getFieldLongList().size());
+        assertEquals((Long) 2L, managedObj.getFieldLongList().get(0));
+        assertEquals((Long) 3L, managedObj.getFieldLongList().get(1));
+        assertEquals(2, managedObj.getFieldIntegerList().size());
+        assertEquals((Integer) 2, managedObj.getFieldIntegerList().get(0));
+        assertEquals((Integer) 3, managedObj.getFieldIntegerList().get(1));
+        assertEquals(2, managedObj.getFieldShortList().size());
+        assertEquals((Short) (short) 2, managedObj.getFieldShortList().get(0));
+        assertEquals((Short) (short) 3, managedObj.getFieldShortList().get(1));
+        assertEquals(2, managedObj.getFieldByteList().size());
+        assertEquals((Byte) (byte) 2, managedObj.getFieldByteList().get(0));
+        assertEquals((Byte) (byte) 3, managedObj.getFieldByteList().get(1));
+        assertEquals(2, managedObj.getFieldDoubleList().size());
+        assertEquals((Double) 2D, managedObj.getFieldDoubleList().get(0));
+        assertEquals((Double) 3D, managedObj.getFieldDoubleList().get(1));
+        assertEquals(2, managedObj.getFieldFloatList().size());
+        assertEquals((Float) 2F, managedObj.getFieldFloatList().get(0));
+        assertEquals((Float) 3F, managedObj.getFieldFloatList().get(1));
+        assertEquals(2, managedObj.getFieldDateList().size());
+        assertEquals(new Date(2L), managedObj.getFieldDateList().get(0));
+        assertEquals(new Date(3L), managedObj.getFieldDateList().get(1));
+
         // Makes sure that excess object by default value is not created.
         assertEquals(2, realm.where(RandomPrimaryKey.class).count());
     }
@@ -2519,7 +2914,8 @@ public void copyToRealm_defaultValuesAreIgnored() {
     @Test
     public void copyFromRealm_defaultValuesAreIgnored() {
         final DefaultValueOfField managedObj;
-        realm.beginTransaction(); {
+        realm.beginTransaction();
+        {
             final DefaultValueOfField obj = new DefaultValueOfField();
             obj.setFieldIgnored(DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE + ".modified");
             obj.setFieldString(DefaultValueOfField.FIELD_STRING_DEFAULT_VALUE + ".modified");
@@ -2545,6 +2941,17 @@ public void copyFromRealm_defaultValuesAreIgnored() {
             list.add(listItem);
             obj.setFieldList(list);
 
+            obj.setFieldStringList(new RealmList<>("2", "3"));
+            obj.setFieldBooleanList(new RealmList<>(true, false));
+            obj.setFieldBinaryList(new RealmList<>(new byte[] {2}, new byte[] {3}));
+            obj.setFieldLongList(new RealmList<>(2L, 3L));
+            obj.setFieldIntegerList(new RealmList<>(2, 3));
+            obj.setFieldShortList(new RealmList<>((short) 2, (short) 3));
+            obj.setFieldByteList(new RealmList<>((byte) 2, (byte) 3));
+            obj.setFieldDoubleList(new RealmList<>(2D, 3D));
+            obj.setFieldFloatList(new RealmList<>(2F, 3F));
+            obj.setFieldDateList(new RealmList<>(new Date(2L), new Date(3L)));
+
             managedObj = realm.copyToRealm(obj);
         }
         realm.commitTransaction();
@@ -2559,14 +2966,46 @@ public void copyFromRealm_defaultValuesAreIgnored() {
         assertEquals(managedObj.getFieldLongPrimaryKey(), copy.getFieldLongPrimaryKey());
         assertEquals(managedObj.getFieldLong(), copy.getFieldLong());
         assertEquals(managedObj.getFieldByte(), copy.getFieldByte());
-        assertEquals(managedObj.getFieldFloat(), copy.getFieldFloat(), 0f);
-        assertEquals(managedObj.getFieldDouble(), copy.getFieldDouble(), 0d);
+        assertEquals(managedObj.getFieldFloat(), copy.getFieldFloat(), 0F);
+        assertEquals(managedObj.getFieldDouble(), copy.getFieldDouble(), 0D);
         assertEquals(managedObj.isFieldBoolean(), copy.isFieldBoolean());
         assertEquals(managedObj.getFieldDate(), copy.getFieldDate());
-        assertTrue(Arrays.equals(managedObj.getFieldBinary(), copy.getFieldBinary()));
+        assertArrayEquals(managedObj.getFieldBinary(), copy.getFieldBinary());
         assertEquals(managedObj.getFieldObject().getFieldInt(), copy.getFieldObject().getFieldInt());
         assertEquals(1, copy.getFieldList().size());
+        //noinspection ConstantConditions
         assertEquals(managedObj.getFieldList().first().getFieldInt(), copy.getFieldList().first().getFieldInt());
+
+        assertEquals(2, managedObj.getFieldStringList().size());
+        assertEquals("2", managedObj.getFieldStringList().get(0));
+        assertEquals("3", managedObj.getFieldStringList().get(1));
+        assertEquals(2, managedObj.getFieldBooleanList().size());
+        assertEquals(true, managedObj.getFieldBooleanList().get(0));
+        assertEquals(false, managedObj.getFieldBooleanList().get(1));
+        assertEquals(2, managedObj.getFieldBinaryList().size());
+        assertArrayEquals(new byte[] {2}, managedObj.getFieldBinaryList().get(0));
+        assertArrayEquals(new byte[] {3}, managedObj.getFieldBinaryList().get(1));
+        assertEquals(2, managedObj.getFieldLongList().size());
+        assertEquals((Long) 2L, managedObj.getFieldLongList().get(0));
+        assertEquals((Long) 3L, managedObj.getFieldLongList().get(1));
+        assertEquals(2, managedObj.getFieldIntegerList().size());
+        assertEquals((Integer) 2, managedObj.getFieldIntegerList().get(0));
+        assertEquals((Integer) 3, managedObj.getFieldIntegerList().get(1));
+        assertEquals(2, managedObj.getFieldShortList().size());
+        assertEquals((Short) (short) 2, managedObj.getFieldShortList().get(0));
+        assertEquals((Short) (short) 3, managedObj.getFieldShortList().get(1));
+        assertEquals(2, managedObj.getFieldByteList().size());
+        assertEquals((Byte) (byte) 2, managedObj.getFieldByteList().get(0));
+        assertEquals((Byte) (byte) 3, managedObj.getFieldByteList().get(1));
+        assertEquals(2, managedObj.getFieldDoubleList().size());
+        assertEquals((Double) 2D, managedObj.getFieldDoubleList().get(0));
+        assertEquals((Double) 3D, managedObj.getFieldDoubleList().get(1));
+        assertEquals(2, managedObj.getFieldFloatList().size());
+        assertEquals((Float) 2F, managedObj.getFieldFloatList().get(0));
+        assertEquals((Float) 3F, managedObj.getFieldFloatList().get(1));
+        assertEquals(2, managedObj.getFieldDateList().size());
+        assertEquals(new Date(2L), managedObj.getFieldDateList().get(0));
+        assertEquals(new Date(3L), managedObj.getFieldDateList().get(1));
     }
 
     // Tests close Realm in another thread different from where it is created.
@@ -3044,38 +3483,28 @@ public void copyFromRealm_dynamicRealmListThrows() {
 
     // Tests if close can be called from Realm change listener when there is no other listeners.
     @Test
+    @RunTestInLooperThread
     public void closeRealmInChangeListener() {
-        realm.close();
-        final CountDownLatch signalTestFinished = new CountDownLatch(1);
-        HandlerThread handlerThread = new HandlerThread("background");
-        handlerThread.start();
-        final Handler handler = new Handler(handlerThread.getLooper());
-        handler.post(new Runnable() {
+        final Realm realm = looperThread.getRealm();
+        final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
             @Override
-            public void run() {
-                final Realm realm = Realm.getInstance(realmConfig);
-                final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
-                    @Override
-                    public void onChange(Realm object) {
-                        if (realm.where(AllTypes.class).count() == 1) {
-                            realm.removeChangeListener(this);
-                            realm.close();
-                            signalTestFinished.countDown();
-                        }
-                    }
-                };
+            public void onChange(Realm object) {
+                if (realm.where(AllTypes.class).count() == 1) {
+                    realm.removeChangeListener(this);
+                    realm.close();
+                    looperThread.testComplete();
+                }
+            }
+        };
 
-                realm.addChangeListener(listener);
+        realm.addChangeListener(listener);
 
-                realm.executeTransactionAsync(new Realm.Transaction() {
-                    @Override
-                    public void execute(Realm realm) {
-                        realm.createObject(AllTypes.class);
-                    }
-                });
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(AllTypes.class);
             }
         });
-        TestHelper.awaitOrFail(signalTestFinished);
     }
 
     // Tests if close can be called from Realm change listener when there is a listener on empty Realm Object.
@@ -3616,7 +4045,7 @@ public void run() {
     }
 
     // Cannot wait inside of a transaction.
-    @Test(expected= IllegalStateException.class)
+    @Test(expected = IllegalStateException.class)
     public void waitForChange_illegalWaitInsideTransaction() {
         realm.beginTransaction();
         realm.waitForChange();
@@ -3696,49 +4125,51 @@ public void run(Realm realm) {
         assertFalse(bgRealmChangeResult.get());
     }
 
+    // Check if the column indices cache is refreshed if the index of a defined column is changed by another Realm
+    // instance.
     @Test
-    public void schemaIndexCacheIsUpdatedAfterSchemaChange() {
-        final AtomicLong nameIndexNew = new AtomicLong(-1L);
+    public void nonAdditiveSchemaChangesWhenTypedRealmExists() throws InterruptedException {
+        final String TEST_CHARS = "TEST_CHARS";
+        final RealmConfiguration realmConfig = configFactory.createConfigurationBuilder()
+                .schema(StringOnly.class)
+                .name("schemaChangeTest")
+                .build();
+        Realm realm = Realm.getInstance(realmConfig);
+        StringOnlyRealmProxy.StringOnlyColumnInfo columnInfo
+                = (StringOnlyRealmProxy.StringOnlyColumnInfo) realm.getSchema().getColumnInfo(StringOnly.class);
+        assertEquals(0, columnInfo.charsIndex);
 
-        // get the pre-update index for the "name" column.
-        CatRealmProxy.CatColumnInfo catColumnInfo
-                = (CatRealmProxy.CatColumnInfo) realm.schema.getColumnInfo(Cat.class);
-        final long nameIndex = catColumnInfo.nameIndex;
+        realm.beginTransaction();
+        StringOnly stringOnly = realm.createObject(StringOnly.class);
+        stringOnly.setChars(TEST_CHARS);
+        realm.commitTransaction();
 
-        // Change the index of the column "name".
-        realm.executeTransaction(new Realm.Transaction() {
+        Thread thread = new Thread(new Runnable() {
             @Override
-            public void execute(Realm realm) {
-                final Table catTable = realm.getSchema().getTable(Cat.CLASS_NAME);
-                final long nameIndex = catTable.getColumnIndex(Cat.FIELD_NAME);
-                catTable.removeColumn(nameIndex);
-                final long newIndex = catTable.addColumn(RealmFieldType.STRING, Cat.FIELD_NAME, true);
-                realm.setVersion(realm.getConfiguration().getSchemaVersion() + 1);
-                nameIndexNew.set(newIndex);
+            public void run() {
+                // Here we try to change the column index of FIELD_CHARS from 0 to 1.
+                DynamicRealm realm = DynamicRealm.getInstance(realmConfig);
+                realm.beginTransaction();
+                RealmObjectSchema stringOnlySchema = realm.getSchema().get(StringOnly.CLASS_NAME);
+                assertEquals(0, stringOnlySchema.getColumnIndex(StringOnly.FIELD_CHARS));
+                Table table = stringOnlySchema.getTable();
+                // Please notice that we cannot do it by removing/adding a column since it is not allowed by Object
+                // Store. Do it by using the internal API insertColumn.
+                table.insertColumn(0, RealmFieldType.INTEGER, "NewColumn");
+                assertEquals(1, stringOnlySchema.getColumnIndex(StringOnly.FIELD_CHARS));
+                realm.commitTransaction();
+                realm.close();
             }
         });
+        thread.start();
+        thread.join();
+        realm.refresh();
 
-        // We need to update index cache if the schema version was changed in the same thread.
-        realm.sharedRealm.invokeSchemaChangeListenerIfSchemaChanged();
-
-        // Verify that the index has changed.
-        assertNotEquals(nameIndex, nameIndexNew);
-
-        // Verify that the index in the ColumnInfo has been updated.
-        catColumnInfo = (CatRealmProxy.CatColumnInfo) realm.schema.getColumnInfo(Cat.class);
-        assertEquals(nameIndexNew.get(), catColumnInfo.nameIndex);
-        assertEquals(nameIndexNew.get(), (long) catColumnInfo.getIndicesMap().get(Cat.FIELD_NAME));
-
-        // Checks by actual get and set.
-        realm.executeTransaction(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                final Cat cat = realm.createObject(Cat.class);
-                cat.setName("pochi");
-            }
-        });
-        //noinspection ConstantConditions
-        assertEquals("pochi", realm.where(Cat.class).findFirst().getName());
+        // The columnInfo object never changes, only the indexes it references will.
+        assertSame(columnInfo, realm.getSchema().getColumnInfo(StringOnly.class));
+        assertEquals(TEST_CHARS, stringOnly.getChars());
+        assertEquals(1, columnInfo.charsIndex);
+        realm.close();
     }
 
     @Test
@@ -3838,6 +4269,35 @@ public boolean accept(File dir, String name) {
         realmOnExternalStorage.close();
     }
 
+    @Test(expected = IllegalStateException.class)
+    public void getInstanceAsync_nonLooperThreadShouldThrow() {
+        Realm.getInstanceAsync(realmConfig, new Realm.Callback() {
+            @Override
+            public void onSuccess(Realm realm) {
+                fail();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void getInstanceAsync_nullConfigShouldThrow() {
+        thrown.expect(IllegalArgumentException.class);
+        Realm.getInstanceAsync(null, new Realm.Callback() {
+            @Override
+            public void onSuccess(Realm realm) {
+                fail();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void getInstanceAsync_nullCallbackShouldThrow() {
+        thrown.expect(IllegalArgumentException.class);
+        Realm.getInstanceAsync(realmConfig, null);
+    }
+
     // Verify that the logic for waiting for the users file dir to be come available isn't totally broken
     // This is pretty hard to test, so forced to break encapsulation in this case.
     @Test
@@ -3861,6 +4321,7 @@ public void init_waitForFilesDir() throws NoSuchMethodException, InvocationTarge
         when(mockContext.getFilesDir()).then(new Answer<File>() {
             int calls = 0;
             File userFolder = tmpFolder.newFolder();
+
             @Override
             public File answer(InvocationOnMock invocationOnMock) throws Throwable {
                 calls++;
@@ -3870,4 +4331,146 @@ public File answer(InvocationOnMock invocationOnMock) throws Throwable {
 
         assertNull(m.invoke(null, mockContext));
     }
+
+    @Test
+    @RunTestInLooperThread
+    public void refresh_triggerNotifications() {
+        final CountDownLatch bgThreadDone = new CountDownLatch(1);
+        final AtomicBoolean listenerCalled = new AtomicBoolean(false);
+        Realm realm = looperThread.getRealm();
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+        assertEquals(0, results.size());
+        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> results) {
+                assertEquals(1, results.size());
+                listenerCalled.set(true);
+            }
+        });
+
+        // Advance the Realm on a background while blocking this thread. When we refresh, it should trigger
+        // the listener.
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(looperThread.getConfiguration());
+                realm.beginTransaction();
+                realm.createObject(AllTypes.class);
+                realm.commitTransaction();
+                realm.close();
+                bgThreadDone.countDown();
+            }
+        }).start();
+        TestHelper.awaitOrFail(bgThreadDone);
+
+        realm.refresh();
+        assertTrue(listenerCalled.get());
+        looperThread.testComplete();
+    }
+
+    @Test
+    public void refresh_nonLooperThreadAdvances() {
+        final CountDownLatch bgThreadDone = new CountDownLatch(1);
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+        assertEquals(0, results.size());
+
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(RealmTests.this.realm.getConfiguration());
+                realm.beginTransaction();
+                realm.createObject(AllTypes.class);
+                realm.commitTransaction();
+                realm.close();
+                bgThreadDone.countDown();
+            }
+        }).start();
+        TestHelper.awaitOrFail(bgThreadDone);
+
+        realm.refresh();
+        assertEquals(1, results.size());
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void refresh_forceSynchronousNotifications() {
+        final CountDownLatch bgThreadDone = new CountDownLatch(1);
+        final AtomicBoolean listenerCalled = new AtomicBoolean(false);
+        Realm realm = looperThread.getRealm();
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
+        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> results) {
+                // Will be forced synchronous
+                assertEquals(1, results.size());
+                listenerCalled.set(true);
+            }
+        });
+
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(looperThread.getConfiguration());
+                realm.beginTransaction();
+                realm.createObject(AllTypes.class);
+                realm.commitTransaction();
+                realm.close();
+                bgThreadDone.countDown();
+            }
+        }).start();
+        TestHelper.awaitOrFail(bgThreadDone);
+
+        realm.refresh();
+        assertTrue(listenerCalled.get());
+        looperThread.testComplete();
+    }
+
+    @Test
+    public void refresh_insideTransactionThrows() {
+        realm.beginTransaction();
+        try {
+            realm.refresh();
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+        realm.cancelTransaction();
+    }
+
+    @Test
+    public void beginTransaction_readOnlyThrows() {
+        RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .name("readonly.realm")
+                .schema(StringOnlyReadOnly.class)
+                .assetFile("readonly.realm")
+                .readOnly()
+                .build();
+        Realm realm = Realm.getInstance(config);
+        try {
+            realm.beginTransaction();
+            fail();
+        } catch (IllegalStateException e) {
+            assertThat(e.getMessage(),
+                    CoreMatchers.containsString("Can't perform transactions on read-only Realms."));
+        } finally {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void getInstance_wrongSchemaInReadonlyThrows() {
+        RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .name("readonly.realm")
+                .schema(StringOnlyReadOnly.class, AllJavaTypes.class)
+                .assetFile("readonly.realm")
+                .readOnly()
+                .build();
+
+        // This will throw because the Realm doesn't have the correct schema, and a new file cannot be re-created
+        // because it is read only.
+        try {
+            realm = Realm.getInstance(config);
+            fail();
+        } catch (RealmMigrationNeededException ignored) {
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RunTestInLooperThreadLifeCycleTest.java b/realm/realm-library/src/androidTest/java/io/realm/RunTestInLooperThreadLifeCycleTest.java
new file mode 100644
index 0000000000..cc70851ced
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/RunTestInLooperThreadLifeCycleTest.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+
+/**
+ * Meta test. Checking the lifecycle of @RunTestInLooperThreadTest does the right thing.
+ *
+ * Current order is:
+ * - @RunTestInLooperThread(before = <classRef>)
+ * - @Before()
+ * - @RunTestInLooperThread/@Test
+ * - @After : This is called when exiting the test method. Warning: Looper test is still running.
+ * - looperThread.runAfterTest(Runnable) : This is called when the LooperTest either succeed or fails.
+ */
+
+@RunWith(AndroidJUnit4.class)
+public class RunTestInLooperThreadLifeCycleTest {
+
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    private static AtomicBoolean beforeCalled = new AtomicBoolean(false);
+    private static AtomicBoolean afterCalled = new AtomicBoolean(false);
+    private static AtomicBoolean testExited = new AtomicBoolean(false);
+    private static AtomicBoolean beforeRunnableCalled = new AtomicBoolean(false);
+    private static AtomicBoolean afterRunnableCalled = new AtomicBoolean(false);
+    private static AtomicBoolean closableClosed = new AtomicBoolean(false);
+
+    @Before
+    public void before() {
+        assertTrue(beforeCalled.compareAndSet(false, true));
+        assertTrue(beforeRunnableCalled.get());
+
+        looperThread.closeAfterTest(new Closeable() {
+            @Override
+            public void close() throws IOException {
+                assertTrue(testExited.get());
+                assertFalse(afterRunnableCalled.get());
+                assertTrue(closableClosed.compareAndSet(false, true));
+            }
+        });
+        looperThread.runAfterTest(new Runnable() {
+            @Override
+            public void run() {
+                assertTrue(testExited.get());
+                assertTrue(afterRunnableCalled.compareAndSet(false, true));
+                assertTrue(looperThread.isTestComplete());
+            }
+        });
+;    }
+
+    @After
+    public void after() {
+        assertTrue(afterCalled.compareAndSet(false, true));
+        assertTrue(testExited.get());
+        assertFalse(looperThread.isTestComplete()); // Beware of this. Use `runAfterTest` for destroying resources used.
+    }
+
+    @Test
+    @RunTestInLooperThread(before = PrepareLooperTest.class)
+    public void looperTest() {
+        looperThread.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                assertTrue(afterCalled.get());
+                assertFalse(looperThread.isTestComplete());
+                looperThread.testComplete();
+            }
+        });
+        assertTrue(testExited.compareAndSet(false, true));
+    }
+
+    public static class PrepareLooperTest implements RunInLooperThread.RunnableBefore {
+        @Override
+        public void run(RealmConfiguration realmConfig) {
+            assertTrue(beforeRunnableCalled.compareAndSet(false, true));
+            assertFalse(beforeCalled.get());
+        }
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
index eafe61d82d..0e3d29d2df 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
@@ -31,20 +31,24 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 
+import io.reactivex.Flowable;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.functions.Action;
+import io.reactivex.functions.Consumer;
+import io.reactivex.functions.Predicate;
 import io.realm.entities.AllTypes;
 import io.realm.entities.CyclicType;
 import io.realm.entities.Dog;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
-import rx.Observable;
-import rx.Subscription;
-import rx.functions.Action0;
-import rx.functions.Action1;
-import rx.functions.Func1;
+import io.realm.rx.CollectionChange;
+import io.realm.rx.ObjectChange;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -57,8 +61,8 @@
     public final RunInLooperThread looperThread = new RunInLooperThread() {
         @Override
         public void looperTearDown() {
-            if (subscription != null && !subscription.isUnsubscribed()) {
-                subscription.unsubscribe();
+            if (subscription != null && !subscription.isDisposed()) {
+                subscription.dispose();
             }
         }
     };
@@ -66,7 +70,7 @@ public void looperTearDown() {
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
 
     private Realm realm;
-    private Subscription subscription;
+    private Disposable subscription;
 
     @Before
     public void setUp() throws Exception {
@@ -90,15 +94,57 @@ public void realmObject_emittedOnSubscribe() {
         realm.commitTransaction();
 
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
-        subscription = obj.<AllTypes>asObservable().subscribe(new Action1<AllTypes>() {
+        subscription = obj.<AllTypes>asFlowable().subscribe(new Consumer <AllTypes>() {
             @Override
-            public void call(AllTypes rxObject) {
+            public void accept(AllTypes rxObject) throws Exception {
                 assertTrue(rxObject == obj);
                 subscribedNotified.set(true);
             }
         });
         assertTrue(subscribedNotified.get());
-        subscription.unsubscribe();
+        subscription.dispose();
+    }
+
+    @Test
+    @UiThreadTest
+    public void realmObject_emitChangesetOnSubscribe() {
+        realm.beginTransaction();
+        final AllTypes obj = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
+        subscription = obj.asChangesetObservable().subscribe(new Consumer<ObjectChange<RealmObject>>() {
+            @Override
+            public void accept(ObjectChange<RealmObject> change) throws Exception {
+                assertTrue(change.getObject() == obj);
+                assertNull(change.getChangeset());
+                subscribedNotified.set(true);
+            }
+        });
+        assertTrue(subscribedNotified.get());
+        subscription.dispose();
+    }
+
+    @Test
+    @UiThreadTest
+    public void dynamicRealmObject_emitChangesetOnSubscribe() {
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
+        dynamicRealm.beginTransaction();
+        final DynamicRealmObject obj = dynamicRealm.createObject(AllTypes.CLASS_NAME);
+        dynamicRealm.commitTransaction();
+
+        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
+        subscription = obj.asChangesetObservable().subscribe(new Consumer<ObjectChange<RealmObject>>() {
+            @Override
+            public void accept(ObjectChange<RealmObject> change) throws Exception {
+                assertTrue(change.getObject() == obj);
+                assertNull(change.getChangeset());
+                subscribedNotified.set(true);
+            }
+        });
+        assertTrue(subscribedNotified.get());
+        subscription.dispose();
+        dynamicRealm.close();
     }
 
     @Test
@@ -110,10 +156,35 @@ public void realmObject_emittedOnUpdate() {
         final AllTypes obj = realm.createObject(AllTypes.class);
         realm.commitTransaction();
 
-        subscription = obj.<AllTypes>asObservable().subscribe(new Action1<AllTypes>() {
+        subscription = obj.<AllTypes>asFlowable().subscribe(new Consumer<AllTypes>() {
+            @Override
+            public void accept(AllTypes allTypes) throws Exception {
+                if (subscriberCalled.incrementAndGet() == 2) {
+                    looperThread.testComplete();
+                }
+            }
+        });
+
+        realm.beginTransaction();
+        obj.setColumnLong(1);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void realmObject_emittedChangesetOnUpdate() {
+        final AtomicInteger subscriberCalled = new AtomicInteger(0);
+        Realm realm = looperThread.getRealm();
+        realm.beginTransaction();
+        final AllTypes obj = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        subscription = obj.asChangesetObservable().subscribe(new Consumer<ObjectChange<RealmObject>>() {
             @Override
-            public void call(AllTypes rxObject) {
+            public void accept(ObjectChange<RealmObject> change) throws Exception {
                 if (subscriberCalled.incrementAndGet() == 2) {
+                    assertNotNull(change.getChangeset());
+                    assertTrue(change.getChangeset().isFieldChanged(AllTypes.FIELD_LONG));
                     looperThread.testComplete();
                 }
             }
@@ -124,6 +195,31 @@ public void call(AllTypes rxObject) {
         realm.commitTransaction();
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void dynamicRealmObject_emittedChangesetOnUpdate() {
+        final AtomicInteger subscriberCalled = new AtomicInteger(0);
+        DynamicRealm realm = DynamicRealm.getInstance(looperThread.getConfiguration());
+        looperThread.closeAfterTest(realm);
+        realm.beginTransaction();
+        final DynamicRealmObject obj = realm.createObject(AllTypes.CLASS_NAME);
+        realm.commitTransaction();
+
+        subscription = obj.asChangesetObservable().subscribe(new Consumer<ObjectChange<RealmObject>>() {
+            @Override
+            public void accept(ObjectChange<RealmObject> change) throws Exception {
+                if (subscriberCalled.incrementAndGet() == 2) {
+                    assertNotNull(change.getChangeset());
+                    assertTrue(change.getChangeset().isFieldChanged(AllTypes.FIELD_LONG));
+                    looperThread.testComplete();
+                }
+            }
+        });
+        realm.beginTransaction();
+        obj.setLong(AllTypes.FIELD_LONG, 1);
+        realm.commitTransaction();
+    }
+
     @Test
     @UiThreadTest
     public void findFirst_emittedOnSubscribe() {
@@ -132,15 +228,15 @@ public void findFirst_emittedOnSubscribe() {
         realm.commitTransaction();
 
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
-        subscription = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, 42).findFirst().<AllTypes>asObservable()
-                .subscribe(new Action1<AllTypes>() {
+        subscription = realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, 42).findFirst().<AllTypes>asFlowable()
+                .subscribe(new Consumer <AllTypes>() {
                     @Override
-                    public void call(AllTypes rxObject) {
+                    public void accept(AllTypes allTypes) throws Exception {
                         subscribedNotified.set(true);
                     }
                 });
         assertTrue(subscribedNotified.get());
-        subscription.unsubscribe();
+        subscription.dispose();
     }
 
     @Test
@@ -152,15 +248,15 @@ public void findFirstAsync_emittedOnSubscribe() {
 
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
         final AllTypes asyncObj = realm.where(AllTypes.class).findFirstAsync();
-        subscription = asyncObj.<AllTypes>asObservable().subscribe(new Action1<AllTypes>() {
+        subscription = asyncObj.<AllTypes>asFlowable().subscribe(new Consumer<AllTypes>() {
             @Override
-            public void call(AllTypes rxObject) {
+            public void accept(AllTypes rxObject) throws Exception {
                 assertTrue(rxObject == asyncObj);
                 subscribedNotified.set(true);
             }
         });
         assertTrue(subscribedNotified.get());
-        subscription.unsubscribe();
+        subscription.dispose();
     }
 
     @Test
@@ -171,9 +267,9 @@ public void findFirstAsync_emittedOnUpdate() {
         realm.beginTransaction();
         AllTypes obj = realm.createObject(AllTypes.class);
         realm.commitTransaction();
-        subscription = realm.where(AllTypes.class).findFirstAsync().<AllTypes>asObservable().subscribe(new Action1<AllTypes>() {
+        subscription = realm.where(AllTypes.class).findFirstAsync().<AllTypes>asFlowable().subscribe(new Consumer<AllTypes>() {
             @Override
-            public void call(AllTypes rxObject) {
+            public void accept(AllTypes rxObject) throws Exception {
                 if (subscriberCalled.incrementAndGet() == 2) {
                     looperThread.testComplete();
                 }
@@ -191,12 +287,12 @@ public void findFirstAsync_emittedOnDelete() {
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
         final Realm realm = looperThread.getRealm();
         realm.beginTransaction();
-        final AllTypes obj = realm.createObject(AllTypes.class);
+        realm.createObject(AllTypes.class);
         realm.commitTransaction();
 
-        subscription = realm.where(AllTypes.class).findFirstAsync().<AllTypes>asObservable().subscribe(new Action1<AllTypes>() {
+        subscription = realm.where(AllTypes.class).findFirstAsync().<AllTypes>asFlowable().subscribe(new Consumer<AllTypes>() {
             @Override
-            public void call(final AllTypes rxObject) {
+            public void accept(AllTypes rxObject) throws Exception {
                 switch (subscriberCalled.incrementAndGet()) {
                     case 1:
                         assertFalse(rxObject.isLoaded());
@@ -228,16 +324,32 @@ public void execute(Realm realm) {
     public void realmResults_emittedOnSubscribe() {
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
         final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
-        subscription = results.asObservable().subscribe(new Action1<RealmResults<AllTypes>>() {
+        subscription = results.asFlowable().subscribe(new Consumer<RealmResults<AllTypes>>() {
             @Override
             @SuppressWarnings("ReferenceEquality")
-            public void call(RealmResults<AllTypes> rxResults) {
+            public void accept(RealmResults<AllTypes> rxResults) throws Exception {
                 assertTrue(rxResults == results);
                 subscribedNotified.set(true);
             }
         });
         assertTrue(subscribedNotified.get());
-        subscription.unsubscribe();
+        subscription.dispose();
+    }
+
+    @Test
+    @UiThreadTest
+    public void realmResults_emittedChangesetOnSubscribe() {
+        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+        subscription = results.asChangesetObservable().subscribe(new Consumer<CollectionChange<RealmResults<AllTypes>>>() {
+            @Override
+            public void accept(CollectionChange<RealmResults<AllTypes>> change) throws Exception {
+                assertEquals(results, change.getCollection());
+                subscribedNotified.set(true);
+            }
+        });
+        assertTrue(subscribedNotified.get());
+        subscription.dispose();
     }
 
     @Test
@@ -247,16 +359,35 @@ public void realmList_emittedOnSubscribe() {
         realm.beginTransaction();
         final RealmList<Dog> list = realm.createObject(AllTypes.class).getColumnRealmList();
         realm.commitTransaction();
-        subscription = list.asObservable().subscribe(new Action1<RealmList<Dog>>() {
+        subscription = list.asFlowable().subscribe(new Consumer<RealmList<Dog>>() {
             @Override
             @SuppressWarnings("ReferenceEquality")
-            public void call(RealmList<Dog> rxList) {
+            public void accept(RealmList<Dog> rxList) throws Exception {
                 assertTrue(rxList == list);
                 subscribedNotified.set(true);
             }
         });
         assertTrue(subscribedNotified.get());
-        subscription.unsubscribe();
+        subscription.dispose();
+    }
+
+    @Test
+    @UiThreadTest
+    public void realmList_emittedChangesetOnSubscribe() {
+        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
+        realm.beginTransaction();
+        final RealmList<Dog> list = realm.createObject(AllTypes.class).getColumnRealmList();
+        realm.commitTransaction();
+        subscription = list.asChangesetObservable().subscribe(new Consumer<CollectionChange<RealmList<Dog>>>() {
+            @Override
+            public void accept(CollectionChange<RealmList<Dog>> change) throws Exception {
+                assertEquals(list, change.getCollection());
+                assertNull(change.getChangeset());
+                subscribedNotified.set(true);
+            }
+        });
+        assertTrue(subscribedNotified.get());
+        subscription.dispose();
     }
 
     @Test
@@ -265,17 +396,36 @@ public void dynamicRealmResults_emittedOnSubscribe() {
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
         final RealmResults<DynamicRealmObject> results = dynamicRealm.where(AllTypes.CLASS_NAME).findAll();
-        subscription = results.asObservable().subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
+        subscription = results.asFlowable().subscribe(new Consumer<RealmResults<DynamicRealmObject>>() {
             @Override
             @SuppressWarnings("ReferenceEquality")
-            public void call(RealmResults<DynamicRealmObject> rxResults) {
+            public void accept(RealmResults<DynamicRealmObject> rxResults) throws Exception {
                 assertTrue(rxResults == results);
                 subscribedNotified.set(true);
             }
         });
         assertTrue(subscribedNotified.get());
         dynamicRealm.close();
-        subscription.unsubscribe();
+        subscription.dispose();
+    }
+
+    @Test
+    @UiThreadTest
+    public void dynamicRealmResults_emittedChangesetOnSubscribe() {
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
+        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
+        final RealmResults<DynamicRealmObject> results = dynamicRealm.where(AllTypes.CLASS_NAME).findAll();
+        subscription = results.asChangesetObservable().subscribe(new Consumer<CollectionChange<RealmResults<DynamicRealmObject>>>() {
+            @Override
+            public void accept(CollectionChange<RealmResults<DynamicRealmObject>> change) throws Exception {
+                assertEquals(results, change.getCollection());
+                assertNull(change.getChangeset());
+                subscribedNotified.set(true);
+            }
+        });
+        assertTrue(subscribedNotified.get());
+        dynamicRealm.close();
+        subscription.dispose();
     }
 
     @Test
@@ -287,9 +437,9 @@ public void realmResults_emittedOnUpdate() {
         RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
         realm.commitTransaction();
 
-        subscription = results.asObservable().subscribe(new Action1<RealmResults<AllTypes>>() {
+        subscription = results.asFlowable().subscribe(new Consumer<RealmResults<AllTypes>>() {
             @Override
-            public void call(RealmResults<AllTypes> allTypes) {
+            public void accept(RealmResults<AllTypes> allTypes) throws Exception {
                 if (subscriberCalled.incrementAndGet() == 2) {
                     looperThread.testComplete();
                 }
@@ -301,6 +451,29 @@ public void call(RealmResults<AllTypes> allTypes) {
         realm.commitTransaction();
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void realmResults_emittedChangesetOnUpdate() {
+        final AtomicInteger subscriberCalled = new AtomicInteger(0);
+        Realm realm = looperThread.getRealm();
+        realm.beginTransaction();
+        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
+        realm.commitTransaction();
+
+        subscription = results.asChangesetObservable().subscribe(new Consumer<CollectionChange<RealmResults<AllTypes>>>() {
+            @Override
+            public void accept(CollectionChange<RealmResults<AllTypes>> change) throws Exception {
+                if (subscriberCalled.incrementAndGet() == 2) {
+                    assertEquals(1, change.getChangeset().getInsertions().length);
+                    looperThread.testComplete();
+                }
+            }
+        });
+        realm.beginTransaction();
+        realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+    }
+
     @Test
     @RunTestInLooperThread
     public void realmList_emittedOnUpdate() {
@@ -310,11 +483,36 @@ public void realmList_emittedOnUpdate() {
         final RealmList<Dog> list = realm.createObject(AllTypes.class).getColumnRealmList();
         realm.commitTransaction();
 
-        subscription = list.asObservable().subscribe(new Action1<RealmList<Dog>>() {
+        subscription = list.asFlowable().subscribe(new Consumer<RealmList<Dog>>() {
+            @Override
+            public void accept(RealmList<Dog> dogs) throws Exception {
+                if (subscriberCalled.incrementAndGet() == 2) {
+                    assertEquals(1, list.size());
+                    looperThread.testComplete();
+                }
+            }
+        });
+
+        realm.beginTransaction();
+        list.add(new Dog());
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void realmList_emittedChangesetOnUpdate() {
+        final AtomicInteger subscriberCalled = new AtomicInteger(0);
+        Realm realm = looperThread.getRealm();
+        realm.beginTransaction();
+        final RealmList<Dog> list = realm.createObject(AllTypes.class).getColumnRealmList();
+        realm.commitTransaction();
+
+        subscription = list.asChangesetObservable().subscribe(new Consumer<CollectionChange<RealmList<Dog>>>() {
             @Override
-            public void call(RealmList<Dog> dogs) {
+            public void accept(CollectionChange<RealmList<Dog>> change) throws Exception {
                 if (subscriberCalled.incrementAndGet() == 2) {
                     assertEquals(1, list.size());
+                    assertEquals(1, change.getChangeset().getInsertions().length);
                     looperThread.testComplete();
                 }
             }
@@ -334,9 +532,9 @@ public void dynamicRealmResults_emittedOnUpdate() {
         RealmResults<DynamicRealmObject> results = dynamicRealm.where(AllTypes.CLASS_NAME).findAll();
         dynamicRealm.commitTransaction();
 
-        subscription = results.asObservable().subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
+        subscription = results.asFlowable().subscribe(new Consumer<RealmResults<DynamicRealmObject>>() {
             @Override
-            public void call(RealmResults<DynamicRealmObject> allTypes) {
+            public void accept(RealmResults<DynamicRealmObject> dynamicRealmObjects) throws Exception {
                 if (subscriberCalled.incrementAndGet() == 2) {
                     dynamicRealm.close();
                     looperThread.testComplete();
@@ -349,21 +547,46 @@ public void call(RealmResults<DynamicRealmObject> allTypes) {
         dynamicRealm.commitTransaction();
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void dynamicRealmResults_emittedChangesetOnUpdate() {
+        final AtomicInteger subscriberCalled = new AtomicInteger(0);
+        final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.getConfiguration());
+        looperThread.closeAfterTest(dynamicRealm);
+        dynamicRealm.beginTransaction();
+        RealmResults<DynamicRealmObject> results = dynamicRealm.where(AllTypes.CLASS_NAME).findAll();
+        dynamicRealm.commitTransaction();
+
+        subscription = results.asChangesetObservable().subscribe(new Consumer<CollectionChange<RealmResults<DynamicRealmObject>>>() {
+            @Override
+            public void accept(CollectionChange<RealmResults<DynamicRealmObject>> change) throws Exception {
+                if (subscriberCalled.incrementAndGet() == 2) {
+                    assertEquals(1, change.getChangeset().getInsertions().length);
+                    looperThread.testComplete();
+                }
+            }
+        });
+
+        dynamicRealm.beginTransaction();
+        dynamicRealm.createObject(AllTypes.CLASS_NAME);
+        dynamicRealm.commitTransaction();
+    }
+
     @Test
     @UiThreadTest
     public void findAllAsync_emittedOnSubscribe() {
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
         final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
-        subscription = results.asObservable().subscribe(new Action1<RealmResults<AllTypes>>() {
+        subscription = results.asFlowable().subscribe(new Consumer<RealmResults<AllTypes>>() {
             @Override
             @SuppressWarnings("ReferenceEquality")
-            public void call(RealmResults<AllTypes> rxResults) {
+            public void accept(RealmResults<AllTypes> rxResults) throws Exception {
                 assertTrue(rxResults == results);
                 subscribedNotified.set(true);
             }
         });
         assertTrue(subscribedNotified.get());
-        subscription.unsubscribe();
+        subscription.dispose();
     }
 
     @Test
@@ -371,9 +594,9 @@ public void call(RealmResults<AllTypes> rxResults) {
     public void findAllAsync_emittedOnUpdate() {
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
         Realm realm = looperThread.getRealm();
-        subscription = realm.where(AllTypes.class).findAllAsync().asObservable().subscribe(new Action1<RealmResults<AllTypes>>() {
+        subscription = realm.where(AllTypes.class).findAllAsync().asFlowable().subscribe(new Consumer<RealmResults<AllTypes>>() {
             @Override
-            public void call(RealmResults<AllTypes> rxResults) {
+            public void accept(RealmResults<AllTypes> allTypes) throws Exception {
                 if (subscriberCalled.incrementAndGet() == 2) {
                     looperThread.testComplete();
                 }
@@ -389,15 +612,15 @@ public void call(RealmResults<AllTypes> rxResults) {
     @UiThreadTest
     public void realm_emittedOnSubscribe() {
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
-        subscription = realm.asObservable().subscribe(new Action1<Realm>() {
+        subscription = realm.asFlowable().subscribe(new Consumer<Realm>() {
             @Override
-            public void call(Realm rxRealm) {
+            public void accept(Realm rxRealm) throws Exception {
                 assertTrue(rxRealm == realm);
                 subscribedNotified.set(true);
             }
         });
         assertTrue(subscribedNotified.get());
-        subscription.unsubscribe();
+        subscription.dispose();
     }
 
     @Test
@@ -405,9 +628,9 @@ public void call(Realm rxRealm) {
     public void realm_emittedOnUpdate() {
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
         Realm realm = looperThread.getRealm();
-        subscription = realm.asObservable().subscribe(new Action1<Realm>() {
+        subscription = realm.asFlowable().subscribe(new Consumer<Realm>() {
             @Override
-            public void call(Realm rxRealm) {
+            public void accept(Realm realm) throws Exception {
                 if (subscriberCalled.incrementAndGet() == 2) {
                     looperThread.testComplete();
                 }
@@ -424,22 +647,23 @@ public void call(Realm rxRealm) {
     public void dynamicRealm_emittedOnSubscribe() {
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
-        subscription = dynamicRealm.asObservable().subscribe(new Action1<DynamicRealm>() {
+        subscription = dynamicRealm.asFlowable().subscribe(new Consumer<DynamicRealm>() {
             @Override
-            public void call(DynamicRealm rxRealm) {
+            public void accept(DynamicRealm rxRealm) throws Exception {
                 assertTrue(rxRealm == dynamicRealm);
                 subscribedNotified.set(true);
             }
-        }, new Action1<Throwable>() {
+        }, new Consumer<Throwable>() {
             @Override
-            public void call(Throwable throwable) {
+            public void accept(Throwable throwable) throws Exception {
                 throwable.printStackTrace();
+                fail();
             }
         });
 
         assertTrue(subscribedNotified.get());
         dynamicRealm.close();
-        subscription.unsubscribe();
+        subscription.dispose();
     }
 
     @Test
@@ -447,9 +671,9 @@ public void call(Throwable throwable) {
     public void dynamicRealm_emittedOnUpdate() {
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(looperThread.getConfiguration());
         final AtomicInteger subscriberCalled = new AtomicInteger(0);
-        subscription = dynamicRealm.asObservable().subscribe(new Action1<DynamicRealm>() {
+        subscription = dynamicRealm.asFlowable().subscribe(new Consumer<DynamicRealm>() {
             @Override
-            public void call(DynamicRealm rxRealm) {
+            public void accept(DynamicRealm dynamicRealm) throws Exception {
                 if (subscriberCalled.incrementAndGet() == 2) {
                     dynamicRealm.close();
                     looperThread.testComplete();
@@ -466,15 +690,15 @@ public void call(DynamicRealm rxRealm) {
     @UiThreadTest
     public void unsubscribe_sameThread() {
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
-        subscription = realm.asObservable().subscribe(new Action1<Realm>() {
+        subscription = realm.asFlowable().subscribe(new Consumer<Realm>() {
             @Override
-            public void call(Realm rxRealm) {
+            public void accept(Realm rxRealm) throws Exception {
                 assertTrue(rxRealm == realm);
                 subscribedNotified.set(true);
             }
         });
         assertEquals(1, realm.sharedRealm.realmNotifier.getListenersListSize());
-        subscription.unsubscribe();
+        subscription.dispose();
         assertEquals(0, realm.sharedRealm.realmNotifier.getListenersListSize());
     }
 
@@ -483,9 +707,9 @@ public void call(Realm rxRealm) {
     public void unsubscribe_fromOtherThread() {
         final CountDownLatch unsubscribeCompleted = new CountDownLatch(1);
         final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
-        final Subscription subscription = realm.asObservable().subscribe(new Action1<Realm>() {
+        final Disposable subscription = realm.asFlowable().subscribe(new Consumer<Realm>() {
             @Override
-            public void call(Realm rxRealm) {
+            public void accept(Realm rxRealm) throws Exception {
                 assertTrue(rxRealm == realm);
                 subscribedNotified.set(true);
             }
@@ -496,7 +720,7 @@ public void call(Realm rxRealm) {
             @Override
             public void run() {
                 try {
-                    subscription.unsubscribe();
+                    subscription.dispose();
                     fail();
                 } catch (IllegalStateException ignored) {
                 } finally {
@@ -506,7 +730,7 @@ public void run() {
         }).start();
         TestHelper.awaitOrFail(unsubscribeCompleted);
         assertEquals(1, realm.sharedRealm.realmNotifier.getListenersListSize());
-        // We cannot call subscription.unsubscribe() again, so manually close the extra Realm instance opened by
+        // We cannot call subscription.dispose() again, so manually close the extra Realm instance opened by
         // the Observable.
         realm.close();
     }
@@ -518,15 +742,16 @@ public void wrongGenericClassThrows() {
         final AllTypes obj = realm.createObject(AllTypes.class);
         realm.commitTransaction();
 
-        Observable<CyclicType> obs = obj.asObservable();
-        obs.subscribe(new Action1<CyclicType>() {
+        Flowable<CyclicType> obs = obj.asFlowable();
+        @SuppressWarnings("unused")
+        Disposable subscription = obs.subscribe(new Consumer<CyclicType>() {
             @Override
-            public void call(CyclicType cyclicType) {
+            public void accept(CyclicType cyclicType) throws Exception {
                 fail();
             }
-        }, new Action1<Throwable>() {
+        }, new Consumer<Throwable>() {
             @Override
-            public void call(Throwable ignored) {
+            public void accept(Throwable ignored) throws Exception {
             }
         });
     }
@@ -534,21 +759,22 @@ public void call(Throwable ignored) {
     @Test
     @UiThreadTest
     public void realm_closeInDoOnUnsubscribe() {
-        Observable<Realm> observable = realm.asObservable()
-                .doOnUnsubscribe(new Action0() {
+        Flowable<Realm> observable = realm.asFlowable()
+                .doOnCancel(new Action() {
                     @Override
-                    public void call() {
+                    public void run() throws Exception {
                         realm.close();
                     }
                 });
 
-        subscription = observable.subscribe(new Action1<Realm>() {
+        subscription = observable.subscribe(new Consumer<Realm>() {
             @Override
-            public void call(Realm rxRealm) {
+            public void accept(Realm realm) throws Exception {
+                assertEquals(2, Realm.getLocalInstanceCount(realm.getConfiguration()));
             }
         });
 
-        subscription.unsubscribe();
+        subscription.dispose();
         assertTrue(realm.isClosed());
     }
 
@@ -557,42 +783,42 @@ public void call(Realm rxRealm) {
     public void dynamicRealm_closeInDoOnUnsubscribe() {
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
 
-        Observable<DynamicRealm> observable = dynamicRealm.asObservable()
-                .doOnUnsubscribe(new Action0() {
+        Flowable<DynamicRealm> observable = dynamicRealm.asFlowable()
+                .doOnCancel(new Action() {
                     @Override
-                    public void call() {
+                    public void run() throws Exception {
                         dynamicRealm.close();
                     }
                 });
 
-        subscription = observable.subscribe(new Action1<DynamicRealm>() {
+        subscription = observable.subscribe(new Consumer<DynamicRealm>() {
             @Override
-            public void call(DynamicRealm rxRealm) {
+            public void accept(DynamicRealm ignored) throws Exception {
             }
         });
 
-        subscription.unsubscribe();
+        subscription.dispose();
         assertTrue(dynamicRealm.isClosed());
     }
 
     @Test
     @UiThreadTest
     public void realmResults_closeInDoOnUnsubscribe() {
-        Observable<RealmResults<AllTypes>> observable = realm.where(AllTypes.class).findAll().asObservable()
-                .doOnUnsubscribe(new Action0() {
+        Flowable<RealmResults<AllTypes>> observable = realm.where(AllTypes.class).findAll().asFlowable()
+                .doOnCancel(new Action() {
                     @Override
-                    public void call() {
+                    public void run() throws Exception {
                         realm.close();
                     }
                 });
 
-        subscription = observable.subscribe(new Action1<RealmResults<AllTypes>>() {
+        subscription = observable.subscribe(new Consumer<RealmResults<AllTypes>>() {
             @Override
-            public void call(RealmResults<AllTypes> allTypes) {
+            public void accept(RealmResults<AllTypes> ignored) throws Exception {
             }
         });
 
-        subscription.unsubscribe();
+        subscription.dispose();
         assertTrue(realm.isClosed());
     }
 
@@ -603,19 +829,19 @@ public void realmList_closeInDoOnUnsubscribe() {
         RealmList<Dog> list = realm.createObject(AllTypes.class).getColumnRealmList();
         realm.commitTransaction();
 
-        Observable<RealmList<Dog>> observable = list.asObservable().doOnUnsubscribe(new Action0() {
+        Flowable<RealmList<Dog>> observable = list.asFlowable().doOnCancel(new Action() {
             @Override
-            public void call() {
+            public void run() throws Exception {
                 realm.close();
             }
         });
-        subscription = observable.subscribe(new Action1<RealmList<Dog>>() {
+        subscription = observable.subscribe(new Consumer<RealmList<Dog>>() {
             @Override
-            public void call(RealmList<Dog> dogs) {
+            public void accept(RealmList<Dog> ignored) throws Exception {
             }
         });
 
-        subscription.unsubscribe();
+        subscription.dispose();
         assertTrue(realm.isClosed());
     }
 
@@ -624,21 +850,21 @@ public void call(RealmList<Dog> dogs) {
     public void dynamicRealmResults_closeInDoOnUnsubscribe() {
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
 
-        Observable<RealmResults<DynamicRealmObject>> observable = dynamicRealm.where(AllTypes.CLASS_NAME).findAll().asObservable()
-                .doOnUnsubscribe(new Action0() {
+        Flowable<RealmResults<DynamicRealmObject>> flowable = dynamicRealm.where(AllTypes.CLASS_NAME).findAll().asFlowable()
+                .doOnCancel(new Action() {
                     @Override
-                    public void call() {
+                    public void run() throws Exception {
                         dynamicRealm.close();
                     }
                 });
 
-        subscription = observable.subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
+        subscription = flowable.subscribe(new Consumer<RealmResults<DynamicRealmObject>>() {
             @Override
-            public void call(RealmResults<DynamicRealmObject> allTypes) {
+            public void accept(RealmResults<DynamicRealmObject> ignored) throws Exception {
             }
         });
 
-        subscription.unsubscribe();
+        subscription.dispose();
         assertTrue(dynamicRealm.isClosed());
     }
 
@@ -649,21 +875,21 @@ public void realmObject_closeInDoOnUnsubscribe() {
         realm.createObject(AllTypes.class);
         realm.commitTransaction();
 
-        Observable<AllTypes> observable = realm.where(AllTypes.class).findFirst().<AllTypes>asObservable()
-                .doOnUnsubscribe(new Action0() {
+        Flowable<AllTypes> flowable = realm.where(AllTypes.class).findFirst().<AllTypes>asFlowable()
+                .doOnCancel(new Action() {
                     @Override
-                    public void call() {
+                    public void run() throws Exception {
                         realm.close();
                     }
                 });
 
-        subscription = observable.subscribe(new Action1<AllTypes>() {
+        subscription = flowable.subscribe(new Consumer<AllTypes>() {
             @Override
-            public void call(AllTypes allTypes) {
+            public void accept(AllTypes ignored) throws Exception {
             }
         });
 
-        subscription.unsubscribe();
+        subscription.dispose();
         assertTrue(realm.isClosed());
     }
 
@@ -675,21 +901,21 @@ public void dynamicRealmObject_closeInDoOnUnsubscribe() {
         realm.commitTransaction();
         final DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
 
-        Observable<DynamicRealmObject> observable = dynamicRealm.where(AllTypes.CLASS_NAME).findFirst().<DynamicRealmObject>asObservable()
-                .doOnUnsubscribe(new Action0() {
+        Flowable<DynamicRealmObject> flowable = dynamicRealm.where(AllTypes.CLASS_NAME).findFirst().<DynamicRealmObject>asFlowable()
+                .doOnCancel(new Action() {
                     @Override
-                    public void call() {
+                    public void run() throws Exception {
                         dynamicRealm.close();
                     }
                 });
 
-        subscription = observable.subscribe(new Action1<DynamicRealmObject>() {
+        subscription = flowable.subscribe(new Consumer<DynamicRealmObject>() {
             @Override
-            public void call(DynamicRealmObject obj) {
+            public void accept(DynamicRealmObject ignored) throws Exception {
             }
         });
 
-        subscription.unsubscribe();
+        subscription.dispose();
         assertTrue(dynamicRealm.isClosed());
     }
 
@@ -697,6 +923,7 @@ public void call(DynamicRealmObject obj) {
     // waiting for results from the async API's.
     @Test
     @RunTestInLooperThread
+    @SuppressWarnings("CheckReturnValue")
     public void realmResults_gcStressTest() {
         final int TEST_SIZE = 50;
         final AtomicLong innerCounter = new AtomicLong();
@@ -710,26 +937,26 @@ public void realmResults_gcStressTest() {
 
         for (int i = 0; i < TEST_SIZE; i++) {
             // Doesn't keep a reference to the Observable.
-            realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, i).findAllAsync().asObservable()
-                    .filter(new Func1<RealmResults<AllTypes>, Boolean>() {
+            realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, i).findAllAsync().asFlowable()
+                    .filter(new Predicate<RealmResults<AllTypes>>() {
                         @Override
-                        public Boolean call(RealmResults<AllTypes> results) {
+                        public boolean test(RealmResults<AllTypes> results) throws Exception {
                             return results.isLoaded();
                         }
                     })
                     .take(1) // Unsubscribes from Realm.
-                    .subscribe(new Action1<RealmResults<AllTypes>>() {
+                    .subscribe(new Consumer<RealmResults<AllTypes>>() {
                         @Override
-                        public void call(RealmResults<AllTypes> result) {
+                        public void accept(RealmResults<AllTypes> allTypes) throws Exception {
                             // Not guaranteed, but can result in the GC of other RealmResults waiting for a result.
                             Runtime.getRuntime().gc();
                             if (innerCounter.incrementAndGet() == TEST_SIZE) {
                                 looperThread.testComplete();
                             }
                         }
-                    }, new Action1<Throwable>() {
+                    }, new Consumer<Throwable>() {
                         @Override
-                        public void call(Throwable throwable) {
+                        public void accept(Throwable throwable) throws Exception {
                             fail(throwable.toString());
                         }
                     });
@@ -740,6 +967,7 @@ public void call(Throwable throwable) {
     // waiting for results from the async API's.
     @Test
     @RunTestInLooperThread
+    @SuppressWarnings("CheckReturnValue")
     public void dynamicRealmResults_gcStressTest() {
         final int TEST_SIZE = 50;
         final AtomicLong innerCounter = new AtomicLong();
@@ -753,17 +981,17 @@ public void dynamicRealmResults_gcStressTest() {
 
         for (int i = 0; i < TEST_SIZE; i++) {
             // Doesn't keep a reference to the Observable.
-            realm.where(AllTypes.CLASS_NAME).equalTo(AllTypes.FIELD_LONG, i).findAllAsync().asObservable()
-                    .filter(new Func1<RealmResults<DynamicRealmObject>, Boolean>() {
+            realm.where(AllTypes.CLASS_NAME).equalTo(AllTypes.FIELD_LONG, i).findAllAsync().asFlowable()
+                    .filter(new Predicate<RealmResults<DynamicRealmObject>>() {
                         @Override
-                        public Boolean call(RealmResults<DynamicRealmObject> results) {
+                        public boolean test(RealmResults<DynamicRealmObject> results) throws Exception {
                             return results.isLoaded();
                         }
                     })
                     .take(1) // Unsubscribes from Realm.
-                    .subscribe(new Action1<RealmResults<DynamicRealmObject>>() {
+                    .subscribe(new Consumer<RealmResults<DynamicRealmObject>>() {
                         @Override
-                        public void call(RealmResults<DynamicRealmObject> result) {
+                        public void accept(RealmResults<DynamicRealmObject> dynamicRealmObjects) throws Exception {
                             // Not guaranteed, but can result in the GC of other RealmResults waiting for a result.
                             Runtime.getRuntime().gc();
                             if (innerCounter.incrementAndGet() == TEST_SIZE) {
@@ -771,9 +999,9 @@ public void call(RealmResults<DynamicRealmObject> result) {
                                 looperThread.testComplete();
                             }
                         }
-                    }, new Action1<Throwable>() {
+                    }, new Consumer<Throwable>() {
                         @Override
-                        public void call(Throwable throwable) {
+                        public void accept(Throwable throwable) throws Exception {
                             fail(throwable.toString());
                         }
                     });
@@ -784,6 +1012,7 @@ public void call(Throwable throwable) {
     // waiting for results from the async API's.
     @Test
     @RunTestInLooperThread
+    @SuppressWarnings("CheckReturnValue")
     public void realmObject_gcStressTest() {
         final int TEST_SIZE = 50;
         final AtomicLong innerCounter = new AtomicLong();
@@ -797,26 +1026,26 @@ public void realmObject_gcStressTest() {
 
         for (int i = 0; i < TEST_SIZE; i++) {
             // Doesn't keep a reference to the Observable.
-            realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, i).findFirstAsync().<AllTypes>asObservable()
-                    .filter(new Func1<AllTypes, Boolean>() {
+            realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, i).findFirstAsync().<AllTypes>asFlowable()
+                    .filter(new Predicate<AllTypes>() {
                         @Override
-                        public Boolean call(AllTypes obj) {
+                        public boolean test(AllTypes obj) throws Exception {
                             return obj.isLoaded();
                         }
                     })
                     .take(1) // Unsubscribes from Realm.
-                    .subscribe(new Action1<AllTypes>() {
+                    .subscribe(new Consumer<AllTypes>() {
                         @Override
-                        public void call(AllTypes result) {
+                        public void accept(AllTypes allTypes) throws Exception {
                             // Not guaranteed, but can result in the GC of other RealmResults waiting for a result.
                             Runtime.getRuntime().gc();
                             if (innerCounter.incrementAndGet() == TEST_SIZE) {
                                 looperThread.testComplete();
                             }
                         }
-                    }, new Action1<Throwable>() {
+                    }, new Consumer<Throwable>() {
                         @Override
-                        public void call(Throwable throwable) {
+                        public void accept(Throwable throwable) throws Exception {
                             fail(throwable.toString());
                         }
                     });
@@ -827,6 +1056,7 @@ public void call(Throwable throwable) {
     // waiting for results from the async API's.
     @Test
     @RunTestInLooperThread
+    @SuppressWarnings("CheckReturnValue")
     public void dynamicRealmObject_gcStressTest() {
         final int TEST_SIZE = 50;
         final AtomicLong innerCounter = new AtomicLong();
@@ -840,17 +1070,17 @@ public void dynamicRealmObject_gcStressTest() {
 
         for (int i = 0; i < TEST_SIZE; i++) {
             // Doesn't keep a reference to the Observable.
-            realm.where(AllTypes.CLASS_NAME).equalTo(AllTypes.FIELD_LONG, i).findFirstAsync().<DynamicRealmObject>asObservable()
-                    .filter(new Func1<DynamicRealmObject, Boolean>() {
+            realm.where(AllTypes.CLASS_NAME).equalTo(AllTypes.FIELD_LONG, i).findFirstAsync().<DynamicRealmObject>asFlowable()
+                    .filter(new Predicate<DynamicRealmObject>() {
                         @Override
-                        public Boolean call(DynamicRealmObject obj) {
+                        public boolean test(DynamicRealmObject obj) throws Exception {
                             return obj.isLoaded();
                         }
                     })
                     .take(1) // Unsubscribes from Realm.
-                    .subscribe(new Action1<DynamicRealmObject>() {
+                    .subscribe(new Consumer<DynamicRealmObject>() {
                         @Override
-                        public void call(DynamicRealmObject result) {
+                        public void accept(DynamicRealmObject dynamicRealmObject) throws Exception {
                             // Not guaranteed, but can result in the GC of other RealmResults waiting for a result.
                             Runtime.getRuntime().gc();
                             if (innerCounter.incrementAndGet() == TEST_SIZE) {
@@ -858,9 +1088,9 @@ public void call(DynamicRealmObject result) {
                                 looperThread.testComplete();
                             }
                         }
-                    }, new Action1<Throwable>() {
+                    }, new Consumer<Throwable>() {
                         @Override
-                        public void call(Throwable throwable) {
+                        public void accept(Throwable throwable) throws Exception {
                             fail(throwable.toString());
                         }
                     });
diff --git a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
index 06f6bd6b49..287d17bf44 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
@@ -30,6 +30,10 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.entities.AllTypes;
+import io.realm.entities.AnnotationIndexTypes;
+import io.realm.entities.StringOnly;
+import io.realm.internal.Table;
+import io.realm.internal.UncheckedRow;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -58,8 +62,12 @@
     private final static Sort[] ORDER_ASC_ASC = {Sort.ASCENDING, Sort.ASCENDING};
     private final static Sort[] ORDER_ASC_DES = {Sort.ASCENDING, Sort.DESCENDING};
 
+    private static String chars;
+    private int numberOfPermutations;
+
     private void populateRealm(Realm realm) {
         realm.beginTransaction();
+
         realm.delete(AllTypes.class);
         AllTypes object1 = realm.createObject(AllTypes.class);
         object1.setColumnLong(5);
@@ -76,9 +84,31 @@ private void populateRealm(Realm realm) {
         AllTypes object4 = realm.createObject(AllTypes.class);
         object4.setColumnLong(5);
         object4.setColumnString("Adam");
+
+        realm.delete(AnnotationIndexTypes.class);
+        AnnotationIndexTypes obj1 = realm.createObject(AnnotationIndexTypes.class);
+        obj1.setIndexLong(1);
+        obj1.setIndexInt(1);
+        obj1.setIndexString("A");
+
+        AnnotationIndexTypes obj2 = realm.createObject(AnnotationIndexTypes.class);
+        obj2.setIndexLong(2);
+        obj2.setIndexInt(1);
+        obj2.setIndexString("B");
+
+        AnnotationIndexTypes obj3 = realm.createObject(AnnotationIndexTypes.class);
+        obj3.setIndexLong(3);
+        obj3.setIndexInt(1);
+        obj3.setIndexString("C");
+
         realm.commitTransaction();
     }
 
+    private UncheckedRow getRowBySourceIndexFromAllTypesTable(long sourceRowIndex) {
+        Table table = realm.getTable(AllTypes.class);
+        return table.getUncheckedRow(sourceRowIndex);
+    }
+
     @Before
     public void setUp() {
         // Creates a Realm with the following objects:
@@ -152,19 +182,19 @@ private void checkSortTwoFieldsStringAscendingIntAscending(RealmResults<AllTypes
 
         assertEquals("Adam", results.get(0).getColumnString());
         assertEquals(4, results.get(0).getColumnLong());
-        assertEquals(0, results.getCollection().indexOf(2));
+        assertEquals(0, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(2)));
 
         assertEquals("Adam", results.get(1).getColumnString());
         assertEquals(5, results.get(1).getColumnLong());
-        assertEquals(1, results.getCollection().indexOf(0));
+        assertEquals(1, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(0)));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(5, results.get(2).getColumnLong());
-        assertEquals(2, results.getCollection().indexOf(3));
+        assertEquals(2, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(3)));
 
         assertEquals("Brian", results.get(3).getColumnString());
         assertEquals(4, results.get(3).getColumnLong());
-        assertEquals(3, results.getCollection().indexOf(1));
+        assertEquals(3, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(1)));
     }
 
     private void checkSortTwoFieldsIntString(RealmResults<AllTypes> results) {
@@ -178,19 +208,19 @@ private void checkSortTwoFieldsIntString(RealmResults<AllTypes> results) {
 
         assertEquals("Adam", results.get(0).getColumnString());
         assertEquals(4, results.get(0).getColumnLong());
-        assertEquals(0, results.getCollection().indexOf(2));
+        assertEquals(0, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(2)));
 
         assertEquals("Brian", results.get(1).getColumnString());
         assertEquals(4, results.get(1).getColumnLong());
-        assertEquals(1, results.getCollection().indexOf(1));
+        assertEquals(1, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(1)));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(5, results.get(2).getColumnLong());
-        assertEquals(2, results.getCollection().indexOf(0));
+        assertEquals(2, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(0)));
 
         assertEquals("Adam", results.get(3).getColumnString());
         assertEquals(5, results.get(3).getColumnLong());
-        assertEquals(3, results.getCollection().indexOf(3));
+        assertEquals(3, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(3)));
     }
 
     private void checkSortTwoFieldsIntAscendingStringDescending(RealmResults<AllTypes> results) {
@@ -204,19 +234,19 @@ private void checkSortTwoFieldsIntAscendingStringDescending(RealmResults<AllType
 
         assertEquals("Brian", results.get(0).getColumnString());
         assertEquals(4, results.get(0).getColumnLong());
-        assertEquals(0, results.getCollection().indexOf(1));
+        assertEquals(0, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(1)));
 
         assertEquals("Adam", results.get(1).getColumnString());
         assertEquals(4, results.get(1).getColumnLong());
-        assertEquals(1, results.getCollection().indexOf(2));
+        assertEquals(1, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(2)));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(5, results.get(2).getColumnLong());
-        assertEquals(2, results.getCollection().indexOf(0));
+        assertEquals(2, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(0)));
 
         assertEquals("Adam", results.get(3).getColumnString());
         assertEquals(5, results.get(3).getColumnLong());
-        assertEquals(3, results.getCollection().indexOf(3));
+        assertEquals(3, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(3)));
     }
 
     private void checkSortTwoFieldsStringAscendingIntDescending(RealmResults<AllTypes> results) {
@@ -230,19 +260,19 @@ private void checkSortTwoFieldsStringAscendingIntDescending(RealmResults<AllType
 
         assertEquals("Adam", results.get(0).getColumnString());
         assertEquals(5, results.get(0).getColumnLong());
-        assertEquals(0, results.getCollection().indexOf(0));
+        assertEquals(0, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(0)));
 
         assertEquals("Adam", results.get(1).getColumnString());
         assertEquals(5, results.get(1).getColumnLong());
-        assertEquals(1, results.getCollection().indexOf(3));
+        assertEquals(1, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(3)));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(4, results.get(2).getColumnLong());
-        assertEquals(2, results.getCollection().indexOf(2));
+        assertEquals(2, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(2)));
 
         assertEquals("Brian", results.get(3).getColumnString());
         assertEquals(4, results.get(3).getColumnLong());
-        assertEquals(3, results.getCollection().indexOf(1));
+        assertEquals(3, results.getOsResults().indexOf(getRowBySourceIndexFromAllTypesTable(1)));
     }
 
     @Test
@@ -516,4 +546,85 @@ public void onChange(RealmResults<AllTypes> element) {
         allTypes.setColumnDate(new Date(TEST_SIZE));
         realm.commitTransaction();
     }
+
+    @Test
+    public void sortByLongDistinctByInt() {
+        // Before sorting:
+        // (FIELD_INDEX_LONG, FIELD_INDEX_INT, FIELD_INDEX_STRING)
+        // (1, 1, "A")
+        // (2, 1, "B")
+        // (3, 1, "C")
+        // After sorting
+        // (3, 1, "C")
+        // (2, 1, "B")
+        // (1, 1, "A)
+        RealmResults<AnnotationIndexTypes> results1 = realm.where(AnnotationIndexTypes.class)
+                .findAllSorted(AnnotationIndexTypes.FIELD_INDEX_LONG, Sort.DESCENDING);
+        assertEquals(3, results1.size());
+        assertEquals(3, results1.get(0).getIndexLong());
+
+        // After distinct:
+        // (3, 1, "C")
+        RealmResults<AnnotationIndexTypes> results2 =  results1.where().distinct(AnnotationIndexTypes.FIELD_INDEX_INT);
+        assertEquals(1, results2.size());
+        assertEquals("C", results2.get(0).getIndexString());
+        assertEquals(3, results2.get(0).getIndexLong());
+    }
+
+    private void createAndTest(String str) {
+        realm.beginTransaction();
+        realm.delete(StringOnly.class);
+        for (int i = 0; i < str.length(); i++) {
+            StringOnly stringOnly = realm.createObject(StringOnly.class);
+            stringOnly.setChars(str.substring(i, i + 1));
+        }
+        realm.commitTransaction();
+        RealmResults<StringOnly> stringOnlies = realm.where(StringOnly.class).findAllSorted("chars");
+        for (int i = 0; i < chars.length(); i++) {
+            assertEquals(chars.substring(i, i + 1), stringOnlies.get(i).getChars());
+        }
+    }
+
+    // permute and swap: http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/
+    private void permute(String str, int l, int r) {
+        if (l == r) {
+            numberOfPermutations++;
+            createAndTest(str);
+        } else {
+            for (int i = l; i <= r; i++) {
+                str = swap(str,l,i);
+                permute(str, l+1, r);
+                str = swap(str,l,i);
+            }
+        }
+    }
+
+    private String swap(String a, int i, int j) {
+        char temp;
+        char[] charArray = a.toCharArray();
+        temp = charArray[i] ;
+        charArray[i] = charArray[j];
+        charArray[j] = temp;
+        return String.valueOf(charArray);
+    }
+
+    private int factorial(int n) {
+        int fac = 1;
+        for(int i = 1; i <= n; i++) {
+            fac *= i;
+        }
+        return fac;
+    }
+
+    @Test
+    public void sortCaseSensitive() {
+        chars = "'- !\"#$%&()*,./:;?_+<=>123aAbBcCxXyYzZ";
+        createAndTest(new StringBuffer(chars).reverse().toString());
+
+        // try all permutations - keep the list short
+        chars = "12aAbB";
+        numberOfPermutations = 0;
+        permute(chars, 0, chars.length()-1);
+        assertEquals(numberOfPermutations, factorial(chars.length()));
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index a688249e8c..4ef63520df 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -21,7 +21,6 @@
 import android.os.Build;
 import android.os.Looper;
 import android.support.test.InstrumentationRegistry;
-import android.util.Log;
 
 import org.junit.Assert;
 
@@ -40,22 +39,25 @@
 import java.util.Date;
 import java.util.Locale;
 import java.util.Random;
+import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 
-import io.realm.entities.AllTypes;
 import io.realm.entities.AllTypesPrimaryKey;
 import io.realm.entities.AnnotationIndexTypes;
+import io.realm.entities.BacklinksSource;
+import io.realm.entities.BacklinksTarget;
 import io.realm.entities.NullTypes;
 import io.realm.entities.PrimaryKeyAsBoxedByte;
 import io.realm.entities.PrimaryKeyAsBoxedInteger;
 import io.realm.entities.PrimaryKeyAsBoxedLong;
 import io.realm.entities.PrimaryKeyAsBoxedShort;
 import io.realm.entities.PrimaryKeyAsString;
-import io.realm.entities.StringOnly;
-import io.realm.internal.Collection;
+import io.realm.internal.OsResults;
+import io.realm.internal.OsObject;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.internal.async.RealmThreadPoolExecutor;
 import io.realm.log.LogLevel;
@@ -69,7 +71,6 @@
     public static final int VERY_SHORT_WAIT_SECS = 1;
     public static final int SHORT_WAIT_SECS = 10;
     public static final int STANDARD_WAIT_SECS = 100;
-    public static final int LONG_WAIT_SECS = 1000;
 
     private static final Charset UTF_8 = Charset.forName("UTF-8");
     private static final Random RANDOM = new Random();
@@ -89,40 +90,209 @@ public void onResult(int count) {
     }
 
     public static RealmFieldType getColumnType(Object o) {
-        if (o instanceof Boolean)
+        if (o instanceof Boolean) {
             return RealmFieldType.BOOLEAN;
-        if (o instanceof String)
+        }
+        if (o instanceof String) {
             return RealmFieldType.STRING;
-        if (o instanceof Long)
+        }
+        if (o instanceof Long) {
             return RealmFieldType.INTEGER;
-        if (o instanceof Float)
+        }
+        if (o instanceof Float) {
             return RealmFieldType.FLOAT;
-        if (o instanceof Double)
+        }
+        if (o instanceof Double) {
             return RealmFieldType.DOUBLE;
-        if (o instanceof Date)
+        }
+        if (o instanceof Date) {
             return RealmFieldType.DATE;
-        if (o instanceof byte[])
+        }
+        if (o instanceof byte[]) {
             return RealmFieldType.BINARY;
-        return RealmFieldType.UNSUPPORTED_MIXED;
+        }
+
+        throw new IllegalArgumentException("Unsupported type");
+    }
+
+    /**
+     * Appends the specified row to the end of the table. For internal testing usage only.
+     *
+     * @param table the table where the object to be added.
+     * @param values values.
+     * @return the row index of the appended row.
+     * @deprecated Remove this functions since it doesn't seem to be useful. And this function does deal with tables
+     * with primary key defined well. Primary key has to be set with `setXxxUnique` as the first thing to do after row
+     * added.
+     */
+    public static long addRowWithValues(Table table, Object... values) {
+        long rowIndex = OsObject.createRow(table);
+
+        // Checks values types.
+        int columns = (int) table.getColumnCount();
+        if (columns != values.length) {
+            throw new IllegalArgumentException("The number of value parameters (" +
+                    String.valueOf(values.length) +
+                    ") does not match the number of columns in the table (" +
+                    String.valueOf(columns) + ").");
+        }
+        RealmFieldType[] colTypes = new RealmFieldType[columns];
+        for (int columnIndex = 0; columnIndex < columns; columnIndex++) {
+            Object value = values[columnIndex];
+            RealmFieldType colType = table.getColumnType(columnIndex);
+            colTypes[columnIndex] = colType;
+            if (!colType.isValid(value)) {
+                // String representation of the provided value type.
+                String providedType;
+                if (value == null) {
+                    providedType = "null";
+                } else {
+                    providedType = value.getClass().toString();
+                }
+
+                throw new IllegalArgumentException("Invalid argument no " + String.valueOf(1 + columnIndex) +
+                        ". Expected a value compatible with column type " + colType + ", but got " + providedType + ".");
+            }
+        }
+
+        // Inserts values.
+        for (long columnIndex = 0; columnIndex < columns; columnIndex++) {
+            Object value = values[(int) columnIndex];
+            switch (colTypes[(int) columnIndex]) {
+                case BOOLEAN:
+                    if (value == null) {
+                        table.setNull(columnIndex, rowIndex, false);
+                    } else {
+                        table.setBoolean(columnIndex, rowIndex, (Boolean) value, false);
+                    }
+                    break;
+                case INTEGER:
+                    if (value == null) {
+                        table.setNull(columnIndex, rowIndex, false);
+                    } else {
+                        long longValue = ((Number) value).longValue();
+                        table.setLong(columnIndex, rowIndex, longValue, false);
+                    }
+                    break;
+                case FLOAT:
+                    if (value == null) {
+                        table.setNull(columnIndex, rowIndex, false);
+                    } else {
+                        table.setFloat(columnIndex, rowIndex, (Float) value, false);
+                    }
+                    break;
+                case DOUBLE:
+                    if (value == null) {
+                        table.setNull(columnIndex, rowIndex, false);
+                    } else {
+                        table.setDouble(columnIndex, rowIndex, (Double) value, false);
+                    }
+                    break;
+                case STRING:
+                    if (value == null) {
+                        table.setNull(columnIndex, rowIndex, false);
+                    } else {
+                        table.setString(columnIndex, rowIndex, (String) value, false);
+                    }
+                    break;
+                case DATE:
+                    if (value == null) {
+                        table.setNull(columnIndex, rowIndex, false);
+                    } else {
+                        table.setDate(columnIndex, rowIndex, (Date) value, false);
+                    }
+                    break;
+                case BINARY:
+                    if (value == null) {
+                        table.setNull(columnIndex, rowIndex, false);
+                    } else {
+                        table.setBinaryByteArray(columnIndex, rowIndex, (byte[]) value, false);
+                    }
+                    break;
+                default:
+                    throw new RuntimeException("Unexpected columnType: " + String.valueOf(colTypes[(int) columnIndex]));
+            }
+        }
+        return rowIndex;
+    }
+
+    /**
+     * Creates an empty table whose name is "temp" with 1 column of all our supported column types, currently 7 columns.
+     *
+     * @param sharedRealm A {@link SharedRealm} where the table is created.
+     * @return created table.
+     */
+    public static Table createTableWithAllColumnTypes(SharedRealm sharedRealm) {
+        return createTableWithAllColumnTypes(sharedRealm, "temp");
     }
 
     /**
-     * Creates an empty table with 1 column of all our supported column types, currently 9 columns.
+     * Creates an empty table with 1 column of all our supported column types, currently 7 columns.
      *
-     * @return
+     * @param sharedRealm A {@link SharedRealm} where the table is created.
+     * @param name name of the table.
+     * @return created table.
      */
-    public static Table getTableWithAllColumnTypes() {
-        Table t = new Table();
-
-        t.addColumn(RealmFieldType.BINARY, "binary");
-        t.addColumn(RealmFieldType.BOOLEAN, "boolean");
-        t.addColumn(RealmFieldType.DATE, "date");
-        t.addColumn(RealmFieldType.DOUBLE, "double");
-        t.addColumn(RealmFieldType.FLOAT, "float");
-        t.addColumn(RealmFieldType.INTEGER, "long");
-        t.addColumn(RealmFieldType.STRING, "string");
-
-        return t;
+    @SuppressWarnings("WeakerAccess")
+    public static Table createTableWithAllColumnTypes(SharedRealm sharedRealm,
+            @SuppressWarnings("SameParameterValue") String name) {
+        boolean wasInTransaction = sharedRealm.isInTransaction();
+        if (!wasInTransaction) {
+            sharedRealm.beginTransaction();
+        }
+        try {
+            Table t = sharedRealm.createTable(name);
+
+            t.addColumn(RealmFieldType.BINARY, "binary");
+            t.addColumn(RealmFieldType.BOOLEAN, "boolean");
+            t.addColumn(RealmFieldType.DATE, "date");
+            t.addColumn(RealmFieldType.DOUBLE, "double");
+            t.addColumn(RealmFieldType.FLOAT, "float");
+            t.addColumn(RealmFieldType.INTEGER, "long");
+            t.addColumn(RealmFieldType.STRING, "string");
+
+            return t;
+        } catch (RuntimeException e) {
+            if (!wasInTransaction) {
+                sharedRealm.cancelTransaction();
+            }
+            throw e;
+        } finally {
+            if (!wasInTransaction && sharedRealm.isInTransaction()) {
+                sharedRealm.commitTransaction();
+            }
+        }
+    }
+
+    public static Table createTable(SharedRealm sharedRealm, String name) {
+        return createTable(sharedRealm, name, null);
+    }
+
+    public interface AdditionalTableSetup {
+        void execute(Table table);
+    }
+
+    public static Table createTable(SharedRealm sharedRealm, String name, AdditionalTableSetup additionalSetup) {
+        boolean wasInTransaction = sharedRealm.isInTransaction();
+        if (!wasInTransaction) {
+            sharedRealm.beginTransaction();
+        }
+        try {
+            Table table = sharedRealm.createTable(name);
+            if (additionalSetup != null) {
+                additionalSetup.execute(table);
+            }
+            return table;
+        } catch (RuntimeException e) {
+            if (!wasInTransaction) {
+                sharedRealm.cancelTransaction();
+            }
+            throw e;
+        } finally {
+            if (!wasInTransaction && sharedRealm.isInTransaction()) {
+                sharedRealm.commitTransaction();
+            }
+        }
     }
 
     public static String streamToString(InputStream in) throws IOException {
@@ -147,19 +317,6 @@ public static InputStream stringToStream(String str) {
         return new ByteArrayInputStream(str.getBytes(UTF_8));
     }
 
-    // Creates a simple migration step in order to support null.
-    // FIXME: generate a new encrypted.realm will null support
-    public static RealmMigration prepareMigrationToNullSupportStep() {
-        RealmMigration realmMigration = new RealmMigration() {
-            @Override
-            public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
-                Table stringOnly = realm.schema.getTable(StringOnly.class);
-                stringOnly.convertColumnToNullable(stringOnly.getColumnIndex("chars"));
-            }
-        };
-        return realmMigration;
-    }
-
     // Returns a random key used by encrypted Realms.
     public static byte[] getRandomKey() {
         byte[] key = new byte[64];
@@ -167,6 +324,13 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         return key;
     }
 
+    public static String getRandomEmail() {
+        StringBuilder sb = new StringBuilder(UUID.randomUUID().toString().toLowerCase());
+        sb.append('@');
+        sb.append("androidtest.realm.io");
+        return sb.toString();
+    }
+
     // Returns a random key from the given seed. Used by encrypted Realms.
     public static byte[] getRandomKey(long seed) {
         byte[] key = new byte[64];
@@ -177,7 +341,7 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
     /**
      * Returns a RealmLogger that will fail if it is asked to log a message above a certain level.
      *
-     * @param failureLevel {@link Log} level from which the unit test will fail.
+     * @param failureLevel level at which the unit test will fail: {@see Log}.
      * @return RealmLogger implementation
      */
     public static RealmLogger getFailureLogger(final int failureLevel) {
@@ -195,11 +359,12 @@ public void log(int level, String tag, Throwable throwable, String message) {
         };
     }
 
+    // Generate a random string with only capital letters which is always a valid class/field name.
     public static String getRandomString(int length) {
         Random r = new Random();
         StringBuilder sb = new StringBuilder(length);
         for (int i = 0; i < length; i++) {
-            sb.append((char) r.nextInt(128)); // Restrict to standard ASCII chars.
+            sb.append((char) (r.nextInt(26) + 'A')); // Restrict to capital letters
         }
         return sb.toString();
     }
@@ -506,7 +671,7 @@ public static void populateTestRealmForNullTests(Realm testRealm) {
         NullTypes[] nullTypesArray = new NullTypes[3];
 
         testRealm.beginTransaction();
-        for (int i = 0; i < words.length; i++) {
+        for (int i = 0; i < 3; i++) {
             NullTypes nullTypes = new NullTypes();
             nullTypes.setId(i + 1);
             // 1 String
@@ -718,30 +883,6 @@ public static void initNullTypesTableExcludes(DynamicRealm realm, String excludi
         realm.commitTransaction();
     }
 
-    public static void populateForMultiSort(Realm typedRealm) {
-        DynamicRealm dynamicRealm = DynamicRealm.getInstance(typedRealm.getConfiguration());
-        populateForMultiSort(dynamicRealm);
-        dynamicRealm.close();
-        typedRealm.waitForChange();
-    }
-
-    public static void populateForMultiSort(DynamicRealm realm) {
-        realm.beginTransaction();
-        realm.delete(AllTypes.CLASS_NAME);
-        DynamicRealmObject object1 = realm.createObject(AllTypes.CLASS_NAME);
-        object1.setLong(AllTypes.FIELD_LONG, 5);
-        object1.setString(AllTypes.FIELD_STRING, "Adam");
-
-        DynamicRealmObject object2 = realm.createObject(AllTypes.CLASS_NAME);
-        object2.setLong(AllTypes.FIELD_LONG, 4);
-        object2.setString(AllTypes.FIELD_STRING, "Brian");
-
-        DynamicRealmObject object3 = realm.createObject(AllTypes.CLASS_NAME);
-        object3.setLong(AllTypes.FIELD_LONG, 4);
-        object3.setString(AllTypes.FIELD_STRING, "Adam");
-        realm.commitTransaction();
-    }
-
     public static void populateSimpleAllTypesPrimaryKey(Realm realm) {
         realm.beginTransaction();
         AllTypesPrimaryKey obj = new AllTypesPrimaryKey();
@@ -856,19 +997,19 @@ public static void quitLooperOrFail() {
      * This helper method is useful to create a mocked {@link RealmResults}.
      *
      * @param realm a {@link Realm} or a {@link DynamicRealm} instance.
-     * @param collection a {@link Collection} instance.
+     * @param osResults a {@link OsResults} instance.
      * @param tableClass a Class of Table.
      * @return a created {@link RealmResults} instance.
      */
     public static <T extends RealmObject> RealmResults<T> newRealmResults(
-            BaseRealm realm, Collection collection, Class<T> tableClass) {
+            BaseRealm realm, OsResults osResults, Class<T> tableClass) {
         //noinspection TryWithIdenticalCatches
         try {
             final Constructor<RealmResults> c = RealmResults.class.getDeclaredConstructor(
-                    BaseRealm.class, Collection.class, Class.class);
+                    BaseRealm.class, OsResults.class, Class.class);
             c.setAccessible(true);
             //noinspection unchecked
-            return c.newInstance(realm, collection, tableClass);
+            return c.newInstance(realm, osResults, tableClass);
         } catch (NoSuchMethodException e) {
             throw new RuntimeException(e);
         } catch (InstantiationException e) {
@@ -982,7 +1123,7 @@ public static void waitRealmThreadExecutorFinish() {
             }
             counter--;
         }
-        fail("'BaseRealm.asyncTaskExecutor' is not finished in " + counter/10 + " seconds");
+        fail("'BaseRealm.asyncTaskExecutor' is not finished in " + counter/10.0D + " seconds");
     }
 
     /**
@@ -1076,4 +1217,36 @@ public static boolean isSelinuxEnforcing() {
             return false;
         }
     }
+
+    public static void populateLinkedDataSet(Realm realm) {
+        realm.beginTransaction();
+        realm.delete(BacklinksSource.class);
+        realm.delete(BacklinksTarget.class);
+
+        BacklinksTarget target1 = realm.createObject(BacklinksTarget.class);
+        target1.setId(1);
+
+        BacklinksTarget target2 = realm.createObject(BacklinksTarget.class);
+        target2.setId(2);
+
+        BacklinksTarget target3 = realm.createObject(BacklinksTarget.class);
+        target3.setId(3);
+
+        BacklinksSource source1 = realm.createObject(BacklinksSource.class);
+        source1.setName("1");
+        source1.setChild(target1);
+        BacklinksSource source2 = realm.createObject(BacklinksSource.class);
+        source2.setName("2");
+        source2.setChild(target2);
+
+        BacklinksSource source3 = realm.createObject(BacklinksSource.class);
+        source3.setName("3");
+
+        BacklinksSource source4 = realm.createObject(BacklinksSource.class);
+        source4.setName("4");
+        source4.setChild(target1);
+
+        realm.commitTransaction();
+    }
+
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
index aa4c01fc54..86067e4bb5 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
@@ -877,7 +877,7 @@ public void onChange(Realm object) {
                     looperThread.postRunnable(new Runnable() {
                         @Override
                         public void run() {
-                            assertEquals(typebasedCommitInvocations.get(), 1);
+                            assertEquals(1, typebasedCommitInvocations.get());
                             looperThread.testComplete();
                         }
                     });
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
index 38e3f84443..8a85897b55 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AllJavaTypes.java
@@ -26,6 +26,7 @@
 import io.realm.annotations.LinkingObjects;
 import io.realm.annotations.PrimaryKey;
 
+
 public class AllJavaTypes extends RealmObject {
 
     public static final String CLASS_NAME = "AllJavaTypes";
@@ -45,12 +46,37 @@
     public static final String FIELD_OBJECT = "fieldObject";
     public static final String FIELD_LIST = "fieldList";
 
-    public static final String   INVALID_LINKED_BINARY_FIELD_FOR_DISTINCT = AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY;
-    public static final String[] INVALID_LINKED_TYPES_FIELDS_FOR_DISTINCT = new String[]{FIELD_OBJECT + "." + FIELD_BINARY, FIELD_OBJECT + "." + FIELD_OBJECT, FIELD_OBJECT + "." + FIELD_LIST};
-
-    @Ignore private String fieldIgnored;
-    @Index private String fieldString;
-    @PrimaryKey private long fieldId;
+    public static final String FIELD_STRING_LIST = "fieldStringList";
+    public static final String FIELD_BINARY_LIST = "fieldBinaryList";
+    public static final String FIELD_BOOLEAN_LIST = "fieldBooleanList";
+    public static final String FIELD_LONG_LIST = "fieldLongList";
+    public static final String FIELD_INTEGER_LIST = "fieldIntegerList";
+    public static final String FIELD_SHORT_LIST = "fieldShortList";
+    public static final String FIELD_BYTE_LIST = "fieldByteList";
+    public static final String FIELD_DOUBLE_LIST = "fieldDoubleList";
+    public static final String FIELD_FLOAT_LIST = "fieldFloatList";
+    public static final String FIELD_DATE_LIST = "fieldDateList";
+
+    public static final String FIELD_LO_OBJECT = "objectParents";
+    public static final String FIELD_LO_LIST = "listParents";
+
+    public static final String[] INVALID_FIELDS_FOR_DISTINCT
+            = new String[] {FIELD_OBJECT, FIELD_LIST, FIELD_DOUBLE, FIELD_FLOAT, FIELD_LO_OBJECT, FIELD_LO_LIST};
+
+    public static final String INVALID_LINKED_BINARY_FIELD_FOR_DISTINCT
+            = AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY;
+
+    public static final String[] INVALID_LINKED_TYPES_FIELDS_FOR_DISTINCT = new String[] {
+            FIELD_OBJECT + "." + FIELD_BINARY,
+            FIELD_OBJECT + "." + FIELD_OBJECT,
+            FIELD_OBJECT + "." + FIELD_LIST};
+
+    @Ignore
+    private String fieldIgnored;
+    @Index
+    private String fieldString;
+    @PrimaryKey
+    private long fieldId;
     private long fieldLong;
     private short fieldShort;
     private int fieldInt;
@@ -63,14 +89,24 @@
     private AllJavaTypes fieldObject;
     private RealmList<AllJavaTypes> fieldList;
 
-    @LinkingObjects("fieldObject")
+    private RealmList<String> fieldStringList;
+    private RealmList<byte[]> fieldBinaryList;
+    private RealmList<Boolean> fieldBooleanList;
+    private RealmList<Long> fieldLongList;
+    private RealmList<Integer> fieldIntegerList;
+    private RealmList<Short> fieldShortList;
+    private RealmList<Byte> fieldByteList;
+    private RealmList<Double> fieldDoubleList;
+    private RealmList<Float> fieldFloatList;
+    private RealmList<Date> fieldDateList;
+
+    @LinkingObjects(FIELD_OBJECT)
     private final RealmResults<AllJavaTypes> objectParents = null;
 
-    @LinkingObjects("fieldList")
+    @LinkingObjects(FIELD_LIST)
     private final RealmResults<AllJavaTypes> listParents = null;
 
     public AllJavaTypes() {
-
     }
 
     public AllJavaTypes(long fieldLong) {
@@ -190,6 +226,86 @@ public void setFieldList(RealmList<AllJavaTypes> columnRealmList) {
         this.fieldList = columnRealmList;
     }
 
+    public RealmList<String> getFieldStringList() {
+        return fieldStringList;
+    }
+
+    public void setFieldStringList(RealmList<String> fieldStringList) {
+        this.fieldStringList = fieldStringList;
+    }
+
+    public RealmList<byte[]> getFieldBinaryList() {
+        return fieldBinaryList;
+    }
+
+    public void setFieldBinaryList(RealmList<byte[]> fieldBinaryList) {
+        this.fieldBinaryList = fieldBinaryList;
+    }
+
+    public RealmList<Boolean> getFieldBooleanList() {
+        return fieldBooleanList;
+    }
+
+    public void setFieldBooleanList(RealmList<Boolean> fieldBooleanList) {
+        this.fieldBooleanList = fieldBooleanList;
+    }
+
+    public RealmList<Long> getFieldLongList() {
+        return fieldLongList;
+    }
+
+    public void setFieldLongList(RealmList<Long> fieldLongList) {
+        this.fieldLongList = fieldLongList;
+    }
+
+    public RealmList<Integer> getFieldIntegerList() {
+        return fieldIntegerList;
+    }
+
+    public void setFieldIntegerList(RealmList<Integer> fieldIntegerList) {
+        this.fieldIntegerList = fieldIntegerList;
+    }
+
+    public RealmList<Short> getFieldShortList() {
+        return fieldShortList;
+    }
+
+    public void setFieldShortList(RealmList<Short> fieldShortList) {
+        this.fieldShortList = fieldShortList;
+    }
+
+    public RealmList<Byte> getFieldByteList() {
+        return fieldByteList;
+    }
+
+    public void setFieldByteList(RealmList<Byte> fieldByteList) {
+        this.fieldByteList = fieldByteList;
+    }
+
+    public RealmList<Double> getFieldDoubleList() {
+        return fieldDoubleList;
+    }
+
+    public void setFieldDoubleList(RealmList<Double> fieldDoubleList) {
+        this.fieldDoubleList = fieldDoubleList;
+    }
+
+    public RealmList<Float> getFieldFloatList() {
+        return fieldFloatList;
+    }
+
+    public void setFieldFloatList(RealmList<Float> fieldFloatList) {
+        this.fieldFloatList = fieldFloatList;
+    }
+
+    public RealmList<Date> getFieldDateList() {
+        return fieldDateList;
+    }
+
+    public void setFieldDateList(RealmList<Date> fieldDateList) {
+        this.fieldDateList = fieldDateList;
+    }
+
     public RealmResults<AllJavaTypes> getObjectParents() {
         return objectParents;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypes.java
index 7d4fbba7b5..f4322445aa 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypes.java
@@ -18,6 +18,7 @@
 
 import java.util.Date;
 
+import io.realm.MutableRealmInteger;
 import io.realm.RealmList;
 import io.realm.RealmObject;
 import io.realm.annotations.Required;
@@ -32,10 +33,22 @@
     public static final String FIELD_BOOLEAN = "columnBoolean";
     public static final String FIELD_DATE = "columnDate";
     public static final String FIELD_BINARY = "columnBinary";
+    public static final String FIELD_MUTABLEREALMINTEGER = "columnMutableRealmInteger";
     public static final String FIELD_REALMOBJECT = "columnRealmObject";
     public static final String FIELD_REALMLIST = "columnRealmList";
 
-    public static final String[] INVALID_TYPES_FIELDS_FOR_DISTINCT = new String[]{FIELD_REALMOBJECT, FIELD_REALMLIST, FIELD_DOUBLE, FIELD_FLOAT};
+    public static final String FIELD_STRING_LIST = "columnStringList";
+    public static final String FIELD_BINARY_LIST = "columnBinaryList";
+    public static final String FIELD_BOOLEAN_LIST = "columnBooleanList";
+    public static final String FIELD_LONG_LIST = "columnLongList";
+    public static final String FIELD_DOUBLE_LIST = "columnDoubleList";
+    public static final String FIELD_FLOAT_LIST = "columnFloatList";
+    public static final String FIELD_DATE_LIST = "columnDateList";
+
+    public static final String[] INVALID_TYPES_FIELDS_FOR_DISTINCT
+            = new String[] {FIELD_REALMOBJECT, FIELD_REALMLIST, FIELD_DOUBLE, FIELD_FLOAT,
+            FIELD_STRING_LIST, FIELD_BINARY_LIST, FIELD_BOOLEAN_LIST, FIELD_LONG_LIST,
+            FIELD_DOUBLE_LIST, FIELD_FLOAT_LIST, FIELD_DATE_LIST};
 
     @Required
     private String columnString = "";
@@ -47,9 +60,19 @@
     private Date columnDate = new Date(0);
     @Required
     private byte[] columnBinary = new byte[0];
+
+    private final MutableRealmInteger columnMutableRealmInteger = MutableRealmInteger.ofNull();
     private Dog columnRealmObject;
     private RealmList<Dog> columnRealmList;
 
+    private RealmList<String> columnStringList;
+    private RealmList<byte[]> columnBinaryList;
+    private RealmList<Boolean> columnBooleanList;
+    private RealmList<Long> columnLongList;
+    private RealmList<Double> columnDoubleList;
+    private RealmList<Float> columnFloatList;
+    private RealmList<Date> columnDateList;
+
     public String getColumnString() {
         return columnString;
     }
@@ -102,6 +125,10 @@ public void setColumnDate(Date columnDate) {
         return columnBinary;
     }
 
+    public MutableRealmInteger getColumnRealmInteger() {
+        return columnMutableRealmInteger;
+    }
+
     public void setColumnBinary(byte[] columnBinary) {
         this.columnBinary = columnBinary;
     }
@@ -121,4 +148,60 @@ public void setColumnRealmObject(Dog columnRealmObject) {
     public void setColumnRealmList(RealmList<Dog> columnRealmList) {
         this.columnRealmList = columnRealmList;
     }
+
+    public RealmList<String> getColumnStringList() {
+        return columnStringList;
+    }
+
+    public void setColumnStringList(RealmList<String> columnStringList) {
+        this.columnStringList = columnStringList;
+    }
+
+    public RealmList<byte[]> getColumnBinaryList() {
+        return columnBinaryList;
+    }
+
+    public void setColumnBinaryList(RealmList<byte[]> columnBinaryList) {
+        this.columnBinaryList = columnBinaryList;
+    }
+
+    public RealmList<Boolean> getColumnBooleanList() {
+        return columnBooleanList;
+    }
+
+    public void setColumnBooleanList(RealmList<Boolean> columnBooleanList) {
+        this.columnBooleanList = columnBooleanList;
+    }
+
+    public RealmList<Long> getColumnLongList() {
+        return columnLongList;
+    }
+
+    public void setColumnLongList(RealmList<Long> columnLongList) {
+        this.columnLongList = columnLongList;
+    }
+
+    public RealmList<Double> getColumnDoubleList() {
+        return columnDoubleList;
+    }
+
+    public void setColumnDoubleList(RealmList<Double> columnDoubleList) {
+        this.columnDoubleList = columnDoubleList;
+    }
+
+    public RealmList<Float> getColumnFloatList() {
+        return columnFloatList;
+    }
+
+    public void setColumnFloatList(RealmList<Float> columnFloatList) {
+        this.columnFloatList = columnFloatList;
+    }
+
+    public RealmList<Date> getColumnDateList() {
+        return columnDateList;
+    }
+
+    public void setColumnDateList(RealmList<Date> columnDateList) {
+        this.columnDateList = columnDateList;
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypesPrimaryKey.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypesPrimaryKey.java
index 5965b6d031..c6bff3fda0 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypesPrimaryKey.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AllTypesPrimaryKey.java
@@ -35,6 +35,14 @@
     private RealmList<DogPrimaryKey> columnRealmList;
     private Boolean columnBoxedBoolean;
 
+    private RealmList<String> columnStringList;
+    private RealmList<byte[]> columnBinaryList;
+    private RealmList<Boolean> columnBooleanList;
+    private RealmList<Long> columnLongList;
+    private RealmList<Double> columnDoubleList;
+    private RealmList<Float> columnFloatList;
+    private RealmList<Date> columnDateList;
+
     public String getColumnString() {
         return columnString;
     }
@@ -114,4 +122,60 @@ public Boolean getColumnBoxedBoolean() {
     public void setColumnBoxedBoolean(Boolean columnBoxedBoolean) {
         this.columnBoxedBoolean = columnBoxedBoolean;
     }
+
+    public RealmList<String> getColumnStringList() {
+        return columnStringList;
+    }
+
+    public void setColumnStringList(RealmList<String> columnStringList) {
+        this.columnStringList = columnStringList;
+    }
+
+    public RealmList<byte[]> getColumnBinaryList() {
+        return columnBinaryList;
+    }
+
+    public void setColumnBinaryList(RealmList<byte[]> columnBinaryList) {
+        this.columnBinaryList = columnBinaryList;
+    }
+
+    public RealmList<Boolean> getColumnBooleanList() {
+        return columnBooleanList;
+    }
+
+    public void setColumnBooleanList(RealmList<Boolean> columnBooleanList) {
+        this.columnBooleanList = columnBooleanList;
+    }
+
+    public RealmList<Long> getColumnLongList() {
+        return columnLongList;
+    }
+
+    public void setColumnLongList(RealmList<Long> columnLongList) {
+        this.columnLongList = columnLongList;
+    }
+
+    public RealmList<Double> getColumnDoubleList() {
+        return columnDoubleList;
+    }
+
+    public void setColumnDoubleList(RealmList<Double> columnDoubleList) {
+        this.columnDoubleList = columnDoubleList;
+    }
+
+    public RealmList<Float> getColumnFloatList() {
+        return columnFloatList;
+    }
+
+    public void setColumnFloatList(RealmList<Float> columnFloatList) {
+        this.columnFloatList = columnFloatList;
+    }
+
+    public RealmList<Date> getColumnDateList() {
+        return columnDateList;
+    }
+
+    public void setColumnDateList(RealmList<Date> columnDateList) {
+        this.columnDateList = columnDateList;
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AnimalModule.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AnimalModule.java
index c26f7fd282..54a74eca05 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/AnimalModule.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AnimalModule.java
@@ -18,6 +18,6 @@
 
 import io.realm.annotations.RealmModule;
 
-@RealmModule(classes = {Dog.class, Cat.class})
+@RealmModule(classes = {Dog.class, Cat.class, DogPrimaryKey.class})
 public class AnimalModule {
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/AnnotationTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/AnnotationTypes.java
index 9926b7bce6..894804edbb 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/AnnotationTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/AnnotationTypes.java
@@ -23,6 +23,11 @@
 
 public class AnnotationTypes extends RealmObject {
 
+    public static final String FIELD_INDEX_STRING = "indexString";
+    public static final String FIELD_NOT_INDEX_STRING = "notIndexString";
+    public static final String FIELD_IGNORE_STRING= "ignoreString";
+    public static final String FIELD_TRANSIENT_STRING = "transientString";
+
     @PrimaryKey
     private long id;
 
@@ -33,6 +38,8 @@
     @Ignore
     private String ignoreString;
 
+    private transient String transientString;
+
     public long getId() {
         return id;
     }
@@ -65,5 +72,11 @@ public void setIgnoreString(String ignoreString) {
         this.ignoreString = ignoreString;
     }
 
+    public String getTransientString() {
+        return transientString;
+    }
 
+    public void setTransientString(String transientString) {
+        this.transientString = transientString;
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksSource.java b/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksSource.java
index ece9bca332..1fecbb552d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksSource.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksSource.java
@@ -19,10 +19,22 @@
 
 public class BacklinksSource extends RealmObject {
     public static final String CLASS_NAME = "BacklinksSource";
+    public static final String FIELD_NAME = "name";
     public static final String FIELD_CHILD = "child";
 
+
+    private String name;
+
     private BacklinksTarget child;
 
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
     public BacklinksTarget getChild() {
         return child;
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksTarget.java b/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksTarget.java
index da3ee95be2..ca20d5d42c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksTarget.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/BacklinksTarget.java
@@ -26,7 +26,7 @@
 
     private int id;
 
-    @LinkingObjects("child")
+    @LinkingObjects(BacklinksSource.FIELD_CHILD)
     private final RealmResults<BacklinksSource> parents = null;
 
     public int getId() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/CatOwner.java b/realm/realm-library/src/androidTest/java/io/realm/entities/CatOwner.java
index 477ee232fd..577525d0fa 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/CatOwner.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/CatOwner.java
@@ -21,6 +21,10 @@
 import io.realm.annotations.Required;
 
 public class CatOwner extends RealmObject {
+    public static final String CLASS_NAME = "CatOwner";
+    public static final String FIELD_NAME = "name";
+    public static final String FIELD_CATS = "cats";
+
     @Required
     private String name;
     private RealmList<Cat> cats;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/ConflictingFieldName.java b/realm/realm-library/src/androidTest/java/io/realm/entities/ConflictingFieldName.java
index 8592877b95..ef350a1dee 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/ConflictingFieldName.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/ConflictingFieldName.java
@@ -26,11 +26,11 @@
     private String isCompleted;
     private String currentTableVersion;
 
-    public String getRealm() {
+    public String getRealmString() {
         return realm;
     }
 
-    public void setRealm(String realm) {
+    public void setRealmString(String realm) {
         this.realm = realm;
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueOfField.java b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueOfField.java
index 0378e64817..c9e13697d3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueOfField.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueOfField.java
@@ -27,42 +27,63 @@
 public class DefaultValueOfField extends RealmObject {
 
     public static final String CLASS_NAME = "DefaultValueOfField";
-    public static String FIELD_IGNORED = "fieldIgnored";
-    public static String FIELD_RANDOM_STRING = "fieldRandomString";
-    public static String FIELD_STRING = "fieldString";
-    public static String FIELD_SHORT = "fieldShort";
-    public static String FIELD_INT = "fieldInt";
-    public static String FIELD_LONG_PRIMARY_KEY = "fieldLongPrimaryKey";
-    public static String FIELD_LONG = "fieldLong";
-    public static String FIELD_BYTE = "fieldByte";
-    public static String FIELD_FLOAT = "fieldFloat";
-    public static String FIELD_DOUBLE = "fieldDouble";
-    public static String FIELD_BOOLEAN = "fieldBoolean";
-    public static String FIELD_DATE = "fieldDate";
-    public static String FIELD_BINARY = "fieldBinary";
-    public static String FIELD_OBJECT = "fieldObject";
-    public static String FIELD_LIST = "fieldList";
-
-
-    public static String FIELD_IGNORED_DEFAULT_VALUE = "ignored";
-    public static String FIELD_STRING_DEFAULT_VALUE = "defaultString";
-    public static short FIELD_SHORT_DEFAULT_VALUE = 1234;
-    public static int FIELD_INT_DEFAULT_VALUE = 123456;
-    public static long FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE = 2L * Integer.MAX_VALUE;
-    public static long FIELD_LONG_DEFAULT_VALUE = 3L * Integer.MAX_VALUE;
-    public static byte FIELD_BYTE_DEFAULT_VALUE = 100;
-    public static float FIELD_FLOAT_DEFAULT_VALUE = 0.5f;
-    public static double FIELD_DOUBLE_DEFAULT_VALUE = 0.25;
-    public static boolean FIELD_BOOLEAN_DEFAULT_VALUE = true;
-    public static Date FIELD_DATE_DEFAULT_VALUE = new Date(1473691826000L /*2016/9/12 23:56:26 JST*/);
-    public static byte[] FIELD_BINARY_DEFAULT_VALUE = new byte[] {123, -100, 0, 2};
-    public static RandomPrimaryKey FIELD_OBJECT_DEFAULT_VALUE;
-    public static RealmList<RandomPrimaryKey> FIELD_LIST_DEFAULT_VALUE;
+    public static final String FIELD_IGNORED = "fieldIgnored";
+    public static final String FIELD_RANDOM_STRING = "fieldRandomString";
+    public static final String FIELD_STRING = "fieldString";
+    public static final String FIELD_SHORT = "fieldShort";
+    public static final String FIELD_INT = "fieldInt";
+    public static final String FIELD_LONG_PRIMARY_KEY = "fieldLongPrimaryKey";
+    public static final String FIELD_LONG = "fieldLong";
+    public static final String FIELD_BYTE = "fieldByte";
+    public static final String FIELD_FLOAT = "fieldFloat";
+    public static final String FIELD_DOUBLE = "fieldDouble";
+    public static final String FIELD_BOOLEAN = "fieldBoolean";
+    public static final String FIELD_DATE = "fieldDate";
+    public static final String FIELD_BINARY = "fieldBinary";
+    public static final String FIELD_OBJECT = "fieldObject";
+    public static final String FIELD_LIST = "fieldList";
+
+
+    public static final String FIELD_IGNORED_DEFAULT_VALUE = "ignored";
+    public static final String FIELD_STRING_DEFAULT_VALUE = "defaultString";
+    public static final short FIELD_SHORT_DEFAULT_VALUE = 1234;
+    public static final int FIELD_INT_DEFAULT_VALUE = 123456;
+    public static final long FIELD_LONG_PRIMARY_KEY_DEFAULT_VALUE = 2L * Integer.MAX_VALUE;
+    public static final long FIELD_LONG_DEFAULT_VALUE = 3L * Integer.MAX_VALUE;
+    public static final byte FIELD_BYTE_DEFAULT_VALUE = 100;
+    public static final float FIELD_FLOAT_DEFAULT_VALUE = 0.5f;
+    public static final double FIELD_DOUBLE_DEFAULT_VALUE = 0.25;
+    public static final boolean FIELD_BOOLEAN_DEFAULT_VALUE = true;
+    public static final Date FIELD_DATE_DEFAULT_VALUE = new Date(1473691826000L /*2016/9/12 23:56:26 JST*/);
+    public static final byte[] FIELD_BINARY_DEFAULT_VALUE = new byte[] {123, -100, 0, 2};
+    public static final RandomPrimaryKey FIELD_OBJECT_DEFAULT_VALUE;
+    public static final RealmList<RandomPrimaryKey> FIELD_LIST_DEFAULT_VALUE;
+    public static final RealmList<String> FIELD_STRING_LIST_DEFAULT_VALUE;
+    public static final RealmList<Boolean> FIELD_BOOLEAN_LIST_DEFAULT_VALUE;
+    public static final RealmList<byte[]> FIELD_BINARY_LIST_DEFAULT_VALUE;
+    public static final RealmList<Long> FIELD_LONG_LIST_DEFAULT_VALUE;
+    public static final RealmList<Integer> FIELD_INTEGER_LIST_DEFAULT_VALUE;
+    public static final RealmList<Short> FIELD_SHORT_LIST_DEFAULT_VALUE;
+    public static final RealmList<Byte> FIELD_BYTE_LIST_DEFAULT_VALUE;
+    public static final RealmList<Double> FIELD_DOUBLE_LIST_DEFAULT_VALUE;
+    public static final RealmList<Float> FIELD_FLOAT_LIST_DEFAULT_VALUE;
+    public static final RealmList<Date> FIELD_DATE_LIST_DEFAULT_VALUE;
 
     static {
         FIELD_OBJECT_DEFAULT_VALUE = new RandomPrimaryKey();
         FIELD_LIST_DEFAULT_VALUE = new RealmList<RandomPrimaryKey>();
         FIELD_LIST_DEFAULT_VALUE.add(new RandomPrimaryKey());
+
+        FIELD_STRING_LIST_DEFAULT_VALUE = new RealmList<>("1");
+        FIELD_BOOLEAN_LIST_DEFAULT_VALUE = new RealmList<>(true);
+        FIELD_BINARY_LIST_DEFAULT_VALUE = new RealmList<>(new byte[] {1});
+        FIELD_LONG_LIST_DEFAULT_VALUE = new RealmList<>(1L);
+        FIELD_INTEGER_LIST_DEFAULT_VALUE = new RealmList<>(1);
+        FIELD_SHORT_LIST_DEFAULT_VALUE = new RealmList<>((short) 1);
+        FIELD_BYTE_LIST_DEFAULT_VALUE = new RealmList<>((byte) 1);
+        FIELD_DOUBLE_LIST_DEFAULT_VALUE = new RealmList<>(1D);
+        FIELD_FLOAT_LIST_DEFAULT_VALUE = new RealmList<>(1F);
+        FIELD_DATE_LIST_DEFAULT_VALUE = new RealmList<>(new Date(1));
     }
 
     public static String lastRandomStringValue;
@@ -83,8 +104,18 @@
     private RandomPrimaryKey fieldObject = FIELD_OBJECT_DEFAULT_VALUE;
     private RealmList<RandomPrimaryKey> fieldList = FIELD_LIST_DEFAULT_VALUE;
 
-    public DefaultValueOfField() {
+    private RealmList<String> fieldStringList = FIELD_STRING_LIST_DEFAULT_VALUE;
+    private RealmList<byte[]> fieldBinaryList = FIELD_BINARY_LIST_DEFAULT_VALUE;
+    private RealmList<Boolean> fieldBooleanList = FIELD_BOOLEAN_LIST_DEFAULT_VALUE;
+    private RealmList<Long> fieldLongList = FIELD_LONG_LIST_DEFAULT_VALUE;
+    private RealmList<Integer> fieldIntegerList = FIELD_INTEGER_LIST_DEFAULT_VALUE;
+    private RealmList<Short> fieldShortList = FIELD_SHORT_LIST_DEFAULT_VALUE;
+    private RealmList<Byte> fieldByteList = FIELD_BYTE_LIST_DEFAULT_VALUE;
+    private RealmList<Double> fieldDoubleList = FIELD_DOUBLE_LIST_DEFAULT_VALUE;
+    private RealmList<Float> fieldFloatList = FIELD_FLOAT_LIST_DEFAULT_VALUE;
+    private RealmList<Date> fieldDateList = FIELD_DATE_LIST_DEFAULT_VALUE;
 
+    public DefaultValueOfField() {
     }
 
     public DefaultValueOfField(long fieldLong) {
@@ -210,4 +241,84 @@ public void setFieldObject(RandomPrimaryKey fieldObject) {
     public void setFieldList(RealmList<RandomPrimaryKey> fieldList) {
         this.fieldList = fieldList;
     }
+
+    public RealmList<String> getFieldStringList() {
+        return fieldStringList;
+    }
+
+    public void setFieldStringList(RealmList<String> fieldStringList) {
+        this.fieldStringList = fieldStringList;
+    }
+
+    public RealmList<byte[]> getFieldBinaryList() {
+        return fieldBinaryList;
+    }
+
+    public void setFieldBinaryList(RealmList<byte[]> fieldBinaryList) {
+        this.fieldBinaryList = fieldBinaryList;
+    }
+
+    public RealmList<Boolean> getFieldBooleanList() {
+        return fieldBooleanList;
+    }
+
+    public void setFieldBooleanList(RealmList<Boolean> fieldBooleanList) {
+        this.fieldBooleanList = fieldBooleanList;
+    }
+
+    public RealmList<Long> getFieldLongList() {
+        return fieldLongList;
+    }
+
+    public void setFieldLongList(RealmList<Long> fieldLongList) {
+        this.fieldLongList = fieldLongList;
+    }
+
+    public RealmList<Integer> getFieldIntegerList() {
+        return fieldIntegerList;
+    }
+
+    public void setFieldIntegerList(RealmList<Integer> fieldIntegerList) {
+        this.fieldIntegerList = fieldIntegerList;
+    }
+
+    public RealmList<Short> getFieldShortList() {
+        return fieldShortList;
+    }
+
+    public void setFieldShortList(RealmList<Short> fieldShortList) {
+        this.fieldShortList = fieldShortList;
+    }
+
+    public RealmList<Byte> getFieldByteList() {
+        return fieldByteList;
+    }
+
+    public void setFieldByteList(RealmList<Byte> fieldByteList) {
+        this.fieldByteList = fieldByteList;
+    }
+
+    public RealmList<Double> getFieldDoubleList() {
+        return fieldDoubleList;
+    }
+
+    public void setFieldDoubleList(RealmList<Double> fieldDoubleList) {
+        this.fieldDoubleList = fieldDoubleList;
+    }
+
+    public RealmList<Float> getFieldFloatList() {
+        return fieldFloatList;
+    }
+
+    public void setFieldFloatList(RealmList<Float> fieldFloatList) {
+        this.fieldFloatList = fieldFloatList;
+    }
+
+    public RealmList<Date> getFieldDateList() {
+        return fieldDateList;
+    }
+
+    public void setFieldDateList(RealmList<Date> fieldDateList) {
+        this.fieldDateList = fieldDateList;
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/HumanModule.java b/realm/realm-library/src/androidTest/java/io/realm/entities/HumanModule.java
index 6810f4288a..12ee54ffc8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/HumanModule.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/HumanModule.java
@@ -18,6 +18,6 @@
 
 import io.realm.annotations.RealmModule;
 
-@RealmModule(classes = {CatOwner.class})
+@RealmModule(classes = {CatOwner.class, Owner.class})
 public class HumanModule {
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/IOSAllTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/IOSAllTypes.java
index db36d1a8e9..771035d7c7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/IOSAllTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/IOSAllTypes.java
@@ -24,6 +24,8 @@
 
 public class IOSAllTypes extends RealmObject {
 
+    public final static String CLASS_NAME = "IOSAllTypes";
+
     @PrimaryKey
     private long id;
 
diff --git a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_WrongType.java b/realm/realm-library/src/androidTest/java/io/realm/entities/IndexedFields.java
similarity index 61%
rename from realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_WrongType.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/IndexedFields.java
index a09363cab4..85109c3c4c 100644
--- a/realm/realm-annotations-processor/src/test/resources/some/test/Backlinks_WrongType.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/IndexedFields.java
@@ -14,17 +14,18 @@
  * limitations under the License.
  */
 
-package some.test;
+package io.realm.entities;
 
 import io.realm.RealmObject;
-import io.realm.RealmResults;
-import io.realm.annotations.LinkingObjects;
+import io.realm.annotations.Index;
 
-public class Backlinks_WrongType extends RealmObject {
-    private int id;
 
-    // The type of the field named in the @LinkingObjects annotation must match
-    // the generic type of the annotated field
-    @LinkingObjects("child")
-    private final RealmResults<BacklinkTarget> parents = null;
+public class IndexedFields extends RealmObject {
+
+    public static final String FIELD_INDEXED_STRING = "indexedString";
+    public static final String FIELD_NON_INDEXED_STRING = "nonIndexedString";
+
+    @Index
+    public String indexedString;
+    public String nonIndexedString;
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/MutableRealmIntegerTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/MutableRealmIntegerTypes.java
new file mode 100644
index 0000000000..3448a138a3
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/MutableRealmIntegerTypes.java
@@ -0,0 +1,49 @@
+package io.realm.entities;
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import io.realm.MutableRealmInteger;
+import io.realm.RealmObject;
+import io.realm.annotations.Index;
+import io.realm.annotations.Required;
+
+
+public class MutableRealmIntegerTypes extends RealmObject {
+    public static final String CLASS_NAME = "MutableRealmIntegerTypes";
+    public static final String FIELD_NULLABLE_MUTABLEEALMINTEGER = "columnNullableMutableRealmInteger";
+    public static final String FIELD_NONNULLABLE_MUTABLEREALMINTEGER = "columnNonNullableMutableRealmInteger";
+    public static final String FIELD_INDEXED_MUTABLEREALMINTEGER = "columnIndexedMutableRealmInteger";
+
+    public final MutableRealmInteger columnNullableMutableRealmInteger = MutableRealmInteger.ofNull();
+
+    @Required
+    public final MutableRealmInteger columnNonNullableMutableRealmInteger = MutableRealmInteger.valueOf(0L);
+
+    @Index
+    public final MutableRealmInteger columnIndexedMutableRealmInteger = MutableRealmInteger.ofNull();
+
+    public MutableRealmInteger getColumnNullableMutableRealmInteger() {
+        return columnNullableMutableRealmInteger;
+    }
+
+    public MutableRealmInteger getColumnNonNullableMutableRealmInteger() {
+        return columnNonNullableMutableRealmInteger;
+    }
+
+    public MutableRealmInteger getColumnIndexedMutableRealmInteger() {
+        return columnIndexedMutableRealmInteger;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/NullTypes.java b/realm/realm-library/src/androidTest/java/io/realm/entities/NullTypes.java
index 5696701480..47842e8796 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/NullTypes.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/NullTypes.java
@@ -20,6 +20,8 @@
 
 import io.realm.RealmList;
 import io.realm.RealmObject;
+import io.realm.RealmResults;
+import io.realm.annotations.LinkingObjects;
 import io.realm.annotations.PrimaryKey;
 import io.realm.annotations.Required;
 
@@ -37,30 +39,53 @@
 // 11 Object
 public class NullTypes extends RealmObject {
 
-    public static String CLASS_NAME = "NullTypes";
-    public static String FIELD_ID = "id";
-    public static String FIELD_STRING_NOT_NULL = "fieldStringNotNull";
-    public static String FIELD_STRING_NULL = "fieldStringNull";
-    public static String FIELD_BYTES_NOT_NULL = "fieldBytesNotNull";
-    public static String FIELD_BYTES_NULL = "fieldBytesNull";
-    public static String FIELD_BOOLEAN_NOT_NULL = "fieldBooleanNotNull";
-    public static String FIELD_BOOLEAN_NULL = "fieldBooleanNull";
-    public static String FIELD_BYTE_NOT_NULL = "fieldByteNotNull";
-    public static String FIELD_BYTE_NULL = "fieldByteNull";
-    public static String FIELD_SHORT_NOT_NULL = "fieldShortNotNull";
-    public static String FIELD_SHORT_NULL = "fieldShortNull";
-    public static String FIELD_INTEGER_NOT_NULL = "fieldIntegerNotNull";
-    public static String FIELD_INTEGER_NULL = "fieldIntegerNull";
-    public static String FIELD_LONG_NOT_NULL = "fieldLongNotNull";
-    public static String FIELD_LONG_NULL = "fieldLongNull";
-    public static String FIELD_FLOAT_NOT_NULL = "fieldFloatNotNull";
-    public static String FIELD_FLOAT_NULL = "fieldFloatNull";
-    public static String FIELD_DOUBLE_NOT_NULL = "fieldDoubleNotNull";
-    public static String FIELD_DOUBLE_NULL = "fieldDoubleNull";
-    public static String FIELD_DATE_NOT_NULL = "fieldDateNotNull";
-    public static String FIELD_DATE_NULL = "fieldDateNull";
-    public static String FIELD_OBJECT_NULL = "fieldObjectNull";
-    public static String FIELD_LIST_NULL = "fieldListNull";
+    public static final String CLASS_NAME = "NullTypes";
+    public static final String FIELD_ID = "id";
+    public static final String FIELD_STRING_NOT_NULL = "fieldStringNotNull";
+    public static final String FIELD_STRING_NULL = "fieldStringNull";
+    public static final String FIELD_BYTES_NOT_NULL = "fieldBytesNotNull";
+    public static final String FIELD_BYTES_NULL = "fieldBytesNull";
+    public static final String FIELD_BOOLEAN_NOT_NULL = "fieldBooleanNotNull";
+    public static final String FIELD_BOOLEAN_NULL = "fieldBooleanNull";
+    public static final String FIELD_BYTE_NOT_NULL = "fieldByteNotNull";
+    public static final String FIELD_BYTE_NULL = "fieldByteNull";
+    public static final String FIELD_SHORT_NOT_NULL = "fieldShortNotNull";
+    public static final String FIELD_SHORT_NULL = "fieldShortNull";
+    public static final String FIELD_INTEGER_NOT_NULL = "fieldIntegerNotNull";
+    public static final String FIELD_INTEGER_NULL = "fieldIntegerNull";
+    public static final String FIELD_LONG_NOT_NULL = "fieldLongNotNull";
+    public static final String FIELD_LONG_NULL = "fieldLongNull";
+    public static final String FIELD_FLOAT_NOT_NULL = "fieldFloatNotNull";
+    public static final String FIELD_FLOAT_NULL = "fieldFloatNull";
+    public static final String FIELD_DOUBLE_NOT_NULL = "fieldDoubleNotNull";
+    public static final String FIELD_DOUBLE_NULL = "fieldDoubleNull";
+    public static final String FIELD_DATE_NOT_NULL = "fieldDateNotNull";
+    public static final String FIELD_DATE_NULL = "fieldDateNull";
+    public static final String FIELD_OBJECT_NULL = "fieldObjectNull";
+    public static final String FIELD_LIST_NULL = "fieldListNull";
+    public static final String FIELD_LO_OBJECT = "objectParents";
+    public static final String FIELD_LO_LIST = "listParents";
+
+    public static final String FIELD_STRING_LIST_NOT_NULL = "fieldStringListNotNull";
+    public static final String FIELD_STRING_LIST_NULL = "fieldStringListNull";
+    public static final String FIELD_BINARY_LIST_NOT_NULL = "fieldBinaryListNotNull";
+    public static final String FIELD_BINARY_LIST_NULL = "fieldBinaryListNull";
+    public static final String FIELD_BOOLEAN_LIST_NOT_NULL = "fieldBooleanListNotNull";
+    public static final String FIELD_BOOLEAN_LIST_NULL = "fieldBooleanListNull";
+    public static final String FIELD_LONG_LIST_NOT_NULL = "fieldLongListNotNull";
+    public static final String FIELD_LONG_LIST_NULL = "fieldLongListNull";
+    public static final String FIELD_INTEGER_LIST_NOT_NULL = "fieldIntegerListNotNull";
+    public static final String FIELD_INTEGER_LIST_NULL = "fieldIntegerListNull";
+    public static final String FIELD_SHORT_LIST_NOT_NULL = "fieldShortListNotNull";
+    public static final String FIELD_SHORT_LIST_NULL = "fieldShortListNull";
+    public static final String FIELD_BYTE_LIST_NOT_NULL = "fieldByteListNotNull";
+    public static final String FIELD_BYTE_LIST_NULL = "fieldByteListNull";
+    public static final String FIELD_DOUBLE_LIST_NOT_NULL = "fieldDoubleListNotNull";
+    public static final String FIELD_DOUBLE_LIST_NULL = "fieldDoubleListNull";
+    public static final String FIELD_FLOAT_LIST_NOT_NULL = "fieldFloatListNotNull";
+    public static final String FIELD_FLOAT_LIST_NULL = "fieldFloatListNull";
+    public static final String FIELD_DATE_LIST_NOT_NULL = "fieldDateListNotNull";
+    public static final String FIELD_DATE_LIST_NULL = "fieldDateListNull";
 
     @PrimaryKey
     private int id;
@@ -107,8 +132,57 @@
 
     private NullTypes fieldObjectNull;
 
+    // never nullable
     private RealmList<NullTypes> fieldListNull;
 
+    @Required
+    private RealmList<String> fieldStringListNotNull;
+    private RealmList<String> fieldStringListNull;
+
+    @Required
+    private RealmList<byte[]> fieldBinaryListNotNull;
+    private RealmList<byte[]> fieldBinaryListNull;
+
+    @Required
+    private RealmList<Boolean> fieldBooleanListNotNull;
+    private RealmList<Boolean> fieldBooleanListNull;
+
+    @Required
+    private RealmList<Long> fieldLongListNotNull;
+    private RealmList<Long> fieldLongListNull;
+
+    @Required
+    private RealmList<Integer> fieldIntegerListNotNull;
+    private RealmList<Integer> fieldIntegerListNull;
+
+    @Required
+    private RealmList<Short> fieldShortListNotNull;
+    private RealmList<Short> fieldShortListNull;
+
+    @Required
+    private RealmList<Byte> fieldByteListNotNull;
+    private RealmList<Byte> fieldByteListNull;
+
+    @Required
+    private RealmList<Double> fieldDoubleListNotNull;
+    private RealmList<Double> fieldDoubleListNull;
+
+    @Required
+    private RealmList<Float> fieldFloatListNotNull;
+    private RealmList<Float> fieldFloatListNull;
+
+    @Required
+    private RealmList<Date> fieldDateListNotNull;
+    private RealmList<Date> fieldDateListNull;
+
+    // never nullable
+    @LinkingObjects(FIELD_OBJECT_NULL)
+    private final RealmResults<NullTypes> objectParents = null;
+
+    // never nullable
+    @LinkingObjects(FIELD_LIST_NULL)
+    private final RealmResults<NullTypes> listParents = null;
+
     public int getId() {
         return id;
     }
@@ -292,4 +366,172 @@ public void setFieldObjectNull(NullTypes fieldObjectNull) {
     public void setFieldListNull(RealmList<NullTypes> fieldListNull) {
         this.fieldListNull = fieldListNull;
     }
+
+    public RealmResults<NullTypes> getObjectParents() {
+        return objectParents;
+    }
+
+    public RealmResults<NullTypes> getListParents() {
+        return listParents;
+    }
+
+    public RealmList<String> getFieldStringListNotNull() {
+        return fieldStringListNotNull;
+    }
+
+    public void setFieldStringListNotNull(RealmList<String> fieldStringListNotNull) {
+        this.fieldStringListNotNull = fieldStringListNotNull;
+    }
+
+    public RealmList<String> getFieldStringListNull() {
+        return fieldStringListNull;
+    }
+
+    public void setFieldStringListNull(RealmList<String> fieldStringListNull) {
+        this.fieldStringListNull = fieldStringListNull;
+    }
+
+    public RealmList<byte[]> getFieldBinaryListNotNull() {
+        return fieldBinaryListNotNull;
+    }
+
+    public void setFieldBinaryListNotNull(RealmList<byte[]> fieldBinaryListNotNull) {
+        this.fieldBinaryListNotNull = fieldBinaryListNotNull;
+    }
+
+    public RealmList<byte[]> getFieldBinaryListNull() {
+        return fieldBinaryListNull;
+    }
+
+    public void setFieldBinaryListNull(RealmList<byte[]> fieldBinaryListNull) {
+        this.fieldBinaryListNull = fieldBinaryListNull;
+    }
+
+    public RealmList<Boolean> getFieldBooleanListNotNull() {
+        return fieldBooleanListNotNull;
+    }
+
+    public void setFieldBooleanListNotNull(RealmList<Boolean> fieldBooleanListNotNull) {
+        this.fieldBooleanListNotNull = fieldBooleanListNotNull;
+    }
+
+    public RealmList<Boolean> getFieldBooleanListNull() {
+        return fieldBooleanListNull;
+    }
+
+    public void setFieldBooleanListNull(RealmList<Boolean> fieldBooleanListNull) {
+        this.fieldBooleanListNull = fieldBooleanListNull;
+    }
+
+    public RealmList<Long> getFieldLongListNotNull() {
+        return fieldLongListNotNull;
+    }
+
+    public void setFieldLongListNotNull(RealmList<Long> fieldLongListNotNull) {
+        this.fieldLongListNotNull = fieldLongListNotNull;
+    }
+
+    public RealmList<Long> getFieldLongListNull() {
+        return fieldLongListNull;
+    }
+
+    public void setFieldLongListNull(RealmList<Long> fieldLongListNull) {
+        this.fieldLongListNull = fieldLongListNull;
+    }
+
+    public RealmList<Integer> getFieldIntegerListNotNull() {
+        return fieldIntegerListNotNull;
+    }
+
+    public void setFieldIntegerListNotNull(RealmList<Integer> fieldIntegerListNotNull) {
+        this.fieldIntegerListNotNull = fieldIntegerListNotNull;
+    }
+
+    public RealmList<Integer> getFieldIntegerListNull() {
+        return fieldIntegerListNull;
+    }
+
+    public void setFieldIntegerListNull(RealmList<Integer> fieldIntegerListNull) {
+        this.fieldIntegerListNull = fieldIntegerListNull;
+    }
+
+    public RealmList<Short> getFieldShortListNotNull() {
+        return fieldShortListNotNull;
+    }
+
+    public void setFieldShortListNotNull(RealmList<Short> fieldShortListNotNull) {
+        this.fieldShortListNotNull = fieldShortListNotNull;
+    }
+
+    public RealmList<Short> getFieldShortListNull() {
+        return fieldShortListNull;
+    }
+
+    public void setFieldShortListNull(RealmList<Short> fieldShortListNull) {
+        this.fieldShortListNull = fieldShortListNull;
+    }
+
+    public RealmList<Byte> getFieldByteListNotNull() {
+        return fieldByteListNotNull;
+    }
+
+    public void setFieldByteListNotNull(RealmList<Byte> fieldByteListNotNull) {
+        this.fieldByteListNotNull = fieldByteListNotNull;
+    }
+
+    public RealmList<Byte> getFieldByteListNull() {
+        return fieldByteListNull;
+    }
+
+    public void setFieldByteListNull(RealmList<Byte> fieldByteListNull) {
+        this.fieldByteListNull = fieldByteListNull;
+    }
+
+    public RealmList<Double> getFieldDoubleListNotNull() {
+        return fieldDoubleListNotNull;
+    }
+
+    public void setFieldDoubleListNotNull(RealmList<Double> fieldDoubleListNotNull) {
+        this.fieldDoubleListNotNull = fieldDoubleListNotNull;
+    }
+
+    public RealmList<Double> getFieldDoubleListNull() {
+        return fieldDoubleListNull;
+    }
+
+    public void setFieldDoubleListNull(RealmList<Double> fieldDoubleListNull) {
+        this.fieldDoubleListNull = fieldDoubleListNull;
+    }
+
+    public RealmList<Float> getFieldFloatListNotNull() {
+        return fieldFloatListNotNull;
+    }
+
+    public void setFieldFloatListNotNull(RealmList<Float> fieldFloatListNotNull) {
+        this.fieldFloatListNotNull = fieldFloatListNotNull;
+    }
+
+    public RealmList<Float> getFieldFloatListNull() {
+        return fieldFloatListNull;
+    }
+
+    public void setFieldFloatListNull(RealmList<Float> fieldFloatListNull) {
+        this.fieldFloatListNull = fieldFloatListNull;
+    }
+
+    public RealmList<Date> getFieldDateListNotNull() {
+        return fieldDateListNotNull;
+    }
+
+    public void setFieldDateListNotNull(RealmList<Date> fieldDateListNotNull) {
+        this.fieldDateListNotNull = fieldDateListNotNull;
+    }
+
+    public RealmList<Date> getFieldDateListNull() {
+        return fieldDateListNull;
+    }
+
+    public void setFieldDateListNull(RealmList<Date> fieldDateListNull) {
+        this.fieldDateListNull = fieldDateListNull;
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/Object4957.java b/realm/realm-library/src/androidTest/java/io/realm/entities/Object4957.java
new file mode 100644
index 0000000000..5016d0c3d1
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/Object4957.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmList;
+import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
+
+// Object to reproduce issue https://github.com/realm/realm-java/issues/4957 .
+public class Object4957 extends RealmObject {
+    @PrimaryKey
+    private int id;
+    // Don't change the order of the field declaration! The order is the key to reproduce the original bug.
+    private Object4957 child;
+    private RealmList<Object4957> childList = new RealmList<Object4957>();
+
+    public void setId(int id) {
+        this.id = id;
+    }
+
+    public int getId() {
+        return id;
+    }
+
+    public void setChild(Object4957 child) {
+        this.child = child;
+    }
+
+    public RealmList<Object4957> getChildList() {
+        return childList;
+    }
+
+    public Object4957 getChild() {
+        return child;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsInteger.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsInteger.java
index c54aa7b6fa..acc955ed01 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsInteger.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsInteger.java
@@ -23,6 +23,7 @@
 
     public static final String CLASS_NAME = "PrimaryKeyAsInteger";
     public static final String FIELD_ID = "id";
+    public static final String FIELD_NAME= "name";
 
     @PrimaryKey
     private int id;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
index 5e70b431b8..099977dcd9 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
@@ -24,6 +24,7 @@
 
     public static final String CLASS_NAME = "PrimaryKeyAsString";
     public static final String FIELD_PRIMARY_KEY = "name";
+    public static final String FIELD_ID = "id";
 
     @PrimaryKey
     private String name;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/StringOnly.java b/realm/realm-library/src/androidTest/java/io/realm/entities/StringOnly.java
index b4183425c9..88bd0419cc 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/StringOnly.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/StringOnly.java
@@ -19,6 +19,10 @@
 import io.realm.RealmObject;
 
 public class StringOnly extends RealmObject {
+
+    public static final String CLASS_NAME = "StringOnly";
+    public static final String FIELD_CHARS = "chars";
+
     private String chars;
 
     public String getChars() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/StringOnlyReadOnly.java b/realm/realm-library/src/androidTest/java/io/realm/entities/StringOnlyReadOnly.java
new file mode 100644
index 0000000000..af886fc2cb
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/StringOnlyReadOnly.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2014 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+
+
+/**
+ * WARNING: This class is used by some `readOnly()` tests. Modifying this class will cause these to fail.
+ * If this class is modified then `/assets/readonly.realm` must be re-created as well.
+ */
+public class StringOnlyReadOnly extends RealmObject {
+    private String chars;
+
+    public String getChars() {
+        return chars;
+    }
+
+    public void setChars(String chars) {
+        this.chars = chars;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/StringOnlyRequired.java b/realm/realm-library/src/androidTest/java/io/realm/entities/StringOnlyRequired.java
new file mode 100644
index 0000000000..df6200f92e
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/StringOnlyRequired.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.Required;
+
+// This class is used for the pre-null testing. Before 0.83.0, without nullable support, String is required by default.
+// To use the Realm file created before 0.83.0 without migration, @Required has to be added to the String field.
+public class StringOnlyRequired extends RealmObject {
+    @Required
+    private String chars;
+
+    public String getChars() {
+        return chars;
+    }
+
+    public void setChars(String chars) {
+        this.chars = chars;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/Thread.java b/realm/realm-library/src/androidTest/java/io/realm/entities/Thread.java
index 8bad4e5472..5509f2f8bb 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/Thread.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/Thread.java
@@ -18,6 +18,7 @@
 
 import io.realm.RealmObject;
 
+@SuppressWarnings("JavaLangClash")
 public class Thread extends RealmObject {
     private String name;
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/String.java b/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/String.java
index 7b57935d58..e6d10a2709 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/String.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/conflict/String.java
@@ -19,6 +19,7 @@
 import io.realm.RealmList;
 import io.realm.RealmObject;
 
+@SuppressWarnings("JavaLangClash")
 public class String extends RealmObject {
     public String str;
     public RealmList<String> strList;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/instrumentation/package-info.java b/realm/realm-library/src/androidTest/java/io/realm/instrumentation/package-info.java
new file mode 100644
index 0000000000..cfc56a563a
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/instrumentation/package-info.java
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+@javax.annotation.ParametersAreNonnullByDefault
+package io.realm.instrumentation;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/AndroidCapabilitiesTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/AndroidCapabilitiesTest.java
new file mode 100644
index 0000000000..b3ca055a6d
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/AndroidCapabilitiesTest.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.internal.android.AndroidCapabilities;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+@RunWith(AndroidJUnit4.class)
+public class AndroidCapabilitiesTest {
+
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    @Test
+    @RunTestInLooperThread()
+    public void emulateMainThread_false() {
+        assertFalse(new AndroidCapabilities().isMainThread());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void emulateMainThread_true() {
+        assertTrue(new AndroidCapabilities().isMainThread());
+        looperThread.testComplete();
+    }
+
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
deleted file mode 100644
index 83ca6db974..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
+++ /dev/null
@@ -1,532 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-
-import android.support.test.runner.AndroidJUnit4;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.ExpectedException;
-import org.junit.runner.RunWith;
-
-import java.lang.ref.WeakReference;
-import java.util.ConcurrentModificationException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import io.realm.RealmChangeListener;
-import io.realm.RealmConfiguration;
-import io.realm.RealmFieldType;
-import io.realm.TestHelper;
-import io.realm.rule.RunInLooperThread;
-import io.realm.rule.RunTestInLooperThread;
-import io.realm.rule.TestRealmConfigurationFactory;
-
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
-import static junit.framework.Assert.assertTrue;
-import static junit.framework.Assert.fail;
-
-
-@RunWith(AndroidJUnit4.class)
-public class CollectionTests {
-    @Rule
-    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
-    @Rule
-    public final ExpectedException thrown = ExpectedException.none();
-    @Rule
-    public final RunInLooperThread looperThread = new RunInLooperThread();
-
-    private RealmConfiguration config;
-    private SharedRealm sharedRealm;
-    private Table table;
-
-    @Before
-    public void setUp() {
-        config = configFactory.createConfiguration();
-        sharedRealm = getSharedRealm();
-        populateData();
-    }
-
-    @After
-    public void tearDown() {
-        sharedRealm.close();
-    }
-
-    private SharedRealm getSharedRealm() {
-        return SharedRealm.getInstance(config, null, true);
-    }
-
-    private void populateData() {
-        sharedRealm.beginTransaction();
-        table = sharedRealm.getTable("test_table");
-        // Specify the column types and names
-        long columnIdx = table.addColumn(RealmFieldType.STRING, "firstName");
-        table.addSearchIndex(columnIdx);
-        table.addColumn(RealmFieldType.STRING, "lastName");
-        table.addColumn(RealmFieldType.INTEGER, "age");
-
-        // Add data to the table
-        long row = table.addEmptyRow();
-        table.setString(0, row, "John", false);
-        table.setString(1, row, "Lee", false);
-        table.setLong(2, row, 4, false);
-
-        row = table.addEmptyRow();
-        table.setString(0, row, "John", false);
-        table.setString(1, row, "Anderson", false);
-        table.setLong(2, row, 3, false);
-
-        row = table.addEmptyRow();
-        table.setString(0, row, "Erik", false);
-        table.setString(1, row, "Lee", false);
-        table.setLong(2, row, 1, false);
-
-        row = table.addEmptyRow();
-        table.setString(0, row, "Henry", false);
-        table.setString(1, row, "Anderson", false);
-        table.setLong(2, row, 1, false);
-        sharedRealm.commitTransaction();
-    }
-
-    private void addRowAsync() {
-        final CountDownLatch latch = new CountDownLatch(1);
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                SharedRealm sharedRealm = getSharedRealm();
-                addRow(sharedRealm);
-                sharedRealm.close();
-                latch.countDown();
-            }
-        }).start();
-        TestHelper.awaitOrFail(latch);
-    }
-
-    private void addRow(SharedRealm sharedRealm) {
-        sharedRealm.beginTransaction();
-        table = sharedRealm.getTable("test_table");
-        table.addEmptyRow();
-        sharedRealm.commitTransaction();
-    }
-
-    @Test
-    public void constructor_withDistinct() {
-        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(table, "firstName");
-        Collection collection = new Collection(sharedRealm, table.where(), null, distinctDescriptor);
-
-        assertEquals(collection.size(), 3);
-        assertEquals(collection.getUncheckedRow(0).getString(0), "John");
-        assertEquals(collection.getUncheckedRow(1).getString(0), "Erik");
-        assertEquals(collection.getUncheckedRow(2).getString(0), "Henry");
-    }
-
-
-    @Test(expected = UnsupportedOperationException.class)
-    public void constructor_queryIsValidated() {
-        // Collection's constructor should call TableQuery.validateQuery()
-        new Collection(sharedRealm, table.where().or());
-    }
-
-    @Test
-    public void constructor_queryOnDeletedTable() {
-        TableQuery query = table.where();
-        sharedRealm.beginTransaction();
-        sharedRealm.removeTable(table.getName());
-        sharedRealm.commitTransaction();
-        // Query should be checked before creating OS Results.
-        thrown.expect(IllegalStateException.class);
-        new Collection(sharedRealm, query);
-    }
-
-    @Test
-    public void size() {
-        Collection collection = new Collection(sharedRealm, table.where());
-        assertEquals(4, collection.size());
-    }
-
-    @Test
-    public void where() {
-        Collection collection = new Collection(sharedRealm, table.where());
-        Collection collection2 = new Collection(sharedRealm, collection.where().equalTo(new long[]{0}, "John"));
-        Collection collection3 =new Collection(sharedRealm, collection2.where().equalTo(new long[]{1}, "Anderson"));
-
-        // A new native Results should be created.
-        assertTrue(collection.getNativePtr() != collection2.getNativePtr());
-        assertTrue(collection2.getNativePtr() != collection3.getNativePtr());
-
-        assertEquals(4, collection.size());
-        assertEquals(2, collection2.size());
-        assertEquals(1, collection3.size());
-    }
-
-    @Test
-    public void sort() {
-        Collection collection = new Collection(sharedRealm, table.where().greaterThan(new long[]{2}, 1));
-        SortDescriptor sortDescriptor = new SortDescriptor(table, new long[] {2});
-
-        Collection collection2 = collection.sort(sortDescriptor);
-
-        // A new native Results should be created.
-        assertTrue(collection.getNativePtr() != collection2.getNativePtr());
-        assertEquals(2, collection.size());
-        assertEquals(2, collection2.size());
-
-        assertEquals(collection2.getUncheckedRow(0).getLong(2), 3);
-        assertEquals(collection2.getUncheckedRow(1).getLong(2), 4);
-    }
-
-    @Test
-    public void clear() {
-        assertEquals(4, table.size());
-        Collection collection = new Collection(sharedRealm, table.where());
-        sharedRealm.beginTransaction();
-        collection.clear();
-        sharedRealm.commitTransaction();
-        assertEquals(0, table.size());
-    }
-
-    @Test
-    public void contains() {
-        Collection collection = new Collection(sharedRealm, table.where());
-        UncheckedRow row = table.getUncheckedRow(0);
-        assertTrue(collection.contains(row));
-    }
-
-    @Test
-    public void indexOf() {
-        SortDescriptor sortDescriptor = new SortDescriptor(table, new long[] {2});
-
-        Collection collection = new Collection(sharedRealm, table.where(), sortDescriptor);
-        UncheckedRow row = table.getUncheckedRow(0);
-        assertEquals(3, collection.indexOf(row));
-    }
-
-    @Test
-    public void indexOf_long() {
-        SortDescriptor sortDescriptor = new SortDescriptor(table, new long[] {2});
-
-        Collection collection = new Collection(sharedRealm, table.where(), sortDescriptor);
-        assertEquals(3, collection.indexOf(0));
-    }
-
-    @Test
-    public void distinct() {
-        Collection collection = new Collection(sharedRealm, table.where().lessThan(new long[]{2}, 4));
-
-        SortDescriptor distinctDescriptor = new SortDescriptor(table, new long[] {2});
-        Collection collection2 = collection.distinct(distinctDescriptor);
-
-        // A new native Results should be created.
-        assertTrue(collection.getNativePtr() != collection2.getNativePtr());
-        assertEquals(3, collection.size());
-        assertEquals(2, collection2.size());
-
-        assertEquals(3, collection2.getUncheckedRow(0).getLong(2));
-        assertEquals(1, collection2.getUncheckedRow(1).getLong(2));
-    }
-
-    // 1. Create a results and add listener.
-    // 2. Query results should be returned in the next loop.
-    @Test
-    @RunTestInLooperThread
-    public void addListener_shouldBeCalledToReturnTheQueryResults() {
-        final SharedRealm sharedRealm = getSharedRealm();
-        Table table = sharedRealm.getTable("test_table");
-
-        final Collection collection = new Collection(sharedRealm, table.where());
-        looperThread.keepStrongReference(collection);
-        collection.addListener(collection, new RealmChangeListener<Collection>() {
-            @Override
-            public void onChange(Collection collection1) {
-                assertEquals(collection, collection1);
-                assertEquals(4, collection1.size());
-                sharedRealm.close();
-                looperThread.testComplete();
-            }
-        });
-    }
-
-    // 1. Create a results and add listener on a non-looper thread.
-    // 2. Query results should be returned when refresh() called.
-    @Test
-    public void addListener_shouldBeCalledWhenRefreshToReturnTheQueryResults() {
-        final AtomicBoolean onChangeCalled = new AtomicBoolean(false);
-        final SharedRealm sharedRealm = getSharedRealm();
-        Table table = sharedRealm.getTable("test_table");
-
-        final Collection collection = new Collection(sharedRealm, table.where());
-        collection.addListener(collection, new RealmChangeListener<Collection>() {
-            @Override
-            public void onChange(Collection collection1) {
-                assertEquals(collection, collection1);
-                assertEquals(4, collection1.size());
-                sharedRealm.close();
-                onChangeCalled.set(true);
-            }
-        });
-        sharedRealm.refresh();
-        assertTrue(onChangeCalled.get());
-    }
-
-    @Test
-    public void addListener_shouldBeCalledWhenRefreshAfterLocalCommit() {
-        final CountDownLatch latch = new CountDownLatch(2);
-        final Collection collection = new Collection(sharedRealm, table.where());
-        assertEquals(4, collection.size()); // See `populateData()`
-        collection.addListener(collection, new RealmChangeListener<Collection>() {
-            @Override
-            public void onChange(Collection element) {
-                if (latch.getCount() == 2) {
-                    // triggered by beginTransaction
-                    assertEquals(4, collection.size());
-                } else if (latch.getCount() == 1) {
-                    // triggered by refresh
-                    assertEquals(5, collection.size());
-                } else {
-                    fail();
-                }
-                latch.countDown();
-            }
-        });
-        sharedRealm.beginTransaction();
-        table.addEmptyRow();
-        sharedRealm.commitTransaction();
-        sharedRealm.refresh();
-        TestHelper.awaitOrFail(latch);
-    }
-
-    // Local commit will trigger the listener first when beginTransaction gets called then again when call refresh.
-    @Test
-    public void addListener_triggeredByRefresh() {
-        final CountDownLatch latch = new CountDownLatch(1);
-        Collection collection = new Collection(sharedRealm, table.where());
-        collection.size();
-        collection.addListener(collection, new RealmChangeListener<Collection>() {
-            @Override
-            public void onChange(Collection element) {
-                assertEquals(1, latch.getCount());
-                latch.countDown();
-            }
-        });
-
-        addRowAsync();
-
-        sharedRealm.waitForChange();
-        sharedRealm.refresh();
-        TestHelper.awaitOrFail(latch);
-    }
-
-    @Test
-    @RunTestInLooperThread
-    public void addListener_queryNotReturned() {
-        final SharedRealm sharedRealm = getSharedRealm();
-        Table table = sharedRealm.getTable("test_table");
-
-        final Collection collection = new Collection(sharedRealm, table.where());
-        looperThread.keepStrongReference(collection);
-        collection.addListener(collection, new RealmChangeListener<Collection>() {
-            @Override
-            public void onChange(Collection collection1) {
-                assertEquals(collection, collection1);
-                assertEquals(5, collection1.size());
-                sharedRealm.close();
-                looperThread.testComplete();
-            }
-        });
-
-        addRowAsync();
-    }
-
-    @Test
-    @RunTestInLooperThread
-    public void addListener_queryReturned() {
-        final SharedRealm sharedRealm = getSharedRealm();
-        Table table = sharedRealm.getTable("test_table");
-
-        final Collection collection = new Collection(sharedRealm, table.where());
-        looperThread.keepStrongReference(collection);
-        assertEquals(collection.size(), 4); // Trigger the query to run.
-        collection.addListener(collection, new RealmChangeListener<Collection>() {
-            @Override
-            public void onChange(Collection collection1) {
-                assertEquals(collection, collection1);
-                assertEquals(5, collection1.size());
-                sharedRealm.close();
-                looperThread.testComplete();
-            }
-        });
-
-        addRowAsync();
-    }
-
-    // Local commit will trigger the listener first when beginTransaction gets called then again when transaction
-    // committed.
-    @Test
-    @RunTestInLooperThread
-    public void addListener_triggeredByLocalCommit() {
-        final SharedRealm sharedRealm = getSharedRealm();
-        Table table = sharedRealm.getTable("test_table");
-        final AtomicInteger listenerCounter = new AtomicInteger(0);
-
-        final Collection collection = new Collection(sharedRealm, table.where());
-        looperThread.keepStrongReference(collection);
-        collection.addListener(collection, new RealmChangeListener<Collection>() {
-            @Override
-            public void onChange(Collection collection1) {
-                switch (listenerCounter.getAndIncrement()) {
-                    case 0:
-                        assertEquals(4, collection1.size());
-                        break;
-                    case 1:
-                        assertEquals(5, collection1.size());
-                        sharedRealm.close();
-                        break;
-                    default:
-                        fail();
-                        break;
-                }
-            }
-        });
-        addRow(sharedRealm);
-        assertEquals(2, listenerCounter.get());
-        looperThread.testComplete();
-    }
-
-    private static class TestIterator extends Collection.Iterator<Integer> {
-        TestIterator(Collection collection) {
-            super(collection);
-        }
-
-        @Override
-        protected Integer convertRowToObject(UncheckedRow row) {
-            return null;
-        }
-
-        boolean isDetached(SharedRealm sharedRealm) {
-            for (WeakReference<Collection.Iterator> iteratorRef : sharedRealm.iterators) {
-                Collection.Iterator iterator = iteratorRef.get();
-                if (iterator == this) {
-                    return false;
-                }
-            }
-            return true;
-        }
-    }
-
-    @Test
-    public void collectionIterator_detach_byBeginTransaction() {
-        final Collection collection = new Collection(sharedRealm, table.where());
-        TestIterator iterator = new TestIterator(collection);
-        assertFalse(iterator.isDetached(sharedRealm));
-        sharedRealm.beginTransaction();
-        assertTrue(iterator.isDetached(sharedRealm));
-        sharedRealm.commitTransaction();
-        assertTrue(iterator.isDetached(sharedRealm));
-    }
-
-    @Test
-    public void collectionIterator_detach_createdInTransaction() {
-        sharedRealm.beginTransaction();
-        final Collection collection = new Collection(sharedRealm, table.where());
-        TestIterator iterator = new TestIterator(collection);
-        assertTrue(iterator.isDetached(sharedRealm));
-    }
-
-    @Test
-    public void collectionIterator_invalid_nonLooperThread_byRefresh() {
-        final Collection collection = new Collection(sharedRealm, table.where());
-        TestIterator iterator = new TestIterator(collection);
-        assertFalse(iterator.isDetached(sharedRealm));
-        sharedRealm.refresh();
-        thrown.expect(ConcurrentModificationException.class);
-        iterator.checkValid();
-    }
-
-    @Test
-    @RunTestInLooperThread
-    public void collectionIterator_invalid_looperThread_byRemoteTransaction() {
-        final SharedRealm sharedRealm = getSharedRealm();
-        Table table = sharedRealm.getTable("test_table");
-        final Collection collection = new Collection(sharedRealm, table.where());
-        final TestIterator iterator = new TestIterator(collection);
-        looperThread.keepStrongReference(collection);
-        assertFalse(iterator.isDetached(sharedRealm));
-        collection.addListener(collection, new RealmChangeListener<Collection>() {
-            @Override
-            public void onChange(Collection element) {
-                try {
-                    iterator.checkValid();
-                    fail();
-                } catch (ConcurrentModificationException ignored) {
-                }
-                sharedRealm.close();
-                looperThread.testComplete();
-            }
-        });
-
-        addRowAsync();
-    }
-
-    @Test
-    public void collectionIterator_newInstance_throwsWhenSharedRealmIsClosed() {
-        final Collection collection = new Collection(sharedRealm, table.where());
-        sharedRealm.close();
-        thrown.expect(IllegalStateException.class);
-        new TestIterator(collection);
-    }
-
-    @Test
-    public void getMode() {
-        Collection collection = new Collection(sharedRealm, table.where());
-        assertTrue(Collection.Mode.QUERY == collection.getMode());
-        collection.firstUncheckedRow(); // Run the query
-        assertTrue(Collection.Mode.TABLEVIEW == collection.getMode());
-    }
-
-    @Test
-    public void createSnapshot() {
-        Collection collection = new Collection(sharedRealm, table.where());
-        Collection snapshot = collection.createSnapshot();
-        assertTrue(Collection.Mode.TABLEVIEW == snapshot.getMode());
-        thrown.expect(IllegalStateException.class);
-        snapshot.addListener(snapshot, new RealmChangeListener<Collection>() {
-            @Override
-            public void onChange(Collection element) {
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread
-    public void load() {
-        final Collection collection = new Collection(sharedRealm, table.where());
-        collection.addListener(collection, new RealmChangeListener<Collection>() {
-            @Override
-            public void onChange(Collection element) {
-                assertTrue(collection.isLoaded());
-                looperThread.testComplete();
-            }
-        });
-        assertFalse(collection.isLoaded());
-        collection.load();
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java
index a44043f00b..a0c0d8cac8 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java
@@ -17,25 +17,56 @@
 package io.realm.internal;
 
 import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
 
-import junit.framework.TestCase;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
 import io.realm.Realm;
+import io.realm.RealmConfiguration;
 import io.realm.RealmFieldType;
+import io.realm.TestHelper;
+import io.realm.rule.TestRealmConfigurationFactory;
 
-public class JNIColumnInfoTest extends TestCase {
+import static junit.framework.TestCase.assertEquals;
 
-    Table table;
 
-    @Override
+@RunWith(AndroidJUnit4.class)
+public class JNIColumnInfoTest {
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private SharedRealm sharedRealm;
+    private Table table;
+
+    @Before
     public void setUp() {
         Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
-        table = new Table();
-        table.addColumn(RealmFieldType.STRING, "firstName");
-        table.addColumn(RealmFieldType.STRING, "lastName");
+        RealmConfiguration config = configFactory.createConfiguration();
+        sharedRealm = SharedRealm.getInstance(config);
+
+        table = TestHelper.createTable(sharedRealm, "temp", new TestHelper.AdditionalTableSetup() {
+            @Override
+            public void execute(Table table) {
+                table.addColumn(RealmFieldType.STRING, "firstName");
+                table.addColumn(RealmFieldType.STRING, "lastName");
+            }
+        });
+    }
+
+    @After
+    public void tearDown() {
+        if (sharedRealm != null) {
+            sharedRealm.close();
+        }
     }
 
-    public void testShouldGetColumnInformation() {
+    @Test
+    public void shouldGetColumnInformation() {
 
         assertEquals(2, table.getColumnCount());
 
@@ -47,7 +78,8 @@ public void testShouldGetColumnInformation() {
 
     }
 
-    public void testValidateColumnInfo() {
+    @Test
+    public void validateColumnInfo() {
 
         assertEquals(2, table.getColumnCount());
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNILinkTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNILinkTest.java
deleted file mode 100644
index 95499e8a4a..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNILinkTest.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import android.support.test.runner.AndroidJUnit4;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import io.realm.RealmConfiguration;
-import io.realm.RealmFieldType;
-import io.realm.rule.TestRealmConfigurationFactory;
-
-import static junit.framework.Assert.assertEquals;
-
-@RunWith(AndroidJUnit4.class)
-public class JNILinkTest {
-    @Rule
-    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
-
-    private SharedRealm sharedRealm;
-
-    @Before
-    public void setUp() {
-        RealmConfiguration config = configFactory.createConfiguration();
-        sharedRealm = SharedRealm.getInstance(config);
-        sharedRealm.beginTransaction();
-    }
-
-    @After
-    public void tearDown() {
-        sharedRealm.cancelTransaction();
-        sharedRealm.close();
-    }
-
-    @Test
-    public void testLinkColumns() {
-        Table table1 = sharedRealm.getTable("table1");
-
-        Table table2 = sharedRealm.getTable("table2");
-        table2.addColumn(RealmFieldType.INTEGER, "int");
-        table2.addColumn(RealmFieldType.STRING, "string");
-
-        table2.add(1, "c");
-        table2.add(2, "b");
-        table2.add(3, "a");
-
-        table1.addColumnLink(RealmFieldType.OBJECT, "Link", table2);
-
-        table1.addEmptyRow();
-        table1.setLink(0, 0, 1, false);
-
-        Table target = table1.getLinkTarget(0);
-
-        System.gc();
-
-        assertEquals(target.getColumnCount(), 2);
-
-        String test = target.getString(1, table1.getLink(0, 0));
-
-        assertEquals(test, "b");
-
-    }
-
-    @Test
-    public void testLinkList() {
-        Table table1 = sharedRealm.getTable("table1");
-        table1.addColumn(RealmFieldType.INTEGER, "int");
-        table1.addColumn(RealmFieldType.STRING, "string");
-        table1.add(1, "c");
-        table1.add(2, "b");
-        table1.add(3, "a");
-
-        Table table2 = sharedRealm.getTable("table2");
-
-        table2.addColumnLink(RealmFieldType.LIST, "LinkList", table1);
-
-        table2.addEmptyRow();
-
-        LinkView links = table2.getUncheckedRow(0).getLinkList(0);
-
-        assertEquals(links.isEmpty(), true);
-        assertEquals(links.size(), 0);
-
-        links.add(2);
-        links.add(1);
-
-        assertEquals(links.isEmpty(), false);
-        assertEquals(links.size(), 2);
-
-        assertEquals(links.getUncheckedRow(0).getColumnName(1), "string");
-
-        assertEquals(links.getUncheckedRow(0).getString(1), "a");
-
-        links.move(1, 0);
-
-        assertEquals(links.getUncheckedRow(0).getString(1), "b");
-
-        links.remove(0);
-
-        assertEquals(links.getUncheckedRow(0).getString(1), "a");
-        assertEquals(links.size(), 1);
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
index 7f9042057d..6fa6a32ea9 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
@@ -17,46 +17,80 @@
 package io.realm.internal;
 
 import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
 
-import junit.framework.TestCase;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
 import java.util.Date;
 import java.util.concurrent.TimeUnit;
 
 import io.realm.Case;
 import io.realm.Realm;
+import io.realm.RealmConfiguration;
 import io.realm.RealmFieldType;
 import io.realm.TestHelper;
+import io.realm.rule.TestRealmConfigurationFactory;
 
-public class JNIQueryTest extends TestCase {
+import static junit.framework.TestCase.assertEquals;
+import static org.junit.Assert.fail;
 
-    Table table;
 
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
+@RunWith(AndroidJUnit4.class)
+public class JNIQueryTest {
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    @SuppressWarnings("FieldCanBeLocal")
+    private RealmConfiguration config;
+    private SharedRealm sharedRealm;
+    private Table table;
+    private final long[] oneNullTable = new long[]{NativeObject.NULLPTR};
+
+
+    @Before
+    public void setUp() throws Exception {
         Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
+        config = configFactory.createConfiguration();
+        sharedRealm = SharedRealm.getInstance(config);
     }
 
-    void init() {
-        table = new Table();
-        table.addColumn(RealmFieldType.INTEGER, "number");
-        table.addColumn(RealmFieldType.STRING, "name");
-
-        table.add(10, "A");
-        table.add(11, "B");
-        table.add(12, "C");
-        table.add(13, "B");
-        table.add(14, "D");
-        table.add(16, "D");
+    @After
+    public void tearDown() {
+        if (sharedRealm != null && !sharedRealm.isClosed()) {
+            sharedRealm.close();
+        }
+    }
+
+    private void init() {
+        table = TestHelper.createTable(sharedRealm, "temp", new TestHelper.AdditionalTableSetup() {
+            @Override
+            public void execute(Table table) {
+                table.addColumn(RealmFieldType.INTEGER, "number");
+                table.addColumn(RealmFieldType.STRING, "name");
+
+                TestHelper.addRowWithValues(table, 10, "A");
+                TestHelper.addRowWithValues(table, 11, "B");
+                TestHelper.addRowWithValues(table, 12, "C");
+                TestHelper.addRowWithValues(table, 13, "B");
+                TestHelper.addRowWithValues(table, 14, "D");
+                TestHelper.addRowWithValues(table, 16, "D");
+            }
+        });
+
         assertEquals(6, table.size());
     }
 
-    public void testShouldQuery() {
+    @Test
+    public void shouldQuery() {
         init();
         TableQuery query = table.where();
 
-        long cnt = query.equalTo(new long[]{1}, "D").count();
+        long cnt = query.equalTo(new long[]{1}, oneNullTable, "D").count();
         assertEquals(2, cnt);
 
         cnt = query.minimumInt(0);
@@ -69,19 +103,20 @@ public void testShouldQuery() {
         assertEquals(14+16, cnt);
 
         double avg = query.averageInt(0);
-        assertEquals(15.0, avg);
+        assertEquals(15.0, avg, Double.MIN_NORMAL);
 
         // TODO: Add tests with all parameters
     }
 
 
-    public void testNonCompleteQuery() {
+    @Test
+    public void nonCompleteQuery() {
         init();
 
         // All the following queries are not valid, e.g contain a group but not a closing group, an or() but not a second filter etc
-        try { table.where().equalTo(new long[]{0}, 1).or().validateQuery();       fail("missing a second filter"); }      catch (UnsupportedOperationException ignore) {}
+        try { table.where().equalTo(new long[]{0}, oneNullTable, 1).or().validateQuery();       fail("missing a second filter"); }      catch (UnsupportedOperationException ignore) {}
         try { table.where().or().validateQuery();                                 fail("just an or()"); }                 catch (UnsupportedOperationException ignore) {}
-        try { table.where().group().equalTo(new long[]{0}, 1).validateQuery();    fail("missing a closing group"); }      catch (UnsupportedOperationException ignore) {}
+        try { table.where().group().equalTo(new long[]{0}, oneNullTable, 1).validateQuery();    fail("missing a closing group"); }      catch (UnsupportedOperationException ignore) {}
 
         try { table.where().group().count();                                fail(); }                               catch (UnsupportedOperationException ignore) {}
         try { table.where().group().validateQuery();                              fail(); }                               catch (UnsupportedOperationException ignore) {}
@@ -91,307 +126,318 @@ public void testNonCompleteQuery() {
         try { table.where().group().sumInt(0);                              fail(); }                               catch (UnsupportedOperationException ignore) {}
         try { table.where().group().averageInt(0);                          fail(); }                               catch (UnsupportedOperationException ignore) {}
 
-        try { table.where().endGroup().equalTo(new long[]{0}, 1).validateQuery(); fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
-        try { table.where().equalTo(new long[]{0}, 1).endGroup().validateQuery(); fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
+        try { table.where().endGroup().equalTo(new long[]{0}, oneNullTable, 1).validateQuery(); fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
+        try { table.where().equalTo(new long[]{0}, oneNullTable, 1).endGroup().validateQuery(); fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
 
-        try { table.where().equalTo(new long[]{0}, 1).endGroup().find();    fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
-        try { table.where().equalTo(new long[]{0}, 1).endGroup().find(0);   fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
-        try { table.where().equalTo(new long[]{0}, 1).endGroup().find(1);   fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
+        try { table.where().equalTo(new long[]{0}, oneNullTable, 1).endGroup().find();    fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
+        try { table.where().equalTo(new long[]{0}, oneNullTable, 1).endGroup().find(0);   fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
+        try { table.where().equalTo(new long[]{0}, oneNullTable, 1).endGroup().find(1);   fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
     }
 
-    public void testInvalidColumnIndexEqualTo() {
-        Table table = TestHelper.getTableWithAllColumnTypes();
+    @Test
+    public void invalidColumnIndexEqualTo() {
+        Table table = TestHelper.createTableWithAllColumnTypes(sharedRealm);
         TableQuery query = table.where();
 
         // Boolean
-        try { query.equalTo(new long[]{-1}, true); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, true);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, true); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, oneNullTable, true); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.equalTo(new long[]{9}, oneNullTable, true);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.equalTo(new long[]{10}, oneNullTable, true); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // Date
-        try { query.equalTo(new long[]{-1}, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, oneNullTable, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.equalTo(new long[]{9}, oneNullTable, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.equalTo(new long[]{10}, oneNullTable, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // Double
-        try { query.equalTo(new long[]{-1}, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, oneNullTable, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.equalTo(new long[]{9}, oneNullTable, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.equalTo(new long[]{10}, oneNullTable, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
 
         // Float
-        try { query.equalTo(new long[]{-1}, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, 1.4f);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, oneNullTable, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.equalTo(new long[]{9}, oneNullTable, 1.4f);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.equalTo(new long[]{10}, oneNullTable, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // Int / long
-        try { query.equalTo(new long[]{-1}, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, 1);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, oneNullTable, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.equalTo(new long[]{9}, oneNullTable, 1);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.equalTo(new long[]{10}, oneNullTable, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // String
-        try { query.equalTo(new long[]{-1}, "a"); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, "a");  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, "a"); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, oneNullTable, "a"); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.equalTo(new long[]{9}, oneNullTable, "a");  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.equalTo(new long[]{10}, oneNullTable, "a"); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // String case true
-        try { query.equalTo(new long[]{-1}, "a", Case.SENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, "a", Case.SENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, "a", Case.SENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, oneNullTable, "a", Case.SENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.equalTo(new long[]{9}, oneNullTable, "a", Case.SENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.equalTo(new long[]{10}, oneNullTable, "a", Case.SENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // String case false
-        try { query.equalTo(new long[]{-1}, "a", Case.INSENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, "a", Case.INSENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, "a", Case.INSENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, oneNullTable, "a", Case.INSENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.equalTo(new long[]{9}, oneNullTable, "a", Case.INSENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.equalTo(new long[]{10}, oneNullTable, "a", Case.INSENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
     }
 
-    public void testInvalidColumnIndexNotEqualTo() {
-        Table table = TestHelper.getTableWithAllColumnTypes();
+    @Test
+    public void invalidColumnIndexNotEqualTo() {
+        Table table = TestHelper.createTableWithAllColumnTypes(sharedRealm);
         TableQuery query = table.where();
 
 
         // Date
-        try { query.notEqualTo(new long[]{-1}, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, oneNullTable, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.notEqualTo(new long[]{9}, oneNullTable, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.notEqualTo(new long[]{10}, oneNullTable, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // Double
-        try { query.notEqualTo(new long[]{-1}, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, oneNullTable, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.notEqualTo(new long[]{9}, oneNullTable, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.notEqualTo(new long[]{10}, oneNullTable, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
 
         // Float
-        try { query.notEqualTo(new long[]{-1}, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, 1.4f);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, oneNullTable, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.notEqualTo(new long[]{9}, oneNullTable, 1.4f);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.notEqualTo(new long[]{10}, oneNullTable, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // Int / long
-        try { query.notEqualTo(new long[]{-1}, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, 1);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, oneNullTable, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.notEqualTo(new long[]{9}, oneNullTable, 1);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.notEqualTo(new long[]{10}, oneNullTable, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // String
-        try { query.notEqualTo(new long[]{-1}, "a"); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, "a");  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, "a"); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, oneNullTable, "a"); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.notEqualTo(new long[]{9}, oneNullTable, "a");  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.notEqualTo(new long[]{10}, oneNullTable, "a"); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // String case true
-        try { query.notEqualTo(new long[]{-1}, "a", Case.SENSITIVE); fail("-1column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, "a", Case.SENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, "a", Case.SENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, oneNullTable, "a", Case.SENSITIVE); fail("-1column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.notEqualTo(new long[]{9}, oneNullTable, "a", Case.SENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.notEqualTo(new long[]{10}, oneNullTable, "a", Case.SENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // String case false
-        try { query.notEqualTo(new long[]{-1}, "a", Case.INSENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, "a", Case.INSENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, "a", Case.INSENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, oneNullTable, "a", Case.INSENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.notEqualTo(new long[]{9}, oneNullTable, "a", Case.INSENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.notEqualTo(new long[]{10}, oneNullTable, "a", Case.INSENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
     }
 
-
-    public void testInvalidColumnIndexGreaterThan() {
-        Table table = TestHelper.getTableWithAllColumnTypes();
+    @Test
+    public void invalidColumnIndexGreaterThan() {
+        Table table = TestHelper.createTableWithAllColumnTypes(sharedRealm);
         TableQuery query = table.where();
 
         // Date
-        try { query.greaterThan(new long[]{-1}, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{9}, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{10}, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{-1}, oneNullTable, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThan(new long[]{9}, oneNullTable, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThan(new long[]{10}, oneNullTable, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // Double
-        try { query.greaterThan(new long[]{-1}, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{9}, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{10}, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{-1}, oneNullTable, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThan(new long[]{9}, oneNullTable, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThan(new long[]{10}, oneNullTable, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
 
         // Float
-        try { query.greaterThan(new long[]{-1}, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{9}, 1.4f);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{10}, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{-1}, oneNullTable, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThan(new long[]{9}, oneNullTable, 1.4f);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThan(new long[]{10}, oneNullTable, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // Int / long
-        try { query.greaterThan(new long[]{-1}, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{9}, 1);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{10}, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{-1}, oneNullTable, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThan(new long[]{9}, oneNullTable, 1);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThan(new long[]{10}, oneNullTable, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
     }
 
-
-    public void testInvalidColumnIndexGreaterThanOrEqual() {
-        Table table = TestHelper.getTableWithAllColumnTypes();
+    @Test
+    public void invalidColumnIndexGreaterThanOrEqual() {
+        Table table = TestHelper.createTableWithAllColumnTypes(sharedRealm);
         TableQuery query = table.where();
 
         // Date
-        try { query.greaterThanOrEqual(new long[]{-1}, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{9}, new Date()); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{10}, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{-1}, oneNullTable, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThanOrEqual(new long[]{9}, oneNullTable, new Date()); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThanOrEqual(new long[]{10}, oneNullTable, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // Double
-        try { query.greaterThanOrEqual(new long[]{-1}, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{9}, 4.5d); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{10}, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{-1}, oneNullTable, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThanOrEqual(new long[]{9}, oneNullTable, 4.5d); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThanOrEqual(new long[]{10}, oneNullTable, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
 
         // Float
-        try { query.greaterThanOrEqual(new long[]{-1}, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{9}, 1.4f); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{10}, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{-1}, oneNullTable, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThanOrEqual(new long[]{9}, oneNullTable, 1.4f); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThanOrEqual(new long[]{10}, oneNullTable, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // Int / long
-        try { query.greaterThanOrEqual(new long[]{-1}, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{9}, 1); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{10}, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{-1}, oneNullTable, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThanOrEqual(new long[]{9}, oneNullTable, 1); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThanOrEqual(new long[]{10}, oneNullTable, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
     }
 
-
-    public void testInvalidColumnIndexLessThan() {
-        Table table = TestHelper.getTableWithAllColumnTypes();
+    @Test
+    public void invalidColumnIndexLessThan() {
+        Table table = TestHelper.createTableWithAllColumnTypes(sharedRealm);
         TableQuery query = table.where();
 
         // Date
-        try { query.lessThan(new long[]{-1}, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{9}, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{10}, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{-1}, oneNullTable, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThan(new long[]{9}, oneNullTable, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThan(new long[]{10}, oneNullTable, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // Double
-        try { query.lessThan(new long[]{-1}, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{9}, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{10}, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{-1}, oneNullTable, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThan(new long[]{9}, oneNullTable, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThan(new long[]{10}, oneNullTable, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
 
         // Float
-        try { query.lessThan(new long[]{-1}, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{9}, 1.4f);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{10}, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{-1}, oneNullTable, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThan(new long[]{9}, oneNullTable, 1.4f);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThan(new long[]{10}, oneNullTable, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // Int / long
-        try { query.lessThan(new long[]{-1}, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{9}, 1);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{10}, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{-1}, oneNullTable, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThan(new long[]{9}, oneNullTable, 1);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThan(new long[]{10}, oneNullTable, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
     }
 
-    public void testInvalidColumnIndexLessThanOrEqual() {
-        Table table = TestHelper.getTableWithAllColumnTypes();
+    @Test
+    public void invalidColumnIndexLessThanOrEqual() {
+        Table table = TestHelper.createTableWithAllColumnTypes(sharedRealm);
         TableQuery query = table.where();
 
         // Date
-        try { query.lessThanOrEqual(new long[]{-1}, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{9}, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{10}, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{-1}, oneNullTable, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThanOrEqual(new long[]{9}, oneNullTable, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThanOrEqual(new long[]{10}, oneNullTable, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // Double
-        try { query.lessThanOrEqual(new long[]{-1}, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{9}, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{10}, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{-1}, oneNullTable, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThanOrEqual(new long[]{9}, oneNullTable, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThanOrEqual(new long[]{10}, oneNullTable, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
 
         // Float
-        try { query.lessThanOrEqual(new long[]{-1}, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{9}, 1.4f); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{10}, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{-1}, oneNullTable, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThanOrEqual(new long[]{9}, oneNullTable, 1.4f); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThanOrEqual(new long[]{10}, oneNullTable, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // Int / long
-        try { query.lessThanOrEqual(new long[]{-1}, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{9}, 1); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{10}, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{-1}, oneNullTable, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThanOrEqual(new long[]{9}, oneNullTable, 1); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThanOrEqual(new long[]{10}, oneNullTable, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
     }
 
-
-    public void testInvalidColumnIndexBetween() {
-        Table table = TestHelper.getTableWithAllColumnTypes();
+    @Test
+    public void invalidColumnIndexBetween() {
+        Table table = TestHelper.createTableWithAllColumnTypes(sharedRealm);
         TableQuery query = table.where();
 
         // Date
-        try { query.between(new long[]{-1}, new Date(), new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{9}, new Date(), new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{10}, new Date(), new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{-1}, new Date(), new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.between(new long[]{9}, new Date(), new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.between(new long[]{10}, new Date(), new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // Double
-        try { query.between(new long[]{-1}, 4.5d, 6.0d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{9}, 4.5d, 6.0d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{10}, 4.5d, 6.0d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{-1}, 4.5d, 6.0d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.between(new long[]{9}, 4.5d, 6.0d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.between(new long[]{10}, 4.5d, 6.0d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
 
         // Float
-        try { query.between(new long[]{-1}, 1.4f, 5.8f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{9}, 1.4f, 5.8f); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{10}, 1.4f, 5.8f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{-1}, 1.4f, 5.8f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.between(new long[]{9}, 1.4f, 5.8f); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.between(new long[]{10}, 1.4f, 5.8f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // Int / long
-        try { query.between(new long[]{-1}, 1, 10); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{9}, 1, 10);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{10}, 1, 10); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{-1}, 1, 10); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.between(new long[]{9}, 1, 10);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.between(new long[]{10}, 1, 10); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
     }
 
-
-    public void testInvalidColumnIndexContains() {
-        Table table = TestHelper.getTableWithAllColumnTypes();
+    @Test
+    public void invalidColumnIndexContains() {
+        Table table = TestHelper.createTableWithAllColumnTypes(sharedRealm);
         TableQuery query = table.where();
 
         // String
-        try { query.contains(new long[]{-1}, "hey"); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{9}, "hey");  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{10}, "hey"); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{-1}, oneNullTable, "hey"); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.contains(new long[]{9}, oneNullTable, "hey");  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.contains(new long[]{10}, oneNullTable, "hey"); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // String case true
-        try { query.contains(new long[]{-1}, "hey", Case.SENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{9}, "hey", Case.SENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{10}, "hey", Case.SENSITIVE); fail("-0 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{-1}, oneNullTable, "hey", Case.SENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.contains(new long[]{9}, oneNullTable, "hey", Case.SENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.contains(new long[]{10}, oneNullTable, "hey", Case.SENSITIVE); fail("-0 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
 
         // String case false
-        try { query.contains(new long[]{-1}, "hey", Case.INSENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{9}, "hey", Case.INSENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{10}, "hey", Case.INSENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{-1}, oneNullTable, "hey", Case.INSENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.contains(new long[]{9}, oneNullTable, "hey", Case.INSENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException ignore) {}
+        try { query.contains(new long[]{10}, oneNullTable, "hey", Case.INSENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException ignore) {}
     }
 
-    public void testNullInputQuery() {
-        Table t = new Table();
-        t.addColumn(RealmFieldType.DATE, "dateCol");
-        t.addColumn(RealmFieldType.STRING, "stringCol");
+    @SuppressWarnings("ConstantConditions")
+    @Test
+    public void nullInputQuery() {
+        Table t = TestHelper.createTable(sharedRealm, "temp", new TestHelper.AdditionalTableSetup() {
+            @Override
+            public void execute(Table t) {
+                t.addColumn(RealmFieldType.DATE, "dateCol");
+                t.addColumn(RealmFieldType.STRING, "stringCol");
+            }
+        });
 
         Date nullDate = null;
-        try { t.where().equalTo(new long[]{0}, nullDate);               fail("Date is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().notEqualTo(new long[]{0}, nullDate);            fail("Date is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().greaterThan(new long[]{0}, nullDate);           fail("Date is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().greaterThanOrEqual(new long[]{0}, nullDate);    fail("Date is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().lessThan(new long[]{0}, nullDate);              fail("Date is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().lessThanOrEqual(new long[]{0}, nullDate);       fail("Date is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().between(new long[]{0}, nullDate, new Date());   fail("Date is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().between(new long[]{0}, new Date(), nullDate);   fail("Date is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().between(new long[]{0}, nullDate, nullDate);     fail("Dates are null"); } catch (IllegalArgumentException e) { }
+        try { t.where().equalTo(new long[]{0}, oneNullTable, nullDate);               fail("Date is null"); } catch (IllegalArgumentException ignore) { }
+        try { t.where().notEqualTo(new long[]{0}, oneNullTable, nullDate);            fail("Date is null"); } catch (IllegalArgumentException ignore) { }
+        try { t.where().greaterThan(new long[]{0}, oneNullTable, nullDate);           fail("Date is null"); } catch (IllegalArgumentException ignore) { }
+        try { t.where().greaterThanOrEqual(new long[]{0}, oneNullTable, nullDate);    fail("Date is null"); } catch (IllegalArgumentException ignore) { }
+        try { t.where().lessThan(new long[]{0}, oneNullTable, nullDate);              fail("Date is null"); } catch (IllegalArgumentException ignore) { }
+        try { t.where().lessThanOrEqual(new long[]{0}, oneNullTable, nullDate);       fail("Date is null"); } catch (IllegalArgumentException ignore) { }
+        try { t.where().between(new long[]{0}, nullDate, new Date());   fail("Date is null"); } catch (IllegalArgumentException ignore) { }
+        try { t.where().between(new long[]{0}, new Date(), nullDate);   fail("Date is null"); } catch (IllegalArgumentException ignore) { }
+        try { t.where().between(new long[]{0}, nullDate, nullDate);     fail("Dates are null"); } catch (IllegalArgumentException ignore) { }
 
         String nullString = null;
-        try { t.where().equalTo(new long[]{1}, nullString);                         fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().equalTo(new long[]{1}, nullString, Case.INSENSITIVE);       fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().notEqualTo(new long[]{1}, nullString);                      fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().notEqualTo(new long[]{1}, nullString, Case.INSENSITIVE);    fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().contains(new long[]{1}, nullString);                        fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().contains(new long[]{1}, nullString, Case.INSENSITIVE);      fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().beginsWith(new long[]{1}, nullString);                      fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().beginsWith(new long[]{1}, nullString, Case.INSENSITIVE);    fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().endsWith(new long[]{1}, nullString);                        fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().endsWith(new long[]{1}, nullString, Case.INSENSITIVE);      fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().like(new long[]{1}, nullString);                            fail("String is null"); } catch (IllegalArgumentException e) { }
-        try { t.where().like(new long[]{1}, nullString, Case.INSENSITIVE);          fail("String is null"); } catch (IllegalArgumentException e) { }
+        try { t.where().equalTo(new long[]{1}, oneNullTable, nullString);                         fail("String is null"); } catch (IllegalArgumentException ignore) { }
+        try { t.where().equalTo(new long[]{1}, oneNullTable, nullString, Case.INSENSITIVE);       fail("String is null"); } catch (IllegalArgumentException ignore) { }
+        try { t.where().notEqualTo(new long[]{1}, oneNullTable, nullString);                      fail("String is null"); } catch (IllegalArgumentException ignore) { }
+        try { t.where().notEqualTo(new long[]{1}, oneNullTable, nullString, Case.INSENSITIVE);    fail("String is null"); } catch (IllegalArgumentException ignore) { }
+        try { t.where().contains(new long[]{1}, oneNullTable, nullString);                        fail("String is null"); } catch (IllegalArgumentException ignore) { }
+        try { t.where().contains(new long[]{1}, oneNullTable, nullString, Case.INSENSITIVE);      fail("String is null"); } catch (IllegalArgumentException ignore) { }
+        try { t.where().beginsWith(new long[]{1}, oneNullTable, nullString);                      fail("String is null"); } catch (IllegalArgumentException ignore) { }
+        try { t.where().beginsWith(new long[]{1}, oneNullTable, nullString, Case.INSENSITIVE);    fail("String is null"); } catch (IllegalArgumentException ignore) { }
+        try { t.where().endsWith(new long[]{1}, oneNullTable, nullString);                        fail("String is null"); } catch (IllegalArgumentException ignore) { }
+        try { t.where().endsWith(new long[]{1}, oneNullTable, nullString, Case.INSENSITIVE);      fail("String is null"); } catch (IllegalArgumentException ignore) { }
+        try { t.where().like(new long[]{1}, oneNullTable, nullString);                            fail("String is null"); } catch (IllegalArgumentException ignore) { }
+        try { t.where().like(new long[]{1}, oneNullTable, nullString, Case.INSENSITIVE);          fail("String is null"); } catch (IllegalArgumentException ignore) { }
     }
 
-
-
-    public void testShouldFind() {
+    @Test
+    public void shouldFind() {
         // Creates a table.
-        Table table = new Table();
-
-        table.addColumn(RealmFieldType.STRING, "username");
-        table.addColumn(RealmFieldType.INTEGER, "score");
-        table.addColumn(RealmFieldType.BOOLEAN, "completed");
-
-        // Inserts some values.
-        table.add("Arnold", 420, false);    // 0
-        table.add("Jane", 770, false);      // 1 *
-        table.add("Erik", 600, false);      // 2
-        table.add("Henry", 601, false);     // 3 *
-        table.add("Bill", 564, true);       // 4
-        table.add("Janet", 875, false);     // 5 *
+        Table table = TestHelper.createTable(sharedRealm, "temp", new TestHelper.AdditionalTableSetup() {
+            @Override
+            public void execute(Table table) {
+                table.addColumn(RealmFieldType.STRING, "username");
+                table.addColumn(RealmFieldType.INTEGER, "score");
+                table.addColumn(RealmFieldType.BOOLEAN, "completed");
+
+                // Inserts some values.
+                TestHelper.addRowWithValues(table, "Arnold", 420, false);    // 0
+                TestHelper.addRowWithValues(table, "Jane", 770, false);      // 1 *
+                TestHelper.addRowWithValues(table, "Erik", 600, false);      // 2
+                TestHelper.addRowWithValues(table, "Henry", 601, false);     // 3 *
+                TestHelper.addRowWithValues(table, "Bill", 564, true);       // 4
+                TestHelper.addRowWithValues(table, "Janet", 875, false);     // 5 *
+            }
+        });
 
-        TableQuery query = table.where().greaterThan(new long[]{1}, 600);
+        TableQuery query = table.where().greaterThan(new long[]{1}, oneNullTable, 600);
 
         // Finds first match.
         assertEquals(1, query.find());
@@ -414,85 +460,87 @@ public void testShouldFind() {
 
         // Tests out of range.
         assertEquals(-1, query.find(6));
-        try {  query.find(7);  fail("Exception expected");  } catch (ArrayIndexOutOfBoundsException e) {  }
+        try {  query.find(7);  fail("Exception expected");  } catch (ArrayIndexOutOfBoundsException ignore) {  }
     }
 
+    @Test
+    public void queryTestForNoMatches() {
+        Table t = TestHelper.createTableWithAllColumnTypes(sharedRealm);
 
+        sharedRealm.beginTransaction();
+        TestHelper.addRowWithValues(t, new byte[]{1,2,3}, true, new Date(1384423149761L), 4.5d, 5.7f, 100, "string");
+        sharedRealm.commitTransaction();
 
-    public void testQueryTestForNoMatches() {
-        Table t = new Table();
-        t = TestHelper.getTableWithAllColumnTypes();
-
-        t.add(new byte[]{1,2,3}, true, new Date(1384423149761l), 4.5d, 5.7f, 100, "string");
-
-        TableQuery q = t.where().greaterThan(new long[]{5}, 1000); // No matches
+        TableQuery q = t.where().greaterThan(new long[]{5}, oneNullTable, 1000); // No matches
 
         assertEquals(-1, q.find());
         assertEquals(-1, q.find(1));
     }
 
+    @Test
+    public void queryWithWrongDataType() {
 
-
-    public void testQueryWithWrongDataType() {
-
-        Table table = TestHelper.getTableWithAllColumnTypes();
+        Table table = TestHelper.createTableWithAllColumnTypes(sharedRealm);
 
         // Queries the table.
         TableQuery query = table.where();
 
         // Compares strings in non string columns.
         for (int i = 0; i <= 6; i++) {
-            try { query.equalTo(new long[]{i}, "string");                 assert(false); } catch(IllegalArgumentException e) {}
-            try { query.notEqualTo(new long[]{i}, "string");              assert(false); } catch(IllegalArgumentException e) {}
-            try { query.beginsWith(new long[]{i}, "string");              assert(false); } catch(IllegalArgumentException e) {}
-            try { query.endsWith(new long[]{i}, "string");                assert(false); } catch(IllegalArgumentException e) {}
-            try { query.like(new long[]{i}, "string");                    assert(false); } catch(IllegalArgumentException e) {}
-            try { query.contains(new long[]{i}, "string");                assert(false); } catch(IllegalArgumentException e) {}
+            if (i != 6) {
+                try { query.equalTo(new long[]{i}, oneNullTable, "string");    fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.notEqualTo(new long[]{i}, oneNullTable, "string"); fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.beginsWith(new long[]{i}, oneNullTable, "string"); fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.endsWith(new long[]{i}, oneNullTable, "string");   fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.like(new long[]{i}, oneNullTable, "string");       fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.contains(new long[]{i}, oneNullTable, "string");   fail(); } catch(IllegalArgumentException ignore) {}
+            }
         }
 
+
         // Compares integer in non integer columns.
         for (int i = 0; i <= 6; i++) {
             if (i != 5) {
-                try { query.equalTo(new long[]{i}, 123);                      assert(false); } catch(IllegalArgumentException e) {}
-                try { query.notEqualTo(new long[]{i}, 123);                   assert(false); } catch(IllegalArgumentException e) {}
-                try { query.lessThan(new long[]{i}, 123);                     assert(false); } catch(IllegalArgumentException e) {}
-                try { query.lessThanOrEqual(new long[]{i}, 123);              assert(false); } catch(IllegalArgumentException e) {}
-                try { query.greaterThan(new long[]{i}, 123);                  assert(false); } catch(IllegalArgumentException e) {}
-                try { query.greaterThanOrEqual(new long[]{i}, 123);           assert(false); } catch(IllegalArgumentException e) {}
-                try { query.between(new long[]{i}, 123, 321);                 assert(false); } catch(IllegalArgumentException e) {}
+                try { query.equalTo(new long[]{i}, oneNullTable, 123);            fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.notEqualTo(new long[]{i}, oneNullTable, 123);         fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.lessThan(new long[]{i}, oneNullTable, 123);           fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.lessThanOrEqual(new long[]{i}, oneNullTable, 123);    fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.greaterThan(new long[]{i}, oneNullTable, 123);        fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.greaterThanOrEqual(new long[]{i}, oneNullTable, 123); fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.between(new long[]{i}, 123, 321);                     fail(); } catch(IllegalArgumentException ignore) {}
             }
         }
 
         // Compares float in non float columns.
         for (int i = 0; i <= 6; i++) {
             if (i != 4) {
-                try { query.equalTo(new long[]{i}, 123F);                     assert(false); } catch(IllegalArgumentException e) {}
-                try { query.notEqualTo(new long[]{i}, 123F);                  assert(false); } catch(IllegalArgumentException e) {}
-                try { query.lessThan(new long[]{i}, 123F);                    assert(false); } catch(IllegalArgumentException e) {}
-                try { query.lessThanOrEqual(new long[]{i}, 123F);             assert(false); } catch(IllegalArgumentException e) {}
-                try { query.greaterThan(new long[]{i}, 123F);                 assert(false); } catch(IllegalArgumentException e) {}
-                try { query.greaterThanOrEqual(new long[]{i}, 123F);          assert(false); } catch(IllegalArgumentException e) {}
-                try { query.between(new long[]{i}, 123F, 321F);               assert(false); } catch(IllegalArgumentException e) {}
+                try { query.equalTo(new long[]{i}, oneNullTable, 123F);            fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.notEqualTo(new long[]{i}, oneNullTable, 123F);         fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.lessThan(new long[]{i}, oneNullTable, 123F);           fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.lessThanOrEqual(new long[]{i}, oneNullTable, 123F);    fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.greaterThan(new long[]{i}, oneNullTable, 123F);        fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.greaterThanOrEqual(new long[]{i}, oneNullTable, 123F); fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.between(new long[]{i}, 123F, 321F);                    fail(); } catch(IllegalArgumentException ignore) {}
             }
         }
 
         // Compares double in non double columns.
         for (int i = 0; i <= 6; i++) {
             if (i != 3) {
-                try { query.equalTo(new long[]{i}, 123D);                     assert(false); } catch(IllegalArgumentException e) {}
-                try { query.notEqualTo(new long[]{i}, 123D);                  assert(false); } catch(IllegalArgumentException e) {}
-                try { query.lessThan(new long[]{i}, 123D);                    assert(false); } catch(IllegalArgumentException e) {}
-                try { query.lessThanOrEqual(new long[]{i}, 123D);             assert(false); } catch(IllegalArgumentException e) {}
-                try { query.greaterThan(new long[]{i}, 123D);                 assert(false); } catch(IllegalArgumentException e) {}
-                try { query.greaterThanOrEqual(new long[]{i}, 123D);          assert(false); } catch(IllegalArgumentException e) {}
-                try { query.between(new long[]{i}, 123D, 321D);               assert(false); } catch(IllegalArgumentException e) {}
+                try { query.equalTo(new long[]{i}, oneNullTable, 123D);                     fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.notEqualTo(new long[]{i}, oneNullTable, 123D);                  fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.lessThan(new long[]{i}, oneNullTable, 123D);                    fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.lessThanOrEqual(new long[]{i}, oneNullTable, 123D);             fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.greaterThan(new long[]{i}, oneNullTable, 123D);                 fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.greaterThanOrEqual(new long[]{i}, oneNullTable, 123D);          fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.between(new long[]{i}, 123D, 321D);                             fail(); } catch(IllegalArgumentException ignore) {}
             }
         }
 
         // Compares boolean in non boolean columns.
         for (int i = 0; i <= 6; i++) {
             if (i != 1) {
-              try { query.equalTo(new long[]{i}, true);                       assert(false); } catch(IllegalArgumentException e) {}
+              try { query.equalTo(new long[]{i}, oneNullTable, true);                       fail(); } catch(IllegalArgumentException ignore) {}
             }
         }
 
@@ -500,195 +548,209 @@ public void testQueryWithWrongDataType() {
         /* TODO:
         for (int i = 0; i <= 8; i++) {
             if (i != 2) {
-                try { query.equal(i, new Date());                   assert(false); } catch(IllegalArgumentException e) {}
-                try { query.lessThan(i, new Date());                assert(false); } catch(IllegalArgumentException e) {}
-                try { query.lessThanOrEqual(i, new Date());         assert(false); } catch(IllegalArgumentException e) {}
-                try { query.greaterThan(i, new Date());             assert(false); } catch(IllegalArgumentException e) {}
-                try { query.greaterThanOrEqual(i, new Date());      assert(false); } catch(IllegalArgumentException e) {}
-                try { query.between(i, new Date(), new Date());     assert(false); } catch(IllegalArgumentException e) {}
+                try { query.equal(i, new Date());                   fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.lessThan(i, new Date());                fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.lessThanOrEqual(i, new Date());         fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.greaterThan(i, new Date());             fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.greaterThanOrEqual(i, new Date());      fail(); } catch(IllegalArgumentException ignore) {}
+                try { query.between(i, new Date(), new Date());     fail(); } catch(IllegalArgumentException ignore) {}
             }
         }
         */
     }
 
-
-    public void testColumnIndexOutOfBounds() {
-        Table table = TestHelper.getTableWithAllColumnTypes();
+    @Test
+    public void columnIndexOutOfBounds() {
+        Table table = TestHelper.createTableWithAllColumnTypes(sharedRealm);
 
         // Queries the table.
         TableQuery query = table.where();
 
-        try { query.minimumInt(0);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumFloat(0);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumDouble(0);           assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumInt(1);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumFloat(1);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumDouble(1);           assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumInt(2);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumFloat(2);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumDouble(2);           assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumInt(6);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumFloat(6);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.minimumDouble(6);           assert(false); } catch(IllegalArgumentException e) {}
-
-        try { query.maximumInt(0);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumFloat(0);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumDouble(0);           assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumInt(1);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumFloat(1);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumDouble(1);           assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumInt(2);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumFloat(2);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumDouble(2);           assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumInt(6);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumFloat(6);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.maximumDouble(6);           assert(false); } catch(IllegalArgumentException e) {}
-
-        try { query.sumInt(0);                     assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumFloat(0);                assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumDouble(0);               assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumInt(1);                     assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumFloat(1);                assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumDouble(1);               assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumInt(2);                     assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumFloat(2);                assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumDouble(2);               assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumInt(6);                     assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumFloat(6);                assert(false); } catch(IllegalArgumentException e) {}
-        try { query.sumDouble(6);               assert(false); } catch(IllegalArgumentException e) {}
-
-        try { query.averageInt(0);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageFloat(0);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageDouble(0);           assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageInt(1);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageFloat(1);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageDouble(1);           assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageInt(2);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageFloat(2);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageDouble(2);           assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageInt(6);                 assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageFloat(6);            assert(false); } catch(IllegalArgumentException e) {}
-        try { query.averageDouble(6);           assert(false); } catch(IllegalArgumentException e) {}
+        try { query.minimumInt(0);                 fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.minimumFloat(0);            fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.minimumDouble(0);           fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.minimumInt(1);                 fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.minimumFloat(1);            fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.minimumDouble(1);           fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.minimumInt(2);                 fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.minimumFloat(2);            fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.minimumDouble(2);           fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.minimumInt(6);                 fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.minimumFloat(6);            fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.minimumDouble(6);           fail(); } catch(IllegalArgumentException ignore) {}
+
+        try { query.maximumInt(0);                 fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.maximumFloat(0);            fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.maximumDouble(0);           fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.maximumInt(1);                 fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.maximumFloat(1);            fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.maximumDouble(1);           fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.maximumInt(2);                 fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.maximumFloat(2);            fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.maximumDouble(2);           fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.maximumInt(6);                 fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.maximumFloat(6);            fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.maximumDouble(6);           fail(); } catch(IllegalArgumentException ignore) {}
+
+        try { query.sumInt(0);                     fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.sumFloat(0);                fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.sumDouble(0);               fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.sumInt(1);                     fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.sumFloat(1);                fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.sumDouble(1);               fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.sumInt(2);                     fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.sumFloat(2);                fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.sumDouble(2);               fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.sumInt(6);                     fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.sumFloat(6);                fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.sumDouble(6);               fail(); } catch(IllegalArgumentException ignore) {}
+
+        try { query.averageInt(0);                 fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.averageFloat(0);            fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.averageDouble(0);           fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.averageInt(1);                 fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.averageFloat(1);            fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.averageDouble(1);           fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.averageInt(2);                 fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.averageFloat(2);            fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.averageDouble(2);           fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.averageInt(6);                 fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.averageFloat(6);            fail(); } catch(IllegalArgumentException ignore) {}
+        try { query.averageDouble(6);           fail(); } catch(IllegalArgumentException ignore) {}
         // Out of bounds for string
-        try { query.equalTo(new long[]{7}, "string");                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{7}, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.beginsWith(new long[]{7}, "string");              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.endsWith(new long[]{7}, "string");                assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.like(new long[]{7}, "string");                    assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{7}, "string");                assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{7}, oneNullTable, "string");                 fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.notEqualTo(new long[]{7}, oneNullTable, "string");              fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.beginsWith(new long[]{7}, oneNullTable, "string");              fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.endsWith(new long[]{7}, oneNullTable, "string");                fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.like(new long[]{7}, oneNullTable, "string");                    fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.contains(new long[]{7}, oneNullTable, "string");                fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
 
 
         // Out of bounds for integer
-        try { query.equalTo(new long[]{7}, 123);                      assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{7}, 123);                   assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{7}, 123);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{7}, 123);              assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{7}, 123);                  assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{7}, 123);           assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{7}, 123, 321);                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{7}, oneNullTable, 123);                      fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.notEqualTo(new long[]{7}, oneNullTable, 123);                   fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThan(new long[]{7}, oneNullTable, 123);                     fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThanOrEqual(new long[]{7}, oneNullTable, 123);              fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThan(new long[]{7}, oneNullTable, 123);                  fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThanOrEqual(new long[]{7}, oneNullTable, 123);           fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.between(new long[]{7}, 123, 321);                               fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
 
 
         // Out of bounds for float
-        try { query.equalTo(new long[]{7}, 123F);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{7}, 123F);                  assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{7}, 123F);                    assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{7}, 123F);             assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{7}, 123F);                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{7}, 123F);          assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{7}, 123F, 321F);               assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{7}, oneNullTable, 123F);                     fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.notEqualTo(new long[]{7}, oneNullTable, 123F);                  fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThan(new long[]{7}, oneNullTable, 123F);                    fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThanOrEqual(new long[]{7}, oneNullTable, 123F);             fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThan(new long[]{7}, oneNullTable, 123F);                 fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThanOrEqual(new long[]{7}, oneNullTable, 123F);          fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.between(new long[]{7}, 123F, 321F);                             fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
 
 
         // Out of bounds for double
-        try { query.equalTo(new long[]{7}, 123D);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{7}, 123D);                  assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{7}, 123D);                    assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{7}, 123D);             assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{7}, 123D);                 assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{7}, 123D);          assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{7}, 123D, 321D);               assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{7}, oneNullTable, 123D);                     fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.notEqualTo(new long[]{7}, oneNullTable, 123D);                  fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThan(new long[]{7}, oneNullTable, 123D);                    fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.lessThanOrEqual(new long[]{7}, oneNullTable, 123D);             fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThan(new long[]{7}, oneNullTable, 123D);                 fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.greaterThanOrEqual(new long[]{7}, oneNullTable, 123D);          fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
+        try { query.between(new long[]{7}, 123D, 321D);                             fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
 
 
         // Out of bounds for boolean
-        try { query.equalTo(new long[]{7}, true);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{7}, oneNullTable, true);                     fail(); } catch(ArrayIndexOutOfBoundsException ignore) {}
     }
 
-    public void testMaximumDate() {
+    @Test
+    public void maximumDate() {
 
-        Table table = new Table();
-        table.addColumn(RealmFieldType.DATE, "date");
+        Table table = TestHelper.createTable(sharedRealm, "temp", new TestHelper.AdditionalTableSetup() {
+            @Override
+            public void execute(Table table) {
+                table.addColumn(RealmFieldType.DATE, "date");
 
-        table.add(new Date(0));
-        table.add(new Date(10000));
-        table.add(new Date(1000));
+                TestHelper.addRowWithValues(table, new Date(0));
+                TestHelper.addRowWithValues(table, new Date(10000));
+                TestHelper.addRowWithValues(table, new Date(1000));
+            }
+        });
 
         assertEquals(new Date(10000), table.where().maximumDate(0));
     }
 
+    @Test
+    public void minimumDate() {
 
-    public void testMinimumDate() {
-
-        Table table = new Table();
-        table.addColumn(RealmFieldType.DATE, "date");
+        Table table = TestHelper.createTable(sharedRealm, "temp", new TestHelper.AdditionalTableSetup() {
+            @Override
+            public void execute(Table table) {
+                table.addColumn(RealmFieldType.DATE, "date");
 
-        table.add(new Date(10000));
-        table.add(new Date(0));
-        table.add(new Date(1000));
+                TestHelper.addRowWithValues(table, new Date(10000));
+                TestHelper.addRowWithValues(table, new Date(0));
+                TestHelper.addRowWithValues(table, new Date(1000));
+            }
+        });
 
         assertEquals(new Date(0), table.where().minimumDate(0));
     }
 
-    public void testDateQuery() throws Exception {
-
-        Table table = new Table();
-        table.addColumn(RealmFieldType.DATE, "date");
+    @Test
+    public void dateQuery() throws Exception {
 
         final Date past = new Date(TimeUnit.SECONDS.toMillis(Integer.MIN_VALUE - 100L));
         final Date future = new Date(TimeUnit.SECONDS.toMillis(Integer.MAX_VALUE + 1L));
         final Date distantPast = new Date(Long.MIN_VALUE);
         final Date distantFuture = new Date(Long.MAX_VALUE);
 
-        table.add(new Date(10000));
-        table.add(new Date(0));
-        table.add(new Date(1000));
-        table.add(future);
-        table.add(distantFuture);
-        table.add(past);
-        table.add(distantPast);
-
-        assertEquals(1L, table.where().equalTo(new long[]{0}, distantPast).count());
-        assertEquals(6L, table.where().notEqualTo(new long[]{0}, distantPast).count());
-        assertEquals(0L, table.where().lessThan(new long[]{0}, distantPast).count());
-        assertEquals(1L, table.where().lessThanOrEqual(new long[]{0}, distantPast).count());
-        assertEquals(6L, table.where().greaterThan(new long[]{0}, distantPast).count());
-        assertEquals(7L, table.where().greaterThanOrEqual(new long[]{0}, distantPast).count());
-
-        assertEquals(1L, table.where().equalTo(new long[]{0}, past).count());
-        assertEquals(6L, table.where().notEqualTo(new long[]{0}, past).count());
-        assertEquals(1L, table.where().lessThan(new long[]{0}, past).count());
-        assertEquals(2L, table.where().lessThanOrEqual(new long[]{0}, past).count());
-        assertEquals(5L, table.where().greaterThan(new long[]{0}, past).count());
-        assertEquals(6L, table.where().greaterThanOrEqual(new long[]{0}, past).count());
-
-        assertEquals(1L, table.where().equalTo(new long[]{0}, new Date(0)).count());
-        assertEquals(6L, table.where().notEqualTo(new long[]{0}, new Date(0)).count());
-        assertEquals(2L, table.where().lessThan(new long[]{0}, new Date(0)).count());
-        assertEquals(3L, table.where().lessThanOrEqual(new long[]{0}, new Date(0)).count());
-        assertEquals(4L, table.where().greaterThan(new long[]{0}, new Date(0)).count());
-        assertEquals(5L, table.where().greaterThanOrEqual(new long[]{0}, new Date(0)).count());
-
-        assertEquals(1L, table.where().equalTo(new long[]{0}, future).count());
-        assertEquals(6L, table.where().notEqualTo(new long[]{0}, future).count());
-        assertEquals(5L, table.where().lessThan(new long[]{0}, future).count());
-        assertEquals(6L, table.where().lessThanOrEqual(new long[]{0}, future).count());
-        assertEquals(1L, table.where().greaterThan(new long[]{0}, future).count());
-        assertEquals(2L, table.where().greaterThanOrEqual(new long[]{0}, future).count());
-
-        assertEquals(1L, table.where().equalTo(new long[]{0}, distantFuture).count());
-        assertEquals(6L, table.where().notEqualTo(new long[]{0}, distantFuture).count());
-        assertEquals(6L, table.where().lessThan(new long[]{0}, distantFuture).count());
-        assertEquals(7L, table.where().lessThanOrEqual(new long[]{0}, distantFuture).count());
-        assertEquals(0L, table.where().greaterThan(new long[]{0}, distantFuture).count());
-        assertEquals(1L, table.where().greaterThanOrEqual(new long[]{0}, distantFuture).count());
+        Table table = TestHelper.createTable(sharedRealm, "temp", new TestHelper.AdditionalTableSetup() {
+            @Override
+            public void execute(Table table) {
+                table.addColumn(RealmFieldType.DATE, "date");
+
+                TestHelper.addRowWithValues(table, new Date(10000));
+                TestHelper.addRowWithValues(table, new Date(0));
+                TestHelper.addRowWithValues(table, new Date(1000));
+                TestHelper.addRowWithValues(table, future);
+                TestHelper.addRowWithValues(table, distantFuture);
+                TestHelper.addRowWithValues(table, past);
+                TestHelper.addRowWithValues(table, distantPast);
+            }
+        });
+
+        assertEquals(1L, table.where().equalTo(new long[]{0}, oneNullTable, distantPast).count());
+        assertEquals(6L, table.where().notEqualTo(new long[]{0}, oneNullTable, distantPast).count());
+        assertEquals(0L, table.where().lessThan(new long[]{0}, oneNullTable, distantPast).count());
+        assertEquals(1L, table.where().lessThanOrEqual(new long[]{0}, oneNullTable, distantPast).count());
+        assertEquals(6L, table.where().greaterThan(new long[]{0}, oneNullTable, distantPast).count());
+        assertEquals(7L, table.where().greaterThanOrEqual(new long[]{0}, oneNullTable, distantPast).count());
+
+        assertEquals(1L, table.where().equalTo(new long[]{0}, oneNullTable, past).count());
+        assertEquals(6L, table.where().notEqualTo(new long[]{0}, oneNullTable, past).count());
+        assertEquals(1L, table.where().lessThan(new long[]{0}, oneNullTable, past).count());
+        assertEquals(2L, table.where().lessThanOrEqual(new long[]{0}, oneNullTable, past).count());
+        assertEquals(5L, table.where().greaterThan(new long[]{0}, oneNullTable, past).count());
+        assertEquals(6L, table.where().greaterThanOrEqual(new long[]{0}, oneNullTable, past).count());
+
+        assertEquals(1L, table.where().equalTo(new long[]{0}, oneNullTable, new Date(0)).count());
+        assertEquals(6L, table.where().notEqualTo(new long[]{0}, oneNullTable, new Date(0)).count());
+        assertEquals(2L, table.where().lessThan(new long[]{0}, oneNullTable, new Date(0)).count());
+        assertEquals(3L, table.where().lessThanOrEqual(new long[]{0}, oneNullTable, new Date(0)).count());
+        assertEquals(4L, table.where().greaterThan(new long[]{0}, oneNullTable, new Date(0)).count());
+        assertEquals(5L, table.where().greaterThanOrEqual(new long[]{0}, oneNullTable, new Date(0)).count());
+
+        assertEquals(1L, table.where().equalTo(new long[]{0}, oneNullTable, future).count());
+        assertEquals(6L, table.where().notEqualTo(new long[]{0}, oneNullTable, future).count());
+        assertEquals(5L, table.where().lessThan(new long[]{0}, oneNullTable, future).count());
+        assertEquals(6L, table.where().lessThanOrEqual(new long[]{0}, oneNullTable, future).count());
+        assertEquals(1L, table.where().greaterThan(new long[]{0}, oneNullTable, future).count());
+        assertEquals(2L, table.where().greaterThanOrEqual(new long[]{0}, oneNullTable, future).count());
+
+        assertEquals(1L, table.where().equalTo(new long[]{0}, oneNullTable, distantFuture).count());
+        assertEquals(6L, table.where().notEqualTo(new long[]{0}, oneNullTable, distantFuture).count());
+        assertEquals(6L, table.where().lessThan(new long[]{0}, oneNullTable, distantFuture).count());
+        assertEquals(7L, table.where().lessThanOrEqual(new long[]{0}, oneNullTable, distantFuture).count());
+        assertEquals(0L, table.where().greaterThan(new long[]{0}, oneNullTable, distantFuture).count());
+        assertEquals(1L, table.where().greaterThanOrEqual(new long[]{0}, oneNullTable, distantFuture).count());
 
         // between
 
@@ -735,29 +797,34 @@ public void testDateQuery() throws Exception {
         assertEquals(1L, table.where().between(new long[]{0}, distantFuture, distantFuture).count());
     }
 
-    public void testByteArrayQuery() throws Exception {
-
-        Table table = new Table();
-        table.addColumn(RealmFieldType.BINARY, "binary");
+    @Test
+    public void byteArrayQuery() throws Exception {
 
         final byte[] binary1 = new byte[] {0x01, 0x02, 0x03, 0x04};
         final byte[] binary2 = new byte[] {0x05, 0x02, 0x03, 0x08};
         final byte[] binary3 = new byte[] {0x09, 0x0a, 0x0b, 0x04};
         final byte[] binary4 = new byte[] {0x05, 0x0a, 0x0b, 0x10};
 
-        table.add((Object) binary1);
-        table.add((Object) binary2);
-        table.add((Object) binary3);
-        table.add((Object) binary4);
+        Table table = TestHelper.createTable(sharedRealm, "temp", new TestHelper.AdditionalTableSetup() {
+            @Override
+            public void execute(Table table) {
+                table.addColumn(RealmFieldType.BINARY, "binary");
+
+                TestHelper.addRowWithValues(table, (Object) binary1);
+                TestHelper.addRowWithValues(table, (Object) binary2);
+                TestHelper.addRowWithValues(table, (Object) binary3);
+                TestHelper.addRowWithValues(table, (Object) binary4);
+            }
+        });
 
         // Equal to
 
-        assertEquals(1L, table.where().equalTo(new long[]{0}, binary1).count());
-        assertEquals(1L, table.where().equalTo(new long[]{0}, binary3).count());
+        assertEquals(1L, table.where().equalTo(new long[]{0}, oneNullTable, binary1).count());
+        assertEquals(1L, table.where().equalTo(new long[]{0}, oneNullTable, binary3).count());
 
         // Not equal to
 
-        assertEquals(3L, table.where().notEqualTo(new long[]{0}, binary2).count());
-        assertEquals(3L, table.where().notEqualTo(new long[]{0}, binary4).count());
+        assertEquals(3L, table.where().notEqualTo(new long[]{0}, oneNullTable, binary2).count());
+        assertEquals(3L, table.where().notEqualTo(new long[]{0}, oneNullTable, binary4).count());
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIRowTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIRowTest.java
index 8b9c613d0b..371f8f2176 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIRowTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIRowTest.java
@@ -16,45 +16,89 @@
 
 package io.realm.internal;
 
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
 import android.test.MoreAsserts;
 
-import junit.framework.TestCase;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 
 import java.util.Date;
 
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
 import io.realm.RealmFieldType;
+import io.realm.TestHelper;
+import io.realm.rule.TestRealmConfigurationFactory;
 
-public class JNIRowTest extends TestCase {
+import static junit.framework.Assert.assertFalse;
+import static junit.framework.Assert.assertNull;
+import static junit.framework.Assert.assertTrue;
+import static org.junit.Assert.assertEquals;
 
-    public void testRow() {
 
-        Table table = new Table();
+@RunWith(AndroidJUnit4.class)
+public class JNIRowTest {
 
-        table.addColumn(RealmFieldType.STRING, "string");
-        table.addColumn(RealmFieldType.INTEGER, "integer");
-        table.addColumn(RealmFieldType.FLOAT, "float");
-        table.addColumn(RealmFieldType.DOUBLE, "double");
-        table.addColumn(RealmFieldType.BOOLEAN, "boolean");
-        table.addColumn(RealmFieldType.DATE, "date");
-        table.addColumn(RealmFieldType.BINARY, "binary");
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    @SuppressWarnings("FieldCanBeLocal")
+    private RealmConfiguration config;
+    private SharedRealm sharedRealm;
 
+    @Before
+    public void setUp() throws Exception {
+        Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
+        config = configFactory.createConfiguration();
+        sharedRealm = SharedRealm.getInstance(config);
 
-        byte[] data = new byte[2];
+        sharedRealm.beginTransaction();
+    }
+
+    @After
+    public void tearDown() {
+        if (sharedRealm != null && sharedRealm.isInTransaction()) {
+            sharedRealm.cancelTransaction();
+        }
 
-        table.add("abc", 3, (float) 1.2, 1.3, true, new Date(0), data);
+        if (sharedRealm != null && !sharedRealm.isClosed()) {
+            sharedRealm.close();
+        }
+    }
 
+    @Test
+    public void nonNullValues() {
+        final byte[] data = new byte[2];
+
+        Table table = TestHelper.createTable(sharedRealm, "temp", new TestHelper.AdditionalTableSetup() {
+            @Override
+            public void execute(Table table) {
+                table.addColumn(RealmFieldType.STRING, "string");
+                table.addColumn(RealmFieldType.INTEGER, "integer");
+                table.addColumn(RealmFieldType.FLOAT, "float");
+                table.addColumn(RealmFieldType.DOUBLE, "double");
+                table.addColumn(RealmFieldType.BOOLEAN, "boolean");
+                table.addColumn(RealmFieldType.DATE, "date");
+                table.addColumn(RealmFieldType.BINARY, "binary");
+
+                TestHelper.addRowWithValues(table, "abc", 3, (float) 1.2, 1.3, true, new Date(0), data);
+            }
+        });
 
         UncheckedRow row = table.getUncheckedRow(0);
 
         assertEquals("abc", row.getString(0));
         assertEquals(3, row.getLong(1));
-        assertEquals((float) 1.2, row.getFloat(2), 0.0001);
-        assertEquals(1.3, row.getDouble(3));
+        assertEquals(1.2F, row.getFloat(2), Float.MIN_NORMAL);
+        assertEquals(1.3, row.getDouble(3), Double.MIN_NORMAL);
         assertEquals(true, row.getBoolean(4));
         assertEquals(new Date(0), row.getDate(5));
         MoreAsserts.assertEquals(data, row.getBinaryByteArray(6));
 
-
         row.setString(0, "a");
         row.setLong(1, 1);
         row.setFloat(2, (float) 8.8);
@@ -67,17 +111,17 @@ public void testRow() {
 
         assertEquals("a", row.getString(0));
         assertEquals(1, row.getLong(1));
-        assertEquals((float) 8.8, row.getFloat(2), 0.0001);
-        assertEquals(9.9, row.getDouble(3));
+        assertEquals(8.8F, row.getFloat(2), Float.MIN_NORMAL);
+        assertEquals(9.9, row.getDouble(3), Double.MIN_NORMAL);
         assertEquals(false, row.getBoolean(4));
         assertEquals(new Date(10000), row.getDate(5));
         MoreAsserts.assertEquals(newData, row.getBinaryByteArray(6));
     }
 
-    public void testNull() {
-
-        Table table = new Table();
+    @Test
+    public void nullValues() {
 
+        Table table = TestHelper.createTable(sharedRealm, "temp");
         long colStringIndex = table.addColumn(RealmFieldType.STRING, "string", true);
         long colIntIndex = table.addColumn(RealmFieldType.INTEGER, "integer", true);
         table.addColumn(RealmFieldType.FLOAT, "float");
@@ -85,12 +129,12 @@ public void testNull() {
         long colBoolIndex = table.addColumn(RealmFieldType.BOOLEAN, "boolean", true);
         table.addColumn(RealmFieldType.DATE, "date");
         table.addColumn(RealmFieldType.BINARY, "binary");
+        long rowIndex = OsObject.createRow(table);
 
-        long rowIndex = table.addEmptyRow();
         UncheckedRow row = table.getUncheckedRow(rowIndex);
 
         row.setString(colStringIndex, "test");
-        assertEquals(row.getString(colStringIndex), "test");
+        assertEquals("test", row.getString(colStringIndex));
         row.setNull(colStringIndex);
         assertNull(row.getString(colStringIndex));
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNISortedLongTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNISortedLongTest.java
deleted file mode 100644
index 6c14e963b4..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNISortedLongTest.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import android.support.test.InstrumentationRegistry;
-
-import junit.framework.TestCase;
-
-import io.realm.Realm;
-import io.realm.RealmFieldType;
-
-public class JNISortedLongTest extends TestCase {
-    Table table;
-
-    void init() {
-        Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
-        table = new Table();
-        table.addColumn(RealmFieldType.INTEGER, "number");
-        table.addColumn(RealmFieldType.STRING, "name");
-
-        table.add(1, "A");
-        table.add(10, "B");
-        table.add(20, "C");
-        table.add(30, "B");
-        table.add(40, "D");
-        table.add(50, "D");
-        table.add(60, "D");
-        table.add(60, "D");
-
-        assertEquals(8, table.size());
-    }
-
-    public void testShouldTestSortedIntTable() {
-        init();
-
-        // Before first entry.
-        assertEquals(0, table.lowerBoundLong(0, 0));
-        assertEquals(0, table.upperBoundLong(0, 0));
-
-        // Finds middle match.
-        assertEquals(4, table.lowerBoundLong(0, 40));
-        assertEquals(5, table.upperBoundLong(0, 40));
-
-        // Finds middle (nonexisting).
-        assertEquals(5, table.lowerBoundLong(0, 41));
-        assertEquals(5, table.upperBoundLong(0, 41));
-
-        // Beyond last entry.
-        assertEquals(8, table.lowerBoundLong(0, 100));
-        assertEquals(8, table.upperBoundLong(0, 100));
-
-        // Finds last match (duplicated).
-        assertEquals(6, table.lowerBoundLong(0, 60));
-        assertEquals(8, table.upperBoundLong(0, 60));
-
-    }
-
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableInsertTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableInsertTest.java
index 1241e4ba64..c98458c169 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableInsertTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableInsertTest.java
@@ -16,6 +16,11 @@
 
 package io.realm.internal;
 
+import android.support.test.InstrumentationRegistry;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -26,8 +31,10 @@
 import java.util.Date;
 import java.util.List;
 
-import io.realm.RealmFieldType;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
 import io.realm.TestHelper;
+import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -36,11 +43,32 @@
 @RunWith(Parameterized.class)
 public class JNITableInsertTest {
 
-    List<Object> value = new ArrayList<Object>();
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    @SuppressWarnings("FieldCanBeLocal")
+    private RealmConfiguration config;
+    private SharedRealm sharedRealm;
+
+    private List<Object> value = new ArrayList<>();
+
+    @Before
+    public void setUp() throws Exception {
+        Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
+        config = configFactory.createConfiguration();
+        sharedRealm = SharedRealm.getInstance(config);
+    }
+
+    @After
+    public void tearDown() {
+        if (sharedRealm != null && !sharedRealm.isClosed()) {
+            sharedRealm.close();
+        }
+    }
 
     @Parameterized.Parameters
     public static Collection<Object[]> parameters() {
-        List<Object> value = new ArrayList<Object>();
+        List<Object> value = new ArrayList<>();
         value.add(0, true);
         value.add(1, "abc");
         value.add(2, 123L);
@@ -58,46 +86,31 @@ public JNITableInsertTest(List<Object> value) {
         this.value = value;
     }
 
-    @Test
-    public void testShouldThrowExceptionWhenColumnNameIsTooLong() {
-
-        Table table = new Table();
-        try {
-            table.addColumn(RealmFieldType.STRING, "THIS STRING HAS 64 CHARACTERS, "
-                    + "LONGER THAN THE MAX 63 CHARACTERS");
-            fail("Too long name");
-        } catch (IllegalArgumentException e) {
-        }
-    }
-
-    @Test
-    public void testWhenColumnNameIsExactly63CharLong() {
-
-        Table table = new Table();
-        table.addColumn(RealmFieldType.STRING, "THIS STRING HAS 63 CHARACTERS PERFECT FOR THE MAX 63 CHARACTERS");
-    }
-
     @Test
     public void testGenericAddOnTable() {
         for (int i = 0; i < value.size(); i++) {
             for (int j = 0; j < value.size(); j++) {
-
-                Table t = new Table();
-
-                // If the objects matches no exception will be thrown.
-                if (value.get(i).getClass().equals(value.get(j).getClass())) {
-                    assertTrue(true);
-
-                } else {
-                    // Adds column.
-                    t.addColumn(TestHelper.getColumnType(value.get(j)), value.get(j).getClass().getSimpleName());
-                    // Adds value.
-                    try {
-                        t.add(value.get(i));
-                        fail("No matching type");
-                    } catch (IllegalArgumentException e) {
+                final Object valueI = value.get(i);
+                final Object valueJ = value.get(j);
+
+                TestHelper.createTable(sharedRealm, "temp" + i + "_" + j, new TestHelper.AdditionalTableSetup() {
+                    @Override
+                    public void execute(Table t) {
+                        // If the objects matches no exception will be thrown.
+                        if (valueI.getClass().equals(valueJ.getClass())) {
+                            assertTrue(true);
+                        } else {
+                            // Adds column.
+                            t.addColumn(TestHelper.getColumnType(valueJ), valueJ.getClass().getSimpleName());
+                            // Adds value.
+                            try {
+                                TestHelper.addRowWithValues(t, valueI);
+                                fail("No matching type");
+                            } catch (IllegalArgumentException ignored) {
+                            }
+                        }
                     }
-                }
+                });
             }
         }
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
index e387e92c1f..dc61fbf252 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
@@ -19,6 +19,7 @@
 import android.support.test.runner.AndroidJUnit4;
 import android.util.Pair;
 
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -29,6 +30,7 @@
 import java.util.List;
 import java.util.ListIterator;
 import java.util.Locale;
+import java.util.concurrent.atomic.AtomicLong;
 
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
@@ -43,37 +45,52 @@
 import static junit.framework.Assert.assertTrue;
 import static junit.framework.Assert.fail;
 
+
 @RunWith(AndroidJUnit4.class)
 public class JNITableTest {
     @Rule
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
 
-    private Table t;
+    @SuppressWarnings("FieldCanBeLocal")
+    private RealmConfiguration config;
+    private SharedRealm sharedRealm;
 
     @Before
     public void setUp() {
-        t = new Table();
+        config = configFactory.createConfiguration();
+        sharedRealm = SharedRealm.getInstance(config);
+    }
+
+    @After
+    public void tearDown() {
+        if (sharedRealm != null)  {
+            sharedRealm.close();
+        }
     }
 
     @Test
     public void tableToString() {
-        Table t = new Table();
-
-        t.addColumn(RealmFieldType.STRING, "stringCol");
-        t.addColumn(RealmFieldType.INTEGER, "intCol");
-        t.addColumn(RealmFieldType.BOOLEAN, "boolCol");
-
-        t.add("s1", 1, true);
-        t.add("s2", 2, false);
+        Table t = TestHelper.createTable(sharedRealm, "temp", new TestHelper.AdditionalTableSetup() {
+            @Override
+            public void execute(Table t) {
+                t.addColumn(RealmFieldType.STRING, "stringCol");
+                t.addColumn(RealmFieldType.INTEGER, "intCol");
+                t.addColumn(RealmFieldType.BOOLEAN, "boolCol");
+
+                TestHelper.addRowWithValues(t, "s1", 1, true);
+                TestHelper.addRowWithValues(t, "s2", 2, false);
+            }
+        });
 
-        String expected = "The Table contains 3 columns: stringCol, intCol, boolCol. And 2 rows.";
+        String expected = "The Table temp contains 3 columns: stringCol, intCol, boolCol. And 2 rows.";
         assertEquals(expected, t.toString());
     }
 
     @Test
-    public void rowOperationsOnZeroRow(){
+    public void rowOperationsOnZeroRow() {
+        Table t = TestHelper.createTable(sharedRealm, "temp");
 
-        Table t = new Table();
+        sharedRealm.beginTransaction();
         // Removes rows without columns.
         try { t.moveLastOver(0);  fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
         try { t.moveLastOver(10); fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
@@ -82,46 +99,58 @@ public void rowOperationsOnZeroRow(){
         t.addColumn(RealmFieldType.STRING, "");
         try { t.moveLastOver(0);  fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
         try { t.moveLastOver(10); fail("No rows in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
-
+        sharedRealm.commitTransaction();
     }
 
     @Test
     public void zeroColOperations() {
-        Table tableZeroCols = new Table();
-
-        // Adds rows.
-        try { tableZeroCols.add("val");         fail("No columns in table"); } catch (IndexOutOfBoundsException ignored) {}
-        try { tableZeroCols.addEmptyRow();      fail("No columns in table"); } catch (IndexOutOfBoundsException ignored) {}
-        try { tableZeroCols.addEmptyRows(10);   fail("No columns in table"); } catch (IndexOutOfBoundsException ignored) {}
-
+        Table tableZeroCols = TestHelper.createTable(sharedRealm, "temp");
 
+        sharedRealm.beginTransaction();
         // Col operations
-        try { tableZeroCols.removeColumn(0);                fail("No columns in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
-        try { tableZeroCols.renameColumn(0, "newName");     fail("No columns in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
-        try { tableZeroCols.removeColumn(10);               fail("No columns in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
-        try { tableZeroCols.renameColumn(10, "newName");    fail("No columns in table"); } catch (ArrayIndexOutOfBoundsException ignored) {}
+        try {
+            tableZeroCols.removeColumn(0);
+            fail("No columns in table");
+        } catch (ArrayIndexOutOfBoundsException ignored) {}
+        try {
+            tableZeroCols.renameColumn(0, "newName");
+            fail("No columns in table");
+        } catch (ArrayIndexOutOfBoundsException ignored) {}
+        try {
+            tableZeroCols.removeColumn(10);
+            fail("No columns in table");
+        } catch (ArrayIndexOutOfBoundsException ignored) {}
+        try {
+            tableZeroCols.renameColumn(10, "newName");
+            fail("No columns in table");
+        } catch (ArrayIndexOutOfBoundsException ignored) {}
+        sharedRealm.commitTransaction();
     }
 
     @Test
     public void findFirstNonExisting() {
-        Table t = TestHelper.getTableWithAllColumnTypes();
-        t.add(new byte[]{1, 2, 3}, true, new Date(1384423149761L), 4.5d, 5.7f, 100, "string");
+        Table t = TestHelper.createTableWithAllColumnTypes(sharedRealm);
+        sharedRealm.beginTransaction();
+        TestHelper.addRowWithValues(t, new byte[] {1, 2, 3}, true, new Date(1384423149761L), 4.5D, 5.7F, 100, "string");
+        sharedRealm.commitTransaction();
 
         assertEquals(-1, t.findFirstBoolean(1, false));
-        // FIXME: reenable when core implements find_first_timestamp(): assertEquals(-1, t.findFirstDate(2, new Date(138442314986l)));
-        assertEquals(-1, t.findFirstDouble(3, 1.0d));
-        assertEquals(-1, t.findFirstFloat(4, 1.0f));
+        assertEquals(-1, t.findFirstDate(2, new Date(138442314986L)));
+        assertEquals(-1, t.findFirstDouble(3, 1.0D));
+        assertEquals(-1, t.findFirstFloat(4, 1.0F));
         assertEquals(-1, t.findFirstLong(5, 50));
     }
 
     @Test
     public void findFirst() {
         final int TEST_SIZE = 10;
-        Table t = TestHelper.getTableWithAllColumnTypes();
+        Table t = TestHelper.createTableWithAllColumnTypes(sharedRealm);
+        sharedRealm.beginTransaction();
         for (int i = 0; i < TEST_SIZE; i++) {
-            t.add(new byte[]{1,2,3}, true, new Date(i), (double)i, (float)i, i, "string " + i);
+            TestHelper.addRowWithValues(t, new byte[] {1, 2, 3}, true, new Date(i), (double) i, (float) i, i, "string " + i);
         }
-        t.add(new byte[]{1, 2, 3}, true, new Date(TEST_SIZE), (double) TEST_SIZE, (float) TEST_SIZE, TEST_SIZE, "");
+        TestHelper.addRowWithValues(t, new byte[] {1, 2, 3}, true, new Date(TEST_SIZE), (double) TEST_SIZE, (float) TEST_SIZE, TEST_SIZE, "");
+        sharedRealm.commitTransaction();
 
         assertEquals(0, t.findFirstBoolean(1, true));
         for (int i = 0; i < TEST_SIZE; i++) {
@@ -144,80 +173,154 @@ public void findFirst() {
 
     @Test
     public void getValuesFromNonExistingColumn() {
-        Table t = TestHelper.getTableWithAllColumnTypes();
-        t.addEmptyRows(10);
+        Table t = TestHelper.createTableWithAllColumnTypes(sharedRealm);
+        sharedRealm.beginTransaction();
+        for (int i = 0; i < 10; i++) {
+            OsObject.createRow(t);
+        }
+        sharedRealm.commitTransaction();
 
-        try { t.getBinaryByteArray(-1, 0);          fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getBinaryByteArray(-10, 0);         fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getBinaryByteArray(9, 0);           fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getBinaryByteArray(-1, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getBinaryByteArray(-10, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getBinaryByteArray(9, 0);
+            fail("Column does not exist");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
 
-        try { t.getBoolean(-1, 0);                  fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getBoolean(-10, 0);                 fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getBoolean(9, 0);                   fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getBoolean(-1, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getBoolean(-10, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getBoolean(9, 0);
+            fail("Column does not exist");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
 
-        try { t.getDate(-1, 0);                     fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getDate(-10, 0);                    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getDate(9, 0);                      fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getDate(-1, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getDate(-10, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getDate(9, 0);
+            fail("Column does not exist");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
 
-        try { t.getDouble(-1, 0);                   fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getDouble(-10, 0);                  fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getDouble(9, 0);                    fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getDouble(-1, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getDouble(-10, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getDouble(9, 0);
+            fail("Column does not exist");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
 
-        try { t.getFloat(-1, 0);                    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getFloat(-10, 0);                   fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getFloat(9, 0);                     fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getFloat(-1, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getFloat(-10, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getFloat(9, 0);
+            fail("Column does not exist");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
 
-        try { t.getLong(-1, 0);                     fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getLong(-10, 0);                    fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getLong(9, 0);                      fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getLong(-1, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getLong(-10, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getLong(9, 0);
+            fail("Column does not exist");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
 
-        try { t.getString(-1, 0);                   fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getString(-10, 0);                  fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException ignored) { }
-        try { t.getString(9, 0);                    fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getString(-1, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getString(-10, 0);
+            fail("Column is less than 0");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
+        try {
+            t.getString(9, 0);
+            fail("Column does not exist");
+        } catch (ArrayIndexOutOfBoundsException ignored) { }
     }
 
     @Test
     public void getNonExistingColumn() {
-        Table t = new Table();
-        t.addColumn(RealmFieldType.INTEGER, "int");
+        Table t = TestHelper.createTable(sharedRealm, "temp", new TestHelper.AdditionalTableSetup() {
+            @Override
+            public void execute(Table t) {
+                t.addColumn(RealmFieldType.INTEGER, "int");
+            }
+        });
 
         assertEquals(-1, t.getColumnIndex("non-existing column"));
-        try { t.getColumnIndex(null); fail("column name null"); } catch (IllegalArgumentException ignored) { }
+        try {
+            t.getColumnIndex(null);
+            fail("column name null");
+        } catch (IllegalArgumentException ignored) { }
     }
 
     @Test
     public void setNulls() {
-        Table t = new Table();
-        t.addColumn(RealmFieldType.STRING, "");
-        t.addColumn(RealmFieldType.DATE, "");
-        t.addColumn(RealmFieldType.BINARY, "");
-        t.add("String val", new Date(), new byte[]{1, 2, 3});
-
-        try { t.setString(0, 0, null, false);  fail("null string not allowed"); } catch (IllegalArgumentException ignored) { }
-        try { t.setDate(1, 0, null, false);    fail("null Date not allowed"); } catch (IllegalArgumentException ignored) { }
-    }
-
-    @Test
-    public void addNegativeEmptyRows() {
-        Table t = new Table();
-        t.addColumn(RealmFieldType.STRING, "colName");
+        Table t = TestHelper.createTable(sharedRealm, "temp", new TestHelper.AdditionalTableSetup() {
+            @Override
+            public void execute(Table t) {
+                t.addColumn(RealmFieldType.STRING, "");
+                t.addColumn(RealmFieldType.DATE, "");
+                t.addColumn(RealmFieldType.BINARY, "");
+                TestHelper.addRowWithValues(t, "String val", new Date(), new byte[] {1, 2, 3});
+            }
+        });
 
-        try { t.addEmptyRows(-1); fail("Argument is negative"); } catch (IllegalArgumentException ignored) { }
+        sharedRealm.beginTransaction();
+        try {
+            t.setString(0, 0, null, false);
+            fail("null string not allowed");
+        } catch (IllegalArgumentException ignored) { }
+        try {
+            t.setDate(1, 0, null, false);
+            fail("null Date not allowed");
+        } catch (IllegalArgumentException ignored) { }
+        sharedRealm.commitTransaction();
     }
 
     @Test
     public void getName() {
         String TABLE_NAME = "tableName";
-        RealmConfiguration configuration = configFactory.createConfiguration();
-        Realm.deleteRealm(configuration);
-
-        SharedRealm sharedRealm = SharedRealm.getInstance(configuration);
         //noinspection TryFinallyCanBeTryWithResources
         try {
 
             // Writes transaction must be run so we are sure a db exists with the correct table.
             sharedRealm.beginTransaction();
-            sharedRealm.getTable(TABLE_NAME);
+            sharedRealm.createTable(TABLE_NAME);
             sharedRealm.commitTransaction();
 
             Table table = sharedRealm.getTable(TABLE_NAME);
@@ -229,16 +332,18 @@ public void getName() {
 
     @Test
     public void shouldThrowWhenSetIndexOnWrongRealmFieldType() {
+        Table t = TestHelper.createTableWithAllColumnTypes(sharedRealm);
         for (long colIndex = 0; colIndex < t.getColumnCount(); colIndex++) {
 
             // All types supported addSearchIndex and removeSearchIndex.
             boolean exceptionExpected = (
-                            t.getColumnType(colIndex) != RealmFieldType.STRING &&
+                    t.getColumnType(colIndex) != RealmFieldType.STRING &&
                             t.getColumnType(colIndex) != RealmFieldType.INTEGER &&
                             t.getColumnType(colIndex) != RealmFieldType.BOOLEAN &&
                             t.getColumnType(colIndex) != RealmFieldType.DATE);
 
             // Tries to addSearchIndex().
+            sharedRealm.beginTransaction();
             try {
                 t.addSearchIndex(colIndex);
                 if (exceptionExpected) {
@@ -246,8 +351,10 @@ public void shouldThrowWhenSetIndexOnWrongRealmFieldType() {
                 }
             } catch (IllegalArgumentException ignored) {
             }
+            sharedRealm.commitTransaction();
 
             // Tries to removeSearchIndex().
+            sharedRealm.beginTransaction();
             try {
                 // Currently core will do nothing if the column doesn't have a search index.
                 t.removeSearchIndex(colIndex);
@@ -256,7 +363,7 @@ public void shouldThrowWhenSetIndexOnWrongRealmFieldType() {
                 }
             } catch (IllegalArgumentException ignored) {
             }
-
+            sharedRealm.commitTransaction();
 
             // Tries to hasSearchIndex() for all columnTypes.
             t.hasSearchIndex(colIndex);
@@ -265,54 +372,67 @@ public void shouldThrowWhenSetIndexOnWrongRealmFieldType() {
 
     @Test
     public void columnName() {
-        Table t = new Table();
-        try { t.addColumn(RealmFieldType.STRING, "I am 64 characters.............................................."); fail("Only 63 characters supported"); } catch (IllegalArgumentException ignored) { }
-        t.addColumn(RealmFieldType.STRING, "I am 63 characters.............................................");
+        TestHelper.createTable(sharedRealm, "temp", new TestHelper.AdditionalTableSetup() {
+            @Override
+            public void execute(Table t) {
+                try {
+                    t.addColumn(RealmFieldType.STRING, "I am 64 characters..............................................");
+                    fail("Only 63 characters supported");
+                } catch (IllegalArgumentException ignored) { }
+                t.addColumn(RealmFieldType.STRING, "I am 63 characters.............................................");
+            }
+        });
     }
 
     @Test
     public void tableNumbers() {
-        Table t = new Table();
-        t.addColumn(RealmFieldType.INTEGER, "intCol");
-        t.addColumn(RealmFieldType.DOUBLE, "doubleCol");
-        t.addColumn(RealmFieldType.FLOAT, "floatCol");
-        t.addColumn(RealmFieldType.STRING, "StringCol");
-
-        // Adds 3 rows of data with same values in each column.
-        t.add(1, 2.0d, 3.0f, "s1");
-        t.add(1, 2.0d, 3.0f, "s1");
-        t.add(1, 2.0d, 3.0f, "s1");
-
-        // Adds other values.
-        t.add(10, 20.0d, 30.0f, "s10");
-        t.add(100, 200.0d, 300.0f, "s100");
-        t.add(1000, 2000.0d, 3000.0f, "s1000");
+        Table t = TestHelper.createTable(sharedRealm, "temp", new TestHelper.AdditionalTableSetup() {
+            @Override
+            public void execute(Table t) {
+                t.addColumn(RealmFieldType.INTEGER, "intCol");
+                t.addColumn(RealmFieldType.DOUBLE, "doubleCol");
+                t.addColumn(RealmFieldType.FLOAT, "floatCol");
+                t.addColumn(RealmFieldType.STRING, "StringCol");
+
+                // Adds 3 rows of data with same values in each column.
+                TestHelper.addRowWithValues(t, 1, 2.0D, 3.0F, "s1");
+                TestHelper.addRowWithValues(t, 1, 2.0D, 3.0F, "s1");
+                TestHelper.addRowWithValues(t, 1, 2.0D, 3.0F, "s1");
+
+                // Adds other values.
+                TestHelper.addRowWithValues(t, 10, 20.0D, 30.0F, "s10");
+                TestHelper.addRowWithValues(t, 100, 200.0D, 300.0F, "s100");
+                TestHelper.addRowWithValues(t, 1000, 2000.0D, 3000.0F, "s1000");
+            }
+        });
 
         // Counts instances of values added in the first 3 rows.
         assertEquals(3, t.count(0, 1));
-        assertEquals(3, t.count(1, 2.0d));
-        assertEquals(3, t.count(2, 3.0f));
+        assertEquals(3, t.count(1, 2.0D));
+        assertEquals(3, t.count(2, 3.0F));
         assertEquals(3, t.count(3, "s1"));
 
 
-        assertEquals(3, t.findFirstDouble(1, 20.0d)); // Find rows index for first double value of 20.0 in column 1.
-        assertEquals(4, t.findFirstFloat(2, 300.0f)); // Find rows index for first float value of 300.0 in column 2.
+        assertEquals(3, t.findFirstDouble(1, 20.0D)); // Find rows index for first double value of 20.0 in column 1.
+        assertEquals(4, t.findFirstFloat(2, 300.0F)); // Find rows index for first float value of 300.0 in column 2.
 
         // Sets double and float.
-        t.setDouble(1, 2, -2.0d, false);
-        t.setFloat(2, 2, -3.0f, false);
+        sharedRealm.beginTransaction();
+        t.setDouble(1, 2, -2.0D, false);
+        t.setFloat(2, 2, -3.0F, false);
+        sharedRealm.commitTransaction();
 
         // Gets double tests.
-        assertEquals(-2.0d, t.getDouble(1, 2));
-        assertEquals(20.0d, t.getDouble(1, 3));
-        assertEquals(200.0d, t.getDouble(1, 4));
-        assertEquals(2000.0d, t.getDouble(1, 5));
+        assertEquals(-2.0D, t.getDouble(1, 2));
+        assertEquals(20.0D, t.getDouble(1, 3));
+        assertEquals(200.0D, t.getDouble(1, 4));
+        assertEquals(2000.0D, t.getDouble(1, 5));
 
         // Gets float test.
-        assertEquals(-3.0f, t.getFloat(2, 2));
-        assertEquals(30.0f, t.getFloat(2, 3));
-        assertEquals(300.0f, t.getFloat(2, 4));
-        assertEquals(3000.0f, t.getFloat(2, 5));
+        assertEquals(-3.0F, t.getFloat(2, 2));
+        assertEquals(30.0F, t.getFloat(2, 3));
+        assertEquals(300.0F, t.getFloat(2, 4));
+        assertEquals(3000.0F, t.getFloat(2, 5));
     }
 
     // Tests the migration of a string column to be nullable.
@@ -320,56 +440,68 @@ public void tableNumbers() {
     public void convertToNullable() {
         RealmFieldType[] columnTypes = {RealmFieldType.BOOLEAN, RealmFieldType.DATE, RealmFieldType.DOUBLE,
                 RealmFieldType.FLOAT, RealmFieldType.INTEGER, RealmFieldType.BINARY, RealmFieldType.STRING};
-        for (RealmFieldType columnType : columnTypes) {
+        int tableIndex = 0;
+        for (final RealmFieldType columnType : columnTypes) {
             // Tests various combinations of column names and nullability.
             String[] columnNames = {"foobar", "__TMP__0"};
-            for (boolean nullable : new boolean[]{Table.NOT_NULLABLE, Table.NULLABLE}) {
-                for (String columnName : columnNames) {
-                    Table table = new Table();
-                    long colIndex = table.addColumn(columnType, columnName, nullable);
-                    table.addColumn(RealmFieldType.BOOLEAN, "bool");
-                    table.addEmptyRow();
-                    if (columnType == RealmFieldType.BOOLEAN) {
-                        table.setBoolean(colIndex, 0, true, false);
-                    } else if (columnType == RealmFieldType.DATE) {
-                        table.setDate(colIndex, 0, new Date(0), false);
-                    } else if (columnType == RealmFieldType.DOUBLE) {
-                        table.setDouble(colIndex, 0, 1.0, false);
-                    } else if (columnType == RealmFieldType.FLOAT) {
-                        table.setFloat(colIndex, 0, 1.0f, false);
-                    } else if (columnType == RealmFieldType.INTEGER) {
-                        table.setLong(colIndex, 0, 1, false);
-                    } else if (columnType == RealmFieldType.BINARY) {
-                        table.setBinaryByteArray(colIndex, 0, new byte[]{0}, false);
-                    } else if (columnType == RealmFieldType.STRING) {
-                        table.setString(colIndex, 0, "Foo", false);
-                    }
-                    try {
-                        table.addEmptyRow();
-                        if (columnType == RealmFieldType.BINARY) {
-                            table.setBinaryByteArray(colIndex, 1, null, false);
-                        } else if (columnType == RealmFieldType.STRING) {
-                            table.setString(colIndex, 1, null, false);
-                        } else {
-                            table.getCheckedRow(1).setNull(colIndex);
+            for (final boolean nullable : new boolean[] {Table.NOT_NULLABLE, Table.NULLABLE}) {
+                for (final String columnName : columnNames) {
+                    final AtomicLong colIndexRef = new AtomicLong();
+                    Table table = TestHelper.createTable(sharedRealm, "temp" + tableIndex, new TestHelper.AdditionalTableSetup() {
+                        @Override
+                        public void execute(Table table) {
+                            long colIndex = table.addColumn(columnType, columnName, nullable);
+                            colIndexRef.set(colIndex);
+                            table.addColumn(RealmFieldType.BOOLEAN, "bool");
+                            OsObject.createRow(table);
+                            if (columnType == RealmFieldType.BOOLEAN) {
+                                table.setBoolean(colIndex, 0, true, false);
+                            } else if (columnType == RealmFieldType.DATE) {
+                                table.setDate(colIndex, 0, new Date(0), false);
+                            } else if (columnType == RealmFieldType.DOUBLE) {
+                                table.setDouble(colIndex, 0, 1.0, false);
+                            } else if (columnType == RealmFieldType.FLOAT) {
+                                table.setFloat(colIndex, 0, 1.0F, false);
+                            } else if (columnType == RealmFieldType.INTEGER) {
+                                table.setLong(colIndex, 0, 1, false);
+                            } else if (columnType == RealmFieldType.BINARY) {
+                                table.setBinaryByteArray(colIndex, 0, new byte[] {0}, false);
+                            } else if (columnType == RealmFieldType.STRING) {
+                                table.setString(colIndex, 0, "Foo", false);
+                            }
+                            try {
+                                OsObject.createRow(table);
+                                if (columnType == RealmFieldType.BINARY) {
+                                    table.setBinaryByteArray(colIndex, 1, null, false);
+                                } else if (columnType == RealmFieldType.STRING) {
+                                    table.setString(colIndex, 1, null, false);
+                                } else {
+                                    table.getCheckedRow(1).setNull(colIndex);
+                                }
+
+                                if (!nullable) {
+                                    fail();
+                                }
+                            } catch (IllegalArgumentException ignored) {
+                            }
+                            table.moveLastOver(table.size() - 1);
                         }
-
-                        if (!nullable) {
-                            fail();
-                        }
-                    } catch (IllegalArgumentException ignored) {
-                    }
-                    table.moveLastOver(table.size() - 1);
+                    });
                     assertEquals(1, table.size());
 
+                    long colIndex = colIndexRef.get();
+
+                    sharedRealm.beginTransaction();
                     table.convertColumnToNullable(colIndex);
+                    sharedRealm.commitTransaction();
                     assertTrue(table.isColumnNullable(colIndex));
                     assertEquals(1, table.size());
                     assertEquals(2, table.getColumnCount());
                     assertTrue(table.getColumnIndex(columnName) >= 0);
                     assertEquals(colIndex, table.getColumnIndex(columnName));
 
-                    table.addEmptyRow();
+                    sharedRealm.beginTransaction();
+                    OsObject.createRow(table);
                     if (columnType == RealmFieldType.BINARY) {
                         table.setBinaryByteArray(colIndex, 0, null, false);
                     } else if (columnType == RealmFieldType.STRING) {
@@ -377,6 +509,7 @@ public void convertToNullable() {
                     } else {
                         table.getCheckedRow(0).setNull(colIndex);
                     }
+                    sharedRealm.commitTransaction();
 
                     assertEquals(2, table.size());
 
@@ -387,6 +520,7 @@ public void convertToNullable() {
                     } else {
                         assertTrue(table.getUncheckedRow(1).isNull(colIndex));
                     }
+                    tableIndex++;
                 }
             }
         }
@@ -396,54 +530,65 @@ public void convertToNullable() {
     public void convertToNotNullable() {
         RealmFieldType[] columnTypes = {RealmFieldType.BOOLEAN, RealmFieldType.DATE, RealmFieldType.DOUBLE,
                 RealmFieldType.FLOAT, RealmFieldType.INTEGER, RealmFieldType.BINARY, RealmFieldType.STRING};
-        for (RealmFieldType columnType : columnTypes) {
+        int tableIndex = 0;
+        for (final RealmFieldType columnType : columnTypes) {
             // Tests various combinations of column names and nullability.
             String[] columnNames = {"foobar", "__TMP__0"};
-            for (boolean nullable : new boolean[]{Table.NOT_NULLABLE, Table.NULLABLE}) {
-                for (String columnName : columnNames) {
-                    Table table = new Table();
-                    long colIndex = table.addColumn(columnType, columnName, nullable);
-                    table.addColumn(RealmFieldType.BOOLEAN, "bool");
-                    table.addEmptyRow();
-                    if (columnType == RealmFieldType.BOOLEAN)
-                        table.setBoolean(colIndex, 0, true, false);
-                    else if (columnType == RealmFieldType.DATE)
-                        table.setDate(colIndex, 0, new Date(1), false);
-                    else if (columnType == RealmFieldType.DOUBLE)
-                        table.setDouble(colIndex, 0, 1.0, false);
-                    else if (columnType == RealmFieldType.FLOAT)
-                        table.setFloat(colIndex, 0, 1.0f, false);
-                    else if (columnType == RealmFieldType.INTEGER)
-                        table.setLong(colIndex, 0, 1, false);
-                    else if (columnType == RealmFieldType.BINARY)
-                        table.setBinaryByteArray(colIndex, 0, new byte[]{0}, false);
-                    else if (columnType == RealmFieldType.STRING)
-                        table.setString(colIndex, 0, "Foo", false);
-                    try {
-                        table.addEmptyRow();
-                        if (columnType == RealmFieldType.BINARY) {
-                            table.setBinaryByteArray(colIndex, 1, null, false);
-                        } else if (columnType == RealmFieldType.STRING) {
-                            table.setString(colIndex, 1, null, false);
-                        } else {
-                            table.getCheckedRow(1).setNull(colIndex);
+            for (final boolean nullable : new boolean[] {Table.NOT_NULLABLE, Table.NULLABLE}) {
+                for (final String columnName : columnNames) {
+                    final AtomicLong colIndexRef = new AtomicLong();
+                    Table table = TestHelper.createTable(sharedRealm, "temp" + tableIndex, new TestHelper.AdditionalTableSetup() {
+                        @Override
+                        public void execute(Table table) {
+                            long colIndex = table.addColumn(columnType, columnName, nullable);
+                            colIndexRef.set(colIndex);
+                            table.addColumn(RealmFieldType.BOOLEAN, "bool");
+                            OsObject.createRow(table);
+                            if (columnType == RealmFieldType.BOOLEAN) {
+                                table.setBoolean(colIndex, 0, true, false);
+                            } else if (columnType == RealmFieldType.DATE) {
+                                table.setDate(colIndex, 0, new Date(1), false);
+                            } else if (columnType == RealmFieldType.DOUBLE) {
+                                table.setDouble(colIndex, 0, 1.0, false);
+                            } else if (columnType == RealmFieldType.FLOAT) {
+                                table.setFloat(colIndex, 0, 1.0F, false);
+                            } else if (columnType == RealmFieldType.INTEGER) {
+                                table.setLong(colIndex, 0, 1, false);
+                            } else if (columnType == RealmFieldType.BINARY) {
+                                table.setBinaryByteArray(colIndex, 0, new byte[] {0}, false);
+                            } else if (columnType == RealmFieldType.STRING) { table.setString(colIndex, 0, "Foo", false); }
+                            try {
+                                OsObject.createRow(table);
+                                if (columnType == RealmFieldType.BINARY) {
+                                    table.setBinaryByteArray(colIndex, 1, null, false);
+                                } else if (columnType == RealmFieldType.STRING) {
+                                    table.setString(colIndex, 1, null, false);
+                                } else {
+                                    table.getCheckedRow(1).setNull(colIndex);
+                                }
+
+                                if (!nullable) {
+                                    fail();
+                                }
+                            } catch (IllegalArgumentException ignored) {
+                            }
                         }
-
-                        if (!nullable) {
-                            fail();
-                        }
-                    } catch (IllegalArgumentException ignored) {
-                    }
+                    });
                     assertEquals(2, table.size());
 
+                    long colIndex = colIndexRef.get();
+
+                    sharedRealm.beginTransaction();
                     table.convertColumnToNotNullable(colIndex);
+                    sharedRealm.commitTransaction();
                     assertFalse(table.isColumnNullable(colIndex));
                     assertEquals(2, table.size());
                     assertEquals(2, table.getColumnCount());
                     assertTrue(table.getColumnIndex(columnName) >= 0);
                     assertEquals(colIndex, table.getColumnIndex(columnName));
 
-                    table.addEmptyRow();
+                    sharedRealm.beginTransaction();
+                    OsObject.createRow(table);
                     try {
                         if (columnType == RealmFieldType.BINARY) {
                             table.setBinaryByteArray(colIndex, 0, null, false);
@@ -458,6 +603,8 @@ else if (columnType == RealmFieldType.STRING)
                     } catch (IllegalArgumentException ignored) {
                     }
                     table.moveLastOver(table.size() -1);
+                    sharedRealm.commitTransaction();
+
                     assertEquals(2, table.size());
 
                     if (columnType == RealmFieldType.BINARY) {
@@ -467,17 +614,19 @@ else if (columnType == RealmFieldType.STRING)
                         assertEquals("", table.getString(colIndex, 1));
                     } else {
                         assertFalse(table.getUncheckedRow(1).isNull(colIndex));
-                        if (columnType == RealmFieldType.BOOLEAN)
+                        if (columnType == RealmFieldType.BOOLEAN) {
                             assertEquals(false, table.getBoolean(colIndex, 1));
-                        else if (columnType == RealmFieldType.DATE)
+                        } else if (columnType == RealmFieldType.DATE) {
                             assertEquals(0, table.getDate(colIndex, 1).getTime());
-                        else if (columnType == RealmFieldType.DOUBLE)
+                        } else if (columnType == RealmFieldType.DOUBLE) {
                             assertEquals(0.0, table.getDouble(colIndex, 1));
-                        else if (columnType == RealmFieldType.FLOAT)
-                            assertEquals(0.0f, table.getFloat(colIndex, 1));
-                        else if (columnType == RealmFieldType.INTEGER)
+                        } else if (columnType == RealmFieldType.FLOAT) {
+                            assertEquals(0.0F, table.getFloat(colIndex, 1));
+                        } else if (columnType == RealmFieldType.INTEGER) {
                             assertEquals(0, table.getLong(colIndex, 1));
+                        }
                     }
+                    tableIndex++;
                 }
             }
         }
@@ -486,9 +635,13 @@ else if (columnType == RealmFieldType.INTEGER)
     // Adds column and read back if it is nullable or not.
     @Test
     public void isNullable() {
-        Table table = new Table();
-        table.addColumn(RealmFieldType.STRING, "string1", Table.NOT_NULLABLE);
-        table.addColumn(RealmFieldType.STRING, "string2", Table.NULLABLE);
+        Table table = TestHelper.createTable(sharedRealm, "temp", new TestHelper.AdditionalTableSetup() {
+            @Override
+            public void execute(Table table) {
+                table.addColumn(RealmFieldType.STRING, "string1", Table.NOT_NULLABLE);
+                table.addColumn(RealmFieldType.STRING, "string2", Table.NULLABLE);
+            }
+        });
 
         assertFalse(table.isColumnNullable(0));
         assertTrue(table.isColumnNullable(1));
@@ -496,26 +649,24 @@ public void isNullable() {
 
     @Test
     public void defaultValue_setAndGet() {
-        // t is not used in this test.
-        t = null;
         final SharedRealm sharedRealm = SharedRealm.getInstance(configFactory.createConfiguration());
         //noinspection TryFinallyCanBeTryWithResources
         try {
             sharedRealm.beginTransaction();
-            final Table table = sharedRealm.getTable(Table.TABLE_PREFIX + "DefaultValueTest");
+            final Table table = sharedRealm.createTable(Table.getTableNameForClass("DefaultValueTest"));
             sharedRealm.commitTransaction();
 
             List<Pair<RealmFieldType, Object>> columnInfoList = Arrays.asList(
                     new Pair<RealmFieldType, Object>(RealmFieldType.STRING, "string value"),
                     new Pair<RealmFieldType, Object>(RealmFieldType.INTEGER, 100L),
                     new Pair<RealmFieldType, Object>(RealmFieldType.BOOLEAN, true),
-                    new Pair<RealmFieldType, Object>(RealmFieldType.BINARY, new byte[]{123}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.BINARY, new byte[] {123}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.DATE, new Date(123456)),
-                    new Pair<RealmFieldType, Object>(RealmFieldType.FLOAT, 1.234f),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.FLOAT, 1.234F),
                     new Pair<RealmFieldType, Object>(RealmFieldType.DOUBLE, Math.PI),
                     new Pair<RealmFieldType, Object>(RealmFieldType.OBJECT, 0L)
-                    // Currently, LIST does not support default value.
-                    // new Pair<RealmFieldType, Object>(RealmFieldType.LIST, )
+                    // FIXME: Currently, LIST does not support default value.
+                    // new CollectionChange<RealmFieldType, Object>(RealmFieldType.LIST, )
             );
 
             for (Pair<RealmFieldType, Object> columnInfo : columnInfoList) {
@@ -528,7 +679,7 @@ public void defaultValue_setAndGet() {
             }
 
             sharedRealm.beginTransaction();
-            table.addEmptyRow();
+            OsObject.createRow(table);
 
             ListIterator<Pair<RealmFieldType, Object>> it = columnInfoList.listIterator();
             for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
@@ -619,26 +770,24 @@ public void defaultValue_setAndGet() {
 
     @Test
     public void defaultValue_setMultipleTimes() {
-        // t is not used in this test.
-        t = null;
         final SharedRealm sharedRealm = SharedRealm.getInstance(configFactory.createConfiguration());
         //noinspection TryFinallyCanBeTryWithResources
         try {
             sharedRealm.beginTransaction();
-            final Table table = sharedRealm.getTable(Table.TABLE_PREFIX + "DefaultValueTest");
+            final Table table = sharedRealm.createTable(Table.getTableNameForClass("DefaultValueTest"));
             sharedRealm.commitTransaction();
 
             List<Pair<RealmFieldType, Object>> columnInfoList = Arrays.asList(
                     new Pair<RealmFieldType, Object>(RealmFieldType.STRING, new String[] {"string value1", "string value2"}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.INTEGER, new Long[] {100L, 102L}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.BOOLEAN, new Boolean[] {false, true}),
-                    new Pair<RealmFieldType, Object>(RealmFieldType.BINARY, new byte[][] {new byte[]{123}, new byte[]{-123}}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.BINARY, new byte[][] {new byte[] {123}, new byte[] {-123}}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.DATE, new Date[] {new Date(123456), new Date(13579)}),
-                    new Pair<RealmFieldType, Object>(RealmFieldType.FLOAT, new Float[] {1.234f, 100f}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.FLOAT, new Float[] {1.234F, 100F}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.DOUBLE, new Double[] {Math.PI, Math.E}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.OBJECT, new Long[] {0L, 1L})
-                    // Currently, LIST does not support default value.
-                    // new Pair<RealmFieldType, Object>(RealmFieldType.LIST, )
+                    // FIXME: Currently, LIST does not support default value.
+                    // new CollectionChange<RealmFieldType, Object>(RealmFieldType.LIST, )
             );
 
             for (Pair<RealmFieldType, Object> columnInfo : columnInfoList) {
@@ -651,8 +800,8 @@ public void defaultValue_setMultipleTimes() {
             }
 
             sharedRealm.beginTransaction();
-            table.addEmptyRow();
-            table.addEmptyRow(); // For link field update.
+            OsObject.createRow(table);
+            OsObject.createRow(table); // For link field update.
 
             ListIterator<Pair<RealmFieldType, Object>> it = columnInfoList.listIterator();
             for (int columnIndex = 0; columnIndex < columnInfoList.size(); columnIndex++) {
@@ -751,26 +900,24 @@ public void defaultValue_setMultipleTimes() {
 
     @Test
     public void defaultValue_overwrittenByNonDefault() {
-        // t is not used in this test.
-        t = null;
         final SharedRealm sharedRealm = SharedRealm.getInstance(configFactory.createConfiguration());
         //noinspection TryFinallyCanBeTryWithResources
         try {
             sharedRealm.beginTransaction();
-            final Table table = sharedRealm.getTable(Table.TABLE_PREFIX + "DefaultValueTest");
+            final Table table = sharedRealm.createTable(Table.getTableNameForClass("DefaultValueTest"));
             sharedRealm.commitTransaction();
 
             List<Pair<RealmFieldType, Object>> columnInfoList = Arrays.asList(
                     new Pair<RealmFieldType, Object>(RealmFieldType.STRING, new String[] {"string value1", "string value2"}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.INTEGER, new Long[] {100L, 102L}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.BOOLEAN, new Boolean[] {false, true}),
-                    new Pair<RealmFieldType, Object>(RealmFieldType.BINARY, new byte[][] {new byte[]{123}, new byte[]{-123}}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.BINARY, new byte[][] {new byte[] {123}, new byte[] {-123}}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.DATE, new Date[] {new Date(123456), new Date(13579)}),
-                    new Pair<RealmFieldType, Object>(RealmFieldType.FLOAT, new Float[] {1.234f, 100f}),
+                    new Pair<RealmFieldType, Object>(RealmFieldType.FLOAT, new Float[] {1.234F, 100F}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.DOUBLE, new Double[] {Math.PI, Math.E}),
                     new Pair<RealmFieldType, Object>(RealmFieldType.OBJECT, new Long[] {0L, 1L})
-                    // Currently, LIST does not support default value.
-                    // new Pair<RealmFieldType, Object>(RealmFieldType.LIST, )
+                    // FIXME: Currently, LIST does not support default value.
+                    // new CollectionChange<RealmFieldType, Object>(RealmFieldType.LIST, )
             );
 
             for (Pair<RealmFieldType, Object> columnInfo : columnInfoList) {
@@ -783,8 +930,8 @@ public void defaultValue_overwrittenByNonDefault() {
             }
 
             sharedRealm.beginTransaction();
-            table.addEmptyRow();
-            table.addEmptyRow(); // For link field update.
+            OsObject.createRow(table);
+            OsObject.createRow(table); // For link field update.
 
             // Sets as default.
             ListIterator<Pair<RealmFieldType, Object>> it = columnInfoList.listIterator();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/ObserverPairListTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/ObserverPairListTests.java
index a36ec5b8df..fb77df3b1e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/ObserverPairListTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/ObserverPairListTests.java
@@ -39,8 +39,8 @@
 @RunWith(AndroidJUnit4.class)
 public class ObserverPairListTests {
 
-    private static class TestListener<Integer> {
-        void onChange(Integer integer) {
+    private static class TestListener<T> {
+        void onChange(T integer) {
         }
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/OsListTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/OsListTests.java
new file mode 100644
index 0000000000..b5ff28356a
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/OsListTests.java
@@ -0,0 +1,484 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+import io.realm.RealmConfiguration;
+import io.realm.RealmFieldType;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertNotNull;
+import static junit.framework.Assert.fail;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+@RunWith(AndroidJUnit4.class)
+public class OsListTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    private SharedRealm sharedRealm;
+    private UncheckedRow row;
+    private OsObjectSchemaInfo testObjectSchemaInfo;
+
+    @Before
+    public void setUp() {
+        OsObjectSchemaInfo objectSchemaInfo = new OsObjectSchemaInfo.Builder("TestModel",14, 0)
+                .addPersistedValueListProperty("longList", RealmFieldType.INTEGER_LIST, !Property.REQUIRED)
+                .addPersistedValueListProperty("doubleList", RealmFieldType.DOUBLE_LIST,  !Property.REQUIRED)
+                .addPersistedValueListProperty("floatList", RealmFieldType.FLOAT_LIST, !Property.REQUIRED)
+                .addPersistedValueListProperty("booleanList", RealmFieldType.BOOLEAN_LIST, !Property.REQUIRED)
+                .addPersistedValueListProperty("binaryList", RealmFieldType.BINARY_LIST, !Property.REQUIRED)
+                .addPersistedValueListProperty("dateList", RealmFieldType.DATE_LIST, !Property.REQUIRED)
+                .addPersistedValueListProperty("stringList", RealmFieldType.STRING_LIST, !Property.REQUIRED)
+
+                .addPersistedValueListProperty("requiredLongList", RealmFieldType.INTEGER_LIST, Property.REQUIRED)
+                .addPersistedValueListProperty("requiredDoubleList", RealmFieldType.DOUBLE_LIST, Property.REQUIRED)
+                .addPersistedValueListProperty("requiredFloatList", RealmFieldType.FLOAT_LIST, Property.REQUIRED)
+                .addPersistedValueListProperty("requiredBooleanList", RealmFieldType.BOOLEAN_LIST, Property.REQUIRED)
+                .addPersistedValueListProperty("requiredBinaryList", RealmFieldType.BINARY_LIST, Property.REQUIRED)
+                .addPersistedValueListProperty("requiredDateList", RealmFieldType.DATE_LIST, Property.REQUIRED)
+                .addPersistedValueListProperty("requiredStringList", RealmFieldType.STRING_LIST, Property.REQUIRED)
+
+                .build();
+        List<OsObjectSchemaInfo> objectSchemaInfoList = new ArrayList<OsObjectSchemaInfo>();
+        objectSchemaInfoList.add(objectSchemaInfo);
+
+        OsSchemaInfo schemaInfo = new OsSchemaInfo(objectSchemaInfoList);
+
+        RealmConfiguration config = configFactory.createConfiguration();
+        OsRealmConfig.Builder configBuilder = new OsRealmConfig.Builder(config)
+                .autoUpdateNotification(true)
+                .schemaInfo(schemaInfo);
+        sharedRealm = SharedRealm.getInstance(configBuilder);
+        sharedRealm.beginTransaction();
+        Table table = sharedRealm.getTable(Table.getTableNameForClass("TestModel"));
+        row = table.getUncheckedRow(OsObject.createRow(table));
+        sharedRealm.commitTransaction();
+
+        schemaInfo = sharedRealm.getSchemaInfo();
+        testObjectSchemaInfo = schemaInfo.getObjectSchemaInfo("TestModel");
+
+        sharedRealm.beginTransaction();
+    }
+
+    @After
+    public void tearDown() {
+        sharedRealm.cancelTransaction();
+        sharedRealm.close();
+    }
+
+    private void addNull_insertNull_setNull_nullableList(OsList osList) {
+        assertNotNull(osList.getValue(1));
+        osList.insertNull(1);
+        assertNull(osList.getValue(1));
+
+        osList.addNull();
+        assertNull(osList.getValue(osList.size() - 1));
+
+        assertNotNull(osList.getValue(2));
+        osList.setNull(2);
+        assertNull(osList.getValue(2));
+    }
+
+    private void addNull_insertNull_setNull_requiredList(OsList osList) {
+        long initialSize = osList.size();
+        try {
+            osList.insertNull(0);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+            assertEquals(initialSize, osList.size());
+        }
+
+        initialSize = osList.size();
+        try {
+            osList.addNull();
+            fail();
+        } catch (IllegalArgumentException ignored) {
+            assertEquals(initialSize, osList.size());
+        }
+
+        initialSize = osList.size();
+        try {
+            osList.setNull(0);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+            assertEquals(initialSize, osList.size());
+        }
+    }
+
+    private void add_insert_set_values_long(OsList osList) {
+        osList.addLong(42);
+        Long value = (Long) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals(42, value.longValue());
+
+        osList.insertLong(0, 24);
+        value = (Long) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals(24, value.longValue());
+
+        osList.setLong(0, 42);
+        value = (Long) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals(42, value.longValue());
+    }
+
+    @Test
+    public void add_insert_set_get_Long() {
+        long index = testObjectSchemaInfo.getProperty("longList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        add_insert_set_values_long(osList);
+        addNull_insertNull_setNull_nullableList(osList);
+    }
+
+    @Test
+    public void add_insert_get_set_required_Long() {
+        long index = testObjectSchemaInfo.getProperty("requiredLongList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        add_insert_set_values_long(osList);
+        addNull_insertNull_setNull_requiredList(osList);
+    }
+
+    private void add_insert_set_values_double(OsList osList) {
+        osList.addDouble(42d);
+        Double value = (Double) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals(42d, value.doubleValue(), 0d);
+
+        osList.insertDouble(0, 24);
+        value = (Double) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals(24d, value.longValue(), 0d);
+
+        osList.setDouble(0, 42);
+        value = (Double) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals(42d, value.longValue(), 0d);
+    }
+
+    @Test
+    public void add_insert_set_get_Double() {
+        long index = testObjectSchemaInfo.getProperty("doubleList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        add_insert_set_values_double(osList);
+        addNull_insertNull_setNull_nullableList(osList);
+    }
+
+    @Test
+    public void add_insert_set_get_required_Double() {
+        long index = testObjectSchemaInfo.getProperty("requiredDoubleList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        add_insert_set_values_double(osList);
+        addNull_insertNull_setNull_requiredList(osList);
+    }
+
+    private void add_insert_set_values_float(OsList osList) {
+        osList.addFloat(42f);
+        Float value = (Float) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals(42f, value.doubleValue(), 0f);
+
+        osList.insertFloat(0, 24f);
+        value = (Float) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals(24f, value.longValue(), 0f);
+
+        osList.setFloat(0, 42f);
+        value = (Float) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals(42f, value.longValue(), 0f);
+    }
+
+    @Test
+    public void add_insert_get_Float() {
+        long index = testObjectSchemaInfo.getProperty("floatList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        add_insert_set_values_float(osList);
+        addNull_insertNull_setNull_nullableList(osList);
+    }
+
+    @Test
+    public void add_insert_get_required_Float() {
+        long index = testObjectSchemaInfo.getProperty("requiredFloatList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        add_insert_set_values_float(osList);
+        addNull_insertNull_setNull_requiredList(osList);
+    }
+
+    private void add_insert_set_values_boolean(OsList osList) {
+        osList.addBoolean(true);
+        Boolean value = (Boolean) osList.getValue(0);
+        assertNotNull(value);
+        assertTrue(value);
+
+        osList.insertBoolean(0, false);
+        value = (Boolean) osList.getValue(0);
+        assertNotNull(value);
+        assertFalse(value);
+
+        osList.setBoolean(0, true);
+        value = (Boolean) osList.getValue(0);
+        assertNotNull(value);
+        assertTrue(value);
+    }
+
+    @Test
+    public void add_insert_set_get_Boolean() {
+        long index = testObjectSchemaInfo.getProperty("booleanList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        add_insert_set_values_boolean(osList);
+        addNull_insertNull_setNull_nullableList(osList);
+    }
+
+    @Test
+    public void add_insert_set_get_required_Boolean() {
+        long index = testObjectSchemaInfo.getProperty("requiredBooleanList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        add_insert_set_values_boolean(osList);
+        addNull_insertNull_setNull_requiredList(osList);
+    }
+
+    @Test
+    public void add_insert_set_get_Date() {
+        long index = testObjectSchemaInfo.getProperty("dateList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        Date date42 = new Date(42);
+        Date date24 = new Date(24);
+
+        osList.addDate(null);
+        Date value = (Date) osList.getValue(0);
+        assertNull(value);
+
+        osList.addDate(date42);
+        value = (Date) osList.getValue(1);
+        assertNotNull(value);
+        assertEquals(date42, value);
+
+        osList.insertDate(0, null);
+        value = (Date) osList.getValue(0);
+        assertNull(value);
+
+        osList.insertDate(0, date24);
+        value = (Date) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals(date24, value);
+
+        osList.insertNull(0);
+        value = (Date) osList.getValue(0);
+        assertNull(value);
+
+        osList.addNull();
+        assertNull(osList.getValue(5));
+
+        osList.setDate(5, date42);
+        value = (Date) osList.getValue(5);
+        assertNotNull(value);
+        assertEquals(date42, value);
+
+        osList.setDate(5, null);
+        value = (Date) osList.getValue(5);
+        assertNull(value);
+    }
+
+    @Test
+    public void add_insert_set_null_required_Date() {
+        long index = testObjectSchemaInfo.getProperty("requiredDateList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        addNull_insertNull_setNull_requiredList(osList);
+
+        try {
+            osList.insertDate(0, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        try {
+            osList.addDate(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        try {
+            osList.setDate(0, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void add_insert_get_String() {
+        long index = testObjectSchemaInfo.getProperty("stringList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        osList.addString(null);
+        String value = (String) osList.getValue(0);
+        assertNull(value);
+
+        osList.addString("42");
+        value = (String) osList.getValue(1);
+        assertNotNull(value);
+        assertEquals("42", value);
+
+        osList.insertString(0, null);
+        value = (String) osList.getValue(0);
+        assertNull(value);
+
+        osList.insertString(0, "24");
+        value = (String) osList.getValue(0);
+        assertNotNull(value);
+        assertEquals("24", value);
+
+        osList.insertNull(0);
+        value = (String) osList.getValue(0);
+        assertNull(value);
+
+        osList.addNull();
+        assertNull(osList.getValue(5));
+
+        osList.setString(5, "24");
+        value = (String) osList.getValue(5);
+        assertNotNull(value);
+        assertEquals("24", value);
+
+        osList.setString(5, null);
+        value = (String) osList.getValue(5);
+        assertNull(value);
+    }
+
+    @Test
+    public void add_insert_set_null_required_String() {
+        long index = testObjectSchemaInfo.getProperty("requiredStringList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        addNull_insertNull_setNull_requiredList(osList);
+
+        try {
+            osList.insertString(0, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        try {
+            osList.addString(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        try {
+            osList.setString(0, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void add_insert_get_Binary() {
+        long index = testObjectSchemaInfo.getProperty("binaryList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        byte[] bytes42 = new byte[1];
+        bytes42[0] = 42;
+        byte[] bytes24 = new byte[2];
+        bytes24[0] = 24;
+        bytes24[1] = 24;
+
+        osList.addBinary(null);
+        byte[] value = (byte[]) osList.getValue(0);
+        assertNull(value);
+
+        osList.addBinary(bytes42);
+        value = (byte[]) osList.getValue(1);
+        assertNotNull(value);
+        assertArrayEquals(bytes42, value);
+
+        osList.insertBinary(0, null);
+        value = (byte[]) osList.getValue(0);
+        assertNull(value);
+
+        osList.insertBinary(0, bytes24);
+        value = (byte[]) osList.getValue(0);
+        assertNotNull(value);
+        assertArrayEquals(bytes24, value);
+
+        osList.insertNull(0);
+        value = (byte[]) osList.getValue(0);
+        assertNull(value);
+
+        osList.addNull();
+        assertNull(osList.getValue(5));
+
+        osList.setBinary(5, bytes24);
+        value = (byte[]) osList.getValue(5);
+        assertNotNull(value);
+        assertArrayEquals(bytes24, value);
+
+        osList.setBinary(5, null);
+        value = (byte[]) osList.getValue(5);
+        assertNull(value);
+    }
+
+    @Test
+    public void add_insert_set_null_required_Binary() {
+        long index = testObjectSchemaInfo.getProperty("requiredBinaryList").getColumnIndex();
+        OsList osList = new OsList(row, index);
+
+        addNull_insertNull_setNull_requiredList(osList);
+
+        try {
+            osList.insertBinary(0, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        try {
+            osList.addBinary(null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        try {
+            osList.setBinary(0, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/OsObjectStoreTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/OsObjectStoreTests.java
new file mode 100644
index 0000000000..cb9e620b1b
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/OsObjectStoreTests.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import io.realm.RealmConfiguration;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertFalse;
+import static junit.framework.Assert.assertTrue;
+import static junit.framework.Assert.fail;
+
+// Tests for OsObjectStore
+@RunWith(AndroidJUnit4.class)
+public class OsObjectStoreTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    @Test
+    public void callWithLock() {
+        RealmConfiguration config = configFactory.createConfiguration();
+
+        // Return false if there are opened SharedRealm instance
+        SharedRealm sharedRealm = SharedRealm.getInstance(config);
+        assertFalse(OsObjectStore.callWithLock(config, new Runnable() {
+            @Override
+            public void run() {
+                fail();
+            }
+        }));
+        sharedRealm.close();
+
+        final AtomicBoolean callbackCalled = new AtomicBoolean(false);
+        assertTrue(OsObjectStore.callWithLock(config, new Runnable() {
+            @Override
+            public void run() {
+                callbackCalled.set(true);
+            }
+        }));
+        assertTrue(callbackCalled.get());
+    }
+
+    // Test if a java exception can be thrown from the callback.
+    @Test
+    public void callWithLock_throwInCallback() {
+        RealmConfiguration config = configFactory.createConfiguration();
+        final RuntimeException exception = new RuntimeException();
+
+        try {
+            OsObjectStore.callWithLock(config, new Runnable() {
+                @Override
+                public void run() {
+                    throw exception;
+                }
+            });
+            fail();
+        } catch (RuntimeException e) {
+            assertEquals(exception, e);
+        }
+
+        // The lock should be released after exception thrown
+        final AtomicBoolean callbackCalled = new AtomicBoolean(false);
+        assertTrue(OsObjectStore.callWithLock(config, new Runnable() {
+            @Override
+            public void run() {
+                callbackCalled.set(true);
+            }
+        }));
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/OsResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/OsResultsTests.java
new file mode 100644
index 0000000000..c81e4c1aed
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/OsResultsTests.java
@@ -0,0 +1,553 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import java.lang.ref.WeakReference;
+import java.util.ConcurrentModificationException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import io.realm.RealmChangeListener;
+import io.realm.RealmConfiguration;
+import io.realm.RealmFieldType;
+import io.realm.TestHelper;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertFalse;
+import static junit.framework.Assert.assertTrue;
+import static junit.framework.Assert.fail;
+
+
+@RunWith(AndroidJUnit4.class)
+public class OsResultsTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    private final long[] oneNullTable = new long[] {NativeObject.NULLPTR};
+
+    private SharedRealm sharedRealm;
+    private Table table;
+
+    @Before
+    public void setUp() {
+        sharedRealm = getSharedRealm();
+        populateData(sharedRealm);
+    }
+
+    @After
+    public void tearDown() {
+        sharedRealm.close();
+    }
+
+    private SharedRealm getSharedRealm() {
+        RealmConfiguration config = configFactory.createConfiguration();
+        return getSharedRealm(config);
+    }
+
+    private SharedRealm getSharedRealmForLooper() {
+        RealmConfiguration config = looperThread.createConfiguration();
+        return getSharedRealm(config);
+    }
+
+    private SharedRealm getSharedRealm(RealmConfiguration config) {
+        OsRealmConfig.Builder configBuilder = new OsRealmConfig.Builder(config)
+                .autoUpdateNotification(true);
+        SharedRealm sharedRealm = SharedRealm.getInstance(configBuilder);
+        sharedRealm.beginTransaction();
+        OsObjectStore.setSchemaVersion(sharedRealm, OsObjectStore.SCHEMA_NOT_VERSIONED);
+        sharedRealm.commitTransaction();
+        return sharedRealm;
+    }
+
+    private Table getTable(SharedRealm sharedRealm) {
+        return sharedRealm.getTable(Table.getTableNameForClass("test_table"));
+    }
+
+    private void populateData(SharedRealm sharedRealm) {
+        sharedRealm.beginTransaction();
+        table = sharedRealm.createTable(Table.getTableNameForClass("test_table"));
+        // Specify the column types and names
+        long columnIdx = table.addColumn(RealmFieldType.STRING, "firstName");
+        table.addSearchIndex(columnIdx);
+        table.addColumn(RealmFieldType.STRING, "lastName");
+        table.addColumn(RealmFieldType.INTEGER, "age");
+
+        // Add data to the table
+        long row = OsObject.createRow(table);
+        table.setString(0, row, "John", false);
+        table.setString(1, row, "Lee", false);
+        table.setLong(2, row, 4, false);
+
+        row = OsObject.createRow(table);
+        table.setString(0, row, "John", false);
+        table.setString(1, row, "Anderson", false);
+        table.setLong(2, row, 3, false);
+
+        row = OsObject.createRow(table);
+        table.setString(0, row, "Erik", false);
+        table.setString(1, row, "Lee", false);
+        table.setLong(2, row, 1, false);
+
+        row = OsObject.createRow(table);
+        table.setString(0, row, "Henry", false);
+        table.setString(1, row, "Anderson", false);
+        table.setLong(2, row, 1, false);
+        sharedRealm.commitTransaction();
+    }
+
+    private void addRowAsync(final SharedRealm sharedRealm) {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final RealmConfiguration configuration = sharedRealm.getConfiguration();
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                SharedRealm sharedRealm = getSharedRealm(configuration);
+                addRow(sharedRealm);
+                sharedRealm.close();
+                latch.countDown();
+            }
+        }).start();
+        TestHelper.awaitOrFail(latch);
+    }
+
+    private void addRow(SharedRealm sharedRealm) {
+        sharedRealm.beginTransaction();
+        Table table = getTable(sharedRealm);
+        OsObject.createRow(table);
+        sharedRealm.commitTransaction();
+    }
+
+    @Test
+    public void constructor_withDistinct() {
+        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(null, table, "firstName");
+        OsResults osResults = new OsResults(sharedRealm, table.where(), null, distinctDescriptor);
+
+        assertEquals(3, osResults.size());
+        assertEquals("John", osResults.getUncheckedRow(0).getString(0));
+        assertEquals("Erik", osResults.getUncheckedRow(1).getString(0));
+        assertEquals("Henry", osResults.getUncheckedRow(2).getString(0));
+    }
+
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void constructor_queryIsValidated() {
+        // OsResults's constructor should call TableQuery.validateQuery()
+        new OsResults(sharedRealm, table.where().or());
+    }
+
+    @Test
+    public void constructor_queryOnDeletedTable() {
+        TableQuery query = table.where();
+        sharedRealm.beginTransaction();
+        assertTrue(OsObjectStore.deleteTableForObject(sharedRealm, table.getClassName()));
+        sharedRealm.commitTransaction();
+        // Query should be checked before creating OS Results.
+        thrown.expect(IllegalStateException.class);
+        new OsResults(sharedRealm, query);
+    }
+
+    @Test
+    public void size() {
+        OsResults osResults = new OsResults(sharedRealm, table.where());
+        assertEquals(4, osResults.size());
+    }
+
+    @Test
+    public void where() {
+        OsResults osResults = new OsResults(sharedRealm, table.where());
+        OsResults osResults2 = new OsResults(sharedRealm, osResults.where().equalTo(new long[] {0}, oneNullTable, "John"));
+        OsResults osResults3 = new OsResults(sharedRealm, osResults2.where().equalTo(new long[] {1}, oneNullTable, "Anderson"));
+
+        // A new native Results should be created.
+        assertTrue(osResults.getNativePtr() != osResults2.getNativePtr());
+        assertTrue(osResults2.getNativePtr() != osResults3.getNativePtr());
+
+        assertEquals(4, osResults.size());
+        assertEquals(2, osResults2.size());
+        assertEquals(1, osResults3.size());
+    }
+
+    @Test
+    public void sort() {
+        OsResults osResults = new OsResults(sharedRealm, table.where().greaterThan(new long[] {2}, oneNullTable, 1));
+        SortDescriptor sortDescriptor = SortDescriptor.getTestInstance(table, new long[] {2});
+
+        OsResults osResults2 = osResults.sort(sortDescriptor);
+
+        // A new native Results should be created.
+        assertTrue(osResults.getNativePtr() != osResults2.getNativePtr());
+        assertEquals(2, osResults.size());
+        assertEquals(2, osResults2.size());
+
+        assertEquals(3, osResults2.getUncheckedRow(0).getLong(2));
+        assertEquals(4, osResults2.getUncheckedRow(1).getLong(2));
+    }
+
+    @Test
+    public void clear() {
+        assertEquals(4, table.size());
+        OsResults osResults = new OsResults(sharedRealm, table.where());
+        sharedRealm.beginTransaction();
+        osResults.clear();
+        sharedRealm.commitTransaction();
+        assertEquals(0, table.size());
+    }
+
+    @Test
+    public void contains() {
+        OsResults osResults = new OsResults(sharedRealm, table.where());
+        UncheckedRow row = table.getUncheckedRow(0);
+        assertTrue(osResults.contains(row));
+    }
+
+    @Test
+    public void indexOf() {
+        SortDescriptor sortDescriptor = SortDescriptor.getTestInstance(table, new long[] {2});
+
+        OsResults osResults = new OsResults(sharedRealm, table.where(), sortDescriptor);
+        UncheckedRow row = table.getUncheckedRow(0);
+        assertEquals(3, osResults.indexOf(row));
+    }
+
+    @Test
+    public void distinct() {
+        OsResults osResults = new OsResults(sharedRealm, table.where().lessThan(new long[] {2}, oneNullTable, 4));
+
+        SortDescriptor distinctDescriptor = SortDescriptor.getTestInstance(table, new long[] {2});
+        OsResults osResults2 = osResults.distinct(distinctDescriptor);
+
+        // A new native Results should be created.
+        assertTrue(osResults.getNativePtr() != osResults2.getNativePtr());
+        assertEquals(3, osResults.size());
+        assertEquals(2, osResults2.size());
+
+        assertEquals(3, osResults2.getUncheckedRow(0).getLong(2));
+        assertEquals(1, osResults2.getUncheckedRow(1).getLong(2));
+    }
+
+    // 1. Create a results and add listener.
+    // 2. Query results should be returned in the next loop.
+    @Test
+    @RunTestInLooperThread
+    public void addListener_shouldBeCalledToReturnTheQueryResults() {
+        final SharedRealm sharedRealm = getSharedRealmForLooper();
+        populateData(sharedRealm);
+        Table table = getTable(sharedRealm);
+
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        looperThread.keepStrongReference(osResults);
+        osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
+            @Override
+            public void onChange(OsResults osResults1) {
+                assertEquals(osResults, osResults1);
+                assertEquals(4, osResults1.size());
+                sharedRealm.close();
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    // 1. Create a results and add listener on a non-looper thread.
+    // 2. Query results should be returned when refresh() called.
+    @Test
+    public void addListener_shouldBeCalledWhenRefreshToReturnTheQueryResults() {
+        final AtomicBoolean onChangeCalled = new AtomicBoolean(false);
+        final SharedRealm sharedRealm = getSharedRealm();
+        Table table = getTable(sharedRealm);
+
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
+            @Override
+            public void onChange(OsResults osResults1) {
+                assertEquals(osResults, osResults1);
+                assertEquals(4, osResults1.size());
+                sharedRealm.close();
+                onChangeCalled.set(true);
+            }
+        });
+        sharedRealm.refresh();
+        assertTrue(onChangeCalled.get());
+    }
+
+    @Test
+    public void addListener_shouldBeCalledWhenRefreshAfterLocalCommit() {
+        final CountDownLatch latch = new CountDownLatch(2);
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        assertEquals(4, osResults.size()); // See `populateData()`
+        osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
+            @Override
+            public void onChange(OsResults element) {
+                if (latch.getCount() == 2) {
+                    // triggered by beginTransaction
+                    assertEquals(4, osResults.size());
+                } else if (latch.getCount() == 1) {
+                    // triggered by refresh
+                    assertEquals(5, osResults.size());
+                } else {
+                    fail();
+                }
+                latch.countDown();
+            }
+        });
+        sharedRealm.beginTransaction();
+        OsObject.createRow(table);
+        sharedRealm.commitTransaction();
+        sharedRealm.refresh();
+        TestHelper.awaitOrFail(latch);
+    }
+
+    // Local commit will trigger the listener first when beginTransaction gets called then again when call refresh.
+    @Test
+    public void addListener_triggeredByRefresh() {
+        final CountDownLatch latch = new CountDownLatch(1);
+        OsResults osResults = new OsResults(sharedRealm, table.where());
+        osResults.size();
+        osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
+            @Override
+            public void onChange(OsResults element) {
+                assertEquals(1, latch.getCount());
+                latch.countDown();
+            }
+        });
+
+        addRowAsync(sharedRealm);
+
+        sharedRealm.waitForChange();
+        sharedRealm.refresh();
+        TestHelper.awaitOrFail(latch);
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void addListener_queryNotReturned() {
+        final SharedRealm sharedRealm = getSharedRealmForLooper();
+        populateData(sharedRealm);
+        Table table = getTable(sharedRealm);
+
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        looperThread.keepStrongReference(osResults);
+        osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
+            @Override
+            public void onChange(OsResults osResults1) {
+                assertEquals(osResults, osResults1);
+                assertEquals(5, osResults1.size());
+                sharedRealm.close();
+                looperThread.testComplete();
+            }
+        });
+
+        addRowAsync(sharedRealm);
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void addListener_queryReturned() {
+        final SharedRealm sharedRealm = getSharedRealmForLooper();
+        populateData(sharedRealm);
+        Table table = getTable(sharedRealm);
+
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        looperThread.keepStrongReference(osResults);
+        assertEquals(4, osResults.size()); // Trigger the query to run.
+        osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
+            @Override
+            public void onChange(OsResults osResults1) {
+                assertEquals(osResults, osResults1);
+                assertEquals(5, osResults1.size());
+                sharedRealm.close();
+                looperThread.testComplete();
+            }
+        });
+
+        addRowAsync(sharedRealm);
+    }
+
+    // Local commit will trigger the listener first when beginTransaction gets called then again when transaction
+    // committed.
+    @Test
+    @RunTestInLooperThread
+    public void addListener_triggeredByLocalCommit() {
+        final SharedRealm sharedRealm = getSharedRealmForLooper();
+        populateData(sharedRealm);
+        Table table = getTable(sharedRealm);
+        final AtomicInteger listenerCounter = new AtomicInteger(0);
+
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        looperThread.keepStrongReference(osResults);
+        osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
+            @Override
+            public void onChange(OsResults osResults1) {
+                switch (listenerCounter.getAndIncrement()) {
+                    case 0:
+                        assertEquals(4, osResults1.size());
+                        break;
+                    case 1:
+                        assertEquals(5, osResults1.size());
+                        sharedRealm.close();
+                        break;
+                    default:
+                        fail();
+                        break;
+                }
+            }
+        });
+        addRow(sharedRealm);
+        assertEquals(2, listenerCounter.get());
+        looperThread.testComplete();
+    }
+
+    private static class TestIterator extends OsResults.Iterator<Integer> {
+        TestIterator(OsResults osResults) {
+            super(osResults);
+        }
+
+        @Override
+        protected Integer convertRowToObject(UncheckedRow row) {
+            return null;
+        }
+
+        boolean isDetached(SharedRealm sharedRealm) {
+            for (WeakReference<OsResults.Iterator> iteratorRef : sharedRealm.iterators) {
+                OsResults.Iterator iterator = iteratorRef.get();
+                if (iterator == this) {
+                    return false;
+                }
+            }
+            return true;
+        }
+    }
+
+    @Test
+    public void collectionIterator_detach_byBeginTransaction() {
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        TestIterator iterator = new TestIterator(osResults);
+        assertFalse(iterator.isDetached(sharedRealm));
+        sharedRealm.beginTransaction();
+        assertTrue(iterator.isDetached(sharedRealm));
+        sharedRealm.commitTransaction();
+        assertTrue(iterator.isDetached(sharedRealm));
+    }
+
+    @Test
+    public void collectionIterator_detach_createdInTransaction() {
+        sharedRealm.beginTransaction();
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        TestIterator iterator = new TestIterator(osResults);
+        assertTrue(iterator.isDetached(sharedRealm));
+    }
+
+    @Test
+    public void collectionIterator_invalid_nonLooperThread_byRefresh() {
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        TestIterator iterator = new TestIterator(osResults);
+        assertFalse(iterator.isDetached(sharedRealm));
+        sharedRealm.refresh();
+        thrown.expect(ConcurrentModificationException.class);
+        iterator.checkValid();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void collectionIterator_invalid_looperThread_byRemoteTransaction() {
+        final SharedRealm sharedRealm = getSharedRealmForLooper();
+        populateData(sharedRealm);
+        Table table = getTable(sharedRealm);
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        final TestIterator iterator = new TestIterator(osResults);
+        looperThread.keepStrongReference(osResults);
+        assertFalse(iterator.isDetached(sharedRealm));
+        osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
+            @Override
+            public void onChange(OsResults element) {
+                try {
+                    iterator.checkValid();
+                    fail();
+                } catch (ConcurrentModificationException ignored) {
+                }
+                sharedRealm.close();
+                looperThread.testComplete();
+            }
+        });
+
+        addRowAsync(sharedRealm);
+    }
+
+    @Test
+    public void collectionIterator_newInstance_throwsWhenSharedRealmIsClosed() {
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        sharedRealm.close();
+        thrown.expect(IllegalStateException.class);
+        new TestIterator(osResults);
+    }
+
+    @Test
+    public void getMode() {
+        OsResults osResults = new OsResults(sharedRealm, table.where());
+        assertTrue(OsResults.Mode.QUERY == osResults.getMode());
+        osResults.firstUncheckedRow(); // Run the query
+        assertTrue(OsResults.Mode.TABLEVIEW == osResults.getMode());
+    }
+
+    @Test
+    public void createSnapshot() {
+        OsResults osResults = new OsResults(sharedRealm, table.where());
+        OsResults snapshot = osResults.createSnapshot();
+        assertTrue(OsResults.Mode.TABLEVIEW == snapshot.getMode());
+        thrown.expect(IllegalStateException.class);
+        snapshot.addListener(snapshot, new RealmChangeListener<OsResults>() {
+            @Override
+            public void onChange(OsResults element) {
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void load() {
+        final SharedRealm sharedRealm = getSharedRealmForLooper();
+        looperThread.closeAfterTest(sharedRealm);
+        populateData(sharedRealm);
+        final OsResults osResults = new OsResults(sharedRealm, table.where());
+        osResults.addListener(osResults, new RealmChangeListener<OsResults>() {
+            @Override
+            public void onChange(OsResults element) {
+                assertTrue(osResults.isLoaded());
+                looperThread.testComplete();
+            }
+        });
+        assertFalse(osResults.isLoaded());
+        osResults.load();
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java
deleted file mode 100644
index 67006b5592..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import android.support.test.InstrumentationRegistry;
-
-import junit.framework.TestCase;
-
-import io.realm.Realm;
-import io.realm.RealmFieldType;
-import io.realm.internal.Table.PivotType;
-
-public class PivotTest extends TestCase {
-
-    Table t;
-    long colIndexSex;
-    long colIndexAge;
-    long colIndexHired;
-
-    @Override
-    public void setUp() {
-        Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
-        t = new Table();
-        colIndexSex = t.addColumn(RealmFieldType.STRING, "sex");
-        colIndexAge = t.addColumn(RealmFieldType.INTEGER, "age");
-        colIndexHired = t.addColumn(RealmFieldType.BOOLEAN, "hired");
-
-        for (long i=0;i<50000;i++){
-            String sex = i % 2 == 0 ? "Male" : "Female";
-            t.add(sex, 20 + (i%20), true);
-        }
-    }
-
-    public void testPivotTable(){
-
-        Table resultCount = t.pivot(colIndexSex, colIndexAge, PivotType.COUNT);
-        assertEquals(2, resultCount.size());
-        assertEquals(25000, resultCount.getLong(1, 0));
-        assertEquals(25000, resultCount.getLong(1, 1));
-
-        Table resultMin = t.pivot(colIndexSex, colIndexAge, PivotType.MIN);
-        assertEquals(20, resultMin.getLong(1, 0));
-        assertEquals(21, resultMin.getLong(1, 1));
-
-        Table resultMax = t.pivot(colIndexSex, colIndexAge, PivotType.MAX);
-        assertEquals(38, resultMax.getLong(1, 0));
-        assertEquals(39, resultMax.getLong(1, 1));
-
-        try { t.pivot(colIndexHired, colIndexAge, PivotType.SUM); fail("Group by not a String column"); } catch (UnsupportedOperationException e) { }
-        try { t.pivot(colIndexSex, colIndexHired, PivotType.SUM); fail("Aggregation not an int column"); } catch (UnsupportedOperationException e) { }
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
index e04e8b4d4f..84b0cfc9b5 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/PrimaryKeyTests.java
@@ -21,6 +21,7 @@
 
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -29,9 +30,14 @@
 import java.util.Arrays;
 import java.util.List;
 
+import io.realm.DynamicRealm;
+import io.realm.DynamicRealmObject;
+import io.realm.FieldAttribute;
+import io.realm.Realm;
 import io.realm.RealmConfiguration;
 import io.realm.RealmFieldType;
-import io.realm.exceptions.RealmError;
+import io.realm.RealmObjectSchema;
+import io.realm.RealmSchema;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmPrimaryKeyConstraintException;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -67,60 +73,65 @@ public void tearDown() {
     private Table getTableWithStringPrimaryKey() {
         sharedRealm = SharedRealm.getInstance(config);
         sharedRealm.beginTransaction();
-        Table t = sharedRealm.getTable("TestTable");
+        OsObjectStore.setSchemaVersion(sharedRealm,0); // Create meta table
+        Table t = sharedRealm.createTable(Table.getTableNameForClass("TestTable"));
         long column = t.addColumn(RealmFieldType.STRING, "colName", true);
         t.addSearchIndex(column);
-        t.setPrimaryKey("colName");
+        OsObjectStore.setPrimaryKeyForObject(sharedRealm, "TestTable", "colName");
         return t;
     }
 
     private Table getTableWithIntegerPrimaryKey() {
         sharedRealm = SharedRealm.getInstance(config);
         sharedRealm.beginTransaction();
-        Table t = sharedRealm.getTable("TestTable");
+        OsObjectStore.setSchemaVersion(sharedRealm,0); // Create meta table
+        Table t = sharedRealm.createTable(Table.getTableNameForClass("TestTable"));
         long column = t.addColumn(RealmFieldType.INTEGER, "colName");
         t.addSearchIndex(column);
-        t.setPrimaryKey("colName");
+        OsObjectStore.setPrimaryKeyForObject(sharedRealm, "TestTable", "colName");
         return t;
     }
 
-    // Tests that primary key constraints are actually removed.
+    /**
+     * This test surfaces a bunch of problems, most of them seem to be around caching of the schema
+     * during a transaction
+     *
+     * 1) Removing the primary key do not invalidate the cache in RealmSchema and those cached
+     *    are ImmutableRealmObjectSchema so do not change when the primary key is removed.
+     *
+     * 2) Addding `schema.refresh()` to RealmObjectSchema.removePrimaryKey()` causes
+     *    RealmPrimaryKeyConstraintException anyway. Unclear why.
+     */
     @Test
     public void removingPrimaryKeyRemovesConstraint_typeSetters() {
         RealmConfiguration config = configFactory.createConfigurationBuilder()
                 .name("removeConstraints").build();
-        SharedRealm sharedRealm = SharedRealm.getInstance(config);
 
-        sharedRealm.beginTransaction();
-        Table tbl = sharedRealm.getTable("EmployeeTable");
-        tbl.addColumn(RealmFieldType.STRING, "name");
-        tbl.setPrimaryKey("name");
+        DynamicRealm realm = DynamicRealm.getInstance(config);
+        RealmSchema realmSchema = realm.getSchema();
+        realm.beginTransaction();
+        RealmObjectSchema tableSchema = realmSchema.create("Employee")
+                .addField("name", String.class, FieldAttribute.PRIMARY_KEY);
 
-        // Creates first entry with name "Foo".
-        tbl.setString(0, tbl.addEmptyRow(), "Foo", false);
+        realm.createObject("Employee", "Foo");
+        DynamicRealmObject obj = realm.createObject("Employee", "Foo2");
 
-        long rowIndex = tbl.addEmptyRow();
         try {
-            tbl.setString(0, rowIndex, "Foo", false); // Tries to create 2nd entry with name Foo.
-        } catch (RealmPrimaryKeyConstraintException e1) {
-            tbl.setPrimaryKey(""); // Primary key check worked, now removes it and tries again.
-            try {
-                tbl.setString(0, rowIndex, "Foo", false);
-                return;
-            } catch (RealmException e2) {
-                fail("Primary key not removed");
-            }
+            // Tries to create 2nd entry with name Foo.
+            obj.setString("name", "Foo");
+        } catch (IllegalArgumentException e) {
+            tableSchema.removePrimaryKey();
+            obj.setString("name", "Foo");
+        } finally {
+            realm.close();
         }
-
-        fail("Primary key not enforced.");
-        sharedRealm.close();
     }
 
     @Test
     public void addEmptyRowWithPrimaryKeyWrongTypeStringThrows() {
         Table t = getTableWithStringPrimaryKey();
         try {
-            t.addEmptyRowWithPrimaryKey(42);
+            OsObject.createWithPrimaryKey(t, 42);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -130,7 +141,7 @@ public void addEmptyRowWithPrimaryKeyWrongTypeStringThrows() {
     @Test
     public void addEmptyRowWithPrimaryKeyNullString() {
         Table t = getTableWithStringPrimaryKey();
-        t.addEmptyRowWithPrimaryKey(null);
+        OsObject.createWithPrimaryKey(t, null);
         assertEquals(1, t.size());
         sharedRealm.cancelTransaction();
     }
@@ -139,7 +150,7 @@ public void addEmptyRowWithPrimaryKeyNullString() {
     public void addEmptyRowWithPrimaryKeyWrongTypeIntegerThrows() {
         Table t = getTableWithIntegerPrimaryKey();
         try {
-            t.addEmptyRowWithPrimaryKey("Foo");
+            OsObject.createWithPrimaryKey(t, "Foo");
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -149,18 +160,18 @@ public void addEmptyRowWithPrimaryKeyWrongTypeIntegerThrows() {
     @Test
     public void addEmptyRowWithPrimaryKeyString() {
         Table t = getTableWithStringPrimaryKey();
-        long rowIndex = t.addEmptyRowWithPrimaryKey("Foo");
+        UncheckedRow row = OsObject.createWithPrimaryKey(t, "Foo");
         assertEquals(1, t.size());
-        assertEquals("Foo", t.getUncheckedRow(rowIndex).getString(0));
+        assertEquals("Foo", row.getString(0));
         sharedRealm.cancelTransaction();
     }
 
     @Test
     public void addEmptyRowWithPrimaryKeyLong() {
         Table t = getTableWithIntegerPrimaryKey();
-        long rowIndex = t.addEmptyRowWithPrimaryKey(42);
+        UncheckedRow row = OsObject.createWithPrimaryKey(t, 42);
         assertEquals(1, t.size());
-        assertEquals(42L, t.getUncheckedRow(rowIndex).getLong(0));
+        assertEquals(42L, row.getLong(0));
         sharedRealm.cancelTransaction();
     }
 
@@ -168,12 +179,9 @@ public void addEmptyRowWithPrimaryKeyLong() {
     public void migratePrimaryKeyTableIfNeeded_first() throws IOException {
         configFactory.copyRealmFromAssets(context, "080_annotationtypes.realm", "default.realm");
         sharedRealm = SharedRealm.getInstance(config);
-        sharedRealm.beginTransaction();
-        assertTrue(Table.migratePrimaryKeyTableIfNeeded(sharedRealm));
-        sharedRealm.commitTransaction();
+        Table.migratePrimaryKeyTableIfNeeded(sharedRealm);
         Table t = sharedRealm.getTable("class_AnnotationTypes");
-        assertTrue(t.hasPrimaryKey());
-        assertEquals(t.getColumnIndex("id"), t.getPrimaryKey());
+        assertEquals("id", OsObjectStore.getPrimaryKeyForObject(sharedRealm, "AnnotationTypes"));
         assertEquals(RealmFieldType.STRING, sharedRealm.getTable("pk").getColumnType(0));
     }
 
@@ -181,12 +189,9 @@ public void migratePrimaryKeyTableIfNeeded_first() throws IOException {
     public void migratePrimaryKeyTableIfNeeded_second() throws IOException {
         configFactory.copyRealmFromAssets(context, "0841_annotationtypes.realm", "default.realm");
         sharedRealm = SharedRealm.getInstance(config);
-        sharedRealm.beginTransaction();
-        assertTrue(Table.migratePrimaryKeyTableIfNeeded(sharedRealm));
-        sharedRealm.commitTransaction();
+        Table.migratePrimaryKeyTableIfNeeded(sharedRealm);
         Table t = sharedRealm.getTable("class_AnnotationTypes");
-        assertTrue(t.hasPrimaryKey());
-        assertEquals(t.getColumnIndex("id"), t.getPrimaryKey());
+        assertEquals("id", OsObjectStore.getPrimaryKeyForObject(sharedRealm, "AnnotationTypes"));
         assertEquals("AnnotationTypes", sharedRealm.getTable("pk").getString(0, 0));
     }
 
@@ -204,9 +209,7 @@ public void migratePrimaryKeyTableIfNeeded_primaryKeyTableMigratedWithRightName(
 
         configFactory.copyRealmFromAssets(context, "0841_pk_migration.realm", "default.realm");
         sharedRealm = SharedRealm.getInstance(config);
-        sharedRealm.beginTransaction();
-        assertTrue(Table.migratePrimaryKeyTableIfNeeded(sharedRealm));
-        sharedRealm.commitTransaction();
+        Table.migratePrimaryKeyTableIfNeeded(sharedRealm);
 
         Table table = sharedRealm.getTable("pk");
         for (int i = 0; i < table.size(); i++) {
@@ -222,13 +225,14 @@ public void migratePrimaryKeyTableIfNeeded_primaryKeyTableMigratedWithRightName(
     public void migratePrimaryKeyTableIfNeeded_primaryKeyTableNeedSearchIndex() {
         sharedRealm = SharedRealm.getInstance(config);
         sharedRealm.beginTransaction();
-        Table table = sharedRealm.getTable("TestTable");
+        OsObjectStore.setSchemaVersion(sharedRealm,0); // Create meta table
+        Table table = sharedRealm.createTable(Table.getTableNameForClass("TestTable"));
         long column = table.addColumn(RealmFieldType.INTEGER, "PKColumn");
         table.addSearchIndex(column);
-        table.setPrimaryKey(column);
+        OsObjectStore.setPrimaryKeyForObject(sharedRealm, "TestTable", "PKColumn");
         sharedRealm.commitTransaction();
 
-        assertEquals(table.getPrimaryKey(), table.getColumnIndex("PKColumn"));
+        assertEquals("PKColumn", OsObjectStore.getPrimaryKeyForObject(sharedRealm, "TestTable"));
         // Now we have a pk table with search index.
 
         sharedRealm.beginTransaction();
@@ -237,21 +241,25 @@ public void migratePrimaryKeyTableIfNeeded_primaryKeyTableNeedSearchIndex() {
         pkTable.removeSearchIndex(classColumn);
 
         // Tries to add a pk for another table.
-        Table table2 = sharedRealm.getTable("TestTable2");
+        Table table2 = sharedRealm.createTable(Table.getTableNameForClass("TestTable2"));
         long column2 = table2.addColumn(RealmFieldType.INTEGER, "PKColumn");
         table2.addSearchIndex(column2);
         try {
-            table2.setPrimaryKey(column2);
+            OsObjectStore.setPrimaryKeyForObject(sharedRealm, "TestTable2", "PKColumn");
         } catch (IllegalStateException ignored) {
             // Column has no search index.
         }
+        sharedRealm.commitTransaction();
 
         assertFalse(pkTable.hasSearchIndex(classColumn));
 
         Table.migratePrimaryKeyTableIfNeeded(sharedRealm);
         assertTrue(pkTable.hasSearchIndex(classColumn));
+
+        sharedRealm.beginTransaction();
         // Now it works.
         table2.addSearchIndex(column2);
-        sharedRealm.cancelTransaction();
+        OsObjectStore.setPrimaryKeyForObject(sharedRealm, "TestTable2", "PKColumn");
+        sharedRealm.commitTransaction();
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java
index 0516f0e115..87ba794501 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java
@@ -27,6 +27,8 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import javax.annotation.Nullable;
+
 import io.realm.RealmChangeListener;
 import io.realm.RealmConfiguration;
 import io.realm.internal.android.AndroidRealmNotifier;
@@ -52,7 +54,12 @@ public boolean canDeliverNotification() {
         }
 
         @Override
-        public void checkCanDeliverNotification(String exceptionMessage) {
+        public void checkCanDeliverNotification(@Nullable String exceptionMessage) {
+        }
+
+        @Override
+        public boolean isMainThread() {
+            return false;
         }
     };
 
@@ -65,7 +72,9 @@ public void tearDown() {
     }
 
     private SharedRealm getSharedRealm(RealmConfiguration config) {
-        return SharedRealm.getInstance(config, null, true);
+        OsRealmConfig.Builder configBuilder = new OsRealmConfig.Builder(config)
+                .autoUpdateNotification(true);
+        return SharedRealm.getInstance(configBuilder);
     }
 
     @Test
@@ -101,15 +110,11 @@ public void onChange(SharedRealm sharedRealm) {
     }
 
     private void makeRemoteChanges(final RealmConfiguration config) {
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                SharedRealm sharedRealm = getSharedRealm(config);
-                sharedRealm.beginTransaction();
-                sharedRealm.commitTransaction();
-                sharedRealm.close();
-            }
-        }).start();
+        // We don't use cache from RealmCoordinator
+        SharedRealm sharedRealm = getSharedRealm(config);
+        sharedRealm.beginTransaction();
+        sharedRealm.commitTransaction();
+        sharedRealm.close();
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
index c735e2dcf1..98ff45c0df 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
@@ -25,13 +25,11 @@
 import org.junit.runner.RunWith;
 
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicLong;
 
 import io.realm.RealmConfiguration;
 import io.realm.exceptions.RealmError;
 import io.realm.rule.TestRealmConfigurationFactory;
 
-import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertTrue;
 
@@ -71,26 +69,26 @@ public void getVersionID() {
     public void hasTable() {
         assertFalse(sharedRealm.hasTable("MyTable"));
         sharedRealm.beginTransaction();
-        sharedRealm.getTable("MyTable");
+        sharedRealm.createTable("MyTable");
         sharedRealm.commitTransaction();
         assertTrue(sharedRealm.hasTable("MyTable"));
     }
 
-    @Test(expected = IllegalStateException.class)
-    public void getTable_createNotInTransactionThrows() {
-        sharedRealm.getTable("NON-EXISTING");
-    }
-
     @Test
     public void getTable() {
         assertFalse(sharedRealm.hasTable("MyTable"));
         sharedRealm.beginTransaction();
-        sharedRealm.getTable("MyTable");
+        sharedRealm.createTable("MyTable");
         sharedRealm.commitTransaction();
         assertTrue(sharedRealm.hasTable("MyTable"));
 
         // Table is existing, no need transaction to create it
-        sharedRealm.getTable("MyTable");
+        assertTrue(sharedRealm.getTable("MyTable").isValid());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void getTable_throwsIfTableNotExist() {
+        sharedRealm.getTable("NON_EXISTING");
     }
 
     @Test
@@ -109,38 +107,10 @@ public void isInTransaction_returnFalseWhenRealmClosed() {
         sharedRealm = null;
     }
 
-    @Test
-    public void removeTable() {
-        sharedRealm.beginTransaction();
-        sharedRealm.getTable("TableToRemove");
-        assertTrue(sharedRealm.hasTable("TableToRemove"));
-        sharedRealm.removeTable("TableToRemove");
-        assertFalse(sharedRealm.hasTable("TableToRemove"));
-        sharedRealm.commitTransaction();
-    }
-
-    @Test
-    public void removeTable_notInTransactionThrows() {
-        sharedRealm.beginTransaction();
-        sharedRealm.getTable("TableToRemove");
-        sharedRealm.commitTransaction();
-        thrown.expect(IllegalStateException.class);
-        sharedRealm.removeTable("TableToRemove");
-    }
-
-    @Test
-    public void removeTable_tableNotExist() {
-        sharedRealm.beginTransaction();
-        assertFalse(sharedRealm.hasTable("TableToRemove"));
-        thrown.expect(RealmError.class);
-        sharedRealm.removeTable("TableToRemove");
-        sharedRealm.cancelTransaction();
-    }
-
     @Test
     public void renameTable() {
         sharedRealm.beginTransaction();
-        sharedRealm.getTable("OldTable");
+        sharedRealm.createTable("OldTable");
         assertTrue(sharedRealm.hasTable("OldTable"));
         sharedRealm.renameTable("OldTable", "NewTable");
         assertFalse(sharedRealm.hasTable("OldTable"));
@@ -151,7 +121,7 @@ public void renameTable() {
     @Test
     public void renameTable_notInTransactionThrows() {
         sharedRealm.beginTransaction();
-        sharedRealm.getTable("OldTable");
+        sharedRealm.createTable("OldTable");
         sharedRealm.commitTransaction();
         thrown.expect(IllegalStateException.class);
         sharedRealm.renameTable("OldTable", "NewTable");
@@ -166,79 +136,49 @@ public void renameTable_tableNotExist() {
         sharedRealm.cancelTransaction();
     }
 
+
+    private void changeSchemaByAnotherRealm() {
+        SharedRealm sharedRealm = SharedRealm.getInstance(config);
+        sharedRealm.beginTransaction();
+        sharedRealm.createTable("NewTable");
+        sharedRealm.commitTransaction();
+        sharedRealm.close();
+    }
+
     @Test
-    public void beginTransaction_SchemaVersionListener() {
+    public void registerSchemaChangedCallback_beginTransaction() {
         final AtomicBoolean listenerCalled = new AtomicBoolean(false);
-        final AtomicLong schemaVersionFromListener = new AtomicLong(-1L);
 
-        sharedRealm.close();
-        sharedRealm = SharedRealm.getInstance(config, new SharedRealm.SchemaVersionListener() {
+        assertFalse(sharedRealm.hasTable("NewTable"));
+
+        sharedRealm.registerSchemaChangedCallback(new SharedRealm.SchemaChangedCallback() {
             @Override
-            public void onSchemaVersionChanged(long currentVersion) {
+            public void onSchemaChanged() {
+                assertTrue(sharedRealm.hasTable("NewTable"));
                 listenerCalled.set(true);
-                schemaVersionFromListener.set(currentVersion);
             }
-        }, true);
-
-        final long before = sharedRealm.getSchemaVersion();
-
-        sharedRealm.beginTransaction();
-        try {
-            // Listener is not called if there was no schema change.
-            assertFalse(listenerCalled.get());
-
-            // Changes the schema version.
-            sharedRealm.setSchemaVersion(before + 1);
-        } finally {
-            sharedRealm.commitTransaction();
-        }
-
-        // Listener is not yet called.
-        assertFalse(listenerCalled.get());
-
+        });
+        changeSchemaByAnotherRealm();
         sharedRealm.beginTransaction();
-        try {
-            assertTrue(listenerCalled.get());
-            assertEquals(before + 1, schemaVersionFromListener.get());
-        } finally {
-            sharedRealm.cancelTransaction();
-        }
+        assertTrue(listenerCalled.get());
     }
 
     @Test
-    public void refresh_SchemaVersionListener() {
+    public void registerSchemaChangedCallback_refresh() {
         final AtomicBoolean listenerCalled = new AtomicBoolean(false);
-        final AtomicLong schemaVersionFromListener = new AtomicLong(-1L);
 
-        sharedRealm.close();
-        sharedRealm = SharedRealm.getInstance(config, new SharedRealm.SchemaVersionListener() {
+        assertFalse(sharedRealm.hasTable("NewTable"));
+
+        sharedRealm.registerSchemaChangedCallback(new SharedRealm.SchemaChangedCallback() {
             @Override
-            public void onSchemaVersionChanged(long currentVersion) {
+            public void onSchemaChanged() {
+                assertTrue(sharedRealm.hasTable("NewTable"));
                 listenerCalled.set(true);
-                schemaVersionFromListener.set(currentVersion);
             }
-        }, true);
-
-        final long before = sharedRealm.getSchemaVersion();
-
-        sharedRealm.refresh();
-        // Listener is not called if there was no schema change.
-        assertFalse(listenerCalled.get());
-
-        sharedRealm.beginTransaction();
-        try {
-            // Changes the schema version.
-            sharedRealm.setSchemaVersion(before + 1);
-        } finally {
-            sharedRealm.commitTransaction();
-        }
-
-        // Listener is not yet called.
-        assertFalse(listenerCalled.get());
-
+        });
+        changeSchemaByAnotherRealm();
         sharedRealm.refresh();
         assertTrue(listenerCalled.get());
-        assertEquals(before + 1, schemaVersionFromListener.get());
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
index 1212415ce0..a8c4bd22f5 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
@@ -25,8 +25,8 @@
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
-import java.util.ArrayList;
-import java.util.List;
+import java.util.HashSet;
+import java.util.Set;
 
 import io.realm.RealmConfiguration;
 import io.realm.RealmFieldType;
@@ -39,6 +39,7 @@
 import static junit.framework.Assert.assertTrue;
 import static junit.framework.Assert.fail;
 
+
 @RunWith(AndroidJUnit4.class)
 public class SortDescriptorTests {
     @Rule
@@ -54,7 +55,7 @@ public void setUp() {
         RealmConfiguration config = configFactory.createConfiguration();
         sharedRealm = SharedRealm.getInstance(config);
         sharedRealm.beginTransaction();
-        table = sharedRealm.getTable("test_table");
+        table = sharedRealm.createTable("test_table");
     }
 
     @After
@@ -64,14 +65,14 @@ public void tearDown() {
 
     @Test
     public void getInstanceForDistinct() {
-        for (RealmFieldType type : SortDescriptor.validFieldTypesForDistinct) {
+        for (RealmFieldType type : SortDescriptor.DISTINCT_VALID_FIELD_TYPES) {
             long column = table.addColumn(type, type.name());
             table.addSearchIndex(column);
         }
 
         long i = 0;
-        for (RealmFieldType type : SortDescriptor.validFieldTypesForDistinct) {
-            SortDescriptor sortDescriptor = SortDescriptor.getInstanceForDistinct(table, type.name());
+        for (RealmFieldType type : SortDescriptor.DISTINCT_VALID_FIELD_TYPES) {
+            SortDescriptor sortDescriptor = SortDescriptor.getInstanceForDistinct(null, table, type.name());
             assertEquals(1, sortDescriptor.getColumnIndices()[0].length);
             assertEquals(i, sortDescriptor.getColumnIndices()[0][0]);
             assertNull(sortDescriptor.getAscendings());
@@ -89,13 +90,13 @@ public void getInstanceForDistinct_shouldThrowOnLinkAndListListField() {
         table.addColumnLink(listType, listType.name(), table);
 
         try {
-            SortDescriptor.getInstanceForDistinct(table, String.format("%s.%s", listType.name(), type.name()));
+            SortDescriptor.getInstanceForDistinct(null, table, String.format("%s.%s", listType.name(), type.name()));
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
         try {
-            SortDescriptor.getInstanceForDistinct(table, String.format("%s.%s", objectType.name(), type.name()));
+            SortDescriptor.getInstanceForDistinct(null, table, String.format("%s.%s", objectType.name(), type.name()));
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -110,8 +111,8 @@ public void getInstanceForDistinct_multipleFields() {
         long intColumn = table.addColumn(intType, intType.name());
         table.addSearchIndex(intColumn);
 
-        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForDistinct(table, new String[] {
-               stringType.name(), intType.name()});
+        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForDistinct(null, table, new String[] {
+                stringType.name(), intType.name()});
         assertEquals(2, sortDescriptor.getColumnIndices().length);
         assertNull(sortDescriptor.getAscendings());
         assertEquals(1, sortDescriptor.getColumnIndices()[0].length);
@@ -122,24 +123,11 @@ public void getInstanceForDistinct_multipleFields() {
 
     @Test
     public void getInstanceForDistinct_shouldThrowOnInvalidField() {
-        List<RealmFieldType> types = new ArrayList<RealmFieldType>();
-        for (RealmFieldType type : RealmFieldType.values()) {
-            if (!SortDescriptor.validFieldTypesForDistinct.contains(type) &&
-                    type != RealmFieldType.UNSUPPORTED_DATE &&
-                    type != RealmFieldType.UNSUPPORTED_TABLE &&
-                    type != RealmFieldType.UNSUPPORTED_MIXED) {
-                if (type == RealmFieldType.LIST || type == RealmFieldType.OBJECT) {
-                    table.addColumnLink(type, type.name(), table);
-                } else {
-                    table.addColumn(type, type.name());
-                }
-                types.add(type);
-            }
-        }
+        Set<RealmFieldType> types = getValidFieldTypes(SortDescriptor.DISTINCT_VALID_FIELD_TYPES);
 
         for (RealmFieldType type : types) {
             try {
-                SortDescriptor.getInstanceForDistinct(table, type.name());
+                SortDescriptor.getInstanceForDistinct(null, table, type.name());
                 fail();
             } catch (IllegalArgumentException ignored) {
                 assertTrue(ignored.getMessage().contains("Distinct is not supported"));
@@ -149,13 +137,13 @@ public void getInstanceForDistinct_shouldThrowOnInvalidField() {
 
     @Test
     public void getInstanceForSort() {
-        for (RealmFieldType type : SortDescriptor.validFieldTypesForSort) {
+        for (RealmFieldType type : SortDescriptor.SORT_VALID_FIELD_TYPES) {
             table.addColumn(type, type.name());
         }
 
         long i = 0;
-        for (RealmFieldType type : SortDescriptor.validFieldTypesForSort) {
-            SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(table, type.name(), Sort.DESCENDING);
+        for (RealmFieldType type : SortDescriptor.SORT_VALID_FIELD_TYPES) {
+            SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(null, table, type.name(), Sort.DESCENDING);
             assertEquals(1, sortDescriptor.getColumnIndices()[0].length);
             assertEquals(i, sortDescriptor.getColumnIndices()[0][0]);
             assertFalse(sortDescriptor.getAscendings()[0]);
@@ -165,7 +153,7 @@ public void getInstanceForSort() {
 
     @Test
     public void getInstanceForSort_linkField() {
-        for (RealmFieldType type : SortDescriptor.validFieldTypesForDistinct) {
+        for (RealmFieldType type : SortDescriptor.DISTINCT_VALID_FIELD_TYPES) {
             long column = table.addColumn(type, type.name());
             table.addSearchIndex(column);
         }
@@ -173,8 +161,8 @@ public void getInstanceForSort_linkField() {
         long columnLink = table.addColumnLink(objectType, objectType.name(), table);
 
         long i = 0;
-        for (RealmFieldType type : SortDescriptor.validFieldTypesForDistinct) {
-            SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(table,
+        for (RealmFieldType type : SortDescriptor.DISTINCT_VALID_FIELD_TYPES) {
+            SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(null, table,
                     String.format("%s.%s", objectType.name(), type.name()), Sort.ASCENDING);
             assertEquals(2, sortDescriptor.getColumnIndices()[0].length);
             assertEquals(columnLink, sortDescriptor.getColumnIndices()[0][0]);
@@ -191,7 +179,7 @@ public void getInstanceForSort_multipleFields() {
         RealmFieldType intType = RealmFieldType.INTEGER;
         long intColumn = table.addColumn(intType, intType.name());
 
-        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(table, new String[] {
+        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(null, table, new String[] {
                 stringType.name(), intType.name()}, new Sort[] {Sort.ASCENDING, Sort.DESCENDING});
 
         assertEquals(2, sortDescriptor.getAscendings().length);
@@ -216,31 +204,18 @@ public void getInstanceForSort_numOfFeildsAndSortOrdersNotMatch() {
 
         thrown.expect(IllegalArgumentException.class);
         thrown.expectMessage("Number of fields and sort orders do not match.");
-        SortDescriptor.getInstanceForSort(table,
-                new String[] { stringType.name(), intType.name()}, new Sort[] {Sort.ASCENDING});
+        SortDescriptor.getInstanceForSort(null, table,
+                new String[] {stringType.name(), intType.name()}, new Sort[] {Sort.ASCENDING});
 
     }
 
     @Test
     public void getInstanceForSort_shouldThrowOnInvalidField() {
-        List<RealmFieldType> types = new ArrayList<RealmFieldType>();
-        for (RealmFieldType type : RealmFieldType.values()) {
-            if (!SortDescriptor.validFieldTypesForSort.contains(type) &&
-                    type != RealmFieldType.UNSUPPORTED_DATE &&
-                    type != RealmFieldType.UNSUPPORTED_TABLE&&
-                    type != RealmFieldType.UNSUPPORTED_MIXED) {
-                if (type == RealmFieldType.LIST || type == RealmFieldType.OBJECT) {
-                    table.addColumnLink(type, type.name(), table);
-                } else {
-                    table.addColumn(type, type.name());
-                }
-                types.add(type);
-            }
-        }
+        Set<RealmFieldType> types = getValidFieldTypes(SortDescriptor.SORT_VALID_FIELD_TYPES);
 
         for (RealmFieldType type : types) {
             try {
-                SortDescriptor.getInstanceForSort(table, type.name(), Sort.ASCENDING);
+                SortDescriptor.getInstanceForSort(null, table, type.name(), Sort.ASCENDING);
                 fail();
             } catch (IllegalArgumentException ignored) {
                 assertTrue(ignored.getMessage().contains("Sort is not supported"));
@@ -256,7 +231,35 @@ public void getInstanceForSort_shouldThrowOnLinkListField() {
         table.addColumnLink(listType, listType.name(), table);
 
         thrown.expect(IllegalArgumentException.class);
-        thrown.expectMessage("is not a supported link field");
-        SortDescriptor.getInstanceForSort(table, String.format("%s.%s", listType.name(), type.name()), Sort.ASCENDING);
+        thrown.expectMessage("Invalid query: field 'LIST' in class 'test_table' is of invalid type 'LIST'.");
+        SortDescriptor.getInstanceForSort(null, table, String.format("%s.%s", listType.name(), type.name()), Sort.ASCENDING);
+    }
+
+    private Set<RealmFieldType> getValidFieldTypes(Set<RealmFieldType> filter) {
+        Set<RealmFieldType> types = new HashSet<>();
+        for (RealmFieldType type : RealmFieldType.values()) {
+            if (!filter.contains(type)) {
+                switch (type) {
+                    case LINKING_OBJECTS: // TODO: should be supported?s
+                    case INTEGER_LIST: // FIXME zaki50 revisit this once Primitive List query is implemented
+                    case BOOLEAN_LIST:
+                    case STRING_LIST:
+                    case BINARY_LIST:
+                    case DATE_LIST:
+                    case FLOAT_LIST:
+                    case DOUBLE_LIST:
+                        break;
+                    case LIST:
+                    case OBJECT:
+                        table.addColumnLink(type, type.name(), table);
+                        types.add(type);
+                        break;
+                    default:
+                        table.addColumn(type, type.name());
+                        types.add(type);
+                }
+            }
+        }
+        return types;
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
index 041c45ced3..3efa42c683 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
@@ -16,26 +16,73 @@
 
 package io.realm.internal;
 
-import junit.framework.TestCase;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
 
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
 import io.realm.RealmFieldType;
+import io.realm.TestHelper;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+
+import static org.junit.Assert.assertEquals;
+
+
+@RunWith(AndroidJUnit4.class)
+public class TableIndexAndDistinctTest {
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+
+    @SuppressWarnings("FieldCanBeLocal")
+    private RealmConfiguration config;
+    private SharedRealm sharedRealm;
+    private Table table;
+
+    @Before
+    public void setUp() throws Exception {
+        Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
+        config = configFactory.createConfiguration();
+        sharedRealm = SharedRealm.getInstance(config);
+
+        sharedRealm.beginTransaction();
+    }
+
+    @After
+    public void tearDown() {
+        if (sharedRealm != null && sharedRealm.isInTransaction()) {
+            sharedRealm.cancelTransaction();
+        }
+
+        if (sharedRealm != null && !sharedRealm.isClosed()) {
+            sharedRealm.close();
+        }
+    }
+
+    private void init() {
+        table = TestHelper.createTable(sharedRealm, "temp", new TestHelper.AdditionalTableSetup() {
+            @Override
+            public void execute(Table table) {
+                table.addColumn(RealmFieldType.INTEGER, "number");
+                table.addColumn(RealmFieldType.STRING, "name");
+
+                TestHelper.addRowWithValues(table, 0, "A");
+                TestHelper.addRowWithValues(table, 1, "B");
+                TestHelper.addRowWithValues(table, 2, "C");
+                TestHelper.addRowWithValues(table, 3, "B");
+                TestHelper.addRowWithValues(table, 4, "D");
+                TestHelper.addRowWithValues(table, 5, "D");
+                TestHelper.addRowWithValues(table, 6, "D");
+            }
+        });
 
-public class TableIndexAndDistinctTest extends TestCase {
-    Table table;
-
-    void init() {
-        table = new Table();
-        table.addColumn(RealmFieldType.INTEGER, "number");
-        table.addColumn(RealmFieldType.STRING, "name");
-
-        long i = 0;
-        table.add(0, "A");
-        table.add(1, "B");
-        table.add(2, "C");
-        table.add(3, "B");
-        table.add(4, "D");
-        table.add(5, "D");
-        table.add(6, "D");
         assertEquals(7, table.size());
     }
 
@@ -43,39 +90,44 @@ void init() {
      * Checks that Index can be set on multiple columns, with the String.
      * @param
      */
-    public void testShouldTestSettingIndexOnMultipleColumns() {
+    @Test
+    public void shouldTestSettingIndexOnMultipleColumns() {
 
         // Creates a table only with String type columns
-        Table t = new Table();
-        t.addColumn(RealmFieldType.STRING, "col1");
-        t.addColumn(RealmFieldType.STRING, "col2");
-        t.addColumn(RealmFieldType.STRING, "col3");
-        t.addColumn(RealmFieldType.STRING, "col4");
-        t.addColumn(RealmFieldType.STRING, "col5");
-        t.add("row1", "row2", "row3", "row4", "row5");
-        t.add("row1", "row2", "row3", "row4", "row5");
-        t.add("row1", "row2", "row3", "row4", "row5");
-        t.add("row1", "row2", "row3", "row4", "row5");
-        t.add("row1", "row2", "row3", "row4", "row5");
+        Table t = TestHelper.createTable(sharedRealm, "temp", new TestHelper.AdditionalTableSetup() {
+            @Override
+            public void execute(Table t) {
+                t.addColumn(RealmFieldType.STRING, "col1");
+                t.addColumn(RealmFieldType.STRING, "col2");
+                t.addColumn(RealmFieldType.STRING, "col3");
+                t.addColumn(RealmFieldType.STRING, "col4");
+                t.addColumn(RealmFieldType.STRING, "col5");
+                TestHelper.addRowWithValues(t, "row1", "row2", "row3", "row4", "row5");
+                TestHelper.addRowWithValues(t, "row1", "row2", "row3", "row4", "row5");
+                TestHelper.addRowWithValues(t, "row1", "row2", "row3", "row4", "row5");
+                TestHelper.addRowWithValues(t, "row1", "row2", "row3", "row4", "row5");
+                TestHelper.addRowWithValues(t, "row1", "row2", "row3", "row4", "row5");
+            }
+        });
 
         for (long c=0;c<t.getColumnCount();c++){
             t.addSearchIndex(c);
             assertEquals(true, t.hasSearchIndex(c));
         }
+
     }
 
 
 // TODO: parametric test
 /*    *//**
      * Checks that all other column types than String throws exception.
-     * @param o
      *//*
 
     @Test(expectedExceptions = IllegalArgumentException.class, dataProvider = "columnIndex")
     public void shouldTestIndexOnWrongColumnType(Long index) {
 
         // Gets a table with all available column types.
-        Table t = TestHelper.getTableWithAllColumnTypes();
+        Table t = TestHelper.createTableWithAllColumnTypes(sharedRealm);
 
         // If column type is String, then throw the excepted exception.
         if (t.getColumnType(index).equals(RealmFieldType.STRING)){
@@ -85,12 +137,14 @@ public void shouldTestIndexOnWrongColumnType(Long index) {
         t.addSearchIndex(index);
     }*/
 
-    public void testShouldCheckIndexIsOkOnColumn() {
+    @Test
+    public void shouldCheckIndexIsOkOnColumn() {
         init();
         table.addSearchIndex(1);
     }
 
-    public void testRemoveSearchIndex() {
+    @Test
+    public void removeSearchIndex() {
         init();
         table.addSearchIndex(1);
         assertEquals(true, table.hasSearchIndex(1));
@@ -99,7 +153,8 @@ public void testRemoveSearchIndex() {
         assertEquals(false, table.hasSearchIndex(1));
     }
 
-    public void testRemoveSearchIndexNoop() {
+    @Test
+    public void removeSearchIndexNoOp() {
         init();
         assertEquals(false, table.hasSearchIndex(1));
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/android/ISO8601UtilsTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/android/ISO8601UtilsTest.java
index 0fffbd9f57..492b34b359 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/android/ISO8601UtilsTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/android/ISO8601UtilsTest.java
@@ -123,6 +123,17 @@ public void testParseOptional() throws java.text.ParseException {
         assertEquals(dateZeroSecondAndMillis, d);
     }
 
+    public void testTimeZoneDesignator() throws java.text.ParseException {
+        Date d = ISO8601Utils.parse("2007-08-13T21:51+02:00", new ParsePosition(0));
+        assertEquals(dateZeroSecondAndMillis, d);
+
+        d = ISO8601Utils.parse("2007-08-13T21:51+0200", new ParsePosition(0));
+        assertEquals(dateZeroSecondAndMillis, d);
+
+        d = ISO8601Utils.parse("2007-08-13T21:51+02", new ParsePosition(0));
+        assertEquals(dateZeroSecondAndMillis, d);
+    }
+
     public void testParseRfc3339Examples() throws java.text.ParseException {
         // Two digit milliseconds.
         Date d = ISO8601Utils.parse("1985-04-12T23:20:50.52Z", new ParsePosition(0));
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/android/JsonUtilsTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/android/JsonUtilsTest.java
index 42958d93fc..9d8a431a99 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/android/JsonUtilsTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/android/JsonUtilsTest.java
@@ -48,7 +48,7 @@ public void testParseJsonDateToDate() {
         String jsonDate = "/Date(1198908717056)/"; // 2007-12-27T23:11:57.056
         Date output = JsonUtils.stringToDate(jsonDate);
 
-        assertEquals(output.getTime(), 1198908717056L);
+        assertEquals(1198908717056L, output.getTime());
     }
 
     public void testNegativeLongDate() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
index 49d1ececa6..ebc149f8c5 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunInLooperThread.java
@@ -23,6 +23,8 @@
 import org.junit.runners.model.MultipleFailureException;
 import org.junit.runners.model.Statement;
 
+import java.io.Closeable;
+import java.io.IOException;
 import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -38,6 +40,7 @@
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
 import io.realm.TestHelper;
+import io.realm.internal.android.AndroidCapabilities;
 
 
 /**
@@ -59,6 +62,9 @@
     // Thread safe
     private final CountDownLatch signalTestCompleted = new CountDownLatch(1);
 
+    // Thread safe
+    private boolean ruleBeingUsed = false;
+
     // Access guarded by 'lock'
     private RealmConfiguration realmConfiguration;
 
@@ -81,6 +87,14 @@
     // Access guarded by 'lock'
     private List<Realm> testRealms;
 
+    // List of closable resources that will be automatically closed when the test finishes.
+    // Access guarded by 'lock'
+    private List<Closeable> closableResources;
+
+    // Runnable guaranteed to trigger after the test either succeeded or failed.
+    // Access guarded by 'lock'
+    private List<Runnable> runAfterTestIsComplete = new ArrayList<>();
+
     /**
      * Get the configuration for the test realm.
      * <p>
@@ -129,6 +143,33 @@ public void keepStrongReference(Object obj) {
         }
     }
 
+    /**
+     * Add a closable resource which this test will guarantee to call {@link Closeable#close()} on
+     * when the tests is done.
+     *
+     * @param closeable {@link Closeable} to close.
+     */
+    public void closeAfterTest(Closeable closeable) {
+        synchronized (lock) {
+            closableResources.add(closeable);
+        }
+    }
+
+    /**
+     * Run this task after the unit test either failed or succeeded.
+     * This is a work-around for the the current @After being triggered right after the unit test method exits,
+     * but before the @RunTestInLooperThread has determined the test is done
+     *
+     * TODO: Consider replacing this pattern with `@AfterLooperTest` annotation.
+     *
+     * @param task task to run. Only one task can be provided
+     */
+    public void runAfterTest(Runnable task) {
+        synchronized (lock) {
+            runAfterTestIsComplete.add(task);
+        }
+    }
+
     /**
      * Add a Realm to be closed when test is complete.
      * <p>
@@ -227,6 +268,7 @@ protected void before() throws Throwable {
         RealmConfiguration config = createConfiguration(UUID.randomUUID().toString());
         LinkedList<Object> refs = new LinkedList<>();
         List<Realm> realms = new LinkedList<>();
+        LinkedList<Closeable> closeables = new LinkedList<>();
 
         synchronized (lock) {
             realmConfiguration = config;
@@ -234,11 +276,16 @@ protected void before() throws Throwable {
             backgroundHandler = null;
             keepStrongReference = refs;
             testRealms = realms;
+            closableResources = closeables;
         }
     }
 
     @Override
     protected void after() {
+        // Wait for all async tasks to have completed to ensure a successful deleteRealm call.
+        // If it times out, it will throw.
+        TestHelper.waitRealmThreadExecutorFinish();
+        AndroidCapabilities.EMULATE_MAIN_THREAD = false;
         super.after();
 
         // probably belt *and* suspenders...
@@ -250,10 +297,14 @@ protected void after() {
 
     @Override
     public Statement apply(Statement base, Description description) {
+        setTestName(description);
         final RunTestInLooperThread annotation = description.getAnnotation(RunTestInLooperThread.class);
         if (annotation == null) {
             return base;
         }
+        synchronized (lock) {
+            ruleBeingUsed = true;
+        }
         return new RunInLooperThreadStatement(annotation, base);
     }
 
@@ -286,6 +337,31 @@ private void closeRealms() {
         }
     }
 
+    private void closeResources() throws IOException {
+        synchronized (lock) {
+            for (Closeable cr : closableResources) {
+                cr.close();
+            }
+        }
+    }
+
+    /**
+     * Checks if the current test is considered completed or not.
+     * It is completed if either {@link #testComplete()} was called or an uncaught exception was thrown.
+     */
+    public boolean isTestComplete() {
+        synchronized (lock) {
+            return signalTestCompleted.getCount() == 0;
+        }
+    }
+
+    /**
+     * Returns true if the current test being run is using this rule.
+     */
+    public boolean isRuleUsed() {
+        return ruleBeingUsed;
+    }
+
     /**
      * If an implementation of this is supplied with the annotation, the {@link RunnableBefore#run(RealmConfiguration)}
      * will be executed before the looper thread starts. It is normally for populating the Realm before the test.
@@ -315,6 +391,7 @@ public void evaluate() throws Throwable {
                 runnableBefore.newInstance().run(getConfiguration());
             }
 
+            AndroidCapabilities.EMULATE_MAIN_THREAD = annotation.emulateMainThread();
             runTest(annotation.threadName());
         }
 
@@ -423,6 +500,10 @@ public void run() {
             } finally {
                 try {
                     looperTearDown();
+                    closeResources();
+                    for (Runnable task : runAfterTestIsComplete) {
+                        task.run();
+                    }
                 } catch (Throwable t) {
                     setAssertionError(t);
                     setUnitTestFailed();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestInLooperThread.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestInLooperThread.java
index c24c085983..6413757f10 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestInLooperThread.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestInLooperThread.java
@@ -33,4 +33,5 @@
 public @interface RunTestInLooperThread {
         String threadName() default "RunTestInLooperThread";
         Class<?extends RunInLooperThread.RunnableBefore> before() default RunInLooperThread.RunnableBefore.class;
+        boolean emulateMainThread() default false;
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestWithRemoteService.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestWithRemoteService.java
new file mode 100644
index 0000000000..1286630c0e
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunTestWithRemoteService.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.rule;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import io.realm.services.RemoteTestService;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * This should be used along with {@link RunWithRemoteService}. See comments there for usage.
+ */
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface RunTestWithRemoteService {
+    Class<? extends RemoteTestService> remoteService();
+    boolean onLooperThread();
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/RunWithRemoteService.java b/realm/realm-library/src/androidTest/java/io/realm/rule/RunWithRemoteService.java
new file mode 100644
index 0000000000..8aff527678
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/RunWithRemoteService.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.rule;
+
+import android.app.ActivityManager;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.RemoteException;
+
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+
+import io.realm.TestHelper;
+import io.realm.services.RemoteTestService;
+
+import static android.support.test.InstrumentationRegistry.getContext;
+import static junit.framework.Assert.assertTrue;
+import static junit.framework.Assert.fail;
+
+/**
+ * This is a helper {@link TestRule} to do test which needs interaction with a remote process.
+ * To use this:
+ * 1. Define a subclass of {@link RemoteTestService} and create steps as static member of it. Those steps should be
+ * named as "stepA_doXXX", "stepB_doYYY", etc. to indicate the order of them.
+ * 2. Add a base message id in {@link RemoteTestService}.
+ * 3. Add the service into the AndroidManifest.xml. And the android:process property must be ":remote".
+ * 4. Annotate your test case by {@link RunTestWithRemoteService} with your remote service class.
+ * 5. To run the tests on the looper thread:
+ *    a) Add {@link RunTestInLooperThread} to the tests.
+ *    b) Add {@code @RunTestWithRemoteService(remoteService = SimpleCommitRemoteService.class, onLooperThread = true)}
+ *       Please notice that {@code onLooperThread} needs to be set to true to avoid the remote service getting killed
+ *       before looper thread finished
+ *    c) Call {@code looperThread.runAfterTest(remoteService.afterRunnable)} to kill the remote service after test.
+ * 6. When your looper thread starts, register the service messenger by calling
+ * {@link RunWithRemoteService#createHandler(Looper)}.
+ * 7. Trigger your first step in the remote service process by calling
+ * {@link RunWithRemoteService#triggerServiceStep(RemoteTestService.Step)}.
+ * 8. Name steps in the foreground process with step1, step2 ... stepN.
+ *    Name steps in the remote process with stepA, stepB ... stepZ.
+ *
+ * See the existing test cases for examples.
+ */
+public class RunWithRemoteService implements TestRule {
+
+    private class InterprocessHandler extends Handler {
+
+        private InterprocessHandler(Looper looper) {
+            super(looper);
+            localMessenger = new Messenger(this);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            Bundle bundle = msg.getData();
+            String error = bundle.getString(RemoteTestService.BUNDLE_KEY_ERROR);
+            if (error != null) {
+                // Assert and show error from remote process
+                fail(error);
+            }
+        }
+    }
+
+    private static final String REMOTE_PROCESS_POSTFIX = ":remote";
+
+    private Messenger remoteMessenger;
+    private Messenger localMessenger;
+    private CountDownLatch serviceStartLatch;
+    public Runnable afterRunnable = new Runnable() {
+        @Override
+        public void run() {
+            after();
+        }
+    };
+
+    private final ServiceConnection serviceConnection = new ServiceConnection() {
+        @Override
+        public void onServiceConnected(ComponentName componentName, IBinder iBinder) {
+            remoteMessenger = new Messenger(iBinder);
+            serviceStartLatch.countDown();
+        }
+
+        @Override
+        public void onServiceDisconnected(ComponentName componentName) {
+            if (serviceStartLatch != null && serviceStartLatch.getCount() > 1) {
+                serviceStartLatch.countDown();
+            }
+            serviceStartLatch = null;
+            remoteMessenger = null;
+        }
+    };
+
+    private void before(Class<?> serviceClass) throws Throwable {
+        // Start the testing remote process.
+        serviceStartLatch = new CountDownLatch(1);
+        Intent intent = new Intent(getContext(), serviceClass);
+        getContext().bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);
+        TestHelper.awaitOrFail(serviceStartLatch);
+    }
+
+    private void after() {
+        getContext().unbindService(serviceConnection);
+
+        // Kill the remote process.
+        ActivityManager.RunningAppProcessInfo info = getRemoteProcessInfo();
+        if (info != null) {
+            android.os.Process.killProcess(info.pid);
+        }
+        int counter = 10;
+        while (getRemoteProcessInfo() != null) {
+            if (counter == 0) {
+                fail("The remote process is still alive.");
+            }
+            try {
+                Thread.sleep(300);
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
+            }
+            counter--;
+        }
+    }
+
+    @Override
+    public Statement apply(final Statement base, Description description) {
+        final RunTestWithRemoteService annotation = description.getAnnotation(RunTestWithRemoteService.class);
+        if (annotation == null) {
+            return base;
+        }
+        return new Statement() {
+            @Override
+            public void evaluate() throws Throwable {
+                before(annotation.remoteService());
+                try {
+                    base.evaluate();
+                } finally {
+                    if (!annotation.onLooperThread()) {
+                        after();
+                    }
+                }
+            }
+        };
+    }
+
+    public void createHandler(Looper looper) {
+        new InterprocessHandler(looper);
+    }
+
+    // Call this to trigger the next step of remote process
+    public void triggerServiceStep(RemoteTestService.Step step) {
+        Message msg = Message.obtain(null, step.message);
+        msg.replyTo = localMessenger;
+        try {
+            remoteMessenger.send(msg);
+        } catch (RemoteException e) {
+            fail(e.getMessage());
+        }
+        // TODO: Find a way to block caller thread until the service process finishes current step.
+    }
+
+    // Get the remote process info if it is alive.
+    private ActivityManager.RunningAppProcessInfo getRemoteProcessInfo() {
+        ActivityManager manager = (ActivityManager)getContext().getSystemService(Context.ACTIVITY_SERVICE);
+        List<ActivityManager.RunningAppProcessInfo> processInfoList = manager.getRunningAppProcesses();
+        for (ActivityManager.RunningAppProcessInfo info : processInfoList) {
+            if (info.processName.equals(getContext().getPackageName() + REMOTE_PROCESS_POSTFIX)) {
+                return info;
+            }
+        }
+
+        return null;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
index 04bc9a4f6d..74a0ec5a15 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/rule/TestRealmConfigurationFactory.java
@@ -28,17 +28,13 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Collections;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 
-import io.realm.DynamicRealm;
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
-import io.realm.RealmMigration;
-import io.realm.RealmObject;
-import io.realm.TestHelper;
-import io.realm.annotations.RealmModule;
 
 import static org.junit.Assert.assertTrue;
 
@@ -53,12 +49,15 @@
     private final Set<RealmConfiguration> configurations = Collections.newSetFromMap(map);
 
     private boolean unitTestFailed = false;
+    private String testName = "";
+    private File tempFolder = null;
 
     @Override
-    public Statement apply(final Statement base, Description description) {
+    public Statement apply(final Statement base, final Description description) {
         return new Statement() {
             @Override
             public void evaluate() throws Throwable {
+                setTestName(description);
                 before();
                 try {
                     base.evaluate();
@@ -80,10 +79,6 @@ protected void before() throws Throwable {
 
     @Override
     protected void after() {
-        // Waits all async tasks done to ensure successful deleteRealm call.
-        // This will throw when timeout. And the reason of timeout needs to be solved properly.
-        TestHelper.waitRealmThreadExecutorFinish();
-
         try {
             for (RealmConfiguration configuration : configurations) {
                 Realm.deleteRealm(configuration);
@@ -99,6 +94,30 @@ protected void after() {
         }
     }
 
+    @Override
+    public void create() throws IOException {
+        super.create();
+        tempFolder = new File(super.getRoot(), testName);
+        tempFolder.delete();
+        tempFolder.mkdir();
+    }
+
+    @Override
+    public File getRoot() {
+        if (tempFolder == null) {
+            throw new IllegalStateException(
+                    "the temporary folder has not yet been created");
+        }
+        return tempFolder;
+    }
+
+    /**
+     * To be called in the {@link #apply(Statement, Description)}.
+     */
+    protected void setTestName(Description description) {
+        testName = description.getDisplayName();
+    }
+
     public synchronized void setUnitTestFailed() {
         this.unitTestFailed = true;
     }
@@ -172,8 +191,9 @@ public void copyRealmFromAssets(Context context, String realmPath, String newNam
     }
 
     public void copyRealmFromAssets(Context context, String realmPath, RealmConfiguration config) throws IOException {
-        // Deletes the existing file before copy
-        Realm.deleteRealm(config);
+        if (new File(config.getPath()).exists()) {
+            throw new IllegalStateException(String.format(Locale.ENGLISH, "%s exists!", config.getPath()));
+        }
 
         File outFile = new File(config.getRealmDirectory(), config.getRealmFileName());
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java b/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java
index 78c7c18575..4062ee8e38 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/services/RemoteProcessService.java
@@ -34,6 +34,7 @@
 
 /**
  * Helper service for multi-processes support testing.
+ * @deprecated use {@link RemoteTestService} instead.
  */
 public class RemoteProcessService extends Service {
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/services/RemoteTestService.java b/realm/realm-library/src/androidTest/java/io/realm/services/RemoteTestService.java
new file mode 100644
index 0000000000..46eee6e089
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/services/RemoteTestService.java
@@ -0,0 +1,183 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.services;
+
+import android.annotation.SuppressLint;
+import android.app.Service;
+import android.content.Intent;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.RemoteException;
+import android.os.StrictMode;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.util.HashMap;
+import java.util.Map;
+
+import io.realm.Realm;
+import io.realm.internal.Util;
+import io.realm.log.RealmLog;
+
+/**
+ * Helper class for multi-processes support testing.
+ * @see io.realm.rule.RunWithRemoteService
+ */
+public abstract class RemoteTestService extends Service {
+    // There is no easy way to dynamically ensure step IDs have same value for different processes. So, use the stupid
+    // way.
+    private static int BASE_MSG_ID = 0;
+    protected static int BASE_SIMPLE_COMMIT = BASE_MSG_ID;
+    protected static int BASE_A_LOT_COMMITS  = BASE_SIMPLE_COMMIT + 100;
+
+    public static abstract class Step {
+        public final int message;
+
+        protected Step(int base, int id) {
+            this.message = base + id;
+            stepMap.put(this.message, this);
+        }
+
+        protected abstract void run();
+
+        protected RemoteTestService getService() {
+            return RemoteTestService.thiz;
+        }
+
+        // Pass a null to tell main process that everything is OK.
+        // Otherwise, pass an error String which will be used by assertion in main process.
+        private void response(String error) {
+            try {
+                Message msg = Message.obtain(null, message);
+                if (error != null) {
+                    Bundle bundle = new Bundle();
+                    bundle.putString(BUNDLE_KEY_ERROR, error);
+                    msg.setData(bundle);
+                }
+                thiz.client.send(msg);
+            } catch (RemoteException e) {
+                RealmLog.error(e);
+            }
+        }
+    }
+
+    public static final String BUNDLE_KEY_ERROR = "error";
+    @SuppressLint("UseSparseArrays")
+    private static Map<Integer, Step> stepMap = new HashMap<Integer, Step>();
+    public static RemoteTestService thiz;
+    private final Messenger messenger = new Messenger(new IncomingHandler());
+    private Messenger client;
+    private File rootFolder;
+    private Realm realm;
+
+    public RemoteTestService() {
+        if (thiz != null) {
+            throw new RuntimeException("Only one instance is allowed!");
+        }
+        thiz = this;
+    }
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();
+        StrictMode.setThreadPolicy(policy);
+        try {
+            rootFolder = File.createTempFile(this.getClass().getSimpleName(), "");
+        } catch (IOException e) {
+            RealmLog.error(e);
+        }
+        //noinspection ResultOfMethodCallIgnored
+        rootFolder.delete();
+        //noinspection ResultOfMethodCallIgnored
+        rootFolder.mkdir();
+
+        Realm.init(getApplicationContext());
+    }
+
+    public File getRoot() {
+        return rootFolder;
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return messenger.getBinder();
+    }
+
+    @Override
+    public boolean onUnbind(Intent intent) {
+        stopSelf();
+        recursiveDelete(rootFolder);
+        return super.onUnbind(intent);
+    }
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        return START_NOT_STICKY;
+    }
+
+    private static class IncomingHandler extends Handler {
+        @Override
+        public void handleMessage(Message msg) {
+            thiz.client = msg.replyTo;
+            if (thiz.client == null) {
+                throw new RuntimeException("Message with an empty client.");
+            }
+            Step step = stepMap.get(msg.what);
+            Throwable throwable = null;
+            if (step != null) {
+                try {
+                    step.run();
+                } catch (Throwable t) {
+                    throwable = t;
+                } finally {
+                    if (throwable != null) {
+                        step.response(throwable.getMessage() + "\n" + Util.getStackTrace(throwable));
+                    } else {
+                        step.response(null);
+                    }
+                }
+            } else {
+                throw new RuntimeException("Cannot find corresponding step to message " + msg.what + ".");
+            }
+        }
+    }
+
+    private void recursiveDelete(File file) {
+        File[] files = file.listFiles();
+        if (files != null) {
+            for (File each : files) {
+                recursiveDelete(each);
+            }
+        }
+        //noinspection ResultOfMethodCallIgnored
+        file.delete();
+    }
+
+    public Realm getRealm() {
+        return realm;
+    }
+
+    public void setRealm(Realm realm) {
+        this.realm = realm;
+    }
+}
diff --git a/realm/realm-library/src/androidTest/kotlin/io/realm/KotlinSchemaTests.kt b/realm/realm-library/src/androidTest/kotlin/io/realm/KotlinSchemaTests.kt
new file mode 100644
index 0000000000..a6a9c34b5a
--- /dev/null
+++ b/realm/realm-library/src/androidTest/kotlin/io/realm/KotlinSchemaTests.kt
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm
+
+import android.support.test.runner.AndroidJUnit4
+import io.realm.entities.AllKotlinTypes
+import io.realm.rule.TestRealmConfigurationFactory
+import org.junit.After
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertTrue
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+
+/**
+ * This class tests how Kotlin classes are interpreted by Realm and exposed in the RealmSchema
+ */
+@RunWith(AndroidJUnit4::class)
+class KotlinSchemaTests {
+
+    @get:Rule
+    val configFactory = TestRealmConfigurationFactory()
+
+    private lateinit var realm: Realm
+
+    @Before
+    fun setUp() {
+        realm = Realm.getInstance(configFactory.createConfiguration())
+    }
+
+    @After
+    fun tearDown() {
+        realm.close()
+    }
+
+    @Test
+    fun kotlinTypeNonNull() {
+        val objSchema = realm.schema.get(AllKotlinTypes::class.simpleName!!)!!
+
+        assertFalse(objSchema.isNullable(AllKotlinTypes::nonNullBinary.name));
+        assertFalse(objSchema.isNullable(AllKotlinTypes::nonNullBoolean.name));
+        assertFalse(objSchema.isNullable(AllKotlinTypes::nonNullString.name));
+        assertFalse(objSchema.isNullable(AllKotlinTypes::nonNullLong.name));
+        assertFalse(objSchema.isNullable(AllKotlinTypes::nonNullInt.name));
+        assertFalse(objSchema.isNullable(AllKotlinTypes::nonNullShort.name));
+        assertFalse(objSchema.isNullable(AllKotlinTypes::nonNullByte.name));
+        assertFalse(objSchema.isNullable(AllKotlinTypes::nonNullDate.name));
+        assertFalse(objSchema.isNullable(AllKotlinTypes::nonNullDouble.name));
+        assertFalse(objSchema.isNullable(AllKotlinTypes::nonNullFloat.name));
+        assertFalse(objSchema.isNullable(AllKotlinTypes::nonNullList.name));
+        // We cannot enforce this constraint inside the schema right now.
+        // If people maintain the variant themselves they need a custom getter
+        // assertTrue(objSchema.isNullable(AllKotlinTypes::nonNullObject.name));
+    }
+
+    @Test
+    fun kotlinTypeNull() {
+        val objSchema = realm.schema.get(AllKotlinTypes::class.simpleName!!)!!
+        assertTrue(objSchema.isNullable(AllKotlinTypes::nullBinary.name));
+        assertTrue(objSchema.isNullable(AllKotlinTypes::nullBoolean.name));
+        assertTrue(objSchema.isNullable(AllKotlinTypes::nullString.name));
+        assertTrue(objSchema.isNullable(AllKotlinTypes::nullLong.name));
+        assertTrue(objSchema.isNullable(AllKotlinTypes::nullInt.name));
+        assertTrue(objSchema.isNullable(AllKotlinTypes::nullShort.name));
+        assertTrue(objSchema.isNullable(AllKotlinTypes::nullByte.name));
+        assertTrue(objSchema.isNullable(AllKotlinTypes::nullDate.name));
+        assertTrue(objSchema.isNullable(AllKotlinTypes::nullDouble.name));
+        assertTrue(objSchema.isNullable(AllKotlinTypes::nullFloat.name));
+        assertFalse(objSchema.isNullable(AllKotlinTypes::nullList.name)); // Managed realm objects do not allow null lists
+        assertTrue(objSchema.isNullable(AllKotlinTypes::nullObject.name));
+    }
+
+}
diff --git a/realm/realm-library/src/androidTest/kotlin/io/realm/entities/AllKotlinTypes.kt b/realm/realm-library/src/androidTest/kotlin/io/realm/entities/AllKotlinTypes.kt
new file mode 100644
index 0000000000..79e36419be
--- /dev/null
+++ b/realm/realm-library/src/androidTest/kotlin/io/realm/entities/AllKotlinTypes.kt
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities
+
+import io.realm.RealmList
+import io.realm.RealmObject
+import io.realm.RealmResults
+import io.realm.annotations.Ignore
+import io.realm.annotations.Index
+import io.realm.annotations.LinkingObjects
+import io.realm.annotations.PrimaryKey
+import java.util.*
+
+open class AllKotlinTypes : RealmObject() {
+
+    @Ignore
+    var ignoredString: String = ""
+    var nullString: String? = null
+    var nonNullString: String = ""
+    @Index
+    var indexedString: String = ""
+
+    var nullLong: Long? = null
+    @PrimaryKey
+    var nonNullLong: Long = 0
+
+    var nullShort : Short? = null
+    var nonNullShort: Short = 0
+
+    var nullInt: Int? = null
+    var nonNullInt: Int = 0
+
+    var nullByte: Byte? = null
+    var nonNullByte: Byte = 0
+
+    var nullFloat: Float? = null
+    var nonNullFloat: Float = 0F
+
+    var nullDouble: Double? = null
+    var nonNullDouble: Double = 0.0 // Double by default
+
+    var nullBoolean: Boolean? = null
+    var nonNullBoolean: Boolean = false
+
+    var nullDate: Date? = null
+    var nonNullDate: Date = Date()
+
+    var nullBinary: ByteArray? = null
+    var nonNullBinary: ByteArray = ByteArray(0)
+
+    // This turns into Byte[] which we dont support for some reason?
+    // var nullBoxedBinary: Array<Byte>? = null
+    // var nonNullBoxedBinary: Array<Byte> = emptyArray()
+
+    var nullObject: AllKotlinTypes? = null
+
+    // Not-null object references cannot be enforced generically at the schema level, e.g. sync that
+    // removes an object reference.
+    // If people can maintain the variant themselves they can just expose a custom non-null getter.
+    // var nonNullObject: AllKotlinTypes = AllKotlinTypes()
+
+    // This is only possible in unmanaged objects, managed objects are never null
+    // For now we allow this anyway.
+    var nullList: RealmList<AllKotlinTypes>? = null
+    var nonNullList: RealmList<AllKotlinTypes> = RealmList()
+
+    @LinkingObjects("nullObject")
+    val objectParents: RealmResults<AllKotlinTypes>? = null;
+
+    @LinkingObjects("nonNullList")
+    val listParents: RealmResults<AllKotlinTypes>? = null;
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
index 54a87b468c..b2aaa7cc5a 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/AuthenticateRequestTests.java
@@ -39,8 +39,8 @@ public void setUp() {
 
     @Test
     public void realmLogin() throws URISyntaxException, JSONException {
-        Token t = SyncTestUtils.createTestUser().getSyncUser().getUserToken();
-        AuthenticateRequest request = AuthenticateRequest.realmLogin(t, new URI("realm://objectserver/" + t.identity() + "/default"));
+        Token t = SyncTestUtils.createTestUser().getRefreshToken();
+        AuthenticateRequest request = AuthenticateRequest.realmLogin(t, new URI("realm://objectserver/" + t.identity() + "/default").getPath());
 
         JSONObject obj = new JSONObject(request.toJson());
         assertEquals("/" + t.identity() + "/default", obj.get("path"));
@@ -60,8 +60,8 @@ public void userLogin() throws URISyntaxException, JSONException {
 
     @Test
     public void userRefresh() throws URISyntaxException, JSONException {
-        Token t = SyncTestUtils.createTestUser().getSyncUser().getUserToken();
-        AuthenticateRequest request = AuthenticateRequest.userRefresh(t, new URI("realm://objectserver/" + t.identity() + "/default"));
+        Token t = SyncTestUtils.createTestUser().getRefreshToken();
+        AuthenticateRequest request = AuthenticateRequest.userRefresh(t, new URI("realm://objectserver/" + t.identity() + "/default").getPath());
 
         JSONObject obj = new JSONObject(request.toJson());
         assertTrue(obj.has("path"));
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/PermissionRequestTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/PermissionRequestTests.java
new file mode 100644
index 0000000000..5ecde21eca
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/PermissionRequestTests.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.permissions.AccessLevel;
+import io.realm.permissions.PermissionRequest;
+import io.realm.permissions.UserCondition;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+
+@RunWith(AndroidJUnit4.class)
+public class PermissionRequestTests {
+
+    @Test
+    public void nullArgumentsThrows() {
+        try {
+            new PermissionRequest(null, "*", AccessLevel.ADMIN);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertTrue(e.getMessage().contains("Non-null 'condition' required."));
+        }
+
+        try {
+            new PermissionRequest(UserCondition.userId("id"), null, AccessLevel.ADMIN);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertTrue(e.getMessage().contains("Non-empty 'realmUrl' required."));
+        }
+
+        try {
+            new PermissionRequest(UserCondition.userId("id"), "*", null);
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertTrue(e.getMessage().contains("Non-null 'accessLevel' required."));
+        }
+    }
+
+    @Test
+    public void url_throwsOnInvalidURIs() {
+        String[] invalidUrls = { "", "\\", "<foo>" };
+        for (String url : invalidUrls) {
+            try {
+                new PermissionRequest(UserCondition.userId("id"), url, AccessLevel.ADMIN);
+                fail(url + " should have thrown");
+            } catch (IllegalArgumentException ignore) {
+            }
+        }
+    }
+
+    @Test
+    public void url_validURIs() {
+        // We support "*" and valid URI's
+        // We don't attempt to do more validation than that and leaves that up to ROS
+        String[] validUrls = {
+                "*",
+                "http://foo/bar/baz",
+                "https://foo/bar/baz",
+                "realm://foo.bar/~/default",
+                "realms://foo.bar/~/default"
+        };
+        for (String url : validUrls) {
+            PermissionRequest request = new PermissionRequest(UserCondition.userId("id"), url, AccessLevel.ADMIN);
+            assertEquals(url, request.getUrl());
+        }
+    }
+
+    @Test
+    public void getters() {
+        UserCondition condition = UserCondition.userId("id");
+        String url = "*";
+        AccessLevel accessLevel = AccessLevel.ADMIN;
+
+        PermissionRequest request = new PermissionRequest(condition, url, accessLevel);
+
+        assertEquals(condition, request.getCondition());
+        assertEquals(url, request.getUrl());
+        assertEquals(accessLevel, request.getAccessLevel());
+    }
+
+    @Test
+    public void equals() {
+        PermissionRequest r1 = new PermissionRequest(UserCondition.userId("id"), "*", AccessLevel.ADMIN);
+        PermissionRequest r2 = new PermissionRequest(UserCondition.userId("id"), "*", AccessLevel.ADMIN);
+
+        assertTrue(r1.equals(r2));
+        assertTrue(r2.equals(r1));
+        assertEquals(r1.hashCode(), r2.hashCode());
+    }
+
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/ProgressTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/ProgressTests.java
new file mode 100644
index 0000000000..22c31bc2a5
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/ProgressTests.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Locale;
+
+import static org.junit.Assert.assertEquals;
+
+@RunWith(AndroidJUnit4.class)
+public class ProgressTests {
+
+    @Test
+    public void getFractionTransferred() {
+        Object[][] testData = {
+            { 0L, 0L, 1.0D },
+            { 0L, 1L, 0.0D },
+            { 1L, 1L, 1.0D },
+            { 1L, 2L, 0.5D }
+        };
+
+        for (Object[] test : testData) {
+            long transferredBytes = (long) test[0];
+            long transferableBytes = (long) test[1];
+            double fraction = (double) test[2];
+            Progress progress = new Progress(transferredBytes, transferableBytes);
+            String errorMessage = String.format(Locale.US, "Failed with: (%d, %d)", transferredBytes, transferableBytes);
+            assertEquals(errorMessage, fraction, progress.getFractionTransferred(), 0.0D);
+        }
+    }
+
+    @Test
+    public void getTransferredBytes () {
+        long[] testData = { 0, Long.MAX_VALUE };
+
+        for (long transferredBytes : testData) {
+            String errorMessage = String.format(Locale.US, "Failed with: %d", transferredBytes);
+            Progress progress = new Progress(transferredBytes, Long.MAX_VALUE);
+            assertEquals(errorMessage, transferredBytes, progress.getTransferredBytes());
+        }
+    }
+
+    @Test
+    public void getTransferableBytes () {
+        long[] testData = { 0, Long.MAX_VALUE };
+
+        for (long transferableBytes : testData) {
+            String errorMessage = String.format(Locale.US, "Failed with: %d", transferableBytes);
+            Progress progress = new Progress(0, transferableBytes);
+            assertEquals(errorMessage, transferableBytes, progress.getTransferableBytes());
+        }
+    }
+
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java
index d9dd20f801..e1c613eb86 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SchemaTests.java
@@ -25,11 +25,13 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.util.Set;
+
 import io.realm.entities.StringOnly;
-import io.realm.rule.TestRealmConfigurationFactory;
 import io.realm.util.SyncTestUtils;
 
 import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertNotNull;
 import static junit.framework.Assert.assertTrue;
 import static junit.framework.TestCase.assertFalse;
 import static org.junit.Assert.fail;
@@ -37,19 +39,18 @@
 @RunWith(AndroidJUnit4.class)
 public class SchemaTests {
     @Rule
-    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    public final TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
 
     private SyncConfiguration config;
 
     @Before
     public void setUp() {
         SyncUser user = SyncTestUtils.createTestUser();
-        config = new SyncConfiguration.Builder(user, "realm://objectserver.realm.io/~/default").build();
+        config = configFactory.createSyncConfigurationBuilder(user, "realm://objectserver.realm.io/~/default").build();
     }
 
     @After
     public void tearDown() throws Exception {
-        Realm.deleteRealm(config);
     }
 
     @Test
@@ -74,7 +75,10 @@ public void createObject() {
 
     @Test
     public void disallow_removeClass() {
-        Realm realm = Realm.getInstance(config);
+        // Init schema
+        Realm.getInstance(config).close();
+
+        DynamicRealm realm = DynamicRealm.getInstance(config);
         String className = "StringOnly";
         realm.beginTransaction();
         assertTrue(realm.getSchema().contains(className));
@@ -90,7 +94,7 @@ public void disallow_removeClass() {
 
     @Test
     public void allow_createClass() {
-        Realm realm = Realm.getInstance(config);
+        DynamicRealm realm = DynamicRealm.getInstance(config);
         String className = "Dogplace";
         realm.beginTransaction();
         realm.getSchema().create("Dogplace");
@@ -101,7 +105,10 @@ public void allow_createClass() {
 
     @Test
     public void disallow_renameClass() {
-        Realm realm = Realm.getInstance(config);
+        // Init schema
+        Realm.getInstance(config).close();
+
+        DynamicRealm realm = DynamicRealm.getInstance(config);
         String className = "StringOnly";
         realm.beginTransaction();
         try {
@@ -117,13 +124,18 @@ public void disallow_renameClass() {
 
     @Test
     public void disallow_removeField() {
-        Realm realm = Realm.getInstance(config);
+        // Init schema
+        Realm.getInstance(config).close();
+
+        DynamicRealm realm = DynamicRealm.getInstance(config);
         String className = "StringOnly";
         String fieldName = "chars";
+        final RealmObjectSchema objectSchema = realm.getSchema().get(className);
+        assertNotNull(objectSchema);
+        assertTrue(objectSchema.hasField(fieldName));
         realm.beginTransaction();
-        assertTrue(realm.getSchema().get(className).hasField(fieldName));
         try {
-            realm.getSchema().get(className).removeField(fieldName);
+            objectSchema.removeField(fieldName);
             fail();
         } catch (IllegalArgumentException ignored) {
         } finally {
@@ -134,15 +146,77 @@ public void disallow_removeField() {
 
     @Test
     public void allow_addField() {
+        // Init schema
+        Realm.getInstance(config).close();
         String className = "StringOnly";
-        Realm realm = Realm.getInstance(config);
 
+        DynamicRealm realm = DynamicRealm.getInstance(config);
+        final RealmObjectSchema objectSchema = realm.getSchema().get(className);
+        assertNotNull(objectSchema);
         realm.beginTransaction();
-        realm.getSchema().get(className).addField("foo", String.class);
+        objectSchema.addField("foo", String.class);
         realm.commitTransaction();
 
-        assertTrue(realm.getSchema().get(className).hasField("foo"));
+        assertTrue(objectSchema.hasField("foo"));
+
+        realm.close();
+    }
+
+    @Test
+    public void addPrimaryKey_notAllowed() {
+        // Init schema
+        Realm.getInstance(config).close();
+        String className = "StringOnly";
+        String fieldName = "chars";
+        DynamicRealm realm = DynamicRealm.getInstance(config);
+
+        RealmObjectSchema objectSchema = realm.getSchema().get(className);
+        assertNotNull(objectSchema);
+        assertTrue(objectSchema.hasField(fieldName));
+
+        realm.beginTransaction();
+        try {
+            objectSchema.addPrimaryKey(fieldName);
+            fail();
+        } catch (UnsupportedOperationException ignored) {
+        } finally {
+            realm.cancelTransaction();
+            realm.close();
+        }
+    }
+
+    @Test
+    public void addField_withPrimaryKeyModifier_notAllowed() {
+        // Init schema
+        Realm.getInstance(config).close();
+        String className = "StringOnly";
+        DynamicRealm realm = DynamicRealm.getInstance(config);
+
+        realm.beginTransaction();
+        RealmObjectSchema objectSchema = realm.getSchema().get(className);
+        assertNotNull(objectSchema);
+
+        try {
+            objectSchema.addField("bar", String.class, FieldAttribute.PRIMARY_KEY);
+            fail();
+        } catch (UnsupportedOperationException ignored) {
+        } finally {
+            realm.cancelTransaction();
+            realm.close();
+        }
+    }
+
+    // Special column "__OID" should be hidden from users.
+    @Test
+    public void getFieldNames_stableIdColumnShouldBeHidden() {
+        String className = "StringOnly";
+        Realm realm = Realm.getInstance(config);
 
+        RealmObjectSchema objectSchema = realm.getSchema().get(className);
+        assertNotNull(objectSchema);
+        Set<String> names = objectSchema.getFieldNames();
+        assertEquals(1, names.size());
+        assertEquals(StringOnly.FIELD_CHARS, names.iterator().next());
         realm.close();
     }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index d5c949a1bf..f4dc71ac09 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -16,6 +16,8 @@
 
 package io.realm;
 
+import android.support.test.annotation.UiThreadTest;
+import android.support.test.rule.UiThreadTestRule;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.Before;
@@ -23,13 +25,17 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import io.realm.entities.StringOnly;
+import io.realm.exceptions.RealmFileException;
+import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
-import io.realm.rule.TestSyncConfigurationFactory;
 
 import static io.realm.util.SyncTestUtils.createTestUser;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -47,6 +53,9 @@
     @Rule
     public final RunInLooperThread looperThread = new RunInLooperThread();
 
+    @Rule
+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();
+
     @Before
     public void setUp() {
         user = createTestUser();
@@ -56,18 +65,66 @@ public void setUp() {
     @Test
     public void get_syncValues() {
         SyncSession session = new SyncSession(configuration);
-        assertEquals("realm://objectserver.realm.io/JohnDoe/default", session.getServerUrl().toString());
+        assertEquals("realm://objectserver.realm.io/" + user.getIdentity() + "/default", session.getServerUrl().toString());
         assertEquals(user, session.getUser());
         assertEquals(configuration, session.getConfiguration());
     }
 
+    @Test
+    public void addDownloadProgressListener_nullThrows() {
+        SyncSession session = SyncManager.getSession(configuration);
+        try {
+            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void addUploadProgressListener_nullThrows() {
+        SyncSession session = SyncManager.getSession(configuration);
+        try {
+            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, null);
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void removeProgressListener() {
+        Realm realm = Realm.getInstance(configuration);
+        SyncSession session = SyncManager.getSession(configuration);
+        ProgressListener[] listeners = new ProgressListener[] {
+                null,
+                new ProgressListener() {
+                    @Override
+                    public void onChange(Progress progress) {
+                        // Listener 1, not present
+                    }
+                },
+                new ProgressListener() {
+                    @Override
+                    public void onChange(Progress progress) {
+                        // Listener 2, present
+                    }
+                }
+        };
+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, listeners[2]);
+
+        // Check that remove works unconditionally for all input
+        for (ProgressListener listener : listeners) {
+            session.removeProgressListener(listener);
+        }
+        realm.close();
+    }
+
     // Check that a Client Reset is correctly reported.
     @Test
     @RunTestInLooperThread
     public void errorHandler_clientResetReported() {
         SyncUser user = createTestUser();
         String url = "realm://objectserver.realm.io/default";
-        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user , url)
+        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
                 .errorHandler(new SyncSession.ErrorHandler() {
                     @Override
                     public void onError(SyncSession session, ObjectServerError error) {
@@ -82,6 +139,7 @@ public void onError(SyncSession session, ObjectServerError error) {
                         assertEquals(filePathFromError, filePathFromConfig);
                         assertFalse(handler.getBackupFile().exists());
                         assertTrue(handler.getOriginalFile().exists());
+
                         looperThread.testComplete();
                     }
                 })
@@ -100,7 +158,7 @@ public void onError(SyncSession session, ObjectServerError error) {
     public void errorHandler_manualExecuteClientReset() {
         SyncUser user = createTestUser();
         String url = "realm://objectserver.realm.io/default";
-        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user , url)
+        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
                 .errorHandler(new SyncSession.ErrorHandler() {
                     @Override
                     public void onError(SyncSession session, ObjectServerError error) {
@@ -134,4 +192,239 @@ public void onError(SyncSession session, ObjectServerError error) {
         // Trigger error
         SyncManager.simulateClientReset(SyncManager.getSession(config));
     }
+
+    // Check that we can use the backup SyncConfiguration to open the Realm.
+    @Test
+    @RunTestInLooperThread
+    public void errorHandler_useBackupSyncConfigurationForClientReset() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {
+                            fail("Wrong error " + error.toString());
+                            return;
+                        }
+
+                        final ClientResetRequiredError handler = (ClientResetRequiredError) error;
+                        // Execute Client Reset
+                        looperThread.closeTestRealms();
+                        handler.executeClientReset();
+
+                        // Validate that files have been moved
+                        assertFalse(handler.getOriginalFile().exists());
+                        assertTrue(handler.getBackupFile().exists());
+
+                        RealmConfiguration backupRealmConfiguration = handler.getBackupRealmConfiguration();
+                        assertNotNull(backupRealmConfiguration);
+                        assertFalse(backupRealmConfiguration.isSyncConfiguration());
+                        assertTrue(backupRealmConfiguration.isRecoveryConfiguration());
+
+                        Realm backupRealm = Realm.getInstance(backupRealmConfiguration);
+                        assertFalse(backupRealm.isEmpty());
+                        assertEquals(1, backupRealm.where(StringOnly.class).count());
+                        assertEquals("Foo", backupRealm.where(StringOnly.class).findAll().first().getChars());
+                        backupRealm.close();
+
+                        // opening a Dynamic Realm should also work
+                        DynamicRealm dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration);
+                        dynamicRealm.getSchema().checkHasTable(StringOnly.CLASS_NAME, "Dynamic Realm should contains " + StringOnly.CLASS_NAME);
+                        RealmResults<DynamicRealmObject> all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll();
+                        assertEquals(1, all.size());
+                        assertEquals("Foo", all.first().getString(StringOnly.FIELD_CHARS));
+                        dynamicRealm.close();
+                        looperThread.testComplete();
+                    }
+                })
+                .modules(new StringOnlyModule())
+                .build();
+
+        Realm realm = Realm.getInstance(config);
+        realm.beginTransaction();
+        realm.createObject(StringOnly.class).setChars("Foo");
+        realm.commitTransaction();
+
+        looperThread.addTestRealm(realm);
+
+        // Trigger error
+        SyncManager.simulateClientReset(SyncManager.getSession(config));
+    }
+
+    // Check that we can open the backup file without using the provided SyncConfiguration,
+    // this might be the case if the user decide to act upon the client reset later (providing s/he
+    // persisted the location of the file)
+    @Test
+    @RunTestInLooperThread
+    public void errorHandler_useBackupSyncConfigurationAfterClientReset() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {
+                            fail("Wrong error " + error.toString());
+                            return;
+                        }
+
+                        final ClientResetRequiredError handler = (ClientResetRequiredError) error;
+                        // Execute Client Reset
+                        looperThread.closeTestRealms();
+                        handler.executeClientReset();
+
+                        // Validate that files have been moved
+                        assertFalse(handler.getOriginalFile().exists());
+                        assertTrue(handler.getBackupFile().exists());
+
+                        String backupFile = handler.getBackupFile().getAbsolutePath();
+
+                        // this SyncConf doesn't specify any module, it will throw a migration required
+                        // exception since the backup Realm contain only StringOnly table
+                        RealmConfiguration backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile);
+
+                        try {
+                            Realm.getInstance(backupRealmConfiguration);
+                            fail("Expected to throw a Migration required");
+                        } catch (RealmMigrationNeededException expected) {
+                        }
+
+                        // opening a DynamicRealm will work though
+                        DynamicRealm dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration);
+
+                        dynamicRealm.getSchema().checkHasTable(StringOnly.CLASS_NAME, "Dynamic Realm should contains " + StringOnly.CLASS_NAME);
+                        RealmResults<DynamicRealmObject> all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll();
+                        assertEquals(1, all.size());
+                        assertEquals("Foo", all.first().getString(StringOnly.FIELD_CHARS));
+
+                        // make sure we can't write to it (read-only Realm)
+                        try {
+                            dynamicRealm.beginTransaction();
+                            fail("Can't perform transactions on read-only Realms");
+                        } catch (IllegalStateException expected) {
+                        }
+                        dynamicRealm.close();
+
+                        try {
+                            SyncConfiguration.forRecovery(backupFile, null, StringOnly.class);
+                            fail("Expected to throw java.lang.Class is not a RealmModule");
+                        } catch (IllegalArgumentException expected) {
+                        }
+
+                        // specifying the module will allow to open the typed Realm
+                        backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, null, new StringOnlyModule());
+                        Realm backupRealm = Realm.getInstance(backupRealmConfiguration);
+                        assertFalse(backupRealm.isEmpty());
+                        assertEquals(1, backupRealm.where(StringOnly.class).count());
+                        RealmResults<StringOnly> allSorted = backupRealm.where(StringOnly.class).findAll();
+                        assertEquals("Foo", allSorted.get(0).getChars());
+                        backupRealm.close();
+
+                        looperThread.testComplete();
+                    }
+                })
+                .modules(new StringOnlyModule())
+                .build();
+
+        Realm realm = Realm.getInstance(config);
+        realm.beginTransaction();
+        realm.createObject(StringOnly.class).setChars("Foo");
+        realm.commitTransaction();
+
+        looperThread.addTestRealm(realm);
+
+        // Trigger error
+        SyncManager.simulateClientReset(SyncManager.getSession(config));
+    }
+
+    // make sure the backup file Realm is encrypted with the same key as the original synced Realm.
+    @Test
+    @RunTestInLooperThread
+    public void errorHandler_useClientResetEncrypted() {
+        SyncUser user = createTestUser();
+        String url = "realm://objectserver.realm.io/default";
+        final byte[] randomKey = TestHelper.getRandomKey();
+        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
+                .encryptionKey(randomKey)
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {
+                            fail("Wrong error " + error.toString());
+                            return;
+                        }
+
+                        final ClientResetRequiredError handler = (ClientResetRequiredError) error;
+                        // Execute Client Reset
+                        looperThread.closeTestRealms();
+                        handler.executeClientReset();
+
+                        RealmConfiguration backupRealmConfiguration = handler.getBackupRealmConfiguration();
+
+                        // can open encrypted backup Realm
+                        Realm backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration);
+                        assertEquals(1, backupEncryptedRealm.where(StringOnly.class).count());
+                        RealmResults<StringOnly> allSorted = backupEncryptedRealm.where(StringOnly.class).findAll();
+                        assertEquals("Foo", allSorted.get(0).getChars());
+                        backupEncryptedRealm.close();
+
+                        String backupFile = handler.getBackupFile().getAbsolutePath();
+                        // build a conf to open a DynamicRealm
+                        backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, randomKey, new StringOnlyModule());
+                        backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration);
+                        assertEquals(1, backupEncryptedRealm.where(StringOnly.class).count());
+                        allSorted = backupEncryptedRealm.where(StringOnly.class).findAll();
+                        assertEquals("Foo", allSorted.get(0).getChars());
+                        backupEncryptedRealm.close();
+
+                        // using wrong key throw
+                        try {
+                            Realm.getInstance(SyncConfiguration.forRecovery(backupFile, TestHelper.getRandomKey(), new StringOnlyModule()));
+                            fail("Expected to throw when using wrong encryption key");
+                        } catch (RealmFileException expected) {
+                        }
+
+                        looperThread.testComplete();
+                    }
+                })
+                .modules(new StringOnlyModule())
+                .build();
+
+        Realm realm = Realm.getInstance(config);
+        realm.beginTransaction();
+        realm.createObject(StringOnly.class).setChars("Foo");
+        realm.commitTransaction();
+
+        looperThread.addTestRealm(realm);
+
+        // Trigger error
+        SyncManager.simulateClientReset(SyncManager.getSession(config));
+    }
+
+    @Test
+    @UiThreadTest
+    public void uploadAllLocalChanges_throwsOnUiThread() throws InterruptedException {
+        Realm realm = Realm.getInstance(configuration);
+        try {
+            SyncManager.getSession(configuration).uploadAllLocalChanges();
+            fail("Should throw an IllegalStateException on Ui Thread");
+        } catch (IllegalStateException ignored) {
+        } finally {
+            realm.close();
+        }
+    }
+
+    @Test
+    @UiThreadTest
+    public void downloadAllServerChanges_throwsOnUiThread() throws InterruptedException {
+        Realm realm = Realm.getInstance(configuration);
+        try {
+            SyncManager.getSession(configuration).downloadAllServerChanges();
+            fail("Should throw an IllegalStateException on Ui Thread");
+        } catch (IllegalStateException ignored) {
+        } finally {
+            realm.close();
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
index 3b7a2a466f..922044f17d 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
@@ -16,12 +16,11 @@
 
 package io.realm;
 
-import android.content.Context;
 import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.After;
-import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -33,10 +32,8 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import io.realm.entities.AllJavaTypes;
 import io.realm.entities.StringOnly;
 import io.realm.rule.RunInLooperThread;
-import io.realm.rule.TestSyncConfigurationFactory;
 
 import static io.realm.util.SyncTestUtils.createNamedTestUser;
 import static io.realm.util.SyncTestUtils.createTestUser;
@@ -61,13 +58,6 @@
     @Rule
     public final ExpectedException thrown = ExpectedException.none();
 
-    private Context context;
-
-    @Before
-    public void setUp() {
-        context = InstrumentationRegistry.getContext();
-    }
-
     @After
     public void tearDown() throws Exception {
         SyncManager.reset();
@@ -104,7 +94,7 @@ public void serverUrl_setsFolderAndFileName() {
 
             SyncConfiguration config = new SyncConfiguration.Builder(user, serverUrl).build();
 
-            assertEquals(new File(context.getFilesDir(), expectedFolder), config.getRealmDirectory());
+            assertEquals(new File(InstrumentationRegistry.getContext().getFilesDir(), expectedFolder), config.getRealmDirectory());
             assertEquals(expectedFileName, config.getRealmFileName());
         }
     }
@@ -377,18 +367,17 @@ public void directory_dirIsAFile() throws IOException {
         file.delete(); // clean up
     }
 
-    /* FIXME: deleteRealmOnLogout is not supported by now
+    @Ignore("deleteRealmOnLogout is not supported yet")
     @Test
     public void deleteOnLogout() {
-        User user = createTestUser();
+        SyncUser user = createTestUser();
         String url = "realm://objectserver.realm.io/default";
 
         SyncConfiguration config = new SyncConfiguration.Builder(user, url)
-                .deleteRealmOnLogout()
+                //.deleteRealmOnLogout()
                 .build();
         assertTrue(config.shouldDeleteRealmOnLogout());
     }
-    */
 
     @Test
     public void initialData() {
@@ -450,88 +439,6 @@ public void compact_NotAllowed() {
         Realm.compactRealm(config);
     }
 
-    @Test
-    public void schemaVersion_throwsIfLessThanCurrentVersion() throws IOException {
-        SyncUser user = createTestUser();
-        String url = "realm://ros.realm.io/~/default";
-        @SuppressWarnings("unchecked")
-        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
-                .schema(AllJavaTypes.class, StringOnly.class)
-                .name("schemaversion_v1.realm")
-                .schemaVersion(0)
-                .build();
-
-        // Add v1 of the Realm to the filsystem
-        configFactory.copyRealmFromAssets(context, "schemaversion_v1.realm", config);
-
-        // Opening the Realm should throw an exception since the schema version is less than the one in the file.
-        Realm realm = null;
-        try {
-            realm = Realm.getInstance(config);
-            fail();
-        } catch(IllegalArgumentException ignore) {
-        } finally {
-            if (realm != null) {
-                realm.close();
-            }
-        }
-    }
-
-    @Test
-    public void schemaVersion_bumpWhenUpgradingSchema() throws IOException {
-        SyncUser user = createTestUser();
-        String url = "realm://ros.realm.io/~/default";
-        @SuppressWarnings("unchecked")
-        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
-                .schema(AllJavaTypes.class, StringOnly.class)
-                .name("schemaversion_v1.realm")
-                .schemaVersion(2)
-                .build();
-
-        // Add v1 of the Realm to the file system. v1 is missing the class `StringOnly`
-        configFactory.copyRealmFromAssets(context, "schemaversion_v1.realm", config);
-
-        // Opening the Realm should automatically upgrade the schema and version
-        Realm realm = null;
-        try {
-            realm = Realm.getInstance(config);
-            assertEquals(2, realm.getVersion());
-            assertTrue(realm.getSchema().contains(StringOnly.class.getSimpleName()));
-        } finally {
-            if (realm != null) {
-                realm.close();
-            }
-        }
-    }
-
-    @Test
-    public void schemaVersion_throwsIfNotUpdatedForSchemaUpgrade() throws IOException {
-        SyncUser user = createTestUser();
-        String url = "realm://ros.realm.io/~/default";
-        @SuppressWarnings("unchecked")
-        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
-                .schema(AllJavaTypes.class, StringOnly.class)
-                .name("schemaversion_v1.realm")
-                .schemaVersion(1)
-                .build();
-
-        // Add v1 of the Realm to the file system. v1 is missing the class `StringOnly`
-        configFactory.copyRealmFromAssets(context, "schemaversion_v1.realm", config);
-
-        // Opening the Realm should throw an exception since the schema changed, but the provided schema version is
-        // the same.
-        Realm realm = null;
-        try {
-            realm = Realm.getInstance(config);
-            fail();
-        } catch(IllegalArgumentException ignore) {
-        } finally {
-            if (realm != null) {
-                realm.close();
-            }
-        }
-    }
-
     // Check that it is possible for multiple users to reference the same Realm URL while each user still use their
     // own copy on the filesystem. This is e.g. what happens if a Realm is shared using a PermissionOffer.
     @Test
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
index 25caf4fb6a..839c935b31 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
@@ -18,6 +18,7 @@
 
 import android.support.test.runner.AndroidJUnit4;
 
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -26,7 +27,9 @@
 
 import java.io.IOException;
 import java.util.Collection;
+import java.util.Collections;
 
+import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static io.realm.util.SyncTestUtils.createTestUser;
@@ -56,21 +59,32 @@ public SyncUser getCurrent() {
             }
 
             @Override
-            public SyncUser get(String identity) {
+            public SyncUser get(String identity, String authenticationUrl) {
                 return null;
             }
 
             @Override
-            public void remove(String identity) {}
+            public void remove(String identity, String authenticationUrl) {
+            }
 
             @Override
             public Collection<SyncUser> allUsers() {
-                return null;
+                return Collections.emptySet();
             }
 
+            @Override
+            public boolean isActive(String identity, String authenticationUrl) {
+                return true;
+            }
         };
     }
 
+    @After
+    public void tearDown() {
+        UserFactory.logoutAllUsers();
+        SyncManager.reset();
+    }
+
     @Test
     public void set_userStore() {
         SyncManager.setUserStore(userStore);
@@ -139,6 +153,7 @@ public void loggedOut(SyncUser user) {
         assertEquals(0, counter[0]);
         assertEquals(0, counter[1]);
     }
+
     @Test
     public void session() throws IOException {
         SyncUser user = createTestUser();
@@ -146,8 +161,10 @@ public void session() throws IOException {
         SyncConfiguration config = new SyncConfiguration.Builder(user, url)
                 .build();
         // This will trigger the creation of the session
-        Realm.getInstance(config);
+        Realm realm = Realm.getInstance(config);
         SyncSession session = SyncManager.getSession(config);
         assertEquals(user, session.getUser()); // see also SessionTests
+
+        realm.close();
     }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
index 0f4fa8b0b9..6fb7dee8b5 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
@@ -17,31 +17,49 @@
 package io.realm;
 
 import android.support.test.InstrumentationRegistry;
+import android.support.test.rule.UiThreadTestRule;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.After;
+import org.junit.Before;
 import org.junit.BeforeClass;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 import org.mockito.Mockito;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
-import java.net.URI;
-import java.net.URISyntaxException;
+import java.io.File;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.net.MalformedURLException;
 import java.net.URL;
+import java.util.Calendar;
+import java.util.Iterator;
+import java.util.List;
 import java.util.Map;
 import java.util.UUID;
 
+import io.realm.entities.StringOnly;
 import io.realm.internal.network.AuthenticateResponse;
 import io.realm.internal.network.AuthenticationServer;
+import io.realm.internal.objectserver.Token;
 import io.realm.log.RealmLog;
+import io.realm.objectserver.utils.StringOnlyModule;
+import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
 import io.realm.util.SyncTestUtils;
 
+import static io.realm.util.SyncTestUtils.createNamedTestUser;
+import static io.realm.util.SyncTestUtils.createTestAdminUser;
 import static io.realm.util.SyncTestUtils.createTestUser;
 import static junit.framework.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
@@ -52,9 +70,29 @@
 @RunWith(AndroidJUnit4.class)
 public class SyncUserTests {
 
+    private static final URL authUrl;
+    private static final Constructor<SyncUser> SYNC_USER_CONSTRUCTOR;
+    static {
+        try {
+            authUrl = new URL("http://localhost/auth");
+            SYNC_USER_CONSTRUCTOR = SyncUser.class.getDeclaredConstructor(Token.class, URL.class);
+            SYNC_USER_CONSTRUCTOR.setAccessible(true);
+        } catch (MalformedURLException e) {
+            throw new ExceptionInInitializerError(e);
+        } catch (NoSuchMethodException e) {
+            throw new ExceptionInInitializerError(e);
+        }
+    }
+
     @Rule
     public final RunInLooperThread looperThread = new RunInLooperThread();
 
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    @Rule
+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();
+
     @BeforeClass
     public static void initUserStore() {
         Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
@@ -62,11 +100,64 @@ public static void initUserStore() {
         SyncManager.setUserStore(userStore);
     }
 
-    @After
-    public void tearDown() {
+    @Before
+    public void setUp() {
         SyncManager.reset();
     }
 
+    @After
+    public void after() {
+        if (!looperThread.isRuleUsed() || looperThread.isTestComplete()) {
+            UserFactory.logoutAllUsers();
+        } else {
+            looperThread.runAfterTest(new Runnable() {
+                @Override
+                public void run() {
+                    UserFactory.logoutAllUsers();
+                }
+            });
+        }
+    }
+
+    private static SyncUser createFakeUser(String id) {
+        final Token token = new Token("token_value", id, "path_value", Long.MAX_VALUE, null);
+        try {
+            return SYNC_USER_CONSTRUCTOR.newInstance(token, authUrl);
+        } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {
+            fail(e.getMessage());
+        }
+        return null;
+    }
+
+    @Test
+    public void equals_validUser() {
+        final SyncUser user1 = createFakeUser("id_value");
+        final SyncUser user2 = createFakeUser("id_value");
+        assertTrue(user1.equals(user2));
+    }
+
+    @Test
+    public void equals_loggedOutUser() {
+        final SyncUser user1 = createFakeUser("id_value");
+        final SyncUser user2 = createFakeUser("id_value");
+        user1.logout();
+        user2.logout();
+        assertTrue(user1.equals(user2));
+    }
+
+    @Test
+    public void hashCode_validUser() {
+        final SyncUser user = createFakeUser("id_value");
+        assertNotEquals(0, user.hashCode());
+    }
+
+    @Test
+    public void hashCode_loggedOutUser() {
+        final SyncUser user = createFakeUser("id_value");
+        user.logout();
+        assertNotEquals(0, user.hashCode());
+    }
+
     @Test
     public void toAndFromJson() {
         SyncUser user1 = createTestUser();
@@ -117,7 +208,7 @@ public AuthenticateResponse answer(InvocationOnMock invocationOnMock) throws Thr
     private AuthenticateResponse getNewRandomUser() {
         String identity = UUID.randomUUID().toString();
         String userTokenValue = UUID.randomUUID().toString();
-        return SyncTestUtils.createLoginResponse(userTokenValue, identity, Long.MAX_VALUE);
+        return SyncTestUtils.createLoginResponse(userTokenValue, identity, Long.MAX_VALUE, false);
     }
 
     // Test that current user is cleared if it is logged out
@@ -155,41 +246,36 @@ public void all_validUsers() {
         assertTrue(users.entrySet().iterator().next().getValue().isValid());
     }
 
-    // Tests that the user store returns the last user to login
-    /* FIXME: This test fails because of wrong JSON string.
     @Test
-    public void currentUser_returnsUserAfterLogin() {
-        AuthenticationServer authServer = Mockito.mock(AuthenticationServer.class);
-        when(authServer.loginUser(any(Credentials.class), any(URL.class))).thenReturn(SyncTestUtils.createLoginResponse(Long.MAX_VALUE));
+    public void isAdmin() {
+        SyncUser user1 = createTestUser();
+        assertFalse(user1.isAdmin());
 
-        User user = User.login(Credentials.facebook("foo"), "http://bar.com/auth");
-        assertEquals(user, User.currentUser());
+        SyncUser user2 = createTestAdminUser();
+        assertTrue(user2.isAdmin());
     }
-    */
 
     @Test
-    public void getManagementRealm() {
-        SyncUser user = SyncTestUtils.createTestUser();
-        Realm managementRealm = user.getManagementRealm();
-        assertNotNull(managementRealm);
-        managementRealm.close();
+    public void isAdmin_allUsers() {
+        UserStore userStore = SyncManager.getUserStore();
+        SyncUser user = SyncTestUtils.createTestAdminUser();
+        assertTrue(user.isAdmin());
+        userStore.put(user);
+
+        Map <String, SyncUser> users = SyncUser.all();
+        assertEquals(1, users.size());
+        assertTrue(users.entrySet().iterator().next().getValue().isAdmin());
     }
 
+    // Tests that the user store returns the last user to login
+    @Ignore("This test fails because of wrong JSON string.")
     @Test
-    public void getManagementRealm_enforceTLS() throws URISyntaxException {
-        // Non TLS
-        SyncUser user = SyncTestUtils.createTestUser("http://objectserver.realm.io/auth");
-        Realm managementRealm = user.getManagementRealm();
-        SyncConfiguration config = (SyncConfiguration) managementRealm.getConfiguration();
-        assertEquals(new URI("realm://objectserver.realm.io/" + user.getIdentity() + "/__management"), config.getServerUrl());
-        managementRealm.close();
+    public void currentUser_returnsUserAfterLogin() {
+        AuthenticationServer authServer = Mockito.mock(AuthenticationServer.class);
+        when(authServer.loginUser(any(SyncCredentials.class), any(URL.class))).thenReturn(SyncTestUtils.createLoginResponse(Long.MAX_VALUE));
 
-        // TLS
-        user = SyncTestUtils.createTestUser("https://objectserver.realm.io/auth");
-        managementRealm = user.getManagementRealm();
-        config = (SyncConfiguration) managementRealm.getConfiguration();
-        assertEquals(new URI("realms://objectserver.realm.io/" + user.getIdentity() + "/__management"), config.getServerUrl());
-        managementRealm.close();
+        SyncUser user = SyncUser.login(SyncCredentials.facebook("foo"), "http://bar.com/auth");
+        assertEquals(user, SyncUser.currentUser());
     }
 
     @Test
@@ -245,4 +331,239 @@ public void login_appendAuthSegment() {
             SyncManager.setAuthServerImpl(originalServer);
         }
     }
+
+    @Test
+    public void changePassword_nullThrows() {
+        SyncUser user = createTestUser();
+
+        thrown.expect(IllegalArgumentException.class);
+        //noinspection ConstantConditions
+        user.changePassword(null);
+    }
+
+    @Test
+    public void changePassword_admin_nullThrows() {
+        SyncUser user = createTestUser();
+
+        thrown.expect(IllegalArgumentException.class);
+        //noinspection ConstantConditions
+        user.changePassword(null, "new-password");
+    }
+
+    @Test
+    public void changePasswordAsync_nonLooperThreadThrows() {
+        SyncUser user = createTestUser();
+
+        thrown.expect(IllegalStateException.class);
+        user.changePasswordAsync("password", new SyncUser.Callback<SyncUser>() {
+            @Override
+            public void onSuccess(SyncUser user) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail();
+            }
+        });
+    }
+
+    @Test
+    public void changePassword_admin_Async_nonLooperThreadThrows() {
+        SyncUser user = createTestUser();
+
+        thrown.expect(IllegalStateException.class);
+        user.changePasswordAsync("user-id", "new", new SyncUser.Callback<SyncUser>() {
+            @Override
+            public void onSuccess(SyncUser user) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changePasswordAsync_nullCallbackThrows() {
+        SyncUser user = createTestUser();
+
+        thrown.expect(IllegalArgumentException.class);
+        //noinspection ConstantConditions
+        user.changePasswordAsync("new-password", null);
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changePassword_admin_Async_nullCallbackThrows() {
+        SyncUser user = createTestUser();
+
+        thrown.expect(IllegalArgumentException.class);
+        //noinspection ConstantConditions
+        user.changePasswordAsync("user-id", "new-password", null);
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changePassword_noneAdminThrows() {
+        SyncUser user = createTestUser();
+
+        thrown.expect(IllegalStateException.class);
+        user.changePassword("user-id", "new-password");
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getPermissionManager_isReferenceCounted() {
+        SyncUser user = createTestUser();
+        PermissionManager pm1 = user.getPermissionManager();
+        PermissionManager pm2 = user.getPermissionManager();
+        assertTrue(pm1 == pm2);
+        assertFalse(pm1.isClosed());
+        pm1.close();
+        assertFalse(pm1.isClosed());
+        pm1.close();
+        assertTrue(pm1.isClosed());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getPermissionManger_instanceUniqueToUser() {
+        SyncUser user1 = createNamedTestUser("user1");
+        SyncUser user2 = createNamedTestUser("user2");
+        PermissionManager pm1 = user1.getPermissionManager();
+        PermissionManager pm2 = user2.getPermissionManager();
+
+        try {
+            assertFalse(pm1 == pm2);
+            assertFalse(pm1.equals(pm2));
+            looperThread.testComplete();
+        } finally {
+            pm1.close();
+            pm2.close();
+            user1.logout();
+            user2.logout();
+        }
+    }
+
+    @Test
+    public void getPermissionManager_throwOnNonLooperThread() {
+        SyncUser user = createTestUser();
+        try {
+            user.getPermissionManager();
+            fail();
+        } catch (IllegalStateException e) {
+        }
+    }
+
+    @Test
+    public void allSessions() {
+        String url1 = "realm://objectserver.realm.io/default";
+        String url2 = "realm://objectserver.realm.io/~/default";
+
+        SyncUser user = createTestUser();
+        assertEquals(0, user.allSessions().size());
+
+        SyncConfiguration configuration1 = new SyncConfiguration.Builder(user, url1).build();
+        Realm realm1 = Realm.getInstance(configuration1);
+        List<SyncSession> allSessions = user.allSessions();
+        assertEquals(1, allSessions.size());
+        Iterator<SyncSession> iter = allSessions.iterator();
+        SyncSession session = iter.next();
+        assertEquals(user, session.getUser());
+        assertEquals(url1, session.getServerUrl().toString());
+
+        SyncConfiguration configuration2 = new SyncConfiguration.Builder(user, url2).build();
+        Realm realm2 = Realm.getInstance(configuration2);
+        allSessions = user.allSessions();
+        assertEquals(2, allSessions.size());
+        iter = allSessions.iterator();
+        String individualUrl = url2.replace("~", user.getIdentity());
+        int foundCount = 0;
+        while (iter.hasNext()) {
+            session = iter.next();
+            assertEquals(user, session.getUser());
+            if (individualUrl.equals(session.getServerUrl().toString())) {
+                foundCount++;
+            }
+        }
+        assertEquals(1, foundCount);
+        realm1.close();
+
+        allSessions = user.allSessions();
+        assertEquals(1, allSessions.size());
+        iter = allSessions.iterator();
+        session = iter.next();
+        assertEquals(user, session.getUser());
+        assertEquals(individualUrl, session.getServerUrl().toString());
+
+        realm2.close();
+        assertEquals(0, user.allSessions().size());
+    }
+
+    // JSON format changed in 3.6.0 (removed unnecessary fields), this regression test
+    // makes sure we can still deserialize a valid SyncUser from the old format.
+    @Test
+    public void fromJson_WorkWithRemovedObjectServerUser() {
+        String oldSyncUserJSON = "{\"authUrl\":\"http:\\/\\/192.168.1.151:9080\\/auth\",\"userToken\":{\"token\":\"eyJpZGVudGl0eSI6IjY4OWQ5MGMxNDIyYTIwMmZkNTljNDYwM2M0ZTRmNmNjIiwiZXhwaXJlcyI6MTgxNjM1ODE4NCwiYXBwX2lkIjoiaW8ucmVhbG0ucmVhbG10YXNrcyIsImFjY2VzcyI6WyJyZWZyZXNoIl0sImlzX2FkbWluIjpmYWxzZSwic2FsdCI6MC4yMTEwMjQyNDgwOTEyMzg1NH0=:lEDa83o1zu8rkwdZVpTyunLHh1wmjxPPSGmZQNxdEM7xDmpbiU7V+8dgDWGevJNHMFluNDAOmrcAOI9TLfhI4rMDl70NI1K9rv\\/Aeq5uIOzq\\/Gf7JTeTUKY5Z7yRoppd8NArlNBKesLFxzdLRlfm1hflF9wH23xQXA19yUZ67JIlkhDPL5e3bau8O3Pr\\/St0unW3KzPOiZUk1l9KRrs2iMCCiXCfq4rf6rp7B2M7rBUMQm68GnB1Ot7l1CblxEWcREcbpyhBKTWIOFRGMwg2TW\\/zRR3cRNglx+ZC4FOeO0mfkX+nf+slyFODAnQkOzPZcGO8xc3I1emafX58Wl\\/Guw==\",\"token_data\":{\"identity\":\"689d90c1422a202fd59c4603c4e4f6cc\",\"path\":\"\",\"expires\":1816358184,\"access\":[\"unknown\"],\"is_admin\":false}},\"realms\":[]}";
+        SyncUser syncUser = SyncUser.fromJson(oldSyncUserJSON);
+
+        // Note: we can't call isValid() and expect it to be true
+        //       since the user is not persisted in the UserStore
+        //       isValid() requires SyncManager.getUserStore().isActive(identity)
+        //       to return true as well.
+        Token refreshToken = syncUser.getRefreshToken();
+        assertNotNull(refreshToken);
+        // refresh token should expire in 10 years (July 23, 2027)
+        Calendar calendar = Calendar.getInstance();
+        calendar.setTimeInMillis(refreshToken.expiresMs());
+        int day = calendar.get(Calendar.DAY_OF_MONTH);
+        int month = calendar.get(Calendar.MONTH);
+        int year = calendar.get(Calendar.YEAR);
+
+        assertEquals(23, day);
+        assertEquals(Calendar.JULY, month);
+        assertEquals(2027, year);
+
+        assertEquals("http://192.168.1.151:9080/auth", syncUser.getAuthenticationUrl().toString());
+    }
+
+    @Test
+    @Ignore("until https://github.com/realm/realm-java/issues/5097 is fixed")
+    public void logoutUserShouldDeleteRealmAfterRestart() throws InterruptedException {
+        SyncManager.reset();
+        BaseRealm.applicationContext = null; // Required for Realm.init() to work
+        Realm.init(InstrumentationRegistry.getTargetContext());
+
+        SyncUser user = createTestUser();
+        SyncConfiguration syncConfiguration = new SyncConfiguration
+                .Builder(user, "realm://127.0.0.1:9080/~/tests")
+                .modules(new StringOnlyModule())
+                .build();
+
+        Realm realm = Realm.getInstance(syncConfiguration);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(StringOnly.class).setChars("1");
+            }
+        });
+        user.logout();
+        realm.close();
+
+        final File realmPath = new File (syncConfiguration.getPath());
+        assertTrue(realmPath.exists());
+
+        // simulate an app restart
+        SyncManager.reset();
+        BaseRealm.applicationContext = null;
+        Realm.init(InstrumentationRegistry.getTargetContext());
+
+        //now the file should be deleted
+        assertFalse(realmPath.exists());
+    }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
index 28f2e3984b..b12d014bea 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
@@ -16,23 +16,37 @@
 
 package io.realm;
 
-import android.content.Context;
 import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 
-import org.junit.After;
-import org.junit.Before;
+import org.hamcrest.CoreMatchers;
+import org.junit.BeforeClass;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
+import java.io.File;
 import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
 
-import io.realm.rule.TestRealmConfigurationFactory;
-import io.realm.rule.TestSyncConfigurationFactory;
+import io.realm.entities.IndexedFields;
+import io.realm.entities.PrimaryKeyAsString;
+import io.realm.entities.StringOnly;
+import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.OsRealmConfig;
+import io.realm.internal.OsSchemaInfo;
+import io.realm.internal.SharedRealm;
+import io.realm.exceptions.IncompatibleSyncedFileException;
+import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.util.SyncTestUtils;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
@@ -43,6 +57,16 @@
 
     @Rule
     public final TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    @BeforeClass
+    public static void beforeClass () {
+        // another Test class may have the BaseRealm.applicationContext set but
+        // the SyncManager reset. This will make assertion to fail, we need to re-initialise
+        // the sync_manager.cpp#m_file_manager (configFactory rule do this)
+        BaseRealm.applicationContext = null;
+    }
 
     @Test
     public void migrateRealm_syncConfigurationThrows() {
@@ -56,4 +80,283 @@ public void migrateRealm_syncConfigurationThrows() {
         }
     }
 
+    // Check that the Realm can still be opened even if the ondisk schema are missing fields. These will be added
+    // automatically.
+    @Test
+    public void addField_worksWithMigrationError() {
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/auth")
+                .schema(StringOnly.class)
+                .build();
+
+        // Setup initial Realm schema (with missing fields)
+        String className = StringOnly.class.getSimpleName();
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);
+        RealmSchema schema = dynamicRealm.getSchema();
+        dynamicRealm.beginTransaction();
+        schema.create(className); // Create empty class
+        dynamicRealm.commitTransaction();
+        dynamicRealm.close();
+
+        // Open typed Realm, which will validate the schema
+        Realm realm = Realm.getInstance(config);
+        RealmObjectSchema stringOnlySchema = realm.getSchema().get(className);
+        try {
+            assertTrue(stringOnlySchema.hasField(StringOnly.FIELD_CHARS)); // Field has been added
+        } finally {
+            realm.close();
+        }
+    }
+
+    // Check that the Realm can still be opened even if the ondisk schema has more fields than in the model class.
+    // The underlying field should not be deleted, just hidden.
+    @Test
+    public void missingFields_hiddenSilently() {
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/auth")
+                .schema(StringOnly.class)
+                .build();
+
+        // Setup initial Realm schema (with too many fields)
+        String className = StringOnly.class.getSimpleName();
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);
+        RealmSchema schema = dynamicRealm.getSchema();
+        dynamicRealm.beginTransaction();
+        schema.create(className)
+                .addField(StringOnly.FIELD_CHARS, String.class)
+                .addField("newField", String.class);
+        // A schema version has to be set otherwise Object Store will try to initialize the schema again and reach an
+        // error branch. That is not a real case.
+        dynamicRealm.setVersion(0);
+        dynamicRealm.commitTransaction();
+        dynamicRealm.close();
+
+        // Open typed Realm, which will validate the schema
+        Realm realm = Realm.getInstance(config);
+        RealmObjectSchema stringOnlySchema = realm.getSchema().get(className);
+        try {
+            assertTrue(stringOnlySchema.hasField(StringOnly.FIELD_CHARS));
+            assertTrue(stringOnlySchema.hasField("newField"));
+            assertEquals(2, stringOnlySchema.getFieldNames().size());
+        } finally {
+            realm.close();
+        }
+    }
+
+    // Check that a Realm cannot be opened if it contain breaking schema changes, like changing a primary key
+    @Test
+    public void breakingSchemaChange_throws() {
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/auth")
+                .schema(PrimaryKeyAsString.class)
+                .build();
+
+        // Setup initial Realm schema (with a different primary key)
+        OsObjectSchemaInfo expectedObjectSchema = new OsObjectSchemaInfo.Builder(PrimaryKeyAsString.CLASS_NAME, 2, 0)
+                .addPersistedProperty(PrimaryKeyAsString.FIELD_PRIMARY_KEY, RealmFieldType.STRING, false, true, false)
+                .addPersistedProperty(PrimaryKeyAsString.FIELD_ID, RealmFieldType.INTEGER, true, true, true)
+                .build();
+        List<OsObjectSchemaInfo> list = new ArrayList<OsObjectSchemaInfo>();
+        list.add(expectedObjectSchema);
+        OsSchemaInfo schemaInfo = new OsSchemaInfo(list);
+        OsRealmConfig.Builder configBuilder = new OsRealmConfig.Builder(config).schemaInfo(schemaInfo);
+        SharedRealm.getInstance(configBuilder).close();
+
+        thrown.expectMessage(
+                CoreMatchers.containsString("The following changes cannot be made in additive-only schema mode:"));
+        thrown.expect(IllegalStateException.class);
+        Realm.getInstance(config);
+    }
+
+    // Check that indexes are not being added if the schema version is the same
+    @Test
+    public void sameSchemaVersion_doNotRebuildIndexes() {
+
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/auth")
+                .schema(IndexedFields.class)
+                .schemaVersion(42)
+                .build();
+
+        // Setup initial Realm schema (with no indexes)
+        String className = IndexedFields.class.getSimpleName();
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);
+        RealmSchema schema = dynamicRealm.getSchema();
+        dynamicRealm.beginTransaction();
+        schema.create(className)
+                .addField(IndexedFields.FIELD_INDEXED_STRING, String.class) // No index
+                .addField(IndexedFields.FIELD_NON_INDEXED_STRING, String.class);
+        dynamicRealm.setVersion(42);
+        dynamicRealm.commitTransaction();
+        dynamicRealm.close();
+
+        Realm realm = Realm.getInstance(config); // Opening at same schema version (42) will not rebuild indexes
+
+        RealmObjectSchema indexedFieldsSchema = realm.getSchema().get(className);
+        try {
+            assertFalse(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_INDEXED_STRING));
+            assertFalse(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_NON_INDEXED_STRING));
+        } finally {
+            realm.close();
+        }
+    }
+
+    // Check that indexes are being added if the schema version is different
+    @Test
+    public void differentSchemaVersions_rebuildIndexes() {
+
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/auth")
+                .schema(IndexedFields.class)
+                .schemaVersion(42)
+                .build();
+
+        // Setup initial Realm schema (with no indexes)
+        String className = IndexedFields.class.getSimpleName();
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);
+        RealmSchema schema = dynamicRealm.getSchema();
+        dynamicRealm.beginTransaction();
+        schema.create(className)
+                .addField(IndexedFields.FIELD_INDEXED_STRING, String.class) // No index
+                .addField(IndexedFields.FIELD_NON_INDEXED_STRING, String.class);
+        dynamicRealm.setVersion(43);
+        dynamicRealm.commitTransaction();
+        dynamicRealm.close();
+
+        Realm realm = Realm.getInstance(config); // Opening at different schema version (42) should rebuild indexes
+        try {
+            RealmObjectSchema indexedFieldsSchema = realm.getSchema().get(className);
+            assertNotNull(indexedFieldsSchema);
+            assertTrue(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_INDEXED_STRING));
+            assertFalse(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_NON_INDEXED_STRING));
+        } finally {
+            realm.close();
+        }
+    }
+
+    // Check that indexes are being added if other fields are being added as well
+    @Test
+    public void addingFields_rebuildIndexes() {
+
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/auth")
+                .schema(IndexedFields.class)
+                .schemaVersion(42)
+                .build();
+
+        // Setup initial Realm schema (with no indexes)
+        String className = IndexedFields.class.getSimpleName();
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);
+        RealmSchema schema = dynamicRealm.getSchema();
+        dynamicRealm.beginTransaction();
+        schema.create(className)
+                .addField(IndexedFields.FIELD_INDEXED_STRING, String.class); // No index
+                // .addField(IndexedFields.FIELD_NON_INDEXED_STRING, String.class); // Missing field
+        dynamicRealm.setVersion(41);
+        dynamicRealm.commitTransaction();
+        dynamicRealm.close();
+
+        // Opening at different schema version (42) should add field and rebuild indexes
+        Realm realm = Realm.getInstance(config);
+        try {
+            assertTrue(realm.getSchema().get(className).hasField(IndexedFields.FIELD_NON_INDEXED_STRING));
+            assertTrue(realm.getSchema().get(className).hasIndex(IndexedFields.FIELD_INDEXED_STRING));
+        } finally {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void schemaVersionUpgradedWhenMigrating() {
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/auth")
+                .schemaVersion(42)
+                .build();
+
+        // Setup initial Realm schema (with missing fields)
+        String className = StringOnly.class.getSimpleName();
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);
+        RealmSchema schema = dynamicRealm.getSchema();
+        dynamicRealm.beginTransaction();
+        schema.create(className); // Create empty class
+        dynamicRealm.setVersion(1);
+        dynamicRealm.commitTransaction();
+        dynamicRealm.close();
+
+        // Open typed Realm, which will validate the schema
+        Realm realm = Realm.getInstance(config);
+        try {
+            assertEquals(42, realm.getVersion());
+        } finally {
+            realm.close();
+        }
+    }
+
+    // The remote Realm containing more field than the local typed Realm defined is allowed.
+    @Test
+    public void moreFieldsThanExpectedIsAllowed() {
+        SyncConfiguration config = configFactory
+                .createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/auth")
+                .schema(StringOnly.class)
+                .build();
+
+        // Initialize schema
+        Realm.getInstance(config).close();
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);
+        dynamicRealm.beginTransaction();
+        RealmObjectSchema objectSchema = dynamicRealm.getSchema().get(StringOnly.CLASS_NAME);
+        // Add one extra field which doesn't exist in the typed Realm.
+        objectSchema.addField("oneMoreField", int.class);
+        dynamicRealm.commitTransaction();
+        // Clear column indices cache.
+        dynamicRealm.close();
+
+        // Verify schema again.
+        Realm realm = Realm.getInstance(config);
+        realm.close();
+    }
+
+    @Test
+    public void offlineClientReset() throws IOException {
+        SyncConfiguration config = configFactory
+                .createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/auth")
+                .modules(new StringOnlyModule())
+                .build();
+
+        String path = config.getPath();
+        File realmFile = new File (path);
+        assertFalse(realmFile.exists());
+        // copy the 1.x Realm
+        configFactory.copyRealmFromAssets(InstrumentationRegistry.getContext(), "sync-1.x.realm", config);
+        assertTrue(realmFile.exists());
+
+        // open the file using the new ROS 2.x server
+        try {
+            Realm.getInstance(config);
+            fail("should throw IncompatibleSyncedFileException");
+        } catch (IncompatibleSyncedFileException expected) {
+            String recoveryPath = expected.getRecoveryPath();
+            assertTrue(new File(recoveryPath).exists());
+            // can open the backup Realm
+            RealmConfiguration backupRealmConfiguration = expected.getBackupRealmConfiguration(null, new StringOnlyModule());
+            Realm backupRealm = Realm.getInstance(backupRealmConfiguration);
+            assertFalse(backupRealm.isEmpty());
+            RealmResults<StringOnly> all = backupRealm.where(StringOnly.class).findAll();
+            assertEquals(1, all.size());
+            assertEquals("Hello from ROS 1.X", all.get(0).getChars());
+
+            // make sure it's read only
+            try {
+                backupRealm.beginTransaction();
+                fail("Backup Realm should be read-only, we should throw");
+            } catch (IllegalStateException ignored) {
+            }
+            backupRealm.close();
+
+            // we can open in dynamic mode
+            DynamicRealm dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration);
+            dynamicRealm.getSchema().checkHasTable(StringOnly.CLASS_NAME, "Dynamic Realm should contains " + StringOnly.CLASS_NAME);
+            RealmResults<DynamicRealmObject> allDynamic = dynamicRealm.where(StringOnly.CLASS_NAME).findAll();
+            assertEquals(1, allDynamic.size());
+            assertEquals("Hello from ROS 1.X", allDynamic.first().getString(StringOnly.FIELD_CHARS));
+            dynamicRealm.close();
+        }
+
+        Realm realm = Realm.getInstance(config);
+        assertTrue(realm.isEmpty());
+        realm.close();
+    }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/rule/TestSyncConfigurationFactory.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/TestSyncConfigurationFactory.java
similarity index 75%
rename from realm/realm-library/src/androidTestObjectServer/java/io/realm/rule/TestSyncConfigurationFactory.java
rename to realm/realm-library/src/androidTestObjectServer/java/io/realm/TestSyncConfigurationFactory.java
index 23b8f908a5..9e7573c865 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/rule/TestSyncConfigurationFactory.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/TestSyncConfigurationFactory.java
@@ -14,10 +14,10 @@
  * limitations under the License.
  */
 
-package io.realm.rule;
+package io.realm;
 
-import io.realm.SyncConfiguration;
-import io.realm.SyncUser;
+import io.realm.internal.OsRealmConfig;
+import io.realm.rule.TestRealmConfigurationFactory;
 
 /**
  * Test rule used for creating SyncConfigurations. Will ensure that any Realm files are deleted when the
@@ -26,6 +26,8 @@
 public class TestSyncConfigurationFactory extends TestRealmConfigurationFactory {
 
     public SyncConfiguration.Builder createSyncConfigurationBuilder(SyncUser user, String url) {
-        return new SyncConfiguration.Builder(user, url).directory(getRoot());
+        return new SyncConfiguration.Builder(user, url)
+                .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
+                .directory(getRoot());
     }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/UserConditionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/UserConditionTests.java
new file mode 100644
index 0000000000..173e3dccce
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/UserConditionTests.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.realm.permissions.UserCondition;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+
+@RunWith(AndroidJUnit4.class)
+public class UserConditionTests {
+
+    @Test
+    public void username_nullOrEmptyThrows() {
+        String[] illegalValues = { null, ""};
+        for (String value : illegalValues) {
+            try {
+                UserCondition.username(value);
+                fail();
+            } catch (IllegalArgumentException ignore) {
+            }
+        }
+    }
+
+    @Test
+    public void userId_nullOrEmptyThrows() {
+        String[] illegalValues = { null, ""};
+        for (String value : illegalValues) {
+            try {
+                UserCondition.userId(value);
+                fail();
+            } catch (IllegalArgumentException ignore) {
+            }
+        }
+    }
+
+    @Test
+    public void keyValue_nullOrEmptyThrows() {
+        // Keys
+        String[] illegalKeys = { null, ""};
+        for (String key : illegalKeys) {
+            try {
+                UserCondition.keyValue(key, "value");
+                fail();
+            } catch (IllegalArgumentException ignore) {
+            }
+        }
+
+        // Values
+        try {
+            UserCondition.keyValue("key", null);
+            fail();
+        } catch (IllegalArgumentException ignore) {
+        }
+    }
+
+    @Test
+    public void username() {
+        UserCondition condition = UserCondition.username("a@b.c");
+        assertEquals("a@b.c", condition.getValue());
+        assertEquals("email", condition.getKey());
+        assertEquals(UserCondition.MatcherType.METADATA, condition.getType());
+    }
+
+    @Test
+    public void userId() {
+        UserCondition condition = UserCondition.userId("foo");
+        assertEquals("foo", condition.getValue());
+        assertEquals("", condition.getKey());
+        assertEquals(UserCondition.MatcherType.USER_ID, condition.getType());
+    }
+
+    @Test
+    public void keyValue() {
+        UserCondition condition = UserCondition.keyValue("key", "value");
+        assertEquals("value", condition.getValue());
+        assertEquals("key", condition.getKey());
+        assertEquals(UserCondition.MatcherType.METADATA, condition.getType());
+    }
+
+    @Test
+    public void nonExistingPermissions() {
+        UserCondition condition = UserCondition.noExistingPermissions();
+        assertEquals("*", condition.getValue());
+        assertEquals("", condition.getKey());
+        assertEquals(UserCondition.MatcherType.USER_ID, condition.getType());
+    }
+
+    @Test
+    public void equals() {
+        UserCondition c1 = UserCondition.username("a@b.c");
+        UserCondition c2 = UserCondition.username("a@b.c");
+
+        assertTrue(c1.equals(c2));
+        assertTrue(c2.equals(c1));
+        assertEquals(c1.hashCode(), c2.hashCode());
+    }
+
+    @Test
+    public void notEquals() {
+        UserCondition c1 = UserCondition.username("a@b.c");
+        UserCondition c2 = UserCondition.username("a@b.d");
+
+        assertFalse(c1.equals(c2));
+        assertFalse(c2.equals(c1));
+        assertNotEquals(c1.hashCode(), c2.hashCode());
+    }
+}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/internal/objectserver/ObjectServerUserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/internal/objectserver/ObjectServerUserTests.java
deleted file mode 100644
index aa68bf09f7..0000000000
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/internal/objectserver/ObjectServerUserTests.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm.internal.objectserver;
-
-import android.support.test.runner.AndroidJUnit4;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.net.MalformedURLException;
-import java.net.URL;
-
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertTrue;
-
-@RunWith(AndroidJUnit4.class)
-public class ObjectServerUserTests {
-
-    private static final URL authUrl;
-
-    static {
-        try {
-            authUrl = new URL("http://localhost/auth");
-        } catch (MalformedURLException e) {
-            throw new ExceptionInInitializerError(e);
-        }
-    }
-
-    private static ObjectServerUser createFakeUser(String id) {
-        final Token token = new Token("token_value", id, "path_value", Long.MAX_VALUE, null);
-        return new ObjectServerUser(token, authUrl);
-    }
-
-    @Test
-    public void equals_validUser() {
-        final ObjectServerUser user1 = createFakeUser("id_value");
-        final ObjectServerUser user2 = createFakeUser("id_value");
-        assertTrue(user1.equals(user2));
-    }
-
-    @Test
-    public void equals_loggedOutUser() {
-        final ObjectServerUser user1 = createFakeUser("id_value");
-        final ObjectServerUser user2 = createFakeUser("id_value");
-        user1.clearTokens();
-        user2.clearTokens();
-        assertTrue(user1.equals(user2));
-    }
-
-    @Test
-    public void hashCode_validUser() {
-        final ObjectServerUser user = createFakeUser("id_value");
-        assertNotEquals(0, user.hashCode());
-    }
-
-    @Test
-    public void hashCode_loggedOutUser() {
-        final ObjectServerUser user = createFakeUser("id_value");
-        user.clearTokens();
-        assertNotEquals(0, user.hashCode());
-    }
-}
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
index de368019a5..97caaa18bd 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/util/SyncTestUtils.java
@@ -16,80 +16,87 @@
 
 package io.realm.util;
 
-import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
 
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.util.UUID;
 
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
-import io.realm.SyncSession;
+import io.realm.SyncManager;
 import io.realm.SyncUser;
+import io.realm.UserStore;
 import io.realm.internal.network.AuthenticateResponse;
-import io.realm.internal.objectserver.ObjectServerUser;
 import io.realm.internal.objectserver.Token;
 
 public class SyncTestUtils {
 
     public static final String USER_TOKEN = UUID.randomUUID().toString();
-    public static final String REALM_TOKEN = UUID.randomUUID().toString();
     public static final String DEFAULT_AUTH_URL = "http://objectserver.realm.io/auth";
-    public static final String DEFAULT_USER_IDENTIFIER = "JohnDoe";
-
-    public static SyncUser createRandomTestUser() {
-        return createTestUser(UUID.randomUUID().toString(),
-                UUID.randomUUID().toString(),
-                UUID.randomUUID().toString(),
-                DEFAULT_AUTH_URL,
-                Long.MAX_VALUE);
+
+    private final static Method SYNC_MANAGER_GET_USER_STORE_METHOD;
+    private final static Method SYNC_USER_GET_ACCESS_TOKEN_METHOD;
+    static {
+        try {
+            SYNC_MANAGER_GET_USER_STORE_METHOD = SyncManager.class.getDeclaredMethod("getUserStore");
+            SYNC_USER_GET_ACCESS_TOKEN_METHOD = SyncUser.class.getDeclaredMethod("getRefreshToken");
+            SYNC_MANAGER_GET_USER_STORE_METHOD.setAccessible(true);
+            SYNC_USER_GET_ACCESS_TOKEN_METHOD.setAccessible(true);
+        } catch (NoSuchMethodException e) {
+            throw new AssertionError(e);
+        }
+    }
+
+    public static SyncUser createTestAdminUser() {
+        return createTestUser(USER_TOKEN, UUID.randomUUID().toString(), DEFAULT_AUTH_URL, Long.MAX_VALUE, true);
     }
 
     public static SyncUser createTestUser() {
-        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_USER_IDENTIFIER, DEFAULT_AUTH_URL, Long.MAX_VALUE);
+        return createTestUser(USER_TOKEN, UUID.randomUUID().toString(), DEFAULT_AUTH_URL, Long.MAX_VALUE, false);
     }
 
     public static SyncUser createTestUser(long expires) {
-        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_USER_IDENTIFIER,  DEFAULT_AUTH_URL, expires);
+        return createTestUser(USER_TOKEN, UUID.randomUUID().toString(), DEFAULT_AUTH_URL, expires, false);
     }
 
     public static SyncUser createTestUser(String authUrl) {
-        return createTestUser(USER_TOKEN, REALM_TOKEN, DEFAULT_USER_IDENTIFIER,  authUrl, Long.MAX_VALUE);
+        return createTestUser(USER_TOKEN, UUID.randomUUID().toString(), authUrl, Long.MAX_VALUE, false);
     }
 
     public static SyncUser createNamedTestUser(String userIdentifier) {
-        return createTestUser(USER_TOKEN, REALM_TOKEN, userIdentifier, DEFAULT_AUTH_URL, Long.MAX_VALUE);
+        return createTestUser(USER_TOKEN, userIdentifier, DEFAULT_AUTH_URL, Long.MAX_VALUE, false);
     }
 
-    public static SyncUser createTestUser(String userTokenValue, String realmTokenValue, String userIdentifier, String authUrl, long expires) {
-        Token userToken = new Token(userTokenValue, userIdentifier, null, expires, null);
-        Token accessToken = new Token(realmTokenValue, userIdentifier, "/foo", expires, new Token.Permission[] {Token.Permission.DOWNLOAD });
-        ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(accessToken, "/data/data/myapp/files/default", false);
+    public static SyncUser createTestUser(String userTokenValue, String userIdentifier, String authUrl, long expires, boolean isAdmin) {
+        Token userToken = new Token(userTokenValue, userIdentifier, null, expires, null, isAdmin);
 
         JSONObject obj = new JSONObject();
         try {
-            JSONArray realmList = new JSONArray();
             JSONObject realmDesc = new JSONObject();
             realmDesc.put("uri", "realm://objectserver.realm.io/default");
-            realmDesc.put("description", desc.toJson());
-            realmList.put(realmDesc);
 
             obj.put("authUrl", authUrl);
             obj.put("userToken", userToken.toJson());
-            obj.put("realms", realmList);
-            return SyncUser.fromJson(obj.toString());
+            SyncUser syncUser = SyncUser.fromJson(obj.toString());
+            // persist the user to the ObjectStore sync metadata, to simulate real login, otherwise SyncUser.isValid will
+            // "throw IllegalArgumentException: User not authenticated or authentication expired." since
+            // the call to  SyncManager.getUserStore().isActive(syncUser.getIdentity()) will return false
+            addToUserStore(syncUser);
+            return syncUser;
         } catch (JSONException e) {
             throw new RuntimeException(e);
         }
     }
 
     public static AuthenticateResponse createLoginResponse(long expires) {
-        return createLoginResponse(USER_TOKEN, "JohnDoe", expires);
+        return createLoginResponse(USER_TOKEN, "JohnDoe", expires, false);
     }
 
-    public static AuthenticateResponse createLoginResponse(String userTokenValue, String userIdentity, long expires) {
+    public static AuthenticateResponse createLoginResponse(String userTokenValue, String userIdentity, long expires, boolean isAdmin) {
         try {
-            Token userToken = new Token(userTokenValue, userIdentity, null, expires, null);
+            Token userToken = new Token(userTokenValue, userIdentity, null, expires, null, isAdmin);
             JSONObject response = new JSONObject();
             response.put("refresh_token", userToken.toJson());
             return AuthenticateResponse.from(response.toString());
@@ -98,18 +105,24 @@ public static AuthenticateResponse createLoginResponse(String userTokenValue, St
         }
     }
 
-    public static AuthenticateResponse createRefreshResponse() {
+    public static AuthenticateResponse createErrorResponse(ErrorCode code) {
+        return AuthenticateResponse.from(new ObjectServerError(code, "dummy"));
+    }
+
+    public static Token getRefreshToken(SyncUser user) {
         try {
-            Token userToken = new Token(USER_TOKEN, "JohnDoe", null, Long.MAX_VALUE, null);
-            JSONObject response = new JSONObject();
-            response.put("refresh_token", userToken.toJson());
-            return AuthenticateResponse.from(response.toString());
-        } catch (JSONException e) {
-            throw new RuntimeException(e);
+            return (Token) SYNC_USER_GET_ACCESS_TOKEN_METHOD.invoke(user);
+        } catch (IllegalAccessException | InvocationTargetException e) {
+            throw new AssertionError(e);
         }
     }
 
-    public static AuthenticateResponse createErrorResponse(ErrorCode code) {
-        return AuthenticateResponse.from(new ObjectServerError(code, "dummy"));
+    private static void addToUserStore(SyncUser user) {
+        try {
+            UserStore userStore = (UserStore) SYNC_MANAGER_GET_USER_STORE_METHOD.invoke(null);
+            userStore.put(user);
+        } catch (InvocationTargetException | IllegalAccessException e) {
+            throw new AssertionError(e);
+        }
     }
 }
diff --git a/realm/realm-library/src/main/cpp/CMake/RealmCore.cmake b/realm/realm-library/src/main/cpp/CMake/RealmCore.cmake
new file mode 100644
index 0000000000..bedbba6b6b
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/CMake/RealmCore.cmake
@@ -0,0 +1,125 @@
+###########################################################################
+#
+# Copyright 2017 Realm Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+###########################################################################
+include(ExternalProject)
+
+function(build_existing_realm_core core_source_path)
+    if (CMAKE_BUILD_TYPE STREQUAL "Debug")
+        set(debug_lib_suffix "-dbg")
+        add_compile_options(-DREALM_DEBUG)
+    else()
+        add_compile_options(-DNDEBUG)
+    endif()
+
+    ExternalProject_Add(realm-core
+        SOURCE_DIR ${core_source_path}
+        PREFIX ${core_source_path}/build-android-${ANDROID_ABI}-${CMAKE_BUILD_TYPE}
+        CMAKE_ARGS  -DCMAKE_TOOLCHAIN_FILE=${CMAKE_TOOLCHAIN_FILE}
+                    -DANDROID_ABI=${ANDROID_ABI}
+                    -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
+                    -DREALM_BUILD_LIB_ONLY=YES
+                    -DREALM_ENABLE_ENCRYPTION=1
+        INSTALL_COMMAND ""
+        LOG_CONFIGURE 1
+        LOG_BUILD 1
+        )
+
+    ExternalProject_Get_Property(realm-core SOURCE_DIR)
+    ExternalProject_Get_Property(realm-core BINARY_DIR)
+
+    # Create directories that are included in INTERFACE_INCLUDE_DIRECTORIES, as CMake requires they exist at
+    # configure time, when they'd otherwise not be created until we download and extract core.
+    file(MAKE_DIRECTORY "${BINARY_DIR}/src")
+
+    set(core_lib_file "${BINARY_DIR}/src/realm/librealm${debug_lib_suffix}.a")
+    add_library(lib_realm_core STATIC IMPORTED)
+    set_target_properties(lib_realm_core PROPERTIES IMPORTED_LOCATION ${core_lib_file}
+        IMPORTED_LINK_INTERFACE_LIBRARIES atomic
+        INTERFACE_INCLUDE_DIRECTORIES "${SOURCE_DIR}/src;${BINARY_DIR}/src")
+
+    ExternalProject_Add_Step(realm-core ensure-libraries
+        DEPENDEES build
+        BYPRODUCTS ${core_lib_file}
+        )
+
+    add_dependencies(lib_realm_core realm-core)
+endfunction()
+
+# Add the sync released as the library.
+function(use_sync_release enable_sync sync_dist_path)
+    # Link to core/sync debug lib for debug build if it is debug build and linking with debug core is enabled.
+    if (CMAKE_BUILD_TYPE STREQUAL "Debug" AND ${ENABLE_DEBUG_CORE})
+        set(debug_lib_suffix "-dbg")
+        add_compile_options(-DREALM_DEBUG)
+    else()
+        add_compile_options(-DNDEBUG)
+    endif()
+
+    # Configure import realm core lib
+    set(core_lib_path ${sync_dist_path}/librealm-android-${ANDROID_ABI}${debug_lib_suffix}.a)
+    if (NOT EXISTS ${core_lib_path})
+        if (ARMEABI)
+            set(core_lib_path ${sync_dist_path}/librealm-android-arm${debug_lib_suffix}.a)
+        elseif (ARMEABI_V7A)
+            set(core_lib_path ${sync_dist_path}/librealm-android-arm-v7a${debug_lib_suffix}.a)
+        elseif (ARM64_V8A)
+            set(core_lib_path ${sync_dist_path}/librealm-android-arm64${debug_lib_suffix}.a)
+        else()
+            message(FATAL_ERROR "Cannot find core lib file: ${core_lib_path}")
+        endif()
+    endif()
+
+    add_library(lib_realm_core STATIC IMPORTED)
+
+    # -latomic is not set by default for mips and armv5.
+    # See https://code.google.com/p/android/issues/detail?id=182094
+    set_target_properties(lib_realm_core PROPERTIES IMPORTED_LOCATION ${core_lib_path}
+        IMPORTED_LINK_INTERFACE_LIBRARIES atomic
+        INTERFACE_INCLUDE_DIRECTORIES "${sync_dist_path}/include")
+
+    if (enable_sync)
+        # Sync static library
+        set(sync_lib_path ${sync_dist_path}/librealm-sync-android-${ANDROID_ABI}${debug_lib_suffix}.a)
+        # Workaround for old core's funny ABI nicknames
+        if (NOT EXISTS ${sync_lib_path})
+            if (ARMEABI)
+                set(sync_lib_path ${sync_dist_path}/librealm-sync-android-arm${debug_lib_suffix}.a)
+            elseif (ARMEABI_V7A)
+                set(sync_lib_path ${sync_dist_path}/librealm-sync-android-arm-v7a${debug_lib_suffix}.a)
+            elseif (ARM64_V8A)
+                set(sync_lib_path ${sync_dist_path}/librealm-sync-android-arm64${debug_lib_suffix}.a)
+            else()
+                message(FATAL_ERROR "Cannot find sync lib file: ${sync_lib_path}")
+            endif()
+        endif()
+        add_library(lib_realm_sync STATIC IMPORTED)
+        set_target_properties(lib_realm_sync PROPERTIES IMPORTED_LOCATION ${sync_lib_path}
+            IMPORTED_LINK_INTERFACE_LIBRARIES lib_realm_core)
+    endif()
+
+    set(REALM_CORE_INCLUDE_DIR "${sync_dist_path}/include")
+endfunction()
+
+# Add core/sync libraries. Set the core_source_path to build core from source.
+# FIXME: Build from sync source is not supported yet.
+function(use_realm_core enable_sync sync_dist_path core_source_path)
+    if (core_source_path)
+        build_existing_realm_core(${core_source_path})
+    else()
+        use_sync_release(${enable_sync} ${sync_dist_path})
+    endif()
+endfunction()
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index 11c3d43caf..c36935cb8d 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -1,5 +1,24 @@
+###########################################################################
+#
+# Copyright 2017 Realm Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+###########################################################################
 cmake_minimum_required(VERSION 3.6.0)
 
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/CMake")
+
 # find javah
 find_package(Java COMPONENTS Development)
 if (NOT Java_Development_FOUND)
@@ -38,12 +57,13 @@ string(TOLOWER ${CMAKE_BUILD_TYPE} build_type_FOLDER)
 set(classes_PATH ${CMAKE_SOURCE_DIR}/../../../build/intermediates/classes/${REALM_FLAVOR}/${build_type_FOLDER}/)
 set(classes_LIST
     io.realm.internal.Table io.realm.internal.CheckedRow
-    io.realm.internal.LinkView io.realm.internal.Util io.realm.internal.UncheckedRow
+    io.realm.internal.Util io.realm.internal.UncheckedRow
     io.realm.internal.TableQuery io.realm.internal.SharedRealm io.realm.internal.TestUtil
-    io.realm.log.LogLevel io.realm.log.RealmLog io.realm.Property io.realm.OsRealmSchema
-    io.realm.OsRealmObjectSchema io.realm.internal.Collection
-    io.realm.internal.NativeObjectReference io.realm.internal.CollectionChangeSet
-    io.realm.internal.OsObject
+    io.realm.log.LogLevel io.realm.log.RealmLog io.realm.internal.Property io.realm.internal.OsSchemaInfo
+    io.realm.internal.OsObjectSchemaInfo io.realm.internal.OsResults
+    io.realm.internal.NativeObjectReference io.realm.internal.OsCollectionChangeSet
+    io.realm.internal.OsObject io.realm.internal.OsRealmConfig io.realm.internal.OsList
+    io.realm.internal.OsObjectStore
 )
 # /./ is the workaround for the problem that AS cannot find the jni headers.
 # See https://github.com/googlesamples/android-ndk/issues/319
@@ -51,7 +71,7 @@ set(jni_headers_PATH /./${PROJECT_BINARY_DIR}/jni_include)
 if (build_SYNC)
     list(APPEND classes_LIST
         io.realm.ClientResetRequiredError io.realm.RealmFileUserStore
-        io.realm.SyncManager io.realm.SyncSession
+        io.realm.SyncManager io.realm.SyncSession io.realm.SyncUser
     )
 endif()
 create_javah(TARGET jni_headers
@@ -62,57 +82,34 @@ create_javah(TARGET jni_headers
     DEPENDS ${classes_PATH}
 )
 
-# TODO: Ideally the debug build should link with core's debug build. But core dbg lib has
-# some compile options problems with arm, especially with macro REALM_DEBUG. Link to core
-# dbg for debug build when that gets solved.
-# We always link to the non-dbg version of core libs for now.
-# This means only JNI part has debugging symbols with debug build.
-# Debugging with core source code will also be done though anther approach -- compiling the core
-# with cmake inside android project.
-# Configure import realm core lib
-set(core_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-android-${ANDROID_ABI}.a)
-# Workaround for old core's funny ABI nicknames
-if (NOT EXISTS ${core_lib_PATH})
-    if (ARMEABI)
-        set(core_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-android-arm.a)
-    elseif (ARMEABI_V7A)
-        set(core_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-android-arm-v7a.a)
-    elseif (ARM64_V8A)
-        set(core_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-android-arm64.a)
-    else()
-        message(FATAL_ERROR "Cannot find core lib file: ${core_lib_PATH}")
-    endif()
-endif()
+include(RealmCore)
 
-add_library(lib_realm_core STATIC IMPORTED)
+use_realm_core(${build_SYNC} "${REALM_CORE_DIST_DIR}" "${CORE_SOURCE_PATH}")
 
-# -latomic is not set by default for mips and armv5.
-# See https://code.google.com/p/android/issues/detail?id=182094
-set_target_properties(lib_realm_core PROPERTIES IMPORTED_LOCATION ${core_lib_PATH}
-                                                IMPORTED_LINK_INTERFACE_LIBRARIES atomic)
+# Download openssl lib
+#string(TOLOWER "${CMAKE_BUILD_TYPE}" openssl_build_TYPE)
+set(openssl_build_TYPE "release")
+# FIXME Read the openssl version from core when the core/sync release has that information.
+set(openssl_VERSION "1.0.2k")
+set(openssl_BUILD_NUMBER "1")
+set(openssl_FILENAME "openssl-${openssl_build_TYPE}-${openssl_VERSION}-${openssl_BUILD_NUMBER}-Android-${ANDROID_ABI}")
+set(openssl_URL "http://static.realm.io/downloads/openssl/${openssl_VERSION}/Android/${ANDROID_ABI}/${openssl_FILENAME}.tar.gz")
 
-if (build_SYNC)
-    # Sync static library
-    set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-${ANDROID_ABI}.a)
-    # Workaround for old core's funny ABI nicknames
-    if (NOT EXISTS ${sync_lib_PATH})
-        if (ARMEABI)
-            set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm.a)
-        elseif (ARMEABI_V7A)
-            set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm-v7a.a)
-        elseif (ARM64_V8A)
-            set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm64.a)
-        else()
-            message(FATAL_ERROR "Cannot find sync lib file: ${sync_lib_PATH}")
-        endif()
-    endif()
-    add_library(lib_realm_sync STATIC IMPORTED)
-    set_target_properties(lib_realm_sync PROPERTIES IMPORTED_LOCATION ${sync_lib_PATH}
-                                                    IMPORTED_LINK_INTERFACE_LIBRARIES lib_realm_core)
-endif()
+message(STATUS "Downloading OpenSSL...")
+file(DOWNLOAD "${openssl_URL}" "${PROJECT_BINARY_DIR}/${openssl_FILENAME}.tar.gz")
+
+message(STATUS "Uncompressing OpenSSL...")
+execute_process(COMMAND ${CMAKE_COMMAND} -E tar xfz "${PROJECT_BINARY_DIR}/${openssl_FILENAME}.tar.gz"
+    WORKING_DIRECTORY "${PROJECT_BINARY_DIR}")
+
+message(STATUS "Importing OpenSSL...")
+include(${PROJECT_BINARY_DIR}/${openssl_FILENAME}/openssl.cmake)
+get_target_property(openssl_include_DIR crypto INTERFACE_INCLUDE_DIRECTORIES)
+get_target_property(crypto_LIB crypto IMPORTED_LOCATION)
+get_target_property(ssl_LIB ssl IMPORTED_LOCATION)
 
 # build application's shared lib
-include_directories(${REALM_CORE_DIST_DIR}/include
+include_directories(
     ${CMAKE_SOURCE_DIR}
     ${jni_headers_PATH}
     ${CMAKE_SOURCE_DIR}/object-store/src)
@@ -151,7 +148,7 @@ endif()
 # And this issue doesn't seem to impact the core compiling.
 set(CMAKE_CXX_FLAGS_RELEASE "-O2 -DNDEBUG")
 #-ggdb doesn't play well with -flto
-set(CMAKE_CXX_FLAGS_DEBUG "-ggdb -Og -DNDEBUG")
+set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -ggdb -Og")
 set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${REALM_COMMON_CXX_FLAGS} ${WARNING_CXX_FLAGS} ${ABI_CXX_FLAGS}")
 
 # Set link flags
@@ -198,9 +195,9 @@ add_library(realm-jni SHARED ${jni_SRC} ${objectstore_SRC} ${objectstore_sync_SR
 add_dependencies(realm-jni jni_headers)
 
 if (build_SYNC)
-    target_link_libraries(realm-jni log android lib_realm_sync)
+    target_link_libraries(realm-jni log android lib_realm_sync crypto ssl)
 else()
-    target_link_libraries(realm-jni log android lib_realm_core)
+    target_link_libraries(realm-jni log android lib_realm_core crypto)
 endif()
 
 # Strip the release so files and backup the unstripped versions
diff --git a/realm/realm-library/src/main/cpp/io_realm_OsRealmObjectSchema.cpp b/realm/realm-library/src/main/cpp/io_realm_OsRealmObjectSchema.cpp
deleted file mode 100644
index c3a954c8f1..0000000000
--- a/realm/realm-library/src/main/cpp/io_realm_OsRealmObjectSchema.cpp
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <jni.h>
-#include "io_realm_OsRealmObjectSchema.h"
-
-#include <object-store/src/object_schema.hpp>
-#include <object-store/src/property.hpp>
-
-#include "util.hpp"
-using namespace realm;
-
-JNIEXPORT jlong JNICALL Java_io_realm_OsRealmObjectSchema_nativeCreateRealmObjectSchema(JNIEnv* env, jclass,
-                                                                                        jstring className_)
-{
-    TR_ENTER()
-    try {
-        JStringAccessor name(env, className_);
-        ObjectSchema* object_schema = new ObjectSchema();
-        object_schema->name = name;
-        return reinterpret_cast<jlong>(object_schema);
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_OsRealmObjectSchema_nativeClose(JNIEnv* env, jclass, jlong native_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    try {
-        ObjectSchema* object_schema = reinterpret_cast<ObjectSchema*>(native_ptr);
-        delete object_schema;
-    }
-    CATCH_STD()
-}
-
-
-JNIEXPORT void JNICALL Java_io_realm_OsRealmObjectSchema_nativeAddProperty(JNIEnv* env, jclass, jlong native_ptr,
-                                                                         jlong property_ptr)
-{
-    TR_ENTER_PTR(native_ptr)
-    try {
-        ObjectSchema* object_schema = reinterpret_cast<ObjectSchema*>(native_ptr);
-        Property* property = reinterpret_cast<Property*>(property_ptr);
-        object_schema->persisted_properties.push_back(*property);
-        if (property->is_primary) {
-            object_schema->primary_key = property->name;
-        }
-    }
-    CATCH_STD()
-}
-
-JNIEXPORT jstring JNICALL Java_io_realm_OsRealmObjectSchema_nativeGetClassName(JNIEnv* env, jclass, jlong nativePtr)
-{
-    TR_ENTER_PTR(nativePtr)
-    try {
-        ObjectSchema* object_schema = reinterpret_cast<ObjectSchema*>(nativePtr);
-        auto name = object_schema->name;
-        return to_jstring(env, name);
-    }
-    CATCH_STD()
-
-    return nullptr;
-}
diff --git a/realm/realm-library/src/main/cpp/io_realm_OsRealmSchema.cpp b/realm/realm-library/src/main/cpp/io_realm_OsRealmSchema.cpp
deleted file mode 100644
index 20a4852a05..0000000000
--- a/realm/realm-library/src/main/cpp/io_realm_OsRealmSchema.cpp
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <jni.h>
-#include "io_realm_OsRealmSchema.h"
-
-#include <object-store/src/schema.hpp>
-#include <object-store/src/object_schema.hpp>
-#include <object-store/src/property.hpp>
-
-#include "util.hpp"
-using namespace realm;
-
-
-JNIEXPORT jlong JNICALL Java_io_realm_OsRealmSchema_nativeCreateFromList(JNIEnv* env, jclass,
-                                                                       jlongArray objectSchemaPtrs_)
-{
-    TR_ENTER()
-    try {
-        std::vector<ObjectSchema> object_schemas;
-        JniLongArray array(env, objectSchemaPtrs_);
-        for (jsize i = 0; i < array.len(); ++i) {
-            object_schemas.push_back(*reinterpret_cast<ObjectSchema*>(array[i]));
-        }
-        auto* schema = new Schema(object_schemas);
-        return reinterpret_cast<jlong>(schema);
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_OsRealmSchema_nativeClose(JNIEnv*, jclass, jlong nativePtr)
-{
-    TR_ENTER_PTR(nativePtr)
-    Schema* schema = reinterpret_cast<Schema*>(nativePtr);
-    delete schema;
-}
diff --git a/realm/realm-library/src/main/cpp/io_realm_Property.cpp b/realm/realm-library/src/main/cpp/io_realm_Property.cpp
deleted file mode 100644
index 38e9dff137..0000000000
--- a/realm/realm-library/src/main/cpp/io_realm_Property.cpp
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <jni.h>
-#include "io_realm_Property.h"
-
-#include <stdexcept>
-#include <object-store/src/property.hpp>
-#include <object-store/src/object_store.hpp>
-
-#include "util.hpp"
-
-using namespace realm;
-
-JNIEXPORT jlong JNICALL Java_io_realm_Property_nativeCreateProperty__Ljava_lang_String_2IZZZ(
-    JNIEnv* env, jclass, jstring name_, jint type, jboolean is_primary, jboolean is_indexed, jboolean is_nullable)
-{
-    TR_ENTER()
-    try {
-        JStringAccessor str(env, name_);
-        PropertyType p_type = static_cast<PropertyType>(static_cast<int>(type));
-        std::unique_ptr<Property> property(
-            new Property(str, p_type, "", "", to_bool(is_primary), to_bool(is_indexed), to_bool(is_nullable)));
-        if (to_bool(is_indexed) && !property->is_indexable()) {
-            throw std::invalid_argument(
-                "This field cannot be indexed - Only String/byte/short/int/long/boolean/Date fields are supported.");
-        }
-        if (to_bool(is_primary) && p_type != PropertyType::Int && p_type != PropertyType::String) {
-            std::string typ = property->type_string();
-            throw std::invalid_argument("Invalid primary key type: " + typ);
-        }
-        return reinterpret_cast<jlong>(property.release());
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_Property_nativeCreateProperty__Ljava_lang_String_2ILjava_lang_String_2(
-    JNIEnv* env, jclass, jstring name_, jint type, jstring linkedToName_)
-{
-    TR_ENTER()
-    try {
-        JStringAccessor name(env, name_);
-        JStringAccessor link_name(env, linkedToName_);
-        PropertyType p_type = static_cast<PropertyType>(static_cast<int>(type));
-        bool is_nullable = (p_type == PropertyType::Object);
-        return reinterpret_cast<jlong>(new Property(name, p_type, link_name, "", false, false, is_nullable));
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_Property_nativeClose(JNIEnv* env, jclass, jlong property_ptr)
-{
-    TR_ENTER_PTR(property_ptr)
-    try {
-        Property* property = reinterpret_cast<Property*>(property_ptr);
-        delete property;
-    }
-    CATCH_STD()
-}
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp b/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
index 313a2d169b..a3e8b7d57d 100644
--- a/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
@@ -14,14 +14,17 @@
  * limitations under the License.
  */
 
-#include <jni.h>
-#include <jni_util/log.hpp>
 #include "io_realm_RealmFileUserStore.h"
-#include "sync/sync_manager.hpp"
-#include "sync/sync_user.hpp"
+
+#include <sync/sync_manager.hpp>
+#include <sync/sync_user.hpp>
+
+#include "java_class_global_def.hpp"
 #include "util.hpp"
+#include "jni_util/log.hpp"
 
 using namespace realm;
+using namespace realm::_impl;
 
 static const char* ERR_COULD_NOT_ALLOCATE_MEMORY = "Could not allocate memory to return all users.";
 
@@ -35,23 +38,31 @@ static jstring to_user_string_or_null(JNIEnv* env, const std::shared_ptr<SyncUse
     }
 }
 
+static SyncUserIdentifier create_sync_user_identifier(JNIEnv* env, jstring j_user_id, jstring j_auth_url)
+{
+    JStringAccessor user_id(env, j_user_id);   // throws
+    JStringAccessor auth_url(env, j_auth_url); // throws
+    return {user_id, auth_url};
+}
+
 JNIEXPORT jstring JNICALL Java_io_realm_RealmFileUserStore_nativeGetCurrentUser(JNIEnv* env, jclass)
 {
     TR_ENTER()
     try {
-        const std::shared_ptr<SyncUser>& user = SyncManager::shared().get_current_user();
+        auto user = SyncManager::shared().get_current_user();
         return to_user_string_or_null(env, user);
     }
     CATCH_STD()
     return nullptr;
 }
 
-JNIEXPORT jstring JNICALL Java_io_realm_RealmFileUserStore_nativeGetUser(JNIEnv* env, jclass, jstring identity)
+JNIEXPORT jstring JNICALL Java_io_realm_RealmFileUserStore_nativeGetUser(JNIEnv* env, jclass, jstring j_user_id,
+                                                                         jstring j_auth_url)
 {
     TR_ENTER()
     try {
-        JStringAccessor id(env, identity); // throws
-        const std::shared_ptr<SyncUser>& user = SyncManager::shared().get_existing_logged_in_user(id);
+        auto user = SyncManager::shared().get_existing_logged_in_user(
+            create_sync_user_identifier(env, j_user_id, j_auth_url));
         return to_user_string_or_null(env, user);
     }
     CATCH_STD()
@@ -59,26 +70,24 @@ JNIEXPORT jstring JNICALL Java_io_realm_RealmFileUserStore_nativeGetUser(JNIEnv*
 }
 
 JNIEXPORT void JNICALL Java_io_realm_RealmFileUserStore_nativeUpdateOrCreateUser(JNIEnv* env, jclass,
-                                                                                 jstring identity, jstring jsonToken,
-                                                                                 jstring url)
+                                                                                 jstring j_user_id, jstring json_token,
+                                                                                 jstring j_auth_url)
 {
     TR_ENTER()
     try {
-        JStringAccessor user_identity(env, identity);    // throws
-        JStringAccessor user_json_token(env, jsonToken); // throws
-        JStringAccessor auth_url(env, url);              // throws
-
-        SyncManager::shared().get_user(user_identity, user_json_token, std::string(auth_url));
+        JStringAccessor user_json_token(env, json_token); // throws
+        SyncManager::shared().get_user(create_sync_user_identifier(env, j_user_id, j_auth_url), user_json_token);
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_RealmFileUserStore_nativeLogoutUser(JNIEnv* env, jclass, jstring identity)
+JNIEXPORT void JNICALL Java_io_realm_RealmFileUserStore_nativeLogoutUser(JNIEnv* env, jclass, jstring j_user_id,
+                                                                         jstring j_auth_url)
 {
     TR_ENTER()
     try {
-        JStringAccessor id(env, identity); // throws
-        const std::shared_ptr<SyncUser>& user = SyncManager::shared().get_existing_logged_in_user(id);
+        auto user = SyncManager::shared().get_existing_logged_in_user(
+            create_sync_user_identifier(env, j_user_id, j_auth_url));
         if (user) {
             user->log_out();
         }
@@ -86,13 +95,28 @@ JNIEXPORT void JNICALL Java_io_realm_RealmFileUserStore_nativeLogoutUser(JNIEnv*
     CATCH_STD()
 }
 
+JNIEXPORT jboolean JNICALL Java_io_realm_RealmFileUserStore_nativeIsActive(JNIEnv* env, jclass, jstring j_user_id,
+                                                                           jstring j_auth_url)
+{
+    TR_ENTER()
+    try {
+        auto user = SyncManager::shared().get_existing_logged_in_user(
+            create_sync_user_identifier(env, j_user_id, j_auth_url));
+        if (user) {
+            return to_jbool(user->state() == SyncUser::State::Active);
+        }
+    }
+    CATCH_STD()
+    return JNI_FALSE;
+}
+
 JNIEXPORT jobjectArray JNICALL Java_io_realm_RealmFileUserStore_nativeGetAllUsers(JNIEnv* env, jclass)
 {
     TR_ENTER()
-    std::vector<std::shared_ptr<SyncUser>> all_users = SyncManager::shared().all_logged_in_users();
+    auto all_users = SyncManager::shared().all_logged_in_users();
     if (!all_users.empty()) {
         size_t len = all_users.size();
-        jobjectArray users_token = env->NewObjectArray(len, java_lang_string, 0);
+        jobjectArray users_token = env->NewObjectArray(len, JavaClassGlobalDef::java_lang_string(), 0);
         if (users_token == nullptr) {
             ThrowException(env, OutOfMemory, ERR_COULD_NOT_ALLOCATE_MEMORY);
             return nullptr;
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
index d9f15dd859..d34e026d87 100644
--- a/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
@@ -23,13 +23,19 @@
 #include <binding_callback_thread_observer.hpp>
 
 #include "util.hpp"
-#include "jni_util/jni_utils.hpp"
+#include "jni_util/java_class.hpp"
 #include "jni_util/java_method.hpp"
+#include "jni_util/jni_utils.hpp"
 
 using namespace realm;
 using namespace realm::jni_util;
+using namespace realm::util;
 
 struct AndroidClientListener : public realm::BindingCallbackThreadObserver {
+    AndroidClientListener(JNIEnv* env)
+        : m_realm_exception_class(env, "io/realm/exceptions/RealmError")
+    {
+    }
 
     void did_create_thread() override
     {
@@ -40,11 +46,32 @@ struct AndroidClientListener : public realm::BindingCallbackThreadObserver {
 
     void will_destroy_thread() override
     {
-        Log::d("SyncClient thread destroyed");
+        // avoid allocating any NewString if we have a pending exception
+        // otherwise a "JNI called with pending exception" will be called
+        if (JniUtils::get_env(true)->ExceptionCheck() == JNI_FALSE) {
+            Log::d("SyncClient thread destroyed");
+        }
+
         // Failing to detach the JVM before closing the thread will crash on ART
         JniUtils::detach_current_thread();
     }
-} s_client_thread_listener;
+
+    void handle_error(std::exception const& e) override
+    {
+        JNIEnv* env = JniUtils::get_env(true);
+        std::string msg = format("An exception has been thrown on the sync client thread:\n%1", e.what());
+        Log::f(msg.c_str());
+        // Since user has no way to handle exceptions thrown on the sync client thread, we just convert it to a Java
+        // exception to get more debug information for ourself.
+        // FIXME: We really need to find a universal and clever way to get the native backtrace when exception thrown
+        env->ThrowNew(m_realm_exception_class, msg.c_str());
+    }
+
+private:
+    // For some reasons, FindClass() doesn't work in the native thread even when the JVM is attached before. Get the
+    // RealmError class on a normal JVM thread and throw it later on the sync client thread.
+    JavaClass m_realm_exception_class;
+};
 
 struct AndroidSyncLoggerFactory : public realm::SyncLoggerFactory {
     // The level param is ignored. Use the global RealmLog.setLevel() to control all log levels.
@@ -72,8 +99,9 @@ JNIEXPORT void JNICALL Java_io_realm_SyncManager_nativeInitializeSyncManager(JNI
         JStringAccessor base_file_path(env, sync_base_dir); // throws
         SyncManager::shared().configure_file_system(base_file_path, SyncManager::MetadataMode::NoEncryption);
 
+        static AndroidClientListener client_thread_listener(env);
         // Register Sync Client thread start/stop callback
-        g_binding_callback_thread_observer = &s_client_thread_listener;
+        g_binding_callback_thread_observer = &client_thread_listener;
 
         // init logger
         SyncManager::shared().set_logger_factory(s_sync_logger_factory);
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
index e3a58bbad2..20c8f764cd 100644
--- a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
@@ -15,6 +15,7 @@
  */
 
 #include <jni.h>
+#include <string>
 
 #include "io_realm_SyncSession.h"
 
@@ -22,30 +23,217 @@
 #include "object-store/src/sync/sync_session.hpp"
 
 #include "util.hpp"
+#include "java_class_global_def.hpp"
+#include "jni_util/java_global_ref.hpp"
+#include "jni_util/java_local_ref.hpp"
+#include "jni_util/java_method.hpp"
+#include "jni_util/java_class.hpp"
+#include "jni_util/jni_utils.hpp"
 
-using namespace std;
 using namespace realm;
-using namespace sync;
+using namespace realm::jni_util;
+using namespace realm::sync;
+using namespace realm::_impl;
+
+static_assert(SyncSession::PublicState::WaitingForAccessToken ==
+                  static_cast<SyncSession::PublicState>(io_realm_SyncSession_STATE_VALUE_WAITING_FOR_ACCESS_TOKEN),
+              "");
+static_assert(SyncSession::PublicState::Active ==
+                  static_cast<SyncSession::PublicState>(io_realm_SyncSession_STATE_VALUE_ACTIVE),
+              "");
+static_assert(SyncSession::PublicState::Dying ==
+                  static_cast<SyncSession::PublicState>(io_realm_SyncSession_STATE_VALUE_DYING),
+              "");
+static_assert(SyncSession::PublicState::Inactive ==
+                  static_cast<SyncSession::PublicState>(io_realm_SyncSession_STATE_VALUE_INACTIVE),
+              "");
+static_assert(SyncSession::PublicState::Error ==
+                  static_cast<SyncSession::PublicState>(io_realm_SyncSession_STATE_VALUE_ERROR),
+              "");
 
 JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeRefreshAccessToken(JNIEnv* env, jclass,
-                                                                              jstring localRealmPath,
-                                                                              jstring accessToken,
-                                                                              jstring sync_realm_url)
+                                                                              jstring j_local_realm_path,
+                                                                              jstring j_access_token,
+                                                                              jstring j_sync_realm_url)
 {
     TR_ENTER()
     try {
-        JStringAccessor local_realm_path(env, localRealmPath);
+        JStringAccessor local_realm_path(env, j_local_realm_path);
         auto session = SyncManager::shared().get_existing_session(local_realm_path);
         if (session) {
-            JStringAccessor access_token(env, accessToken);
-            JStringAccessor realm_url(env, sync_realm_url);
-            session->refresh_access_token(access_token, std::string(realm_url));
+            JStringAccessor access_token(env, j_access_token);
+            JStringAccessor realm_url(env, j_sync_realm_url);
+
+            session->refresh_access_token(access_token, std::string(session->config().realm_url()));
             return JNI_TRUE;
         }
         else {
-            realm::jni_util::Log::d("no active/inactive session found");
+            Log::d("no active/inactive session found");
+        }
+    }
+    CATCH_STD()
+    return JNI_FALSE;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_SyncSession_nativeAddProgressListener(JNIEnv* env, jclass,
+                                                                            jstring j_local_realm_path,
+                                                                            jlong listener_id, jint direction,
+                                                                            jboolean is_streaming)
+{
+    try {
+        // JNIEnv is thread confined, so we need a deep copy in order to capture the string in the lambda
+        std::string local_realm_path(JStringAccessor(env, j_local_realm_path));
+        std::shared_ptr<SyncSession> session = SyncManager::shared().get_existing_active_session(local_realm_path);
+        if (!session) {
+            // FIXME: We should lift this restriction
+            ThrowException(env, IllegalState,
+                           "Cannot register a progress listener before a session is "
+                           "created. A session will be created after the first call to Realm.getInstance().");
+            return 0;
+        }
+
+        SyncSession::NotifierType type =
+            (direction == 1) ? SyncSession::NotifierType::download : SyncSession::NotifierType::upload;
+
+        static JavaClass java_syncmanager_class(env, "io/realm/SyncManager");
+        static JavaMethod java_notify_progress_listener(env, java_syncmanager_class, "notifyProgressListener", "(Ljava/lang/String;JJJ)V", true);
+
+        std::function<SyncProgressNotifierCallback> callback = [local_realm_path, listener_id](
+            uint64_t transferred, uint64_t transferrable) {
+            JNIEnv* local_env = jni_util::JniUtils::get_env(true);
+
+            JavaLocalRef<jstring> path(local_env, to_jstring(local_env, local_realm_path));
+            local_env->CallStaticVoidMethod(java_syncmanager_class, java_notify_progress_listener, path.get(),
+                                            listener_id, static_cast<jlong>(transferred),
+                                            static_cast<jlong>(transferrable));
+
+            // All exceptions will be caught on the Java side of handlers, but Errors will still end
+            // up here, so we need to do something sensible with them.
+            // Throwing a C++ exception will terminate the sync thread and cause the pending Java
+            // exception to become visible. For some (unknown) reason Logcat will not see the C++
+            // exception, only the Java one.
+            if (local_env->ExceptionCheck()) {
+                local_env->ExceptionDescribe();
+                throw std::runtime_error("An unexpected Error was thrown from Java. See LogCat");
+            }
+        };
+        uint64_t token = session->register_progress_notifier(callback, type, to_bool(is_streaming));
+        return static_cast<jlong>(token);
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT void JNICALL Java_io_realm_SyncSession_nativeRemoveProgressListener(JNIEnv* env, jclass,
+                                                                              jstring j_local_realm_path,
+                                                                              jlong listener_token)
+{
+    try {
+        JStringAccessor local_realm_path(env, j_local_realm_path);
+        std::shared_ptr<SyncSession> session = SyncManager::shared().get_existing_active_session(local_realm_path);
+        if (session) {
+            session->unregister_progress_notifier(static_cast<uint64_t>(listener_token));
+        }
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeWaitForDownloadCompletion(JNIEnv* env,
+                                                                                     jobject session_object,
+                                                                                     jint callback_id,
+                                                                                     jstring j_local_realm_path)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor local_realm_path(env, j_local_realm_path);
+        auto session = SyncManager::shared().get_existing_session(local_realm_path);
+
+        if (session) {
+            static JavaClass java_sync_session_class(env, "io/realm/SyncSession");
+            static JavaMethod java_notify_result_method(env, java_sync_session_class, "notifyAllChangesSent",
+                                                        "(ILjava/lang/Long;Ljava/lang/String;)V");
+            JavaGlobalRef java_session_object_ref(env, session_object);
+
+            bool listener_registered =
+                session->wait_for_download_completion([java_session_object_ref, callback_id](std::error_code error) {
+                    JNIEnv* env = JniUtils::get_env(true);
+                    JavaLocalRef<jobject> java_error_code;
+                    JavaLocalRef<jstring> java_error_message;
+                    if (error != std::error_code{}) {
+                        java_error_code =
+                            JavaLocalRef<jobject>(env, JavaClassGlobalDef::new_long(env, error.value()));
+                        java_error_message = JavaLocalRef<jstring>(env, env->NewStringUTF(error.message().c_str()));
+                    }
+                    env->CallVoidMethod(java_session_object_ref.get(), java_notify_result_method,
+                                        callback_id, java_error_code.get(), java_error_message.get());
+                });
+
+            return to_jbool(listener_registered);
         }
     }
     CATCH_STD()
     return JNI_FALSE;
 }
+
+JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeWaitForUploadCompletion(JNIEnv* env,
+                                                                                   jobject session_object,
+                                                                                   jint callback_id,
+                                                                                   jstring j_local_realm_path)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor local_realm_path(env, j_local_realm_path);
+        auto session = SyncManager::shared().get_existing_session(local_realm_path);
+
+        if (session) {
+            static JavaClass java_sync_session_class(env, "io/realm/SyncSession");
+            static JavaMethod java_notify_result_method(env, java_sync_session_class, "notifyAllChangesSent",
+                                                        "(ILjava/lang/Long;Ljava/lang/String;)V");
+            JavaGlobalRef java_session_object_ref(env, session_object);
+
+            bool listener_registered =
+                session->wait_for_upload_completion([java_session_object_ref, callback_id](std::error_code error) {
+                    JNIEnv* env = JniUtils::get_env(true);
+                    JavaLocalRef<jobject> java_error_code;
+                    JavaLocalRef<jstring> java_error_message;
+                    if (error != std::error_code{}) {
+                        java_error_code = JavaLocalRef<jobject>(env, JavaClassGlobalDef::new_long(env, error.value()));
+                        java_error_message = JavaLocalRef<jstring>(env, env->NewStringUTF(error.message().c_str()));
+                    }
+                    env->CallVoidMethod(java_session_object_ref.get(), java_notify_result_method,
+                                        callback_id, java_error_code.get(), java_error_message.get());
+                });
+
+            return to_jbool(listener_registered);
+        }
+    }
+    CATCH_STD()
+    return JNI_FALSE;
+}
+
+
+JNIEXPORT jbyte JNICALL Java_io_realm_SyncSession_nativeGetState(JNIEnv* env, jclass, jstring j_local_realm_path)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor local_realm_path(env, j_local_realm_path);
+        auto session = SyncManager::shared().get_existing_session(local_realm_path);
+
+        if (session) {
+            switch (session->state()) {
+                case SyncSession::PublicState::WaitingForAccessToken:
+                    return io_realm_SyncSession_STATE_VALUE_WAITING_FOR_ACCESS_TOKEN;
+                case SyncSession::PublicState::Active:
+                    return io_realm_SyncSession_STATE_VALUE_ACTIVE;
+                case SyncSession::PublicState::Dying:
+                    return io_realm_SyncSession_STATE_VALUE_DYING;
+                case SyncSession::PublicState::Inactive:
+                    return io_realm_SyncSession_STATE_VALUE_INACTIVE;
+                case SyncSession::PublicState::Error:
+                    return io_realm_SyncSession_STATE_VALUE_ERROR;
+            }
+        }
+    }
+    CATCH_STD()
+    return -1;
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp
index b584438ada..988e938528 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_CheckedRow.cpp
@@ -159,16 +159,6 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_CheckedRow_nativeIsNullLink(JN
     return Java_io_realm_internal_UncheckedRow_nativeIsNullLink(env, obj, nativeRowPtr, columnIndex);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CheckedRow_nativeGetLinkView(JNIEnv* env, jobject obj,
-                                                                            jlong nativeRowPtr, jlong columnIndex)
-{
-    if (!ROW_AND_COL_INDEX_AND_TYPE_VALID(env, ROW(nativeRowPtr), columnIndex, type_LinkList)) {
-        return 0;
-    }
-
-    return Java_io_realm_internal_UncheckedRow_nativeGetLinkView(env, obj, nativeRowPtr, columnIndex);
-}
-
 JNIEXPORT void JNICALL Java_io_realm_internal_CheckedRow_nativeSetLong(JNIEnv* env, jobject obj, jlong nativeRowPtr,
                                                                        jlong columnIndex, jlong value)
 {
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp
index 057f7a79ba..26f53313cc 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp
@@ -14,46 +14,22 @@
  * limitations under the License.
  */
 
-#include <jni.h>
-#include "io_realm_internal_Collection.h"
+#include "io_realm_internal_OsResults.h"
 
 #include <shared_realm.hpp>
 #include <results.hpp>
+#include <list.hpp>
 
+#include "java_class_global_def.hpp"
 #include "java_sort_descriptor.hpp"
+#include "observable_collection_wrapper.hpp"
 #include "util.hpp"
 
-#include "jni_util/java_global_weak_ref.hpp"
-#include "jni_util/java_method.hpp"
-
 using namespace realm;
 using namespace realm::jni_util;
 using namespace realm::_impl;
 
-// We need to control the life cycle of Results, weak ref of Java Collection object and the NotificationToken.
-// Wrap all three together, so when the Java Collection object gets GCed, all three of them will be invalidated.
-struct ResultsWrapper {
-    JavaGlobalWeakRef m_collection_weak_ref;
-    NotificationToken m_notification_token;
-    Results m_results;
-
-    ResultsWrapper(Results& results)
-        : m_collection_weak_ref()
-        , m_notification_token()
-        , m_results(std::move(results))
-    {
-    }
-
-    ResultsWrapper(ResultsWrapper&&) = delete;
-    ResultsWrapper& operator=(ResultsWrapper&&) = delete;
-
-    ResultsWrapper(ResultsWrapper const&) = delete;
-    ResultsWrapper& operator=(ResultsWrapper const&) = delete;
-
-    ~ResultsWrapper()
-    {
-    }
-};
+typedef ObservableCollectionWrapper<Results> ResultsWrapper;
 
 static void finalize_results(jlong ptr);
 
@@ -63,10 +39,10 @@ static void finalize_results(jlong ptr)
     delete reinterpret_cast<ResultsWrapper*>(ptr);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateResults(JNIEnv* env, jclass,
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeCreateResults(JNIEnv* env, jclass,
                                                                               jlong shared_realm_ptr, jlong query_ptr,
-                                                                              jobject sort_desc,
-                                                                              jobject distinct_desc)
+                                                                              jobject j_sort_desc,
+                                                                              jobject j_distinct_desc)
 {
     TR_ENTER()
     try {
@@ -76,8 +52,16 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateResults(JN
         }
 
         auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-        Results results(shared_realm, *query, SortDescriptor(JavaSortDescriptor(env, sort_desc)),
-                        SortDescriptor(JavaSortDescriptor(env, distinct_desc)));
+
+        DescriptorOrdering descriptor_ordering;
+        REALM_ASSERT_RELEASE(!(j_sort_desc && j_distinct_desc));
+        if (j_sort_desc) {
+            descriptor_ordering.append_sort(JavaSortDescriptor(env, j_sort_desc).sort_descriptor());
+        }
+        if (j_distinct_desc) {
+            descriptor_ordering.append_distinct(JavaSortDescriptor(env, j_distinct_desc).distinct_descriptor());
+        }
+        Results results(shared_realm, *query, descriptor_ordering);
         auto wrapper = new ResultsWrapper(results);
 
         return reinterpret_cast<jlong>(wrapper);
@@ -86,16 +70,19 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateResults(JN
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateResultsFromLinkView(JNIEnv* env, jclass,
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeCreateResultsFromList(JNIEnv* env, jclass,
                                                                                           jlong shared_realm_ptr,
-                                                                                          jlong link_view_ptr,
-                                                                                          jobject sort_desc)
+                                                                                          jlong list_ptr,
+                                                                                          jobject j_sort_desc)
 {
     TR_ENTER()
     try {
-        auto link_view_ref = reinterpret_cast<LinkViewRef*>(link_view_ptr);
+        auto& list_wrapper = *reinterpret_cast<ObservableCollectionWrapper<List>*>(list_ptr);
+        auto& list = list_wrapper.collection();
         auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-        Results results(shared_realm, *link_view_ref, util::none, SortDescriptor(JavaSortDescriptor(env, sort_desc)));
+        Results results = j_sort_desc ?
+            list.sort(JavaSortDescriptor(env, j_sort_desc).sort_descriptor()) :
+            list.as_results();
         auto wrapper = new ResultsWrapper(results);
 
         return reinterpret_cast<jlong>(wrapper);
@@ -104,12 +91,12 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateResultsFro
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateSnapshot(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeCreateSnapshot(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr);
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        auto snapshot_results = wrapper->m_results.snapshot();
+        auto snapshot_results = wrapper->collection().snapshot();
         auto snapshot_wrapper = new ResultsWrapper(snapshot_results);
         return reinterpret_cast<jlong>(snapshot_wrapper);
     }
@@ -117,39 +104,39 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateSnapshot(J
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeContains(JNIEnv* env, jclass, jlong native_ptr,
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_OsResults_nativeContains(JNIEnv* env, jclass, jlong native_ptr,
                                                                             jlong native_row_ptr)
 {
     TR_ENTER_PTR(native_ptr);
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
         auto row = reinterpret_cast<Row*>(native_row_ptr);
-        size_t index = wrapper->m_results.index_of(*row);
+        size_t index = wrapper->collection().index_of(RowExpr(*row));
         return to_jbool(index != not_found);
     }
     CATCH_STD();
     return JNI_FALSE;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeGetRow(JNIEnv* env, jclass, jlong native_ptr,
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeGetRow(JNIEnv* env, jclass, jlong native_ptr,
                                                                        jint index)
 {
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        auto row = wrapper->m_results.get(static_cast<size_t>(index));
+        auto row = wrapper->collection().get(static_cast<size_t>(index));
         return reinterpret_cast<jlong>(new Row(std::move(row)));
     }
     CATCH_STD()
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeFirstRow(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeFirstRow(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        auto optional_row = wrapper->m_results.first();
+        auto optional_row = wrapper->collection().first();
         if (optional_row) {
             return reinterpret_cast<jlong>(new Row(std::move(optional_row.value())));
         }
@@ -158,12 +145,12 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeFirstRow(JNIEnv*
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeLastRow(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeLastRow(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        auto optional_row = wrapper->m_results.last();
+        auto optional_row = wrapper->collection().last();
         if (optional_row) {
             return reinterpret_cast<jlong>(new Row(std::move(optional_row.value())));
         }
@@ -172,28 +159,28 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeLastRow(JNIEnv*
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Collection_nativeClear(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT void JNICALL Java_io_realm_internal_OsResults_nativeClear(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        wrapper->m_results.clear();
+        wrapper->collection().clear();
     }
     CATCH_STD()
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeSize(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeSize(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        return static_cast<jlong>(wrapper->m_results.size());
+        return static_cast<jlong>(wrapper->collection().size());
     }
     CATCH_STD()
     return 0;
 }
 
-JNIEXPORT jobject JNICALL Java_io_realm_internal_Collection_nativeAggregate(JNIEnv* env, jclass, jlong native_ptr,
+JNIEXPORT jobject JNICALL Java_io_realm_internal_OsResults_nativeAggregate(JNIEnv* env, jclass, jlong native_ptr,
                                                                             jlong column_index, jbyte agg_func)
 {
     TR_ENTER_PTR(native_ptr)
@@ -203,20 +190,24 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_Collection_nativeAggregate(JNIE
         size_t index = S(column_index);
         Optional<Mixed> value;
         switch (agg_func) {
-            case io_realm_internal_Collection_AGGREGATE_FUNCTION_MINIMUM:
-                value = wrapper->m_results.min(index);
+            case io_realm_internal_OsResults_AGGREGATE_FUNCTION_MINIMUM:
+                value = wrapper->collection().min(index);
                 break;
-            case io_realm_internal_Collection_AGGREGATE_FUNCTION_MAXIMUM:
-                value = wrapper->m_results.max(index);
+            case io_realm_internal_OsResults_AGGREGATE_FUNCTION_MAXIMUM:
+                value = wrapper->collection().max(index);
                 break;
-            case io_realm_internal_Collection_AGGREGATE_FUNCTION_AVERAGE:
-                value = wrapper->m_results.average(index);
-                if (!value) {
+            case io_realm_internal_OsResults_AGGREGATE_FUNCTION_AVERAGE: {
+                Optional<double> value_count(wrapper->collection().average(index));
+                if (value_count) {
+                    value = Optional<Mixed>(Mixed(value_count.value()));
+                }
+                else {
                     value = Optional<Mixed>(0.0);
                 }
                 break;
-            case io_realm_internal_Collection_AGGREGATE_FUNCTION_SUM:
-                value = wrapper->m_results.sum(index);
+            }
+            case io_realm_internal_OsResults_AGGREGATE_FUNCTION_SUM:
+                value = wrapper->collection().sum(index);
                 break;
             default:
                 REALM_UNREACHABLE();
@@ -229,13 +220,13 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_Collection_nativeAggregate(JNIE
         Mixed m = *value;
         switch (m.get_type()) {
             case type_Int:
-                return NewLong(env, m.get_int());
+                return JavaClassGlobalDef::new_long(env, m.get_int());
             case type_Float:
-                return NewFloat(env, m.get_float());
+                return JavaClassGlobalDef::new_float(env, m.get_float());
             case type_Double:
-                return NewDouble(env, m.get_double());
+                return JavaClassGlobalDef::new_double(env, m.get_double());
             case type_Timestamp:
-                return NewDate(env, m.get_timestamp());
+                return JavaClassGlobalDef::new_date(env, m.get_timestamp());
             default:
                 throw std::invalid_argument("Excepted numeric type");
         }
@@ -244,96 +235,69 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_Collection_nativeAggregate(JNIE
     return static_cast<jobject>(nullptr);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeSort(JNIEnv* env, jclass, jlong native_ptr,
-                                                                     jobject sort_desc)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeSort(JNIEnv* env, jclass, jlong native_ptr,
+                                                                     jobject j_sort_desc)
 {
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        auto sorted_result = wrapper->m_results.sort(JavaSortDescriptor(env, sort_desc));
+        auto sorted_result = wrapper->collection().sort(JavaSortDescriptor(env, j_sort_desc).sort_descriptor());
         return reinterpret_cast<jlong>(new ResultsWrapper(sorted_result));
     }
     CATCH_STD()
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeDistinct(JNIEnv* env, jclass, jlong native_ptr,
-                                                                         jobject distinct_desc)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeDistinct(JNIEnv* env, jclass, jlong native_ptr,
+                                                                         jobject j_distinct_desc)
 {
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        auto distinct_result = wrapper->m_results.distinct(JavaSortDescriptor(env, distinct_desc));
+        auto distinct_result =
+            wrapper->collection().distinct(JavaSortDescriptor(env, j_distinct_desc).distinct_descriptor());
         return reinterpret_cast<jlong>(new ResultsWrapper(distinct_result));
     }
     CATCH_STD()
     return reinterpret_cast<jlong>(nullptr);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Collection_nativeStartListening(JNIEnv* env, jobject instance,
+JNIEXPORT void JNICALL Java_io_realm_internal_OsResults_nativeStartListening(JNIEnv* env, jobject instance,
                                                                               jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
 
-    static JavaMethod notify_change_listeners(env, instance, "notifyChangeListeners", "(J)V");
-
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        if (!wrapper->m_collection_weak_ref) {
-            wrapper->m_collection_weak_ref = JavaGlobalWeakRef(env, instance);
-        }
-
-        auto cb = [=](CollectionChangeSet const& changes, std::exception_ptr err) {
-            // OS will call all notifiers' callback in one run, so check the Java exception first!!
-            if (env->ExceptionCheck())
-                return;
-
-            if (err) {
-                try {
-                    std::rethrow_exception(err);
-                }
-                catch (const std::exception& e) {
-                    realm::jni_util::Log::e("Caught exception in collection change callback %1", e.what());
-                    return;
-                }
-            }
-
-            wrapper->m_collection_weak_ref.call_with_local_ref(env, [&](JNIEnv* local_env, jobject collection_obj) {
-                local_env->CallVoidMethod(
-                    collection_obj, notify_change_listeners,
-                    reinterpret_cast<jlong>(changes.empty() ? 0 : new CollectionChangeSet(changes)));
-            });
-        };
-
-        wrapper->m_notification_token = wrapper->m_results.add_notification_callback(cb);
+        wrapper->start_listening(env, instance);
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Collection_nativeStopListening(JNIEnv* env, jobject, jlong native_ptr)
+JNIEXPORT void JNICALL Java_io_realm_internal_OsResults_nativeStopListening(JNIEnv* env, jobject, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
 
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        wrapper->m_notification_token = {};
+        wrapper->stop_listening();
     }
     CATCH_STD()
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeGetFinalizerPtr(JNIEnv*, jclass)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeGetFinalizerPtr(JNIEnv*, jclass)
 {
     TR_ENTER()
     return reinterpret_cast<jlong>(&finalize_results);
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeWhere(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeWhere(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
 
-        auto table_view = wrapper->m_results.get_tableview();
+        auto table_view = wrapper->collection().get_tableview();
         Query* query =
             new Query(table_view.get_parent(), std::unique_ptr<TableViewBase>(new TableView(std::move(table_view))));
         return reinterpret_cast<jlong>(query);
@@ -342,7 +306,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeWhere(JNIEnv* en
     return 0;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeIndexOf(JNIEnv* env, jclass, jlong native_ptr,
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeIndexOf(JNIEnv* env, jclass, jlong native_ptr,
                                                                         jlong row_native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
@@ -350,33 +314,18 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeIndexOf(JNIEnv*
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
         auto row = reinterpret_cast<Row*>(row_native_ptr);
 
-        return static_cast<jlong>(wrapper->m_results.index_of(*row));
-    }
-    CATCH_STD()
-    return npos;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeIndexOfBySourceRowIndex(JNIEnv* env, jclass,
-                                                                                        jlong native_ptr,
-                                                                                        jlong source_row_index)
-{
-    TR_ENTER_PTR(native_ptr)
-    try {
-        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        auto index = static_cast<size_t>(source_row_index);
-
-        return static_cast<jlong>(wrapper->m_results.index_of(index));
+        return static_cast<jlong>(wrapper->collection().index_of(RowExpr(*row)));
     }
     CATCH_STD()
     return npos;
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeDeleteLast(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_OsResults_nativeDeleteLast(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        auto row = wrapper->m_results.last();
+        auto row = wrapper->collection().last();
         if (row && row->is_attached()) {
             row->move_last_over();
             return JNI_TRUE;
@@ -386,13 +335,13 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeDeleteLast(JN
     return JNI_FALSE;
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeDeleteFirst(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_OsResults_nativeDeleteFirst(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
 
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        auto row = wrapper->m_results.first();
+        auto row = wrapper->collection().first();
         if (row && row->is_attached()) {
             row->move_last_over();
             return JNI_TRUE;
@@ -402,14 +351,14 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeDeleteFirst(J
     return JNI_FALSE;
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Collection_nativeDelete(JNIEnv* env, jclass, jlong native_ptr,
+JNIEXPORT void JNICALL Java_io_realm_internal_OsResults_nativeDelete(JNIEnv* env, jclass, jlong native_ptr,
                                                                       jlong index)
 {
     TR_ENTER_PTR(native_ptr)
 
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        auto row = wrapper->m_results.get(index);
+        auto row = wrapper->collection().get(index);
         if (row.is_attached()) {
             row.move_last_over();
         }
@@ -417,40 +366,40 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Collection_nativeDelete(JNIEnv* en
     CATCH_STD()
 }
 
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Collection_nativeIsValid(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_OsResults_nativeIsValid(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        return wrapper->m_results.is_valid();
+        return wrapper->collection().is_valid();
     }
     CATCH_STD()
     return JNI_FALSE;
 }
 
-JNIEXPORT jbyte JNICALL Java_io_realm_internal_Collection_nativeGetMode(JNIEnv* env, jclass, jlong native_ptr)
+JNIEXPORT jbyte JNICALL Java_io_realm_internal_OsResults_nativeGetMode(JNIEnv* env, jclass, jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
     try {
         auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
-        switch (wrapper->m_results.get_mode()) {
+        switch (wrapper->collection().get_mode()) {
             case Results::Mode::Empty:
-                return io_realm_internal_Collection_MODE_EMPTY;
+                return io_realm_internal_OsResults_MODE_EMPTY;
             case Results::Mode::Table:
-                return io_realm_internal_Collection_MODE_TABLE;
+                return io_realm_internal_OsResults_MODE_TABLE;
             case Results::Mode::Query:
-                return io_realm_internal_Collection_MODE_QUERY;
+                return io_realm_internal_OsResults_MODE_QUERY;
             case Results::Mode::LinkView:
-                return io_realm_internal_Collection_MODE_LINKVIEW;
+                return io_realm_internal_OsResults_MODE_LINKVIEW;
             case Results::Mode::TableView:
-                return io_realm_internal_Collection_MODE_TABLEVIEW;
+                return io_realm_internal_OsResults_MODE_TABLEVIEW;
         }
     }
     CATCH_STD()
     return -1; // Invalid mode value
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Collection_nativeCreateResultsFromBacklinks(JNIEnv *env, jclass,
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeCreateResultsFromBacklinks(JNIEnv *env, jclass,
                                                                                            jlong shared_realm_ptr,
                                                                                            jlong row_ptr,
                                                                                            jlong src_table_ptr,
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_LinkView.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_LinkView.cpp
deleted file mode 100644
index 4ad4066411..0000000000
--- a/realm/realm-library/src/main/cpp/io_realm_internal_LinkView.cpp
+++ /dev/null
@@ -1,270 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "io_realm_internal_LinkView.h"
-#include "util.hpp"
-
-using namespace realm;
-
-static void finalize_link_view(jlong ptr);
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetRow(JNIEnv* env, jobject, jlong nativeLinkViewPtr,
-                                                                     jlong pos)
-{
-    TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkViewRef* lv = LV(nativeLinkViewPtr);
-    if (!ROW_INDEX_VALID(env, *lv, pos)) {
-        return -1;
-    }
-    try {
-        LinkViewRef lvr = *lv;
-        Row* row = new Row((*lvr)[S(pos)]);
-        return reinterpret_cast<jlong>(row);
-    }
-    CATCH_STD()
-    return 0;
-}
-
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetRowIndex(JNIEnv* env, jobject,
-                                                                                jlong nativeLinkViewPtr,
-                                                                                jlong linkViewIndex)
-{
-    TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkViewRef* lv = LV(nativeLinkViewPtr);
-    if (!ROW_INDEX_VALID(env, *lv, linkViewIndex)) {
-        return -1;
-    }
-    try {
-        LinkViewRef lvr = *lv;
-        return lvr->get(S(linkViewIndex)).get_index();
-    }
-    CATCH_STD()
-    return 0;
-}
-
-
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeAdd(JNIEnv* env, jclass, jlong nativeLinkViewPtr,
-                                                                 jlong rowIndex)
-{
-    TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkViewRef* lv = LV(nativeLinkViewPtr);
-    try {
-        LinkViewRef lvr = *lv;
-        lvr->add(S(rowIndex));
-    }
-    CATCH_STD()
-}
-
-
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeInsert(JNIEnv* env, jobject, jlong nativeLinkViewPtr,
-                                                                    jlong pos, jlong rowIndex)
-{
-    TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkViewRef* lv = LV(nativeLinkViewPtr);
-    try {
-        LinkViewRef lvr = *lv;
-        lvr->insert(S(pos), S(rowIndex));
-    }
-    CATCH_STD()
-}
-
-
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeSet(JNIEnv* env, jobject, jlong nativeLinkViewPtr,
-                                                                 jlong pos, jlong rowIndex)
-{
-    TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkViewRef* lv = LV(nativeLinkViewPtr);
-    if (!ROW_INDEX_VALID(env, *lv, pos)) {
-        return;
-    }
-    try {
-        LinkViewRef lvr = *lv;
-        lvr->set(S(pos), S(rowIndex));
-    }
-    CATCH_STD()
-}
-
-
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeMove(JNIEnv* env, jobject, jlong nativeLinkViewPtr,
-                                                                  jlong old_pos, jlong new_pos)
-{
-    TR_ENTER_PTR(nativeLinkViewPtr)
-    try {
-        LinkViewRef* lv = LV(nativeLinkViewPtr);
-        LinkViewRef lvr = *lv;
-        size_t size = lvr->size();
-        if (old_pos < 0 || new_pos < 0 || size_t(old_pos) >= size || size_t(new_pos) >= size) {
-            ThrowException(env, IndexOutOfBounds, "Indices must be within range [0, " + num_to_string(size) + "[. " +
-                                                      "Yours were (" + num_to_string(old_pos) + "," +
-                                                      num_to_string(new_pos) + ")");
-            return;
-        }
-        lvr->move(S(old_pos), S(new_pos));
-    }
-    CATCH_STD()
-}
-
-
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemove(JNIEnv* env, jobject, jlong nativeLinkViewPtr,
-                                                                    jlong pos)
-{
-    TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkViewRef* lv = LV(nativeLinkViewPtr);
-    if (!ROW_INDEX_VALID(env, *lv, pos)) {
-        return;
-    }
-    try {
-        LinkViewRef lvr = *lv;
-        return lvr->remove(S(pos));
-    }
-    CATCH_STD()
-}
-
-
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeClear(JNIEnv* env, jclass, jlong nativeLinkViewPtr)
-{
-    TR_ENTER_PTR(nativeLinkViewPtr)
-    try {
-        LinkViewRef* lv = LV(nativeLinkViewPtr);
-        LinkViewRef lvr = *lv;
-        return lvr->clear();
-    }
-    CATCH_STD()
-}
-
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeSize(JNIEnv* env, jobject, jlong nativeLinkViewPtr)
-{
-
-    TR_ENTER_PTR(nativeLinkViewPtr)
-    try {
-        LinkViewRef* lv = LV(nativeLinkViewPtr);
-        LinkViewRef lvr = *lv;
-        return static_cast<jlong>(lvr->size());
-    }
-    CATCH_STD()
-    return 0;
-}
-
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsEmpty(JNIEnv* env, jobject,
-                                                                         jlong nativeLinkViewPtr)
-{
-    TR_ENTER_PTR(nativeLinkViewPtr)
-    try {
-        LinkViewRef* lv = LV(nativeLinkViewPtr);
-        LinkViewRef lvr = *lv;
-        return to_jbool(lvr->is_empty());
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeWhere(JNIEnv* env, jobject, jlong nativeLinkViewPtr)
-{
-    TR_ENTER_PTR(nativeLinkViewPtr)
-    try {
-        LinkViewRef* lv = LV(nativeLinkViewPtr);
-        LinkViewRef lvr = *lv;
-        Query* queryPtr = new Query(lvr->get_target_table().where(LinkViewRef(lvr)));
-        return reinterpret_cast<jlong>(queryPtr);
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_LinkView_nativeIsAttached(JNIEnv* env, jobject,
-                                                                            jlong nativeLinkViewPtr)
-{
-    TR_ENTER_PTR(nativeLinkViewPtr)
-    try {
-        LinkViewRef* lv = LV(nativeLinkViewPtr);
-        LinkViewRef lvr = *lv;
-        return to_jbool(lvr->is_attached());
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeFind(JNIEnv* env, jobject, jlong nativeLinkViewPtr,
-                                                                   jlong targetRowIndex)
-{
-    TR_ENTER_PTR(nativeLinkViewPtr)
-    try {
-        LinkViewRef* lv = LV(nativeLinkViewPtr);
-        LinkViewRef lvr = *lv;
-        if (!ROW_INDEX_VALID(env, &lvr->get_target_table(), targetRowIndex)) {
-            return -1;
-        }
-        size_t ndx = lvr->find(static_cast<size_t>(targetRowIndex));
-        return to_jlong_or_not_found(ndx);
-    }
-    CATCH_STD()
-    return -1;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveAllTargetRows(JNIEnv* env, jobject,
-                                                                                 jlong nativeLinkViewPtr)
-{
-    TR_ENTER_PTR(nativeLinkViewPtr)
-    try {
-        LinkViewRef* lv = LV(nativeLinkViewPtr);
-        LinkViewRef lvr = *lv;
-        lvr->remove_all_target_rows();
-    }
-    CATCH_STD()
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetTargetTable(JNIEnv*, jobject,
-                                                                             jlong nativeLinkViewPtr)
-{
-    TR_ENTER_PTR(nativeLinkViewPtr)
-
-    LinkViewRef* lv = LV(nativeLinkViewPtr);
-    LinkViewRef lvr = *lv;
-    Table* pTable = &(lvr->get_target_table());
-    LangBindHelper::bind_table_ptr(pTable);
-
-    return reinterpret_cast<jlong>(pTable);
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_LinkView_nativeRemoveTargetRow(JNIEnv* env, jobject,
-                                                                             jlong nativeLinkViewPtr, jlong pos)
-{
-    TR_ENTER_PTR(nativeLinkViewPtr)
-    LinkViewRef* lv = LV(nativeLinkViewPtr);
-    if (!ROW_INDEX_VALID(env, *lv, pos)) {
-        return;
-    }
-    try {
-        LinkViewRef lvr = *lv;
-        return lvr->remove_target_row(S(pos));
-    }
-    CATCH_STD()
-}
-
-static void finalize_link_view(jlong ptr)
-{
-    TR_ENTER_PTR(ptr)
-    LangBindHelper::unbind_linklist_ptr(*LV(ptr));
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_LinkView_nativeGetFinalizerPtr(JNIEnv*, jclass)
-{
-    TR_ENTER()
-    return reinterpret_cast<jlong>(&finalize_link_view);
-}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_CollectionChangeSet.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsCollectionChangeSet.cpp
similarity index 78%
rename from realm/realm-library/src/main/cpp/io_realm_internal_CollectionChangeSet.cpp
rename to realm/realm-library/src/main/cpp/io_realm_internal_OsCollectionChangeSet.cpp
index f85fb853af..807ce9afa2 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_CollectionChangeSet.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsCollectionChangeSet.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#include "io_realm_internal_CollectionChangeSet.h"
+#include "io_realm_internal_OsCollectionChangeSet.h"
 
 #include <collection_notifications.hpp>
 
@@ -44,11 +44,11 @@ static jintArray index_set_to_jint_array(JNIEnv* env, const IndexSet& index_set)
         ranges_vector.push_back(changes.second - changes.first);
     }
 
-    if (ranges_vector.size() > io_realm_internal_CollectionChangeSet_MAX_ARRAY_LENGTH) {
+    if (ranges_vector.size() > io_realm_internal_OsCollectionChangeSet_MAX_ARRAY_LENGTH) {
         std::ostringstream error_msg;
         error_msg << "There are too many ranges changed in this change set. They cannot fit into an array."
                   << " ranges_vector's size: " << ranges_vector.size()
-                  << " Java array's max size: " << io_realm_internal_CollectionChangeSet_MAX_ARRAY_LENGTH << ".";
+                  << " Java array's max size: " << io_realm_internal_OsCollectionChangeSet_MAX_ARRAY_LENGTH << ".";
         ThrowException(env, IllegalState, error_msg.str());
         return nullptr;
     }
@@ -67,11 +67,11 @@ static jintArray index_set_to_indices_array(JNIEnv* env, const IndexSet& index_s
     for (auto index : index_set.as_indexes()) {
         indices_vector.push_back(index);
     }
-    if (indices_vector.size() > io_realm_internal_CollectionChangeSet_MAX_ARRAY_LENGTH) {
+    if (indices_vector.size() > io_realm_internal_OsCollectionChangeSet_MAX_ARRAY_LENGTH) {
         std::ostringstream error_msg;
         error_msg << "There are too many indices in this change set. They cannot fit into an array."
                   << " indices_vector's size: " << indices_vector.size()
-                  << " Java array's max size: " << io_realm_internal_CollectionChangeSet_MAX_ARRAY_LENGTH << ".";
+                  << " Java array's max size: " << io_realm_internal_OsCollectionChangeSet_MAX_ARRAY_LENGTH << ".";
         ThrowException(env, IllegalState, error_msg.str());
         return nullptr;
     }
@@ -80,42 +80,42 @@ static jintArray index_set_to_indices_array(JNIEnv* env, const IndexSet& index_s
     return jint_array;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_CollectionChangeSet_nativeGetFinalizerPtr(JNIEnv*, jclass)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsCollectionChangeSet_nativeGetFinalizerPtr(JNIEnv*, jclass)
 {
     TR_ENTER()
     return reinterpret_cast<jlong>(&finalize_changeset);
 }
 
-JNIEXPORT jintArray JNICALL Java_io_realm_internal_CollectionChangeSet_nativeGetRanges(JNIEnv* env, jclass,
+JNIEXPORT jintArray JNICALL Java_io_realm_internal_OsCollectionChangeSet_nativeGetRanges(JNIEnv* env, jclass,
                                                                                        jlong native_ptr, jint type)
 {
     TR_ENTER_PTR(native_ptr)
     // no throws
     auto& change_set = *reinterpret_cast<CollectionChangeSet*>(native_ptr);
     switch (type) {
-        case io_realm_internal_CollectionChangeSet_TYPE_DELETION:
+        case io_realm_internal_OsCollectionChangeSet_TYPE_DELETION:
             return index_set_to_jint_array(env, change_set.deletions);
-        case io_realm_internal_CollectionChangeSet_TYPE_INSERTION:
+        case io_realm_internal_OsCollectionChangeSet_TYPE_INSERTION:
             return index_set_to_jint_array(env, change_set.insertions);
-        case io_realm_internal_CollectionChangeSet_TYPE_MODIFICATION:
+        case io_realm_internal_OsCollectionChangeSet_TYPE_MODIFICATION:
             return index_set_to_jint_array(env, change_set.modifications_new);
         default:
             REALM_UNREACHABLE();
     }
 }
 
-JNIEXPORT jintArray JNICALL Java_io_realm_internal_CollectionChangeSet_nativeGetIndices(JNIEnv* env, jclass,
+JNIEXPORT jintArray JNICALL Java_io_realm_internal_OsCollectionChangeSet_nativeGetIndices(JNIEnv* env, jclass,
                                                                                         jlong native_ptr, jint type)
 {
     TR_ENTER_PTR(native_ptr)
     // no throws
     auto& change_set = *reinterpret_cast<CollectionChangeSet*>(native_ptr);
     switch (type) {
-        case io_realm_internal_CollectionChangeSet_TYPE_DELETION:
+        case io_realm_internal_OsCollectionChangeSet_TYPE_DELETION:
             return index_set_to_indices_array(env, change_set.deletions);
-        case io_realm_internal_CollectionChangeSet_TYPE_INSERTION:
+        case io_realm_internal_OsCollectionChangeSet_TYPE_INSERTION:
             return index_set_to_indices_array(env, change_set.insertions);
-        case io_realm_internal_CollectionChangeSet_TYPE_MODIFICATION:
+        case io_realm_internal_OsCollectionChangeSet_TYPE_MODIFICATION:
             return index_set_to_indices_array(env, change_set.modifications_new);
         default:
             REALM_UNREACHABLE();
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsList.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsList.cpp
new file mode 100644
index 0000000000..ccee1c9720
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsList.cpp
@@ -0,0 +1,551 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "io_realm_internal_OsList.h"
+
+#include <list.hpp>
+#include <results.hpp>
+#include <shared_realm.hpp>
+
+#include "observable_collection_wrapper.hpp"
+#include "java_accessor.hpp"
+#include "java_exception_def.hpp"
+#include "jni_util/java_exception_thrower.hpp"
+#include "util.hpp"
+
+using namespace realm;
+using namespace realm::util;
+using namespace realm::_impl;
+
+typedef ObservableCollectionWrapper<List> ListWrapper;
+
+namespace {
+void finalize_list(jlong ptr)
+{
+    TR_ENTER_PTR(ptr)
+    delete reinterpret_cast<ListWrapper*>(ptr);
+}
+
+inline void add_value(JNIEnv* env, jlong list_ptr, Any&& value)
+{
+    auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+
+    JavaAccessorContext context(env);
+    wrapper.collection().add(context, value);
+}
+
+inline void insert_value(JNIEnv* env, jlong list_ptr, jlong pos, Any&& value)
+{
+    auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+
+    JavaAccessorContext context(env);
+    wrapper.collection().insert(context, pos, value);
+}
+
+inline void set_value(JNIEnv* env, jlong list_ptr, jlong pos, Any&& value)
+{
+    auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+
+    JavaAccessorContext context(env);
+    wrapper.collection().set(context, pos, value);
+}
+
+// Check nullable earlier https://github.com/realm/realm-object-store/issues/544
+inline void check_nullable(JNIEnv* env, jlong list_ptr, jobject jobject_ptr = nullptr)
+{
+    auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+    if (!jobject_ptr && !is_nullable(wrapper.collection().get_type())) {
+        THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalArgument,
+                             "This 'RealmList' is not nullable. A non-null value is expected.");
+    }
+}
+} // anonymous namespace
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsList_nativeGetFinalizerPtr(JNIEnv*, jclass)
+{
+    TR_ENTER()
+    return reinterpret_cast<jlong>(&finalize_list);
+}
+
+JNIEXPORT jlongArray JNICALL Java_io_realm_internal_OsList_nativeCreate(JNIEnv* env, jclass, jlong shared_realm_ptr,
+                                                                        jlong row_ptr, jlong column_index)
+{
+    TR_ENTER_PTR(row_ptr)
+
+    try {
+        auto& row = *reinterpret_cast<realm::Row*>(row_ptr);
+
+        if (!ROW_AND_COL_INDEX_VALID(env, &row, column_index)) {
+            return 0;
+        }
+
+        auto& shared_realm = *reinterpret_cast<SharedRealm*>(shared_realm_ptr);
+        jlong ret[2];
+
+        List list(shared_realm, *row.get_table(), column_index, row.get_index());
+        ListWrapper* wrapper_ptr = new ListWrapper(list);
+        ret[0] = reinterpret_cast<jlong>(wrapper_ptr);
+
+        if (wrapper_ptr->collection().get_type() == PropertyType::Object) {
+            LinkViewRef link_view_ref(row.get_linklist(column_index));
+
+            Table* target_table_ptr = &(link_view_ref)->get_target_table();
+            LangBindHelper::bind_table_ptr(target_table_ptr);
+            ret[1] = reinterpret_cast<jlong>(target_table_ptr);
+        }
+        else {
+            ret[1] = reinterpret_cast<jlong>(nullptr);
+        }
+
+        jlongArray ret_array = env->NewLongArray(2);
+        if (!ret_array) {
+            ThrowException(env, OutOfMemory, "Could not allocate memory to create OsList.");
+            return nullptr;
+        }
+        env->SetLongArrayRegion(ret_array, 0, 2, ret);
+        return ret_array;
+    }
+    CATCH_STD()
+    return nullptr;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsList_nativeGetRow(JNIEnv* env, jclass, jlong list_ptr,
+                                                                   jlong column_index)
+{
+    TR_ENTER_PTR(list_ptr)
+
+    try {
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        auto row = wrapper.collection().get(column_index);
+        return reinterpret_cast<jlong>(new Row(std::move(row)));
+    }
+    CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeAddRow(JNIEnv* env, jclass, jlong list_ptr,
+                                                                  jlong target_row_index)
+{
+    TR_ENTER_PTR(list_ptr)
+
+    try {
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        wrapper.collection().add(static_cast<size_t>(target_row_index));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeInsertRow(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                     jlong target_row_index)
+{
+    TR_ENTER_PTR(list_ptr)
+
+    try {
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        wrapper.collection().insert(static_cast<size_t>(pos), static_cast<size_t>(target_row_index));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeSetRow(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                  jlong target_row_index)
+{
+    TR_ENTER_PTR(list_ptr)
+
+    try {
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        wrapper.collection().set(static_cast<size_t>(pos), static_cast<size_t>(target_row_index));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeMove(JNIEnv* env, jclass, jlong list_ptr,
+                                                                jlong source_index, jlong target_index)
+{
+    TR_ENTER_PTR(list_ptr)
+
+    try {
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        wrapper.collection().move(source_index, target_index);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeRemove(JNIEnv* env, jclass, jlong list_ptr, jlong index)
+{
+    TR_ENTER_PTR(list_ptr)
+
+    try {
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        wrapper.collection().remove(index);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeRemoveAll(JNIEnv* env, jclass, jlong list_ptr)
+{
+    TR_ENTER_PTR(list_ptr)
+
+    try {
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        wrapper.collection().remove_all();
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsList_nativeSize(JNIEnv* env, jclass, jlong list_ptr)
+{
+    TR_ENTER_PTR(list_ptr)
+
+    try {
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        return wrapper.collection().size();
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsList_nativeGetQuery(JNIEnv* env, jclass, jlong list_ptr)
+{
+    TR_ENTER_PTR(list_ptr)
+
+    try {
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        auto query = wrapper.collection().get_query();
+        return reinterpret_cast<jlong>(new Query(std::move(query)));
+    }
+    CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
+}
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_OsList_nativeIsValid(JNIEnv* env, jclass, jlong list_ptr)
+{
+    TR_ENTER_PTR(list_ptr)
+
+    try {
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        return wrapper.collection().is_valid();
+    }
+    CATCH_STD()
+    return JNI_FALSE;
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeDelete(JNIEnv* env, jclass, jlong list_ptr, jlong index)
+{
+    TR_ENTER_PTR(list_ptr)
+
+    try {
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        wrapper.collection().delete_at(S(index));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeDeleteAll(JNIEnv* env, jclass, jlong list_ptr)
+{
+    TR_ENTER_PTR(list_ptr)
+
+    try {
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        wrapper.collection().delete_all();
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeStartListening(JNIEnv* env, jobject instance,
+                                                                              jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    try {
+        auto wrapper = reinterpret_cast<ListWrapper*>(native_ptr);
+        wrapper->start_listening(env, instance);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeStopListening(JNIEnv* env, jobject, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    try {
+        auto wrapper = reinterpret_cast<ListWrapper*>(native_ptr);
+        wrapper->stop_listening();
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeAddNull(JNIEnv* env, jclass, jlong list_ptr)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        check_nullable(env, list_ptr);
+        add_value(env, list_ptr, Any());
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeInsertNull(JNIEnv* env, jclass, jlong list_ptr, jlong pos)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        check_nullable(env, list_ptr);
+        insert_value(env, list_ptr, pos, Any());
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeSetNull(JNIEnv* env, jclass, jlong list_ptr, jlong pos)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        check_nullable(env, list_ptr);
+        set_value(env, list_ptr, pos, Any());
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeAddLong(JNIEnv* env, jclass, jlong list_ptr, jlong value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        add_value(env, list_ptr, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeInsertLong(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                      jlong value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        insert_value(env, list_ptr, pos, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeSetLong(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                   jlong value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        set_value(env, list_ptr, pos, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeAddDouble(JNIEnv* env, jclass, jlong list_ptr,
+                                                                     jdouble value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        add_value(env, list_ptr, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeInsertDouble(JNIEnv* env, jclass, jlong list_ptr,
+                                                                        jlong pos, jdouble value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        insert_value(env, list_ptr, pos, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeSetDouble(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                     jdouble value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        set_value(env, list_ptr, pos, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeAddFloat(JNIEnv* env, jclass, jlong list_ptr, jfloat value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        add_value(env, list_ptr, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeInsertFloat(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                       jfloat value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        insert_value(env, list_ptr, pos, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeSetFloat(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                    jfloat value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        set_value(env, list_ptr, pos, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeAddBoolean(JNIEnv* env, jclass, jlong list_ptr,
+                                                                      jboolean value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        add_value(env, list_ptr, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeInsertBoolean(JNIEnv* env, jclass, jlong list_ptr,
+                                                                         jlong pos, jboolean value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        insert_value(env, list_ptr, pos, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeSetBoolean(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                      jboolean value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        set_value(env, list_ptr, pos, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeAddBinary(JNIEnv* env, jclass, jlong list_ptr,
+                                                                     jbyteArray value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        check_nullable(env, list_ptr, value);
+        JByteArrayAccessor accessor(env, value);
+        add_value(env, list_ptr, Any(accessor));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeInsertBinary(JNIEnv* env, jclass, jlong list_ptr,
+                                                                        jlong pos, jbyteArray value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        check_nullable(env, list_ptr, value);
+        JByteArrayAccessor accessor(env, value);
+        insert_value(env, list_ptr, pos, Any(accessor));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeSetBinary(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                     jbyteArray value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        check_nullable(env, list_ptr, value);
+        JByteArrayAccessor accessor(env, value);
+        set_value(env, list_ptr, pos, Any(accessor));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeAddDate(JNIEnv* env, jclass, jlong list_ptr, jlong value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        add_value(env, list_ptr, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeInsertDate(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                      jlong value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        insert_value(env, list_ptr, pos, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeSetDate(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                   jlong value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        set_value(env, list_ptr, pos, Any(value));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeAddString(JNIEnv* env, jclass, jlong list_ptr,
+                                                                     jstring value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        check_nullable(env, list_ptr, value);
+        JStringAccessor accessor(env, value);
+        add_value(env, list_ptr, Any(accessor));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeInsertString(JNIEnv* env, jclass, jlong list_ptr,
+                                                                        jlong pos, jstring value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        check_nullable(env, list_ptr, value);
+        JStringAccessor accessor(env, value);
+        insert_value(env, list_ptr, pos, Any(accessor));
+    }
+    CATCH_STD();
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsList_nativeSetString(JNIEnv* env, jclass, jlong list_ptr, jlong pos,
+                                                                     jstring value)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        check_nullable(env, list_ptr, value);
+        JStringAccessor accessor(env, value);
+        set_value(env, list_ptr, pos, Any(accessor));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT jobject JNICALL Java_io_realm_internal_OsList_nativeGetValue(JNIEnv* env, jclass, jlong list_ptr, jlong pos)
+{
+    TR_ENTER_PTR(list_ptr)
+    try {
+        auto& wrapper = *reinterpret_cast<ListWrapper*>(list_ptr);
+        JavaAccessorContext context(env);
+        return any_cast<jobject>(wrapper.collection().get(context, pos));
+    }
+    CATCH_STD()
+
+    return nullptr;
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
index 62887708c9..3099c70d56 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
@@ -17,16 +17,28 @@
 #include "io_realm_internal_OsObject.h"
 
 #include <realm/row.hpp>
+#if REALM_ENABLE_SYNC
+#include <realm/sync/object.hpp>
+#endif
 #include <object_schema.hpp>
 #include <object.hpp>
+#include <shared_realm.hpp>
+#include <util/format.hpp>
 
 #include "util.hpp"
+#include "java_class_global_def.hpp"
 
 #include "jni_util/java_global_weak_ref.hpp"
 #include "jni_util/java_method.hpp"
+#include "jni_util/java_class.hpp"
+#include "jni_util/java_exception_thrower.hpp"
 
 using namespace realm;
 using namespace realm::jni_util;
+using namespace realm::_impl;
+
+static const char* PK_CONSTRAINT_EXCEPTION_CLASS = "io/realm/exceptions/RealmPrimaryKeyConstraintException";
+static const char* PK_EXCEPTION_MSG_FORMAT = "Primary key value already exists: %1 .";
 
 // We need to control the life cycle of Object, weak ref of Java OsObject and the NotificationToken.
 // Wrap all three together, so when the Java object gets GCed, all three of them will be invalidated.
@@ -54,8 +66,9 @@ struct ObjectWrapper {
 };
 
 struct ChangeCallback {
-    ChangeCallback(ObjectWrapper* wrapper)
-        : m_wrapper(wrapper)
+    ChangeCallback(ObjectWrapper* wrapper, JavaMethod notify_change_listeners)
+        : m_wrapper(wrapper),
+        m_notify_change_listeners_method(notify_change_listeners)
     {
     }
 
@@ -81,7 +94,7 @@ struct ChangeCallback {
             // wrapper->m_object.get_object_schema() will be faster.
             field_names.push_back(JavaGlobalRef(env, to_jstring(env, table->get_column_name(i)), true));
         }
-        m_field_names_array = env->NewObjectArray(field_names.size(), java_lang_string, 0);
+        m_field_names_array = env->NewObjectArray(field_names.size(), JavaClassGlobalDef::java_lang_string(), 0);
         for (size_t i = 0; i < field_names.size(); ++i) {
             env->SetObjectArrayElement(m_field_names_array, i, field_names[i].get());
         }
@@ -118,11 +131,8 @@ struct ChangeCallback {
         }
 
         parse_fields(env, change_set);
-
         m_wrapper->m_row_object_weak_ref.call_with_local_ref(env, [&](JNIEnv*, jobject row_obj) {
-            static JavaMethod notify_change_listeners(env, row_obj, "notifyChangeListeners",
-                                                      "([Ljava/lang/String;)V");
-            env->CallVoidMethod(row_obj, notify_change_listeners, m_deleted ? nullptr : m_field_names_array);
+            env->CallVoidMethod(row_obj, m_notify_change_listeners_method, m_deleted ? nullptr : m_field_names_array);
         });
         m_field_names_array = nullptr;
         m_deleted = false;
@@ -144,6 +154,7 @@ struct ChangeCallback {
     ObjectWrapper* m_wrapper;
     bool m_deleted = false;
     jobjectArray m_field_names_array = nullptr;
+    JavaMethod m_notify_change_listeners_method;
 };
 
 static void finalize_object(jlong ptr)
@@ -152,6 +163,101 @@ static void finalize_object(jlong ptr)
     delete reinterpret_cast<ObjectWrapper*>(ptr);
 }
 
+static inline size_t do_create_row(jlong shared_realm_ptr, jlong table_ptr)
+{
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& table = *(reinterpret_cast<realm::Table*>(table_ptr));
+    shared_realm->verify_in_write();
+#if REALM_ENABLE_SYNC
+    return sync::create_object(shared_realm->read_group(), table);
+#else
+    return table.add_empty_row();
+#endif
+}
+
+static inline size_t do_create_row_with_primary_key(JNIEnv* env, jlong shared_realm_ptr, jlong table_ptr,
+                                                    jlong pk_column_ndx, jlong pk_value, jboolean is_pk_null)
+{
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& table = *(reinterpret_cast<realm::Table*>(table_ptr));
+    shared_realm->verify_in_write(); // throws
+    if (is_pk_null && !TBL_AND_COL_NULLABLE(env, &table, pk_column_ndx)) {
+        return realm::npos;
+    }
+
+    if (is_pk_null) {
+        if (table.find_first_null(pk_column_ndx) != npos) {
+            THROW_JAVA_EXCEPTION(env, PK_CONSTRAINT_EXCEPTION_CLASS, format(PK_EXCEPTION_MSG_FORMAT, "'null'"));
+        }
+    }
+    else {
+        if (table.find_first_int(pk_column_ndx, pk_value) != npos) {
+            THROW_JAVA_EXCEPTION(env, PK_CONSTRAINT_EXCEPTION_CLASS,
+                                 format(PK_EXCEPTION_MSG_FORMAT, reinterpret_cast<long long>(pk_value)));
+        }
+    }
+
+    size_t row_ndx;
+#if REALM_ENABLE_SYNC
+    if (is_pk_null) {
+        row_ndx = sync::create_object_with_primary_key(shared_realm->read_group(), table, util::none);
+    }
+    else {
+        row_ndx = sync::create_object_with_primary_key(shared_realm->read_group(), table,
+                                                       util::Optional<int64_t>(pk_value));
+    }
+#else
+    row_ndx = table.add_empty_row();
+
+    if (is_pk_null) {
+        table.set_null_unique(pk_column_ndx, row_ndx);
+    }
+    else {
+        table.set_int_unique(pk_column_ndx, row_ndx, pk_value);
+    }
+#endif
+    return row_ndx;
+}
+
+static inline size_t do_create_row_with_primary_key(JNIEnv* env, jlong shared_realm_ptr, jlong table_ptr,
+                                                    jlong pk_column_ndx, jstring pk_value)
+{
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& table = *(reinterpret_cast<realm::Table*>(table_ptr));
+    shared_realm->verify_in_write(); // throws
+    JStringAccessor str_accessor(env, pk_value); // throws
+    if (!pk_value && !TBL_AND_COL_NULLABLE(env, &table, pk_column_ndx)) {
+        return realm::npos;
+    }
+
+    if (pk_value) {
+        if (table.find_first_string(pk_column_ndx, str_accessor) != npos) {
+            THROW_JAVA_EXCEPTION(env, PK_CONSTRAINT_EXCEPTION_CLASS,
+                                 format(PK_EXCEPTION_MSG_FORMAT, str_accessor.operator std::string()));
+        }
+    }
+    else {
+        if (table.find_first_null(pk_column_ndx) != npos) {
+            THROW_JAVA_EXCEPTION(env, PK_CONSTRAINT_EXCEPTION_CLASS, format(PK_EXCEPTION_MSG_FORMAT, "'null'"));
+        }
+    }
+
+    size_t row_ndx;
+#if REALM_ENABLE_SYNC
+    row_ndx = sync::create_object_with_primary_key(shared_realm->read_group(), table, str_accessor);
+#else
+    row_ndx = table.add_empty_row();
+    if (pk_value) {
+        table.set_string_unique(pk_column_ndx, row_ndx, str_accessor);
+    }
+    else {
+        table.set_string_unique(pk_column_ndx, row_ndx, null{});
+    }
+#endif
+
+    return row_ndx;
+}
+
 JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObject_nativeGetFinalizerPtr(JNIEnv*, jclass)
 {
     TR_ENTER()
@@ -159,7 +265,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObject_nativeGetFinalizerPtr(JN
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObject_nativeCreate(JNIEnv*, jclass, jlong shared_realm_ptr,
-                                                                      jlong row_ptr)
+                                                                     jlong row_ptr)
 {
     TR_ENTER_PTR(row_ptr)
 
@@ -176,7 +282,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObject_nativeCreate(JNIEnv*, jc
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_OsObject_nativeStartListening(JNIEnv* env, jobject instance,
-                                                                             jlong native_ptr)
+                                                                            jlong native_ptr)
 {
     TR_ENTER_PTR(native_ptr)
 
@@ -186,10 +292,13 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsObject_nativeStartListening(JNIE
             wrapper->m_row_object_weak_ref = JavaGlobalWeakRef(env, instance);
         }
 
+        static JavaClass os_object_class(env, "io/realm/internal/OsObject");
+        static JavaMethod notify_change_listeners(env, os_object_class, "notifyChangeListeners",
+                                                  "([Ljava/lang/String;)V");
         // The wrapper pointer will be used in the callback. But it should never become an invalid pointer when the
         // notification block gets called. This should be guaranteed by the Object Store that after the notification
         // token is destroyed, the block shouldn't be called.
-        wrapper->m_notification_token = wrapper->m_object.add_notification_callback(ChangeCallback(wrapper));
+        wrapper->m_notification_token = wrapper->m_object.add_notification_callback(ChangeCallback(wrapper, notify_change_listeners));
     }
     CATCH_STD()
 }
@@ -204,3 +313,89 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsObject_nativeStopListening(JNIEn
     }
     CATCH_STD()
 }
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObject_nativeCreateRow(JNIEnv* env, jclass, jlong shared_realm_ptr,
+                                                                        jlong table_ptr)
+{
+    try {
+        return do_create_row(shared_realm_ptr, table_ptr);
+    }
+    CATCH_STD()
+    return -1;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObject_nativeCreateNewObject(JNIEnv* env, jclass,
+                                                                              jlong shared_realm_ptr, jlong table_ptr)
+{
+    try {
+        size_t row_ndx = do_create_row(shared_realm_ptr, table_ptr);
+        auto& table = *(reinterpret_cast<realm::Table*>(table_ptr));
+        return reinterpret_cast<jlong>(new Row(table[row_ndx]));
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObject_nativeCreateNewObjectWithLongPrimaryKey(
+    JNIEnv* env, jclass, jlong shared_realm_ptr, jlong table_ptr, jlong pk_column_ndx, jlong pk_value,
+    jboolean is_pk_null)
+{
+    try {
+        auto& table = *(reinterpret_cast<realm::Table*>(table_ptr));
+        size_t row_ndx =
+            do_create_row_with_primary_key(env, shared_realm_ptr, table_ptr, pk_column_ndx, pk_value, is_pk_null);
+        if (row_ndx != realm::npos) {
+            return reinterpret_cast<jlong>(new Row(table[row_ndx]));
+        }
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObject_nativeCreateRowWithLongPrimaryKey(
+    JNIEnv* env, jclass, jlong shared_realm_ptr, jlong table_ptr, jlong pk_column_ndx, jlong pk_value,
+    jboolean is_pk_null)
+{
+    try {
+        return do_create_row_with_primary_key(env, shared_realm_ptr, table_ptr, pk_column_ndx, pk_value, is_pk_null);
+    }
+    CATCH_STD()
+    return realm::npos;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObject_nativeCreateNewObjectWithStringPrimaryKey(
+    JNIEnv* env, jclass, jlong shared_realm_ptr, jlong table_ptr, jlong pk_column_ndx, jstring pk_value)
+{
+    try {
+        auto& table = *(reinterpret_cast<realm::Table*>(table_ptr));
+        size_t row_ndx = do_create_row_with_primary_key(env, shared_realm_ptr, table_ptr, pk_column_ndx, pk_value);
+        if (row_ndx != realm::npos) {
+            return reinterpret_cast<jlong>(new Row(table[row_ndx]));
+        }
+    }
+    CATCH_STD()
+
+    return 0;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObject_nativeCreateRowWithStringPrimaryKey(
+    JNIEnv* env, jclass, jlong shared_realm_ptr, jlong table_ptr, jlong pk_column_ndx, jstring pk_value)
+{
+    try {
+        return do_create_row_with_primary_key(env, shared_realm_ptr, table_ptr, pk_column_ndx, pk_value);
+    }
+    CATCH_STD()
+
+    return realm::npos;
+}
+
+JNIEXPORT jstring JNICALL Java_io_realm_internal_OsObject_nativeGetObjectIdColumName(JNIEnv* env, jclass)
+{
+// TODO: Remove the macro and get the name from core when core has stable ID support.
+#if REALM_ENABLE_SYNC
+    const char* object_id_column_name = sync::object_id_column_name;
+#else
+    const char* object_id_column_name = "!OID";
+#endif
+    return to_jstring(env, object_id_column_name);
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp
new file mode 100644
index 0000000000..b291ea3c28
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectSchemaInfo.cpp
@@ -0,0 +1,139 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "io_realm_internal_OsObjectSchemaInfo.h"
+
+#include <realm/util/assert.hpp>
+
+#include <object_schema.hpp>
+#include <property.hpp>
+
+#include "java_accessor.hpp"
+#include "java_exception_def.hpp"
+#include "jni_util/java_exception_thrower.hpp"
+#include "util.hpp"
+
+using namespace realm;
+using namespace realm::jni_util;
+using namespace realm::_impl;
+
+static void finalize_object_schema(jlong ptr)
+{
+    TR_ENTER_PTR(ptr);
+    delete reinterpret_cast<ObjectSchema*>(ptr);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeCreateRealmObjectSchema(JNIEnv* env, jclass,
+                                                                                                jstring j_name_str)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor name(env, j_name_str);
+        ObjectSchema* object_schema = new ObjectSchema();
+        object_schema->name = name;
+        return reinterpret_cast<jlong>(object_schema);
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeGetFinalizerPtr(JNIEnv*, jclass)
+{
+    TR_ENTER()
+    return reinterpret_cast<jlong>(&finalize_object_schema);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeAddProperties(JNIEnv* env, jclass,
+                                                                                     jlong native_ptr,
+                                                                                     jlongArray j_persisted_properties,
+                                                                                     jlongArray j_computed_properties)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        ObjectSchema& object_schema = *reinterpret_cast<ObjectSchema*>(native_ptr);
+        JLongArrayAccessor persisted_properties(env, j_persisted_properties);
+        for (jsize i = 0; i < persisted_properties.size(); ++i)
+        {
+            Property* prop = reinterpret_cast<Property*>(persisted_properties[i]);
+            REALM_ASSERT_DEBUG(prop != nullptr);
+            if (prop->is_primary) {
+                object_schema.primary_key = prop->name;
+            }
+            object_schema.persisted_properties.emplace_back(std::move(*prop));
+            delete prop;
+        }
+
+        JLongArrayAccessor computed_properties(env, j_computed_properties);
+        for (jsize i = 0; i < computed_properties.size(); ++i)
+        {
+            Property* prop = reinterpret_cast<Property*>(computed_properties[i]);
+            REALM_ASSERT_DEBUG(prop != nullptr);
+            object_schema.computed_properties.emplace_back(std::move(*prop));
+            delete prop;
+        }
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT jstring JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeGetClassName(JNIEnv* env, jclass,
+                                                                                       jlong nativePtr)
+{
+    TR_ENTER_PTR(nativePtr)
+    try {
+        ObjectSchema* object_schema = reinterpret_cast<ObjectSchema*>(nativePtr);
+        auto name = object_schema->name;
+        return to_jstring(env, name);
+    }
+    CATCH_STD()
+
+    return nullptr;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeGetProperty(JNIEnv* env, jclass,
+                                                                                    jlong native_ptr,
+                                                                                    jstring j_property_name)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        auto& object_schema = *reinterpret_cast<ObjectSchema*>(native_ptr);
+        JStringAccessor property_name_accessor(env, j_property_name);
+        StringData property_name(property_name_accessor);
+        auto* property = object_schema.property_for_name(property_name);
+        if (property) {
+            return reinterpret_cast<jlong>(new Property(*property));
+        }
+        THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalState,
+                             format("Property '%1' cannot be found.", property_name.data()));
+    }
+    CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObjectSchemaInfo_nativeGetPrimaryKeyProperty(JNIEnv* env, jclass,
+                                                                                              jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    try {
+        auto& object_schema = *reinterpret_cast<ObjectSchema*>(native_ptr);
+        auto* property = object_schema.primary_key_property();
+        if (property) {
+            return reinterpret_cast<jlong>(new Property(*property));
+        }
+    }
+    CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectStore.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectStore.cpp
new file mode 100644
index 0000000000..a3018f02d8
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsObjectStore.cpp
@@ -0,0 +1,164 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "io_realm_internal_OsObjectStore.h"
+
+#include <object_store.hpp>
+#include <shared_realm.hpp>
+
+#include "util.hpp"
+#include "jni_util/java_method.hpp"
+#include "jni_util/java_exception_thrower.hpp"
+#include "jni_util/java_exception_thrower.hpp"
+
+using namespace realm;
+using namespace realm::jni_util;
+using namespace realm::util;
+using namespace realm::_impl;
+
+// FIXME: Enable after https://github.com/realm/realm-object-store/pull/550 merged
+//static_assert(io_realm_internal_OsObjectStore_SCHEMA_NOT_VERSIONED == static_cast<jlong>(ObjectStore::NotVersioned),
+//              "");
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsObjectStore_nativeSetPrimaryKeyForObject(JNIEnv* env, jclass,
+                                                                                          jlong shared_realm_ptr,
+                                                                                          jstring j_class_name,
+                                                                                          jstring j_pk_field_name)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+    try {
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        JStringAccessor class_name_accessor(env, j_class_name);
+        JStringAccessor pk_field_name_accessor(env, j_pk_field_name);
+
+        auto table = ObjectStore::table_for_object_type(shared_realm->read_group(), class_name_accessor);
+        if (!table) {
+            THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalArgument,
+                                 format("Class '%1' doesn't exist.", StringData(class_name_accessor)));
+        }
+
+        if (j_pk_field_name) {
+            // Not removal, check the column.
+            auto pk_column_ndx = table->get_column_index(pk_field_name_accessor);
+            if (pk_column_ndx == realm::npos) {
+                THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalArgument,
+                                     format("Field '%1' doesn't exist in Class '%2'.",
+                                            StringData(pk_field_name_accessor), StringData(class_name_accessor)));
+            }
+
+            // Check valid column type
+            auto field_type = table->get_column_type(pk_column_ndx);
+            if (field_type != type_Int && field_type != type_String) {
+                THROW_JAVA_EXCEPTION(
+                    env, JavaExceptionDef::IllegalArgument,
+                    format("Field '%1' is not a valid primary key type.", StringData(pk_field_name_accessor)));
+            }
+
+            // Check duplicated values. The pk field must have been indexed before set as a PK.
+            if (table->get_distinct_view(pk_column_ndx).size() != table->size()) {
+                THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalArgument,
+                                     format("Field '%1' cannot be set as primary key since there are duplicated "
+                                            "values for field '%1' in Class '%2'.",
+                                            StringData(pk_field_name_accessor), StringData(class_name_accessor)));
+            }
+        }
+        shared_realm->verify_in_write();
+        ObjectStore::set_primary_key_for_object(shared_realm->read_group(), class_name_accessor,
+                                                pk_field_name_accessor);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT jstring JNICALL Java_io_realm_internal_OsObjectStore_nativeGetPrimaryKeyForObject(JNIEnv* env, jclass,
+                                                                                             jlong shared_realm_ptr,
+                                                                                             jstring j_class_name)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+    try {
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        JStringAccessor class_name_accessor(env, j_class_name);
+        StringData pk_field_name =
+            ObjectStore::get_primary_key_for_object(shared_realm->read_group(), class_name_accessor);
+        return pk_field_name.size() == 0 ? nullptr : to_jstring(env, pk_field_name);
+    }
+    CATCH_STD()
+    return nullptr;
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsObjectStore_nativeSetSchemaVersion(JNIEnv* env, jclass,
+                                                                                   jlong shared_realm_ptr,
+                                                                                   jlong schema_version)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+    try {
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        shared_realm->verify_in_write();
+        ObjectStore::set_schema_version(shared_realm->read_group(), schema_version);
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsObjectStore_nativeGetSchemaVersion(JNIEnv* env, jclass,
+                                                                                    jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+    try {
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        return ObjectStore::get_schema_version(shared_realm->read_group());
+    }
+    CATCH_STD()
+    return ObjectStore::NotVersioned;
+}
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_OsObjectStore_nativeDeleteTableForObject(JNIEnv* env, jclass,
+                                                                                        jlong shared_realm_ptr,
+                                                                                        jstring j_class_name)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+    try {
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        JStringAccessor class_name_accessor(env, j_class_name);
+        shared_realm->verify_in_write();
+        if (!ObjectStore::table_for_object_type(shared_realm->read_group(), class_name_accessor)) {
+            return JNI_FALSE;
+        }
+        ObjectStore::delete_data_for_object(shared_realm->read_group(), class_name_accessor);
+        return JNI_TRUE;
+    }
+    CATCH_STD()
+    return JNI_FALSE;
+}
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_OsObjectStore_nativeCallWithLock(JNIEnv* env, jclass,
+                                                                                   jstring j_realm_path,
+                                                                                   jobject j_runnable)
+{
+    TR_ENTER();
+    try {
+        JStringAccessor path_accessor(env, j_realm_path);
+        std::string realm_path(path_accessor);
+        static JavaClass runnable_class(env, "java/lang/Runnable");
+        static JavaMethod run_method(env, runnable_class, "run", "()V");
+        bool result = SharedGroup::call_with_lock(realm_path, [&](std::string path) {
+            REALM_ASSERT_RELEASE_EX(realm_path.compare(path) == 0, realm_path.c_str(), path.c_str());
+            env->CallVoidMethod(j_runnable, run_method);
+            TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(env, nullptr);
+        });
+        return result;
+    }
+    CATCH_STD()
+    return false;
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
new file mode 100644
index 0000000000..b07e992dc8
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
@@ -0,0 +1,366 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "io_realm_internal_OsRealmConfig.h"
+
+#include <shared_realm.hpp>
+#if REALM_ENABLE_SYNC
+#include <sync/sync_config.hpp>
+#include <sync/sync_manager.hpp>
+#include <sync/sync_session.hpp>
+#endif
+
+#include "java_accessor.hpp"
+#include "util.hpp"
+#include "jni_util/java_method.hpp"
+#include "jni_util/java_class.hpp"
+#include "jni_util/java_global_weak_ref.hpp"
+#include "jni_util/jni_utils.hpp"
+#include "jni_util/java_exception_thrower.hpp"
+
+using namespace realm;
+using namespace realm::jni_util;
+using namespace realm::_impl;
+
+static_assert(SchemaMode::Automatic ==
+                  static_cast<SchemaMode>(io_realm_internal_OsRealmConfig_SCHEMA_MODE_VALUE_AUTOMATIC),
+              "");
+static_assert(SchemaMode::Immutable==
+                  static_cast<SchemaMode>(io_realm_internal_OsRealmConfig_SCHEMA_MODE_VALUE_IMMUTABLE),
+              "");
+static_assert(SchemaMode::ReadOnlyAlternative ==
+                  static_cast<SchemaMode>(io_realm_internal_OsRealmConfig_SCHEMA_MODE_VALUE_READONLY),
+              "");
+static_assert(SchemaMode::ResetFile ==
+                  static_cast<SchemaMode>(io_realm_internal_OsRealmConfig_SCHEMA_MODE_VALUE_RESET_FILE),
+              "");
+static_assert(SchemaMode::Additive ==
+                  static_cast<SchemaMode>(io_realm_internal_OsRealmConfig_SCHEMA_MODE_VALUE_ADDITIVE),
+              "");
+static_assert(SchemaMode::Manual == static_cast<SchemaMode>(io_realm_internal_OsRealmConfig_SCHEMA_MODE_VALUE_MANUAL),
+              "");
+
+static void finalize_realm_config(jlong ptr)
+{
+    TR_ENTER_PTR(ptr)
+    delete reinterpret_cast<Realm::Config*>(ptr);
+}
+
+static JavaClass& get_shared_realm_class(JNIEnv* env)
+{
+    static JavaClass shared_realm_class(env, "io/realm/internal/SharedRealm");
+    return shared_realm_class;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsRealmConfig_nativeGetFinalizerPtr(JNIEnv*, jclass)
+{
+    TR_ENTER()
+    return reinterpret_cast<jlong>(&finalize_realm_config);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsRealmConfig_nativeCreate(JNIEnv* env, jclass, jstring j_realm_path,
+                                                                          jboolean enable_cache,
+                                                                          jboolean enable_format_upgrade)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor realm_path(env, j_realm_path);
+        auto* config_ptr = new Realm::Config();
+        config_ptr->path = realm_path;
+        config_ptr->cache = enable_cache;
+        config_ptr->disable_format_upgrade = !enable_format_upgrade;
+        return reinterpret_cast<jlong>(config_ptr);
+    }
+    CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetEncryptionKey(JNIEnv* env, jclass,
+                                                                                   jlong native_ptr,
+                                                                                   jbyteArray j_key_array)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        JByteArrayAccessor jarray_accessor(env, j_key_array);
+        auto& config = *reinterpret_cast<Realm::Config*>(native_ptr);
+        // Encryption key should be set before creating sync_config.
+        REALM_ASSERT(!config.sync_config);
+        config.encryption_key = jarray_accessor.transform<std::vector<char>>();
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetInMemory(JNIEnv*, jclass, jlong native_ptr,
+                                                                              jboolean in_mem)
+{
+    TR_ENTER_PTR(native_ptr)
+    auto& config = *reinterpret_cast<Realm::Config*>(native_ptr);
+    config.in_memory = in_mem; // no throw
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetSchemaConfig(JNIEnv* env, jobject j_config,
+                                                                                  jlong native_ptr, jbyte schema_mode,
+                                                                                  jlong schema_version,
+                                                                                  jlong schema_info_ptr,
+                                                                                  jobject j_migration_callback)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        auto& config = *reinterpret_cast<Realm::Config*>(native_ptr);
+        config.schema_mode = static_cast<SchemaMode>(schema_mode);
+        config.schema_version = schema_version;
+        if (schema_info_ptr) {
+            auto& schema = *reinterpret_cast<Schema*>(schema_info_ptr);
+            config.schema = schema;
+        }
+        else {
+            config.schema = none;
+        }
+
+        if (j_migration_callback) {
+            static JavaMethod run_migration_callback_method(
+                env, get_shared_realm_class(env), "runMigrationCallback",
+                "(JLio/realm/internal/OsRealmConfig;Lio/realm/internal/SharedRealm$MigrationCallback;J)V", true);
+            // weak ref to avoid leaks caused by circular refs.
+            JavaGlobalWeakRef j_config_weak(env, j_config);
+            JavaGlobalWeakRef j_migration_cb_weak(env, j_migration_callback);
+            // TODO: It would be great if we can use move constructor in the lambda capture which was introduced in
+            // c++14. But sadly it seems to be a bug with gcc 4.9 to support it.
+            config.migration_function = [j_migration_cb_weak, j_config_weak](SharedRealm old_realm,
+                                                                                 SharedRealm realm, Schema&) {
+                JNIEnv* env = JniUtils::get_env(false);
+                // Java needs a new pointer for the SharedRealm life control.
+                SharedRealm* new_shared_realm_ptr = new SharedRealm(realm);
+                JavaGlobalRef config_global = j_config_weak.global_ref(env);
+                if (!config_global) {
+                    return;
+                }
+
+                j_migration_cb_weak.call_with_local_ref(env, [&](JNIEnv* env, jobject obj) {
+                    env->CallStaticVoidMethod(get_shared_realm_class(env), run_migration_callback_method,
+                                              reinterpret_cast<jlong>(new_shared_realm_ptr), config_global.get(), obj,
+                                              old_realm->schema_version());
+                });
+                // Close the SharedRealm. Otherwise it will only be closed when the Java OsSharedRealm gets GCed. And
+                // that will be too late.
+                TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(
+                    env, [&new_shared_realm_ptr]() { (*new_shared_realm_ptr)->close(); });
+            };
+        }
+        else {
+            config.migration_function = nullptr;
+        }
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetCompactOnLaunchCallback(
+    JNIEnv* env, jclass, jlong native_ptr, jobject j_compact_on_launch)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    try {
+        auto& config = *reinterpret_cast<Realm::Config*>(native_ptr);
+        if (j_compact_on_launch) {
+            static JavaClass compact_on_launch_class(env, "io/realm/CompactOnLaunchCallback");
+            static JavaMethod should_compact(env, compact_on_launch_class, "shouldCompact", "(JJ)Z");
+            // weak ref to avoid leaks caused by circular refs.
+            JavaGlobalWeakRef java_compact_on_launch_weak(env, j_compact_on_launch);
+
+            config.should_compact_on_launch_function = [java_compact_on_launch_weak](uint64_t totalBytes,
+                                                                                    uint64_t usedBytes) {
+                JNIEnv* env = JniUtils::get_env(false);
+                bool result = false;
+                java_compact_on_launch_weak.call_with_local_ref(env, [&](JNIEnv* env, jobject obj) {
+                    result = env->CallBooleanMethod(obj, should_compact, static_cast<jlong>(totalBytes),
+                                                    static_cast<jlong>(usedBytes));
+                });
+                TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(env, nullptr);
+                return result;
+            };
+        }
+        else {
+            config.should_compact_on_launch_function = nullptr;
+        }
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetInitializationCallback(JNIEnv* env,
+                                                                                            jobject j_config,
+                                                                                            jlong native_ptr,
+                                                                                            jobject j_init_callback)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    try {
+        auto& config = *reinterpret_cast<Realm::Config*>(native_ptr);
+
+        if (j_init_callback) {
+            static JavaMethod run_initialization_callback_method(
+                env, get_shared_realm_class(env), "runInitializationCallback",
+                "(JLio/realm/internal/OsRealmConfig;Lio/realm/internal/SharedRealm$InitializationCallback;)V", true);
+            // weak ref to avoid leaks caused by circular refs.
+            JavaGlobalWeakRef j_init_cb_weak(env, j_init_callback);
+            JavaGlobalWeakRef j_config_weak(env, j_config);
+            config.initialization_function = [j_init_cb_weak, j_config_weak](SharedRealm realm) {
+                JNIEnv* env = JniUtils::get_env(false);
+                // Java needs a new pointer for the SharedRealm life control.
+                SharedRealm* new_shared_realm_ptr = new SharedRealm(realm);
+                JavaGlobalRef config_global_ref = j_config_weak.global_ref(env);
+                if (!config_global_ref) {
+                    return;
+                }
+                j_init_cb_weak.call_with_local_ref(env, [&](JNIEnv* env, jobject obj) {
+                    env->CallStaticVoidMethod(get_shared_realm_class(env), run_initialization_callback_method,
+                                              reinterpret_cast<jlong>(new_shared_realm_ptr), config_global_ref.get(),
+                                              obj);
+                });
+                // Close the SharedRealm. Otherwise it will only be closed when the Java OsSharedRealm gets GCed. And
+                // that will be too late.
+                TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(
+                    env, [&new_shared_realm_ptr]() { (*new_shared_realm_ptr)->close(); });
+            };
+        }
+        else {
+            config.initialization_function = nullptr;
+        }
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeEnableChangeNotification(
+    JNIEnv*, jclass, jlong native_ptr, jboolean enable_auto_change_notification)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    // No throws
+    auto& config = *reinterpret_cast<Realm::Config*>(native_ptr);
+    config.automatic_change_notifications = enable_auto_change_notification;
+}
+
+#if REALM_ENABLE_SYNC
+JNIEXPORT jstring JNICALL Java_io_realm_internal_OsRealmConfig_nativeCreateAndSetSyncConfig(
+    JNIEnv* env, jclass, jlong native_ptr, jstring j_sync_realm_url, jstring j_auth_url, jstring j_user_id,
+    jstring j_refresh_token, jboolean j_is_partial, jbyte j_session_stop_policy)
+{
+    TR_ENTER_PTR(native_ptr)
+    auto& config = *reinterpret_cast<Realm::Config*>(native_ptr);
+    // sync_config should only be initialized once!
+    REALM_ASSERT(!config.sync_config);
+
+    try {
+        static JavaClass sync_manager_class(env, "io/realm/SyncManager");
+        // Doing the methods lookup from the thread that loaded the lib, to avoid
+        // https://developer.android.com/training/articles/perf-jni.html#faq_FindClass
+        static JavaMethod java_error_callback_method(env, sync_manager_class, "notifyErrorHandler",
+                                                     "(ILjava/lang/String;Ljava/lang/String;)V", true);
+        static JavaMethod java_bind_session_method(env, sync_manager_class, "bindSessionWithConfig",
+                                                   "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;", true);
+
+        // error handler will be called form the sync client thread
+        auto error_handler = [](std::shared_ptr<SyncSession> session, SyncError error) {
+            realm::jni_util::Log::d("error_handler lambda invoked");
+
+            auto error_message = error.message;
+            auto error_code = error.error_code.value();
+            if (error.is_client_reset_requested()) {
+                // Hack the error message to send information about the location of the backup.
+                // If more uses of the user_info map surfaces. Refactor this to send the full
+                // map instead.
+                error_message = error.user_info[SyncError::c_recovery_file_path_key];
+                error_code = 7; // See ErrorCode.java
+            }
+
+            JNIEnv* env = realm::jni_util::JniUtils::get_env(true);
+            env->CallStaticVoidMethod(sync_manager_class, java_error_callback_method, error_code,
+                                      to_jstring(env, error_message), to_jstring(env, session.get()->path()));
+        };
+
+        // path on disk of the Realm file.
+        // the sync configuration object.
+        // the session which should be bound.
+        auto bind_handler = [](const std::string& path, const SyncConfig& syncConfig,
+                               std::shared_ptr<SyncSession> session) {
+            realm::jni_util::Log::d("Callback to Java requesting token for path");
+
+            JNIEnv* env = realm::jni_util::JniUtils::get_env(true);
+
+            jstring access_token_string = (jstring)env->CallStaticObjectMethod(
+                sync_manager_class, java_bind_session_method, to_jstring(env, path.c_str()),
+                to_jstring(env, session->user()->refresh_token().c_str()));
+            if (access_token_string) {
+                // reusing cached valid token
+                JStringAccessor access_token(env, access_token_string);
+                session->refresh_access_token(access_token, realm::util::Optional<std::string>(syncConfig.realm_url()));
+            }
+        };
+
+        // Get logged in user
+        JStringAccessor user_id(env, j_user_id);
+        JStringAccessor auth_url(env, j_auth_url);
+        SyncUserIdentifier sync_user_identifier = {user_id, auth_url};
+        std::shared_ptr<SyncUser> user = SyncManager::shared().get_existing_logged_in_user(sync_user_identifier);
+        if (!user) {
+            JStringAccessor realm_auth_url(env, j_auth_url);
+            JStringAccessor refresh_token(env, j_refresh_token);
+            user = SyncManager::shared().get_user(sync_user_identifier, refresh_token);
+        }
+
+        util::Optional<std::array<char, 64>> sync_encryption_key(util::none);
+        if (!config.encryption_key.empty()) {
+            sync_encryption_key = std::array<char, 64>();
+            std::copy_n(config.encryption_key.begin(), 64, sync_encryption_key->begin());
+        }
+
+        SyncSessionStopPolicy session_stop_policy = static_cast<SyncSessionStopPolicy>(j_session_stop_policy);
+
+        JStringAccessor realm_url(env, j_sync_realm_url);
+        config.sync_config = std::make_shared<SyncConfig>(SyncConfig{
+            user, realm_url, session_stop_policy, std::move(bind_handler), std::move(error_handler),
+            nullptr, sync_encryption_key});
+        config.sync_config->is_partial = (j_is_partial == JNI_TRUE);
+
+        return to_jstring(env, config.sync_config->realm_url().c_str());
+
+    }
+    CATCH_STD()
+    return nullptr;
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetSyncConfigSslSettings(
+    JNIEnv* env, jclass, jlong native_ptr, jboolean sync_client_validate_ssl,
+    jstring j_sync_ssl_trust_certificate_path)
+{
+    TR_ENTER_PTR(native_ptr);
+
+    auto& config = *reinterpret_cast<Realm::Config*>(native_ptr);
+    // To ensure the sync_config has been created and this function won't be called multiple time on the same config.
+    REALM_ASSERT(config.sync_config);
+    REALM_ASSERT(config.sync_config->client_validate_ssl);
+    REALM_ASSERT(!config.sync_config->ssl_trust_certificate_path);
+
+    try {
+        config.sync_config->client_validate_ssl = sync_client_validate_ssl;
+        if (j_sync_ssl_trust_certificate_path) {
+            JStringAccessor cert_path(env, j_sync_ssl_trust_certificate_path);
+            config.sync_config->ssl_trust_certificate_path = realm::util::Optional<std::string>(cert_path);
+        }
+    }
+    CATCH_STD()
+}
+
+#endif
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsSchemaInfo.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsSchemaInfo.cpp
new file mode 100644
index 0000000000..0f428436a7
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsSchemaInfo.cpp
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "io_realm_internal_OsSchemaInfo.h"
+
+#include <schema.hpp>
+#include <object_schema.hpp>
+#include <property.hpp>
+#include <util/format.hpp>
+
+#include "java_accessor.hpp"
+#include "java_exception_def.hpp"
+#include "util.hpp"
+#include "jni_util/java_exception_thrower.hpp"
+
+using namespace realm;
+using namespace realm::jni_util;
+using namespace realm::util;
+using namespace realm::_impl;
+
+static void finalize_schema(jlong ptr)
+{
+    TR_ENTER_PTR(ptr);
+    delete reinterpret_cast<Schema*>(ptr);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsSchemaInfo_nativeCreateFromList(JNIEnv* env, jclass,
+                                                                                 jlongArray objectSchemaPtrs_)
+{
+    TR_ENTER()
+    try {
+        std::vector<ObjectSchema> object_schemas;
+        JLongArrayAccessor array(env, objectSchemaPtrs_);
+        for (jsize i = 0; i < array.size(); ++i) {
+            object_schemas.push_back(*reinterpret_cast<ObjectSchema*>(array[i]));
+        }
+        auto* schema = new Schema(std::move(object_schemas));
+        return reinterpret_cast<jlong>(schema);
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsSchemaInfo_nativeGetFinalizerPtr(JNIEnv*, jclass)
+{
+    TR_ENTER()
+    return reinterpret_cast<jlong>(&finalize_schema);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_OsSchemaInfo_nativeGetObjectSchemaInfo(JNIEnv* env, jclass,
+                                                                                      jlong native_ptr,
+                                                                                      jstring j_class_name)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    try {
+        JStringAccessor class_name_accessor(env, j_class_name);
+        StringData class_name(class_name_accessor);
+        auto& schema = *reinterpret_cast<Schema*>(native_ptr);
+        auto it = schema.find(class_name);
+        if (it == schema.end()) {
+            THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalState,
+                                 format("Class '%1' cannot be found in the schema.", class_name.data()));
+        } else {
+            return reinterpret_cast<jlong>(new ObjectSchema(*it));
+        }
+    }
+    CATCH_STD()
+
+    return reinterpret_cast<jlong>(nullptr);
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Property.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Property.cpp
new file mode 100644
index 0000000000..8362e7c559
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Property.cpp
@@ -0,0 +1,137 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "io_realm_internal_Property.h"
+
+#include <property.hpp>
+#include <object_store.hpp>
+
+#include "util.hpp"
+
+using namespace realm;
+
+static_assert(io_realm_internal_Property_TYPE_INT == static_cast<jint>(PropertyType::Int), "");
+static_assert(io_realm_internal_Property_TYPE_BOOL == static_cast<jint>(PropertyType::Bool), "");
+static_assert(io_realm_internal_Property_TYPE_STRING == static_cast<jint>(PropertyType::String), "");
+static_assert(io_realm_internal_Property_TYPE_DATA == static_cast<jint>(PropertyType::Data), "");
+static_assert(io_realm_internal_Property_TYPE_DATE == static_cast<jint>(PropertyType::Date), "");
+static_assert(io_realm_internal_Property_TYPE_FLOAT == static_cast<jint>(PropertyType::Float), "");
+static_assert(io_realm_internal_Property_TYPE_DOUBLE == static_cast<jint>(PropertyType::Double), "");
+static_assert(io_realm_internal_Property_TYPE_OBJECT == static_cast<jint>(PropertyType::Object), "");
+static_assert(io_realm_internal_Property_TYPE_LINKING_OBJECTS == static_cast<jint>(PropertyType::LinkingObjects), "");
+static_assert(io_realm_internal_Property_TYPE_REQUIRED == static_cast<jint>(PropertyType::Required), "");
+static_assert(io_realm_internal_Property_TYPE_NULLABLE == static_cast<jint>(PropertyType::Nullable), "");
+static_assert(io_realm_internal_Property_TYPE_ARRAY == static_cast<jint>(PropertyType::Array), "");
+
+static void finalize_property(jlong ptr)
+{
+    TR_ENTER_PTR(ptr);
+    delete reinterpret_cast<Property*>(ptr);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Property_nativeCreatePersistedProperty(JNIEnv* env, jclass,
+                                                                                      jstring j_name_str, jint type,
+                                                                                      jboolean is_primary,
+                                                                                      jboolean is_indexed)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor str(env, j_name_str);
+        PropertyType p_type = static_cast<PropertyType>(static_cast<int>(type));
+        std::unique_ptr<Property> property(
+            new Property(str, p_type, to_bool(is_primary), to_bool(is_indexed)));
+        if (to_bool(is_indexed) && !property->type_is_indexable()) {
+            throw std::invalid_argument(
+                "This field cannot be indexed - Only String/byte/short/int/long/boolean/Date fields are supported.");
+        }
+        if (to_bool(is_primary) && p_type != PropertyType::Int && p_type != PropertyType::String) {
+            std::string typ = property->type_string();
+            throw std::invalid_argument("Invalid primary key type: " + typ);
+        }
+        return reinterpret_cast<jlong>(property.release());
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Property_nativeCreatePersistedLinkProperty(JNIEnv* env, jclass,
+                                                                                          jstring j_name_str,
+                                                                                          jint type,
+                                                                                          jstring j_target_class_name)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor name(env, j_name_str);
+        JStringAccessor link_name(env, j_target_class_name);
+        PropertyType p_type = static_cast<PropertyType>(static_cast<int>(type));
+        return reinterpret_cast<jlong>(new Property(name, p_type, link_name));
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Property_nativeCreateComputedLinkProperty(JNIEnv* env, jclass,
+                                                                                         jstring j_name_str,
+                                                                                         jstring j_source_class_name,
+                                                                                         jstring j_source_field_name)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor name(env, j_name_str);
+        JStringAccessor target_class_name(env, j_source_class_name);
+        JStringAccessor target_field_name(env, j_source_field_name);
+
+        PropertyType p_type = PropertyType::LinkingObjects | PropertyType::Array;
+        return reinterpret_cast<jlong>(new Property(name, p_type, target_class_name, target_field_name));
+    }
+    CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Property_nativeGetFinalizerPtr(JNIEnv*, jclass)
+{
+    TR_ENTER()
+    return reinterpret_cast<jlong>(&finalize_property);
+}
+
+JNIEXPORT jint JNICALL Java_io_realm_internal_Property_nativeGetType(JNIEnv*, jclass, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr);
+    auto& property = *reinterpret_cast<Property*>(native_ptr);
+    return static_cast<jint>(property.type);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Property_nativeGetColumnIndex(JNIEnv*, jclass, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr);
+    auto& property = *reinterpret_cast<Property*>(native_ptr);
+    return static_cast<jlong>(property.table_column);
+}
+
+JNIEXPORT jstring JNICALL Java_io_realm_internal_Property_nativeGetLinkedObjectName(JNIEnv* env, jclass,
+                                                                                    jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr);
+    try {
+        auto& property = *reinterpret_cast<Property*>(native_ptr);
+        std::string name = property.object_type;
+        if (!name.empty()) {
+            return to_jstring(env, name);
+        }
+    }
+    CATCH_STD()
+    return nullptr;
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
index f542b345b0..9649f18563 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
@@ -19,136 +19,35 @@
 #include "object-store/src/sync/sync_manager.hpp"
 #include "object-store/src/sync/sync_config.hpp"
 #include "object-store/src/sync/sync_session.hpp"
+#include "object-store/src/results.hpp"
+#include "object-store/src/sync/partial_sync.hpp"
+
+#include "observable_collection_wrapper.hpp"
 #endif
 
+#include <realm/util/assert.hpp>
+
 #include <shared_realm.hpp>
 
-#include "object_store.hpp"
+#include "java_accessor.hpp"
 #include "java_binding_context.hpp"
+#include "java_exception_def.hpp"
+#include "object_store.hpp"
 #include "util.hpp"
-
 #include "jni_util/java_method.hpp"
 #include "jni_util/java_class.hpp"
+#include "jni_util/java_exception_thrower.hpp"
+
 
 using namespace realm;
 using namespace realm::_impl;
 using namespace realm::jni_util;
 
-static_assert(SchemaMode::Automatic ==
-                  static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_AUTOMATIC),
-              "");
-static_assert(SchemaMode::ReadOnly ==
-                  static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_READONLY),
-              "");
-static_assert(SchemaMode::ResetFile ==
-                  static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_RESET_FILE),
-              "");
-static_assert(SchemaMode::Additive ==
-                  static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_ADDITIVE),
-              "");
-static_assert(SchemaMode::Manual == static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_MANUAL),
-              "");
-
-static void finalize_shared_realm(jlong ptr);
-
-// Wrapper class for SyncConfig. This is required as we need to keep track of the Java session
-// object as part of the configuration.
-class JniConfigWrapper {
-
-public:
-    JniConfigWrapper(const JniConfigWrapper&) = delete;
-
-    JniConfigWrapper& operator=(const JniConfigWrapper&) = delete;
-    JniConfigWrapper(JniConfigWrapper&&) = delete;
-    JniConfigWrapper& operator=(JniConfigWrapper&&) = delete;
-
-    // Non-sync constructor
-    JniConfigWrapper(JNIEnv*, Realm::Config& config)
-        : m_config(std::move(config))
-    {
-    }
-
-    // Sync constructor
-    JniConfigWrapper(REALM_UNUSED JNIEnv* env, REALM_UNUSED Realm::Config& config,
-                     REALM_UNUSED jstring sync_realm_url, REALM_UNUSED jstring sync_realm_auth_url,
-                     REALM_UNUSED jstring sync_user_identity, REALM_UNUSED jstring sync_refresh_token)
-        : m_config(std::move(config))
-    {
-#if REALM_ENABLE_SYNC
-        static JavaClass sync_manager_class(env, "io/realm/SyncManager");
-        // Doing the methods lookup from the thread that loaded the lib, to avoid
-        // https://developer.android.com/training/articles/perf-jni.html#faq_FindClass
-        static JavaMethod java_error_callback_method(env, sync_manager_class, "notifyErrorHandler",
-                                                     "(ILjava/lang/String;Ljava/lang/String;)V", true);
-        static JavaMethod java_bind_session_method(env, sync_manager_class, "bindSessionWithConfig",
-                                                   "(Ljava/lang/String;)Ljava/lang/String;", true);
-
-        // error handler will be called form the sync client thread
-        auto error_handler = [=](std::shared_ptr<SyncSession> session, SyncError error) {
-            realm::jni_util::Log::d("error_handler lambda invoked");
-
-            auto error_message = error.message;
-            auto error_code = error.error_code.value();
-            if (error.is_client_reset_requested()) {
-                // Hack the error message to send information about the location of the backup.
-                // If more uses of the user_info map surfaces. Refactor this to send the full
-                // map instead.
-                error_message = error.user_info[SyncError::c_recovery_file_path_key];
-                error_code = 7; // See ErrorCode.java
-            }
-
-            JNIEnv* env = realm::jni_util::JniUtils::get_env(true);
-            env->CallStaticVoidMethod(sync_manager_class, java_error_callback_method, error_code,
-                                      to_jstring(env, error_message), to_jstring(env, session.get()->path()));
-        };
-
-        // path on disk of the Realm file.
-        // the sync configuration object.
-        // the session which should be bound.
-        auto bind_handler = [=](const std::string& path, const SyncConfig& syncConfig,
-                                std::shared_ptr<SyncSession> session) {
-            realm::jni_util::Log::d("Callback to Java requesting token for path");
-
-            JNIEnv* env = realm::jni_util::JniUtils::get_env(true);
-
-            jstring access_token_string = (jstring)env->CallStaticObjectMethod(
-                sync_manager_class, java_bind_session_method, to_jstring(env, path.c_str()));
-            if (access_token_string) {
-                // reusing cached valid token
-                JStringAccessor access_token(env, access_token_string);
-                session->refresh_access_token(access_token, realm::util::Optional<std::string>(syncConfig.realm_url));
-            }
-        };
+static const char* c_table_name_exists_exception_msg = "Class already exists: '%1'.";
 
-        // Get logged in user
-        JStringAccessor user_identity(env, sync_user_identity);
-        JStringAccessor realm_url(env, sync_realm_url);
-        std::shared_ptr<SyncUser> user = SyncManager::shared().get_existing_logged_in_user(user_identity);
-        if (!user) {
-            JStringAccessor realm_auth_url(env, sync_realm_auth_url);
-            JStringAccessor refresh_token(env, sync_refresh_token);
-            user = SyncManager::shared().get_user(user_identity, refresh_token,
-                                                  realm::util::Optional<std::string>(realm_auth_url));
-        }
-        m_config.sync_config = std::make_shared<SyncConfig>(SyncConfig{
-            user, realm_url, SyncSessionStopPolicy::Immediately, std::move(bind_handler), std::move(error_handler)});
-#else
-        REALM_UNREACHABLE();
+#if REALM_ENABLE_SYNC // used only for partial sync now
+typedef ObservableCollectionWrapper<Results> ResultsWrapper;
 #endif
-    }
-
-    inline Realm::Config& get_config()
-    {
-        return m_config;
-    }
-
-    ~JniConfigWrapper()
-    {
-    }
-
-private:
-    Realm::Config m_config;
-};
 
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeInit(JNIEnv* env, jclass,
                                                                      jstring temporary_directory_path)
@@ -162,60 +61,45 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeInit(JNIEnv* env
     CATCH_STD()
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeCreateConfig(
-    JNIEnv* env, jclass, jstring realm_path, jbyteArray key, jbyte schema_mode, jboolean in_memory, jboolean cache,
-    jlong /* schema_version */, jboolean disable_format_upgrade, jboolean auto_change_notification,
-    REALM_UNUSED jstring sync_server_url, REALM_UNUSED jstring sync_server_auth_url,
-    REALM_UNUSED jstring sync_user_identity, REALM_UNUSED jstring sync_refresh_token)
-{
-    TR_ENTER()
-
-    try {
-        JStringAccessor path(env, realm_path); // throws
-        JniByteArray key_array(env, key);
-        Realm::Config config;
-        config.path = path;
-        // config->schema_version = schema_version; TODO: Disabled until we remove version handling from Java
-        config.encryption_key = key_array;
-        config.schema_mode = static_cast<SchemaMode>(schema_mode);
-        config.in_memory = in_memory;
-        config.cache = cache;
-        config.disable_format_upgrade = disable_format_upgrade;
-        config.automatic_change_notifications = auto_change_notification;
-        if (sync_server_url) {
-            return reinterpret_cast<jlong>(new JniConfigWrapper(env, config, sync_server_url, sync_server_auth_url,
-                                                                sync_user_identity, sync_refresh_token));
-        }
-        else {
-            return reinterpret_cast<jlong>(new JniConfigWrapper(env, config));
-        }
-    }
-    CATCH_STD()
-
-    return static_cast<jlong>(NULL);
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeCloseConfig(JNIEnv*, jclass, jlong config_ptr)
-{
-    TR_ENTER_PTR(config_ptr)
-
-    auto config = reinterpret_cast<JniConfigWrapper*>(config_ptr);
-    delete config;
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeGetSharedRealm(JNIEnv* env, jclass, jlong config_ptr,
                                                                                 jobject realm_notifier)
 {
     TR_ENTER_PTR(config_ptr)
 
-    auto config = reinterpret_cast<JniConfigWrapper*>(config_ptr);
+    auto& config = *reinterpret_cast<Realm::Config*>(config_ptr);
     try {
-        auto shared_realm = Realm::get_shared_realm(config->get_config());
+        auto shared_realm = Realm::get_shared_realm(config);
+        // The migration callback & initialization callback could throw.
+        if (env->ExceptionCheck()) {
+            return reinterpret_cast<jlong>(nullptr);
+        }
         shared_realm->m_binding_context = JavaBindingContext::create(env, realm_notifier);
         return reinterpret_cast<jlong>(new SharedRealm(std::move(shared_realm)));
     }
+    catch (SchemaMismatchException& e) {
+        // An exception has been thrown in the migration block.
+        if (env->ExceptionCheck()) {
+            return reinterpret_cast<jlong>(nullptr);
+        }
+        static JavaClass migration_needed_class(env, JavaExceptionDef::RealmMigrationNeeded);
+        static JavaMethod constructor(env, migration_needed_class, "<init>",
+                                      "(Ljava/lang/String;Ljava/lang/String;)V");
+
+        jstring message = to_jstring(env, e.what());
+        jstring path = to_jstring(env, config.path);
+        jobject migration_needed_exception = env->NewObject(migration_needed_class, constructor, path, message);
+        env->Throw(reinterpret_cast<jthrowable>(migration_needed_exception));
+    }
+    catch (InvalidSchemaVersionException& e) {
+        // An exception has been thrown in the migration block.
+        if (env->ExceptionCheck()) {
+            return reinterpret_cast<jlong>(nullptr);
+        }
+        // To match the old behaviour. Otherwise it will be converted to ISE in the CATCH_STD.
+        ThrowException(env, IllegalArgument, e.what());
+    }
     CATCH_STD()
-    return static_cast<jlong>(NULL);
+    return reinterpret_cast<jlong>(nullptr);
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeCloseSharedRealm(JNIEnv*, jclass,
@@ -223,7 +107,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeCloseSharedRealm
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     // Close the SharedRealm only. Let the finalizer daemon thread free the SharedRealm
     if (!shared_realm->is_closed()) {
         shared_realm->close();
@@ -235,7 +119,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeBeginTransaction
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         shared_realm->begin_transaction();
     }
@@ -247,7 +131,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeCommitTransactio
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         shared_realm->commit_transaction();
         // Realm could be closed in the RealmNotifier.didChange().
@@ -265,7 +149,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeCancelTransactio
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         shared_realm->cancel_transaction();
     }
@@ -278,62 +162,16 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeIsInTransact
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     return static_cast<jboolean>(shared_realm->is_in_transaction());
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeReadGroup(JNIEnv* env, jclass,
-                                                                           jlong shared_realm_ptr)
-{
-    TR_ENTER_PTR(shared_realm_ptr)
-
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-    try {
-        return reinterpret_cast<jlong>(&shared_realm->read_group());
-    }
-    CATCH_STD()
-
-    return static_cast<jlong>(NULL);
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeGetVersion(JNIEnv* env, jclass,
-                                                                            jlong shared_realm_ptr)
-{
-    TR_ENTER_PTR(shared_realm_ptr)
-
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-    try {
-        return static_cast<jlong>(ObjectStore::get_schema_version(shared_realm->read_group()));
-    }
-    CATCH_STD()
-    return static_cast<jlong>(ObjectStore::NotVersioned);
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeSetVersion(JNIEnv* env, jclass,
-                                                                           jlong shared_realm_ptr, jlong version)
-{
-    TR_ENTER_PTR(shared_realm_ptr)
-
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-    try {
-        if (!shared_realm->is_in_transaction()) {
-            std::ostringstream ss;
-            ss << "Cannot set schema version when the realm is not in transaction.";
-            ThrowException(env, IllegalState, ss.str());
-            return;
-        }
-
-        ObjectStore::set_schema_version(shared_realm->read_group(), static_cast<uint64_t>(version));
-    }
-    CATCH_STD()
-}
-
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeIsEmpty(JNIEnv* env, jclass,
                                                                             jlong shared_realm_ptr)
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         return static_cast<jboolean>(ObjectStore::is_empty(shared_realm->read_group()));
     }
@@ -345,7 +183,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeRefresh(JNIEnv*
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         shared_realm->refresh();
     }
@@ -357,7 +195,7 @@ JNIEXPORT jlongArray JNICALL Java_io_realm_internal_SharedRealm_nativeGetVersion
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         using rf = realm::_impl::RealmFriend;
         SharedGroup::VersionID version_id = rf::get_shared_group(*shared_realm).get_version_of_current_transaction();
@@ -384,7 +222,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeIsClosed(JNI
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     return static_cast<jboolean>(shared_realm->is_closed());
 }
 
@@ -396,19 +234,99 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeGetTable(JNIEnv
 
     try {
         JStringAccessor name(env, table_name); // throws
-        auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-        if (!shared_realm->read_group().has_table(name) && !shared_realm->is_in_transaction()) {
-            std::ostringstream ss;
-            ss << "Class " << name << " doesn't exist and the shared Realm is not in transaction.";
-            ThrowException(env, IllegalState, ss.str());
-            return static_cast<jlong>(NULL);
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        if (!shared_realm->read_group().has_table(name)) {
+            std::string name_str = name;
+            if (name_str.find(TABLE_PREFIX) == 0) {
+                name_str = name_str.substr(TABLE_PREFIX.length());
+            }
+            THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalArgument,
+                                 format("The class '%1' doesn't exist in this Realm.", name_str));
+        }
+        Table* table = LangBindHelper::get_table(shared_realm->read_group(), name);
+        return reinterpret_cast<jlong>(table);
+    }
+    CATCH_STD()
+
+    return reinterpret_cast<jlong>(nullptr);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeCreateTable(JNIEnv* env, jclass,
+                                                                             jlong shared_realm_ptr,
+                                                                             jstring j_table_name)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    std::string table_name;
+    try {
+        table_name = JStringAccessor(env, j_table_name); // throws
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        shared_realm->verify_in_write(); // throws
+        Table* table;
+        auto& group = shared_realm->read_group();
+#if REALM_ENABLE_SYNC
+        // Sync doesn't throw when table exists.
+        if (group.has_table(table_name)) {
+            THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalArgument,
+                                 format(c_table_name_exists_exception_msg, table_name.substr(TABLE_PREFIX.length())));
+        }
+        auto table_ref = sync::create_table(group, table_name); // throws
+        table = LangBindHelper::get_table(group, table_ref->get_index_in_group());
+#else
+        table = LangBindHelper::add_table(group, table_name); // throws
+#endif
+        return reinterpret_cast<jlong>(table);
+    }
+    catch (TableNameInUse& e) {
+        // We need to print the table name, so catch the exception here.
+        std::string class_name_str(table_name.substr(TABLE_PREFIX.length()));
+        ThrowException(env, IllegalArgument, format(c_table_name_exists_exception_msg, class_name_str));
+    }
+    CATCH_STD()
+
+    return reinterpret_cast<jlong>(nullptr);
+}
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeCreateTableWithPrimaryKeyField(
+    JNIEnv* env, jclass, jlong shared_realm_ptr, jstring j_table_name, jstring j_field_name, jboolean is_string_type,
+    jboolean is_nullable)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    std::string class_name_str;
+    try {
+        std::string table_name(JStringAccessor(env, j_table_name));
+        class_name_str = std::string(table_name.substr(TABLE_PREFIX.length()));
+        JStringAccessor field_name(env, j_field_name); // throws
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        shared_realm->verify_in_write(); // throws
+        DataType pkType = is_string_type ? DataType::type_String : DataType::type_Int;
+        Table* table;
+        auto& group = shared_realm->read_group();
+#if REALM_ENABLE_SYNC
+        // Sync doesn't throw when table exists.
+        if (group.has_table(table_name)) {
+            THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalArgument,
+                                 format(c_table_name_exists_exception_msg, class_name_str));
         }
-        Table* pTable = LangBindHelper::get_or_add_table(shared_realm->read_group(), name);
-        return reinterpret_cast<jlong>(pTable);
+        auto table_ref =
+            sync::create_table_with_primary_key(group, table_name, pkType, field_name, is_nullable);
+        table = LangBindHelper::get_table(group, table_ref->get_index_in_group());
+#else
+        table = LangBindHelper::add_table(group, table_name);
+        size_t column_idx = table->add_column(pkType, field_name, is_nullable);
+        table->add_search_index(column_idx);
+#endif
+        ObjectStore::set_primary_key_for_object(group, class_name_str, field_name);
+        return reinterpret_cast<jlong>(table);
+    }
+    catch (TableNameInUse& e) {
+        // We need to print the table name, so catch the exception here.
+        ThrowException(env, IllegalArgument, format(c_table_name_exists_exception_msg, class_name_str));
     }
     CATCH_STD()
 
-    return static_cast<jlong>(NULL);
+    return reinterpret_cast<jlong>(nullptr);
 }
 
 JNIEXPORT jstring JNICALL Java_io_realm_internal_SharedRealm_nativeGetTableName(JNIEnv* env, jclass,
@@ -417,7 +335,7 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_SharedRealm_nativeGetTableName(
 
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         return to_jstring(env, shared_realm->read_group().get_table_name(static_cast<size_t>(index)));
     }
@@ -431,7 +349,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeHasTable(JNI
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         JStringAccessor name(env, table_name);
         return static_cast<jboolean>(shared_realm->read_group().has_table(name));
@@ -447,7 +365,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeRenameTable(JNIE
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         JStringAccessor old_name(env, old_table_name);
         if (!shared_realm->is_in_transaction()) {
@@ -462,31 +380,11 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeRenameTable(JNIE
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeRemoveTable(JNIEnv* env, jclass,
-                                                                            jlong shared_realm_ptr,
-                                                                            jstring table_name)
-{
-    TR_ENTER_PTR(shared_realm_ptr)
-
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-    try {
-        JStringAccessor name(env, table_name);
-        if (!shared_realm->is_in_transaction()) {
-            std::ostringstream ss;
-            ss << "Class " << name << " cannot be removed when the realm is not in transaction.";
-            ThrowException(env, IllegalState, ss.str());
-            return;
-        }
-        shared_realm->read_group().remove_table(name);
-    }
-    CATCH_STD()
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeSize(JNIEnv* env, jclass, jlong shared_realm_ptr)
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         return static_cast<jlong>(shared_realm->read_group().size());
     }
@@ -500,11 +398,11 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeWriteCopy(JNIEnv
 {
     TR_ENTER_PTR(shared_realm_ptr);
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         JStringAccessor path_str(env, path);
-        JniByteArray key_buffer(env, key);
-        shared_realm->write_copy(path_str, key_buffer);
+        JByteArrayAccessor jarray_accessor(env, key);
+        shared_realm->write_copy(path_str, jarray_accessor.transform<BinaryData>());
     }
     CATCH_STD()
 }
@@ -514,7 +412,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeWaitForChang
 {
     TR_ENTER_PTR(shared_realm_ptr);
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         using rf = realm::_impl::RealmFriend;
         return static_cast<jboolean>(rf::get_shared_group(*shared_realm).wait_for_change());
@@ -529,7 +427,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeStopWaitForChang
 {
     TR_ENTER_PTR(shared_realm_ptr);
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         using rf = realm::_impl::RealmFriend;
         rf::get_shared_group(*shared_realm).wait_for_change_release();
@@ -542,7 +440,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeCompact(JNIE
 {
     TR_ENTER_PTR(shared_realm_ptr);
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         return static_cast<jboolean>(shared_realm->compact());
     }
@@ -551,50 +449,6 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeCompact(JNIE
     return JNI_FALSE;
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeGetSnapshotVersion(JNIEnv* env, jclass,
-                                                                                    jlong shared_realm_ptr)
-{
-    TR_ENTER_PTR(shared_realm_ptr)
-
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-    try {
-        using rf = realm::_impl::RealmFriend;
-        auto& shared_group = rf::get_shared_group(*shared_realm);
-        return LangBindHelper::get_version_of_latest_snapshot(shared_group);
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeUpdateSchema(JNIEnv* env, jclass,
-                                                                             jlong shared_realm_ptr, jlong schema_ptr,
-                                                                             jlong version)
-{
-    TR_ENTER_PTR(shared_realm_ptr)
-    try {
-        auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-        auto* schema = reinterpret_cast<Schema*>(schema_ptr);
-        shared_realm->update_schema(*schema, static_cast<uint64_t>(version), nullptr, true);
-    }
-    CATCH_STD()
-}
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeRequiresMigration(JNIEnv* env, jclass,
-                                                                                      jlong nativePtr,
-                                                                                      jlong nativeSchemaPtr)
-{
-
-    TR_ENTER()
-    try {
-        auto shared_realm = *(reinterpret_cast<SharedRealm*>(nativePtr));
-        auto* schema = reinterpret_cast<Schema*>(nativeSchemaPtr);
-        const std::vector<SchemaChange>& change_list = shared_realm->schema().compare(*schema);
-        return static_cast<jboolean>(!change_list.empty());
-    }
-    CATCH_STD()
-    return JNI_FALSE;
-}
-
 static void finalize_shared_realm(jlong ptr)
 {
     TR_ENTER_PTR(ptr)
@@ -613,7 +467,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeSetAutoRefresh(J
 {
     TR_ENTER_PTR(shared_realm_ptr)
     try {
-        auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
         shared_realm->set_auto_refresh(to_bool(enabled));
     }
     CATCH_STD()
@@ -624,9 +478,84 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeIsAutoRefres
 {
     TR_ENTER_PTR(shared_realm_ptr)
     try {
-        auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
         return to_jbool(shared_realm->auto_refresh());
     }
     CATCH_STD()
     return JNI_FALSE;
 }
+
+JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeGetSchemaInfo(JNIEnv*, jclass,
+                                                                               jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    // No throws
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    return reinterpret_cast<jlong>(&shared_realm->schema());
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeRegisterSchemaChangedCallback(
+    JNIEnv* env, jclass, jlong shared_realm_ptr, jobject j_schema_changed_callback)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+    // No throws
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    JavaGlobalWeakRef callback_weak_ref(env, j_schema_changed_callback);
+    if (shared_realm->m_binding_context) {
+        JavaBindingContext& java_binding_context =
+            *(static_cast<JavaBindingContext*>(shared_realm->m_binding_context.get()));
+        java_binding_context.set_schema_changed_callback(env, j_schema_changed_callback);
+    }
+}
+
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeRegisterPartialSyncQuery(
+    REALM_UNUSED JNIEnv* env, REALM_UNUSED jobject j_shared_realm_instance, REALM_UNUSED jlong shared_realm_ptr, REALM_UNUSED jstring j_class_name,
+    REALM_UNUSED jstring j_query, REALM_UNUSED jobject j_callback)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+
+#if REALM_ENABLE_SYNC
+
+    auto& shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+    try {
+        JStringAccessor class_name(env, j_class_name);               // throws
+        JStringAccessor query(env, j_query);                         // throws
+
+        // The lambda will capture the copied reference and it will be unreferenced when the lambda's life cycle is over.
+        // That happens when the Realm is closed or the callback has been triggered once.
+        JavaGlobalRef j_callback_ref(env, j_callback);
+        JavaGlobalWeakRef j_shared_realm_instance_ref(env, j_shared_realm_instance);
+
+        static JavaClass shared_realm_class(env, "io/realm/internal/SharedRealm");
+        static JavaMethod partial_sync_cb(env, shared_realm_class, "runPartialSyncRegistrationCallback",
+                                          "(Ljava/lang/String;JLio/realm/internal/SharedRealm$PartialSyncCallback;)V");
+
+        auto cb = [j_callback_ref, j_shared_realm_instance_ref](Results results, std::exception_ptr err) {
+            JNIEnv* env = JniUtils::get_env(true);
+            j_shared_realm_instance_ref.call_with_local_ref(env, [&](JNIEnv*, jobject row_obj) {
+                if (err) {
+                    try {
+                        std::rethrow_exception(err);
+                    }
+                    catch (const std::exception& e) {
+                        env->CallVoidMethod(row_obj, partial_sync_cb, to_jstring(env, e.what()),
+                                            reinterpret_cast<jlong>(nullptr), j_callback_ref.get());
+                    }
+                    return;
+                }
+
+                auto wrapper = new ResultsWrapper(results);
+                env->CallVoidMethod(row_obj, partial_sync_cb, nullptr, reinterpret_cast<jlong>(wrapper),
+                                    j_callback_ref.get());
+            });
+        };
+
+        partial_sync::register_query(shared_realm, class_name, query, std::move(cb));
+    }
+    CATCH_STD()
+#else
+    REALM_TERMINATE("Unsupported operation. Only available when used with the Realm Object Server");
+#endif
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
index 2a2c339ebc..1618c48ad9 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
@@ -17,11 +17,31 @@
 #include <sstream>
 
 #include "util.hpp"
+#include "io_realm_internal_Property.h"
 #include "io_realm_internal_Table.h"
-#include "tablebase_tpl.hpp"
+
+#include "shared_realm.hpp"
+#include "util/format.hpp"
+
+#include "java_accessor.hpp"
+#include "java_exception_def.hpp"
+#include "jni_util/java_exception_thrower.hpp"
 
 using namespace std;
 using namespace realm;
+using namespace realm::_impl;
+using namespace realm::jni_util;
+using namespace realm::util;
+
+static_assert(io_realm_internal_Table_MAX_STRING_SIZE == Table::max_string_size, "");
+static_assert(io_realm_internal_Table_MAX_BINARY_SIZE == Table::max_binary_size, "");
+
+static const char* c_null_values_cannot_set_required_msg = "The primary key field '%1' has 'null' values stored.  It "
+                                                           "cannot be converted to a '@Required' primary key field.";
+static const char* const PK_TABLE_NAME = "pk"; // ObjectStore::c_primaryKeyTableName
+static const size_t CLASS_COLUMN_INDEX = 0; // ObjectStore::c_primaryKeyObjectClassColumnIndex
+static const size_t FIELD_COLUMN_INDEX = 1; // ObjectStore::c_primaryKeyPropertyNameColumnIndex
+
 
 static void finalize_table(jlong ptr);
 
@@ -54,7 +74,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddColumn(JNIEnv* env
     try {
         JStringAccessor name2(env, name); // throws
         bool is_column_nullable = to_bool(isNullable);
-
         DataType dataType = DataType(colType);
         if (is_column_nullable && dataType == type_LinkList) {
             ThrowException(env, IllegalArgument, "List fields cannot be nullable.");
@@ -65,6 +84,25 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddColumn(JNIEnv* env
     return 0;
 }
 
+JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddPrimitiveListColumn(JNIEnv* env, jobject,
+                                                                                  jlong native_table_ptr, jint j_col_type,
+                                                                                  jstring j_name, jboolean j_is_nullable)
+{
+    if (!TABLE_VALID(env, TBL(native_table_ptr))) {
+        return 0;
+    }
+    try {
+        JStringAccessor name(env, j_name); // throws
+        bool is_column_nullable = to_bool(j_is_nullable);
+        DataType data_type = DataType(j_col_type);
+        Table* table = TBL(native_table_ptr);
+        size_t col = table->add_column(type_Table, name);
+        return table->get_subdescriptor(col)->add_column(data_type, ObjectStore::ArrayColumnName, nullptr, is_column_nullable);
+    }
+    CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
+}
+
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddColumnLink(JNIEnv* env, jobject, jlong nativeTablePtr,
                                                                          jint colType, jstring name,
                                                                          jlong targetTablePtr)
@@ -90,40 +128,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddColumnLink(JNIEnv*
 }
 
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativePivot(JNIEnv* env, jobject, jlong dataTablePtr,
-                                                                jlong stringCol, jlong intCol, jint operation,
-                                                                jlong resultTablePtr)
-{
-    Table* dataTable = TBL(dataTablePtr);
-    Table* resultTable = TBL(resultTablePtr);
-    Table::AggrType pivotOp;
-    switch (operation) {
-        case 0:
-            pivotOp = Table::aggr_count;
-            break;
-        case 1:
-            pivotOp = Table::aggr_sum;
-            break;
-        case 2:
-            pivotOp = Table::aggr_avg;
-            break;
-        case 3:
-            pivotOp = Table::aggr_min;
-            break;
-        case 4:
-            pivotOp = Table::aggr_max;
-            break;
-        default:
-            ThrowException(env, UnsupportedOperation, "No pivot operation specified.");
-            return;
-    }
-
-    try {
-        dataTable->aggregate(S(stringCol), S(intCol), pivotOp, *resultTable);
-    }
-    CATCH_STD()
-}
-
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveColumn(JNIEnv* env, jobject, jlong nativeTablePtr,
                                                                        jlong columnIndex)
 {
@@ -141,6 +145,22 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRemoveColumn(JNIEnv* e
     CATCH_STD()
 }
 
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeInsertColumn(JNIEnv* env, jclass, jlong native_table_ptr,
+                                                                       jlong column_index, jint type, jstring j_name)
+{
+    auto table_ptr = reinterpret_cast<realm::Table*>(native_table_ptr);
+    if (!TABLE_VALID(env, table_ptr)) {
+        return;
+    }
+    try {
+        JStringAccessor name(env, j_name); // throws
+
+        DataType data_type = DataType(type);
+        table_ptr->insert_column(column_index, data_type, name);
+    }
+    CATCH_STD()
+}
+
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeRenameColumn(JNIEnv* env, jobject, jlong nativeTablePtr,
                                                                        jlong columnIndex, jstring name)
 {
@@ -171,8 +191,13 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsColumnNullable(J
         ThrowException(env, UnsupportedOperation, "Not allowed to convert field in subtable.");
         return JNI_FALSE;
     }
-    size_t column_index = S(columnIndex);
-    return to_jbool(table->is_nullable(column_index));
+
+    if (table->get_column_type(S(columnIndex)) != type_Table) {
+        // for other than primitive list (including object, object list).
+        return to_jbool(table->is_nullable(S(columnIndex))); // noexcept
+    }
+    // For primitive list
+    return to_jbool(table->get_descriptor()->get_subdescriptor(S(columnIndex))->is_nullable(S(0))); // noexcept
 }
 
 
@@ -191,219 +216,315 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsColumnNullable(J
 // 5. search indexing must be preserved
 // 6. removing the original column and renaming the temporary column will make it look like original is being modified
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullable(JNIEnv* env, jobject,
-                                                                                  jlong nativeTablePtr,
-                                                                                  jlong columnIndex)
-{
-    Table* table = TBL(nativeTablePtr);
-    if (!TBL_AND_COL_INDEX_VALID(env, table, columnIndex)) {
-        return;
-    }
-    if (table->has_shared_type()) {
-        ThrowException(env, UnsupportedOperation, "Not allowed to convert field in subtable.");
-        return;
-    }
-    try {
-        size_t column_index = S(columnIndex);
-        if (table->is_nullable(column_index)) {
-            return; // column is already nullable
-        }
-
-        std::string column_name = table->get_column_name(column_index);
-        DataType column_type = table->get_column_type(column_index);
-        if (column_type == type_Link || column_type == type_LinkList || column_type == type_Mixed ||
-            column_type == type_Table) {
-            ThrowException(env, IllegalArgument, "Wrong type - cannot be converted to nullable.");
-        }
-
-        std::string tmp_column_name;
-
-        size_t j = 0;
-        while (true) {
-            std::ostringstream ss;
-            ss << std::string("__TMP__") << j;
-            std::string str = ss.str();
-            StringData sd(str);
-            if (table->get_column_index(sd) == realm::not_found) {
-                table->insert_column(column_index, column_type, sd, true);
-                tmp_column_name = ss.str();
+// Converts a table to allow for nullable values
+// Works on both normal table columns and sub tables
+static void convert_column_to_nullable(JNIEnv* env, Table* old_table, size_t old_col_ndx, Table* new_table, size_t new_col_ndx, bool is_primary_key)
+{
+    DataType column_type = old_table->get_column_type(old_col_ndx);
+    if (old_table != new_table) {
+        new_table->add_empty_row(old_table->size());
+    }
+    for (size_t i = 0; i < old_table->size(); ++i) {
+        switch (column_type) {
+            case type_String: {
+                // Payload copy is needed
+                StringData sd(old_table->get_string(old_col_ndx, i));
+                if (is_primary_key) {
+                    new_table->set_string_unique(new_col_ndx, i, sd);
+                }
+                else {
+                    new_table->set_string(new_col_ndx, i, sd);
+                }
                 break;
             }
-            j++;
-        }
-
-        for (size_t i = 0; i < table->size(); ++i) {
-            switch (column_type) {
-                case type_String: {
-                    // Payload copy is needed
-                    StringData sd(table->get_string(column_index + 1, i));
-                    table->set_string(column_index, i, sd);
-                    break;
+            case type_Binary: {
+                BinaryData bd = old_table->get_binary(old_col_ndx, i);
+                new_table->set_binary(new_col_ndx, i, BinaryData(bd.data(), bd.size()));
+                break;
+            }
+            case type_Int:
+                if (is_primary_key) {
+                    new_table->set_int_unique(new_col_ndx, i, old_table->get_int(old_col_ndx, i));
                 }
-                case type_Binary: {
-                    // Payload copy is needed
-                    BinaryData bd = table->get_binary(column_index + 1, i);
-                    std::vector<char> binary_copy(bd.data(), bd.data() + bd.size());
-                    table->set_binary(column_index, i, BinaryData(binary_copy.data(), binary_copy.size()));
-                    break;
+                else {
+                    new_table->set_int(new_col_ndx, i, old_table->get_int(old_col_ndx, i));
                 }
-                case type_Int:
-                    table->set_int(column_index, i, table->get_int(column_index + 1, i));
-                    break;
-                case type_Bool:
-                    table->set_bool(column_index, i, table->get_bool(column_index + 1, i));
-                    break;
-                case type_Timestamp:
-                    table->set_timestamp(column_index, i, table->get_timestamp(column_index + 1, i));
-                    break;
-                case type_Float:
-                    table->set_float(column_index, i, table->get_float(column_index + 1, i));
-                    break;
-                case type_Double:
-                    table->set_double(column_index, i, table->get_double(column_index + 1, i));
-                    break;
-                case type_Link:
-                case type_LinkList:
-                case type_Mixed:
-                case type_Table:
-                    // checked previously
-                    break;
-                case type_OldDateTime:
-                    ThrowException(env, UnsupportedOperation, "The old DateTime type is not supported.");
-                    return;
+                break;
+            case type_Bool:
+                new_table->set_bool(new_col_ndx, i, old_table->get_bool(old_col_ndx, i));
+                break;
+            case type_Timestamp:
+                new_table->set_timestamp(new_col_ndx, i, old_table->get_timestamp(old_col_ndx, i));
+                break;
+            case type_Float:
+                new_table->set_float(new_col_ndx, i, old_table->get_float(old_col_ndx, i));
+                break;
+            case type_Double:
+                new_table->set_double(new_col_ndx, i, old_table->get_double(old_col_ndx, i));
+                break;
+            case type_Link:
+            case type_LinkList:
+            case type_Mixed:
+            case type_Table:
+                // checked previously
+                break;
+            case type_OldDateTime:
+                ThrowException(env, UnsupportedOperation, "The old DateTime type is not supported.");
+                return;
+        }
+    }
+}
+
+// Creates the new column into which all old data is copied when switching between nullable and non-nullable.
+static void create_new_column(Table* table, size_t column_index, bool nullable)
+{
+    std::string column_name = table->get_column_name(column_index);
+    DataType column_type = table->get_column_type(column_index);
+    bool is_subtable = table->get_column_type(column_index) == DataType::type_Table;
+    size_t j = 0;
+    while (true) {
+        std::ostringstream ss;
+        ss << std::string("__TMP__") << j;
+        std::string str = ss.str();
+        StringData tmp_column_name(str);
+        if (table->get_column_index(tmp_column_name) == realm::not_found) {
+            if (is_subtable) {
+                DataType original_type = table->get_subdescriptor(column_index)->get_column_type(0);
+                table->insert_column(column_index, type_Table, tmp_column_name, true);
+                table->get_subdescriptor(column_index)->add_column(original_type, ObjectStore::ArrayColumnName, nullptr, nullable);
             }
+            else {
+                table->insert_column(column_index, column_type, tmp_column_name, nullable);
+            }
+            break;
         }
+        j++;
+    }
+
+    // Search index has too be added first since if it is a PK field, add_xxx_unique will check it.
+    if (!is_subtable) {
+        // TODO indexes on sub tables not supported yet?
         if (table->has_search_index(column_index + 1)) {
             table->add_search_index(column_index);
         }
-        table->remove_column(column_index + 1);
-        table->rename_column(table->get_column_index(tmp_column_name), column_name);
     }
-    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNullable(JNIEnv* env, jobject,
-                                                                                     jlong nativeTablePtr,
-                                                                                     jlong columnIndex)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNullable(JNIEnv* env, jobject obj,
+                                                                                  jlong native_table_ptr,
+                                                                                  jlong j_column_index,
+                                                                                  jboolean is_primary_key)
 {
-    Table* table = TBL(nativeTablePtr);
-    if (!TBL_AND_COL_INDEX_VALID(env, table, columnIndex)) {
-        return;
-    }
-    if (table->has_shared_type()) {
-        ThrowException(env, UnsupportedOperation, "Not allowed to convert field in subtable.");
+    Table* table = TBL(native_table_ptr);
+    if (!TBL_AND_COL_INDEX_VALID(env, table, j_column_index)) {
         return;
     }
     try {
-        size_t column_index = S(columnIndex);
-        if (!table->is_nullable(column_index)) {
-            return; // column is already not nullable
+        Table* table = TBL(native_table_ptr);
+        if (!TBL_AND_COL_INDEX_VALID(env, table, j_column_index)) {
+            return;
+        }
+        if (table->has_shared_type()) {
+            ThrowException(env, UnsupportedOperation, "Not allowed to convert field in subtable.");
+            return;
         }
 
-        std::string column_name = table->get_column_name(column_index);
+        size_t column_index = S(j_column_index);
         DataType column_type = table->get_column_type(column_index);
-        if (column_type == type_Link || column_type == type_LinkList || column_type == type_Mixed ||
-            column_type == type_Table) {
+        std::string column_name = table->get_column_name(column_index);
+        bool is_subtable = (column_type == DataType::type_Table);
+
+        // Cannot convert Object links or lists of objects
+        if (column_type == type_Link || column_type == type_LinkList || column_type == type_Mixed) {
             ThrowException(env, IllegalArgument, "Wrong type - cannot be converted to nullable.");
         }
 
-        std::string tmp_column_name;
-        size_t j = 0;
-        while (true) {
-            std::ostringstream ss;
-            ss << std::string("__TMP__") << j;
-            std::string str = ss.str();
-            StringData sd(str);
-            if (table->get_column_index(sd) == realm::not_found) {
-                table->insert_column(column_index, column_type, sd, false);
-                tmp_column_name = ss.str();
-                break;
+        // Exit quickly if column is already nullable
+        if (Java_io_realm_internal_Table_nativeIsColumnNullable(env, obj, native_table_ptr, j_column_index)) {
+            return;
+        }
+
+        // 1. Create temporary table
+        create_new_column(table, column_index, true);
+
+        // Move all values
+        if (is_subtable) {
+            for (size_t i = 0; i < table->size(); ++i) {
+                TableRef new_subtable = table->get_subtable(column_index, i);
+                TableRef old_subtable = table->get_subtable(column_index + 1, i);
+                convert_column_to_nullable(env, old_subtable.get(), 0, new_subtable.get(), 0, is_primary_key);
             }
-            j++;
         }
+        else {
+            convert_column_to_nullable(env, table, column_index + 1, table, column_index, is_primary_key);
+        }
+
+        // Cleanup
+        table->remove_column(column_index + 1);
+        table->rename_column(column_index, column_name);
+
+    }
+    CATCH_STD()
+}
 
-        for (size_t i = 0; i < table->size(); ++i) {
-            switch (column_type) { // FIXME: respect user-specified default values
-                case type_String: {
-                    StringData sd = table->get_string(column_index + 1, i);
-                    if (sd == realm::null()) {
-                        table->set_string(column_index, i, "");
+// Convert a tables values to not nullable, but converting all null values to the defaul value for the type
+// Works on both normal table columns and sub tables
+static void convert_column_to_not_nullable(JNIEnv* env, Table* old_table, size_t old_col_ndx, Table* new_table, size_t new_col_ndx, bool is_primary_key)
+{
+    DataType column_type = old_table->get_column_type(old_col_ndx);
+    std::string column_name = old_table->get_column_name(old_col_ndx);
+    if (old_table != new_table) {
+        new_table->add_empty_row(old_table->size());
+    }
+    for (size_t i = 0; i < old_table->size(); ++i) {
+        switch (column_type) { // FIXME: respect user-specified default values
+            case type_String: {
+                StringData sd = old_table->get_string(old_col_ndx, i);
+                if (sd == realm::null()) {
+                    if (is_primary_key) {
+                        THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalState,
+                                             format(c_null_values_cannot_set_required_msg, column_name));
                     }
                     else {
-                        // Payload copy is needed
-                        table->set_string(column_index, i, sd);
+                        new_table->set_string(new_col_ndx, i, "");
                     }
-                    break;
                 }
-                case type_Binary: {
-                    BinaryData bd = table->get_binary(column_index + 1, i);
-                    if (bd.is_null()) {
-                        table->set_binary(column_index, i, BinaryData(""));
+                else {
+                    // Payload copy is needed
+                    if (is_primary_key) {
+                        new_table->set_string_unique(new_col_ndx, i, sd);
                     }
                     else {
-                        // Payload copy is needed
-                        std::vector<char> bd_copy(bd.data(), bd.data() + bd.size());
-                        table->set_binary(column_index, i, BinaryData(bd_copy.data(), bd_copy.size()));
+                        new_table->set_string(new_col_ndx, i, sd);
                     }
-                    break;
                 }
-                case type_Int:
-                    if (table->is_null(column_index + 1, i)) {
-                        table->set_int(column_index, i, 0);
-                    }
-                    else {
-                        table->set_int(column_index, i, table->get_int(column_index + 1, i));
-                    }
-                    break;
-                case type_Bool:
-                    if (table->is_null(column_index + 1, i)) {
-                        table->set_bool(column_index, i, false);
-                    }
-                    else {
-                        table->set_bool(column_index, i, table->get_bool(column_index + 1, i));
-                    }
-                    break;
-                case type_Timestamp:
-                    if (table->is_null(column_index + 1, i)) {
-                        table->set_timestamp(column_index, i, Timestamp(0, 0));
-                    }
-                    else {
-                        table->set_timestamp(column_index, i, table->get_timestamp(column_index + 1, i));
-                    }
-                    break;
-                case type_Float:
-                    if (table->is_null(column_index + 1, i)) {
-                        table->set_float(column_index, i, 0.0);
+                break;
+            }
+            case type_Binary: {
+                BinaryData bd = old_table->get_binary(old_col_ndx, i);
+                if (bd.is_null()) {
+                    new_table->set_binary(new_col_ndx, i, BinaryData("", 0));
+                }
+                else {
+                    // Payload copy is needed
+                    std::vector<char> bd_copy(bd.data(), bd.data() + bd.size());
+                    new_table->set_binary(new_col_ndx, i, BinaryData(bd_copy.data(), bd_copy.size()));
+                }
+                break;
+            }
+            case type_Int:
+                if (old_table->is_null(old_col_ndx, i)) {
+                    if (is_primary_key) {
+                        THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalState,
+                                             format(c_null_values_cannot_set_required_msg, column_name));
                     }
                     else {
-                        table->set_float(column_index, i, table->get_float(column_index + 1, i));
+                        new_table->set_int(new_col_ndx, i, 0);
                     }
-                    break;
-                case type_Double:
-                    if (table->is_null(column_index + 1, i)) {
-                        table->set_double(column_index, i, 0.0);
+                }
+                else {
+                    if (is_primary_key) {
+                        new_table->set_int_unique(new_col_ndx, i, old_table->get_int(old_col_ndx, i));
                     }
                     else {
-                        table->set_double(column_index, i, table->get_double(column_index + 1, i));
+                        new_table->set_int(new_col_ndx, i, old_table->get_int(old_col_ndx, i));
                     }
-                    break;
-                case type_Link:
-                case type_LinkList:
-                case type_Mixed:
-                case type_Table:
-                    // checked previously
-                    break;
-                case type_OldDateTime:
-                    // not used
-                    ThrowException(env, UnsupportedOperation, "The old DateTime type is not supported.");
-                    return;
+                }
+                break;
+            case type_Bool:
+                if (old_table->is_null(old_col_ndx, i)) {
+                    new_table->set_bool(new_col_ndx, i, false);
+                }
+                else {
+                    new_table->set_bool(new_col_ndx, i, old_table->get_bool(old_col_ndx, i));
+                }
+                break;
+            case type_Timestamp:
+                if (old_table->is_null(old_col_ndx, i)) {
+                    new_table->set_timestamp(new_col_ndx, i, Timestamp(0, 0));
+                }
+                else {
+                    new_table->set_timestamp(new_col_ndx, i, old_table->get_timestamp(old_col_ndx, i));
+                }
+                break;
+            case type_Float:
+                if (old_table->is_null(old_col_ndx, i)) {
+                    new_table->set_float(new_col_ndx, i, 0.0);
+                }
+                else {
+                    new_table->set_float(new_col_ndx, i, old_table->get_float(old_col_ndx, i));
+                }
+                break;
+            case type_Double:
+                if (old_table->is_null(old_col_ndx, i)) {
+                    new_table->set_double(new_col_ndx, i, 0.0);
+                }
+                else {
+                    new_table->set_double(new_col_ndx, i, old_table->get_double(old_col_ndx, i));
+                }
+                break;
+            case type_Link:
+            case type_LinkList:
+            case type_Mixed:
+            case type_Table:
+                // checked previously
+                break;
+            case type_OldDateTime:
+                // not used
+                ThrowException(env, UnsupportedOperation, "The old DateTime type is not supported.");
+                return;
+        }
+    }
+}
+
+
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeConvertColumnToNotNullable(JNIEnv* env, jobject obj,
+                                                                                     jlong native_table_ptr,
+                                                                                     jlong j_column_index,
+                                                                                     jboolean is_primary_key)
+{
+    try {
+        Table* table = TBL(native_table_ptr);
+        if (!TBL_AND_COL_INDEX_VALID(env, table, j_column_index)) {
+            return;
+        }
+        if (table->has_shared_type()) {
+            ThrowException(env, UnsupportedOperation, "Not allowed to convert field in subtable.");
+            return;
+        }
+
+        // Exit quickly if column is already non-nullable
+        if (!Java_io_realm_internal_Table_nativeIsColumnNullable(env, obj, native_table_ptr, j_column_index)) {
+            return;
+        }
+
+        size_t column_index = S(j_column_index);
+        std::string column_name = table->get_column_name(column_index);
+        DataType column_type = table->get_column_type(column_index);
+        bool is_subtable = (column_type == DataType::type_Table);
+
+        if (column_type == type_Link || column_type == type_LinkList || column_type == type_Mixed) {
+            ThrowException(env, IllegalArgument, "Wrong type - cannot be converted to nullable.");
+        }
+
+        // 1. Create temporary table
+        create_new_column(table, column_index, false);
+
+        // 2. Move all values
+        if (is_subtable) {
+            for (size_t i = 0; i < table->size(); ++i) {
+                TableRef new_subtable = table->get_subtable(column_index, i);
+                TableRef old_subtable = table->get_subtable(column_index + 1, i);
+                convert_column_to_not_nullable(env, old_subtable.get(), 0, new_subtable.get(), 0, is_primary_key);
             }
         }
-        if (table->has_search_index(column_index + 1)) {
-            table->add_search_index(column_index);
+        else {
+            convert_column_to_not_nullable(env, table, column_index + 1, table, column_index, is_primary_key);
         }
+
+        // 3. Delete old values
         table->remove_column(column_index + 1);
-        table->rename_column(table->get_column_index(tmp_column_name), column_name);
+        table->rename_column(column_index, column_name);
     }
     CATCH_STD()
 }
@@ -473,30 +594,21 @@ JNIEXPORT jint JNICALL Java_io_realm_internal_Table_nativeGetColumnType(JNIEnv*
         return 0;
     }
 
-    return static_cast<jint>(TBL(nativeTablePtr)->get_column_type(S(columnIndex))); // noexcept
+    auto column_type = TBL(nativeTablePtr)->get_column_type(S(columnIndex)); // noexcept
+    if (column_type != type_Table) {
+        // For other than primitive list (including object, object list).
+        return static_cast<jint>(column_type);
+    }
+    // For primitive list
+    // FIXME: Add test in https://github.com/realm/realm-java/pull/5221 before merging to master
+    // FIXME: Add method in Object Store to return a PropertyType.
+    return static_cast<jint>(TBL(nativeTablePtr)->get_descriptor()->get_subdescriptor(S(columnIndex))->get_column_type(S(0))
+                             + io_realm_internal_Property_TYPE_ARRAY); // noexcept
 }
 
 
 // ---------------- Row handling
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeAddEmptyRow(JNIEnv* env, jclass, jlong nativeTablePtr,
-                                                                       jlong rows)
-{
-    Table* pTable = TBL(nativeTablePtr);
-    if (!TABLE_VALID(env, pTable)) {
-        return 0;
-    }
-    if (pTable->get_column_count() < 1) {
-        ThrowException(env, IndexOutOfBounds, concat_stringdata("Table has no columns: ", pTable->get_name()));
-        return 0;
-    }
-    try {
-        return static_cast<jlong>(pTable->add_empty_row(S(rows)));
-    }
-    CATCH_STD()
-    return 0;
-}
-
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMoveLastOver(JNIEnv* env, jobject, jlong nativeTablePtr,
                                                                        jlong rowIndex)
 {
@@ -596,8 +708,13 @@ JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_Table_nativeGetByteArray(JNI
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Binary)) {
         return nullptr;
     }
+    try {
+        realm::BinaryData bin = TBL(nativeTablePtr)->get_binary(S(columnIndex), S(rowIndex));
+        return JavaClassGlobalDef::new_byte_array(env, bin);
+    }
+    CATCH_STD()
 
-    return tbl_GetByteArray<Table>(env, nativeTablePtr, columnIndex, rowIndex); // noexcept
+    return nullptr;
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLink(JNIEnv* env, jobject, jlong nativeTablePtr,
@@ -609,20 +726,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLink(JNIEnv* env,
     return static_cast<jlong>(TBL(nativeTablePtr)->get_link(S(columnIndex), S(rowIndex))); // noexcept
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLinkView(JNIEnv* env, jclass, jlong nativeTablePtr,
-                                                                       jlong columnIndex, jlong rowIndex)
-{
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_LinkList)) {
-        return 0;
-    }
-    try {
-        LinkViewRef* link_view_ptr = new LinkViewRef(TBL(nativeTablePtr)->get_linklist(S(columnIndex), S(rowIndex)));
-        return reinterpret_cast<jlong>(link_view_ptr);
-    }
-    CATCH_STD()
-    return 0;
-}
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetLinkTarget(JNIEnv* env, jobject, jlong nativeTablePtr,
                                                                          jlong columnIndex)
 {
@@ -669,15 +772,21 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLong(JNIEnv* env, j
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetLongUnique(JNIEnv* env, jclass, jlong nativeTablePtr,
-                                                                        jlong columnIndex, jlong rowIndex,
-                                                                        jlong value)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeIncrementLong(JNIEnv* env, jclass, jlong nativeTablePtr,
+                                                                  jlong columnIndex, jlong rowIndex, jlong value)
 {
     if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_Int)) {
         return;
     }
+
     try {
-        TBL(nativeTablePtr)->set_int_unique(S(columnIndex), S(rowIndex), value);
+        Table* table = TBL(nativeTablePtr);
+        if (table->is_null(columnIndex, rowIndex)) {
+            THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalState,
+                                 "Cannot increment a MutableRealmInteger whose value is null. Set its value first.");
+        }
+
+        table->add_int(S(columnIndex), S(rowIndex), value);
     }
     CATCH_STD()
 }
@@ -740,28 +849,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetString(JNIEnv* env,
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetStringUnique(JNIEnv* env, jclass, jlong nativeTablePtr,
-                                                                          jlong columnIndex, jlong rowIndex,
-                                                                          jstring value)
-{
-    if (!TBL_AND_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, rowIndex, type_String)) {
-        return;
-    }
-    try {
-        if (value == nullptr) {
-            if (!TBL_AND_COL_NULLABLE(env, TBL(nativeTablePtr), columnIndex)) {
-                return;
-            }
-            TBL(nativeTablePtr)->set_string_unique(S(columnIndex), S(rowIndex), null{});
-        }
-        else {
-            JStringAccessor value2(env, value); // throws
-            TBL(nativeTablePtr)->set_string_unique(S(columnIndex), S(rowIndex), value2);
-        }
-    }
-    CATCH_STD()
-}
-
 JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetTimestamp(JNIEnv* env, jclass, jlong nativeTablePtr,
                                                                        jlong columnIndex, jlong rowIndex,
                                                                        jlong timestampValue, jboolean isDefault)
@@ -800,8 +887,9 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetByteArray(JNIEnv* e
             return;
         }
 
-        JniByteArray byteAccessor(env, dataArray);
-        TBL(nativeTablePtr)->set_binary(S(columnIndex), S(rowIndex), byteAccessor, B(isDefault));
+        JByteArrayAccessor jarray_accessor(env, dataArray);
+        TBL(nativeTablePtr)
+            ->set_binary(S(columnIndex), S(rowIndex), jarray_accessor.transform<BinaryData>(), B(isDefault));
     }
     CATCH_STD()
 }
@@ -827,27 +915,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetNull(JNIEnv* env, j
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeSetNullUnique(JNIEnv* env, jclass, jlong nativeTablePtr,
-                                                                        jlong columnIndex, jlong rowIndex)
-{
-    Table* pTable = TBL(nativeTablePtr);
-    if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex)) {
-        return;
-    }
-    if (!TBL_AND_ROW_INDEX_VALID(env, pTable, rowIndex)) {
-        return;
-    }
-    if (!TBL_AND_COL_NULLABLE(env, pTable, columnIndex)) {
-        return;
-    }
-
-    try {
-        pTable->set_null_unique(S(columnIndex), S(rowIndex));
-    }
-    CATCH_STD()
-}
-
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetRowPtr(JNIEnv* env, jobject, jlong nativeTablePtr,
                                                                      jlong index)
 {
@@ -1105,117 +1172,8 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstNull(JNIEnv*
 
 // FindAll
 
-
-// FIXME: reenable when find_first_timestamp() is implemented
-/*
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllTimestamp(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong dateTimeValue)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Timestamp))
-        return 0;
-    try {
-        TableView* pTableView = new TableView(TBL(nativeTablePtr)->find_all_timestamp(S(columnIndex),
-from_milliseconds(dateTimeValue)));
-        return reinterpret_cast<jlong>(pTableView);
-    } CATCH_STD()
-    return 0;
-}
-*/
-
-
-// experimental
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeLowerBoundInt(JNIEnv* env, jobject, jlong nativeTablePtr,
-                                                                         jlong columnIndex, jlong value)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int)) {
-        return 0;
-    }
-
-    Table* pTable = TBL(nativeTablePtr);
-    try {
-        return static_cast<jlong>(pTable->lower_bound_int(S(columnIndex), S(value)));
-    }
-    CATCH_STD()
-    return 0;
-}
-
-
-// experimental
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeUpperBoundInt(JNIEnv* env, jobject, jlong nativeTablePtr,
-                                                                         jlong columnIndex, jlong value)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int)) {
-        return 0;
-    }
-
-    Table* pTable = TBL(nativeTablePtr);
-    try {
-        return static_cast<jlong>(pTable->upper_bound_int(S(columnIndex), S(value)));
-    }
-    CATCH_STD()
-    return 0;
-}
-
 //
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti(JNIEnv* env, jobject,
-                                                                              jlong nativeTablePtr,
-                                                                              jlongArray columnIndices,
-                                                                              jbooleanArray ascending)
-{
-    Table* pTable = TBL(nativeTablePtr);
-
-    JniLongArray long_arr(env, columnIndices);
-    JniBooleanArray bool_arr(env, ascending);
-    jsize arr_len = long_arr.len();
-    jsize asc_len = bool_arr.len();
-
-    if (arr_len == 0) {
-        ThrowException(env, IllegalArgument, "You must provide at least one field name.");
-        return 0;
-    }
-    if (asc_len == 0) {
-        ThrowException(env, IllegalArgument, "You must provide at least one sort order.");
-        return 0;
-    }
-    if (arr_len != asc_len) {
-        ThrowException(env, IllegalArgument, "Number of column indices and sort orders do not match.");
-        return 0;
-    }
-
-    std::vector<std::vector<size_t>> indices(S(arr_len));
-    std::vector<bool> ascendings(S(arr_len));
-
-    for (int i = 0; i < arr_len; ++i) {
-        if (!TBL_AND_COL_INDEX_VALID(env, pTable, S(long_arr[i]))) {
-            return 0;
-        }
-        int colType = pTable->get_column_type(S(long_arr[i]));
-        switch (colType) {
-            case type_Int:
-            case type_Bool:
-            case type_String:
-            case type_Double:
-            case type_Float:
-            case type_Timestamp:
-                indices[i] = std::vector<size_t>{S(long_arr[i])};
-                ascendings[i] = S(bool_arr[i]);
-                break;
-            default:
-                ThrowException(env, IllegalArgument, "Sort is only support on String, Date, boolean, byte, short, "
-                                                     "int, long and their boxed variants.");
-                return 0;
-        }
-    }
-
-    try {
-        TableView* pTableView = new TableView(pTable->get_sorted_view(SortDescriptor(*pTable, indices, ascendings)));
-        return reinterpret_cast<jlong>(pTableView);
-    }
-    CATCH_STD()
-    return 0;
-}
-
 JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetName(JNIEnv* env, jobject, jlong nativeTablePtr)
 {
     try {
@@ -1229,151 +1187,32 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeGetName(JNIEnv* env
     return nullptr;
 }
 
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_Table_nativeToJson(JNIEnv* env, jobject, jlong nativeTablePtr)
-{
-    Table* table = TBL(nativeTablePtr);
-    if (!TABLE_VALID(env, table)) {
-        return nullptr;
-    }
-
-    // Write table to string in JSON format
-    try {
-        ostringstream ss;
-        ss.sync_with_stdio(false); // for performance
-        table->to_json(ss);
-        const string str = ss.str();
-        return to_jstring(env, str);
-    }
-    CATCH_STD()
-    return nullptr;
-}
-
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeIsValid(JNIEnv*, jobject, jlong nativeTablePtr)
 {
     TR_ENTER_PTR(nativeTablePtr)
     return to_jbool(TBL(nativeTablePtr)->is_attached()); // noexcept
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_createNative(JNIEnv* env, jobject)
+static bool pk_table_needs_migration(ConstTableRef pk_table)
 {
-    TR_ENTER()
-    try {
-        return reinterpret_cast<jlong>(LangBindHelper::new_table());
-    }
-    CATCH_STD()
-    return 0;
-}
-
-// Checks if the primary key column contains any duplicate values, making it ineligible as a
-// primary key.
-static bool check_valid_primary_key_column(JNIEnv* env, Table* table, StringData column_name) // throws
-{
-    size_t column_index = table->get_column_index(column_name);
-    if (column_index == realm::not_found) {
-        std::ostringstream error_msg;
-        error_msg << table->get_name() << " does not contain the field \"" << column_name << "\"";
-        ThrowException(env, IllegalArgument, error_msg.str());
+    // Fix wrong types (string, int) -> (string, string)
+    if (pk_table->get_column_type(FIELD_COLUMN_INDEX) == type_Int) {
+        return true;
     }
-    DataType column_type = table->get_column_type(column_index);
-    TableView results = table->get_sorted_view(column_index);
-
-    switch (column_type) {
-        case type_Int:
-            if (results.size() > 1) {
-                int64_t val = results.get_int(column_index, 0);
-                for (size_t i = 1; i < results.size(); i++) {
-                    int64_t next_val = results.get_int(column_index, i);
-                    if (val == next_val) {
-                        std::ostringstream error_msg;
-                        error_msg << "Field \"" << column_name << "\" cannot be a primary key, ";
-                        error_msg << "it already contains duplicate values: " << val;
-                        ThrowException(env, IllegalArgument, error_msg.str());
-                        return false;
-                    }
-                    else {
-                        val = next_val;
-                    }
-                }
-            }
-            return true;
 
-        case type_String:
-            if (results.size() > 1) {
-                string str = results.get_string(column_index, 0);
-                for (size_t i = 1; i < results.size(); i++) {
-                    string next_str = results.get_string(column_index, i);
-                    if (str.compare(next_str) == 0) {
-                        std::ostringstream error_msg;
-                        error_msg << "Field \"" << column_name << "\" cannot be a primary key, ";
-                        error_msg << "it already contains duplicate values: " << str;
-                        ThrowException(env, IllegalArgument, error_msg.str());
-                        return false;
-                    }
-                    else {
-                        str = next_str;
-                    }
-                }
-            }
+    // If needed remove "class_" prefix from class names
+    size_t number_of_rows = pk_table->size();
+    for (size_t row_ndx = 0; row_ndx < number_of_rows; row_ndx++) {
+        StringData table_name = pk_table->get_string(CLASS_COLUMN_INDEX, row_ndx);
+        if (table_name.begins_with(TABLE_PREFIX)) {
             return true;
-
-        default:
-            std::ostringstream error_msg;
-            error_msg << "Invalid primary key type for column: " << column_name;
-            ThrowException(env, IllegalArgument, error_msg.str());
-            return false;
-    }
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(JNIEnv* env, jobject,
-                                                                         jlong nativePrivateKeyTablePtr,
-                                                                         jlong nativeTablePtr, jstring columnName)
-{
-    try {
-        Table* table = TBL(nativeTablePtr);
-        Table* pk_table = TBL(nativePrivateKeyTablePtr);
-        const std::string table_name(table->get_name().substr(TABLE_PREFIX.length())); // Remove "class_" prefix
-        size_t row_index =
-            pk_table->find_first_string(io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX, table_name);
-
-        if (columnName == NULL || env->GetStringLength(columnName) == 0) {
-            // No primary key provided => remove previous set keys
-            if (row_index != realm::not_found) {
-                pk_table->remove(row_index);
-            }
-            return io_realm_internal_Table_NO_PRIMARY_KEY;
-        }
-        else {
-            JStringAccessor new_primary_key_column_name(env, columnName);
-            size_t primary_key_column_index = table->get_column_index(new_primary_key_column_name);
-            if (row_index == realm::not_found) {
-                // No primary key is currently set
-                if (check_valid_primary_key_column(env, table, new_primary_key_column_name)) {
-                    row_index = pk_table->add_empty_row();
-                    pk_table->set_string_unique(io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX, row_index,
-                                                table_name);
-                    pk_table->set_string(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_index,
-                                         new_primary_key_column_name);
-                }
-            }
-            else {
-                // Primary key already exists
-                // We only wish to check for duplicate values if a column isn't already a primary key
-                StringData current_primary_key =
-                    pk_table->get_string(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_index);
-                if (new_primary_key_column_name != current_primary_key) {
-                    if (check_valid_primary_key_column(env, table, new_primary_key_column_name)) {
-                        pk_table->set_string(io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX, row_index,
-                                             new_primary_key_column_name);
-                    }
-                }
-            }
-
-            return static_cast<jlong>(primary_key_column_index);
         }
     }
-    CATCH_STD()
-    return 0;
+    // From realm-java 2.0.0, pk table's class column requires a search index.
+    if (!pk_table->has_search_index(CLASS_COLUMN_INDEX)) {
+        return true;
+    }
+    return false;
 }
 
 // 1) Fixes interop issue with Cocoa Realm where the Primary Key table had different types.
@@ -1395,15 +1234,9 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeSetPrimaryKey(JNIEnv*
 
 // This methods converts the old (wrong) table format (string, integer) to the right (string,string) format and strips
 // any class names in the col[0] of their "class_" prefix
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTableIfNeeded(
-    JNIEnv*, jclass, jlong groupNativePtr, jlong privateKeyTableNativePtr)
+static bool migrate_pk_table(const Group& group, TableRef pk_table)
 {
-    const size_t CLASS_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX;
-    const size_t FIELD_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX;
-
-    auto group = reinterpret_cast<Group*>(groupNativePtr);
-    Table* pk_table = TBL(privateKeyTableNativePtr);
-    jboolean changed = JNI_FALSE;
+    bool changed = false;
 
     // Fix wrong types (string, int) -> (string, string)
     if (pk_table->get_column_type(FIELD_COLUMN_INDEX) == type_Int) {
@@ -1415,7 +1248,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyT
         for (size_t row_ndx = 0; row_ndx < number_of_rows; row_ndx++) {
             StringData table_name = pk_table->get_string(CLASS_COLUMN_INDEX, row_ndx);
             size_t col_ndx = static_cast<size_t>(pk_table->get_int(FIELD_COLUMN_INDEX, row_ndx));
-            StringData col_name = group->get_table(table_name)->get_column_name(col_ndx);
+            StringData col_name = group.get_table(table_name)->get_column_name(col_ndx);
             // Make a copy of the string
             pk_table->set_string(tmp_col_ndx, row_ndx, col_name);
         }
@@ -1424,7 +1257,7 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyT
         // The column index for the renamed column will then be the same as the deleted old column
         pk_table->remove_column(FIELD_COLUMN_INDEX);
         pk_table->rename_column(pk_table->get_column_index(tmp_col_name), StringData("pk_property"));
-        changed = JNI_TRUE;
+        changed = true;
     }
 
     // If needed remove "class_" prefix from class names
@@ -1436,45 +1269,42 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyT
             std::string str(table_name.substr(TABLE_PREFIX.length()));
             StringData sd(str);
             pk_table->set_string(CLASS_COLUMN_INDEX, row_ndx, sd);
-            changed = JNI_TRUE;
+            changed = true;
         }
     }
 
     // From realm-java 2.0.0, pk table's class column requires a search index.
     if (!pk_table->has_search_index(CLASS_COLUMN_INDEX)) {
         pk_table->add_search_index(CLASS_COLUMN_INDEX);
-        changed = JNI_TRUE;
+        changed = true;
     }
     return changed;
 }
 
-JNIEXPORT jboolean JNICALL
-Java_io_realm_internal_Table_nativePrimaryKeyTableNeedsMigration(JNIEnv*, jclass, jlong primaryKeyTableNativePtr)
+JNIEXPORT void JNICALL Java_io_realm_internal_Table_nativeMigratePrimaryKeyTableIfNeeded(JNIEnv* env, jclass,
+                                                                                         jlong shared_realm_ptr)
 {
+    TR_ENTER_PTR(shared_realm_ptr)
+    auto& shared_realm = *reinterpret_cast<SharedRealm*>(shared_realm_ptr);
+    try {
+        if (!shared_realm->read_group().has_table(PK_TABLE_NAME)) {
+            return;
+        }
 
-    const size_t CLASS_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_CLASS_COLUMN_INDEX;
-    const size_t FIELD_COLUMN_INDEX = io_realm_internal_Table_PRIMARY_KEY_FIELD_COLUMN_INDEX;
-
-    Table* pk_table = TBL(primaryKeyTableNativePtr);
-
-    // Fix wrong types (string, int) -> (string, string)
-    if (pk_table->get_column_type(FIELD_COLUMN_INDEX) == type_Int) {
-        return JNI_TRUE;
-    }
+        auto pk_table = shared_realm->read_group().get_table(PK_TABLE_NAME);
+        if (!pk_table_needs_migration(pk_table)) {
+            return;
+        }
 
-    // If needed remove "class_" prefix from class names
-    size_t number_of_rows = pk_table->size();
-    for (size_t row_ndx = 0; row_ndx < number_of_rows; row_ndx++) {
-        StringData table_name = pk_table->get_string(CLASS_COLUMN_INDEX, row_ndx);
-        if (table_name.begins_with(TABLE_PREFIX)) {
-            return JNI_TRUE;
+        shared_realm->begin_transaction();
+        if (migrate_pk_table(shared_realm->read_group(), pk_table)) {
+            shared_realm->commit_transaction();
+        }
+        else {
+            shared_realm->cancel_transaction();
         }
     }
-    // From realm-java 2.0.0, pk table's class column requires a search index.
-    if (!pk_table->has_search_index(CLASS_COLUMN_INDEX)) {
-        return JNI_TRUE;
-    }
-    return JNI_FALSE;
+    CATCH_STD()
 }
 
 JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSameSchema(JNIEnv*, jobject, jlong thisTablePtr,
@@ -1483,23 +1313,6 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_Table_nativeHasSameSchema(JNIE
     return to_jbool(*TBL(thisTablePtr)->get_descriptor() == *TBL(otherTablePtr)->get_descriptor());
 }
 
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeVersion(JNIEnv* env, jobject, jlong nativeTablePtr)
-{
-    bool valid = (TBL(nativeTablePtr) != nullptr);
-    if (valid) {
-        if (!TBL(nativeTablePtr)->is_attached()) {
-            ThrowException(env, IllegalState, "The Realm has been closed and is no longer accessible.");
-            return 0;
-        }
-    }
-    try {
-        return static_cast<jlong>(TBL(nativeTablePtr)->get_version_counter());
-    }
-    CATCH_STD()
-    return 0;
-}
-
 static void finalize_table(jlong ptr)
 {
     TR_ENTER_PTR(ptr)
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
index bfa10d391f..d8706d945c 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
@@ -18,15 +18,19 @@
 
 #include <realm.hpp>
 #include <realm/query_expression.hpp>
+#include <realm/table.hpp>
 
 #include <shared_realm.hpp>
 #include <object_store.hpp>
 #include <results.hpp>
 
+#include "java_accessor.hpp"
+#include "java_class_global_def.hpp"
 #include "util.hpp"
 
 using namespace realm;
 using namespace realm::jni_util;
+using namespace realm::_impl;
 
 #if 1
 #define QUERY_COL_TYPE_VALID(env, jPtr, col, type) query_col_type_valid(env, jPtr, col, type)
@@ -62,27 +66,60 @@ JNIEXPORT jstring JNICALL Java_io_realm_internal_TableQuery_nativeValidateQuery(
 // helper functions
 
 // Return TableRef used for build link queries
-static TableRef getTableForLinkQuery(jlong nativeQueryPtr, JniLongArray& indicesArray)
-{
-    TableRef table_ref = Q(nativeQueryPtr)->get_table();
-    jsize link_element_count = indicesArray.len() - 1;
-    for (int i = 0; i < link_element_count; i++) {
-        table_ref->link(size_t(indicesArray[i]));
+// Each element in the indicesArray is the index of a column to be used to link to the next TableRef.
+// If the corresponding entry in tablesArray is anything other than a nullptr, the link is a backlink.
+// In that case, the tablesArray element is the pointer to the backlink source table and the
+// indicesArray entry is the source column index in the source table.
+static TableRef getTableForLinkQuery(jlong nativeQueryPtr, const JLongArrayAccessor& tablesArray,
+                                     const JLongArrayAccessor& indicesArray)
+{
+    auto table_ref = reinterpret_cast<Query *>(nativeQueryPtr)->get_table();
+    jsize link_element_count = indicesArray.size() - 1;
+    for (int i = 0; i < link_element_count; ++i) {
+        auto col_index = size_t(indicesArray[i]);
+        auto table_ptr = reinterpret_cast<Table *>(tablesArray[i]);
+        if (table_ptr == nullptr) {
+            table_ref->link(col_index);
+        }
+        else {
+            table_ref->backlink(*table_ptr, col_index);
+        }
     }
     return table_ref;
 }
 
 // Return TableRef point to original table or the link table
-static TableRef getTableByArray(jlong nativeQueryPtr, JniLongArray& indicesArray)
+static TableRef getTableByArray(jlong nativeQueryPtr, const JLongArrayAccessor& tablesArray,
+                                const JLongArrayAccessor& indicesArray)
 {
-    TableRef table_ref = Q(nativeQueryPtr)->get_table();
-    jsize link_element_count = indicesArray.len() - 1;
-    for (int i = 0; i < link_element_count; i++) {
-        table_ref = table_ref->get_link_target(size_t(indicesArray[i]));
+    auto table_ref = reinterpret_cast<Query *>(nativeQueryPtr)->get_table();
+    jsize link_element_count = indicesArray.size() - 1;
+    for (int i = 0; i < link_element_count; ++i) {
+        auto table_ptr = reinterpret_cast<Table *>(tablesArray[i]);
+        if (table_ptr == nullptr) {
+            table_ref = table_ref->get_link_target(static_cast<size_t>(indicesArray[i]));
+        }
+        else {
+            table_ref = TableRef(table_ptr);
+        }
     }
     return table_ref;
 }
 
+// I am not at all sure that it is even the right idea, let alone correct code. --gbm
+static bool isNullable(JNIEnv* env, Table* src_table_ptr, TableRef table_ref, jlong column_idx)
+{
+    // if table_arr is not a nullptr, this is a backlink and not allowed.
+    if (src_table_ptr != nullptr) {
+        ThrowException(env, IllegalArgument, "LinkingObject from field " + std::string(src_table_ptr->get_column_name(column_idx)) + " is not nullable.");
+        return false;
+    }
+    if (!TBL_AND_COL_NULLABLE(env, table_ref.get(), column_idx)) {
+        return false;
+    }
+    return true;
+}
+
 template <typename coretype, typename cpptype, typename javatype>
 Query numeric_link_equal(TableRef tbl, jlong columnIndex, javatype value)
 {
@@ -122,132 +159,144 @@ Query numeric_link_lessequal(TableRef tbl, jlong columnIndex, javatype value)
 
 // Integer
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JJ(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3J_3JJ(JNIEnv* env, jobject,
                                                                             jlong nativeQueryPtr,
-                                                                            jlongArray columnIndexes, jlong value)
+                                                                            jlongArray columnIndexes,
+                                                                            jlongArray tablePointers, jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Int)) {
                 return;
             }
-            Q(nativeQueryPtr)->equal(S(arr[0]), static_cast<int64_t>(value));
+            Q(nativeQueryPtr)->equal(S(index_arr[0]), static_cast<int64_t>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_equal<Int, int64_t, jlong>(table_ref, arr[arr_len - 1], value));
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_equal<Int, int64_t, jlong>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JJ(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3J_3JJ(JNIEnv* env, jobject,
                                                                                        jlong nativeQueryPtr,
                                                                                        jlongArray columnIndexes,
+                                                                                       jlongArray tablePointers,
                                                                                        jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Int)) {
                 return;
             }
-            Q(nativeQueryPtr)->not_equal(S(arr[0]), static_cast<int64_t>(value));
+            Q(nativeQueryPtr)->not_equal(S(index_arr[0]), static_cast<int64_t>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_notequal<Int, int64_t, jlong>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_notequal<Int, int64_t, jlong>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JJ(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3J_3JJ(JNIEnv* env, jobject,
                                                                               jlong nativeQueryPtr,
-                                                                              jlongArray columnIndexes, jlong value)
+                                                                              jlongArray columnIndexes,
+                                                                              jlongArray tablePointers, jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Int)) {
                 return;
             }
-            Q(nativeQueryPtr)->greater(S(arr[0]), static_cast<int64_t>(value));
+            Q(nativeQueryPtr)->greater(S(index_arr[0]), static_cast<int64_t>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_greater<Int, int64_t, jlong>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_greater<Int, int64_t, jlong>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JJ(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3J_3JJ(JNIEnv* env, jobject,
                                                                                    jlong nativeQueryPtr,
                                                                                    jlongArray columnIndexes,
+                                                                                   jlongArray tablePointers,
                                                                                    jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Int)) {
                 return;
             }
-            Q(nativeQueryPtr)->greater_equal(S(arr[0]), static_cast<int64_t>(value));
+            Q(nativeQueryPtr)->greater_equal(S(index_arr[0]), static_cast<int64_t>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_greaterequal<Int, int64_t, jlong>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_greaterequal<Int, int64_t, jlong>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JJ(JNIEnv* env, jobject, jlong nativeQueryPtr,
-                                                                           jlongArray columnIndexes, jlong value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3J_3JJ(JNIEnv* env, jobject, jlong nativeQueryPtr,
+                                                                           jlongArray columnIndexes,
+                                                                           jlongArray tablePointers, jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Int)) {
                 return;
             }
-            Q(nativeQueryPtr)->less(S(arr[0]), static_cast<int64_t>(value));
+            Q(nativeQueryPtr)->less(S(index_arr[0]), static_cast<int64_t>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_less<Int, int64_t, jlong>(table_ref, arr[arr_len - 1], value));
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_less<Int, int64_t, jlong>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JJ(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3J_3JJ(JNIEnv* env, jobject,
                                                                                 jlong nativeQueryPtr,
-                                                                                jlongArray columnIndexes, jlong value)
+                                                                                jlongArray columnIndexes,
+                                                                                jlongArray tablePointers, jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Int)) {
                 return;
             }
-            Q(nativeQueryPtr)->less_equal(S(arr[0]), static_cast<int64_t>(value));
+            Q(nativeQueryPtr)->less_equal(S(index_arr[0]), static_cast<int64_t>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_lessequal<Int, int64_t, jlong>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_lessequal<Int, int64_t, jlong>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
@@ -258,8 +307,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JJJ(J
                                                                                jlongArray columnIndexes, jlong value1,
                                                                                jlong value2)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor arr(env, columnIndexes);
+    jsize arr_len = arr.size();
     if (arr_len == 1) {
         if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Int)) {
             return;
@@ -276,134 +325,146 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JJJ(J
 
 // Float
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JF(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3J_3JF(JNIEnv* env, jobject,
                                                                             jlong nativeQueryPtr,
-                                                                            jlongArray columnIndexes, jfloat value)
+                                                                            jlongArray columnIndexes,
+                                                                            jlongArray tablePointers, jfloat value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Float)) {
                 return;
             }
-            Q(nativeQueryPtr)->equal(S(arr[0]), static_cast<float>(value));
+            Q(nativeQueryPtr)->equal(S(index_arr[0]), static_cast<float>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_equal<Float, float, jfloat>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_equal<Float, float, jfloat>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JF(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3J_3JF(JNIEnv* env, jobject,
                                                                                        jlong nativeQueryPtr,
                                                                                        jlongArray columnIndexes,
+                                                                                       jlongArray tablePointers,
                                                                                        jfloat value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Float)) {
                 return;
             }
-            Q(nativeQueryPtr)->not_equal(S(arr[0]), static_cast<float>(value));
+            Q(nativeQueryPtr)->not_equal(S(index_arr[0]), static_cast<float>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_notequal<Float, float, jfloat>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_notequal<Float, float, jfloat>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JF(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3J_3JF(JNIEnv* env, jobject,
                                                                               jlong nativeQueryPtr,
-                                                                              jlongArray columnIndexes, jfloat value)
+                                                                              jlongArray columnIndexes,
+                                                                              jlongArray tablePointers, jfloat value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Float)) {
                 return;
             }
-            Q(nativeQueryPtr)->greater(S(arr[0]), static_cast<float>(value));
+            Q(nativeQueryPtr)->greater(S(index_arr[0]), static_cast<float>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_greater<Float, float, jfloat>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_greater<Float, float, jfloat>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JF(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3J_3JF(JNIEnv* env, jobject,
                                                                                    jlong nativeQueryPtr,
                                                                                    jlongArray columnIndexes,
+                                                                                   jlongArray tablePointers,
                                                                                    jfloat value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Float)) {
                 return;
             }
-            Q(nativeQueryPtr)->greater_equal(S(arr[0]), static_cast<float>(value));
+            Q(nativeQueryPtr)->greater_equal(S(index_arr[0]), static_cast<float>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_greaterequal<Float, float, jfloat>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_greaterequal<Float, float, jfloat>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JF(JNIEnv* env, jobject, jlong nativeQueryPtr,
-                                                                           jlongArray columnIndexes, jfloat value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3J_3JF(JNIEnv* env, jobject, jlong nativeQueryPtr,
+                                                                           jlongArray columnIndexes,
+                                                                           jlongArray tablePointers, jfloat value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Float)) {
                 return;
             }
-            Q(nativeQueryPtr)->less(S(arr[0]), static_cast<float>(value));
+            Q(nativeQueryPtr)->less(S(index_arr[0]), static_cast<float>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-            Q(nativeQueryPtr)->and_query(numeric_link_less<Float, float, jfloat>(table_ref, arr[arr_len - 1], value));
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
+            Q(nativeQueryPtr)->and_query(numeric_link_less<Float, float, jfloat>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JF(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3J_3JF(JNIEnv* env, jobject,
                                                                                 jlong nativeQueryPtr,
                                                                                 jlongArray columnIndexes,
+                                                                                jlongArray tablePointers,
                                                                                 jfloat value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Float)) {
                 return;
             }
-            Q(nativeQueryPtr)->less_equal(S(arr[0]), static_cast<float>(value));
+            Q(nativeQueryPtr)->less_equal(S(index_arr[0]), static_cast<float>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_lessequal<Float, float, jfloat>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_lessequal<Float, float, jfloat>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
@@ -414,8 +475,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JFF(J
                                                                                jlongArray columnIndexes,
                                                                                jfloat value1, jfloat value2)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor arr(env, columnIndexes);
+    jsize arr_len = arr.size();
     try {
         if (arr_len == 1) {
             if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Float)) {
@@ -433,135 +494,147 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JFF(J
 
 // Double
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JD(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3J_3JD(JNIEnv* env, jobject,
                                                                             jlong nativeQueryPtr,
-                                                                            jlongArray columnIndexes, jdouble value)
+                                                                            jlongArray columnIndexes,
+                                                                            jlongArray tablePointers, jdouble value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Double)) {
                 return;
             }
-            Q(nativeQueryPtr)->equal(S(arr[0]), static_cast<double>(value));
+            Q(nativeQueryPtr)->equal(S(index_arr[0]), static_cast<double>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_equal<Double, double, jdouble>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_equal<Double, double, jdouble>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JD(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3J_3JD(JNIEnv* env, jobject,
                                                                                        jlong nativeQueryPtr,
                                                                                        jlongArray columnIndexes,
+                                                                                       jlongArray tablePointers,
                                                                                        jdouble value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Double)) {
                 return;
             }
-            Q(nativeQueryPtr)->not_equal(S(arr[0]), static_cast<double>(value));
+            Q(nativeQueryPtr)->not_equal(S(index_arr[0]), static_cast<double>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_notequal<Double, double, jdouble>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_notequal<Double, double, jdouble>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3JD(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreater__J_3J_3JD(JNIEnv* env, jobject,
                                                                               jlong nativeQueryPtr,
-                                                                              jlongArray columnIndexes, jdouble value)
+                                                                              jlongArray columnIndexes,
+                                                                              jlongArray tablePointers, jdouble value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Double)) {
                 return;
             }
-            Q(nativeQueryPtr)->greater(S(arr[0]), static_cast<double>(value));
+            Q(nativeQueryPtr)->greater(S(index_arr[0]), static_cast<double>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_greater<Double, double, jdouble>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_greater<Double, double, jdouble>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3JD(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqual__J_3J_3JD(JNIEnv* env, jobject,
                                                                                    jlong nativeQueryPtr,
                                                                                    jlongArray columnIndexes,
+                                                                                   jlongArray tablePointers,
                                                                                    jdouble value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Double)) {
                 return;
             }
-            Q(nativeQueryPtr)->greater_equal(S(arr[0]), static_cast<double>(value));
+            Q(nativeQueryPtr)->greater_equal(S(index_arr[0]), static_cast<double>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_greaterequal<Double, double, jdouble>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_greaterequal<Double, double, jdouble>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3JD(JNIEnv* env, jobject, jlong nativeQueryPtr,
-                                                                           jlongArray columnIndexes, jdouble value)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLess__J_3J_3JD(JNIEnv* env, jobject, jlong nativeQueryPtr,
+                                                                           jlongArray columnIndexes,
+                                                                           jlongArray tablePointers, jdouble value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Double)) {
                 return;
             }
-            Q(nativeQueryPtr)->less(S(arr[0]), static_cast<double>(value));
+            Q(nativeQueryPtr)->less(S(index_arr[0]), static_cast<double>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_less<Double, double, jdouble>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_less<Double, double, jdouble>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3JD(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqual__J_3J_3JD(JNIEnv* env, jobject,
                                                                                 jlong nativeQueryPtr,
                                                                                 jlongArray columnIndexes,
+                                                                                jlongArray tablePointers,
                                                                                 jdouble value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Double)) {
                 return;
             }
-            Q(nativeQueryPtr)->less_equal(S(arr[0]), static_cast<double>(value));
+            Q(nativeQueryPtr)->less_equal(S(index_arr[0]), static_cast<double>(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_lessequal<Double, double, jdouble>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_lessequal<Double, double, jdouble>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
@@ -572,8 +645,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JDD(J
                                                                                jlongArray columnIndexes,
                                                                                jdouble value1, jdouble value2)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor arr(env, columnIndexes);
+    jsize arr_len = arr.size();
     try {
         if (arr_len == 1) {
             if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Double)) {
@@ -593,21 +666,23 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetween__J_3JDD(J
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqualTimestamp(JNIEnv* env, jobject,
                                                                               jlong nativeQueryPtr,
-                                                                              jlongArray columnIndexes, jlong value)
+                                                                              jlongArray columnIndexes,
+                                                                              jlongArray tablePointers, jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->equal(S(arr[0]), from_milliseconds(value));
+            Q(nativeQueryPtr)->equal(S(index_arr[0]), from_milliseconds(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_equal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len - 1],
+                ->and_query(numeric_link_equal<Timestamp, Timestamp, Timestamp>(table_ref, index_arr[arr_len - 1],
                                                                                 from_milliseconds(value)));
         }
     }
@@ -617,21 +692,23 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqualTimestamp(JN
 JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqualTimestamp(JNIEnv* env, jobject,
                                                                                          jlong nativeQueryPtr,
                                                                                          jlongArray columnIndexes,
+                                                                                         jlongArray tablePointers,
                                                                                          jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->not_equal(S(arr[0]), from_milliseconds(value));
+            Q(nativeQueryPtr)->not_equal(S(index_arr[0]), from_milliseconds(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_notequal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len - 1],
+                ->and_query(numeric_link_notequal<Timestamp, Timestamp, Timestamp>(table_ref, index_arr[arr_len - 1],
                                                                                    from_milliseconds(value)));
         }
     }
@@ -640,21 +717,23 @@ JNIEXPORT void JNICALL JNICALL Java_io_realm_internal_TableQuery_nativeNotEqualT
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterTimestamp(JNIEnv* env, jobject,
                                                                                 jlong nativeQueryPtr,
-                                                                                jlongArray columnIndexes, jlong value)
+                                                                                jlongArray columnIndexes,
+                                                                                jlongArray tablePointers, jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->greater(S(arr[0]), from_milliseconds(value));
+            Q(nativeQueryPtr)->greater(S(index_arr[0]), from_milliseconds(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_greater<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len - 1],
+                ->and_query(numeric_link_greater<Timestamp, Timestamp, Timestamp>(table_ref, index_arr[arr_len - 1],
                                                                                   from_milliseconds(value)));
         }
     }
@@ -664,21 +743,23 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterTimestamp(
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqualTimestamp(JNIEnv* env, jobject,
                                                                                      jlong nativeQueryPtr,
                                                                                      jlongArray columnIndexes,
+                                                                                     jlongArray tablePointers,
                                                                                      jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->greater_equal(S(arr[0]), from_milliseconds(value));
+            Q(nativeQueryPtr)->greater_equal(S(index_arr[0]), from_milliseconds(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_greaterequal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len - 1],
+                ->and_query(numeric_link_greaterequal<Timestamp, Timestamp, Timestamp>(table_ref, index_arr[arr_len - 1],
                                                                                        from_milliseconds(value)));
         }
     }
@@ -687,21 +768,23 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGreaterEqualTimes
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessTimestamp(JNIEnv* env, jobject,
                                                                              jlong nativeQueryPtr,
-                                                                             jlongArray columnIndexes, jlong value)
+                                                                             jlongArray columnIndexes,
+                                                                             jlongArray tablePointers, jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->less(S(arr[0]), from_milliseconds(value));
+            Q(nativeQueryPtr)->less(S(index_arr[0]), from_milliseconds(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_less<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len - 1],
+                ->and_query(numeric_link_less<Timestamp, Timestamp, Timestamp>(table_ref, index_arr[arr_len - 1],
                                                                                from_milliseconds(value)));
         }
     }
@@ -711,21 +794,23 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessTimestamp(JNI
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLessEqualTimestamp(JNIEnv* env, jobject,
                                                                                   jlong nativeQueryPtr,
                                                                                   jlongArray columnIndexes,
+                                                                                  jlongArray tablePointers,
                                                                                   jlong value)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Timestamp)) {
                 return;
             }
-            Q(nativeQueryPtr)->less_equal(S(arr[0]), from_milliseconds(value));
+            Q(nativeQueryPtr)->less_equal(S(index_arr[0]), from_milliseconds(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_lessequal<Timestamp, Timestamp, Timestamp>(table_ref, arr[arr_len - 1],
+                ->and_query(numeric_link_lessequal<Timestamp, Timestamp, Timestamp>(table_ref, index_arr[arr_len - 1],
                                                                                     from_milliseconds(value)));
         }
     }
@@ -737,8 +822,8 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetweenTimestamp(
                                                                                 jlongArray columnIndexes,
                                                                                 jlong value1, jlong value2)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor arr(env, columnIndexes);
+    jsize arr_len = arr.size();
     try {
         if (arr_len == 1) {
             if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Timestamp)) {
@@ -757,24 +842,25 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBetweenTimestamp(
 
 // Bool
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JZ(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3J_3JZ(JNIEnv* env, jobject,
                                                                             jlong nativeQueryPtr,
-                                                                            jlongArray columnIndexes, jboolean value)
+                                                                            jlongArray columnIndexes,
+                                                                            jlongArray tablePointers, jboolean value)
 {
-    JniLongArray arr(env, columnIndexes);
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
-        jsize arr_len = arr.len();
-
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Bool)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Bool)) {
                 return;
             }
-            Q(nativeQueryPtr)->equal(S(arr[0]), value != 0 ? true : false);
+            Q(nativeQueryPtr)->equal(S(index_arr[0]), to_bool(value));
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
+            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
             Q(nativeQueryPtr)
-                ->and_query(numeric_link_equal<Bool, bool, jboolean>(table_ref, arr[arr_len - 1], value));
+                ->and_query(numeric_link_equal<Bool, bool, jboolean>(table_ref, index_arr[arr_len - 1], value));
         }
     }
     CATCH_STD()
@@ -785,75 +871,77 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JZ(JNIE
 enum StringPredicate { StringEqual, StringNotEqual, StringContains, StringBeginsWith, StringEndsWith, StringLike };
 
 
-static void TableQuery_StringPredicate(JNIEnv* env, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value,
+static void TableQuery_StringPredicate(JNIEnv* env, jlong nativeQueryPtr, jlongArray columnIndexes,
+                                       jlongArray tablePointers, jstring value,
                                        jboolean caseSensitive, StringPredicate predicate)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     try {
+        TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
         if (value == NULL) {
-            if (!TBL_AND_COL_NULLABLE(env, getTableByArray(nativeQueryPtr, arr).get(), arr[arr_len - 1])) {
+            if (!TBL_AND_COL_NULLABLE(env, table_ref.get(), index_arr[arr_len - 1])) {
                 return;
             }
         }
-        bool is_case_sensitive = caseSensitive ? true : false;
+        bool is_case_sensitive = to_bool(caseSensitive);
         JStringAccessor value2(env, value); // throws
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_String)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_String)) {
                 return;
             }
             switch (predicate) {
                 case StringEqual:
-                    Q(nativeQueryPtr)->equal(S(arr[0]), value2, is_case_sensitive);
+                    Q(nativeQueryPtr)->equal(S(index_arr[0]), value2, is_case_sensitive);
                     break;
                 case StringNotEqual:
-                    Q(nativeQueryPtr)->not_equal(S(arr[0]), value2, is_case_sensitive);
+                    Q(nativeQueryPtr)->not_equal(S(index_arr[0]), value2, is_case_sensitive);
                     break;
                 case StringContains:
-                    Q(nativeQueryPtr)->contains(S(arr[0]), value2, is_case_sensitive);
+                    Q(nativeQueryPtr)->contains(S(index_arr[0]), value2, is_case_sensitive);
                     break;
                 case StringBeginsWith:
-                    Q(nativeQueryPtr)->begins_with(S(arr[0]), value2, is_case_sensitive);
+                    Q(nativeQueryPtr)->begins_with(S(index_arr[0]), value2, is_case_sensitive);
                     break;
                 case StringEndsWith:
-                    Q(nativeQueryPtr)->ends_with(S(arr[0]), value2, is_case_sensitive);
+                    Q(nativeQueryPtr)->ends_with(S(index_arr[0]), value2, is_case_sensitive);
                     break;
                 case StringLike:
-                    Q(nativeQueryPtr)->like(S(arr[0]), value2, is_case_sensitive);
+                    Q(nativeQueryPtr)->like(S(index_arr[0]), value2, is_case_sensitive);
                     break;
             }
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
             switch (predicate) {
                 case StringEqual:
                     Q(nativeQueryPtr)
-                        ->and_query(table_ref->column<String>(size_t(arr[arr_len - 1]))
+                        ->and_query(table_ref->column<String>(size_t(index_arr[arr_len - 1]))
                                         .equal(StringData(value2), is_case_sensitive));
                     break;
                 case StringNotEqual:
                     Q(nativeQueryPtr)
-                        ->and_query(table_ref->column<String>(size_t(arr[arr_len - 1]))
+                        ->and_query(table_ref->column<String>(size_t(index_arr[arr_len - 1]))
                                         .not_equal(StringData(value2), is_case_sensitive));
                     break;
                 case StringContains:
                     Q(nativeQueryPtr)
-                        ->and_query(table_ref->column<String>(size_t(arr[arr_len - 1]))
+                        ->and_query(table_ref->column<String>(size_t(index_arr[arr_len - 1]))
                                         .contains(StringData(value2), is_case_sensitive));
                     break;
                 case StringBeginsWith:
                     Q(nativeQueryPtr)
-                        ->and_query(table_ref->column<String>(size_t(arr[arr_len - 1]))
+                        ->and_query(table_ref->column<String>(size_t(index_arr[arr_len - 1]))
                                         .begins_with(StringData(value2), is_case_sensitive));
                     break;
                 case StringEndsWith:
                     Q(nativeQueryPtr)
-                        ->and_query(table_ref->column<String>(size_t(arr[arr_len - 1]))
+                        ->and_query(table_ref->column<String>(size_t(index_arr[arr_len - 1]))
                                         .ends_with(StringData(value2), is_case_sensitive));
                     break;
                 case StringLike:
                     Q(nativeQueryPtr)
-                        ->and_query(table_ref->column<String>(size_t(arr[arr_len - 1]))
+                        ->and_query(table_ref->column<String>(size_t(index_arr[arr_len - 1]))
                                         .like(StringData(value2), is_case_sensitive));
                     break;
             }
@@ -862,93 +950,94 @@ static void TableQuery_StringPredicate(JNIEnv* env, jlong nativeQueryPtr, jlongA
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3JLjava_lang_String_2Z(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3J_3JLjava_lang_String_2Z(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes,
+    jlongArray tablePointers, jstring value, jboolean caseSensitive)
 {
-    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringEqual);
+    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, tablePointers, value, caseSensitive, StringEqual);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3JLjava_lang_String_2Z(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes, jstring value, jboolean caseSensitive)
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3J_3JLjava_lang_String_2Z(
+    JNIEnv* env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes,
+    jlongArray tablePointers, jstring value, jboolean caseSensitive)
 {
-    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringNotEqual);
+    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, tablePointers, value, caseSensitive, StringNotEqual);
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeBeginsWith(JNIEnv* env, jobject, jlong nativeQueryPtr,
-                                                                          jlongArray columnIndexes, jstring value,
+                                                                          jlongArray columnIndexes,
+                                                                          jlongArray tablePointers, jstring value,
                                                                           jboolean caseSensitive)
 {
-    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringBeginsWith);
+    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, tablePointers, value, caseSensitive, StringBeginsWith);
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEndsWith(JNIEnv* env, jobject, jlong nativeQueryPtr,
-                                                                        jlongArray columnIndexes, jstring value,
+                                                                        jlongArray columnIndexes,
+                                                                        jlongArray tablePointers, jstring value,
                                                                         jboolean caseSensitive)
 {
-    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringEndsWith);
+    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, tablePointers, value, caseSensitive, StringEndsWith);
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeLike(JNIEnv* env, jobject, jlong nativeQueryPtr,
-                                                                    jlongArray columnIndexes, jstring value,
+                                                                    jlongArray columnIndexes,
+                                                                    jlongArray tablePointers, jstring value,
                                                                     jboolean caseSensitive)
 {
-    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringLike);
+    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, tablePointers, value, caseSensitive, StringLike);
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeContains(JNIEnv* env, jobject, jlong nativeQueryPtr,
-                                                                        jlongArray columnIndexes, jstring value,
+                                                                        jlongArray columnIndexes,
+                                                                        jlongArray tablePointers, jstring value,
                                                                         jboolean caseSensitive)
 {
-    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, value, caseSensitive, StringContains);
+    TableQuery_StringPredicate(env, nativeQueryPtr, columnIndexes, tablePointers, value, caseSensitive, StringContains);
 }
 
 // Binary
 
 enum BinaryPredicate { BinaryEqual, BinaryNotEqual };
 
-static void TableQuery_BinaryPredicate(JNIEnv* env, jlong nativeQueryPtr, jlongArray columnIndices, jbyteArray value,
-                                       BinaryPredicate predicate)
+static void TableQuery_BinaryPredicate(JNIEnv* env, jlong nativeQueryPtr, jlongArray columnIndexes,
+                                       jlongArray tablePointers, jbyteArray value, BinaryPredicate predicate)
 {
-    JniLongArray arr(env, columnIndices);
-    jsize arr_len = arr.len();
     try {
-        JniByteArray bytes(env, value);
-        BinaryData value2;
-        if (value == NULL) {
-            if (!TBL_AND_COL_NULLABLE(env, getTableByArray(nativeQueryPtr, arr).get(), arr[arr_len - 1])) {
-                return;
-            }
-            value2 = BinaryData();
-        }
-        else {
-            if (!bytes.ptr()) {
-                ThrowException(env, IllegalArgument, "binaryPredicate");
-                return;
-            }
-            value2 = BinaryData(reinterpret_cast<char*>(bytes.ptr()), S(bytes.len()));
+        JLongArrayAccessor table_arr(env, tablePointers);
+        JLongArrayAccessor index_arr(env, columnIndexes);
+        jsize arr_len = index_arr.size();
+        TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
+
+        if (value == NULL && !TBL_AND_COL_NULLABLE(env, table_ref.get(), index_arr[arr_len - 1])) {
+            return;
         }
 
+        JByteArrayAccessor jarray_accessor(env, value);
         if (arr_len == 1) {
-            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, arr[0], type_Binary)) {
+            if (!QUERY_COL_TYPE_VALID(env, nativeQueryPtr, index_arr[0], type_Binary)) {
                 return;
             }
             switch (predicate) {
                 case BinaryEqual:
-                    Q(nativeQueryPtr)->equal(S(arr[0]), value2);
+                    Q(nativeQueryPtr)->equal(S(index_arr[0]), jarray_accessor.transform<BinaryData>());
                     break;
                 case BinaryNotEqual:
-                    Q(nativeQueryPtr)->not_equal(S(arr[0]), value2);
+                    Q(nativeQueryPtr)->not_equal(S(index_arr[0]), jarray_accessor.transform<BinaryData>());
                     break;
             }
         }
         else {
-            TableRef table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
             switch (predicate) {
                 case BinaryEqual:
-                    Q(nativeQueryPtr)->and_query(table_ref->column<Binary>(size_t(arr[arr_len - 1])) == value2);
+                    Q(nativeQueryPtr)
+                        ->and_query(table_ref->column<Binary>(size_t(index_arr[arr_len - 1])) ==
+                                    jarray_accessor.transform<BinaryData>());
                     break;
                 case BinaryNotEqual:
-                    Q(nativeQueryPtr)->and_query(table_ref->column<Binary>(size_t(arr[arr_len - 1])) != value2);
+                    Q(nativeQueryPtr)
+                        ->and_query(table_ref->column<Binary>(size_t(index_arr[arr_len - 1])) !=
+                                    jarray_accessor.transform<BinaryData>());
                     break;
             }
         }
@@ -956,20 +1045,22 @@ static void TableQuery_BinaryPredicate(JNIEnv* env, jlong nativeQueryPtr, jlongA
     CATCH_STD()
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3J_3B(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeEqual__J_3J_3J_3B(JNIEnv* env, jobject,
                                                                               jlong nativeQueryPtr,
                                                                               jlongArray columnIndices,
+                                                                              jlongArray tablePointers,
                                                                               jbyteArray value)
 {
-    TableQuery_BinaryPredicate(env, nativeQueryPtr, columnIndices, value, BinaryEqual);
+    TableQuery_BinaryPredicate(env, nativeQueryPtr, columnIndices, tablePointers, value, BinaryEqual);
 }
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3J_3B(JNIEnv* env, jobject,
+JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3J_3J_3B(JNIEnv* env, jobject,
                                                                                  jlong nativeQueryPtr,
                                                                                  jlongArray columnIndices,
+                                                                                 jlongArray tablePointers,
                                                                                  jbyteArray value)
 {
-    TableQuery_BinaryPredicate(env, nativeQueryPtr, columnIndices, value, BinaryNotEqual);
+    TableQuery_BinaryPredicate(env, nativeQueryPtr, columnIndices, tablePointers, value, BinaryNotEqual);
 }
 
 // General ----------------------------------------------------
@@ -1103,7 +1194,7 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumInt(JNI
         size_t return_ndx;
         int64_t result = pQuery->maximum_int(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
         if (return_ndx != npos) {
-            return NewLong(env, result);
+            return JavaClassGlobalDef::new_long(env, result);
         }
     }
     CATCH_STD()
@@ -1124,7 +1215,7 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumInt(JNI
         size_t return_ndx;
         int64_t result = pQuery->minimum_int(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
         if (return_ndx != npos) {
-            return NewLong(env, result);
+            return JavaClassGlobalDef::new_long(env, result);
         }
     }
     CATCH_STD()
@@ -1187,7 +1278,7 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumFloat(J
         size_t return_ndx;
         float result = pQuery->maximum_float(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
         if (return_ndx != npos) {
-            return NewFloat(env, result);
+            return JavaClassGlobalDef::new_float(env, result);
         }
     }
     CATCH_STD()
@@ -1209,7 +1300,7 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumFloat(J
         size_t return_ndx;
         float result = pQuery->minimum_float(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
         if (return_ndx != npos) {
-            return NewFloat(env, result);
+            return JavaClassGlobalDef::new_float(env, result);
         }
     }
     CATCH_STD()
@@ -1270,7 +1361,7 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumDouble(
         size_t return_ndx;
         double result = pQuery->maximum_double(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
         if (return_ndx != npos) {
-            return NewDouble(env, result);
+            return JavaClassGlobalDef::new_double(env, result);
         }
     }
     CATCH_STD()
@@ -1292,7 +1383,7 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumDouble(
         size_t return_ndx;
         double result = pQuery->minimum_double(S(columnIndex), NULL, S(start), S(end), S(limit), &return_ndx);
         if (return_ndx != npos) {
-            return NewDouble(env, result);
+            return JavaClassGlobalDef::new_double(env, result);
         }
     }
     CATCH_STD()
@@ -1338,7 +1429,7 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMaximumTimesta
         size_t return_ndx;
         Timestamp result = pQuery->find_all().maximum_timestamp(S(columnIndex), &return_ndx);
         if (return_ndx != npos && !result.is_null()) {
-            return NewLong(env, to_milliseconds(result));
+            return JavaClassGlobalDef::new_long(env, to_milliseconds(result));
         }
     }
     CATCH_STD()
@@ -1360,7 +1451,7 @@ JNIEXPORT jobject JNICALL Java_io_realm_internal_TableQuery_nativeMinimumTimesta
         size_t return_ndx;
         Timestamp result = pQuery->find_all().minimum_timestamp(S(columnIndex), &return_ndx);
         if (return_ndx != npos && !result.is_null()) {
-            return NewLong(env, to_milliseconds(result));
+            return JavaClassGlobalDef::new_long(env, to_milliseconds(result));
         }
     }
     CATCH_STD()
@@ -1400,21 +1491,24 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeRemove(JNIEnv* e
 // isNull and isNotNull
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(JNIEnv* env, jobject, jlong nativeQueryPtr,
-                                                                      jlongArray columnIndexes)
+                                                                      jlongArray columnIndexes,
+                                                                      jlongArray tablePointers)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
-    Query* pQuery = Q(nativeQueryPtr);
-
     try {
-        TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-        jlong column_idx = arr[arr_len - 1];
-        TableRef table_ref = getTableByArray(nativeQueryPtr, arr);
-        if (!TBL_AND_COL_NULLABLE(env, table_ref.get(), column_idx)) {
+        JLongArrayAccessor table_arr(env, tablePointers);
+        JLongArrayAccessor index_arr(env, columnIndexes);
+        jsize arr_len = index_arr.size();
+        auto pQuery = reinterpret_cast<Query *>(nativeQueryPtr);
+
+        jlong column_idx = index_arr[arr_len - 1];
+
+        TableRef table_ref = getTableByArray(nativeQueryPtr, table_arr, index_arr);
+        if (!isNullable(env, reinterpret_cast<Table *>(table_arr[arr_len - 1]), table_ref, column_idx)) {
             return;
         }
 
-        int col_type = table_ref->get_column_type(S(column_idx));
+        TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
+        DataType col_type = table_ref->get_column_type(S(column_idx));
         if (arr_len == 1) {
             switch (col_type) {
                 case type_Link:
@@ -1477,65 +1571,25 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(JNIEnv* en
     CATCH_STD()
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverRowIntoSharedGroup(
-    JNIEnv* env, jclass, jlong handoverPtr, jlong callerSharedGrpPtr)
-{
-    TR_ENTER_PTR(handoverPtr)
-    SharedGroup::Handover<Row>* handoverRowPtr = HO(Row, handoverPtr);
-    std::unique_ptr<SharedGroup::Handover<Row>> handoverRow(handoverRowPtr);
-
-    try {
-        // import_from_handover will free (delete) the handover
-        auto sharedRealm = *(reinterpret_cast<SharedRealm*>(callerSharedGrpPtr));
-        if (!sharedRealm->is_closed()) {
-            using rf = realm::_impl::RealmFriend;
-            auto row = rf::get_shared_group(*sharedRealm).import_from_handover(std::move(handoverRow));
-            return reinterpret_cast<jlong>(row.release());
-        }
-        else {
-            ThrowException(env, RuntimeError, ERR_IMPORT_CLOSED_REALM);
-        }
-    }
-    CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeHandoverQuery(JNIEnv* env, jobject,
-                                                                              jlong bgSharedRealmPtr,
-                                                                              jlong nativeQueryPtr)
-{
-    TR_ENTER_PTR(nativeQueryPtr)
-    Query* pQuery = Q(nativeQueryPtr);
-    if (!QUERY_VALID(env, pQuery)) {
-        return 0;
-    }
-    try {
-        auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
-        using rf = realm::_impl::RealmFriend;
-        auto handover = rf::get_shared_group(*sharedRealm).export_for_handover(*pQuery, ConstSourcePayload::Copy);
-        return reinterpret_cast<jlong>(handover.release());
-    }
-    CATCH_STD()
-    return 0;
-}
-
-
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNotNull(JNIEnv* env, jobject, jlong nativeQueryPtr,
-                                                                         jlongArray columnIndexes)
+                                                                         jlongArray columnIndexes,
+                                                                         jlongArray tablePointers)
 {
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
     Query* pQuery = Q(nativeQueryPtr);
     try {
-        TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-        jlong column_idx = arr[arr_len - 1];
-        TableRef table_ref = getTableByArray(nativeQueryPtr, arr);
+        jlong column_idx = index_arr[arr_len - 1];
 
-        if (!TBL_AND_COL_NULLABLE(env, table_ref.get(), column_idx)) {
+        TableRef table_ref = getTableByArray(nativeQueryPtr, table_arr, index_arr);
+        if (!isNullable(env, TBL(table_arr[arr_len - 1]), table_ref, column_idx)) {
             return;
         }
 
-        int col_type = table_ref->get_column_type(S(column_idx));
+        TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
+
+        DataType col_type = table_ref->get_column_type(S(column_idx));
         if (arr_len == 1) {
             switch (col_type) {
                 case type_Link:
@@ -1600,29 +1654,37 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNotNull(JNIEnv*
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty(JNIEnv* env, jobject, jlong nativeQueryPtr,
-                                                                       jlongArray columnIndexes)
+                                                                       jlongArray columnIndexes,
+                                                                       jlongArray tablePointers)
 {
-
-    JniLongArray arr(env, columnIndexes);
-    jsize arr_len = arr.len();
-    Query* pQuery = Q(nativeQueryPtr);
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
+    Query* pQuery = reinterpret_cast<Query *>(nativeQueryPtr);
     try {
-        TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, arr);
-        jlong column_idx = arr[arr_len - 1];
-        TableRef table_ref = getTableByArray(nativeQueryPtr, arr);
+        TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
+        auto column_idx = static_cast<size_t>(index_arr[arr_len - 1]);
+
+        // Support a backlink as the last column in a field descriptor
+        auto last = reinterpret_cast<Table*>(table_arr[arr_len-1]);
+        if (last != nullptr) {
+            pQuery->and_query(src_table_ref->column<BackLink>(*last, column_idx).count() == 0);
+            return;
+        }
 
-        int col_type = table_ref->get_column_type(S(column_idx));
+        TableRef table_ref = getTableByArray(nativeQueryPtr, table_arr, index_arr);
+        DataType col_type = table_ref->get_column_type(column_idx);
         if (arr_len == 1) {
             // Field queries
             switch (col_type) {
                 case type_Binary:
-                    pQuery->equal(S(column_idx), BinaryData("", 0));
+                    pQuery->equal(column_idx, BinaryData("", 0));
                     break;
                 case type_LinkList:
-                    pQuery->and_query(table_ref->column<LinkList>(S(column_idx)).count() == 0);
+                    pQuery->and_query(src_table_ref->column<LinkList>(column_idx).count() == 0);
                     break;
                 case type_String:
-                    pQuery->equal(S(column_idx), "");
+                    pQuery->equal(column_idx, "");
                     break;
                 case type_Link:
                 case type_Bool:
@@ -1639,13 +1701,13 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty(JNIEnv* e
             // Linked queries
             switch (col_type) {
                 case type_Binary:
-                    pQuery->and_query(src_table_ref->column<Binary>(S(column_idx)) == BinaryData("", 0));
+                    pQuery->and_query(src_table_ref->column<Binary>(column_idx) == BinaryData("", 0));
                     break;
                 case type_LinkList:
-                    pQuery->and_query(src_table_ref->column<LinkList>(S(column_idx)).count() == 0);
+                    pQuery->and_query(src_table_ref->column<LinkList>(column_idx).count() == 0);
                     break;
                 case type_String:
-                    pQuery->and_query(src_table_ref->column<String>(S(column_idx)) == "");
+                    pQuery->and_query(src_table_ref->column<String>(column_idx) == "");
                     break;
                 case type_Link:
                 case type_Bool:
@@ -1663,6 +1725,77 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsEmpty(JNIEnv* e
     CATCH_STD()
 }
 
+JNIEXPORT void JNICALL
+Java_io_realm_internal_TableQuery_nativeIsNotEmpty(JNIEnv *env, jobject, jlong nativeQueryPtr,
+                                                   jlongArray columnIndexes, jlongArray tablePointers) {
+    JLongArrayAccessor table_arr(env, tablePointers);
+    JLongArrayAccessor index_arr(env, columnIndexes);
+    jsize arr_len = index_arr.size();
+    Query* pQuery = reinterpret_cast<Query *>(nativeQueryPtr);
+    try {
+        TableRef src_table_ref = getTableForLinkQuery(nativeQueryPtr, table_arr, index_arr);
+        auto column_idx = static_cast<size_t>(index_arr[arr_len - 1]);
+
+        // Support a backlink as the last column in a field descriptor
+        auto last = reinterpret_cast<Table*>(table_arr[arr_len-1]);
+        if (last != nullptr) {
+            pQuery->and_query(src_table_ref->column<BackLink>(*last, column_idx).count() != 0);
+            return;
+        }
+
+        TableRef table_ref = getTableByArray(nativeQueryPtr, table_arr, index_arr);
+        DataType col_type = table_ref->get_column_type(column_idx);
+        if (arr_len == 1) {
+            // Field queries
+            switch (col_type) {
+                case type_Binary:
+                    pQuery->not_equal(column_idx, BinaryData("", 0));
+                    break;
+                case type_LinkList:
+                    pQuery->and_query(src_table_ref->column<LinkList>(column_idx).count() != 0);
+                    break;
+                case type_String:
+                    pQuery->not_equal(column_idx, "");
+                    break;
+                case type_Link:
+                case type_Bool:
+                case type_Int:
+                case type_Float:
+                case type_Double:
+                case type_Timestamp:
+                default:
+                    ThrowException(env, IllegalArgument, "isNotEmpty() only works on String, byte[] and RealmList.");
+                    return;
+            }
+        }
+        else {
+            // Linked queries
+            switch (col_type) {
+                case type_Binary:
+                    pQuery->and_query(src_table_ref->column<Binary>(column_idx) != BinaryData("", 0));
+                    break;
+                case type_LinkList:
+                    pQuery->and_query(src_table_ref->column<LinkList>(column_idx).count() != 0);
+                    break;
+                case type_String:
+                    pQuery->and_query(src_table_ref->column<String>(column_idx) != "");
+                    break;
+                case type_Link:
+                case type_Bool:
+                case type_Int:
+                case type_Float:
+                case type_Double:
+                case type_Timestamp:
+                default:
+                    ThrowException(env, IllegalArgument,
+                                   "isNotEmpty() only works on String, byte[] and RealmList across links.");
+                    return;
+            }
+        }
+    }
+    CATCH_STD()
+}
+
 static void finalize_table_query(jlong ptr)
 {
     TR_ENTER_PTR(ptr)
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_TestUtil.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_TestUtil.cpp
index 6eab915b78..7b7fcb5198 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_TestUtil.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_TestUtil.cpp
@@ -45,7 +45,7 @@ static jstring throwOrGetExpectedMessage(JNIEnv* env, jlong testcase, bool shoul
                 ThrowException(env, UnsupportedOperation, "parm1", "parm2");
             break;
         case OutOfMemory:
-            expect = "io.realm.internal.OutOfMemoryError: parm1 parm2";
+            expect = "java.lang.OutOfMemoryError: parm1 parm2";
             if (should_throw)
                 ThrowException(env, OutOfMemory, "parm1", "parm2");
             break;
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
index 8b491db0b4..319597fb17 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_UncheckedRow.cpp
@@ -15,9 +15,13 @@
  */
 
 #include "io_realm_internal_UncheckedRow.h"
+#include "io_realm_internal_Property.h"
+
+#include "java_accessor.hpp"
 #include "util.hpp"
 
 using namespace realm;
+using namespace realm::_impl;
 
 static void finalize_unchecked_row(jlong ptr);
 
@@ -68,7 +72,13 @@ JNIEXPORT jint JNICALL Java_io_realm_internal_UncheckedRow_nativeGetColumnType(J
                                                                                jlong columnIndex)
 {
     TR_ENTER_PTR(nativeRowPtr)
-    return static_cast<jint>(ROW(nativeRowPtr)->get_column_type(S(columnIndex))); // noexcept
+    auto column_type = ROW(nativeRowPtr)->get_column_type(S(columnIndex)); // noexcept
+    if (column_type != type_Table) {
+        return static_cast<jint>(column_type);
+    }
+    // FIXME: Add test in https://github.com/realm/realm-java/pull/5221 before merging to master
+    return static_cast<jint>(ROW(nativeRowPtr)->get_table()->get_descriptor()->get_subdescriptor(S(columnIndex))->get_column_type(S(0))
+                             + io_realm_internal_Property_TYPE_ARRAY); // noexcept
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetIndex(JNIEnv* env, jobject, jlong nativeRowPtr)
@@ -161,22 +171,12 @@ JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_UncheckedRow_nativeGetByteAr
         return nullptr;
     }
 
-    BinaryData bin = ROW(nativeRowPtr)->get_binary(S(columnIndex));
-    if (bin.is_null()) {
-        return nullptr;
-    }
-    else if (bin.size() <= MAX_JSIZE) {
-        jbyteArray jresult = env->NewByteArray(static_cast<jsize>(bin.size()));
-        if (jresult) {
-            env->SetByteArrayRegion(jresult, 0, static_cast<jsize>(bin.size()),
-                                    reinterpret_cast<const jbyte*>(bin.data())); // throws
-        }
-        return jresult;
-    }
-    else {
-        ThrowException(env, IllegalArgument, "Length of ByteArray is larger than an Int.");
-        return nullptr;
+    try {
+        BinaryData bin = ROW(nativeRowPtr)->get_binary(S(columnIndex));
+        return JavaClassGlobalDef::new_byte_array(env, bin);
     }
+    CATCH_STD()
+    return nullptr;
 }
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLink(JNIEnv* env, jobject, jlong nativeRowPtr,
@@ -205,19 +205,6 @@ JNIEXPORT jboolean JNICALL Java_io_realm_internal_UncheckedRow_nativeIsNullLink(
     return to_jbool(ROW(nativeRowPtr)->is_null_link(S(columnIndex)));
 }
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_UncheckedRow_nativeGetLinkView(JNIEnv* env, jobject,
-                                                                              jlong nativeRowPtr, jlong columnIndex)
-{
-    TR_ENTER_PTR(nativeRowPtr)
-    if (!ROW_VALID(env, ROW(nativeRowPtr))) {
-        return 0;
-    }
-
-    LinkViewRef* link_view_ptr =
-        const_cast<LinkViewRef*>(&(LangBindHelper::get_linklist_ptr(*ROW(nativeRowPtr), S(columnIndex))));
-    return reinterpret_cast<jlong>(link_view_ptr);
-}
-
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLong(JNIEnv* env, jobject, jlong nativeRowPtr,
                                                                          jlong columnIndex, jlong value)
 {
@@ -318,30 +305,17 @@ JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetByteArray(JN
         return;
     }
 
-    jbyte* bytePtr = nullptr;
     try {
-        if (value == nullptr) {
-            if (!(ROW(nativeRowPtr)->get_table()->is_nullable(S(columnIndex)))) {
-                ThrowNullValueException(env, ROW(nativeRowPtr)->get_table(), S(columnIndex));
-                return;
-            }
-            ROW(nativeRowPtr)->set_binary(S(columnIndex), BinaryData());
-        }
-        else {
-            bytePtr = env->GetByteArrayElements(value, NULL);
-            if (!bytePtr) {
-                ThrowException(env, IllegalArgument, "doByteArray");
-                return;
-            }
-            size_t dataLen = S(env->GetArrayLength(value));
-            ROW(nativeRowPtr)->set_binary(S(columnIndex), BinaryData(reinterpret_cast<char*>(bytePtr), dataLen));
+        auto& row = *reinterpret_cast<realm::Row*>(nativeRowPtr);
+        if (value == nullptr && !(row.get_table()->is_nullable(S(columnIndex)))) {
+            ThrowNullValueException(env, ROW(nativeRowPtr)->get_table(), S(columnIndex));
+            return;
         }
-    }
-    CATCH_STD()
 
-    if (bytePtr) {
-        env->ReleaseByteArrayElements(value, bytePtr, JNI_ABORT);
+        JByteArrayAccessor jarray_accessor(env, value);
+        row.set_binary(static_cast<size_t>(columnIndex), jarray_accessor.transform<BinaryData>());
     }
+    CATCH_STD()
 }
 
 JNIEXPORT void JNICALL Java_io_realm_internal_UncheckedRow_nativeSetLink(JNIEnv* env, jobject, jlong nativeRowPtr,
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
index 2c26299cbe..f104ab1cf9 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
@@ -18,6 +18,7 @@
 
 #include "jni_util/jni_utils.hpp"
 #include "jni_util/hack.hpp"
+#include "java_class_global_def.hpp"
 
 #include <realm/string_data.hpp>
 #include <realm/unicode.hpp>
@@ -26,6 +27,7 @@
 
 using std::string;
 using namespace realm::jni_util;
+using namespace realm::_impl;
 
 //#define USE_VLD
 #if defined(_MSC_VER) && defined(_DEBUG) && defined(USE_VLD)
@@ -46,16 +48,7 @@ JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*)
     }
     else {
         JniUtils::initialize(vm, JNI_VERSION_1_6);
-        // Loading classes and constructors for later use - used by box typed fields and a few methods' return value
-        java_lang_long = GetClass(env, "java/lang/Long");
-        java_lang_long_init = env->GetMethodID(java_lang_long, "<init>", "(J)V");
-        java_lang_float = GetClass(env, "java/lang/Float");
-        java_lang_float_init = env->GetMethodID(java_lang_float, "<init>", "(F)V");
-        java_lang_double = GetClass(env, "java/lang/Double");
-        java_lang_string = GetClass(env, "java/lang/String");
-        java_lang_double_init = env->GetMethodID(java_lang_double, "<init>", "(D)V");
-        java_util_date = GetClass(env, "java/util/Date");
-        java_util_date_init = env->GetMethodID(java_util_date, "<init>", "(J)V");
+        JavaClassGlobalDef::initialize(env);
     }
 
     return JNI_VERSION_1_6;
@@ -68,11 +61,7 @@ JNIEXPORT void JNI_OnUnload(JavaVM* vm, void*)
         return;
     }
     else {
-        env->DeleteGlobalRef(java_lang_long);
-        env->DeleteGlobalRef(java_lang_float);
-        env->DeleteGlobalRef(java_lang_double);
-        env->DeleteGlobalRef(java_util_date);
-        env->DeleteGlobalRef(java_lang_string);
+        JavaClassGlobalDef::release();
         JniUtils::release();
     }
 }
diff --git a/realm/realm-library/src/main/cpp/java_accessor.hpp b/realm/realm-library/src/main/cpp/java_accessor.hpp
new file mode 100644
index 0000000000..333f77a3f4
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/java_accessor.hpp
@@ -0,0 +1,436 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef REALM_JNI_IMPL_JAVA_ACCESSOR_HPP
+#define REALM_JNI_IMPL_JAVA_ACCESSOR_HPP
+
+#include <jni.h>
+
+#include <vector>
+#include <memory>
+
+#include <realm/binary_data.hpp>
+#include <realm/table.hpp>
+
+#include <object_accessor.hpp>
+#include <util/any.hpp>
+#include <util/format.hpp>
+
+#include "java_class_global_def.hpp"
+#include "java_exception_def.hpp"
+#include "jni_util/java_exception_thrower.hpp"
+
+// Utility classes for accessing Java objects from JNI
+namespace realm {
+namespace _impl {
+
+template <typename, typename>
+class JPrimitiveArrayAccessor;
+typedef JPrimitiveArrayAccessor<jbyteArray, jbyte> JByteArrayAccessor;
+typedef JPrimitiveArrayAccessor<jbooleanArray, jboolean> JBooleanArrayAccessor;
+typedef JPrimitiveArrayAccessor<jlongArray, jlong> JLongArrayAccessor;
+
+// JPrimitiveArrayAccessor and JObjectArrayAccessor are not supposed to be used across JNI borders. They won't acquire
+// references of the original Java object. Thus, you have to ensure the original java object is available during the
+// life cycle of those accessors. Moreover, some returned object like BinaryData and StringData, they don't own the
+// memory they use. So the accessor has to be available during the life cycle of those returned objects.
+
+// Accessor for Java primitive arrays
+template <typename ArrayType, typename ElementType>
+class JPrimitiveArrayAccessor {
+public:
+    JPrimitiveArrayAccessor(JNIEnv* env, ArrayType jarray)
+        : m_size(jarray ? env->GetArrayLength(jarray) : 0)
+        , m_elements_holder(std::make_shared<ElementsHolder>(env, jarray))
+    {
+        check_init(env);
+    }
+    ~JPrimitiveArrayAccessor() = default;
+
+    JPrimitiveArrayAccessor(JPrimitiveArrayAccessor&&) = default;
+    JPrimitiveArrayAccessor& operator=(JPrimitiveArrayAccessor&&) = default;
+    JPrimitiveArrayAccessor(const JPrimitiveArrayAccessor&) = default;
+    JPrimitiveArrayAccessor& operator=(const JPrimitiveArrayAccessor&) = default;
+
+    inline bool is_null()
+    {
+        return !m_elements_holder->m_jarray;
+    }
+
+    inline jsize size() const noexcept
+    {
+        return m_size;
+    }
+
+    inline ElementType* data() const noexcept
+    {
+        return m_elements_holder->m_data_ptr;
+    }
+
+    inline const ElementType& operator[](const int index) const noexcept
+    {
+        return m_elements_holder->m_data_ptr[index];
+    }
+
+    // Converts the Java array into an instance of T. The returned value's life cycle may still rely on this accessor.
+    // (e.g.: BinaryData/StringData)
+    template <typename T>
+    T transform();
+
+private:
+    // Holding the data returned by GetXxxArrayElements call.
+    struct ElementsHolder {
+        ElementsHolder(JNIEnv*, ArrayType);
+        ~ElementsHolder();
+
+        JNIEnv* m_env;
+        const ArrayType m_jarray;
+        ElementType* m_data_ptr;
+        const jint m_release_mode = JNI_ABORT;
+    };
+
+    jsize m_size;
+    // For enabling copy/move constructors. ReleaseXxxArrayElements should only be called once.
+    std::shared_ptr<ElementsHolder> m_elements_holder;
+
+    inline void check_init(JNIEnv* env)
+    {
+        if (m_elements_holder->m_jarray != nullptr && m_elements_holder->m_data_ptr == nullptr) {
+            THROW_JAVA_EXCEPTION(env, JavaExceptionDef::IllegalArgument,
+                                 util::format("GetXxxArrayElements failed on %1.",
+                                              reinterpret_cast<int64_t>(m_elements_holder->m_jarray)));
+        }
+    }
+};
+
+// Accessor for Java object arrays
+template <typename AccessorType, typename ObjectType>
+class JObjectArrayAccessor {
+public:
+    JObjectArrayAccessor(JNIEnv* env, jobjectArray jobject_array)
+        : m_env(env)
+        , m_jobject_array(jobject_array)
+        , m_size(jobject_array ? env->GetArrayLength(jobject_array) : 0)
+    {
+    }
+    ~JObjectArrayAccessor()
+    {
+    }
+
+    // Not implemented
+    JObjectArrayAccessor(JObjectArrayAccessor&&) = delete;
+    JObjectArrayAccessor& operator=(JObjectArrayAccessor&&) = delete;
+    JObjectArrayAccessor(const JObjectArrayAccessor&) = delete;
+    JObjectArrayAccessor& operator=(const JObjectArrayAccessor&) = delete;
+
+    inline jsize size() const noexcept
+    {
+        return m_size;
+    }
+
+    inline AccessorType operator[](const int index) const noexcept
+    {
+        return AccessorType(m_env, static_cast<ObjectType>(m_env->GetObjectArrayElement(m_jobject_array, index)));
+    }
+
+private:
+    JNIEnv* m_env;
+    jobjectArray m_jobject_array;
+    jsize m_size;
+};
+
+// An object accessor context which can be used to create and access objects
+// using util::Any as the type-erased value type. In addition, this serves as
+// the reference implementation of an accessor context that must be implemented
+// by each binding.
+class JavaAccessorContext {
+public:
+    JavaAccessorContext(JNIEnv* env)
+        : m_env(env){}
+
+    // Convert from core types to the boxed type
+    util::Any box(BinaryData v) const
+    {
+        return reinterpret_cast<jobject>(JavaClassGlobalDef::new_byte_array(m_env, v));
+    }
+    util::Any box(List /*v*/) const
+    {
+        REALM_TERMINATE("not supported");
+    }
+    util::Any box(Object /*v*/) const
+    {
+        REALM_TERMINATE("not supported");
+    }
+    util::Any box(Results /*v*/) const
+    {
+        REALM_TERMINATE("not supported");
+    }
+    util::Any box(StringData v) const
+    {
+        return reinterpret_cast<jobject>(to_jstring(m_env, v));
+    }
+    util::Any box(Timestamp v) const
+    {
+        return JavaClassGlobalDef::new_date(m_env, v);
+    }
+    util::Any box(bool v) const
+    {
+        return _impl::JavaClassGlobalDef::new_boolean(m_env, v);
+    }
+    util::Any box(double v) const
+    {
+        return _impl::JavaClassGlobalDef::new_double(m_env, v);
+    }
+    util::Any box(float v) const
+    {
+        return _impl::JavaClassGlobalDef::new_float(m_env, v);
+    }
+    util::Any box(int64_t v) const
+    {
+        return _impl::JavaClassGlobalDef::new_long(m_env, v);
+    }
+    util::Any box(util::Optional<bool> v) const
+    {
+        return v ? _impl::JavaClassGlobalDef::new_boolean(m_env, v.value()) : nullptr;
+    }
+    util::Any box(util::Optional<double> v) const
+    {
+        return v ? _impl::JavaClassGlobalDef::new_double(m_env, v.value()) : nullptr;
+    }
+    util::Any box(util::Optional<float> v) const
+    {
+        return v ? _impl::JavaClassGlobalDef::new_float(m_env, v.value()) : nullptr;
+    }
+    util::Any box(util::Optional<int64_t> v) const
+    {
+        return v ? _impl::JavaClassGlobalDef::new_long(m_env, v.value()) : nullptr;
+    }
+    util::Any box(RowExpr) const
+    {
+        REALM_TERMINATE("not supported");
+    }
+
+    // Any properties are only supported by the Cocoa binding to enable reading
+    // old Realm files that may have used them. Other bindings can safely not
+    // implement this.
+    util::Any box(Mixed) const
+    {
+        REALM_TERMINATE("not supported");
+    }
+
+    // Convert from the boxed type to core types. This needs to be implemented
+    // for all of the types which `box()` can take, plus `RowExpr` and optional
+    // versions of the numeric types, minus `List` and `Results`.
+    //
+    // `create` and `update` are only applicable to `unbox<RowExpr>`. If
+    // `create` is false then when given something which is not a managed Realm
+    // object `unbox()` should simply return a detached row expr, while if it's
+    // true then `unbox()` should create a new object in the context's Realm
+    // using the provided value. If `update` is true then upsert semantics
+    // should be used for this.
+    template <typename T>
+    T unbox(util::Any& v, bool /*create*/ = false, bool /*update*/ = false) const
+    {
+        return any_cast<T>(v);
+    }
+
+private:
+    JNIEnv* m_env;
+
+    inline void check_value_not_null(util::Any& v, const char* expected_type) const
+    {
+        if (!v.has_value()) {
+            THROW_JAVA_EXCEPTION(
+                m_env, JavaExceptionDef::IllegalArgument,
+                util::format("This field is required. A non-null '%1' type value is expected.", expected_type));
+        }
+    }
+};
+
+// Accessor for jbyteArray
+template <>
+inline JPrimitiveArrayAccessor<jbyteArray, jbyte>::ElementsHolder::ElementsHolder(JNIEnv* env, jbyteArray jarray)
+    : m_env(env)
+    , m_jarray(jarray)
+    , m_data_ptr(jarray ? env->GetByteArrayElements(jarray, nullptr) : nullptr)
+{
+}
+
+template <>
+inline JPrimitiveArrayAccessor<jbyteArray, jbyte>::ElementsHolder::~ElementsHolder()
+{
+    if (m_jarray) {
+        m_env->ReleaseByteArrayElements(m_jarray, m_data_ptr, m_release_mode);
+    }
+}
+
+template <>
+template <>
+inline BinaryData JPrimitiveArrayAccessor<jbyteArray, jbyte>::transform<BinaryData>()
+{
+    // To solve the link issue by directly using Table::max_binary_size
+    static constexpr size_t max_binary_size = Table::max_binary_size;
+
+    if (static_cast<size_t>(m_size) > max_binary_size) {
+        THROW_JAVA_EXCEPTION(m_elements_holder->m_env, JavaExceptionDef::IllegalArgument,
+                             util::format("The length of 'byte[]' value is %1 which exceeds the max binary size %2.",
+                                 m_size, max_binary_size));
+    }
+    return is_null() ? realm::BinaryData()
+                     : realm::BinaryData(reinterpret_cast<const char*>(m_elements_holder->m_data_ptr), m_size);
+}
+
+template <>
+template <>
+inline std::vector<char> JPrimitiveArrayAccessor<jbyteArray, jbyte>::transform<std::vector<char>>()
+{
+    if (is_null()) {
+        return {};
+    }
+
+    std::vector<char> v(m_size);
+    std::copy_n(m_elements_holder->m_data_ptr, v.size(), v.begin());
+    return v;
+}
+
+// Accessor for jbooleanArray
+template <>
+inline JPrimitiveArrayAccessor<jbooleanArray, jboolean>::ElementsHolder::ElementsHolder(JNIEnv* env,
+                                                                                        jbooleanArray jarray)
+    : m_env(env)
+    , m_jarray(jarray)
+    , m_data_ptr(jarray ? env->GetBooleanArrayElements(jarray, nullptr) : nullptr)
+{
+}
+
+template <>
+inline JPrimitiveArrayAccessor<jbooleanArray, jboolean>::ElementsHolder::~ElementsHolder()
+{
+    if (m_jarray) {
+        m_env->ReleaseBooleanArrayElements(m_jarray, m_data_ptr, m_release_mode);
+    }
+}
+
+// Accessor for jlongArray
+template <>
+inline JPrimitiveArrayAccessor<jlongArray, jlong>::ElementsHolder::ElementsHolder(JNIEnv* env, jlongArray jarray)
+    : m_env(env)
+    , m_jarray(jarray)
+    , m_data_ptr(jarray ? env->GetLongArrayElements(jarray, nullptr) : nullptr)
+{
+}
+
+template <>
+inline JPrimitiveArrayAccessor<jlongArray, jlong>::ElementsHolder::~ElementsHolder()
+{
+    if (m_jarray) {
+        m_env->ReleaseLongArrayElements(m_jarray, m_data_ptr, m_release_mode);
+    }
+}
+
+template <>
+inline bool JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    check_value_not_null(v, "Boolean");
+    return any_cast<jboolean>(v) == JNI_TRUE;
+}
+
+template <>
+inline int64_t JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    check_value_not_null(v, "Long");
+    return static_cast<int64_t>(any_cast<jlong>(v));
+}
+
+template <>
+inline double JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    check_value_not_null(v, "Double");
+    return static_cast<double>(any_cast<jdouble>(v));
+}
+
+template <>
+inline float JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    check_value_not_null(v, "Float");
+    return static_cast<float>(any_cast<jfloat>(v));
+}
+
+template <>
+inline StringData JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    if (!v.has_value()) {
+        return StringData();
+    }
+    auto& value = any_cast<JStringAccessor&>(v);
+    return value;
+}
+
+template <>
+inline BinaryData JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    if (!v.has_value())
+        return BinaryData();
+    auto& value = any_cast<JByteArrayAccessor&>(v);
+    return value.transform<BinaryData>();
+}
+
+template <>
+inline Timestamp JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    return v.has_value() ? from_milliseconds(any_cast<jlong>(v)) : Timestamp();
+}
+
+template <>
+inline RowExpr JavaAccessorContext::unbox(util::Any&, bool, bool) const
+{
+    REALM_TERMINATE("not supported");
+}
+
+template <>
+inline util::Optional<bool> JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    return v.has_value() ? util::make_optional(any_cast<jboolean>(v) == JNI_TRUE) : util::none;
+}
+
+template <>
+inline util::Optional<int64_t> JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    return v.has_value() ? util::make_optional(static_cast<int64_t>(any_cast<jlong>(v))) : util::none;
+}
+
+template <>
+inline util::Optional<double> JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    return v.has_value() ? util::make_optional(any_cast<jdouble>(v)) : util::none;
+}
+
+template <>
+inline util::Optional<float> JavaAccessorContext::unbox(util::Any& v, bool, bool) const
+{
+    return v.has_value() ? util::make_optional(any_cast<jfloat>(v)) : util::none;
+}
+
+template <>
+inline Mixed JavaAccessorContext::unbox(util::Any&, bool, bool) const
+{
+    REALM_TERMINATE("not supported");
+}
+
+} // namespace realm
+} // namespace _impl
+
+#endif // REALM_JNI_IMPL_JAVA_ACCESSOR_HPP
diff --git a/realm/realm-library/src/main/cpp/java_binding_context.cpp b/realm/realm-library/src/main/cpp/java_binding_context.cpp
index 7c4480d004..2406d18498 100644
--- a/realm/realm-library/src/main/cpp/java_binding_context.cpp
+++ b/realm/realm-library/src/main/cpp/java_binding_context.cpp
@@ -15,6 +15,7 @@
  */
 
 #include "java_binding_context.hpp"
+#include "java_class_global_def.hpp"
 #include "jni_util/java_method.hpp"
 
 #include "util.hpp"
@@ -31,7 +32,8 @@ void JavaBindingContext::before_notify()
     if (m_java_notifier) {
         m_java_notifier.call_with_local_ref([&](JNIEnv* env, jobject notifier_obj) {
             // Method IDs from RealmNotifier implementation. Cache them as member vars.
-            static JavaMethod notify_by_other_method(env, notifier_obj, "beforeNotify", "()V");
+            static JavaMethod notify_by_other_method(env, JavaClassGlobalDef::realm_notifier(), "beforeNotify",
+                                                     "()V");
             env->CallVoidMethod(notifier_obj, notify_by_other_method);
         });
     }
@@ -47,8 +49,26 @@ void JavaBindingContext::did_change(std::vector<BindingContext::ObserverState> c
     }
     if (version_changed) {
         m_java_notifier.call_with_local_ref(env, [&](JNIEnv*, jobject notifier_obj) {
-            static JavaMethod realm_notifier_did_change_method(env, notifier_obj, "didChange", "()V");
+            static JavaMethod realm_notifier_did_change_method(env, JavaClassGlobalDef::realm_notifier(), "didChange",
+                                                               "()V");
             env->CallVoidMethod(notifier_obj, realm_notifier_did_change_method);
         });
     }
 }
+
+void JavaBindingContext::schema_did_change(Schema const&)
+{
+    if (!m_schema_changed_callback) {
+        return;
+    }
+    auto env = JniUtils::get_env(false);
+    static JavaMethod on_schema_changed_method(env, JavaClassGlobalDef::shared_realm_schema_change_callback(),
+                                               "onSchemaChanged", "()V");
+    m_schema_changed_callback.call_with_local_ref(
+        env, [](JNIEnv* env, jobject callback_obj) { env->CallVoidMethod(callback_obj, on_schema_changed_method); });
+}
+
+void JavaBindingContext::set_schema_changed_callback(JNIEnv* env, jobject schema_changed_callback)
+{
+    m_schema_changed_callback = JavaGlobalWeakRef(env, schema_changed_callback);
+}
diff --git a/realm/realm-library/src/main/cpp/java_binding_context.hpp b/realm/realm-library/src/main/cpp/java_binding_context.hpp
index de3a15c62c..0ff2caea2b 100644
--- a/realm/realm-library/src/main/cpp/java_binding_context.hpp
+++ b/realm/realm-library/src/main/cpp/java_binding_context.hpp
@@ -27,7 +27,6 @@
 namespace realm {
 
 namespace _impl {
-
 // Binding context which will be called from OS.
 class JavaBindingContext final : public BindingContext {
 private:
@@ -36,18 +35,21 @@ class JavaBindingContext final : public BindingContext {
         jobject java_notifier;
     };
 
-    // A weak global ref to the implementation of RealmNotifier
-    // Java should hold a strong ref to it as long as the SharedRealm lives
+    // Weak global refs to the needed Java objects.
+    // Java should hold a strong ref to them as long as the SharedRealm lives
     jni_util::JavaGlobalWeakRef m_java_notifier;
+    jni_util::JavaGlobalWeakRef m_schema_changed_callback;
 
 public:
     virtual ~JavaBindingContext(){};
-    virtual void before_notify();
-    virtual void did_change(std::vector<ObserverState> const& observers, std::vector<void*> const& invalidated,
-                            bool version_changed = true);
+    void before_notify() override;
+    void did_change(std::vector<ObserverState> const& observers, std::vector<void*> const& invalidated,
+                    bool version_changed = true) override;
+    void schema_did_change(Schema const&) override;
 
     explicit JavaBindingContext(const ConcreteJavaBindContext& concrete_context)
         : m_java_notifier(concrete_context.jni_env, concrete_context.java_notifier)
+        , m_schema_changed_callback()
     {
     }
     JavaBindingContext(const JavaBindingContext&) = delete;
@@ -55,6 +57,8 @@ class JavaBindingContext final : public BindingContext {
     JavaBindingContext(JavaBindingContext&&) = delete;
     JavaBindingContext& operator=(JavaBindingContext&&) = delete;
 
+    void set_schema_changed_callback(JNIEnv* env, jobject schema_changed_callback);
+
     static inline std::unique_ptr<JavaBindingContext> create(JNIEnv* env, jobject notifier)
     {
         return std::make_unique<JavaBindingContext>(ConcreteJavaBindContext{env, notifier});
diff --git a/realm/realm-library/src/main/cpp/java_class_global_def.cpp b/realm/realm-library/src/main/cpp/java_class_global_def.cpp
new file mode 100644
index 0000000000..d1ecd443ca
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/java_class_global_def.cpp
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "realm/array_blob.hpp"
+
+#include "java_class_global_def.hpp"
+#include "java_exception_def.hpp"
+#include "jni_util/java_exception_thrower.hpp"
+
+using namespace realm;
+using namespace realm::_impl;
+
+jbyteArray JavaClassGlobalDef::new_byte_array(JNIEnv* env, const BinaryData& binary_data)
+{
+    static_assert(MAX_JSIZE >= ArrayBlob::max_binary_size, "ArrayBlob's max size is too big.");
+
+    if (binary_data.is_null()) {
+        return nullptr;
+    }
+
+    auto size = static_cast<jsize>(binary_data.size());
+    jbyteArray ret = env->NewByteArray(size);
+    if (!ret) {
+        THROW_JAVA_EXCEPTION(env, JavaExceptionDef::OutOfMemory,
+                             util::format("'NewByteArray' failed with size %1.", size));
+    }
+
+    env->SetByteArrayRegion(ret, 0, size, reinterpret_cast<const jbyte*>(binary_data.data()));
+    return ret;
+}
diff --git a/realm/realm-library/src/main/cpp/java_class_global_def.hpp b/realm/realm-library/src/main/cpp/java_class_global_def.hpp
new file mode 100644
index 0000000000..268082de8e
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/java_class_global_def.hpp
@@ -0,0 +1,174 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef REALM_JNI_IMPL_CLASS_GLOBAL_DEF_HPP
+#define REALM_JNI_IMPL_CLASS_GLOBAL_DEF_HPP
+
+#include "util.hpp"
+#include "jni_util/java_class.hpp"
+#include "jni_util/java_method.hpp"
+
+#include <memory>
+
+#include <realm/util/assert.hpp>
+
+namespace realm {
+
+class BinaryData;
+
+namespace _impl {
+
+// Manage a global static jclass pool which will be initialized when JNI_OnLoad() called.
+// FindClass is a relatively slow operation, loading all the needed classes when start is not good since usually user
+// will call Realm.init() when the app starts.
+// Instead, we only load necessary classes including:
+// 1. Common types which might be used everywhere. (Boxed types, String, etc.)
+// 2. Classes which might be initialized in the native thread.
+//
+// FindClass will fail if it is called from a native thread (e.g.: the sync client thread.). But usually it is not a
+// problem if the FindClass is called from an JNI method. So keeping a static JavaClass var locally is still preferred
+// if it is possible.
+class JavaClassGlobalDef {
+private:
+    JavaClassGlobalDef(JNIEnv* env)
+        : m_java_lang_long(env, "java/lang/Long", false)
+        , m_java_lang_float(env, "java/lang/Float", false)
+        , m_java_lang_double(env, "java/lang/Double", false)
+        , m_java_util_date(env, "java/util/Date", false)
+        , m_java_lang_string(env, "java/lang/String", false)
+        , m_java_lang_boolean(env, "java/lang/Boolean", false)
+        , m_shared_realm_schema_change_callback(env, "io/realm/internal/SharedRealm$SchemaChangedCallback", false)
+        , m_realm_notifier(env, "io/realm/internal/RealmNotifier", false)
+    {
+    }
+
+    jni_util::JavaClass m_java_lang_long;
+    jni_util::JavaClass m_java_lang_float;
+    jni_util::JavaClass m_java_lang_double;
+    jni_util::JavaClass m_java_util_date;
+    jni_util::JavaClass m_java_lang_string;
+    jni_util::JavaClass m_java_lang_boolean;
+
+    jni_util::JavaClass m_shared_realm_schema_change_callback;
+    jni_util::JavaClass m_realm_notifier;
+
+    inline static std::unique_ptr<JavaClassGlobalDef>& instance()
+    {
+        static std::unique_ptr<JavaClassGlobalDef> instance;
+        return instance;
+    };
+
+public:
+    // Called in JNI_OnLoad
+    static void initialize(JNIEnv* env)
+    {
+        REALM_ASSERT(!instance());
+        instance().reset(new JavaClassGlobalDef(env));
+    }
+    // Called in JNI_OnUnload
+    static void release()
+    {
+        REALM_ASSERT(instance());
+        instance().release();
+    }
+
+    // java.lang.Long
+    inline static jobject new_long(JNIEnv* env, int64_t value)
+    {
+        static jni_util::JavaMethod init(env, instance()->m_java_lang_long, "<init>", "(J)V");
+        return env->NewObject(instance()->m_java_lang_long, init, value);
+    }
+    inline static const jni_util::JavaClass& java_lang_long()
+    {
+        return instance()->m_java_lang_long;
+    }
+
+    // java.lang.Float
+    inline static jobject new_float(JNIEnv* env, float value)
+    {
+        static jni_util::JavaMethod init(env, instance()->m_java_lang_float, "<init>", "(F)V");
+        return env->NewObject(instance()->m_java_lang_float, init, value);
+    }
+    inline static const jni_util::JavaClass& java_lang_float()
+    {
+        return instance()->m_java_lang_float;
+    }
+
+    // java.lang.Double
+    inline static jobject new_double(JNIEnv* env, double value)
+    {
+        static jni_util::JavaMethod init(env, instance()->m_java_lang_double, "<init>", "(D)V");
+        return env->NewObject(instance()->m_java_lang_double, init, value);
+    }
+    inline static const jni_util::JavaClass& java_lang_double()
+    {
+        return instance()->m_java_lang_double;
+    }
+
+    // java.lang.Boolean
+    inline static jobject new_boolean(JNIEnv* env, bool value)
+    {
+        static jni_util::JavaMethod init(env, instance()->m_java_lang_boolean, "<init>", "(Z)V");
+        return env->NewObject(instance()->m_java_lang_boolean, init, value ? JNI_TRUE : JNI_FALSE);
+    }
+    inline static const jni_util::JavaClass& java_lang_boolean()
+    {
+        return instance()->m_java_lang_boolean;
+    }
+
+    // java.util.Date
+    // return nullptr if ts is null
+    inline static jobject new_date(JNIEnv* env, const realm::Timestamp& ts)
+    {
+        if (ts.is_null()) {
+            return nullptr;
+        }
+        static jni_util::JavaMethod init(env, instance()->m_java_util_date, "<init>", "(J)V");
+        return env->NewObject(instance()->m_java_util_date, init, to_milliseconds(ts));
+    }
+    inline static const jni_util::JavaClass& java_util_date()
+    {
+        return instance()->m_java_util_date;
+    }
+
+    // java.util.String
+    inline static const jni_util::JavaClass& java_lang_string()
+    {
+        return instance()->m_java_lang_string;
+    }
+
+    // byte[]
+    // return nullptr if binary_data is null
+    static jbyteArray new_byte_array(JNIEnv* env, const BinaryData& binary_data);
+
+    // io.realm.internal.SharedRealm.SchemaChangedCallback
+    inline static const jni_util::JavaClass& shared_realm_schema_change_callback()
+    {
+        return instance()->m_shared_realm_schema_change_callback;
+    }
+
+    // io.realm.internal.RealmNotifier
+    inline static const jni_util::JavaClass& realm_notifier()
+    {
+        return instance()->m_realm_notifier;
+    }
+};
+
+} // namespace realm
+} // namespace jni_impl
+
+
+#endif // REALM_JNI_IMPL_CLASS_GLOBAL_DEF_HPP
diff --git a/realm/realm-library/src/main/cpp/java_exception_def.cpp b/realm/realm-library/src/main/cpp/java_exception_def.cpp
new file mode 100644
index 0000000000..af773d13f5
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/java_exception_def.cpp
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "java_exception_def.hpp"
+
+using namespace realm::_impl;
+
+const char* JavaExceptionDef::IllegalState = "java/lang/IllegalStateException";
+const char* JavaExceptionDef::IllegalArgument = "java/lang/IllegalArgumentException";
+const char* JavaExceptionDef::OutOfMemory = "java/lang/OutOfMemoryError";
+const char* JavaExceptionDef::RealmMigrationNeeded = "io/realm/exceptions/RealmMigrationNeededException";
diff --git a/realm/realm-library/src/main/cpp/java_exception_def.hpp b/realm/realm-library/src/main/cpp/java_exception_def.hpp
new file mode 100644
index 0000000000..c705416157
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/java_exception_def.hpp
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef REALM_JNI_IMPL_EXCEPTION_DEF_HPP
+#define REALM_JNI_IMPL_EXCEPTION_DEF_HPP
+
+namespace realm {
+namespace _impl {
+
+// Definitions of Java exceptions which are used in JNI.
+class JavaExceptionDef {
+public:
+    // Class names
+    static const char* IllegalState;
+    static const char* IllegalArgument;
+    static const char* OutOfMemory;
+    static const char* RealmMigrationNeeded;
+};
+
+} // namespace realm
+} // namespace jni_impl
+
+#endif
diff --git a/realm/realm-library/src/main/cpp/java_sort_descriptor.cpp b/realm/realm-library/src/main/cpp/java_sort_descriptor.cpp
index b26c76309b..90adec02ef 100644
--- a/realm/realm-library/src/main/cpp/java_sort_descriptor.cpp
+++ b/realm/realm-library/src/main/cpp/java_sort_descriptor.cpp
@@ -15,50 +15,84 @@
  */
 
 
+#include "java_accessor.hpp"
 #include "java_sort_descriptor.hpp"
 #include "util.hpp"
+#include "jni_util/java_class.hpp"
 #include "jni_util/java_method.hpp"
 
 using namespace realm;
 using namespace realm::_impl;
 using namespace realm::jni_util;
 
-JavaSortDescriptor::operator realm::SortDescriptor() const noexcept
+SortDescriptor JavaSortDescriptor::sort_descriptor() const noexcept
 {
     if (m_sort_desc_obj == nullptr) {
         return SortDescriptor();
     }
 
-    // Cache the method IDs.
-    static JavaMethod getColumnIndices(m_env, m_sort_desc_obj, "getColumnIndices", "()[[J");
-    static JavaMethod getAscendings(m_env, m_sort_desc_obj, "getAscendings", "()[Z");
-    static JavaMethod getTablePtr(m_env, m_sort_desc_obj, "getTablePtr", "()J");
+    return SortDescriptor(*get_table_ptr(), get_column_indices(), get_ascendings());
+}
 
-    jobjectArray column_indices =
-        static_cast<jobjectArray>(m_env->CallObjectMethod(m_sort_desc_obj, getColumnIndices));
-    jbooleanArray ascendings = static_cast<jbooleanArray>(m_env->CallObjectMethod(m_sort_desc_obj, getAscendings));
-    jlong table_ptr = m_env->CallLongMethod(m_sort_desc_obj, getTablePtr);
+DistinctDescriptor JavaSortDescriptor::distinct_descriptor() const noexcept
+{
+    if (m_sort_desc_obj == nullptr) {
+        return DistinctDescriptor();
+    }
+    return DistinctDescriptor(*get_table_ptr(), get_column_indices());
+}
 
-    JniArrayOfArrays<JniLongArray, jlongArray> arrays(m_env, column_indices);
-    JniBooleanArray ascending_array(m_env, ascendings);
-    jsize arr_len = arrays.len();
+Table* JavaSortDescriptor::get_table_ptr() const noexcept
+{
+    static JavaMethod get_table_ptr_method(m_env, get_sort_desc_class(), "getTablePtr", "()J");
+    jlong table_ptr = m_env->CallLongMethod(m_sort_desc_obj, get_table_ptr_method);
+    return reinterpret_cast<Table*>(table_ptr);
+}
 
+std::vector<std::vector<size_t>> JavaSortDescriptor::get_column_indices() const noexcept
+{
+    static JavaMethod get_column_indices_method(m_env, get_sort_desc_class(), "getColumnIndices", "()[[J");
+    jobjectArray column_indices =
+        static_cast<jobjectArray>(m_env->CallObjectMethod(m_sort_desc_obj, get_column_indices_method));
+    JObjectArrayAccessor<JLongArrayAccessor, jlongArray> arrays(m_env, column_indices);
+    jsize arr_len = arrays.size();
     std::vector<std::vector<size_t>> indices;
-    std::vector<bool> ascending_list;
 
     for (int i = 0; i < arr_len; ++i) {
-        JniLongArray& jni_long_array = arrays[i];
+        auto jni_long_array = arrays[i];
         std::vector<size_t> col_indices;
-        for (int j = 0; j < jni_long_array.len(); ++j) {
+        for (int j = 0; j < jni_long_array.size(); ++j) {
             col_indices.push_back(static_cast<size_t>(jni_long_array[j]));
         }
         indices.push_back(std::move(col_indices));
-        if (ascendings) {
-            ascending_list.push_back(static_cast<bool>(ascending_array[i]));
-        }
     }
+    return indices;
+}
 
-    return ascendings
-               ? SortDescriptor(*reinterpret_cast<Table*>(table_ptr), std::move(indices), std::move(ascending_list))
-               : SortDescriptor(*reinterpret_cast<Table*>(table_ptr), std::move(indices));
+std::vector<bool> JavaSortDescriptor::get_ascendings() const noexcept
+{
+    static JavaMethod get_ascendings_method(m_env, get_sort_desc_class(), "getAscendings", "()[Z");
+
+    jbooleanArray ascendings =
+        static_cast<jbooleanArray>(m_env->CallObjectMethod(m_sort_desc_obj, get_ascendings_method));
+
+    if (!ascendings) {
+        return {};
+    }
+
+    JBooleanArrayAccessor ascending_array(m_env, ascendings);
+    std::vector<bool> ascending_list;
+    jsize arr_len = ascending_array.size();
+
+    for (int i = 0; i < arr_len; i++) {
+        ascending_list.push_back(static_cast<bool>(ascending_array[i]));
+    }
+    return ascending_list;
+}
+
+JavaClass const& JavaSortDescriptor::get_sort_desc_class() const noexcept
+{
+    static JavaClass sort_desc_class(m_env, "io/realm/internal/SortDescriptor");
+    return sort_desc_class;
 }
+
diff --git a/realm/realm-library/src/main/cpp/java_sort_descriptor.hpp b/realm/realm-library/src/main/cpp/java_sort_descriptor.hpp
index 39c175254c..81384f9a15 100644
--- a/realm/realm-library/src/main/cpp/java_sort_descriptor.hpp
+++ b/realm/realm-library/src/main/cpp/java_sort_descriptor.hpp
@@ -18,9 +18,15 @@
 #define JAVA_SORT_DESCRIPTOR_HPP
 
 #include <jni.h>
-#include <realm/views.hpp>
+
+#include "descriptor_ordering.hpp"
 
 namespace realm {
+
+namespace jni_util {
+class JavaClass;
+}
+
 namespace _impl {
 
 // For converting a Java SortDescriptor object to realm::SortDescriptor.
@@ -41,11 +47,24 @@ class JavaSortDescriptor {
     JavaSortDescriptor(JavaSortDescriptor&&) = delete;
     JavaSortDescriptor& operator=(JavaSortDescriptor&&) = delete;
 
-    operator realm::SortDescriptor() const noexcept;
+    // Prevent heap allocation
+    static void *operator new     (size_t) = delete;
+    static void *operator new[]   (size_t) = delete;
+    static void  operator delete  (void*)  = delete;
+    static void  operator delete[](void*)  = delete;
+
+    realm::SortDescriptor sort_descriptor() const noexcept;
+    realm::DistinctDescriptor distinct_descriptor() const noexcept;
 
 private:
     JNIEnv* m_env;
     jobject m_sort_desc_obj;
+
+    realm::Table* get_table_ptr() const noexcept;
+    std::vector<std::vector<size_t>> get_column_indices() const noexcept;
+    std::vector<bool> get_ascendings() const noexcept;
+
+    jni_util::JavaClass const& get_sort_desc_class() const noexcept;
 };
 
 } // namespace _impl
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_class.cpp b/realm/realm-library/src/main/cpp/jni_util/java_class.cpp
index f0bb7530c5..357a504703 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_class.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_class.cpp
@@ -21,6 +21,12 @@
 
 using namespace realm::jni_util;
 
+JavaClass::JavaClass()
+    : m_ref_owner()
+    , m_class(nullptr)
+{
+}
+
 JavaClass::JavaClass(JNIEnv* env, const char* class_name, bool free_on_unload)
     : m_ref_owner(get_jclass(env, class_name))
     , m_class(reinterpret_cast<jclass>(m_ref_owner.get()))
@@ -31,12 +37,18 @@ JavaClass::JavaClass(JNIEnv* env, const char* class_name, bool free_on_unload)
     }
 }
 
+JavaClass::JavaClass(JavaClass&& rhs)
+    : m_ref_owner(std::move(rhs.m_ref_owner))
+    , m_class(rhs.m_class)
+{
+    rhs.m_class = nullptr;
+}
+
 JavaGlobalRef JavaClass::get_jclass(JNIEnv* env, const char* class_name)
 {
     jclass cls = env->FindClass(class_name);
-    REALM_ASSERT_DEBUG(cls);
+    REALM_ASSERT_RELEASE_EX(cls, class_name);
 
-    JavaGlobalRef cls_ref(env, cls);
-    env->DeleteLocalRef(cls);
+    JavaGlobalRef cls_ref(env, cls, true);
     return cls_ref;
 }
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_class.hpp b/realm/realm-library/src/main/cpp/jni_util/java_class.hpp
index c95dce29d4..e6ee130f73 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_class.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_class.hpp
@@ -27,6 +27,7 @@ namespace jni_util {
 // To find the jclass and manage the lifecycle for the jclass's global ref.
 class JavaClass {
 public:
+    JavaClass();
     // when free_on_unload is true, the jclass's global ref will be released when JNI_OnUnload called. This is useful
     // when the JavaClass instance is static. Otherwise the jclass's global ref will be released when this object is
     // deleted.
@@ -35,6 +36,8 @@ class JavaClass {
     {
     }
 
+    JavaClass(JavaClass&&);
+
     inline jclass get() noexcept
     {
         return m_class;
@@ -45,8 +48,12 @@ class JavaClass {
         return m_class;
     }
 
+    inline operator bool() const noexcept
+    {
+        return m_class != nullptr;
+    }
+
     // Not implemented for now.
-    JavaClass(JavaClass&&) = delete;
     JavaClass(JavaClass&) = delete;
     JavaClass& operator=(JavaClass&&) = delete;
 
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.cpp b/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.cpp
new file mode 100644
index 0000000000..6278fd7fb8
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.cpp
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "java_exception_thrower.hpp"
+#include "log.hpp"
+
+#include <util/format.hpp>
+
+using namespace realm::util;
+using namespace realm::jni_util;
+
+JavaExceptionThrower::JavaExceptionThrower(const char* file_path, int line_num)
+    : std::runtime_error("Java exception has been occurred. Terminate JNI by throwing a c++ exception.")
+    , m_exception_class()
+    , m_file_path(file_path)
+    , m_line_num(line_num)
+{
+}
+
+JavaExceptionThrower::JavaExceptionThrower(JNIEnv* env, const char* class_name, std::string message,
+                                           const char* file_path, int line_num)
+    : std::runtime_error(std::move(message))
+    , m_exception_class(env, class_name, false)
+    , m_file_path(file_path)
+    , m_line_num(line_num)
+{
+}
+
+void JavaExceptionThrower::throw_java_exception(JNIEnv* env)
+{
+    std::string message = format("%1\n(%2:%3)", what(), m_file_path, m_line_num);
+    Log::w(message.c_str());
+
+    // There is a pending Java exception, just return.
+    if (env->ExceptionCheck()) {
+        Log::w("There is a pending Java exception.");
+        return;
+    }
+    env->ThrowNew(m_exception_class, message.c_str());
+}
+
+void JavaExceptionThrower::terminate_jni_if_java_exception_occurred(JNIEnv* env, CleanUpFunction clean_up_func,
+                                                                    const char* file_path, int line_num)
+{
+    if (!env->ExceptionCheck()) {
+        return;
+    }
+    if (clean_up_func) {
+        clean_up_func();
+    }
+    throw JavaExceptionThrower(file_path, line_num);
+}
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.hpp b/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.hpp
new file mode 100644
index 0000000000..488c5399b0
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/jni_util/java_exception_thrower.hpp
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef REALM_JNI_UTIL_JAVA_EXCEPTION_THROWER_HPP
+#define REALM_JNI_UTIL_JAVA_EXCEPTION_THROWER_HPP
+
+#include <jni.h>
+
+#include <functional>
+#include <stdexcept>
+
+#include "java_class.hpp"
+
+namespace realm {
+namespace jni_util {
+
+#define THROW_JAVA_EXCEPTION(env, class_name, message)                                                               \
+    throw realm::jni_util::JavaExceptionThrower(env, class_name, message, __FILE__, __LINE__)
+
+#define TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(env, clean_up_func)                                                 \
+    JavaExceptionThrower::terminate_jni_if_java_exception_occurred(env, clean_up_func, __FILE__, __LINE__);
+
+// Class to help throw a Java exception from JNI code.
+// This exception will be called from CATCH_STD and throw a Java exception there.
+class JavaExceptionThrower : public std::runtime_error {
+public:
+    using CleanUpFunction = std::function<void()>;
+
+    JavaExceptionThrower(const char* file_path, int line_num);
+    JavaExceptionThrower(JNIEnv* env, const char* class_name, std::string message, const char* file_path,
+                         int line_num);
+
+    void throw_java_exception(JNIEnv* env);
+
+    // This method will throw a JavaExceptionThrower to terminate JNI then return to java if there is an Java
+    // exception has been thrown before.
+    // clean_up_fucn will be called before throwing the c++ exception if there is a pending java exception.
+    static void terminate_jni_if_java_exception_occurred(JNIEnv* env, CleanUpFunction clean_up_func,
+                                                         const char* file_path, int line_num);
+
+private:
+    JavaClass m_exception_class;
+    const char* m_file_path;
+    int m_line_num;
+};
+
+} // namespace realm
+} // namesapce jni_util
+
+#endif // REALM_JNI_UTIL_JAVA_EXCEPTION_THROWER_HPP
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_global_ref.cpp b/realm/realm-library/src/main/cpp/jni_util/java_global_ref.cpp
index fd6036cf95..68d9fd99de 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_global_ref.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_global_ref.cpp
@@ -34,3 +34,8 @@ JavaGlobalRef& JavaGlobalRef::operator=(JavaGlobalRef&& rhs)
     new (this) JavaGlobalRef(std::move(rhs));
     return *this;
 }
+
+JavaGlobalRef::JavaGlobalRef(JavaGlobalRef& rhs)
+        : m_ref(rhs.m_ref ? jni_util::JniUtils::get_env(true)->NewGlobalRef(rhs.m_ref) : nullptr)
+{
+}
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_global_ref.hpp b/realm/realm-library/src/main/cpp/jni_util/java_global_ref.hpp
index f2d0c3320d..7c68165b63 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_global_ref.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_global_ref.hpp
@@ -45,20 +45,19 @@ class JavaGlobalRef {
     ~JavaGlobalRef();
 
     JavaGlobalRef& operator=(JavaGlobalRef&& rhs);
+    JavaGlobalRef& operator=(JavaGlobalRef& rhs) = delete;
+    JavaGlobalRef(JavaGlobalRef&);
 
     inline operator bool() const noexcept
     {
         return m_ref != nullptr;
     }
 
-    inline jobject get() noexcept
+    inline jobject get() const noexcept
     {
         return m_ref;
     }
 
-    // Not implemented for now.
-    JavaGlobalRef(JavaGlobalRef&) = delete;
-
 private:
     jobject m_ref;
 };
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.cpp b/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.cpp
index 10718df40c..898cdeeace 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.cpp
@@ -19,7 +19,56 @@
 
 using namespace realm::jni_util;
 
-bool JavaGlobalWeakRef::call_with_local_ref(JNIEnv* env, std::function<Callback> callback)
+JavaGlobalWeakRef::JavaGlobalWeakRef()
+    : m_weak(nullptr)
+{
+}
+
+JavaGlobalWeakRef::JavaGlobalWeakRef(JNIEnv* env, jobject obj)
+    : m_weak(obj ? env->NewWeakGlobalRef(obj) : nullptr)
+{
+}
+
+JavaGlobalWeakRef::~JavaGlobalWeakRef()
+{
+    if (m_weak) {
+        JniUtils::get_env()->DeleteWeakGlobalRef(m_weak);
+    }
+}
+
+JavaGlobalWeakRef::JavaGlobalWeakRef(JavaGlobalWeakRef&& rhs)
+    : m_weak(rhs.m_weak)
+{
+    rhs.m_weak = nullptr;
+}
+
+JavaGlobalWeakRef& JavaGlobalWeakRef::operator=(JavaGlobalWeakRef&& rhs)
+{
+    this->~JavaGlobalWeakRef();
+    new (this) JavaGlobalWeakRef(std::move(rhs));
+    return *this;
+}
+
+JavaGlobalWeakRef::JavaGlobalWeakRef(const JavaGlobalWeakRef& rhs)
+    : m_weak(JniUtils::get_env(true)->NewWeakGlobalRef(rhs.m_weak))
+{
+}
+
+JavaGlobalWeakRef& JavaGlobalWeakRef::operator=(const JavaGlobalWeakRef& rhs)
+{
+    new (this) JavaGlobalWeakRef(rhs);
+    return *this;
+}
+
+JavaGlobalRef JavaGlobalWeakRef::global_ref(JNIEnv* env) const
+{
+    if (!env) {
+        env = JniUtils::get_env(true);
+    }
+    return JavaGlobalRef(env, m_weak);
+}
+
+bool JavaGlobalWeakRef::call_with_local_ref(JNIEnv* env, std::function<Callback> callback) const
 {
     if (!m_weak) {
         return false;
@@ -34,7 +83,7 @@ bool JavaGlobalWeakRef::call_with_local_ref(JNIEnv* env, std::function<Callback>
     return true;
 }
 
-bool JavaGlobalWeakRef::call_with_local_ref(std::function<Callback> callback)
+bool JavaGlobalWeakRef::call_with_local_ref(std::function<Callback> callback) const
 {
     return call_with_local_ref(JniUtils::get_env(), callback);
 }
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.hpp b/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.hpp
index 4e6c60df56..f21d640f0a 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.hpp
@@ -28,48 +28,30 @@ namespace jni_util {
 // RAII wrapper for weak global ref.
 class JavaGlobalWeakRef {
 public:
-    JavaGlobalWeakRef()
-        : m_weak(nullptr)
-    {
-    }
-    JavaGlobalWeakRef(JNIEnv* env, jobject obj)
-        : m_weak(obj ? env->NewWeakGlobalRef(obj) : nullptr)
-    {
-    }
-    ~JavaGlobalWeakRef()
-    {
-        if (m_weak) {
-            JniUtils::get_env()->DeleteWeakGlobalRef(m_weak);
-        }
-    }
+    JavaGlobalWeakRef();
+    JavaGlobalWeakRef(JNIEnv*, jobject);
+    ~JavaGlobalWeakRef();
 
-    JavaGlobalWeakRef(JavaGlobalWeakRef&& rhs)
-        : m_weak(rhs.m_weak)
-    {
-        rhs.m_weak = nullptr;
-    }
-    JavaGlobalWeakRef& operator=(JavaGlobalWeakRef&& rhs)
-    {
-        this->~JavaGlobalWeakRef();
-        new (this) JavaGlobalWeakRef(std::move(rhs));
-        return *this;
-    }
+    JavaGlobalWeakRef(JavaGlobalWeakRef&&);
+    JavaGlobalWeakRef& operator=(JavaGlobalWeakRef&&);
 
-    JavaGlobalWeakRef(const JavaGlobalWeakRef&) = delete;
-    JavaGlobalWeakRef& operator=(const JavaGlobalWeakRef&) = delete;
+    JavaGlobalWeakRef(const JavaGlobalWeakRef&);
+    JavaGlobalWeakRef& operator=(const JavaGlobalWeakRef&);
 
     inline operator bool() const noexcept
     {
         return m_weak != nullptr;
     }
 
+    JavaGlobalRef global_ref(JNIEnv* env = nullptr) const;
+
     using Callback = void(JNIEnv* env, jobject obj);
 
     // Acquire a local ref and run the callback with it if the weak ref is valid. The local ref will be deleted after
     // callback finished. Return false if the weak ref is not valid anymore.
-    bool call_with_local_ref(JNIEnv* env, std::function<Callback> callback);
+    bool call_with_local_ref(JNIEnv* env, std::function<Callback> callback) const ;
     // Try to get an JNIEnv for current thread then run the callback.
-    bool call_with_local_ref(std::function<Callback> callback);
+    bool call_with_local_ref(std::function<Callback> callback) const;
 
 private:
     jweak m_weak;
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp b/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
index 283c948fba..0417887449 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_local_ref.hpp
@@ -29,27 +29,42 @@ static constexpr NeedToCreateLocalRef need_to_create_local_ref{};
 // Wraps jobject and automatically calls DeleteLocalRef when this object is destroyed.
 // DeleteLocalRef is not necessary to be called in most cases since all local references will be cleaned up when the
 // program returns to Java from native. But if the local ref is created in a loop, consider to use this class to wrap
-// it
-// because the size of local reference table is relative small (512 bytes on Android).
+// it because the size of local reference table is relative small (512 bytes on Android).
 template <typename T>
 class JavaLocalRef {
 public:
-    // need_to_create is useful when acquire a local ref from a global weak ref.
+    inline JavaLocalRef() noexcept
+        : m_jobject(nullptr)
+        , m_env(nullptr){};
     inline JavaLocalRef(JNIEnv* env, T obj) noexcept
         : m_jobject(obj)
         , m_env(env){};
+    // need_to_create is useful when acquire a local ref from a global weak ref.
     inline JavaLocalRef(JNIEnv* env, T obj, NeedToCreateLocalRef) noexcept
         : m_jobject(env->NewLocalRef(obj))
         , m_env(env){};
+
     inline ~JavaLocalRef()
     {
-        m_env->DeleteLocalRef(m_jobject);
+        if (m_jobject) {
+            m_env->DeleteLocalRef(m_jobject);
+        }
     }
 
-    JavaLocalRef(const JavaLocalRef&) = delete;
-    JavaLocalRef& operator=(const JavaLocalRef&) = delete;
-    JavaLocalRef(JavaLocalRef&& rhs) = delete;
-    JavaLocalRef& operator=(JavaLocalRef&& rhs) = delete;
+    JavaLocalRef& operator=(JavaLocalRef&& rhs)
+    {
+        this->~JavaLocalRef();
+        new (this) JavaLocalRef(std::move(rhs));
+        return *this;
+    }
+
+    inline JavaLocalRef(JavaLocalRef&& rhs)
+        : m_jobject(rhs.m_jobject)
+        , m_env(rhs.m_env)
+    {
+        rhs.m_jobject = nullptr;
+        rhs.m_env = nullptr;
+    }
 
     inline operator bool() const noexcept
     {
@@ -59,6 +74,13 @@ class JavaLocalRef {
     {
         return m_jobject;
     }
+    inline T get() const noexcept
+    {
+        return m_jobject;
+    };
+
+    JavaLocalRef(const JavaLocalRef&) = delete;
+    JavaLocalRef& operator=(const JavaLocalRef&) = delete;
 
 private:
     T m_jobject;
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_method.cpp b/realm/realm-library/src/main/cpp/jni_util/java_method.cpp
index 882e4ef38f..2cb559750e 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_method.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_method.cpp
@@ -15,12 +15,13 @@
  */
 
 #include "java_method.hpp"
+#include "java_class.hpp"
 
 #include <realm/util/assert.hpp>
 
 using namespace realm::jni_util;
 
-JavaMethod::JavaMethod(JNIEnv* env, jclass cls, const char* method_name, const char* signature, bool static_method)
+JavaMethod::JavaMethod(JNIEnv* env, JavaClass const& cls, const char* method_name, const char* signature, bool static_method)
 {
     if (static_method) {
         m_method_id = env->GetStaticMethodID(cls, method_name, signature);
@@ -29,26 +30,5 @@ JavaMethod::JavaMethod(JNIEnv* env, jclass cls, const char* method_name, const c
         m_method_id = env->GetMethodID(cls, method_name, signature);
     }
 
-    REALM_ASSERT_RELEASE(m_method_id != nullptr);
-}
-
-JavaMethod::JavaMethod(JNIEnv* env, jobject obj, const char* method_name, const char* signature)
-{
-    jclass cls = env->GetObjectClass(obj);
-    m_method_id = env->GetMethodID(cls, method_name, signature);
-    REALM_ASSERT_RELEASE(m_method_id != nullptr);
-    env->DeleteLocalRef(cls);
-}
-
-JavaMethod::JavaMethod(JNIEnv* env, const char* class_name, const char* method_name, const char* signature,
-                       bool static_method)
-{
-    jclass cls = env->FindClass(class_name);
-    REALM_ASSERT_RELEASE(cls != nullptr);
-    if (static_method) {
-        m_method_id = env->GetStaticMethodID(cls, method_name, signature);
-    }
-    else {
-        m_method_id = env->GetMethodID(cls, method_name, signature);
-    }
+    REALM_ASSERT_RELEASE_EX(m_method_id != nullptr, method_name, signature);
 }
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_method.hpp b/realm/realm-library/src/main/cpp/jni_util/java_method.hpp
index d582399fd3..0bcc80172a 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_method.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_method.hpp
@@ -22,6 +22,7 @@
 namespace realm {
 namespace jni_util {
 
+class JavaClass;
 // RAII wrapper for java method ID. Since normally method ID stays unchanged for the whole JVM life cycle, it would be
 // safe to have a static JavaMethod object to avoid calling GetMethodID multiple times.
 class JavaMethod {
@@ -30,11 +31,28 @@ class JavaMethod {
         : m_method_id(nullptr)
     {
     }
-    JavaMethod(JNIEnv* env, jclass cls, const char* method_name, const char* signature, bool static_method = false);
-    JavaMethod(JNIEnv* env, jobject obj, const char* method_name, const char* signature);
-    JavaMethod(JNIEnv* env, const char* class_name, const char* method_name, const char* signature,
+    JavaMethod(JNIEnv* env, JavaClass const& cls, const char* method_name, const char* signature,
                bool static_method = false);
 
+    // From https://developer.android.com/training/articles/perf-jni.html
+    // The class references, field IDs, and method IDs are guaranteed valid until the class is unloaded. Classes are
+    // only unloaded if all classes associated with a ClassLoader can be garbage collected, which is rare but will not
+    // be impossible in Android. Note however that the jclass is a class reference and must be protected with a call
+    // to NewGlobalRef (see the next section).
+    //
+    // BUT THERE ARE BUGS. See below:
+    //
+    // WARNING!! For anyone wants to implement this method, please DON'T. There might be a bug in JVM implementation
+    // that the jmethodID retrieved from jobject's jclass would be invalid under some certain conditions.
+    // See https://github.com/realm/realm-java/issues/4964 for how to reproduce it.
+    // JavaMethod(JNIEnv* env, jobject obj, const char* method_name, const char* signature);
+
+    // For this constructor, there is no evidence that jmethodID will be invalidated when there is no ref to the jclass.
+    // Just in case, though we force the caller to keep a global ref by JavaClass to make sure we won't encounter another
+    // JVM bug.
+    // JavaMethod(JNIEnv* env, const char* class_name, const char* method_name, const char* signature,
+    //           bool static_method = false);
+
     JavaMethod(const JavaMethod&) = default;
     JavaMethod& operator=(const JavaMethod&) = default;
     JavaMethod(JavaMethod&& rhs) = delete;
diff --git a/realm/realm-library/src/main/cpp/jni_util/log.cpp b/realm/realm-library/src/main/cpp/jni_util/log.cpp
index c90a4d5e25..14026e3ccc 100644
--- a/realm/realm-library/src/main/cpp/jni_util/log.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/log.cpp
@@ -19,6 +19,7 @@
 #include <realm/util/assert.hpp>
 
 #include "jni_util/log.hpp"
+#include "jni_util/java_local_ref.hpp"
 
 using namespace realm;
 using namespace realm::jni_util;
@@ -91,8 +92,9 @@ void JavaLogger::log(Log::Level level, const char* tag, jthrowable throwable, co
     // "JNI called with pending exception". This is something that should be avoided when printing log in JNI --
     // Always
     // print log before calling env->ThrowNew. Doing env->ExceptionCheck() here creates overhead for normal cases.
-    env->CallVoidMethod(m_java_logger, m_log_method, level, env->NewStringUTF(tag), throwable,
-                        env->NewStringUTF(message));
+    JavaLocalRef<jstring> java_tag(env, env->NewStringUTF(tag));
+    JavaLocalRef<jstring> java_error_message(env, env->NewStringUTF(message));
+    env->CallVoidMethod(m_java_logger, m_log_method, level, java_tag.get(), throwable, java_error_message.get());
 }
 
 bool JavaLogger::is_same_object(JNIEnv* env, jobject java_logger)
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index dfddfa7f7b..136b3a32a2 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit dfddfa7f7bf564619e2257243c252ffad6d5c9c3
+Subproject commit 136b3a32a218f50275f1183ed078b31945a9e29f
diff --git a/realm/realm-library/src/main/cpp/observable_collection_wrapper.hpp b/realm/realm-library/src/main/cpp/observable_collection_wrapper.hpp
new file mode 100644
index 0000000000..6b86d91138
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/observable_collection_wrapper.hpp
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef REALM_JNI_IMPL_OBSERVABLE_COLLECTION_WRAPPER_HPP
+#define REALM_JNI_IMPL_OBSERVABLE_COLLECTION_WRAPPER_HPP
+
+#include "jni_util/java_class.hpp"
+#include "jni_util/java_global_weak_ref.hpp"
+#include "jni_util/java_method.hpp"
+#include "jni_util/log.hpp"
+
+namespace realm {
+namespace _impl {
+
+// Wrapper of Object Store List & Results.
+// We need to control the life cycle of Results/List, weak ref of Java OsResults/OsList object and the NotificationToken.
+// Wrap all three together, so when the Java OsResults/OsList object gets GCed, all three of them will be invalidated.
+template <typename T>
+class ObservableCollectionWrapper {
+public:
+    ObservableCollectionWrapper(T& collection)
+        : m_collection_weak_ref()
+        , m_notification_token()
+        , m_collection(std::move(collection))
+    {
+    }
+
+    ~ObservableCollectionWrapper() = default;
+
+    ObservableCollectionWrapper(ObservableCollectionWrapper&&) = delete;
+    ObservableCollectionWrapper& operator=(ObservableCollectionWrapper&&) = delete;
+    ObservableCollectionWrapper(ObservableCollectionWrapper const&) = delete;
+    ObservableCollectionWrapper& operator=(ObservableCollectionWrapper const&) = delete;
+
+    T& collection()
+    {
+        return m_collection;
+    };
+    void start_listening(JNIEnv* env, jobject j_collection_object);
+    void stop_listening();
+
+private:
+    jni_util::JavaGlobalWeakRef m_collection_weak_ref;
+    NotificationToken m_notification_token;
+    T m_collection;
+};
+
+template <typename T>
+void ObservableCollectionWrapper<T>::start_listening(JNIEnv* env, jobject j_collection_object)
+{
+    static jni_util::JavaClass os_results_class(env, "io/realm/internal/ObservableCollection");
+    static jni_util::JavaMethod notify_change_listeners(env, os_results_class, "notifyChangeListeners", "(J)V");
+
+    if (!m_collection_weak_ref) {
+        m_collection_weak_ref = jni_util::JavaGlobalWeakRef(env, j_collection_object);
+    }
+
+    auto cb = [=](CollectionChangeSet const& changes, std::exception_ptr err) {
+        // OS will call all notifiers' callback in one run, so check the Java exception first!!
+        if (env->ExceptionCheck())
+            return;
+
+        if (err) {
+            try {
+                std::rethrow_exception(err);
+            }
+            catch (const std::exception& e) {
+                realm::jni_util::Log::e("Caught exception in collection change callback %1", e.what());
+                return;
+            }
+        }
+
+        m_collection_weak_ref.call_with_local_ref(env, [&](JNIEnv* local_env, jobject collection_obj) {
+            local_env->CallVoidMethod(
+                collection_obj, notify_change_listeners,
+                reinterpret_cast<jlong>(changes.empty() ? 0 : new CollectionChangeSet(changes)));
+        });
+    };
+
+    m_notification_token = m_collection.add_notification_callback(cb);
+}
+
+template <typename T>
+void ObservableCollectionWrapper<T>::stop_listening()
+{
+    m_notification_token = {};
+}
+
+} // namespace realm
+} // namespace _impl
+
+#endif // REALM_JNI_IMPL_OBSERVABLE_COLLECTION_WRAPPER_HPP
diff --git a/realm/realm-library/src/main/cpp/tablebase_tpl.hpp b/realm/realm-library/src/main/cpp/tablebase_tpl.hpp
deleted file mode 100644
index 54db725c51..0000000000
--- a/realm/realm-library/src/main/cpp/tablebase_tpl.hpp
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef REALM_JNI_TABLEBASE_TPL_HPP
-#define REALM_JNI_TABLEBASE_TPL_HPP
-
-#include <realm.hpp>
-
-template <class T>
-jbyteArray tbl_GetByteArray(JNIEnv* env, jlong nativeTablePtr, jlong columnIndex, jlong rowIndex)
-{
-    if (!TBL_AND_INDEX_VALID(env, reinterpret_cast<T*>(nativeTablePtr), columnIndex, rowIndex)) {
-        return nullptr;
-    }
-
-    realm::BinaryData bin = reinterpret_cast<T*>(nativeTablePtr)->get_binary(S(columnIndex), S(rowIndex));
-    if (bin.is_null()) {
-        return nullptr;
-    }
-    if (bin.size() <= MAX_JSIZE) {
-        jbyteArray jresult = env->NewByteArray(static_cast<jsize>(bin.size()));
-        if (jresult) {
-            env->SetByteArrayRegion(jresult, 0, static_cast<jsize>(bin.size()),
-                                    reinterpret_cast<const jbyte *>(bin.data())); // throws
-        }
-        return jresult;
-    }
-    else {
-        ThrowException(env, IllegalArgument, "Length of ByteArray is larger than an Int.");
-        return nullptr;
-    }
-}
-
-#endif // REALM_JNI_TABLEBASE_TPL_HPP
diff --git a/realm/realm-library/src/main/cpp/util.cpp b/realm/realm-library/src/main/cpp/util.cpp
index e562c12564..f21d1bfc09 100644
--- a/realm/realm-library/src/main/cpp/util.cpp
+++ b/realm/realm-library/src/main/cpp/util.cpp
@@ -20,6 +20,7 @@
 #include <realm/util/assert.hpp>
 #include <realm/util/file.hpp>
 #include <realm/unicode.hpp>
+#include <jni_util/java_method.hpp>
 #include "utf8.hpp"
 
 #include "util.hpp"
@@ -27,24 +28,18 @@
 #include "io_realm_internal_SharedRealm.h"
 #include "shared_realm.hpp"
 #include "results.hpp"
+#include "list.hpp"
+#include "java_exception_def.hpp"
+
+#include "jni_util/java_exception_thrower.hpp"
 
 using namespace std;
 using namespace realm;
 using namespace realm::util;
 using namespace realm::jni_util;
+using namespace realm::_impl;
 
-// Caching classes and constructors for boxed types.
-jclass java_lang_long;
-jmethodID java_lang_long_init;
-jclass java_lang_float;
-jmethodID java_lang_float_init;
-jclass java_lang_double;
-jclass java_lang_string;
-jmethodID java_lang_double_init;
-jclass java_util_date;
-jmethodID java_util_date_init;
-
-void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::RealmFileException::Kind kind);
+void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::RealmFileException::Kind kind, const std::string& path = "");
 
 void ConvertException(JNIEnv* env, const char* file, int line)
 {
@@ -52,6 +47,9 @@ void ConvertException(JNIEnv* env, const char* file, int line)
     try {
         throw;
     }
+    catch (JavaExceptionThrower& e) {
+        e.throw_java_exception(env);
+    }
     catch (bad_alloc& e) {
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, OutOfMemory, ss.str());
@@ -70,7 +68,7 @@ void ConvertException(JNIEnv* env, const char* file, int line)
     }
     catch (RealmFileException& e) {
         ss << e.what() << " (" << e.underlying() << ") (" << e.path() << ") in " << file << " line " << line;
-        ThrowRealmFileException(env, ss.str(), e.kind());
+        ThrowRealmFileException(env, ss.str(), e.kind(), e.path());
     }
     catch (File::AccessError& e) {
         ss << e.what() << " (" << e.get_path() << ") in " << file << " line " << line;
@@ -102,12 +100,25 @@ void ConvertException(JNIEnv* env, const char* file, int line)
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, IllegalState, ss.str());
     }
+    catch (List::OutOfBoundsIndexException& e) {
+        ss << "Out of range  in " << file << " line " << line << "(requested: " << e.requested
+           << " valid: " << e.valid_count << ")";
+        ThrowException(env, IndexOutOfBounds, ss.str());
+    }
     catch (IncorrectThreadException& e) {
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, IllegalState, ss.str());
     }
     catch (realm::LogicError e) {
-        ThrowException(env, IllegalState, e.what());
+        ExceptionKind kind;
+        if (e.kind() == LogicError::string_too_big || e.kind() == LogicError::binary_too_big ||
+            e.kind() == LogicError::column_not_nullable) {
+            kind = IllegalArgument;
+        }
+        else {
+            kind = IllegalState;
+        }
+        ThrowException(env, kind, e.what());
     }
     catch (std::logic_error e) {
         ThrowException(env, IllegalState, e.what());
@@ -153,7 +164,7 @@ void ThrowException(JNIEnv* env, ExceptionKind exception, const std::string& cla
             break;
 
         case OutOfMemory:
-            jExceptionClass = env->FindClass("io/realm/internal/OutOfMemoryError");
+            jExceptionClass = env->FindClass(JavaExceptionDef::OutOfMemory);
             message = classStr + " " + itemStr;
             break;
 
@@ -193,11 +204,11 @@ void ThrowException(JNIEnv* env, ExceptionKind exception, const std::string& cla
     env->DeleteLocalRef(jExceptionClass);
 }
 
-void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::RealmFileException::Kind kind)
+void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::RealmFileException::Kind kind, const std::string& path)
 {
-    jclass cls = env->FindClass("io/realm/exceptions/RealmFileException");
+    static JavaClass  jrealm_file_exception_cls(env, "io/realm/exceptions/RealmFileException");
+    static JavaMethod constructor(env, jrealm_file_exception_cls, "<init>", "(BLjava/lang/String;)V");
 
-    jmethodID constructor = env->GetMethodID(cls, "<init>", "(BLjava/lang/String;)V");
     // Initial value to suppress gcc warning.
     jbyte kind_code = -1; // To suppress compile warning.
     switch (kind) {
@@ -222,27 +233,28 @@ void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::Rea
         case realm::RealmFileException::Kind::FormatUpgradeRequired:
             kind_code = io_realm_internal_SharedRealm_FILE_EXCEPTION_KIND_FORMAT_UPGRADE_REQUIRED;
             break;
-    }
-    jstring jstr = env->NewStringUTF(message.c_str());
-    jobject exception = env->NewObject(cls, constructor, kind_code, jstr);
+        case realm::RealmFileException::Kind::IncompatibleSyncedRealm:
+#if REALM_ENABLE_SYNC
+            static JavaClass jincompatible_synced_file_cls(env,
+                                                           "io/realm/exceptions/IncompatibleSyncedFileException");
+            static JavaMethod jicompatible_synced_ctor(env, jincompatible_synced_file_cls, "<init>",
+                                                       "(Ljava/lang/String;Ljava/lang/String;)V");
+            jobject jexception = env->NewObject(jincompatible_synced_file_cls, jicompatible_synced_ctor,
+                                                to_jstring(env, message), to_jstring(env, path));
+            env->Throw(reinterpret_cast<jthrowable>(jexception));
+            env->DeleteLocalRef(jexception);
+            return;
+#else
+            REALM_ASSERT_RELEASE_EX(false, "'IncompatibleSyncedRealm' should not be thrown for non-sync realm.");
+#endif
+    }
+    jstring jmessage = to_jstring(env, message);
+    jstring jpath = to_jstring(env, path);
+    jobject exception = env->NewObject(jrealm_file_exception_cls, constructor, kind_code, jmessage, jpath);
     env->Throw(reinterpret_cast<jthrowable>(exception));
-    env->DeleteLocalRef(cls);
     env->DeleteLocalRef(exception);
 }
 
-jclass GetClass(JNIEnv* env, const char* classStr)
-{
-    jclass localRefClass = env->FindClass(classStr);
-    if (localRefClass == NULL) {
-        ThrowException(env, ClassNotFound, classStr);
-        return NULL;
-    }
-
-    jclass myClass = reinterpret_cast<jclass>(env->NewGlobalRef(localRefClass));
-    env->DeleteLocalRef(localRefClass);
-    return myClass;
-}
-
 void ThrowNullValueException(JNIEnv* env, Table* table, size_t col_ndx)
 {
     std::ostringstream ss;
@@ -251,23 +263,6 @@ void ThrowNullValueException(JNIEnv* env, Table* table, size_t col_ndx)
     ThrowException(env, IllegalArgument, ss.str());
 }
 
-bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, realm::BinaryData& bin)
-{
-    const char* data = static_cast<char*>(env->GetDirectBufferAddress(jByteBuffer));
-    if (!data) {
-        ThrowException(env, IllegalArgument, "ByteBuffer is invalid");
-        return false;
-    }
-    jlong size = env->GetDirectBufferCapacity(jByteBuffer);
-    if (size < 0) {
-        ThrowException(env, IllegalArgument, "Can't get BufferCapacity.");
-        return false;
-    }
-    bin = BinaryData(data, S(size));
-    return true;
-}
-
-
 //*********************************************************************
 // String handling
 //*********************************************************************
@@ -438,6 +433,7 @@ transcode_complete : {
 
 
 JStringAccessor::JStringAccessor(JNIEnv* env, jstring str)
+    : m_env(env)
 {
     // For efficiency, if the incoming UTF-16 string is sufficiently
     // small, we will choose an UTF-8 output buffer whose size (in
@@ -468,7 +464,7 @@ JStringAccessor::JStringAccessor(JNIEnv* env, jstring str)
         buf_size = Xcode::find_utf8_buf_size(begin, end, error_code);
     }
     char* tmp_char_array = new char[buf_size]; // throws
-    m_data.reset(tmp_char_array);
+    m_data.reset(tmp_char_array, std::default_delete<char[]>());
     {
         const jchar* in_begin = chars.data();
         const jchar* in_end = in_begin + chars.size();
diff --git a/realm/realm-library/src/main/cpp/util.hpp b/realm/realm-library/src/main/cpp/util.hpp
index 29c2813d17..21bb35c354 100644
--- a/realm/realm-library/src/main/cpp/util.hpp
+++ b/realm/realm-library/src/main/cpp/util.hpp
@@ -29,13 +29,16 @@
 #include <realm.hpp>
 #include <realm/lang_bind_helper.hpp>
 #include <realm/timestamp.hpp>
+#include <realm/table.hpp>
 #include <realm/util/safe_int_ops.hpp>
 
 #include <util/format.hpp>
 
 #include "io_realm_internal_Util.h"
 
+#include "java_exception_def.hpp"
 #include "jni_util/log.hpp"
+#include "jni_util/java_exception_thrower.hpp"
 
 #define CHECK_PARAMETERS 1 // Check all parameters in API and throw exceptions in java if invalid
 
@@ -78,11 +81,8 @@ std::string num_to_string(T pNumber)
 #define B(x) static_cast<bool>(x)
 #define S64(x) static_cast<int64_t>(x)
 #define TBL(x) reinterpret_cast<realm::Table*>(x)
-#define TV(x) reinterpret_cast<realm::TableView*>(x)
-#define LV(x) reinterpret_cast<realm::LinkViewRef*>(x)
 #define Q(x) reinterpret_cast<realm::Query*>(x)
 #define ROW(x) reinterpret_cast<realm::Row*>(x)
-#define HO(T, ptr) reinterpret_cast<realm::SharedGroup::Handover<T>*>(ptr)
 
 // Exception handling
 enum ExceptionKind {
@@ -109,9 +109,6 @@ void ThrowException(JNIEnv* env, ExceptionKind exception, const std::string& cla
 void ThrowException(JNIEnv* env, ExceptionKind exception, const char* classStr);
 void ThrowNullValueException(JNIEnv* env, realm::Table* table, size_t col_ndx);
 
-jclass GetClass(JNIEnv* env, const char* classStr);
-
-
 // Check parameters
 
 #define TABLE_VALID(env, ptr) TableIsValid(env, ptr)
@@ -436,9 +433,6 @@ inline bool TblIndexAndTypeInsertValid(JNIEnv* env, T* pTable, jlong columnIndex
            TypeValid(env, pTable, columnIndex, expectColType);
 }
 
-bool GetBinaryData(JNIEnv* env, jobject jByteBuffer, realm::BinaryData& data);
-
-
 // Utility function for appending StringData, which is returned
 // by a lot of core functions, and might potentially be NULL.
 std::string concat_stringdata(const char* message, realm::StringData data);
@@ -460,11 +454,21 @@ class JStringAccessor {
 public:
     JStringAccessor(JNIEnv*, jstring); // throws
 
-    operator realm::StringData() const noexcept
+    operator realm::StringData() const
     {
+        // To solve the link issue by directly using Table::max_string_size
+        static constexpr size_t max_string_size = realm::Table::max_string_size;
+
         if (m_is_null) {
             return realm::StringData(NULL);
         }
+        else if (m_size > max_string_size) {
+            THROW_JAVA_EXCEPTION(
+                m_env, realm::_impl::JavaExceptionDef::IllegalArgument,
+                realm::util::format(
+                    "The length of 'String' value in UTF8 encoding is %1 which exceeds the max string length %2.",
+                    m_size, max_string_size));
+        }
         else {
             return realm::StringData(m_data.get(), m_size);
         }
@@ -479,246 +483,12 @@ class JStringAccessor {
     }
 
 private:
+    JNIEnv* m_env;
     bool m_is_null;
-    std::unique_ptr<char[]> m_data;
+    std::shared_ptr<char> m_data;
     std::size_t m_size;
 };
 
-class JniLongArray {
-public:
-    JniLongArray(JNIEnv* env, jlongArray javaArray)
-        : m_env(env)
-        , m_javaArray(javaArray)
-        , m_arrayLength(javaArray == NULL ? 0 : env->GetArrayLength(javaArray))
-        , m_array(javaArray == NULL ? NULL : env->GetLongArrayElements(javaArray, NULL))
-        , m_releaseMode(JNI_ABORT)
-    {
-    }
-
-    JniLongArray(JniLongArray& other) = delete;
-
-    JniLongArray(JniLongArray&& other)
-        : m_env(other.m_env)
-        , m_javaArray(other.m_javaArray)
-        , m_arrayLength(other.m_arrayLength)
-        , m_array(other.m_array)
-        , m_releaseMode(other.m_releaseMode)
-    {
-        other.m_env = nullptr;
-        other.m_javaArray = nullptr;
-        other.m_arrayLength = 0;
-        other.m_array = nullptr;
-    }
-
-    ~JniLongArray()
-    {
-        if (m_array) {
-            m_env->ReleaseLongArrayElements(m_javaArray, m_array, m_releaseMode);
-        }
-    }
-
-    inline jsize len() const noexcept
-    {
-        return m_arrayLength;
-    }
-
-    inline jlong* ptr() const noexcept
-    {
-        return m_array;
-    }
-
-    inline jlong& operator[](const int index) noexcept
-    {
-        return m_array[index];
-    }
-
-    inline void updateOnRelease() noexcept
-    {
-        m_releaseMode = 0;
-    }
-
-private:
-    JNIEnv* m_env;
-    jlongArray m_javaArray;
-    jsize m_arrayLength;
-    jlong* m_array;
-    jint m_releaseMode;
-};
-
-template <typename T, typename J>
-class JniArrayOfArrays {
-public:
-    JniArrayOfArrays(JNIEnv* env, jobjectArray javaArray)
-        : m_env(env)
-        , m_javaArray(javaArray)
-        , m_arrayLength(javaArray == nullptr ? 0 : env->GetArrayLength(javaArray))
-    {
-        for (int i = 0; i < m_arrayLength; ++i) {
-            // No type checking. Internal use only.
-            J j_array = static_cast<J>(env->GetObjectArrayElement(m_javaArray, i));
-            m_array.push_back(T(env, j_array));
-        }
-    }
-
-    ~JniArrayOfArrays()
-    {
-    }
-
-    inline jsize len() const noexcept
-    {
-        return m_arrayLength;
-    }
-
-    inline T& operator[](const int index) noexcept
-    {
-        return m_array[index];
-    }
-
-private:
-    JNIEnv* const m_env;
-    jobjectArray const m_javaArray;
-    jsize const m_arrayLength;
-    std::vector<T> m_array;
-};
-
-class JniByteArray {
-public:
-    JniByteArray(JNIEnv* env, jbyteArray javaArray)
-        : m_env(env)
-        , m_javaArray(javaArray)
-        , m_arrayLength(javaArray == NULL ? 0 : env->GetArrayLength(javaArray))
-        , m_array(javaArray == NULL ? NULL : env->GetByteArrayElements(javaArray, NULL))
-        , m_releaseMode(JNI_ABORT)
-    {
-        if (m_javaArray != nullptr && m_array == nullptr) {
-            // javaArray is not null but GetByteArrayElements returns null, something is really wrong.
-            throw std::runtime_error(
-                realm::util::format("GetByteArrayElements failed on byte array %x", m_javaArray));
-        }
-    }
-
-    ~JniByteArray()
-    {
-        if (m_array) {
-            m_env->ReleaseByteArrayElements(m_javaArray, m_array, m_releaseMode);
-        }
-    }
-
-    inline jsize len() const noexcept
-    {
-        return m_arrayLength;
-    }
-
-    inline jbyte* ptr() const noexcept
-    {
-        return m_array;
-    }
-
-    inline jbyte& operator[](const int index) noexcept
-    {
-        return m_array[index];
-    }
-
-    inline operator realm::BinaryData() const noexcept
-    {
-        return realm::BinaryData(reinterpret_cast<const char*>(m_array), m_arrayLength);
-    }
-
-    inline operator std::vector<char>() const noexcept
-    {
-        if (m_array == nullptr) {
-            return {};
-        }
-
-        std::vector<char> v(m_arrayLength);
-        std::copy_n(m_array, v.size(), v.begin());
-        return v;
-    }
-
-    inline void updateOnRelease() noexcept
-    {
-        m_releaseMode = 0;
-    }
-
-private:
-    JNIEnv* const m_env;
-    jbyteArray const m_javaArray;
-    jsize const m_arrayLength;
-    jbyte* const m_array;
-    jint m_releaseMode;
-};
-
-class JniBooleanArray {
-public:
-    JniBooleanArray(JNIEnv* env, jbooleanArray javaArray)
-        : m_env(env)
-        , m_javaArray(javaArray)
-        , m_arrayLength(javaArray == NULL ? 0 : env->GetArrayLength(javaArray))
-        , m_array(javaArray == NULL ? NULL : env->GetBooleanArrayElements(javaArray, NULL))
-        , m_releaseMode(JNI_ABORT)
-    {
-    }
-
-    ~JniBooleanArray()
-    {
-        if (m_array) {
-            m_env->ReleaseBooleanArrayElements(m_javaArray, m_array, m_releaseMode);
-        }
-    }
-
-    inline jsize len() const noexcept
-    {
-        return m_arrayLength;
-    }
-
-    inline jboolean* ptr() const noexcept
-    {
-        return m_array;
-    }
-
-    inline jboolean& operator[](const int index) noexcept
-    {
-        return m_array[index];
-    }
-
-    inline void updateOnRelease() noexcept
-    {
-        m_releaseMode = 0;
-    }
-
-private:
-    JNIEnv* const m_env;
-    jbooleanArray const m_javaArray;
-    jsize const m_arrayLength;
-    jboolean* const m_array;
-    jint m_releaseMode;
-};
-
-extern jclass java_lang_long;
-extern jmethodID java_lang_long_init;
-extern jclass java_lang_float;
-extern jmethodID java_lang_float_init;
-extern jclass java_lang_double;
-extern jclass java_lang_string;
-extern jmethodID java_lang_double_init;
-extern jclass java_util_date;
-extern jmethodID java_util_date_init;
-
-inline jobject NewLong(JNIEnv* env, int64_t value)
-{
-    return env->NewObject(java_lang_long, java_lang_long_init, value);
-}
-
-inline jobject NewDouble(JNIEnv* env, double value)
-{
-    return env->NewObject(java_lang_double, java_lang_double_init, value);
-}
-
-inline jobject NewFloat(JNIEnv* env, float value)
-{
-    return env->NewObject(java_lang_float, java_lang_float_init, value);
-}
-
 inline jlong to_milliseconds(const realm::Timestamp& ts)
 {
     // From core's reference implementation aka unit test
@@ -737,11 +507,6 @@ inline realm::Timestamp from_milliseconds(jlong milliseconds)
     return realm::Timestamp(seconds, nanoseconds);
 }
 
-inline jobject NewDate(JNIEnv* env, const realm::Timestamp& ts)
-{
-    return env->NewObject(java_util_date, java_util_date_init, to_milliseconds(ts));
-}
-
 extern const std::string TABLE_PREFIX;
 
 static inline bool to_bool(jboolean b)
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index 894e581e0a..aa3f85e9e4 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -26,12 +26,19 @@
 import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import io.reactivex.Flowable;
+import javax.annotation.Nullable;
+
+import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.CheckedRow;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.InvalidRow;
-import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.OsObjectStore;
+import io.realm.internal.OsRealmConfig;
+import io.realm.internal.OsSchemaInfo;
+import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
@@ -39,8 +46,6 @@
 import io.realm.internal.Util;
 import io.realm.internal.async.RealmThreadPoolExecutor;
 import io.realm.log.RealmLog;
-import rx.Observable;
-
 
 /**
  * Base class for all Realm instances.
@@ -50,12 +55,11 @@
  */
 @SuppressWarnings("WeakerAccess")
 abstract class BaseRealm implements Closeable {
-    protected static final long UNVERSIONED = -1;
     private static final String INCORRECT_THREAD_CLOSE_MESSAGE =
             "Realm access from incorrect thread. Realm instance can only be closed on the thread it was created.";
-    private static final String INCORRECT_THREAD_MESSAGE =
+    static final String INCORRECT_THREAD_MESSAGE =
             "Realm access from incorrect thread. Realm objects can only be accessed on the thread they were created.";
-    private static final String CLOSED_REALM_MESSAGE =
+    static final String CLOSED_REALM_MESSAGE =
             "This Realm instance has already been closed, making it unusable.";
     private static final String NOT_IN_TRANSACTION_MESSAGE =
             "Changing Realm data can only be done from inside a transaction.";
@@ -69,23 +73,69 @@
 
     final long threadId;
     protected final RealmConfiguration configuration;
-    protected SharedRealm sharedRealm;
+    // Which RealmCache is this Realm associated to. It is null if the Realm instance is opened without being put into a
+    // cache. It is also null if the Realm is closed.
+    private RealmCache realmCache;
+    public SharedRealm sharedRealm;
+    private boolean shouldCloseSharedRealm;
+    private SharedRealm.SchemaChangedCallback schemaChangedCallback = new SharedRealm.SchemaChangedCallback() {
+        @Override
+        public void onSchemaChanged() {
+            RealmSchema schema = getSchema();
+            if (schema != null) {
+                schema.refresh();
+            }
+        }
+    };
 
-    protected final StandardRealmSchema schema;
+    // Create a realm instance and associate it to a RealmCache.
+    BaseRealm(RealmCache cache, @Nullable OsSchemaInfo schemaInfo) {
+        this(cache.getConfiguration(), schemaInfo);
+        this.realmCache = cache;
+    }
 
-    protected BaseRealm(RealmConfiguration configuration) {
+    // Create a realm instance without associating it to any RealmCache.
+    BaseRealm(final RealmConfiguration configuration, @Nullable OsSchemaInfo schemaInfo) {
         this.threadId = Thread.currentThread().getId();
         this.configuration = configuration;
+        this.realmCache = null;
+
+        SharedRealm.MigrationCallback migrationCallback = null;
+        if (schemaInfo != null && configuration.getMigration() != null) {
+            migrationCallback = createMigrationCallback(configuration.getMigration());
+        }
 
-        this.sharedRealm = SharedRealm.getInstance(configuration,
-                !(this instanceof Realm) ? null :
-                        new SharedRealm.SchemaVersionListener() {
-                            @Override
-                            public void onSchemaVersionChanged(long currentVersion) {
-                                RealmCache.updateSchemaCache((Realm) BaseRealm.this);
-                            }
-                        }, true);
-        this.schema = new StandardRealmSchema(this);
+        SharedRealm.InitializationCallback initializationCallback = null;
+        final Realm.Transaction initialDataTransaction = configuration.getInitialDataTransaction();
+        if (initialDataTransaction != null) {
+            initializationCallback = new SharedRealm.InitializationCallback() {
+                @Override
+                public void onInit(SharedRealm sharedRealm) {
+                    initialDataTransaction.execute(Realm.createInstance(sharedRealm));
+                }
+            };
+        }
+
+        OsRealmConfig.Builder configBuilder = new OsRealmConfig.Builder(configuration)
+                .autoUpdateNotification(true)
+                .migrationCallback(migrationCallback)
+                .schemaInfo(schemaInfo)
+                .initializationCallback(initializationCallback);
+        this.sharedRealm = SharedRealm.getInstance(configBuilder);
+        this.shouldCloseSharedRealm = true;
+
+        sharedRealm.registerSchemaChangedCallback(schemaChangedCallback);
+    }
+
+    // Create a realm instance directly from a SharedRealm instance. This instance doesn't have the ownership of the
+    // given SharedRealm instance. The SharedRealm instance should not be closed when close() called.
+    BaseRealm(SharedRealm sharedRealm) {
+        this.threadId = Thread.currentThread().getId();
+        this.configuration = sharedRealm.getConfiguration();
+        this.realmCache = null;
+
+        this.sharedRealm = sharedRealm;
+        this.shouldCloseSharedRealm = false;
     }
 
     /**
@@ -113,6 +163,24 @@ public boolean isAutoRefresh() {
         return sharedRealm.isAutoRefresh();
     }
 
+    /**
+     * Refreshes the Realm instance and all the RealmResults and RealmObjects instances coming from it.
+     * It also calls any listeners associated with the Realm if neeeded.
+     * <p>
+     * WARNING: Calling this on a thread with async queries will turn those queries into synchronous queries.
+     * In most cases it is better to use {@link RealmChangeListener}s to be notified about changes to the
+     * Realm on a given thread than it is to use this method.
+     *
+     * @throws IllegalStateException if attempting to refresh from within a transaction.
+     */
+    public void refresh() {
+        checkIfValid();
+        if (isInTransaction()) {
+            throw new IllegalStateException("Cannot refresh a Realm instance inside a transaction.");
+        }
+        sharedRealm.refresh();
+    }
+
     /**
      * Checks if the Realm is currently in a transaction.
      *
@@ -124,6 +192,7 @@ public boolean isInTransaction() {
     }
 
     protected <T extends BaseRealm> void addListener(RealmChangeListener<T> listener) {
+        //noinspection ConstantConditions
         if (listener == null) {
             throw new IllegalArgumentException("Listener should not be null");
         }
@@ -142,6 +211,7 @@ public boolean isInTransaction() {
      * @see io.realm.RealmChangeListener
      */
     protected <T extends BaseRealm> void removeListener(RealmChangeListener<T> listener) {
+        //noinspection ConstantConditions
         if (listener == null) {
             throw new IllegalArgumentException("Listener should not be null");
         }
@@ -152,16 +222,16 @@ public boolean isInTransaction() {
     }
 
     /**
-     * Returns an RxJava Observable that monitors changes to this Realm. It will emit the current state
+     * Returns an RxJava Flowable that monitors changes to this Realm. It will emit the current state
      * when subscribed to. Items will continually be emitted as the Realm is updated -
      * {@code onComplete} will never be called.
      * <p>
-     * If you would like the {@code asObservable()} to stop emitting items, you can instruct RxJava to
+     * If you would like the {@code asFlowable()} to stop emitting items, you can instruct RxJava to
      * only emit only the first item by using the {@code first()} operator:
      * <p>
      * <pre>
      * {@code
-     * realm.asObservable().first().subscribe( ... ) // You only get the results once
+     * realm.asFlowable().first().subscribe( ... ) // You only get the results once
      * }
      * </pre>
      *
@@ -169,7 +239,7 @@ public boolean isInTransaction() {
      * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath.
      * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
      */
-    public abstract Observable asObservable();
+    public abstract Flowable asFlowable();
 
     /**
      * Removes all user-defined change listeners.
@@ -196,7 +266,12 @@ protected void removeAllListeners() {
      * destination file.
      */
     public void writeCopyTo(File destination) {
-        writeEncryptedCopyTo(destination, null);
+        //noinspection ConstantConditions
+        if (destination == null) {
+            throw new IllegalArgumentException("The destination argument cannot be null");
+        }
+        checkIfValid();
+        sharedRealm.writeCopy(destination, null);
     }
 
     /**
@@ -215,6 +290,7 @@ public void writeCopyTo(File destination) {
      * destination file.
      */
     public void writeEncryptedCopyTo(File destination, byte[] key) {
+        //noinspection ConstantConditions
         if (destination == null) {
             throw new IllegalArgumentException("The destination argument cannot be null");
         }
@@ -259,16 +335,20 @@ public boolean waitForChange() {
      * @throws IllegalStateException if the {@link io.realm.Realm} instance has already been closed.
      */
     public void stopWaitForChange() {
-        RealmCache.invokeWithLock(new RealmCache.Callback0() {
-            @Override
-            public void onCall() {
-                // Checks if the Realm instance has been closed.
-                if (sharedRealm == null || sharedRealm.isClosed()) {
-                    throw new IllegalStateException(BaseRealm.CLOSED_REALM_MESSAGE);
+        if (realmCache != null) {
+            realmCache.invokeWithLock(new RealmCache.Callback0() {
+                @Override
+                public void onCall() {
+                    // Checks if the Realm instance has been closed.
+                    if (sharedRealm == null || sharedRealm.isClosed()) {
+                        throw new IllegalStateException(BaseRealm.CLOSED_REALM_MESSAGE);
+                    }
+                    sharedRealm.stopWaitForChange();
                 }
-                sharedRealm.stopWaitForChange();
-            }
-        });
+            });
+        } else {
+            throw new IllegalStateException(BaseRealm.CLOSED_REALM_MESSAGE);
+        }
     }
 
     /**
@@ -397,7 +477,7 @@ public RealmConfiguration getConfiguration() {
      * @return the schema version for the Realm file backing this Realm.
      */
     public long getVersion() {
-        return sharedRealm.getSchemaVersion();
+        return OsObjectStore.getSchemaVersion(sharedRealm);
     }
 
     /**
@@ -414,20 +494,22 @@ public void close() {
             throw new IllegalStateException(INCORRECT_THREAD_CLOSE_MESSAGE);
         }
 
-        RealmCache.release(this);
+        if (realmCache != null) {
+            realmCache.release(this);
+        } else {
+            doClose();
+        }
     }
 
     /**
      * Closes the Realm instances and all its resources without checking the {@link RealmCache}.
      */
     void doClose() {
-        if (sharedRealm != null) {
+        realmCache = null;
+        if (sharedRealm != null && shouldCloseSharedRealm) {
             sharedRealm.close();
             sharedRealm = null;
         }
-        if (schema != null) {
-            schema.close();
-        }
     }
 
     /**
@@ -454,23 +536,16 @@ public boolean isEmpty() {
         return sharedRealm.isEmpty();
     }
 
-    // package protected so unit tests can access it
-    void setVersion(long version) {
-        sharedRealm.setSchemaVersion(version);
-    }
-
     /**
      * Returns the schema for this Realm.
      *
      * @return The {@link RealmSchema} for this Realm.
      */
-    public RealmSchema getSchema() {
-        return schema;
-    }
+    public abstract RealmSchema getSchema();
 
-    // Used by RealmList/RealmResults, to create RealmObject from a Collection.
+    // Used by RealmList/RealmResults, to create RealmObject from a OsResults.
     // Invariant: if dynamicClassName != null -> clazz == DynamicRealmObject
-    <E extends RealmModel> E get(Class<E> clazz, String dynamicClassName, UncheckedRow row) {
+    <E extends RealmModel> E get(@Nullable Class<E> clazz, @Nullable String dynamicClassName, UncheckedRow row) {
         final boolean isDynamicRealmObject = dynamicClassName != null;
 
         E result;
@@ -478,26 +553,29 @@ public RealmSchema getSchema() {
             //noinspection unchecked
             result = (E) new DynamicRealmObject(this, CheckedRow.getFromRow(row));
         } else {
-            result = configuration.getSchemaMediator().newInstance(clazz, this, row, schema.getColumnInfo(clazz),
+            // 'clazz' is non-null when 'dynamicClassName' is null.
+            //noinspection ConstantConditions
+            result = configuration.getSchemaMediator().newInstance(clazz, this, row, getSchema().getColumnInfo(clazz),
                     false, Collections.<String>emptyList());
         }
         return result;
     }
 
     <E extends RealmModel> E get(Class<E> clazz, long rowIndex, boolean acceptDefaultValue, List<String> excludeFields) {
-        Table table = schema.getTable(clazz);
+        Table table = getSchema().getTable(clazz);
         UncheckedRow row = table.getUncheckedRow(rowIndex);
-        E result = configuration.getSchemaMediator().newInstance(clazz, this, row, schema.getColumnInfo(clazz),
+        return configuration.getSchemaMediator().newInstance(clazz, this, row, getSchema().getColumnInfo(clazz),
                 acceptDefaultValue, excludeFields);
-        return result;
     }
 
     // Used by RealmList/RealmResults
     // Invariant: if dynamicClassName != null -> clazz == DynamicRealmObject
     // TODO: Remove this after RealmList is backed by OS Results.
-    <E extends RealmModel> E get(Class<E> clazz, String dynamicClassName, long rowIndex) {
+    <E extends RealmModel> E get(@Nullable Class<E> clazz, @Nullable String dynamicClassName, long rowIndex) {
         final boolean isDynamicRealmObject = dynamicClassName != null;
-        final Table table = isDynamicRealmObject ? schema.getTable(dynamicClassName) : schema.getTable(clazz);
+        // 'clazz' is non-null when 'dynamicClassName' is null.
+        //noinspection ConstantConditions
+        final Table table = isDynamicRealmObject ? getSchema().getTable(dynamicClassName) : getSchema().getTable(clazz);
 
         E result;
         if (isDynamicRealmObject) {
@@ -508,7 +586,7 @@ public RealmSchema getSchema() {
         } else {
             result = configuration.getSchemaMediator().newInstance(clazz, this,
                     (rowIndex != Table.NO_MATCH) ? table.getUncheckedRow(rowIndex) : InvalidRow.INSTANCE,
-                    schema.getColumnInfo(clazz), false, Collections.<String>emptyList());
+                    getSchema().getColumnInfo(clazz), false, Collections.<String>emptyList());
         }
 
         return result;
@@ -521,8 +599,8 @@ public RealmSchema getSchema() {
      */
     public void deleteAll() {
         checkIfValid();
-        for (RealmObjectSchema objectSchema : schema.getAll()) {
-            schema.getTable(objectSchema.getClassName()).clear();
+        for (RealmObjectSchema objectSchema : getSchema().getAll()) {
+            getSchema().getTable(objectSchema.getClassName()).clear();
         }
     }
 
@@ -531,20 +609,20 @@ public void deleteAll() {
      */
     static boolean deleteRealm(final RealmConfiguration configuration) {
         final AtomicBoolean realmDeleted = new AtomicBoolean(true);
-        RealmCache.invokeWithGlobalRefCount(configuration, new RealmCache.Callback() {
+        boolean callbackExecuted = OsObjectStore.callWithLock(configuration, new Runnable() {
             @Override
-            public void onResult(int count) {
-                if (count != 0) {
-                    throw new IllegalStateException("It's not allowed to delete the file associated with an open Realm. " +
-                            "Remember to close() all the instances of the Realm before deleting its file: " + configuration.getPath());
-                }
-
+            public void run() {
                 String canonicalPath = configuration.getPath();
                 File realmFolder = configuration.getRealmDirectory();
                 String realmFileName = configuration.getRealmFileName();
                 realmDeleted.set(Util.deleteRealm(canonicalPath, realmFolder, realmFileName));
             }
         });
+        if (!callbackExecuted) {
+            throw new IllegalStateException("It's not allowed to delete the file associated with an open Realm. " +
+                    "Remember to close() all the instances of the Realm before deleting its file: "
+                    + configuration.getPath());
+        }
         return realmDeleted.get();
     }
 
@@ -567,15 +645,13 @@ static boolean compactRealm(final RealmConfiguration configuration) {
      * @param configuration configuration for the Realm that should be migrated. If this is a SyncConfiguration this
      * method does nothing.
      * @param migration if set, this migration block will override what is set in {@link RealmConfiguration}.
-     * @param callback callback for specific Realm type behaviors.
-     * @param cause which triggers this migration.
      * @throws FileNotFoundException if the Realm file doesn't exist.
-     * @throws IllegalArgumentException if the provided configuration is a {@link SyncConfiguration}.
+     * @throws IllegalArgumentException if the provided configuration is a {@code SyncConfiguration}.
      */
-    protected static void migrateRealm(final RealmConfiguration configuration, final RealmMigration migration,
-            final MigrationCallback callback, final RealmMigrationNeededException cause)
+    protected static void migrateRealm(final RealmConfiguration configuration, @Nullable final RealmMigration migration)
             throws FileNotFoundException {
 
+        //noinspection ConstantConditions
         if (configuration == null) {
             throw new IllegalArgumentException("RealmConfiguration must be provided");
         }
@@ -583,7 +659,7 @@ protected static void migrateRealm(final RealmConfiguration configuration, final
             throw new IllegalArgumentException("Manual migrations are not supported for synced Realms");
         }
         if (migration == null && configuration.getMigration() == null) {
-            throw new RealmMigrationNeededException(configuration.getPath(), "RealmMigration must be provided", cause);
+            throw new RealmMigrationNeededException(configuration.getPath(), "RealmMigration must be provided.");
         }
 
         final AtomicBoolean fileNotFound = new AtomicBoolean(false);
@@ -602,24 +678,24 @@ public void onResult(int count) {
                     return;
                 }
 
-                RealmMigration realmMigration = (migration == null) ? configuration.getMigration() : migration;
-                DynamicRealm realm = null;
+                RealmProxyMediator mediator = configuration.getSchemaMediator();
+                OsSchemaInfo schemaInfo = new OsSchemaInfo(mediator.getExpectedObjectSchemaInfoMap().values());
+                SharedRealm.MigrationCallback migrationCallback = null;
+                final RealmMigration migrationToBeApplied = migration != null ? migration : configuration.getMigration();
+                if (migrationToBeApplied != null) {
+                    migrationCallback = createMigrationCallback(migrationToBeApplied);
+                }
+                OsRealmConfig.Builder configBuilder = new OsRealmConfig.Builder(configuration)
+                        .autoUpdateNotification(false)
+                        .schemaInfo(schemaInfo)
+                        .migrationCallback(migrationCallback);
+                SharedRealm sharedRealm = null;
                 try {
-                    realm = DynamicRealm.getInstance(configuration);
-                    realm.beginTransaction();
-                    long currentVersion = realm.getVersion();
-                    realmMigration.migrate(realm, currentVersion, configuration.getSchemaVersion());
-                    realm.setVersion(configuration.getSchemaVersion());
-                    realm.commitTransaction();
-                } catch (RuntimeException e) {
-                    if (realm != null) {
-                        realm.cancelTransaction();
-                    }
-                    throw e;
+                    sharedRealm =
+                            SharedRealm.getInstance(configBuilder);
                 } finally {
-                    if (realm != null) {
-                        realm.close();
-                        callback.migrationComplete();
+                    if (sharedRealm != null) {
+                        sharedRealm.close();
                     }
                 }
             }
@@ -631,13 +707,25 @@ public void onResult(int count) {
         }
     }
 
+    private static SharedRealm.MigrationCallback createMigrationCallback(final RealmMigration migration) {
+        return new SharedRealm.MigrationCallback() {
+            @Override
+            public void onMigrationNeeded(SharedRealm sharedRealm, long oldVersion, long newVersion) {
+                migration.migrate(DynamicRealm.createInstance(sharedRealm), oldVersion, newVersion);
+            }
+        };
+    }
+
     @Override
     protected void finalize() throws Throwable {
-        if (sharedRealm != null && !sharedRealm.isClosed()) {
+        if (shouldCloseSharedRealm && sharedRealm != null && !sharedRealm.isClosed()) {
             RealmLog.warn("Remember to call close() on all Realm instances. " +
                     "Realm %s is being finalized without being closed, " +
                     "this can lead to running out of native memory.", configuration.getPath()
             );
+            if (realmCache != null) {
+                realmCache.leak();
+            }
         }
         super.finalize();
     }
@@ -646,11 +734,6 @@ SharedRealm getSharedRealm() {
         return sharedRealm;
     }
 
-    // Internal delegate for migrations.
-    protected interface MigrationCallback {
-        void migrationComplete();
-    }
-
     public static final class RealmObjectContext {
         private BaseRealm realm;
         private Row row;
@@ -696,6 +779,7 @@ public void clear() {
         }
     }
 
+    // FIXME: This stuff doesn't appear to be used.  It should either be explained or deleted.
     static final class ThreadLocalRealmObjectContext extends ThreadLocal<RealmObjectContext> {
         @Override
         protected RealmObjectContext initialValue() {
@@ -704,4 +788,90 @@ protected RealmObjectContext initialValue() {
     }
 
     public static final ThreadLocalRealmObjectContext objectContext = new ThreadLocalRealmObjectContext();
+
+    /**
+     * The Callback used when reporting back the result of loading a Realm asynchronously using either
+     * {@link Realm#getInstanceAsync(RealmConfiguration, Realm.Callback)} or
+     * {@link DynamicRealm#getInstanceAsync(RealmConfiguration, DynamicRealm.Callback)}.
+     * <p>
+     * Before creating the first Realm instance in a process, there are some initialization work that need to be done
+     * such as creating or validating schemas, running migration if needed,
+     * copy asset file if {@link RealmConfiguration.Builder#assetFile(String)} is supplied and execute the
+     * {@link RealmConfiguration.Builder#initialData(Realm.Transaction)} if necessary. This work may take time
+     * and block the caller thread for a while. To avoid the {@code getInstance()} call blocking the main thread, the
+     * {@code getInstanceAsync()} can be used instead to do the initialization work in the background thread and
+     * deliver a Realm instance to the caller thread.
+     * <p>
+     * In general, this method is mostly useful on the UI thread since that should be blocked as little as possible. On
+     * any other Looper threads or other threads that don't support callbacks, using the standard {@code getInstance()}
+     * should be fine.
+     * <p>
+     * Here is an example of using {@code getInstanceAsync()} when the app starts the first activity:
+     * <pre>
+     * public class MainActivity extends Activity {
+     *
+     *   private Realm realm = null;
+     *   private RealmAsyncTask realmAsyncTask;
+     *   private static RealmConfiguration config = new RealmConfiguration.Builder()
+     *     .schema(42)
+     *     .migration(new MyMigration()) // Potentially lengthy migration
+     *     .build();
+     *
+     *   \@Override
+     *   protected void onCreate(Bundle savedInstanceState) {
+     *     super.onCreate(savedInstanceState);
+     *     setContentView(R.layout.layout_main);
+     *     realmAsyncTask = Realm.getInstanceAsync(config, new Callback() {
+     *         \@Override
+     *         public void onSuccess(Realm realm) {
+     *             if (isDestroyed()) {
+     *                 // If the activity is destroyed, the Realm instance should be closed immediately to avoid leaks.
+     *                 // Or you can call realmAsyncTask.cancel() in onDestroy() to stop callback delivery.
+     *                 realm.close();
+     *             } else {
+     *                 MainActivity.this.realm = realm;
+     *                 // Remove the spinner and start the real UI.
+     *             }
+     *         }
+     *     });
+     *
+     *     // Show a spinner before Realm instance returned by the callback.
+     *   }
+     *
+     *   \@Override
+     *   protected void onDestroy() {
+     *     super.onDestroy();
+     *     if (realm != null) {
+     *         realm.close();
+     *         realm = null;
+     *     } else {
+     *         // Calling cancel() on the thread where getInstanceAsync was called on to stop the callback delivery.
+     *         // Otherwise you need to check if the activity is destroyed to close in the onSuccess() properly.
+     *         realmAsyncTask.cancel();
+     *     }
+     *   }
+     * }
+     * </pre>
+     *
+     * @param <T> {@link Realm} or {@link DynamicRealm}.
+     */
+    public abstract static class InstanceCallback<T extends BaseRealm> {
+
+        /**
+         * Deliver a Realm instance to the caller thread.
+         *
+         * @param realm the Realm instance for the caller thread.
+         */
+        public abstract void onSuccess(T realm);
+
+        /**
+         * Deliver an error happens when creating the Realm instance to the caller thread. The default implementation
+         * will throw an exception on the caller thread.
+         *
+         * @param exception happened while initializing Realm on a background thread.
+         */
+        public void onError(Throwable exception) {
+            throw new RealmException("Exception happens when initializing Realm in the background thread.", exception);
+        }
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/CompactOnLaunchCallback.java b/realm/realm-library/src/main/java/io/realm/CompactOnLaunchCallback.java
new file mode 100644
index 0000000000..9f1a4866f9
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/CompactOnLaunchCallback.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import io.realm.internal.Keep;
+
+/**
+ * This interface is used to determine if a Realm file should be compacted the first time the file is opened and before
+ * the instance is returned.
+ * <p>
+ * Note that compacting a file can take a while, so compacting should generally only be done on a background thread or
+ * when used in combination with {@link Realm#getInstanceAsync(RealmConfiguration, io.realm.Realm.Callback)}.
+ */
+@Keep
+public interface CompactOnLaunchCallback {
+
+    /**
+     * This method determines if the Realm file should be compacted before opened and returned to the user. It is passed
+     * the total file size (data + free space) and the bytes used by data in the file.
+     *
+     * @param totalBytes the total file size (data + free space).
+     * @param usedBytes the total bytes used by data in the file.
+     * @return {code true} to indicate an attempt to compact the file should be made. Otherwise, the compaction will be
+     * skipped.
+     */
+    boolean shouldCompact(long totalBytes, long usedBytes);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/DefaultCompactOnLaunchCallback.java b/realm/realm-library/src/main/java/io/realm/DefaultCompactOnLaunchCallback.java
new file mode 100644
index 0000000000..59369a51a6
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/DefaultCompactOnLaunchCallback.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+/**
+ * The default implementation for determining if a file should be compacted or not. This implementation will only
+ * trigger if the file is above 50 MB and more than 50% can be reclaimed.
+ */
+public class DefaultCompactOnLaunchCallback implements CompactOnLaunchCallback {
+    @Override
+    public boolean shouldCompact(long totalBytes, long usedBytes) {
+        final long thresholdSize = 50 * 1024 * 1024;
+        return (totalBytes > thresholdSize) && (((double) usedBytes / (double) totalBytes) < 0.5);
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
index 3a4f79ea94..ec14a7169e 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
@@ -16,12 +16,17 @@
 
 package io.realm;
 
+import io.reactivex.Flowable;
+import java.util.Locale;
+
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmFileException;
+import io.realm.internal.CheckedRow;
+import io.realm.internal.OsObject;
+import io.realm.internal.OsObjectStore;
+import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.log.RealmLog;
-import rx.Observable;
-
 
 /**
  * DynamicRealm is a dynamic variant of {@link io.realm.Realm}. This means that all access to data and/or queries are
@@ -45,8 +50,36 @@
  */
 public class DynamicRealm extends BaseRealm {
 
-    private DynamicRealm(RealmConfiguration configuration) {
-        super(configuration);
+    private final RealmSchema schema;
+
+    private DynamicRealm(final RealmCache cache) {
+        super(cache, null);
+        RealmCache.invokeWithGlobalRefCount(cache.getConfiguration(), new RealmCache.Callback() {
+            @Override
+            public void onResult(int count) {
+                if (count > 0)  {
+                    return;
+                }
+                if (cache.getConfiguration().isReadOnly()) {
+                    return;
+                }
+                if (OsObjectStore.getSchemaVersion(sharedRealm) != OsObjectStore.SCHEMA_NOT_VERSIONED) {
+                    return;
+                }
+                sharedRealm.beginTransaction();
+                if (OsObjectStore.getSchemaVersion(sharedRealm) == OsObjectStore.SCHEMA_NOT_VERSIONED) {
+                    // To initialize the meta table.
+                    OsObjectStore.setSchemaVersion(sharedRealm, OsObjectStore.SCHEMA_NOT_VERSIONED);
+                }
+                sharedRealm.commitTransaction();
+            }
+        });
+        this.schema = new MutableRealmSchema(this);
+    }
+
+    private DynamicRealm(SharedRealm sharedRealm) {
+        super(sharedRealm);
+        this.schema = new MutableRealmSchema(this);
     }
 
     /**
@@ -60,12 +93,35 @@ private DynamicRealm(RealmConfiguration configuration) {
      * @see RealmConfiguration for details on how to configure a Realm.
      */
     public static DynamicRealm getInstance(RealmConfiguration configuration) {
+        //noinspection ConstantConditions
         if (configuration == null) {
             throw new IllegalArgumentException("A non-null RealmConfiguration must be provided");
         }
         return RealmCache.createRealmOrGetFromCache(configuration, DynamicRealm.class);
     }
 
+    /**
+     * The creation of the first Realm instance per {@link RealmConfiguration} in a process can take some time as all
+     * initialization code need to run at that point (Setting up the Realm, validating schemas and creating initial
+     * data). This method places the initialization work in a background thread and deliver the Realm instance
+     * to the caller thread asynchronously after the initialization is finished.
+     *
+     * @param configuration {@link RealmConfiguration} used to open the Realm.
+     * @param callback invoked to return the results.
+     * @throws IllegalArgumentException if a null {@link RealmConfiguration} or a null {@link Callback} is provided.
+     * @throws IllegalStateException if it is called from a non-Looper or {@link android.app.IntentService} thread.
+     * @return a {@link RealmAsyncTask} representing a cancellable task.
+     * @see Callback for more details.
+     */
+    public static RealmAsyncTask getInstanceAsync(RealmConfiguration configuration,
+                                                  Callback callback) {
+        //noinspection ConstantConditions
+        if (configuration == null) {
+            throw new IllegalArgumentException("A non-null RealmConfiguration must be provided");
+        }
+        return RealmCache.createRealmOrGetFromCacheAsync(configuration, callback, DynamicRealm.class);
+    }
+
     /**
      * Instantiates and adds a new object to the Realm.
      *
@@ -76,13 +132,15 @@ public static DynamicRealm getInstance(RealmConfiguration configuration) {
     public DynamicRealmObject createObject(String className) {
         checkIfValid();
         Table table = schema.getTable(className);
+        String pkField = OsObjectStore.getPrimaryKeyForObject(sharedRealm, className);
         // Check and throw the exception earlier for a better exception message.
-        if (table.hasPrimaryKey()) {
-            throw new RealmException(String.format("'%s' has a primary key, use" +
-                    " 'createObject(String, Object)' instead.", className));
+        if (pkField != null) {
+            throw new RealmException(String.format(Locale.US,
+                    "'%s' has a primary key field '%s', use  'createObject(String, Object)' instead.",
+                    className, pkField));
         }
-        long rowIndex = table.addEmptyRow();
-        return get(DynamicRealmObject.class, className, rowIndex);
+
+        return new DynamicRealmObject(this, CheckedRow.getFromRow(OsObject.create(table)));
     }
 
     /**
@@ -98,8 +156,8 @@ public DynamicRealmObject createObject(String className) {
      */
     public DynamicRealmObject createObject(String className, Object primaryKeyValue) {
         Table table = schema.getTable(className);
-        long index = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
-        return new DynamicRealmObject(this, table.getCheckedRow(index));
+        return new DynamicRealmObject(this,
+                CheckedRow.getFromRow(OsObject.createWithPrimaryKey(table, primaryKeyValue)));
     }
 
     /**
@@ -112,7 +170,7 @@ public DynamicRealmObject createObject(String className, Object primaryKeyValue)
      */
     public RealmQuery<DynamicRealmObject> where(String className) {
         checkIfValid();
-        if (!sharedRealm.hasTable(Table.TABLE_PREFIX + className)) {
+        if (!sharedRealm.hasTable(Table.getTableNameForClass(className))) {
             throw new IllegalArgumentException("Class does not exist in the Realm and cannot be queried: " + className);
         }
         return RealmQuery.createDynamicQuery(this, className);
@@ -181,6 +239,7 @@ public void delete(String className) {
      * @throws IllegalArgumentException if the {@code transaction} is {@code null}.
      */
     public void executeTransaction(Transaction transaction) {
+        //noinspection ConstantConditions
         if (transaction == null) {
             throw new IllegalArgumentException("Transaction should not be null");
         }
@@ -204,18 +263,52 @@ public void executeTransaction(Transaction transaction) {
      *
      * @return a {@link DynamicRealm} instance.
      */
-    static DynamicRealm createInstance(RealmConfiguration configuration) {
-        return new DynamicRealm(configuration);
+    static DynamicRealm createInstance(RealmCache cache) {
+        return new DynamicRealm(cache);
+    }
+
+    /**
+     * Creates a {@link DynamicRealm} instance with a given {@link SharedRealm} instance without owning it.
+     * This is designed to be used in the migration block when opening a typed Realm instance.
+     *
+     * @param sharedRealm the existing {@link SharedRealm} instance.
+     * @return a {@link DynamicRealm} instance.
+     */
+    static DynamicRealm createInstance(SharedRealm sharedRealm) {
+        return new DynamicRealm(sharedRealm);
     }
 
     /**
      * {@inheritDoc}
      */
     @Override
-    public Observable<DynamicRealm> asObservable() {
+    public Flowable<DynamicRealm> asFlowable() {
         return configuration.getRxFactory().from(this);
     }
 
+    /**
+     * Returns the mutable schema for this Realm.
+     *
+     * @return The {@link RealmSchema} for this Realm.
+     */
+    @Override
+    public RealmSchema getSchema() {
+        return schema;
+    }
+
+    /**
+     * Set the schema version of this dynamic realm to the given version number. If the meta table doesn't exist, this
+     * will create the meta table first.
+     * <p>
+     * NOTE: This API is for internal testing only. Except testing, the schema version should always be set by the
+     * Object Store during schema initialization or migration.
+     *
+     * @param version the schema version to be set.
+     */
+    void setVersion(long version) {
+        OsObjectStore.setSchemaVersion(sharedRealm, version);
+    }
+
     /**
      * Encapsulates a Realm transaction.
      * <p>
@@ -226,5 +319,23 @@ static DynamicRealm createInstance(RealmConfiguration configuration) {
     public interface Transaction {
         void execute(DynamicRealm realm);
     }
-}
 
+    /**
+     * {@inheritDoc}
+     */
+    public static abstract class Callback extends InstanceCallback<DynamicRealm> {
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public abstract void onSuccess(DynamicRealm realm);
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void onError(Throwable exception) {
+            super.onError(exception);
+        }
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
index 0d1d518201..85fbbaecdf 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
@@ -17,11 +17,15 @@
 
 import java.util.Arrays;
 import java.util.Date;
+import java.util.Iterator;
 import java.util.Locale;
 
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
 import io.realm.exceptions.RealmException;
 import io.realm.internal.CheckedRow;
-import io.realm.internal.LinkView;
+import io.realm.internal.OsList;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.Table;
@@ -35,8 +39,9 @@
  */
 @SuppressWarnings("WeakerAccess")
 public class DynamicRealmObject extends RealmObject implements RealmObjectProxy {
+    static final String MSG_LINK_QUERY_NOT_SUPPORTED = "Queries across relationships are not supported";
 
-    private final ProxyState proxyState = new ProxyState(this);
+    private final ProxyState<DynamicRealmObject> proxyState = new ProxyState<>(this);
 
     /**
      * Creates a dynamic Realm object based on an existing object.
@@ -45,6 +50,7 @@
      * @throws IllegalArgumentException if object isn't managed by Realm or is a {@link DynamicRealmObject} already.
      */
     public DynamicRealmObject(RealmModel obj) {
+        //noinspection ConstantConditions
         if (obj == null) {
             throw new IllegalArgumentException("A non-null object must be provided.");
         }
@@ -69,7 +75,7 @@ public DynamicRealmObject(RealmModel obj) {
         proxyState.setConstructionFinished();
     }
 
-    // row must not be an instance of UncheckedRow
+    // row must be an instance of CheckedRow or InvalidRow
     DynamicRealmObject(BaseRealm realm, Row row) {
         proxyState.setRealm$realm(realm);
         proxyState.setRow$realm(row);
@@ -108,8 +114,6 @@ public DynamicRealmObject(RealmModel obj) {
                 return (E) getObject(fieldName);
             case LIST:
                 return (E) getList(fieldName);
-            case UNSUPPORTED_TABLE:
-            case UNSUPPORTED_MIXED:
             default:
                 throw new IllegalStateException("Field type not supported: " + type);
         }
@@ -316,6 +320,7 @@ public Date getDate(String fieldName) {
      * @return the {@link DynamicRealmObject} representation of the linked object or {@code null} if no object is linked.
      * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain links to other objects.
      */
+    @Nullable
     public DynamicRealmObject getObject(String fieldName) {
         proxyState.getRealm$realm().checkIfValid();
 
@@ -331,26 +336,81 @@ public DynamicRealmObject getObject(String fieldName) {
     }
 
     /**
-     * Returns the {@link RealmList} of objects being linked to from this field.
+     * Returns the {@link RealmList} of {@link DynamicRealmObject}s being linked from the given field.
+     * <p>
+     * If the list contains primitive types, use {@link #getList(String, Class)} instead.
      *
      * @param fieldName the name of the field.
      * @return the {@link RealmList} data for this field.
-     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain a list of links.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain a list of objects.
      */
     public RealmList<DynamicRealmObject> getList(String fieldName) {
         proxyState.getRealm$realm().checkIfValid();
 
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         try {
-            LinkView linkView = proxyState.getRow$realm().getLinkList(columnIndex);
-            String className = RealmSchema.getSchemaForTable(linkView.getTargetTable());
-            return new RealmList<>(className, linkView, proxyState.getRealm$realm());
+            OsList osList = proxyState.getRow$realm().getModelList(columnIndex);
+            //noinspection ConstantConditions
+            @Nonnull
+            String className = osList.getTargetTable().getClassName();
+            return new RealmList<>(className, osList, proxyState.getRealm$realm());
         } catch (IllegalArgumentException e) {
             checkFieldType(fieldName, columnIndex, RealmFieldType.LIST);
             throw e;
         }
     }
 
+    /**
+     * Returns the {@link RealmList} containing only primitive values.
+     *
+     * <p>
+     * If the list contains references to other Realm objects, use {@link #getList(String)} instead.
+     *
+     * @param fieldName the name of the field.
+     * @param primitiveType the type of elements in the list. Only primitive types are supported.
+     * @return the {@link RealmList} data for this field.
+     * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain a list of primitive objects.
+     */
+    public <E> RealmList<E> getList(String fieldName, Class<E> primitiveType) {
+        proxyState.getRealm$realm().checkIfValid();
+
+        if (primitiveType == null) {
+            throw new IllegalArgumentException("Non-null 'primitiveType' required.");
+        }
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        RealmFieldType realmType = classToRealmType(primitiveType);
+        try {
+            OsList osList = proxyState.getRow$realm().getValueList(columnIndex, realmType);
+            return new RealmList<>(primitiveType, osList, proxyState.getRealm$realm());
+        } catch (IllegalArgumentException e) {
+            checkFieldType(fieldName, columnIndex, realmType);
+            throw e;
+        }
+    }
+
+    private <E> RealmFieldType classToRealmType(Class<E> primitiveType) {
+        if (primitiveType.equals(Integer.class)
+                || primitiveType.equals(Long.class)
+                || primitiveType.equals(Short.class)
+                || primitiveType.equals(Byte.class)) {
+            return RealmFieldType.INTEGER_LIST;
+        } else if (primitiveType.equals(Boolean.class)) {
+            return RealmFieldType.BOOLEAN_LIST;
+        } else if (primitiveType.equals(String.class)) {
+            return RealmFieldType.STRING_LIST;
+        } else if (primitiveType.equals(byte[].class)) {
+            return RealmFieldType.BINARY_LIST;
+        } else if (primitiveType.equals(Date.class)) {
+            return RealmFieldType.DATE_LIST;
+        } else if (primitiveType.equals(Float.class)) {
+            return RealmFieldType.FLOAT_LIST;
+        } else if (primitiveType.equals(Double.class)) {
+            return RealmFieldType.DOUBLE_LIST;
+        } else {
+            throw new IllegalArgumentException("Unsupported element type. Only primitive types supported. Yours was: " + primitiveType);
+        }
+    }
+
     /**
      * Checks if the value of a given field is {@code null}.
      *
@@ -375,8 +435,15 @@ public boolean isNull(String fieldName) {
             case DATE:
                 return proxyState.getRow$realm().isNull(columnIndex);
             case LIST:
-            case UNSUPPORTED_TABLE:
-            case UNSUPPORTED_MIXED:
+            case LINKING_OBJECTS:
+            case INTEGER_LIST:
+            case BOOLEAN_LIST:
+            case STRING_LIST:
+            case BINARY_LIST:
+            case DATE_LIST:
+            case FLOAT_LIST:
+            case DOUBLE_LIST:
+                // fall through
             default:
                 return false;
         }
@@ -391,7 +458,7 @@ public boolean isNull(String fieldName) {
     public boolean hasField(String fieldName) {
         proxyState.getRealm$realm().checkIfValid();
 
-        //noinspection SimplifiableIfStatement
+        //noinspection SimplifiableIfStatement,ConstantConditions
         if (fieldName == null || fieldName.isEmpty()) {
             return false;
         }
@@ -453,7 +520,8 @@ public void set(String fieldName, Object value) {
                     value = JsonUtils.stringToDate(strValue);
                     break;
                 default:
-                    throw new IllegalArgumentException(String.format("Field %s is not a String field, " +
+                    throw new IllegalArgumentException(String.format(Locale.US,
+                            "Field %s is not a String field, " +
                             "and the provide value could not be automatically converted: %s. Use a typed" +
                             "setter instead", fieldName, value));
             }
@@ -492,8 +560,7 @@ private void setValue(String fieldName, Object value) {
         } else if (valueClass == DynamicRealmObject.class) {
             setObject(fieldName, (DynamicRealmObject) value);
         } else if (valueClass == RealmList.class) {
-            @SuppressWarnings("unchecked")
-            RealmList<DynamicRealmObject> list = (RealmList<DynamicRealmObject>) value;
+            RealmList<?> list = (RealmList<?>) value;
             setList(fieldName, list);
         } else {
             throw new IllegalArgumentException("Value is of an type not supported: " + value.getClass());
@@ -614,7 +681,7 @@ public void setDouble(String fieldName, double value) {
      * @throws IllegalArgumentException if field name doesn't exist or field isn't a String field.
      * @throws RealmException if the field is a {@link io.realm.annotations.PrimaryKey} field.
      */
-    public void setString(String fieldName, String value) {
+    public void setString(String fieldName, @Nullable String value) {
         proxyState.getRealm$realm().checkIfValid();
 
         checkIsPrimaryKey(fieldName);
@@ -629,7 +696,7 @@ public void setString(String fieldName, String value) {
      * @param value value to insert.
      * @throws IllegalArgumentException if field name doesn't exist or field isn't a binary field.
      */
-    public void setBlob(String fieldName, byte[] value) {
+    public void setBlob(String fieldName, @Nullable byte[] value) {
         proxyState.getRealm$realm().checkIfValid();
 
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -643,7 +710,7 @@ public void setBlob(String fieldName, byte[] value) {
      * @param value value to insert.
      * @throws IllegalArgumentException if field name doesn't exist or field isn't a Date field.
      */
-    public void setDate(String fieldName, Date value) {
+    public void setDate(String fieldName, @Nullable Date value) {
         proxyState.getRealm$realm().checkIfValid();
 
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -662,7 +729,7 @@ public void setDate(String fieldName, Date value) {
      * @throws IllegalArgumentException if field name doesn't exist, it doesn't link to other Realm objects, the type
      * of DynamicRealmObject doesn't match or it belongs to a different Realm.
      */
-    public void setObject(String fieldName, DynamicRealmObject value) {
+    public void setObject(String fieldName, @Nullable DynamicRealmObject value) {
         proxyState.getRealm$realm().checkIfValid();
 
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
@@ -678,7 +745,8 @@ public void setObject(String fieldName, DynamicRealmObject value) {
             Table table = proxyState.getRow$realm().getTable().getLinkTarget(columnIndex);
             Table inputTable = value.proxyState.getRow$realm().getTable();
             if (!table.hasSameSchema(inputTable)) {
-                throw new IllegalArgumentException(String.format("Type of object is wrong. Was %s, expected %s",
+                throw new IllegalArgumentException(String.format(Locale.US,
+                        "Type of object is wrong. Was %s, expected %s",
                         inputTable.getName(), table.getName()));
             }
             proxyState.getRow$realm().setLink(columnIndex, value.proxyState.getRow$realm().getIndex());
@@ -689,22 +757,58 @@ public void setObject(String fieldName, DynamicRealmObject value) {
      * Sets the reference to a {@link RealmList} on the given field.
      *
      * @param fieldName field name.
-     * @param list list of references.
-     * @throws IllegalArgumentException if field name doesn't exist, it is not a list field, the type
-     * of the object represented by the DynamicRealmObject doesn't match or any element in the list belongs to a
-     * different Realm.
+     * @param list list of objects. Must either be primitive types or {@link DynamicRealmObject}s.
+     * @throws IllegalArgumentException if field name doesn't exist, it is not a list field, the objects in the
+     * list doesn't match the expected type or any Realm object in the list belongs to a different Realm.
      */
-    public void setList(String fieldName, RealmList<DynamicRealmObject> list) {
+    public <E> void setList(String fieldName, RealmList<E> list) {
         proxyState.getRealm$realm().checkIfValid();
 
+        //noinspection ConstantConditions
         if (list == null) {
-            throw new IllegalArgumentException("Null values not allowed for lists");
+            throw new IllegalArgumentException("Non-null 'list' required");
         }
 
+        // Find type of list in Realm
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
-        LinkView links = proxyState.getRow$realm().getLinkList(columnIndex);
-        Table linkTargetTable = links.getTargetTable();
-        final String linkTargetTableName = Table.tableNameToClassName(linkTargetTable.getName());
+        final RealmFieldType columnType = proxyState.getRow$realm().getColumnType(columnIndex);
+
+        switch (columnType) {
+            case LIST:
+                // Due to type erasure it is not possible to check the generic parameter,
+                // instead we try to see if the first element is of the wrong type in order
+                // to throw a better error message.
+                // Primitive types are checked inside `setModelList`
+                if (!list.isEmpty()) {
+                    E element = list.first();
+                    if (!(element instanceof DynamicRealmObject) && RealmModel.class.isAssignableFrom(element.getClass())) {
+                        throw new IllegalArgumentException("RealmList must contain `DynamicRealmObject's, not Java model classes.");
+                    }
+                }
+                //noinspection unchecked
+                setModelList(fieldName, (RealmList<DynamicRealmObject>) list);
+                break;
+            case INTEGER_LIST:
+            case BOOLEAN_LIST:
+            case STRING_LIST:
+            case BINARY_LIST:
+            case DATE_LIST:
+            case FLOAT_LIST:
+            case DOUBLE_LIST:
+                setValueList(fieldName, list, columnType);
+                break;
+            default:
+                throw new IllegalArgumentException(String.format("Field '%s' is not a list but a %s", fieldName, columnType));
+        }
+    }
+
+    private void setModelList(String fieldName, RealmList<DynamicRealmObject> list) {
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        OsList osList = proxyState.getRow$realm().getModelList(columnIndex);
+        Table linkTargetTable = osList.getTargetTable();
+        //noinspection ConstantConditions
+        @Nonnull
+        final String linkTargetTableName = linkTargetTable.getClassName();
 
         boolean typeValidated;
         if (list.className == null && list.clazz == null) {
@@ -713,9 +817,9 @@ public void setList(String fieldName, RealmList<DynamicRealmObject> list) {
             typeValidated = false;
         } else {
             String listType = list.className != null ? list.className
-                    : Table.tableNameToClassName(proxyState.getRealm$realm().getSchema().getTable(list.clazz).getName());
+                    : proxyState.getRealm$realm().getSchema().getTable(list.clazz).getClassName();
             if (!linkTargetTableName.equals(listType)) {
-                throw new IllegalArgumentException(String.format(Locale.ENGLISH,
+                throw new IllegalArgumentException(String.format(Locale.US,
                         "The elements in the list are not the proper type. " +
                                 "Was %s expected %s.", listType, linkTargetTableName));
             }
@@ -731,22 +835,90 @@ public void setList(String fieldName, RealmList<DynamicRealmObject> list) {
                 throw new IllegalArgumentException("Each element in 'list' must belong to the same Realm instance.");
             }
             if (!typeValidated && !linkTargetTable.hasSameSchema(obj.realmGet$proxyState().getRow$realm().getTable())) {
-                throw new IllegalArgumentException(String.format(Locale.ENGLISH,
+                throw new IllegalArgumentException(String.format(Locale.US,
                         "Element at index %d is not the proper type. " +
                                 "Was '%s' expected '%s'.",
                         i,
-                        Table.tableNameToClassName(obj.realmGet$proxyState().getRow$realm().getTable().getName()),
+                        obj.realmGet$proxyState().getRow$realm().getTable().getClassName(),
                         linkTargetTableName));
             }
             indices[i] = obj.realmGet$proxyState().getRow$realm().getIndex();
         }
 
-        links.clear();
+        osList.removeAll();
         for (int i = 0; i < listLength; i++) {
-            links.add(indices[i]);
+            osList.addRow(indices[i]);
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    private <E> void setValueList(String fieldName, RealmList<E> list, RealmFieldType primitiveType) {
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        OsList osList = proxyState.getRow$realm().getValueList(columnIndex, primitiveType);
+
+        Class<E> elementClass;
+        switch(primitiveType) {
+            case INTEGER_LIST: elementClass = (Class<E>) Long.class; break;
+            case BOOLEAN_LIST: elementClass = (Class<E>) Boolean.class; break;
+            case STRING_LIST: elementClass = (Class<E>) String.class; break;
+            case BINARY_LIST: elementClass = (Class<E>) byte[].class; break;
+            case DATE_LIST: elementClass = (Class<E>) Date.class; break;
+            case FLOAT_LIST: elementClass = (Class<E>) Float.class; break;
+            case DOUBLE_LIST: elementClass = (Class<E>) Double.class; break;
+            default:
+                throw new IllegalArgumentException("Unsupported type: " + primitiveType);
+        }
+        final ManagedListOperator<?> operator = getOperator(proxyState.getRealm$realm(), osList, primitiveType, elementClass);
+
+        if (list.isManaged() && osList.size() == list.size()) {
+            // There is a chance that the source list and the target list are the same list in the same object.
+            // In this case, we can't use removeAll().
+            final int size = list.size();
+            final Iterator<?> iterator = list.iterator();
+            for (int i = 0; i < size; i++) {
+                @Nullable
+                final Object value = iterator.next();
+                operator.set(i, value);
+            }
+        }  else {
+            osList.removeAll();
+            for (Object value : list) {
+                operator.append(value);
+            }
         }
     }
 
+    private <E> ManagedListOperator<E> getOperator(BaseRealm realm, OsList osList, RealmFieldType valueListType, Class<E> valueClass) {
+        if (valueListType == RealmFieldType.STRING_LIST) {
+            //noinspection unchecked
+            return (ManagedListOperator<E>) new StringListOperator(realm, osList, (Class<String>) valueClass);
+        }
+        if (valueListType == RealmFieldType.INTEGER_LIST) {
+            return new LongListOperator<>(realm, osList, valueClass);
+        }
+        if (valueListType == RealmFieldType.BOOLEAN_LIST) {
+            //noinspection unchecked
+            return (ManagedListOperator<E>) new BooleanListOperator(realm, osList, (Class<Boolean>) valueClass);
+        }
+        if (valueListType == RealmFieldType.BINARY_LIST) {
+            //noinspection unchecked
+            return (ManagedListOperator<E>) new BinaryListOperator(realm, osList, (Class<byte[]>) valueClass);
+        }
+        if (valueListType == RealmFieldType.DOUBLE_LIST) {
+            //noinspection unchecked
+            return (ManagedListOperator<E>) new DoubleListOperator(realm, osList, (Class<Double>) valueClass);
+        }
+        if (valueListType == RealmFieldType.FLOAT_LIST) {
+            //noinspection unchecked
+            return (ManagedListOperator<E>) new FloatListOperator(realm, osList, (Class<Float>) valueClass);
+        }
+        if (valueListType == RealmFieldType.DATE_LIST) {
+            //noinspection unchecked
+            return (ManagedListOperator<E>) new DateListOperator(realm, osList, (Class<Date>) valueClass);
+        }
+        throw new IllegalArgumentException("Unexpected list type: " + valueListType.name());
+    }
+
     /**
      * Sets the value to {@code null} for the given field.
      *
@@ -776,7 +948,7 @@ public void setNull(String fieldName) {
     public String getType() {
         proxyState.getRealm$realm().checkIfValid();
 
-        return RealmSchema.getSchemaForTable(proxyState.getRow$realm().getTable());
+        return proxyState.getRow$realm().getTable().getClassName();
     }
 
     /**
@@ -802,7 +974,8 @@ private void checkFieldType(String fieldName, long columnIndex, RealmFieldType e
             if (columnType == RealmFieldType.INTEGER || columnType == RealmFieldType.OBJECT) {
                 columnTypeIndefiniteVowel = "n";
             }
-            throw new IllegalArgumentException(String.format("'%s' is not a%s '%s', but a%s '%s'.",
+            throw new IllegalArgumentException(String.format(Locale.US,
+                    "'%s' is not a%s '%s', but a%s '%s'.",
                     fieldName, expectedIndefiniteVowel, expectedType, columnTypeIndefiniteVowel, columnType));
         }
     }
@@ -872,8 +1045,8 @@ public String toString() {
             return "Invalid object";
         }
 
-        final String className = Table.tableNameToClassName(proxyState.getRow$realm().getTable().getName());
-        StringBuilder sb = new StringBuilder(className + " = [");
+        final String className = proxyState.getRow$realm().getTable().getClassName();
+        StringBuilder sb = new StringBuilder(className + " = dynamic[");
         String[] fields = getFieldNames();
         for (String field : fields) {
             long columnIndex = proxyState.getRow$realm().getColumnIndex(field);
@@ -905,26 +1078,107 @@ public String toString() {
                 case OBJECT:
                     sb.append(proxyState.getRow$realm().isNullLink(columnIndex)
                             ? "null"
-                            : Table.tableNameToClassName(proxyState.getRow$realm().getTable().getLinkTarget(columnIndex).getName()));
+                            : proxyState.getRow$realm().getTable().getLinkTarget(columnIndex).getClassName());
                     break;
                 case LIST:
-                    final String tableName = proxyState.getRow$realm().getTable().getLinkTarget(columnIndex).getName();
-                    String targetType = Table.tableNameToClassName(tableName);
-                    sb.append(String.format("RealmList<%s>[%s]", targetType, proxyState.getRow$realm().getLinkList(columnIndex).size()));
+                    String targetClassName = proxyState.getRow$realm().getTable().getLinkTarget(columnIndex).getClassName();
+                    sb.append(String.format(Locale.US, "RealmList<%s>[%s]", targetClassName, proxyState.getRow$realm().getModelList(columnIndex).size()));
+                    break;
+                case INTEGER_LIST:
+                    sb.append(String.format(Locale.US, "RealmList<Long>[%s]", proxyState.getRow$realm().getValueList(columnIndex, type).size()));
+                    break;
+                case BOOLEAN_LIST:
+                    sb.append(String.format(Locale.US, "RealmList<Boolean>[%s]", proxyState.getRow$realm().getValueList(columnIndex, type).size()));
+                    break;
+                case STRING_LIST:
+                    sb.append(String.format(Locale.US, "RealmList<String>[%s]", proxyState.getRow$realm().getValueList(columnIndex, type).size()));
+                    break;
+                case BINARY_LIST:
+                    sb.append(String.format(Locale.US, "RealmList<byte[]>[%s]", proxyState.getRow$realm().getValueList(columnIndex, type).size()));
+                    break;
+                case DATE_LIST:
+                    sb.append(String.format(Locale.US, "RealmList<Date>[%s]", proxyState.getRow$realm().getValueList(columnIndex, type).size()));
+                    break;
+                case FLOAT_LIST:
+                    sb.append(String.format(Locale.US, "RealmList<Float>[%s]", proxyState.getRow$realm().getValueList(columnIndex, type).size()));
+                    break;
+                case DOUBLE_LIST:
+                    sb.append(String.format(Locale.US, "RealmList<Double>[%s]", proxyState.getRow$realm().getValueList(columnIndex, type).size()));
                     break;
-                case UNSUPPORTED_TABLE:
-                case UNSUPPORTED_MIXED:
                 default:
                     sb.append("?");
                     break;
             }
-            sb.append("}, ");
+            sb.append("},");
         }
-        sb.replace(sb.length() - 2, sb.length(), "");
+        sb.replace(sb.length() - 1, sb.length(), "");
         sb.append("]");
         return sb.toString();
     }
 
+    /**
+     * Returns {@link RealmResults} containing all {@code srcClassName} class objects that have a relationship
+     * to this object from {@code srcFieldName} field.
+     * <p>
+     * An entry is added for each reference, e.g. if the same reference is in a list multiple times,
+     * the src object will show up here multiple times.
+     *
+     * @param srcClassName name of the class returned objects belong to.
+     * @param srcFieldName name of the field in the source class that holds a reference to this object.
+     *                    Field type must be either {@code io.realm.RealmFieldType.OBJECT} or {@code io.realm.RealmFieldType.LIST}.
+     * @return the result.
+     * @throws IllegalArgumentException if the {@code srcClassName} is {@code null} or does not exist,
+     * the {@code srcFieldName} is {@code null} or does not exist,
+     * type of the source field is not supported.
+     */
+    public RealmResults<DynamicRealmObject> linkingObjects(String srcClassName, String srcFieldName) {
+        final DynamicRealm realm = (DynamicRealm) proxyState.getRealm$realm();
+        realm.checkIfValid();
+        proxyState.getRow$realm().checkIfAttached();
+
+        final RealmSchema schema = realm.getSchema();
+        final RealmObjectSchema realmObjectSchema = schema.get(srcClassName);
+        if (realmObjectSchema == null) {
+            throw new IllegalArgumentException("Class not found: " + srcClassName);
+        }
+
+        //noinspection ConstantConditions
+        if (srcFieldName == null) {
+            throw new IllegalArgumentException("Non-null 'srcFieldName' required.");
+        }
+        if (srcFieldName.contains(".")) {
+            throw new IllegalArgumentException(MSG_LINK_QUERY_NOT_SUPPORTED);
+        }
+
+        final RealmFieldType fieldType = realmObjectSchema.getFieldType(srcFieldName); // throws IAE if not found
+        if (fieldType != RealmFieldType.OBJECT && fieldType != RealmFieldType.LIST) {
+            throw new IllegalArgumentException(String.format(Locale.US,
+                    "Unexpected field type: %1$s. Field type should be either %2$s.%3$s or %2$s.%4$s.",
+                    fieldType.name(),
+                    RealmFieldType.class.getSimpleName(),
+                    RealmFieldType.OBJECT.name(), RealmFieldType.LIST.name()));
+        }
+
+        return RealmResults.createDynamicBacklinkResults(realm, (CheckedRow) proxyState.getRow$realm(), realmObjectSchema.getTable(), srcFieldName);
+    }
+
+    /**
+     * Returns {@link DynamicRealm} instance where this {@link DynamicRealmObject} belongs.
+     * <p>
+     * You <b>must not</b> call {@link DynamicRealm#close()} against returned instance.
+     *
+     * @return {@link DynamicRealm} instance where this object belongs.
+     * @throws IllegalStateException if this object was deleted or the corresponding {@link DynamicRealm} was already closed.
+     */
+    public DynamicRealm getDynamicRealm() {
+        final BaseRealm realm = realmGet$proxyState().getRealm$realm();
+        realm.checkIfValid();
+        if (!isValid()) {
+            throw new IllegalStateException(MSG_DELETED_OBJECT);
+        }
+        return (DynamicRealm) realm;
+    }
+
     @Override
     public void realm$injectObjectContext() {
         // nothing to do for DynamicRealmObject
@@ -939,7 +1193,7 @@ public String toString() {
     private void checkIsPrimaryKey(String fieldName) {
         RealmObjectSchema objectSchema = proxyState.getRealm$realm().getSchema().getSchemaForClass(getType());
         if (objectSchema.hasPrimaryKey() && objectSchema.getPrimaryKey().equals(fieldName)) {
-            throw new IllegalArgumentException(String.format(
+            throw new IllegalArgumentException(String.format(Locale.US,
                     "Primary key field '%s' cannot be changed after object was created.", fieldName));
         }
     }
diff --git a/realm/realm-library/src/main/java/io/realm/FieldAttribute.java b/realm/realm-library/src/main/java/io/realm/FieldAttribute.java
index 42000915dc..e3771ad4f8 100644
--- a/realm/realm-library/src/main/java/io/realm/FieldAttribute.java
+++ b/realm/realm-library/src/main/java/io/realm/FieldAttribute.java
@@ -30,7 +30,7 @@
     INDEXED,
 
     /**
-     * Marks a field as a primary key. This also implicitly mark it as {@link #INDEXED} and {@link #REQUIRED}.
+     * Marks a field as a primary key. This also implicitly mark it as {@link #INDEXED}.
      *
      * @see io.realm.annotations.PrimaryKey
      */
diff --git a/realm/realm-library/src/main/java/io/realm/ImmutableRealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/ImmutableRealmObjectSchema.java
new file mode 100644
index 0000000000..48c3e67d4e
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/ImmutableRealmObjectSchema.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import io.realm.internal.ColumnInfo;
+import io.realm.internal.Table;
+
+/**
+ * Immutable {@link RealmObjectSchema}.
+ */
+class ImmutableRealmObjectSchema extends RealmObjectSchema {
+
+    private static final String SCHEMA_IMMUTABLE_EXCEPTION_MSG = "This 'RealmObjectSchema' is immutable." +
+            " Please use 'DynamicRealm.getSchema() to get a mutable instance.";
+
+    ImmutableRealmObjectSchema(BaseRealm realm, RealmSchema schema, Table table, ColumnInfo columnInfo) {
+        super(realm, schema, table, columnInfo);
+    }
+
+    ImmutableRealmObjectSchema(BaseRealm realm, RealmSchema schema, Table table) {
+        super(realm, schema, table, new DynamicColumnIndices(table));
+    }
+
+    @Override
+    public RealmObjectSchema setClassName(String className) {
+        throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
+    }
+
+    @Override
+    public RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes) {
+        throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
+    }
+
+    @Override
+    public RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema) {
+        throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
+    }
+
+    @Override
+    public RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema) {
+        throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
+    }
+
+    @Override
+    public RealmObjectSchema addRealmListField(String fieldName, Class<?> primitiveType) {
+        throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
+    }
+
+    @Override
+    public RealmObjectSchema removeField(String fieldName) {
+        throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
+    }
+
+    @Override
+    public RealmObjectSchema renameField(String currentFieldName, String newFieldName) {
+        throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
+    }
+
+    @Override
+    public RealmObjectSchema addIndex(String fieldName) {
+        throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
+    }
+
+    @Override
+    public RealmObjectSchema removeIndex(String fieldName) {
+        throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
+    }
+
+    @Override
+    public RealmObjectSchema addPrimaryKey(String fieldName) {
+        throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
+    }
+
+    @Override
+    public RealmObjectSchema removePrimaryKey() {
+        throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
+    }
+
+    @Override
+    public RealmObjectSchema setRequired(String fieldName, boolean required) {
+        throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
+    }
+
+    @Override
+    public RealmObjectSchema setNullable(String fieldName, boolean nullable) {
+        throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
+    }
+
+    @Override
+    public RealmObjectSchema transform(Function function) {
+        throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/ImmutableRealmSchema.java b/realm/realm-library/src/main/java/io/realm/ImmutableRealmSchema.java
new file mode 100644
index 0000000000..b3d79f7da0
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/ImmutableRealmSchema.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import io.realm.internal.ColumnIndices;
+import io.realm.internal.Table;
+
+/**
+ * Immutable {@link RealmSchema}.
+ */
+class ImmutableRealmSchema extends RealmSchema {
+
+    private static final String SCHEMA_IMMUTABLE_EXCEPTION_MSG = "This 'RealmSchema' is immutable." +
+            " Please use 'DynamicRealm.getSchema() to get a mutable instance.";
+
+    ImmutableRealmSchema(BaseRealm realm, ColumnIndices columnIndices) {
+        super(realm, columnIndices);
+    }
+
+    @Override
+    public RealmObjectSchema get(String className) {
+        checkNotEmpty(className, EMPTY_STRING_MSG);
+
+        String internalClassName = Table.getTableNameForClass(className);
+        if (!realm.getSharedRealm().hasTable(internalClassName)) { return null; }
+        Table table = realm.getSharedRealm().getTable(internalClassName);
+        return new ImmutableRealmObjectSchema(realm, this, table, getColumnInfo(className));
+    }
+
+    @Override
+    public RealmObjectSchema create(String className) {
+        throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
+    }
+
+    @Override
+    public RealmObjectSchema createWithPrimaryKeyField(String className, String primaryKeyFieldName, Class<?> fieldType, FieldAttribute... attributes) {
+        throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
+    }
+
+    @Override
+    public void remove(String className) {
+        throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
+    }
+
+    @Override
+    public RealmObjectSchema rename(String oldClassName, String newClassName) {
+        throw new UnsupportedOperationException(SCHEMA_IMMUTABLE_EXCEPTION_MSG);
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/MutableRealmInteger.java b/realm/realm-library/src/main/java/io/realm/MutableRealmInteger.java
new file mode 100644
index 0000000000..c1ec454d80
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/MutableRealmInteger.java
@@ -0,0 +1,359 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm;
+
+import javax.annotation.Nullable;
+
+import io.realm.annotations.Beta;
+import io.realm.internal.ManagableObject;
+import io.realm.internal.Row;
+import io.realm.internal.Table;
+
+
+/**
+ * A {@code MutableRealmInteger} is a mutable, {@link Long}-like numeric quantity.
+ * It behaves almost exactly as a reference to a {@link Long}. More specifically:
+ * <ul>
+ * <li>A {@code MutableRealmInteger} may have the value {@code null}.</li>
+ * <li>The {@link #equals} operator compares the contained {@link Long} values. {@code null}-valued {@code MutableRealmInteger} are {@code .equals}</li>
+ * <li>The {@link #compareTo} operator compares the contained {@link Long} values.  It considers {@code null} &lt; any non-{@code null} value.</li>
+ * <li>The {@link #increment} and {@link #decrement} operators throw {@link IllegalStateException} when applied to a {@code null}-valued {@code MutableRealmInteger}.</li>
+ * </ul>
+ * <p>
+ *
+ * {@code MutableRealmInteger}s are most interesting as members of a managed {@link RealmModel} object.
+ * When managed, the {@link #increment} and {@link #decrement} operators implement a
+ * <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">conflict free replicated data type</a>:
+ * Simultaneous increments and decrements from multiple distributed clients will be aggregated correctly.
+ * For instance, if the value of {@code counter} field for the object representing user "Fred" is currently 0,
+ * then the following code, executed on two different devices, simultaneously, even if connected by only a slow,
+ * unreliable network, will <b>always</b> cause the value of {@code counter} to converge, eventually on the value 2.
+ * <pre>
+ * <code> MutableRealmInteger counter = realm.where(Users.class)
+ *     .equalTo("name", Fred)
+ *     .findFirst()
+ *     .counter.increment(1);</code>
+ * </pre>
+ * Note that the {@link #set(Long)} operator must be used with extreme care. It will quash the effects of any prior calls
+ * to {@link #increment(long)} or {@link #decrement(long)}. Although the value of a {@code MutableRealmInteger} will
+ * always converge across devices, the specific value on which it converges will depend on the actual order in which
+ * operations took place. Mixing {@link #set(Long)} with {@link #increment(long)} and {@link #decrement(long)} is,
+ * therefore, not advised, unless fuzzy counting is acceptable.
+ * <p>
+ *
+ * {@code MutableRealmInteger}s may not be primary keys. Their implementations are not thread safe.
+ * Like all managed Realm objects, managed {@code MutableRealmInteger}s may not be moved across threads.
+ * Unmanaged {@code MutableRealmInteger}s may be moved across threads but require safe publication.
+ * <p>
+ *
+ * A {@code MutableRealmInteger}, in a model class, must always be declared {@code final}. For instance:
+ * <pre>
+ * {@code public final MutableRealmInteger counter = MutableRealmInteger.ofNull(); }
+ * </pre>
+ * Although initializing the {@code MutableRealmInteger} as {@code null} may work very limited circumstances,
+ * developers are advised <b>not</b> to do it:
+ * <pre>
+ * {@code
+ *  public final MutableRealmInteger counter = null; // DO NOT DO THIS! }
+ * </pre>
+ * Also note that when a {@code MutableRealmInteger} is {@code @Required}, it is better, though not required,
+ * to initialize it with a non-null value.
+ * <pre>
+ * <code>
+ * {@literal @}Required
+ *  public final MutableRealmInteger counter = MutableRealmInteger.valueOf(0L);</code>
+ * </pre>
+ *
+ *<p>
+ * A reference to a managed {@code MutableRealmInteger} is subject to all of the constraints that apply
+ * to the model object from which it was obtained: It can only be mutated within a transaction and
+ * it becomes invalid if the Realm backing it is closed. Use the {@code isManaged()}
+ * and {@code isValid()} operators to determine whether a {@code MutableRealmInteger} is
+ * in a consistent state. Note, in particular, that a reference to a managed {@code MutableRealmInteger}
+ * retains a reference to the model object to which it belongs. For example in this code:
+ * <pre>
+ * {@code MutableRealmInteger counter = realm.where(Users.class).findFirst().counter; }
+ * </pre>
+ * the {@code counter} holds a reference to the {@code User} model object from which it was obtained.
+ * Neither can be GCed until all references to both are unreachable.
+ */
+@Beta
+public abstract class MutableRealmInteger implements Comparable<MutableRealmInteger>, ManagableObject {
+
+    /**
+     * Unmanaged Implementation.
+     */
+    private static final class Unmanaged extends MutableRealmInteger {
+        @Nullable
+        private Long value;
+
+        Unmanaged(@Nullable Long value) {
+            this.value = value;
+        }
+
+        @Override
+        public boolean isManaged() {
+            return false;
+        }
+
+        @Override
+        public boolean isValid() {
+            return true;
+        }
+
+        @Override
+        public void set(@Nullable Long newValue) {
+            value = newValue;
+        }
+
+        @Override
+        @Nullable
+        public Long get() {
+            return value;
+        }
+
+        @Override
+        public void increment(long inc) {
+            if (value == null) {
+                throw new IllegalStateException("Cannot increment a MutableRealmInteger whose value is null. Set its value first.");
+            }
+            //noinspection UnnecessaryBoxing
+            value = Long.valueOf(value + inc);
+        }
+
+        @Override
+        public void decrement(long dec) {
+            increment(-dec);
+        }
+    }
+
+
+    /**
+     * Managed Implementation.
+     * Proxies create new subclasses for each {@code MutableRealmInteger} field.
+     */
+    @SuppressWarnings("unused")
+    abstract static class Managed<T extends RealmModel> extends MutableRealmInteger {
+        protected abstract ProxyState<T> getProxyState();
+
+        protected abstract long getColumnIndex();
+
+        @Override
+        public final boolean isManaged() {
+            return true;
+        }
+
+        @Override
+        public final boolean isValid() {
+            return !getRealm().isClosed() && getRow().isAttached();
+        }
+
+        @Override
+        public final Long get() {
+            Row row = getRow();
+            row.checkIfAttached();
+            long columnIndex = getColumnIndex();
+            return (row.isNull(columnIndex)) ? null : row .getLong(columnIndex);
+        }
+
+        @Override
+        public final void set(@Nullable Long value) {
+            ProxyState proxyState = getProxyState();
+            proxyState.getRealm$realm().checkIfValidAndInTransaction();
+
+            if (!proxyState.isUnderConstruction()) {
+                setValue(value, false);
+                return;
+            }
+
+            if (!proxyState.getAcceptDefaultValue$realm()) {
+                return;
+            }
+
+            setValue(value, true);
+        }
+
+        @Override
+        public final void increment(long inc) {
+            getRealm().checkIfValidAndInTransaction();
+            Row row = getRow();
+            row.getTable().incrementLong(getColumnIndex(), row.getIndex(), inc);
+        }
+
+        @Override
+        public final void decrement(long dec) {
+            increment(-dec);
+        }
+
+        private BaseRealm getRealm() {
+            return getProxyState().getRealm$realm();
+       }
+
+        private Row getRow() {
+            return getProxyState().getRow$realm();
+        }
+
+        private void setValue(@Nullable Long value, boolean isDefault) {
+            Row row = getRow();
+            Table table = row.getTable();
+            long rowIndex = row.getIndex();
+            long columnIndex = getColumnIndex();
+            if (value == null) {
+                table.setNull(columnIndex, rowIndex, isDefault);
+            } else {
+                table.setLong(columnIndex, rowIndex, value, isDefault);
+            }
+        }
+    }
+
+    /**
+     * Creates a new, unmanaged {@code MutableRealmInteger} with the specified initial value.
+     *
+     * @param value initial value.
+     */
+    public static MutableRealmInteger valueOf(Long value) {
+        return new MutableRealmInteger.Unmanaged(value);
+    }
+
+    /**
+     * Creates a new, unmanaged {@code MutableRealmInteger} whose value is {@code null}.
+     */
+    public static MutableRealmInteger ofNull() {
+        return new MutableRealmInteger.Unmanaged(null);
+    }
+
+    /**
+     * Creates a new, unmanaged {@code MutableRealmInteger} with the specified initial value.
+     *
+     * @param value initial value.
+     */
+    public static MutableRealmInteger valueOf(long value) {
+        return valueOf(Long.valueOf(value));
+    }
+
+    /**
+     * Creates a new, unmanaged {@code MutableRealmInteger} with the specified initial value.
+     *
+     * @param value initial value: parsed by {@link Long#parseLong}.
+     */
+    public static MutableRealmInteger valueOf(String value) {
+        return valueOf(Long.parseLong(value));
+    }
+
+    /**
+     * Seal the class.
+     * In fact, this allows subclasses inside the package "realm.io".
+     * Because it eliminates the synthetic constructor, though, we can live with that.
+     * Don't make subclasses.
+     */
+    MutableRealmInteger() {}
+
+    /**
+     * Gets the {@code MutableRealmInteger} value.
+     * The value may be null.
+     *
+     * @return the value.
+     */
+    @Nullable
+    public abstract Long get();
+
+    /**
+     * Sets the {@code MutableRealmInteger} value.
+     * Calling {@code set} forcibly sets the {@code MutableRealmInteger} to the provided value.
+     * Doing this obliterates the effects of any calls to {@link #increment} and {@link #decrement} perceived
+     * before the call to {@code set}.
+     *
+     * @param newValue new value.
+     */
+    public abstract void set(@Nullable Long newValue);
+
+    /**
+     * Sets the {@code MutableRealmInteger} value.
+     * Calling {@link #set} forcibly sets the {@code MutableRealmInteger} to the provided value.
+     * Doing this obliterates the effects of any calls to {@link #increment} and {@link #decrement} perceived
+     * before the call to {@link #set}.
+     *
+     * @param newValue new value.
+     */
+    public final void set(long newValue) {
+        set(Long.valueOf(newValue));
+    }
+
+    /**
+     * Increments the {@code MutableRealmInteger}, adding the value of the argument.
+     * Increment/decrement from all devices are reflected in the new value, which is guaranteed to converge.
+     *
+     * @param inc quantity to be added to the {@code MutableRealmInteger}.
+     */
+    public abstract void increment(long inc);
+
+    /**
+     * Decrements the {@code MutableRealmInteger}, subtracting the value of the argument.
+     * Increment/decrement from all devices are reflected in the new value, which is guaranteed to converge.
+     *
+     * @param dec quantity to be subtracted from the {@code MutableRealmInteger}.
+     */
+    public abstract void decrement(long dec);
+
+    /**
+     * @return true if and only if {@link #get} will return {@code null}.
+     */
+    public final boolean isNull() {
+        return get() == null;
+    }
+
+    /**
+     * {@code MutableRealmInteger}s compare strictly by their values.
+     * Null is a legal value for a {@code MutableRealmInteger} and {@code null} &lt; any non-{@code null} value
+     *
+     * @param o the compare target
+     * @return -1, 0, or 1, depending on whether this object's value is &lt;, =, or &gt; the target's.
+     */
+    @Override
+    public final int compareTo(MutableRealmInteger o) {
+        Long thisValue = get();
+        Long otherValue = o.get();
+        return (thisValue == null)
+                ? ((otherValue == null) ? 0 : -1)
+                : ((otherValue == null) ? 1 : thisValue.compareTo (otherValue));
+    }
+
+    /**
+     * A {@code MutableRealmInteger}'s hash code is, exactly, the hash code of its value.
+     *
+     * @return true if the target has the same value.
+     */
+    @Override
+    public final int hashCode() {
+        Long thisValue = get();
+        return (thisValue == null) ? 0 : thisValue.hashCode();
+    }
+
+    /**
+     * Two {@code MutableRealmInteger}s are {@code .equals} if and only if their {@code longValues} are equal.
+     *
+     * @param o compare target
+     * @return true if the target has the same value.
+     */
+    @Override
+    public final boolean equals(Object o) {
+        if (o == this) { return true; }
+        if (!(o instanceof MutableRealmInteger)) { return false; }
+        Long thisValue = get();
+        Long otherValue = ((MutableRealmInteger) o).get();
+        return (thisValue == null) ? otherValue == null : thisValue.equals(otherValue);
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/MutableRealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/MutableRealmObjectSchema.java
new file mode 100644
index 0000000000..51e269bb93
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/MutableRealmObjectSchema.java
@@ -0,0 +1,348 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.Locale;
+
+import javax.annotation.Nonnull;
+
+import io.realm.internal.OsObjectStore;
+import io.realm.internal.Table;
+
+/**
+ * Mutable {@link RealmObjectSchema}.
+ */
+class MutableRealmObjectSchema extends RealmObjectSchema {
+
+    /**
+     * Creates a mutable schema object for a given Realm class.
+     *
+     * @param realm Realm holding the objects.
+     * @param table table representation of the Realm class
+     */
+    MutableRealmObjectSchema(BaseRealm realm, RealmSchema schema, Table table) {
+        super(realm, schema, table, new DynamicColumnIndices(table));
+    }
+
+    @Override
+    public RealmObjectSchema setClassName(String className) {
+        realm.checkNotInSync(); // renaming a table is not permitted
+        checkEmpty(className);
+        String internalTableName = Table.getTableNameForClass(className);
+        if (className.length() > Table.CLASS_NAME_MAX_LENGTH) {
+            throw new IllegalArgumentException(String.format(Locale.US,
+                    "Class name is too long. Limit is %1$d characters: \'%2$s\' (%3$d)",
+                    Table.CLASS_NAME_MAX_LENGTH, className, className.length()));
+        }
+        //noinspection ConstantConditions
+        if (realm.sharedRealm.hasTable(internalTableName)) {
+            throw new IllegalArgumentException("Class already exists: " + className);
+        }
+        // in case this table has a primary key, we need to transfer it after renaming the table.
+        //noinspection ConstantConditions
+        @Nonnull String oldTableName = table.getName();
+        @Nonnull String oldClassName = table.getClassName();
+        String pkField = OsObjectStore.getPrimaryKeyForObject(realm.sharedRealm, oldClassName);
+        if (pkField != null) {
+            OsObjectStore.setPrimaryKeyForObject(realm.sharedRealm, oldClassName, null);
+        }
+        realm.sharedRealm.renameTable(oldTableName, internalTableName);
+        if (pkField != null) {
+            try {
+                OsObjectStore.setPrimaryKeyForObject(realm.sharedRealm, className, pkField);
+            } catch (Exception e) {
+                // revert the table name back when something goes wrong
+                //noinspection ConstantConditions
+                realm.sharedRealm.renameTable(table.getName(), oldTableName);
+                throw e;
+            }
+        }
+        return this;
+    }
+
+    private void checkEmpty(String str) {
+        //noinspection ConstantConditions
+        if (str == null || str.isEmpty()) {
+            throw new IllegalArgumentException("Null or empty class names are not allowed");
+        }
+    }
+
+    @Override
+    public RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes) {
+        FieldMetaData metadata = SUPPORTED_SIMPLE_FIELDS.get(fieldType);
+        if (metadata == null) {
+            if (SUPPORTED_LINKED_FIELDS.containsKey(fieldType)) {
+                throw new IllegalArgumentException("Use addRealmObjectField() instead to add fields that link to other RealmObjects: " + fieldName);
+            } else {
+                throw new IllegalArgumentException(String.format(Locale.US,
+                        "Realm doesn't support this field type: %s(%s)",
+                        fieldName, fieldType));
+            }
+        }
+
+        if (containsAttribute(attributes, FieldAttribute.PRIMARY_KEY)) {
+            checkAddPrimaryKeyForSync();
+        }
+
+        checkNewFieldName(fieldName);
+        boolean nullable = metadata.defaultNullable;
+        if (containsAttribute(attributes, FieldAttribute.REQUIRED)) {
+            nullable = false;
+        }
+
+        long columnIndex = table.addColumn(metadata.fieldType, fieldName, nullable);
+        try {
+            addModifiers(fieldName, attributes);
+        } catch (Exception e) {
+            // Modifiers have been removed by the addModifiers method()
+            table.removeColumn(columnIndex);
+            throw e;
+        }
+        return this;
+    }
+
+    @Override
+    public RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema) {
+        checkLegalName(fieldName);
+        checkFieldNameIsAvailable(fieldName);
+        table.addColumnLink(RealmFieldType.OBJECT, fieldName, realm.sharedRealm.getTable(Table.getTableNameForClass(objectSchema.getClassName())));
+        return this;
+    }
+
+    @Override
+    public RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema) {
+        checkLegalName(fieldName);
+        checkFieldNameIsAvailable(fieldName);
+        table.addColumnLink(RealmFieldType.LIST, fieldName, realm.sharedRealm.getTable(Table.getTableNameForClass(objectSchema.getClassName())));
+        return this;
+    }
+
+    @Override
+    public RealmObjectSchema addRealmListField(String fieldName, Class<?> primitiveType) {
+        checkLegalName(fieldName);
+        checkFieldNameIsAvailable(fieldName);
+
+        FieldMetaData metadata = SUPPORTED_SIMPLE_FIELDS.get(primitiveType);
+        if (metadata == null) {
+            if (primitiveType.equals(RealmObjectSchema.class) || RealmModel.class.isAssignableFrom(primitiveType)) {
+                throw new IllegalArgumentException("Use 'addRealmListField(String name, RealmObjectSchema schema)' instead to add lists that link to other RealmObjects: " + fieldName);
+            } else {
+                throw new IllegalArgumentException(String.format(Locale.US,
+                        "RealmList does not support lists with this type: %s(%s)",
+                        fieldName, primitiveType));
+            }
+        }
+        table.addColumn(metadata.listType, fieldName, metadata.defaultNullable);
+        return this;
+    }
+
+    @Override
+    public RealmObjectSchema removeField(String fieldName) {
+        realm.checkNotInSync(); // destructive modification of a schema is not permitted
+        checkLegalName(fieldName);
+        if (!hasField(fieldName)) {
+            throw new IllegalStateException(fieldName + " does not exist.");
+        }
+        long columnIndex = getColumnIndex(fieldName);
+        String className = getClassName();
+        if (fieldName.equals(OsObjectStore.getPrimaryKeyForObject(realm.sharedRealm, className))) {
+            OsObjectStore.setPrimaryKeyForObject(realm.sharedRealm, className, fieldName);
+        }
+        table.removeColumn(columnIndex);
+        return this;
+    }
+
+    @Override
+    public RealmObjectSchema renameField(String currentFieldName, String newFieldName) {
+        realm.checkNotInSync(); // destructive modification of a schema is not permitted
+        checkLegalName(currentFieldName);
+        checkFieldExists(currentFieldName);
+        checkLegalName(newFieldName);
+        checkFieldNameIsAvailable(newFieldName);
+        long columnIndex = getColumnIndex(currentFieldName);
+        table.renameColumn(columnIndex, newFieldName);
+
+        // ATTENTION: We don't need to re-set the PK table here since the column index won't be changed when renaming.
+
+        return this;
+    }
+
+    @Override
+    public RealmObjectSchema addIndex(String fieldName) {
+        checkLegalName(fieldName);
+        checkFieldExists(fieldName);
+        long columnIndex = getColumnIndex(fieldName);
+        if (table.hasSearchIndex(columnIndex)) {
+            throw new IllegalStateException(fieldName + " already has an index.");
+        }
+        table.addSearchIndex(columnIndex);
+        return this;
+    }
+
+    @Override
+    public RealmObjectSchema removeIndex(String fieldName) {
+        realm.checkNotInSync(); // Destructive modifications are not permitted.
+        checkLegalName(fieldName);
+        checkFieldExists(fieldName);
+        long columnIndex = getColumnIndex(fieldName);
+        if (!table.hasSearchIndex(columnIndex)) {
+            throw new IllegalStateException("Field is not indexed: " + fieldName);
+        }
+        table.removeSearchIndex(columnIndex);
+        return this;
+    }
+
+    @Override
+    public RealmObjectSchema addPrimaryKey(String fieldName) {
+        checkAddPrimaryKeyForSync();
+        checkLegalName(fieldName);
+        checkFieldExists(fieldName);
+        String currentPKField = OsObjectStore.getPrimaryKeyForObject(realm.sharedRealm, getClassName());
+        if (currentPKField != null) {
+            throw new IllegalStateException(
+                    String.format(Locale.ENGLISH, "Field '%s' has been already defined as primary key.",
+                            currentPKField));
+        }
+        long columnIndex = getColumnIndex(fieldName);
+        if (!table.hasSearchIndex(columnIndex)) {
+            // No exception will be thrown since adding PrimaryKey implies the column has an index.
+            table.addSearchIndex(columnIndex);
+        }
+        OsObjectStore.setPrimaryKeyForObject(realm.sharedRealm, getClassName(), fieldName);
+        return this;
+    }
+
+    @Override
+    public RealmObjectSchema removePrimaryKey() {
+        realm.checkNotInSync(); // Destructive modifications are not permitted.
+        String pkField = OsObjectStore.getPrimaryKeyForObject(realm.sharedRealm, getClassName());
+        if (pkField == null) {
+            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
+        }
+        long columnIndex = table.getColumnIndex(pkField);
+        if (table.hasSearchIndex(columnIndex)) {
+            table.removeSearchIndex(columnIndex);
+        }
+        OsObjectStore.setPrimaryKeyForObject(realm.sharedRealm, getClassName(), null);
+        return this;
+    }
+
+    @Override
+    public RealmObjectSchema setRequired(String fieldName, boolean required) {
+        long columnIndex = table.getColumnIndex(fieldName);
+        boolean currentColumnRequired = isRequired(fieldName);
+        RealmFieldType type = table.getColumnType(columnIndex);
+
+        if (type == RealmFieldType.OBJECT) {
+            throw new IllegalArgumentException("Cannot modify the required state for RealmObject references: " + fieldName);
+        }
+        if (type == RealmFieldType.LIST) {
+            throw new IllegalArgumentException("Cannot modify the required state for RealmList references: " + fieldName);
+        }
+        if (required && currentColumnRequired) {
+            throw new IllegalStateException("Field is already required: " + fieldName);
+        }
+        if (!required && !currentColumnRequired) {
+            throw new IllegalStateException("Field is already nullable: " + fieldName);
+        }
+
+        if (required) {
+            table.convertColumnToNotNullable(columnIndex);
+        } else {
+            table.convertColumnToNullable(columnIndex);
+        }
+        return this;
+    }
+
+    @Override
+    public RealmObjectSchema setNullable(String fieldName, boolean nullable) {
+        setRequired(fieldName, !nullable);
+        return this;
+    }
+
+    @Override
+    public RealmObjectSchema transform(Function function) {
+        //noinspection ConstantConditions
+        if (function != null) {
+            long size = table.size();
+            for (long i = 0; i < size; i++) {
+                function.apply(new DynamicRealmObject(realm, table.getCheckedRow(i)));
+            }
+        }
+
+        return this;
+    }
+
+    // Invariant: Field was just added. This method is responsible for cleaning up attributes if it fails.
+    private void addModifiers(String fieldName, FieldAttribute[] attributes) {
+        boolean indexAdded = false;
+        try {
+            //noinspection ConstantConditions
+            if (attributes != null && attributes.length > 0) {
+                if (containsAttribute(attributes, FieldAttribute.INDEXED)) {
+                    addIndex(fieldName);
+                    indexAdded = true;
+                }
+
+                if (containsAttribute(attributes, FieldAttribute.PRIMARY_KEY)) {
+                    // Note : adding primary key implies application of FieldAttribute.INDEXED attribute.
+                    addPrimaryKey(fieldName);
+                    indexAdded = true;
+                }
+
+                // REQUIRED is being handled when adding the column using addField through the nullable parameter.
+            }
+        } catch (Exception e) {
+            // If something went wrong, revert all attributes.
+            long columnIndex = getColumnIndex(fieldName);
+            if (indexAdded) {
+                table.removeSearchIndex(columnIndex);
+            }
+            throw (RuntimeException) e;
+        }
+    }
+
+    static boolean containsAttribute(FieldAttribute[] attributeList, FieldAttribute attribute) {
+        //noinspection ConstantConditions
+        if (attributeList == null || attributeList.length == 0) {
+            return false;
+        }
+        for (FieldAttribute anAttributeList : attributeList) {
+            if (anAttributeList == attribute) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private void checkNewFieldName(String fieldName) {
+        checkLegalName(fieldName);
+        checkFieldNameIsAvailable(fieldName);
+    }
+
+    private void checkFieldNameIsAvailable(String fieldName) {
+        if (table.getColumnIndex(fieldName) != Table.NO_MATCH) {
+            throw new IllegalArgumentException("Field already exists in '" + getClassName() + "': " + fieldName);
+        }
+    }
+
+    private void checkAddPrimaryKeyForSync() {
+        if (realm.configuration.isSyncConfiguration()) {
+            throw new UnsupportedOperationException("'addPrimaryKey' is not supported by synced Realms.");
+        }
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/MutableRealmSchema.java b/realm/realm-library/src/main/java/io/realm/MutableRealmSchema.java
new file mode 100644
index 0000000000..10f060b24e
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/MutableRealmSchema.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.Locale;
+
+import io.realm.internal.OsObjectStore;
+import io.realm.internal.Table;
+
+/**
+ * Mutable {@link RealmSchema}.
+ */
+class MutableRealmSchema extends RealmSchema {
+
+    MutableRealmSchema(BaseRealm realm) {
+        super(realm, null);
+    }
+
+    @Override
+    public RealmObjectSchema get(String className) {
+        checkNotEmpty(className, EMPTY_STRING_MSG);
+
+        String internalClassName = Table.getTableNameForClass(className);
+        if (!realm.getSharedRealm().hasTable(internalClassName)) { return null; }
+        Table table = realm.getSharedRealm().getTable(internalClassName);
+        return new MutableRealmObjectSchema(realm, this, table);
+    }
+
+    @Override
+    public RealmObjectSchema create(String className) {
+        // Adding a class is always permitted.
+        checkNotEmpty(className, EMPTY_STRING_MSG);
+
+        String internalTableName = Table.getTableNameForClass(className);
+        if (className.length() > Table.CLASS_NAME_MAX_LENGTH) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.US,
+                            "Class name is too long. Limit is %1$d characters: %2$s",
+                            Table.CLASS_NAME_MAX_LENGTH,
+                            className.length()));
+        }
+        return new MutableRealmObjectSchema(realm, this, realm.getSharedRealm().createTable(internalTableName));
+    }
+
+    @Override
+    public RealmObjectSchema createWithPrimaryKeyField(String className, String primaryKeyFieldName, Class<?> fieldType,
+                                                       FieldAttribute... attributes) {
+        checkNotEmpty(className, EMPTY_STRING_MSG);
+        RealmObjectSchema.checkLegalName(primaryKeyFieldName);
+        String internalTableName = checkAndGetTableNameFromClassName(className);
+
+        RealmObjectSchema.FieldMetaData metadata = RealmObjectSchema.getSupportedSimpleFields().get(fieldType);
+        if (metadata == null || (metadata.fieldType != RealmFieldType.STRING &&
+                metadata.fieldType != RealmFieldType.INTEGER)) {
+            throw new IllegalArgumentException(String.format("Realm doesn't support primary key field type '%s'.",
+                    fieldType));
+        }
+        boolean isStringField = (metadata.fieldType == RealmFieldType.STRING);
+
+        boolean nullable = metadata.defaultNullable;
+        if (MutableRealmObjectSchema.containsAttribute(attributes, FieldAttribute.REQUIRED)) {
+            nullable = false;
+        }
+
+        return new MutableRealmObjectSchema(realm, this,
+                realm.getSharedRealm().createTableWithPrimaryKey(internalTableName, primaryKeyFieldName,
+                        isStringField, nullable));
+    }
+
+    @Override
+    public void remove(String className) {
+        realm.checkNotInSync(); // Destructive modifications are not permitted.
+        checkNotEmpty(className, EMPTY_STRING_MSG);
+        String internalTableName = Table.getTableNameForClass(className);
+        if (!OsObjectStore.deleteTableForObject(realm.getSharedRealm(), className)) {
+            throw new IllegalArgumentException("Cannot remove class because it is not in this Realm: " + className);
+        }
+        removeFromClassNameToSchemaMap(internalTableName);
+    }
+
+    @Override
+    public RealmObjectSchema rename(String oldClassName, String newClassName) {
+        realm.checkNotInSync(); // Destructive modifications are not permitted.
+        checkNotEmpty(oldClassName, "Class names cannot be empty or null");
+        checkNotEmpty(newClassName, "Class names cannot be empty or null");
+        String oldInternalName = Table.getTableNameForClass(oldClassName);
+        String newInternalName = Table.getTableNameForClass(newClassName);
+        checkHasTable(oldClassName, "Cannot rename class because it doesn't exist in this Realm: " + oldClassName);
+        if (realm.getSharedRealm().hasTable(newInternalName)) {
+            throw new IllegalArgumentException(oldClassName + " cannot be renamed because the new class already exists: " + newClassName);
+        }
+
+        // Checks if there is a primary key defined for the old class.
+        String pkField = OsObjectStore.getPrimaryKeyForObject(realm.sharedRealm, oldClassName);
+        if (pkField != null) {
+            OsObjectStore.setPrimaryKeyForObject(realm.sharedRealm, oldClassName, null);
+        }
+
+        realm.getSharedRealm().renameTable(oldInternalName, newInternalName);
+        Table table = realm.getSharedRealm().getTable(newInternalName);
+
+        // Sets the primary key for the new class if necessary.
+        if (pkField != null) {
+            OsObjectStore.setPrimaryKeyForObject(realm.sharedRealm, newClassName, pkField);
+        }
+
+        RealmObjectSchema objectSchema = removeFromClassNameToSchemaMap(oldInternalName);
+        if (objectSchema == null || !objectSchema.getTable().isValid() || !objectSchema.getClassName().equals(newClassName)) {
+            objectSchema = new MutableRealmObjectSchema(realm, this, table);
+        }
+        putToClassNameToSchemaMap(newInternalName, objectSchema);
+
+        return objectSchema;
+    }
+
+    private String checkAndGetTableNameFromClassName(String className) {
+        if (className.length() > Table.CLASS_NAME_MAX_LENGTH) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.US,
+                            "Class name is too long. Limit is %1$d characters: %2$s",
+                            Table.CLASS_NAME_MAX_LENGTH,
+                            className.length()));
+        }
+        return Table.getTableNameForClass(className);
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
index 896eb28665..0024658bd9 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
@@ -18,6 +18,8 @@
 
 import java.util.List;
 
+import javax.annotation.Nullable;
+
 
 /**
  * An {@code OrderedRealmCollection} is a collection which maintains an ordering for its elements. Every
@@ -98,7 +100,7 @@
  * As you can see, after deletion, the size and elements order of snapshot stay the same as before. But the element at
  * the position becomes invalid.
  */
-public interface OrderedRealmCollection<E extends RealmModel> extends List<E>, RealmCollection<E> {
+public interface OrderedRealmCollection<E> extends List<E>, RealmCollection<E> {
 
     /**
      * Gets the first object from the collection.
@@ -106,6 +108,7 @@
      * @return the first object.
      * @throws IndexOutOfBoundsException if the collection is empty.
      */
+    @Nullable
     E first();
 
     /**
@@ -113,7 +116,8 @@
      *
      * @return the first object or the provided default.
      */
-    E first(E defaultValue);
+    @Nullable
+    E first(@Nullable E defaultValue);
 
     /**
      * Gets the last object from the collection.
@@ -121,6 +125,7 @@
      * @return the last object.
      * @throws IndexOutOfBoundsException if the collection is empty.
      */
+    @Nullable
     E last();
 
     /**
@@ -128,7 +133,8 @@
      *
      * @return the last object or the provided default.
      */
-    E last(E defaultValue);
+    @Nullable
+    E last(@Nullable E defaultValue);
 
     /**
      * Sorts a collection based on the provided field in ascending order.
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionChangeListener.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionChangeListener.java
index 8c51f2a570..24216e776d 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionChangeListener.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionChangeListener.java
@@ -16,6 +16,8 @@
 
 package io.realm;
 
+import javax.annotation.Nullable;
+
 /**
  * {@link OrderedRealmCollectionChangeListener} can be registered with a {@link RealmResults} to receive a notification
  * with a {@link OrderedCollectionChangeSet} to describe the details of what have been changed in the collection from
@@ -32,9 +34,9 @@
     /**
      * This will be called when the async query is finished the first time or the collection of objects has changed.
      *
-     * @param collection the collection this listener is registered to.
+     * @param t the collection this listener is registered to.
      * @param changeSet object with information about which rows in the collection were added, removed or modified.
      * {@code null} is returned the first time an async query is completed.
      */
-    void onChange(T collection, OrderedCollectionChangeSet changeSet);
+    void onChange(T t, @Nullable OrderedCollectionChangeSet changeSet);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java
index e7852490d1..da24bf45d9 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java
@@ -5,8 +5,12 @@
 import java.util.Date;
 import java.util.Iterator;
 import java.util.ListIterator;
+import java.util.Locale;
 
-import io.realm.internal.Collection;
+import javax.annotation.Nullable;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import io.realm.internal.OsResults;
 import io.realm.internal.InvalidRow;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.SortDescriptor;
@@ -17,35 +21,41 @@
 /**
  * General implementation for {@link OrderedRealmCollection} which is based on the {@code Collection}.
  */
-abstract class OrderedRealmCollectionImpl<E extends RealmModel>
+abstract class OrderedRealmCollectionImpl<E>
         extends AbstractList<E> implements OrderedRealmCollection<E> {
     private final static String NOT_SUPPORTED_MESSAGE = "This method is not supported by 'RealmResults' or" +
             " 'OrderedRealmCollectionSnapshot'.";
 
     final BaseRealm realm;
-    Class<E> classSpec;   // Return type
-    String className;     // Class name used by DynamicRealmObjects
+    @Nullable final Class<E> classSpec;   // Return type
+    @Nullable final String className;     // Class name used by DynamicRealmObjects
+    // FIXME implement this
+    @SuppressFBWarnings("SS_SHOULD_BE_STATIC")
+    final boolean forValues = false;
 
-    final Collection collection;
+    final OsResults osResults;
 
-    OrderedRealmCollectionImpl(BaseRealm realm, Collection collection, Class<E> clazz) {
-        this.realm = realm;
-        this.classSpec = clazz;
-        this.collection = collection;
+    OrderedRealmCollectionImpl(BaseRealm realm, OsResults osResults, Class<E> clazz) {
+        this(realm, osResults, clazz, null);
+    }
+
+    OrderedRealmCollectionImpl(BaseRealm realm, OsResults osResults, String className) {
+        this(realm, osResults, null, className);
     }
 
-    OrderedRealmCollectionImpl(BaseRealm realm, Collection collection, String className) {
+    private OrderedRealmCollectionImpl(BaseRealm realm, OsResults osResults, @Nullable Class<E> clazz, @Nullable String className) {
         this.realm = realm;
+        this.osResults = osResults;
+        this.classSpec = clazz;
         this.className = className;
-        this.collection = collection;
     }
 
     Table getTable() {
-        return collection.getTable();
+        return osResults.getTable();
     }
 
-    Collection getCollection() {
-        return collection;
+    OsResults getOsResults() {
+        return osResults;
     }
 
     /**
@@ -53,7 +63,7 @@ Collection getCollection() {
      */
     @Override
     public boolean isValid() {
-        return collection.isValid();
+        return osResults.isValid();
     }
 
     /**
@@ -75,7 +85,7 @@ public boolean isManaged() {
      * {@code false} otherwise.
      */
     @Override
-    public boolean contains(Object object) {
+    public boolean contains(@Nullable Object object) {
         if (isLoaded()) {
             // Deleted objects can never be part of a RealmResults
             if (object instanceof RealmObjectProxy) {
@@ -102,15 +112,23 @@ public boolean contains(Object object) {
      * @throws IndexOutOfBoundsException if {@code location < 0 || location >= size()}.
      */
     @Override
+    @Nullable
     public E get(int location) {
         realm.checkIfValid();
-        return realm.get(classSpec, className, collection.getUncheckedRow(location));
+        if (forValues) {
+            // TODO implement this
+            return null;
+        }
+
+        //noinspection unchecked
+        return (E) realm.get((Class<? extends RealmModel>) classSpec, className, osResults.getUncheckedRow(location));
     }
 
     /**
      * {@inheritDoc}
      */
     @Override
+    @Nullable
     public E first() {
         return firstImpl(true, null);
     }
@@ -119,15 +137,23 @@ public E first() {
      * {@inheritDoc}
      */
     @Override
-    public E first(E defaultValue) {
+    @Nullable
+    public E first(@Nullable E defaultValue) {
         return firstImpl(false, defaultValue);
     }
 
-    private E firstImpl(boolean shouldThrow, E defaultValue) {
-        UncheckedRow row = collection.firstUncheckedRow();
+    @Nullable
+    private E firstImpl(boolean shouldThrow, @Nullable E defaultValue) {
+        UncheckedRow row = osResults.firstUncheckedRow();
+
+        if (forValues) {
+            // TODO implement this
+            return null;
+        }
 
         if (row != null) {
-            return realm.get(classSpec, className, row);
+            //noinspection unchecked
+            return (E) realm.get((Class<? extends RealmModel>) classSpec, className, row);
         } else {
             if (shouldThrow) {
                 throw new IndexOutOfBoundsException("No results were found.");
@@ -141,6 +167,7 @@ private E firstImpl(boolean shouldThrow, E defaultValue) {
      * {@inheritDoc}
      */
     @Override
+    @Nullable
     public E last() {
         return lastImpl(true, null);
     }
@@ -149,16 +176,24 @@ public E last() {
      * {@inheritDoc}
      */
     @Override
-    public E last(E defaultValue) {
+    @Nullable
+    public E last(@Nullable E defaultValue) {
         return lastImpl(false, defaultValue);
 
     }
 
-    private E lastImpl(boolean shouldThrow, E defaultValue) {
-        UncheckedRow row = collection.lastUncheckedRow();
+    @Nullable
+    private E lastImpl(boolean shouldThrow, @Nullable E defaultValue) {
+        UncheckedRow row = osResults.lastUncheckedRow();
+
+        if (forValues) {
+            // TODO implement this
+            return null;
+        }
 
         if (row != null) {
-            return realm.get(classSpec, className, row);
+            //noinspection unchecked
+            return (E) realm.get((Class<? extends RealmModel>) classSpec, className, row);
         } else {
             if (shouldThrow) {
                 throw new IndexOutOfBoundsException("No results were found.");
@@ -175,7 +210,7 @@ private E lastImpl(boolean shouldThrow, E defaultValue) {
     public void deleteFromRealm(int location) {
         // TODO: Implement the delete in OS level and do check there!
         realm.checkIfValidAndInTransaction();
-        collection.delete(location);
+        osResults.delete(location);
     }
 
     /**
@@ -185,7 +220,7 @@ public void deleteFromRealm(int location) {
     public boolean deleteAllFromRealm() {
         realm.checkIfValid();
         if (size() > 0) {
-            collection.clear();
+            osResults.clear();
             return true;
         }
         return false;
@@ -235,15 +270,16 @@ public boolean deleteAllFromRealm() {
 
     // aux. method used by sort methods
     private long getColumnIndexForSort(String fieldName) {
+        //noinspection ConstantConditions
         if (fieldName == null || fieldName.isEmpty()) {
             throw new IllegalArgumentException("Non-empty field name required.");
         }
         if (fieldName.contains(".")) {
             throw new IllegalArgumentException("Aggregates on child object fields are not supported: " + fieldName);
         }
-        long columnIndex = collection.getTable().getColumnIndex(fieldName);
+        long columnIndex = osResults.getTable().getColumnIndex(fieldName);
         if (columnIndex < 0) {
-            throw new IllegalArgumentException(String.format("Field '%s' does not exist.", fieldName));
+            throw new IllegalArgumentException(String.format(Locale.US, "Field '%s' does not exist.", fieldName));
         }
         return columnIndex;
     }
@@ -254,10 +290,10 @@ private long getColumnIndexForSort(String fieldName) {
     @Override
     public RealmResults<E> sort(String fieldName) {
         SortDescriptor sortDescriptor =
-                SortDescriptor.getInstanceForSort(collection.getTable(), fieldName, Sort.ASCENDING);
+                SortDescriptor.getInstanceForSort(getSchemaConnector(), osResults.getTable(), fieldName, Sort.ASCENDING);
 
-        Collection sortedCollection = collection.sort(sortDescriptor);
-        return createLoadedResults(sortedCollection);
+        OsResults sortedOsResults = osResults.sort(sortDescriptor);
+        return createLoadedResults(sortedOsResults);
     }
 
     /**
@@ -266,10 +302,10 @@ private long getColumnIndexForSort(String fieldName) {
     @Override
     public RealmResults<E> sort(String fieldName, Sort sortOrder) {
         SortDescriptor sortDescriptor =
-                SortDescriptor.getInstanceForSort(collection.getTable(), fieldName, sortOrder);
+                SortDescriptor.getInstanceForSort(getSchemaConnector(), osResults.getTable(), fieldName, sortOrder);
 
-        Collection sortedCollection = collection.sort(sortDescriptor);
-        return createLoadedResults(sortedCollection);
+        OsResults sortedOsResults = osResults.sort(sortDescriptor);
+        return createLoadedResults(sortedOsResults);
     }
 
     /**
@@ -278,10 +314,10 @@ private long getColumnIndexForSort(String fieldName) {
     @Override
     public RealmResults<E> sort(String fieldNames[], Sort sortOrders[]) {
         SortDescriptor sortDescriptor =
-                SortDescriptor.getInstanceForSort(collection.getTable(), fieldNames, sortOrders);
+                SortDescriptor.getInstanceForSort(getSchemaConnector(), osResults.getTable(), fieldNames, sortOrders);
 
-        Collection sortedCollection = collection.sort(sortDescriptor);
-        return createLoadedResults(sortedCollection);
+        OsResults sortedOsResults = osResults.sort(sortDescriptor);
+        return createLoadedResults(sortedOsResults);
     }
 
     /**
@@ -302,7 +338,7 @@ private long getColumnIndexForSort(String fieldName) {
     @Override
     public int size() {
         if (isLoaded()) {
-            long size = collection.size();
+            long size = osResults.size();
             return (size > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) size;
         }
         return 0;
@@ -315,7 +351,7 @@ public int size() {
     public Number min(String fieldName) {
         realm.checkIfValid();
         long columnIndex = getColumnIndexForSort(fieldName);
-        return collection.aggregateNumber(io.realm.internal.Collection.Aggregate.MINIMUM, columnIndex);
+        return osResults.aggregateNumber(OsResults.Aggregate.MINIMUM, columnIndex);
     }
 
     /**
@@ -325,7 +361,7 @@ public Number min(String fieldName) {
     public Date minDate(String fieldName) {
         realm.checkIfValid();
         long columnIndex = getColumnIndexForSort(fieldName);
-        return collection.aggregateDate(Collection.Aggregate.MINIMUM, columnIndex);
+        return osResults.aggregateDate(OsResults.Aggregate.MINIMUM, columnIndex);
     }
 
     /**
@@ -335,7 +371,7 @@ public Date minDate(String fieldName) {
     public Number max(String fieldName) {
         realm.checkIfValid();
         long columnIndex = getColumnIndexForSort(fieldName);
-        return collection.aggregateNumber(Collection.Aggregate.MAXIMUM, columnIndex);
+        return osResults.aggregateNumber(OsResults.Aggregate.MAXIMUM, columnIndex);
     }
 
     /**
@@ -349,10 +385,11 @@ public Number max(String fieldName) {
      * @throws IllegalArgumentException if fieldName is not a Date field.
      */
     @Override
+    @Nullable
     public Date maxDate(String fieldName) {
         realm.checkIfValid();
         long columnIndex = getColumnIndexForSort(fieldName);
-        return collection.aggregateDate(Collection.Aggregate.MAXIMUM, columnIndex);
+        return osResults.aggregateDate(OsResults.Aggregate.MAXIMUM, columnIndex);
     }
 
 
@@ -363,7 +400,7 @@ public Date maxDate(String fieldName) {
     public Number sum(String fieldName) {
         realm.checkIfValid();
         long columnIndex = getColumnIndexForSort(fieldName);
-        return collection.aggregateNumber(Collection.Aggregate.SUM, columnIndex);
+        return osResults.aggregateNumber(OsResults.Aggregate.SUM, columnIndex);
     }
 
     /**
@@ -374,7 +411,7 @@ public double average(String fieldName) {
         realm.checkIfValid();
         long columnIndex = getColumnIndexForSort(fieldName);
 
-        Number avg = collection.aggregateNumber(Collection.Aggregate.AVERAGE, columnIndex);
+        Number avg = osResults.aggregateNumber(OsResults.Aggregate.AVERAGE, columnIndex);
         return avg.doubleValue();
     }
 
@@ -444,7 +481,7 @@ public boolean retainAll(@SuppressWarnings("NullableProblems") java.util.Collect
     public boolean deleteLastFromRealm() {
         // TODO: Implement the deleteLast in OS level and do check there!
         realm.checkIfValidAndInTransaction();
-        return collection.deleteLast();
+        return osResults.deleteLast();
     }
 
     /**
@@ -456,7 +493,7 @@ public boolean deleteLastFromRealm() {
     public boolean deleteFirstFromRealm() {
         // TODO: Implement the deleteLast in OS level and do check there!
         realm.checkIfValidAndInTransaction();
-        return collection.deleteFirst();
+        return osResults.deleteFirst();
     }
 
     /**
@@ -516,46 +553,64 @@ public boolean addAll(@SuppressWarnings("NullableProblems") java.util.Collection
     }
 
     // Custom RealmResults iterator. It ensures that we only iterate on a Realm that hasn't changed.
-    private class RealmCollectionIterator extends Collection.Iterator<E> {
+    private class RealmCollectionIterator extends OsResults.Iterator<E> {
         RealmCollectionIterator() {
-            super(OrderedRealmCollectionImpl.this.collection);
+            super(OrderedRealmCollectionImpl.this.osResults);
         }
 
         @Override
         protected E convertRowToObject(UncheckedRow row) {
-            return realm.get(classSpec, className, row);
+            if (forValues) {
+                // TODO implement this
+                return null;
+            }
+            //noinspection unchecked
+            return (E) realm.get((Class<? extends RealmObject>) classSpec, className, row);
         }
     }
 
     @Override
     public OrderedRealmCollectionSnapshot<E> createSnapshot() {
         if (className != null) {
-            return new OrderedRealmCollectionSnapshot<E>(realm, collection, className);
+            return new OrderedRealmCollectionSnapshot<E>(realm, osResults, className);
         } else {
-            return new OrderedRealmCollectionSnapshot<E>(realm, collection, classSpec);
+            // 'classSpec' is non-null when 'className' is null.
+            //noinspection ConstantConditions
+            return new OrderedRealmCollectionSnapshot<E>(realm, osResults, classSpec);
         }
     }
 
     // Custom RealmResults list iterator.
-    private class RealmCollectionListIterator extends Collection.ListIterator<E> {
+    private class RealmCollectionListIterator extends OsResults.ListIterator<E> {
         RealmCollectionListIterator(int start) {
-            super(OrderedRealmCollectionImpl.this.collection, start);
+            super(OrderedRealmCollectionImpl.this.osResults, start);
         }
 
         @Override
         protected E convertRowToObject(UncheckedRow row) {
-            return realm.get(classSpec, className, row);
+            if (forValues) {
+                // TODO implement this
+                return null;
+            }
+            //noinspection unchecked
+            return (E) realm.get((Class<? extends RealmObject>) classSpec, className, row);
         }
     }
 
-    RealmResults<E> createLoadedResults(Collection newCollection) {
+    RealmResults<E> createLoadedResults(OsResults newOsResults) {
         RealmResults<E> results;
         if (className != null) {
-            results = new RealmResults<E>(realm, newCollection, className);
+            results = new RealmResults<E>(realm, newOsResults, className);
         } else {
-            results = new RealmResults<E>(realm, newCollection, classSpec);
+            // 'classSpec' is non-null when 'className' is null.
+            //noinspection ConstantConditions
+            results = new RealmResults<E>(realm, newOsResults, classSpec);
         }
         results.load();
         return results;
     }
+
+    private SchemaConnector getSchemaConnector() {
+        return new SchemaConnector(realm.getSchema());
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionSnapshot.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionSnapshot.java
index 49124234d0..6b2d9fd30a 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionSnapshot.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionSnapshot.java
@@ -16,7 +16,9 @@
 
 package io.realm;
 
-import io.realm.internal.Collection;
+import java.util.Locale;
+
+import io.realm.internal.OsResults;
 import io.realm.internal.UncheckedRow;
 
 
@@ -46,16 +48,16 @@
  * }
  * </pre>
  */
-public class OrderedRealmCollectionSnapshot<E extends RealmModel> extends OrderedRealmCollectionImpl<E> {
+public class OrderedRealmCollectionSnapshot<E> extends OrderedRealmCollectionImpl<E> {
 
     private int size = -1;
 
-    OrderedRealmCollectionSnapshot(BaseRealm realm, Collection collection, Class<E> clazz) {
-        super(realm, collection.createSnapshot(), clazz);
+    OrderedRealmCollectionSnapshot(BaseRealm realm, OsResults osResults, Class<E> clazz) {
+        super(realm, osResults.createSnapshot(), clazz);
     }
 
-    OrderedRealmCollectionSnapshot(BaseRealm realm, Collection collection, String className) {
-        super(realm, collection.createSnapshot(), className);
+    OrderedRealmCollectionSnapshot(BaseRealm realm, OsResults osResults, String className) {
+        super(realm, osResults.createSnapshot(), className);
     }
 
     /**
@@ -128,7 +130,7 @@ public int size() {
 
     private UnsupportedOperationException getUnsupportedException(String methodName) {
         return new UnsupportedOperationException(
-                String.format("'%s()' is not supported by OrderedRealmCollectionSnapshot. " +
+                String.format(Locale.US, "'%s()' is not supported by OrderedRealmCollectionSnapshot. " +
                         "Call '%s()' on the original 'RealmCollection' instead.", methodName, methodName));
     }
 
@@ -169,9 +171,9 @@ public boolean load() {
     @Override
     public void deleteFromRealm(int location) {
         realm.checkIfValidAndInTransaction();
-        UncheckedRow row = collection.getUncheckedRow(location);
+        UncheckedRow row = osResults.getUncheckedRow(location);
         if (row.isAttached()) {
-            collection.delete(location);
+            osResults.delete(location);
         }
     }
 
@@ -184,8 +186,8 @@ public void deleteFromRealm(int location) {
     @Override
     public boolean deleteFirstFromRealm() {
         realm.checkIfValidAndInTransaction();
-        UncheckedRow row = collection.firstUncheckedRow();
-        return row != null && row.isAttached() && collection.deleteFirst();
+        UncheckedRow row = osResults.firstUncheckedRow();
+        return row != null && row.isAttached() && osResults.deleteFirst();
     }
 
     /**
@@ -197,8 +199,8 @@ public boolean deleteFirstFromRealm() {
     @Override
     public boolean deleteLastFromRealm() {
         realm.checkIfValidAndInTransaction();
-        UncheckedRow row = collection.lastUncheckedRow();
-        return row != null && row.isAttached() && collection.deleteLast();
+        UncheckedRow row = osResults.lastUncheckedRow();
+        return row != null && row.isAttached() && osResults.deleteLast();
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/OsRealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/OsRealmObjectSchema.java
deleted file mode 100644
index 6078699ec8..0000000000
--- a/realm/realm-library/src/main/java/io/realm/OsRealmObjectSchema.java
+++ /dev/null
@@ -1,213 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm;
-
-import java.util.LinkedHashSet;
-import java.util.Set;
-
-import io.realm.internal.Table;
-
-
-class OsRealmObjectSchema extends RealmObjectSchema {
-    private long nativePtr;
-
-    /**
-     * Creates a schema object using object store. This constructor is intended to be used by
-     * the validation of schema, object schemas and properties through the object store. Even though the constructor
-     * is public, there is never a purpose which justifies calling it!
-     *
-     * @param className name of the class
-     */
-    OsRealmObjectSchema(String className) {
-        this.nativePtr = nativeCreateRealmObjectSchema(className);
-    }
-
-    OsRealmObjectSchema(long nativePtr) {
-        this.nativePtr = nativePtr;
-    }
-
-    @Override
-    public void close() {
-        if (nativePtr != 0L) {
-            nativeClose(nativePtr);
-            nativePtr = 0L;
-        }
-    }
-
-    @Override
-    public String getClassName() {
-        return nativeGetClassName(nativePtr);
-    }
-
-    @Override
-    public OsRealmObjectSchema setClassName(String className) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema removeField(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema renameField(String currentFieldName, String newFieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean hasField(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema addIndex(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean hasIndex(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema removeIndex(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema addPrimaryKey(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema removePrimaryKey() {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema setRequired(String fieldName, boolean required) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema setNullable(String fieldName, boolean nullable) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean isRequired(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean isNullable(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean isPrimaryKey(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean hasPrimaryKey() {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public String getPrimaryKey() {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public Set<String> getFieldNames() {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public OsRealmObjectSchema transform(Function function) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public RealmFieldType getFieldType(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    long[] getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    OsRealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
-        final Property property = new Property(name, type, primary, indexed, required);
-        try {
-            nativeAddProperty(nativePtr, property.getNativePtr());
-        } finally {
-            property.close();
-        }
-        return this;
-    }
-
-    @Override
-    OsRealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
-        final Property property = new Property(name, type, linkedTo);
-        try {
-            nativeAddProperty(nativePtr, property.getNativePtr());
-        } finally {
-            property.close();
-        }
-        return this;
-    }
-
-    long getNativePtr() {
-        return nativePtr;
-    }
-
-    @Override
-    Table getTable() {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    long getAndCheckFieldIndex(String fieldName) {
-        throw new UnsupportedOperationException();
-    }
-
-    static native long nativeCreateRealmObjectSchema(String className);
-
-    static native void nativeAddProperty(long nativePtr, long nativePropertyPtr);
-
-    static native void nativeClose(long nativePtr);
-
-    static native String nativeGetClassName(long nativePtr);
-}
diff --git a/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java b/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java
deleted file mode 100644
index 7d96117d9d..0000000000
--- a/realm/realm-library/src/main/java/io/realm/OsRealmSchema.java
+++ /dev/null
@@ -1,216 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import java.util.HashMap;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-
-import io.realm.internal.Table;
-
-
-/**
- * Class for interacting with the Realm schema using a dynamic API. This makes it possible
- * to add, delete and change the classes in the Realm.
- * <p>
- * All changes must happen inside a write transaction for the particular Realm.
- *
- * @see RealmMigration
- */
-class OsRealmSchema extends RealmSchema {
-    static final class Creator extends RealmSchema {
-        private final Map<String, RealmObjectSchema> schema = new HashMap<>();
-
-        @Override
-        public void close() {
-            for (Map.Entry<String, RealmObjectSchema> entry : schema.entrySet()) {
-                entry.getValue().close();
-            }
-            schema.clear();
-        }
-
-        @Override
-        public RealmObjectSchema get(String className) {
-            checkEmpty(className);
-            return (!contains(className)) ? null : schema.get(className);
-        }
-
-        @Override
-        public Set<RealmObjectSchema> getAll() {
-            return new LinkedHashSet<>(schema.values());
-        }
-
-        @Override
-        public RealmObjectSchema create(String className) {
-            checkEmpty(className);
-            OsRealmObjectSchema realmObjectSchema = new OsRealmObjectSchema(className);
-            schema.put(className, realmObjectSchema);
-            return realmObjectSchema;
-        }
-
-        @Override
-        public boolean contains(String className) {
-            return schema.containsKey(className);
-        }
-
-        @Override
-        Table getTable(Class<? extends RealmModel> clazz) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        Table getTable(String className) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        OsRealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        OsRealmObjectSchema getSchemaForClass(String className) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public void remove(String className) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public RealmObjectSchema rename(String oldClassName, String newClassName) {
-            throw new UnsupportedOperationException();
-        }
-    }
-
-    private final Map<String, RealmObjectSchema> dynamicClassToSchema = new HashMap<>();
-
-    private long nativePtr;
-
-    OsRealmSchema(Creator creator) {
-        Set<RealmObjectSchema> realmObjectSchemas = creator.getAll();
-        long[] schemaNativePointers = new long[realmObjectSchemas.size()];
-        int i = 0;
-        for (RealmObjectSchema schema : realmObjectSchemas) {
-            schemaNativePointers[i++] = ((OsRealmObjectSchema) schema).getNativePtr();
-        }
-        this.nativePtr = nativeCreateFromList(schemaNativePointers);
-    }
-
-    public long getNativePtr() {
-        return this.nativePtr;
-    }
-
-    // See BaseRealm uses a StandardRealmSchema, not a OsRealmSchema.
-    @Override
-    public void close() {
-        if (nativePtr != 0L) {
-            nativeClose(nativePtr);
-            nativePtr = 0L;
-        }
-    }
-
-    /**
-     * Returns the Realm schema for a given class.
-     *
-     * @param className name of the class
-     * @return schema object for that class or {@code null} if the class doesn't exists.
-     */
-    @Override
-    public RealmObjectSchema get(String className) {
-        checkEmpty(className);
-        return (!contains(className)) ? null : dynamicClassToSchema.get(className);
-    }
-
-    /**
-     * Returns the {@link RealmObjectSchema} for all RealmObject classes that can be saved in this Realm.
-     *
-     * @return the set of all classes in this Realm or no RealmObject classes can be saved in the Realm.
-     */
-    @Override
-    public Set<RealmObjectSchema> getAll() {
-        throw new UnsupportedOperationException();
-    }
-
-    /**
-     * Adds a new class to the Realm.
-     *
-     * @param className name of the class.
-     * @return a Realm schema object for that class.
-     */
-    @Override
-    public RealmObjectSchema create(String className) {
-        // Adding a class is always permitted.
-        checkEmpty(className);
-        OsRealmObjectSchema realmObjectSchema = new OsRealmObjectSchema(className);
-        dynamicClassToSchema.put(className, realmObjectSchema);
-        return realmObjectSchema;
-    }
-
-    @Override
-    public void remove(String className) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public RealmObjectSchema rename(String oldClassName, String newClassName) {
-        throw new UnsupportedOperationException();
-    }
-
-    /**
-     * Checks if a given class already exists in the schema.
-     *
-     * @param className class name to check.
-     * @return {@code true} if the class already exists. {@code false} otherwise.
-     */
-    @Override
-    public boolean contains(String className) {
-        return dynamicClassToSchema.containsKey(className);
-    }
-
-    @Override
-    Table getTable(Class<? extends RealmModel> clazz) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    Table getTable(String className) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    OsRealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    OsRealmObjectSchema getSchemaForClass(String className) {
-        throw new UnsupportedOperationException();
-    }
-
-    static void checkEmpty(String str) {
-        if (str == null || str.isEmpty()) {
-            throw new IllegalArgumentException("Null or empty class names are not allowed");
-        }
-    }
-
-    static native long nativeCreateFromList(long[] objectSchemaPtrs);
-
-    static native void nativeClose(long nativePtr);
-}
diff --git a/realm/realm-library/src/main/java/io/realm/Property.java b/realm/realm-library/src/main/java/io/realm/Property.java
deleted file mode 100644
index 4285be3db5..0000000000
--- a/realm/realm-library/src/main/java/io/realm/Property.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-
-/**
- * Class for handling properties/fields.
- */
-
-class Property {
-    public static final boolean PRIMARY_KEY = true;
-    public static final boolean REQUIRED = true;
-    public static final boolean INDEXED = true;
-
-    private long nativePtr;
-
-    Property(String name, RealmFieldType type, boolean isPrimary, boolean isIndexed, boolean isRequired) {
-        this.nativePtr = nativeCreateProperty(name, type.getNativeValue(), isPrimary, isIndexed, !isRequired);
-    }
-
-    Property(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
-        this.nativePtr = nativeCreateProperty(name, type.getNativeValue(), linkedTo.getClassName());
-    }
-
-    protected Property(long nativePtr) {
-        this.nativePtr = nativePtr;
-    }
-
-    protected long getNativePtr() {
-        return nativePtr;
-    }
-
-    public void close() {
-        if (nativePtr != 0) {
-            nativeClose(nativePtr);
-            nativePtr = 0L;
-        }
-    }
-
-    private static native long nativeCreateProperty(String name, int type, boolean isPrimary, boolean isIndexed, boolean isNullable);
-
-    private static native long nativeCreateProperty(String name, int type, String linkedToName);
-
-    private static native void nativeClose(long nativePtr);
-}
diff --git a/realm/realm-library/src/main/java/io/realm/ProxyState.java b/realm/realm-library/src/main/java/io/realm/ProxyState.java
index 58ef76c7ec..7ebdce93e2 100644
--- a/realm/realm-library/src/main/java/io/realm/ProxyState.java
+++ b/realm/realm-library/src/main/java/io/realm/ProxyState.java
@@ -18,8 +18,11 @@
 
 import java.util.List;
 
+import javax.annotation.Nullable;
+
 import io.realm.internal.ObserverPairList;
 import io.realm.internal.PendingRow;
+import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.OsObject;
 import io.realm.internal.UncheckedRow;
@@ -35,6 +38,7 @@
         private final RealmChangeListener<T> listener;
 
         RealmChangeListenerWrapper(RealmChangeListener<T> listener) {
+            //noinspection ConstantConditions
             if (listener == null) {
                 throw new IllegalArgumentException("Listener should not be null");
             }
@@ -42,7 +46,7 @@
         }
 
         @Override
-        public void onChange(T object, ObjectChangeSet changes) {
+        public void onChange(T object, @Nullable ObjectChangeSet changes) {
             listener.onChange(object);
         }
 
@@ -112,6 +116,7 @@ public ProxyState(E model) {
         this.acceptDefaultValue = acceptDefaultValue;
     }
 
+    @SuppressWarnings("unused")
     public List<String> getExcludeFields$realm() {
         return excludeFields;
     }
@@ -196,4 +201,19 @@ public void onQueryFinished(Row row) {
             registerToObjectNotifier();
         }
     }
+
+    /**
+     * Check that object is a valid and managed object by this Realm.
+     * Used by proxy classes to verify input.
+     *
+     * @param value model object
+     */
+    public void checkValidObject(RealmModel value) {
+        if (!RealmObject.isValid(value) || !RealmObject.isManaged(value)) {
+            throw new IllegalArgumentException("'value' is not a valid managed object.");
+        }
+        if (((RealmObjectProxy) value).realmGet$proxyState().getRealm$realm() != getRealm$realm()) {
+            throw new IllegalArgumentException("'value' belongs to a different Realm.");
+        }
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index efcf14c5ba..666c8a225e 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -40,18 +40,27 @@
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Scanner;
 import java.util.Set;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import javax.annotation.Nullable;
+
+import io.reactivex.Flowable;
+import io.realm.annotations.Beta;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmMigrationNeededException;
 import io.realm.internal.ColumnIndices;
-import io.realm.internal.ColumnInfo;
 import io.realm.internal.ObjectServerFacade;
+import io.realm.internal.OsObject;
+import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.OsObjectStore;
+import io.realm.internal.OsResults;
+import io.realm.internal.OsSchemaInfo;
 import io.realm.internal.RealmCore;
 import io.realm.internal.RealmNotifier;
 import io.realm.internal.RealmObjectProxy;
@@ -60,8 +69,6 @@
 import io.realm.internal.Table;
 import io.realm.internal.async.RealmAsyncTaskImpl;
 import io.realm.log.RealmLog;
-import rx.Observable;
-
 
 /**
  * The Realm class is the storage and transactional manager of your object persistent store. It is in charge of creating
@@ -128,28 +135,75 @@
  */
 public class Realm extends BaseRealm {
 
+    private static final String NULL_CONFIG_MSG = "A non-null RealmConfiguration must be provided";
+
     public static final String DEFAULT_REALM_NAME = RealmConfiguration.DEFAULT_REALM_NAME;
 
+    private static final Object defaultConfigurationLock = new Object();
+    // guarded by `defaultConfigurationLock`
     private static RealmConfiguration defaultConfiguration;
+    private final RealmSchema schema;
 
     /**
      * The constructor is private to enforce the use of the static one.
      *
-     * @param configuration the {@link RealmConfiguration} used to open the Realm.
+     * @param cache the {@link RealmCache} associated to this Realm instance.
      * @throws IllegalArgumentException if trying to open an encrypted Realm with the wrong key.
      */
-    Realm(RealmConfiguration configuration) {
-        super(configuration);
+    private Realm(RealmCache cache) {
+        super(cache, createExpectedSchemaInfo(cache.getConfiguration().getSchemaMediator()));
+        schema = new ImmutableRealmSchema(this,
+                new ColumnIndices(configuration.getSchemaMediator(), sharedRealm.getSchemaInfo()));
+        // FIXME: This is to work around the different behaviour between the read only Realms in the Object Store and
+        // in current java implementation. Opening a read only Realm with some missing schemas is allowed by Object
+        // Store and realm-cocoa. In that case, any query based on the missing schema should just return an empty
+        // results. Fix this together with https://github.com/realm/realm-java/issues/2953
+        if (configuration.isReadOnly()) {
+            RealmProxyMediator mediator = configuration.getSchemaMediator();
+            Set<Class<? extends RealmModel>> classes = mediator.getModelClasses();
+            for (Class<? extends RealmModel> clazz  : classes) {
+                String tableName = Table.getTableNameForClass(mediator.getSimpleClassName(clazz));
+                if (!sharedRealm.hasTable(tableName)) {
+                    sharedRealm.close();
+                    throw new RealmMigrationNeededException(configuration.getPath(),
+                            String.format(Locale.US, "Cannot open the read only Realm. '%s' is missing.",
+                                    Table.getClassNameForTable(tableName)));
+                }
+            }
+        }
+    }
+
+    private Realm(SharedRealm sharedRealm) {
+        super(sharedRealm);
+        schema = new ImmutableRealmSchema(this,
+                new ColumnIndices(configuration.getSchemaMediator(), sharedRealm.getSchemaInfo()));
+    }
+
+    private static OsSchemaInfo createExpectedSchemaInfo(RealmProxyMediator mediator) {
+        return new OsSchemaInfo(mediator.getExpectedObjectSchemaInfoMap().values());
     }
 
     /**
      * {@inheritDoc}
      */
     @Override
-    public Observable<Realm> asObservable() {
+    public Flowable<Realm> asFlowable() {
         return configuration.getRxFactory().from(this);
     }
 
+    /**
+     * Returns the schema for this Realm. The schema is immutable.
+     * Any attempt to modify it will result in an {@link UnsupportedOperationException}.
+     * <p>
+     * The schema can only be modified using {@link DynamicRealm#getSchema()} or through an migration.
+     *
+     * @return The {@link RealmSchema} for this Realm.
+     */
+    @Override
+    public RealmSchema getSchema() {
+        return schema;
+    }
+
     /**
      * Initializes the Realm library and creates a default configuration that is ready to use. It is required to call
      * this method before interacting with any other of the Realm API's.
@@ -186,14 +240,19 @@
      */
     public static synchronized void init(Context context) {
         if (BaseRealm.applicationContext == null) {
+            //noinspection ConstantConditions
             if (context == null) {
                 throw new IllegalArgumentException("Non-null context required.");
             }
             checkFilesDirAvailable(context);
             RealmCore.loadLibrary(context);
-            defaultConfiguration = new RealmConfiguration.Builder(context).build();
+            setDefaultConfiguration(new RealmConfiguration.Builder(context).build());
             ObjectServerFacade.getSyncFacadeIfPossible().init(context);
-            BaseRealm.applicationContext = context.getApplicationContext();
+            if (context.getApplicationContext() != null) {
+                BaseRealm.applicationContext = context.getApplicationContext();
+            } else {
+                BaseRealm.applicationContext = context;
+            }
             SharedRealm.initialize(new File(context.getFilesDir(), ".realm.temp"));
         }
     }
@@ -259,12 +318,19 @@ private static void checkFilesDirAvailable(Context context) {
      * @throws RealmMigrationNeededException if no migration has been provided by the default configuration and the
      * RealmObject classes or version has has changed so a migration is required.
      * @throws RealmFileException if an error happened when accessing the underlying Realm file.
+     * @throws io.realm.exceptions.DownloadingRealmInterruptedException if {@link SyncConfiguration.Builder#waitForInitialRemoteData()}
+     * was set and the thread opening the Realm was interrupted while the download was in progress.
      */
     public static Realm getDefaultInstance() {
-        if (defaultConfiguration == null) {
-            throw new IllegalStateException("Call `Realm.init(Context)` before calling this method.");
+        RealmConfiguration configuration = getDefaultConfiguration();
+        if (configuration == null) {
+            if (BaseRealm.applicationContext == null) {
+                throw new IllegalStateException("Call `Realm.init(Context)` before calling this method.");
+            } else {
+                throw new IllegalStateException("Set default configuration by using `Realm.setDefaultConfiguration(RealmConfiguration)`.");
+            }
         }
-        return RealmCache.createRealmOrGetFromCache(defaultConfiguration, Realm.class);
+        return RealmCache.createRealmOrGetFromCache(configuration, Realm.class);
     }
 
     /**
@@ -276,15 +342,40 @@ public static Realm getDefaultInstance() {
      * classes or version has has changed so a migration is required.
      * @throws RealmFileException if an error happened when accessing the underlying Realm file.
      * @throws IllegalArgumentException if a null {@link RealmConfiguration} is provided.
+     * @throws io.realm.exceptions.DownloadingRealmInterruptedException if {@link SyncConfiguration.Builder#waitForInitialRemoteData()}
+     * was set and the thread opening the Realm was interrupted while the download was in progress.
      * @see RealmConfiguration for details on how to configure a Realm.
      */
     public static Realm getInstance(RealmConfiguration configuration) {
+        //noinspection ConstantConditions
         if (configuration == null) {
-            throw new IllegalArgumentException("A non-null RealmConfiguration must be provided");
+            throw new IllegalArgumentException(NULL_CONFIG_MSG);
         }
         return RealmCache.createRealmOrGetFromCache(configuration, Realm.class);
     }
 
+    /**
+     * The creation of the first Realm instance per {@link RealmConfiguration} in a process can take some time as all
+     * initialization code need to run at that point (setting up the Realm, validating schemas and creating initial
+     * data). This method places the initialization work in a background thread and deliver the Realm instance
+     * to the caller thread asynchronously after the initialization is finished.
+     *
+     * @param configuration {@link RealmConfiguration} used to open the Realm.
+     * @param callback invoked to return the results.
+     * @throws IllegalArgumentException if a null {@link RealmConfiguration} or a null {@link Callback} is provided.
+     * @throws IllegalStateException if it is called from a non-Looper or {@link IntentService} thread.
+     * @return a {@link RealmAsyncTask} representing a cancellable task.
+     * @see Callback for more details.
+     */
+    public static RealmAsyncTask getInstanceAsync(RealmConfiguration configuration,
+                                                  Callback callback) {
+        //noinspection ConstantConditions
+        if (configuration == null) {
+            throw new IllegalArgumentException(NULL_CONFIG_MSG);
+        }
+        return RealmCache.createRealmOrGetFromCacheAsync(configuration, callback, Realm.class);
+    }
+
     /**
      * Sets the {@link io.realm.RealmConfiguration} used when calling {@link #getDefaultInstance()}.
      *
@@ -293,10 +384,25 @@ public static Realm getInstance(RealmConfiguration configuration) {
      * @see RealmConfiguration for details on how to configure a Realm.
      */
     public static void setDefaultConfiguration(RealmConfiguration configuration) {
+        //noinspection ConstantConditions
         if (configuration == null) {
             throw new IllegalArgumentException("A non-null RealmConfiguration must be provided");
         }
-        defaultConfiguration = configuration;
+        synchronized (defaultConfigurationLock) {
+            defaultConfiguration = configuration;
+        }
+    }
+
+    /**
+     * Returns the default configuration for {@link #getDefaultInstance()}.
+     *
+     * @return default configuration object or {@code null} if no default configuration is specified.
+     */
+    @Nullable
+    public static RealmConfiguration getDefaultConfiguration() {
+        synchronized (defaultConfigurationLock) {
+            return defaultConfiguration;
+        }
     }
 
     /**
@@ -304,215 +410,27 @@ public static void setDefaultConfiguration(RealmConfiguration configuration) {
      * fail until a new default configuration has been set using {@link #setDefaultConfiguration(RealmConfiguration)}.
      */
     public static void removeDefaultConfiguration() {
-        defaultConfiguration = null;
+        synchronized (defaultConfigurationLock) {
+            defaultConfiguration = null;
+        }
     }
 
     /**
      * Creates a {@link Realm} instance without checking the existence in the {@link RealmCache}.
      *
-     * @param configuration {@link RealmConfiguration} used to create the Realm.
-     * @param globalCacheArray if this is not {@code null} and contains an entry for current schema version,
-     * the {@link BaseRealm#schema#columnIndices} will be initialized with the copy of
-     * the entry. Otherwise, {@link BaseRealm#schema#columnIndices} will be populated
-     * from the Realm file.
+     * @param cache the {@link RealmCache} where to create the realm in.
      * @return a {@link Realm} instance.
      */
-    static Realm createInstance(RealmConfiguration configuration, ColumnIndices[] globalCacheArray) {
-        try {
-            return createAndValidate(configuration, globalCacheArray);
-
-        } catch (RealmMigrationNeededException e) {
-            if (configuration.shouldDeleteRealmIfMigrationNeeded()) {
-                deleteRealm(configuration);
-            } else {
-                try {
-                    if (configuration.getMigration() != null) {
-                        migrateRealm(configuration, e);
-                    }
-                } catch (FileNotFoundException fileNotFoundException) {
-                    // Should never happen.
-                    throw new RealmFileException(RealmFileException.Kind.NOT_FOUND, fileNotFoundException);
-                }
-            }
-
-            return createAndValidate(configuration, globalCacheArray);
-        }
-    }
-
-    private static Realm createAndValidate(RealmConfiguration configuration, ColumnIndices[] globalCacheArray) {
-        Realm realm = new Realm(configuration);
-
-        final long currentVersion = realm.getVersion();
-        final long requiredVersion = configuration.getSchemaVersion();
-
-        final ColumnIndices columnIndices = RealmCache.findColumnIndices(globalCacheArray, requiredVersion);
-
-        if (columnIndices != null) {
-            // Copies global cache as a Realm local indices cache.
-            realm.schema.setInitialColumnIndices(columnIndices);
-        } else {
-            final boolean syncingConfig = configuration.isSyncConfiguration();
-
-            if (!syncingConfig && (currentVersion != UNVERSIONED)) {
-                if (currentVersion < requiredVersion) {
-                    realm.doClose();
-                    throw new RealmMigrationNeededException(
-                            configuration.getPath(),
-                            String.format("Realm on disk need to migrate from v%s to v%s", currentVersion, requiredVersion));
-                }
-                if (requiredVersion < currentVersion) {
-                    realm.doClose();
-                    throw new IllegalArgumentException(
-                            String.format("Realm on disk is newer than the one specified: v%s vs. v%s", currentVersion, requiredVersion));
-                }
-            }
-
-            // Initializes Realm schema if needed.
-            try {
-                if (!syncingConfig) {
-                    initializeRealm(realm);
-                } else {
-                    initializeSyncedRealm(realm);
-                }
-            } catch (RuntimeException e) {
-                realm.doClose();
-                throw e;
-            }
-        }
-
-        return realm;
-    }
-
-    private static void initializeRealm(Realm realm) {
-        // Everything in this method needs to be behind a transaction lock to prevent multi-process interaction while
-        // the Realm is initialized.
-        boolean commitChanges = false;
-        try {
-            realm.beginTransaction();
-            long currentVersion = realm.getVersion();
-            boolean unversioned = currentVersion == UNVERSIONED;
-            commitChanges = unversioned;
-
-            RealmConfiguration configuration = realm.getConfiguration();
-
-            if (unversioned) {
-                realm.setVersion(configuration.getSchemaVersion());
-            }
-
-            final RealmProxyMediator mediator = configuration.getSchemaMediator();
-            final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
-
-            if (unversioned) {
-                // Create all of the tables.
-                for (Class<? extends RealmModel> modelClass : modelClasses) {
-                    mediator.createRealmObjectSchema(modelClass, realm.getSchema());
-                }
-            }
-
-            final Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap = new HashMap<>(modelClasses.size());
-            for (Class<? extends RealmModel> modelClass : modelClasses) {
-                // Now that they have all been created, validate them.
-                columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
-            }
-
-            realm.getSchema().setInitialColumnIndices(
-                    (unversioned) ? configuration.getSchemaVersion() : currentVersion,
-                    columnInfoMap);
-
-            if (unversioned) {
-                final Transaction transaction = configuration.getInitialDataTransaction();
-                if (transaction != null) {
-                    transaction.execute(realm);
-                }
-            }
-        } catch (Exception e) {
-            commitChanges = false;
-            throw e;
-        } finally {
-            if (commitChanges) {
-                realm.commitTransaction();
-            } else {
-                realm.cancelTransaction();
-            }
-        }
+    static Realm createInstance(RealmCache cache) {
+        return new Realm(cache);
     }
 
-    // Everything in this method needs to be behind a transaction lock
-    // to prevent multi-process interaction while the Realm is initialized.
-    private static void initializeSyncedRealm(Realm realm) {
-        boolean commitChanges = false;
-        OsRealmSchema schema = null;
-        OsRealmSchema.Creator schemaCreator = null;
-        try {
-            realm.beginTransaction();
-            long currentVersion = realm.getVersion();
-            final boolean unversioned = currentVersion == UNVERSIONED;
-
-            RealmConfiguration configuration = realm.getConfiguration();
-
-            final RealmProxyMediator mediator = configuration.getSchemaMediator();
-            final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
-
-            schemaCreator = new OsRealmSchema.Creator();
-            for (Class<? extends RealmModel> modelClass : modelClasses) {
-                mediator.createRealmObjectSchema(modelClass, schemaCreator);
-            }
-
-            // Assumption: When SyncConfiguration then additive schema update mode.
-            schema = new OsRealmSchema(schemaCreator);
-            schemaCreator.close();
-            schemaCreator = null;
-
-            long newVersion = configuration.getSchemaVersion();
-            // !!! FIXME: This appalling kludge is necessitated by current package structure/visiblity constraints.
-            // It absolutely breaks encapsulation and needs to be fixed!
-            long schemaNativePointer = schema.getNativePtr();
-            if (realm.sharedRealm.requiresMigration(schemaNativePointer)) {
-                if (currentVersion >= newVersion) {
-                    throw new IllegalArgumentException(String.format(
-                            "The schema was changed but the schema version was not updated. " +
-                                    "The configured schema version (%d) must be greater than the version " +
-                                    " in the Realm file (%d) in order to update the schema.",
-                            newVersion, currentVersion));
-                }
-                realm.sharedRealm.updateSchema(schemaNativePointer, newVersion);
-                // The OS currently does not handle setting the schema version. We have to do it manually.
-                realm.setVersion(newVersion);
-                commitChanges = true;
-            }
-
-            final Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap = new HashMap<>(modelClasses.size());
-            for (Class<? extends RealmModel> modelClass : modelClasses) {
-                columnInfoMap.put(modelClass, mediator.validateTable(modelClass, realm.sharedRealm, false));
-            }
-
-            realm.getSchema().setInitialColumnIndices(
-                    (unversioned) ? newVersion : currentVersion,
-                    columnInfoMap);
-
-            if (unversioned) {
-                final Transaction transaction = configuration.getInitialDataTransaction();
-                if (transaction != null) {
-                    transaction.execute(realm);
-                }
-            }
-        } catch (RuntimeException e) {
-            commitChanges = false;
-            throw e;
-        } finally {
-            if (schemaCreator != null) {
-                schemaCreator.close();
-            }
-
-            if (schema != null) {
-                schema.close();
-            }
-            if (commitChanges) {
-                realm.commitTransaction();
-            } else {
-                realm.cancelTransaction();
-            }
-        }
+    /**
+     * Creates a {@code Realm} instance directly from a {@link SharedRealm}. This {@code Realm} doesn't need to be
+     * closed.
+     */
+    static Realm createInstance(SharedRealm sharedRealm) {
+        return new Realm(sharedRealm);
     }
 
     /**
@@ -521,6 +439,9 @@ private static void initializeSyncedRealm(Realm realm) {
      * JSON properties with unknown properties will be ignored. If a {@link RealmObject} field is not present in the
      * JSON object the {@link RealmObject} field will be set to the default value for that type.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of Realm objects to create.
      * @param json an array where each JSONObject must map to the specified class.
      * @throws RealmException if mapping from JSON fails.
@@ -528,6 +449,7 @@ private static void initializeSyncedRealm(Realm realm) {
      * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      */
     public <E extends RealmModel> void createAllFromJson(Class<E> clazz, JSONArray json) {
+        //noinspection ConstantConditions
         if (clazz == null || json == null) {
             return;
         }
@@ -549,6 +471,9 @@ private static void initializeSyncedRealm(Realm realm) {
      * a new {@link RealmObject} is created and a field is not found in the JSON object, that field will be assigned the
      * default value for the field type.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param json array with object data.
      * @throws IllegalArgumentException if trying to update a class without a {@link io.realm.annotations.PrimaryKey}.
@@ -562,6 +487,7 @@ private static void initializeSyncedRealm(Realm realm) {
     }
 
     public <E extends RealmModel> List<E> createOrUpdateAllFromJsonAndReturn(Class<E> clazz, JSONArray json) {
+        //noinspection ConstantConditions
         if (clazz == null || json == null) {
             return null;
         }
@@ -584,6 +510,9 @@ private static void initializeSyncedRealm(Realm realm) {
      * JSON properties with unknown properties will be ignored. If a {@link RealmObject} field is not present in the
      * JSON object the {@link RealmObject} field will be set to the default value for that type.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of Realm objects to create.
      * @param json the JSON array as a String where each object can map to the specified class.
      * @throws RealmException if mapping from JSON fails.
@@ -591,6 +520,7 @@ private static void initializeSyncedRealm(Realm realm) {
      * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      */
     public <E extends RealmModel> void createAllFromJson(Class<E> clazz, String json) {
+        //noinspection ConstantConditions
         if (clazz == null || json == null || json.length() == 0) {
             return;
         }
@@ -612,6 +542,9 @@ private static void initializeSyncedRealm(Realm realm) {
      * If a new {@link RealmObject} is created and a field is not found in the JSON object, that field will be assigned
      * the default value for the field type.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param json string with an array of JSON objects.
      * @throws IllegalArgumentException if trying to update a class without a {@link io.realm.annotations.PrimaryKey}.
@@ -625,6 +558,7 @@ private static void initializeSyncedRealm(Realm realm) {
     }
 
     public <E extends RealmModel> List<E> createOrUpdateAllFromJsonAndReturn(Class<E> clazz, String json) {
+        //noinspection ConstantConditions
         if (clazz == null || json == null || json.length() == 0) {
             return null;
         }
@@ -648,6 +582,9 @@ private static void initializeSyncedRealm(Realm realm) {
      * <p>
      * This API is only available in API level 11 or later.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of Realm objects created.
      * @param inputStream the JSON array as a InputStream. All objects in the array must be of the specified class.
      * @throws RealmException if mapping from JSON fails.
@@ -657,6 +594,7 @@ private static void initializeSyncedRealm(Realm realm) {
      */
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
     public <E extends RealmModel> void createAllFromJson(Class<E> clazz, InputStream inputStream) throws IOException {
+        //noinspection ConstantConditions
         if (clazz == null || inputStream == null) {
             return;
         }
@@ -683,6 +621,9 @@ private static void initializeSyncedRealm(Realm realm) {
      * <p>
      * This API is only available in API level 11 or later.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param in the InputStream with a list of object data in JSON format.
      * @throws IllegalArgumentException if trying to update a class without a {@link io.realm.annotations.PrimaryKey}.
@@ -697,6 +638,7 @@ private static void initializeSyncedRealm(Realm realm) {
     }
 
     public <E extends RealmModel> List<E> createOrUpdateAllFromJsonAndReturn(Class<E> clazz, InputStream in) {
+        //noinspection ConstantConditions
         if (clazz == null || in == null) {
             return null;
         }
@@ -730,6 +672,9 @@ private static void initializeSyncedRealm(Realm realm) {
      * properties with unknown properties will be ignored. If a {@link RealmObject} field is not present in the JSON
      * object the {@link RealmObject} field will be set to the default value for that type.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of Realm object to create.
      * @param json the JSONObject with object data.
      * @return created object or {@code null} if no JSON data was provided.
@@ -738,7 +683,9 @@ private static void initializeSyncedRealm(Realm realm) {
      * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      * @see #createOrUpdateObjectFromJson(Class, org.json.JSONObject)
      */
+    @Nullable
     public <E extends RealmModel> E createObjectFromJson(Class<E> clazz, JSONObject json) {
+        //noinspection ConstantConditions
         if (clazz == null || json == null) {
             return null;
         }
@@ -757,6 +704,9 @@ private static void initializeSyncedRealm(Realm realm) {
      * and a field is not found in the JSON object, that field will not be updated. If a new {@link RealmObject} is
      * created and a field is not found in the JSON object, that field will be assigned the default value for the field type.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz Type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param json {@link org.json.JSONObject} with object data.
      * @return created or updated {@link io.realm.RealmObject}.
@@ -767,6 +717,7 @@ private static void initializeSyncedRealm(Realm realm) {
      * @see #createObjectFromJson(Class, org.json.JSONObject)
      */
     public <E extends RealmModel> E createOrUpdateObjectFromJson(Class<E> clazz, JSONObject json) {
+        //noinspection ConstantConditions
         if (clazz == null || json == null) {
             return null;
         }
@@ -784,6 +735,9 @@ private static void initializeSyncedRealm(Realm realm) {
      * properties with unknown properties will be ignored. If a {@link RealmObject} field is not present in the JSON
      * object the {@link RealmObject} field will be set to the default value for that type.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of Realm object to create.
      * @param json the JSON string with object data.
      * @return created object or {@code null} if JSON string was empty or null.
@@ -791,7 +745,9 @@ private static void initializeSyncedRealm(Realm realm) {
      * @throws IllegalArgumentException if the JSON object doesn't have a primary key property but the corresponding
      * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      */
+    @Nullable
     public <E extends RealmModel> E createObjectFromJson(Class<E> clazz, String json) {
+        //noinspection ConstantConditions
         if (clazz == null || json == null || json.length() == 0) {
             return null;
         }
@@ -813,6 +769,9 @@ private static void initializeSyncedRealm(Realm realm) {
      * {@link RealmObject} is created and a field is not found in the JSON object, that field will be assigned the
      * default value for the field type.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param json string with object data in JSON format.
      * @return created or updated {@link io.realm.RealmObject}.
@@ -823,6 +782,7 @@ private static void initializeSyncedRealm(Realm realm) {
      * @see #createObjectFromJson(Class, String)
      */
     public <E extends RealmModel> E createOrUpdateObjectFromJson(Class<E> clazz, String json) {
+        //noinspection ConstantConditions
         if (clazz == null || json == null || json.length() == 0) {
             return null;
         }
@@ -846,6 +806,9 @@ private static void initializeSyncedRealm(Realm realm) {
      * <p>
      * This API is only available in API level 11 or later.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of Realm object to create.
      * @param inputStream the JSON object data as a InputStream.
      * @return created object or {@code null} if JSON string was empty or null.
@@ -854,15 +817,18 @@ private static void initializeSyncedRealm(Realm realm) {
      * {@link RealmObjectSchema} has a {@link io.realm.annotations.PrimaryKey} defined.
      * @throws IOException if something went wrong with the input stream.
      */
+    @Nullable
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
     public <E extends RealmModel> E createObjectFromJson(Class<E> clazz, InputStream inputStream) throws IOException {
+        //noinspection ConstantConditions
         if (clazz == null || inputStream == null) {
             return null;
         }
         checkIfValid();
         E realmObject;
-        Table table = schema.getTable(clazz);
-        if (table.hasPrimaryKey()) {
+
+        if (OsObjectStore.getPrimaryKeyForObject(
+                sharedRealm, configuration.getSchemaMediator().getSimpleClassName(clazz)) != null) {
             // As we need the primary key value we have to first parse the entire input stream as in the general
             // case that value might be the last property. :(
             Scanner scanner = null;
@@ -898,6 +864,9 @@ private static void initializeSyncedRealm(Realm realm) {
      * <p>
      * This API is only available in API level 11 or later.
      *
+     * <p>
+     * This method currently does not support value list field.
+     *
      * @param clazz type of {@link io.realm.RealmObject} to create or update. It must have a primary key defined.
      * @param in the {@link InputStream} with object data in JSON format.
      * @return created or updated {@link io.realm.RealmObject}.
@@ -909,6 +878,7 @@ private static void initializeSyncedRealm(Realm realm) {
      */
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
     public <E extends RealmModel> E createOrUpdateObjectFromJson(Class<E> clazz, InputStream in) {
+        //noinspection ConstantConditions
         if (clazz == null || in == null) {
             return null;
         }
@@ -968,12 +938,15 @@ private Scanner getFullStringScanner(InputStream in) {
             List<String> excludeFields) {
         Table table = schema.getTable(clazz);
         // Checks and throws the exception earlier for a better exception message.
-        if (table.hasPrimaryKey()) {
-            throw new RealmException(String.format("'%s' has a primary key, use" +
-                    " 'createObject(Class<E>, Object)' instead.", Table.tableNameToClassName(table.getName())));
+        if (OsObjectStore.getPrimaryKeyForObject(
+                sharedRealm, configuration.getSchemaMediator().getSimpleClassName(clazz)) != null) {
+            throw new RealmException(String.format(Locale.US, "'%s' has a primary key, use" +
+                    " 'createObject(Class<E>, Object)' instead.", table.getClassName()));
         }
-        long rowIndex = table.addEmptyRow();
-        return get(clazz, rowIndex, acceptDefaultValue, excludeFields);
+        return configuration.getSchemaMediator().newInstance(clazz, this,
+                OsObject.create(table),
+                schema.getColumnInfo(clazz),
+                acceptDefaultValue, excludeFields);
     }
 
     /**
@@ -991,7 +964,7 @@ private Scanner getFullStringScanner(InputStream in) {
      * @throws IllegalArgumentException if the {@code primaryKeyValue} doesn't have a value that can be converted to the
      * expected value.
      */
-    public <E extends RealmModel> E createObject(Class<E> clazz, Object primaryKeyValue) {
+    public <E extends RealmModel> E createObject(Class<E> clazz, @Nullable Object primaryKeyValue) {
         checkIfValid();
         return createObjectInternal(clazz, primaryKeyValue, true, Collections.<String>emptyList());
     }
@@ -1012,12 +985,15 @@ private Scanner getFullStringScanner(InputStream in) {
     // Called from proxy classes.
     <E extends RealmModel> E createObjectInternal(
             Class<E> clazz,
-            Object primaryKeyValue,
+            @Nullable Object primaryKeyValue,
             boolean acceptDefaultValue,
             List<String> excludeFields) {
         Table table = schema.getTable(clazz);
-        long rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
-        return get(clazz, rowIndex, acceptDefaultValue, excludeFields);
+
+        return configuration.getSchemaMediator().newInstance(clazz, this,
+                OsObject.createWithPrimaryKey(table, primaryKeyValue),
+                schema.getColumnInfo(clazz),
+                acceptDefaultValue, excludeFields);
     }
 
     /**
@@ -1072,6 +1048,7 @@ private Scanner getFullStringScanner(InputStream in) {
      * @throws java.lang.IllegalArgumentException if any of the elements in the input collection is {@code null}.
      */
     public <E extends RealmModel> List<E> copyToRealm(Iterable<E> objects) {
+        //noinspection ConstantConditions
         if (objects == null) {
             return new ArrayList<>();
         }
@@ -1110,6 +1087,7 @@ private Scanner getFullStringScanner(InputStream in) {
      */
     public void insert(Collection<? extends RealmModel> objects) {
         checkIfValidAndInTransaction();
+        //noinspection ConstantConditions
         if (objects == null) {
             throw new IllegalArgumentException("Null objects cannot be inserted into Realm.");
         }
@@ -1146,6 +1124,7 @@ public void insert(Collection<? extends RealmModel> objects) {
      */
     public void insert(RealmModel object) {
         checkIfValidAndInTransaction();
+        //noinspection ConstantConditions
         if (object == null) {
             throw new IllegalArgumentException("Null object cannot be inserted into Realm.");
         }
@@ -1181,6 +1160,7 @@ public void insert(RealmModel object) {
      */
     public void insertOrUpdate(Collection<? extends RealmModel> objects) {
         checkIfValidAndInTransaction();
+        //noinspection ConstantConditions
         if (objects == null) {
             throw new IllegalArgumentException("Null objects cannot be inserted into Realm.");
         }
@@ -1216,6 +1196,7 @@ public void insertOrUpdate(Collection<? extends RealmModel> objects) {
      */
     public void insertOrUpdate(RealmModel object) {
         checkIfValidAndInTransaction();
+        //noinspection ConstantConditions
         if (object == null) {
             throw new IllegalArgumentException("Null object cannot be inserted into Realm.");
         }
@@ -1237,6 +1218,7 @@ public void insertOrUpdate(RealmModel object) {
      * @see #copyToRealm(Iterable)
      */
     public <E extends RealmModel> List<E> copyToRealmOrUpdate(Iterable<E> objects) {
+        //noinspection ConstantConditions
         if (objects == null) {
             return new ArrayList<>(0);
         }
@@ -1295,6 +1277,7 @@ public void insertOrUpdate(RealmModel object) {
      */
     public <E extends RealmModel> List<E> copyFromRealm(Iterable<E> realmObjects, int maxDepth) {
         checkMaxDepth(maxDepth);
+        //noinspection ConstantConditions
         if (realmObjects == null) {
             return new ArrayList<>(0);
         }
@@ -1421,6 +1404,7 @@ public void removeAllChangeListeners() {
      * @throws RealmMigrationNeededException if the latest version contains incompatible schema changes.
      */
     public void executeTransaction(Transaction transaction) {
+        //noinspection ConstantConditions
         if (transaction == null) {
             throw new IllegalArgumentException("Transaction should not be null");
         }
@@ -1461,6 +1445,7 @@ public RealmAsyncTask executeTransactionAsync(final Transaction transaction) {
      * another thread.
      */
     public RealmAsyncTask executeTransactionAsync(final Transaction transaction, final Realm.Transaction.OnSuccess onSuccess) {
+        //noinspection ConstantConditions
         if (onSuccess == null) {
             throw new IllegalArgumentException("onSuccess callback can't be null");
         }
@@ -1478,6 +1463,7 @@ public RealmAsyncTask executeTransactionAsync(final Transaction transaction, fin
      * another thread.
      */
     public RealmAsyncTask executeTransactionAsync(final Transaction transaction, final Realm.Transaction.OnError onError) {
+        //noinspection ConstantConditions
         if (onError == null) {
             throw new IllegalArgumentException("onError callback can't be null");
         }
@@ -1496,10 +1482,11 @@ public RealmAsyncTask executeTransactionAsync(final Transaction transaction, fin
      * another thread.
      */
     public RealmAsyncTask executeTransactionAsync(final Transaction transaction,
-            final Realm.Transaction.OnSuccess onSuccess,
-            final Realm.Transaction.OnError onError) {
+            @Nullable final Realm.Transaction.OnSuccess onSuccess,
+            @Nullable final Realm.Transaction.OnError onError) {
         checkIfValid();
 
+        //noinspection ConstantConditions
         if (transaction == null) {
             throw new IllegalArgumentException("Transaction should not be null");
         }
@@ -1595,8 +1582,8 @@ public void run() {
                     }
                 } else {
                     if (backgroundException != null) {
-                        // FIXME: ThreadPoolExecutor will never throw the exception in the background. We need a
-                        //        redesign of the async transaction API.
+                        // FIXME: ThreadPoolExecutor will never throw the exception in the background.
+                        // We need a redesign of the async transaction API.
                         // Throw in the worker thread since the caller thread cannot get notifications.
                         throw new RealmException("Async transaction failed", backgroundException);
                     }
@@ -1632,13 +1619,17 @@ public void delete(Class<? extends RealmModel> clazz) {
     }
 
     private <E extends RealmModel> void checkNotNullObject(E object) {
+        //noinspection ConstantConditions
         if (object == null) {
             throw new IllegalArgumentException("Null objects cannot be copied into Realm.");
         }
     }
 
     private void checkHasPrimaryKey(Class<? extends RealmModel> clazz) {
-        if (!schema.getTable(clazz).hasPrimaryKey()) {
+        String className = configuration.getSchemaMediator().getSimpleClassName(clazz);
+        OsObjectSchemaInfo objectSchemaInfo = sharedRealm.getSchemaInfo().getObjectSchemaInfo(className);
+
+        if (objectSchemaInfo.getPrimaryKeyProperty() == null) {
             throw new IllegalArgumentException("A RealmObject with no @PrimaryKey cannot be updated: " + clazz.toString());
         }
     }
@@ -1650,6 +1641,7 @@ private void checkMaxDepth(int maxDepth) {
     }
 
     private <E extends RealmModel> void checkValidObjectForDetach(E realmObject) {
+        //noinspection ConstantConditions
         if (realmObject == null) {
             throw new IllegalArgumentException("Null objects cannot be copied from Realm.");
         }
@@ -1669,23 +1661,7 @@ private void checkMaxDepth(int maxDepth) {
      * @throws FileNotFoundException if the Realm file doesn't exist.
      */
     public static void migrateRealm(RealmConfiguration configuration) throws FileNotFoundException {
-        migrateRealm(configuration, (RealmMigration) null);
-    }
-
-    /**
-     * Called when migration needed in the Realm initialization.
-     *
-     * @param configuration {@link RealmConfiguration}
-     * @param cause which triggers this migration.
-     * @throws FileNotFoundException if the Realm file doesn't exist.
-     */
-    private static void migrateRealm(final RealmConfiguration configuration, final RealmMigrationNeededException cause)
-            throws FileNotFoundException {
-        BaseRealm.migrateRealm(configuration, null, new MigrationCallback() {
-            @Override
-            public void migrationComplete() {
-            }
-        }, cause);
+        migrateRealm(configuration, null);
     }
 
     /**
@@ -1696,21 +1672,24 @@ public void migrationComplete() {
      * configuration.
      * @throws FileNotFoundException if the Realm file doesn't exist.
      */
-    public static void migrateRealm(RealmConfiguration configuration, RealmMigration migration)
+    public static void migrateRealm(RealmConfiguration configuration, @Nullable RealmMigration migration)
             throws FileNotFoundException {
-        BaseRealm.migrateRealm(configuration, migration, new MigrationCallback() {
-            @Override
-            public void migrationComplete() {
-            }
-        }, null);
+        BaseRealm.migrateRealm(configuration, migration);
     }
 
     /**
-     * Deletes the Realm file specified by the given {@link RealmConfiguration} from the filesystem.
+     * Deletes the Realm file along with the related temporary files specified by the given {@link RealmConfiguration}
+     * from the filesystem. Temporary file with ".lock" extension won't be deleted.
+     * <p>
      * All Realm instances must be closed before calling this method.
+     * <p>
+     * WARNING: For synchronized Realm, there is a chance that an internal Realm instance on the background thread is
+     * not closed even all the user controlled Realm instances are closed. This will result an
+     * {@code IllegalStateException}. See issue https://github.com/realm/realm-java/issues/5416 .
      *
      * @param configuration a {@link RealmConfiguration}.
-     * @return {@code false} if a file could not be deleted. The failing file will be logged.
+     * @return {@code false} if the Realm file could not be deleted. Temporary files deletion failure won't impact
+     * the return value. All of the failing file deletions will be logged.
      * @throws IllegalStateException if not all realm instances are closed.
      */
     public static boolean deleteRealm(RealmConfiguration configuration) {
@@ -1738,47 +1717,46 @@ public static boolean compactRealm(RealmConfiguration configuration) {
         return BaseRealm.compactRealm(configuration);
     }
 
-    Table getTable(Class<? extends RealmModel> clazz) {
-        return schema.getTable(clazz);
-    }
-
     /**
-     * Updates own schema cache.
+     * If the Realm is a partially synchronized Realm, fetch and synchronize the objects of a given
+     * object type that match the given query (in string format).
      *
-     * @param globalCacheArray global cache of column indices. If it contains an entry for current
-     * schema version, this method only copies the indices information in the entry.
-     * @return newly created indices information for current schema version. Or {@code null} if {@code globalCacheArray}
-     * already contains the entry for current schema version.
+     * The results will be returned asynchronously in the callback.
+     *
+     * @param clazz the class to query.
+     * @param query string query.
+     * @param callback A callback used to vend the results of a partial sync fetch.
+     * @throws IllegalStateException if it is called from a non-Looper or {@link IntentService} thread.
+     * @throws IllegalStateException if called from a non-synchronized (Realm Object Server) Realm.
      */
-    ColumnIndices updateSchemaCache(ColumnIndices[] globalCacheArray) {
-        final long currentSchemaVersion = sharedRealm.getSchemaVersion();
-        final long cacheSchemaVersion = schema.getSchemaVersion();
-        if (currentSchemaVersion == cacheSchemaVersion) {
-            return null;
+    @Beta
+    public <E extends RealmModel> void subscribeToObjects(final Class<E> clazz, String query, final PartialSyncCallback<E> callback) {
+        checkIfValid();
+        if (!configuration.isSyncConfiguration()) {
+            throw new IllegalStateException("Partial sync is only available for synchronized Realm (Realm Object Server)");
         }
 
-        ColumnIndices createdGlobalCache = null;
-        final RealmProxyMediator mediator = getConfiguration().getSchemaMediator();
-        ColumnIndices cacheForCurrentVersion = RealmCache.findColumnIndices(globalCacheArray,
-                currentSchemaVersion);
-        if (cacheForCurrentVersion == null) {
-            // Not found in global cache. create it.
-            final Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
-            final Map<Class<? extends RealmModel>, ColumnInfo> map;
-            map = new HashMap<>(modelClasses.size());
-            try {
-                for (Class<? extends RealmModel> clazz : modelClasses) {
-                    final ColumnInfo columnInfo = mediator.validateTable(clazz, sharedRealm, true);
-                    map.put(clazz, columnInfo);
-                }
-            } catch (RealmMigrationNeededException e) {
-                throw e;
+        sharedRealm.capabilities.checkCanDeliverNotification(BaseRealm.LISTENER_NOT_ALLOWED_MESSAGE);
+
+        String className = configuration.getSchemaMediator().getSimpleClassName(clazz);
+        SharedRealm.PartialSyncCallback internalCallback = new SharedRealm.PartialSyncCallback(className) {
+            @Override
+            public void onSuccess(OsResults osResults) {
+                RealmResults<E> results = new RealmResults<>(Realm.this, osResults, clazz);
+                callback.onSuccess(results);
             }
 
-            cacheForCurrentVersion = createdGlobalCache = new ColumnIndices(currentSchemaVersion, map);
-        }
-        schema.updateColumnIndices(cacheForCurrentVersion, mediator);
-        return createdGlobalCache;
+            @Override
+            public void onError(RealmException error) {
+                callback.onError(error);
+            }
+        };
+
+        sharedRealm.registerPartialSyncQuery(query, internalCallback);
+    }
+
+    Table getTable(Class<? extends RealmModel> clazz) {
+        return schema.getTable(clazz);
     }
 
     /**
@@ -1789,6 +1767,7 @@ ColumnIndices updateSchemaCache(ColumnIndices[] globalCacheArray) {
      * @throws RealmException if unable to create an instance of the module.
      * @see io.realm.RealmConfiguration.Builder#modules(Object, Object...)
      */
+    @Nullable
     public static Object getDefaultModule() {
         String moduleName = "io.realm.DefaultRealmModule";
         Class<?> clazz;
@@ -1873,4 +1852,28 @@ public void onError(Exception ignore) {}
             void onError(Throwable error);
         }
     }
+
+    /**
+     * {@inheritDoc}
+     */
+    public static abstract class Callback extends InstanceCallback<Realm> {
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public abstract void onSuccess(Realm realm);
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void onError(Throwable exception) {
+            super.onError(exception);
+        }
+    }
+
+    public static abstract class PartialSyncCallback<T extends RealmModel> {
+        public abstract void onSuccess(RealmResults<T> results);
+        public abstract void onError(RealmException error);
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java b/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
index 28fceabc74..950b3066d7 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmAsyncTask.java
@@ -17,7 +17,7 @@
 package io.realm;
 
 /**
- * Represents a pending asynchronous Realm transaction.
+ * Represents a pending asynchronous Realm task, like asynchronous transactions.
  * <p>
  * Users are responsible for maintaining a reference to {@code RealmAsyncTask} in order to call {@link #cancel()} in
  * case of a configuration change for example (to avoid memory leak, as the transaction will post the result to the
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index b4cab8a8ec..a7544f5da6 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -19,16 +19,30 @@
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.lang.ref.WeakReference;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.EnumMap;
-import java.util.HashMap;
-import java.util.Map;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import io.realm.exceptions.RealmFileException;
-import io.realm.internal.ColumnIndices;
+import io.realm.internal.Capabilities;
 import io.realm.internal.ObjectServerFacade;
+import io.realm.internal.OsObjectStore;
+import io.realm.internal.RealmNotifier;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
+import io.realm.internal.Util;
+import io.realm.internal.android.AndroidCapabilities;
+import io.realm.internal.android.AndroidRealmNotifier;
+import io.realm.internal.async.RealmAsyncTaskImpl;
 import io.realm.log.RealmLog;
 
 
@@ -73,31 +87,187 @@ static RealmCacheType valueOf(Class<? extends BaseRealm> clazz) {
         }
     }
 
+    private static class CreateRealmRunnable<T extends BaseRealm> implements Runnable {
+        private final RealmConfiguration configuration;
+        private final BaseRealm.InstanceCallback<T> callback;
+        private final Class<T> realmClass;
+        private final CountDownLatch canReleaseBackgroundInstanceLatch = new CountDownLatch(1);
+        private final RealmNotifier notifier;
+        // The Future this runnable belongs to.
+        private Future future;
+
+        CreateRealmRunnable(RealmNotifier notifier, RealmConfiguration configuration,
+                BaseRealm.InstanceCallback<T> callback, Class<T> realmClass) {
+            this.configuration = configuration;
+            this.realmClass = realmClass;
+            this.callback = callback;
+            this.notifier = notifier;
+        }
+
+        public void setFuture(Future future) {
+            this.future = future;
+        }
+
+        @Override
+        public void run() {
+            T instance = null;
+            try {
+                // First call that will run all schema validation, migrations or initial transactions.
+                instance = createRealmOrGetFromCache(configuration, realmClass);
+                boolean results = notifier.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        // If the RealmAsyncTask.cancel() is called before, we just return without creating the Realm
+                        // instance on the caller thread.
+                        // Thread.isInterrupted() cannot be used for checking here since CountDownLatch.await() will
+                        // will clear interrupted status.
+                        // Using the future to check which this runnable belongs to is to ensure if it is canceled from
+                        // the caller thread before, the callback will never be delivered.
+                        if (future == null || future.isCancelled()) {
+                            canReleaseBackgroundInstanceLatch.countDown();
+                            return;
+                        }
+                        T instanceToReturn = null;
+                        Throwable throwable = null;
+                        try {
+                            // This will run on the caller thread, but since the first `createRealmOrGetFromCache`
+                            // should have completed at this point, all expensive initializer functions have already
+                            // run.
+                            instanceToReturn = createRealmOrGetFromCache(configuration, realmClass);
+                        } catch (Throwable e) {
+                            throwable = e;
+                        } finally {
+                            canReleaseBackgroundInstanceLatch.countDown();
+                        }
+                        if (instanceToReturn != null) {
+                            callback.onSuccess(instanceToReturn);
+                        } else {
+                            // throwable is non-null
+                            //noinspection ConstantConditions
+                            callback.onError(throwable);
+                        }
+                    }
+                });
+                if (!results) {
+                    canReleaseBackgroundInstanceLatch.countDown();
+                }
+                // There is a small chance that the posted runnable cannot be executed because of the thread terminated
+                // before the runnable gets fetched from the event queue.
+                if (!canReleaseBackgroundInstanceLatch.await(2, TimeUnit.SECONDS)) {
+                    RealmLog.warn("Timeout for creating Realm instance in foreground thread in `CreateRealmRunnable` ");
+                }
+            } catch (InterruptedException e) {
+                RealmLog.warn(e, "`CreateRealmRunnable` has been interrupted.");
+            } catch (final Throwable e) {
+                // DownloadingRealmInterruptedException is treated specially.
+                // It async open is canceled, this could interrupt the download, but the user should
+                // not care in this case, so just ignore it.
+                if (!ObjectServerFacade.getSyncFacadeIfPossible().wasDownloadInterrupted(e)) {
+                    RealmLog.error(e, "`CreateRealmRunnable` failed.");
+                    notifier.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            callback.onError(e);
+                        }
+                    });
+                }
+            } finally {
+                if (instance != null) {
+                    instance.close();
+                }
+            }
+        }
+    }
+
+    private static final String ASYNC_NOT_ALLOWED_MSG =
+            "Realm instances cannot be loaded asynchronously on a non-looper thread.";
+    private static final String ASYNC_CALLBACK_NULL_MSG =
+            "The callback cannot be null.";
+
     // Separated references and counters for typed Realm and dynamic Realm.
     private final EnumMap<RealmCacheType, RefAndCount> refAndCountMap;
 
-    final private RealmConfiguration configuration;
+    // Path to the Realm file to identify this cache.
+    private final String realmPath;
 
-    // Column indices are cached to speed up opening typed Realm. If a Realm instance is created in one thread, creating
-    // Realm instances in other threads doesn't have to initialize the column indices again.
-    private static final int MAX_ENTRIES_IN_TYPED_COLUMN_INDICES_ARRAY = 4;
-    private final ColumnIndices[] typedColumnIndicesArray = new ColumnIndices[MAX_ENTRIES_IN_TYPED_COLUMN_INDICES_ARRAY];
+    // This will be only valid if getTotalGlobalRefCount() > 0.
+    // NOTE: We do reset this when globalCount reaches 0, but if exception thrown in doCreateRealmOrGetFromCache at the
+    // first time when globalCount == 0, this could have a non-null value but it will be reset when the next
+    // doCreateRealmOrGetFromCache is called with globalCount == 0.
+    private RealmConfiguration configuration;
 
-    // Realm path will be used as the key to store different RealmCaches. Different Realm configurations with same path
-    // are not allowed and an exception will be thrown when trying to add it to the cache map.
-    private static final Map<String, RealmCache> cachesMap = new HashMap<>();
+    // Realm path will be used to identify different RealmCaches. Different Realm configurations with same path
+    // are not allowed and an exception will be thrown when trying to add it to the cache list.
+    // A weak ref is used to hold the RealmCache instance. The weak ref entry will be cleared if and only if there
+    // is no Realm instance holding a strong ref to it and there is no Realm instance associated it is BEING created.
+    private static final List<WeakReference<RealmCache>> cachesList = new LinkedList<WeakReference<RealmCache>>();
+
+    // See leak()
+    // isLeaked flag is used to avoid adding strong ref multiple times without iterating the list.
+    private final AtomicBoolean isLeaked = new AtomicBoolean(false);
+    // Keep strong ref to the leaked RealmCache
+    @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
+    private static final Collection<RealmCache> leakedCaches = new ConcurrentLinkedQueue<RealmCache>();
 
     private static final String DIFFERENT_KEY_MESSAGE = "Wrong key used to decrypt Realm.";
     private static final String WRONG_REALM_CLASS_MESSAGE = "The type of Realm class must be Realm or DynamicRealm.";
 
-    private RealmCache(RealmConfiguration config) {
-        configuration = config;
+    private RealmCache(String path) {
+        realmPath = path;
         refAndCountMap = new EnumMap<>(RealmCacheType.class);
         for (RealmCacheType type : RealmCacheType.values()) {
             refAndCountMap.put(type, new RefAndCount());
         }
     }
 
+    private static RealmCache getCache(String realmPath, boolean createIfNotExist) {
+        RealmCache cacheToReturn = null;
+        synchronized (cachesList) {
+            Iterator<WeakReference<RealmCache>> it = cachesList.iterator();
+
+            while (it.hasNext()) {
+                RealmCache cache = it.next().get();
+                if (cache == null) {
+                    // Clear the entry if there is no one holding the RealmCache.
+                    it.remove();
+                } else if (cache.realmPath.equals(realmPath)) {
+                    cacheToReturn = cache;
+                }
+            }
+
+            if (cacheToReturn == null && createIfNotExist) {
+                cacheToReturn = new RealmCache(realmPath);
+                cachesList.add(new WeakReference<RealmCache>(cacheToReturn));
+            }
+        }
+        return cacheToReturn;
+    }
+
+    static <T extends BaseRealm> RealmAsyncTask createRealmOrGetFromCacheAsync(
+            RealmConfiguration configuration, BaseRealm.InstanceCallback<T> callback, Class<T> realmClass) {
+        RealmCache cache = getCache(configuration.getPath(), true);
+        return cache.doCreateRealmOrGetFromCacheAsync(configuration, callback, realmClass);
+    }
+
+    private synchronized <T extends BaseRealm> RealmAsyncTask doCreateRealmOrGetFromCacheAsync(
+            RealmConfiguration configuration, BaseRealm.InstanceCallback<T> callback, Class<T> realmClass) {
+        Capabilities capabilities = new AndroidCapabilities();
+        capabilities.checkCanDeliverNotification(ASYNC_NOT_ALLOWED_MSG);
+        //noinspection ConstantConditions
+        if (callback == null) {
+            throw new IllegalArgumentException(ASYNC_CALLBACK_NULL_MSG);
+        }
+
+        // Always create a Realm instance in the background thread even when there are instances existing on current
+        // thread. This to ensure that onSuccess will always be called in the following event loop but not current one.
+        CreateRealmRunnable<T> createRealmRunnable = new CreateRealmRunnable<T>(
+                new AndroidRealmNotifier(null, capabilities), configuration, callback, realmClass);
+        Future<?> future = BaseRealm.asyncTaskExecutor.submitTransaction(createRealmRunnable);
+        createRealmRunnable.setFuture(future);
+
+        return new RealmAsyncTaskImpl(future, BaseRealm.asyncTaskExecutor);
+    }
+
     /**
      * Creates a new Realm instance or get an existing instance for current thread.
      *
@@ -105,35 +275,62 @@ private RealmCache(RealmConfiguration config) {
      * @param realmClass class of {@link Realm} or {@link DynamicRealm} to be created in or gotten from the cache.
      * @return the {@link Realm} or {@link DynamicRealm} instance.
      */
-    static synchronized <E extends BaseRealm> E createRealmOrGetFromCache(RealmConfiguration configuration,
+    static <E extends BaseRealm> E createRealmOrGetFromCache(RealmConfiguration configuration,
             Class<E> realmClass) {
-        boolean isCacheInMap = true;
-        RealmCache cache = cachesMap.get(configuration.getPath());
-        if (cache == null) {
-            // Creates a new cache.
-            cache = new RealmCache(configuration);
-            // The new cache should be added to the map later.
-            isCacheInMap = false;
+        RealmCache cache = getCache(configuration.getPath(), true);
 
-            copyAssetFileIfNeeded(configuration);
-        } else {
-            // Throws the exception if validation failed.
-            cache.validateConfiguration(configuration);
-        }
+        return cache.doCreateRealmOrGetFromCache(configuration, realmClass);
+    }
 
-        RefAndCount refAndCount = cache.refAndCountMap.get(RealmCacheType.valueOf(realmClass));
+    private synchronized <E extends BaseRealm> E doCreateRealmOrGetFromCache(RealmConfiguration configuration,
+            Class<E> realmClass) {
+
+        RefAndCount refAndCount = refAndCountMap.get(RealmCacheType.valueOf(realmClass));
+
+        if (getTotalGlobalRefCount() == 0) {
+            copyAssetFileIfNeeded(configuration);
+            boolean fileExists = configuration.realmExists();
 
-        if (refAndCount.globalCount == 0) {
-            SharedRealm sharedRealm = SharedRealm.getInstance(configuration);
-            if (Table.primaryKeyTableNeedsMigration(sharedRealm)) {
-                sharedRealm.beginTransaction();
-                if (Table.migratePrimaryKeyTableIfNeeded(sharedRealm)) {
-                    sharedRealm.commitTransaction();
+            SharedRealm sharedRealm = null;
+            try {
+                if (configuration.isSyncConfiguration()) {
+                    // If waitForInitialRemoteData() was enabled, we need to make sure that all data is downloaded
+                    // before proceeding. We need to open the Realm instance first to start any potential underlying
+                    // SyncSession so this will work. TODO: This needs to be decoupled.
+                    if (!fileExists) {
+                        sharedRealm = SharedRealm.getInstance(configuration);
+                        try {
+                            ObjectServerFacade.getSyncFacadeIfPossible().downloadRemoteChanges(configuration);
+                        } catch (Throwable t) {
+                            // If an error happened while downloading initial data, we need to reset the file so we can
+                            // download it again on the next attempt.
+                            sharedRealm.close();
+                            sharedRealm = null;
+                            // FIXME: We don't have a way to ensure that the Realm instance on client thread has been
+                            //        closed for now.
+                            // https://github.com/realm/realm-java/issues/5416
+                            BaseRealm.deleteRealm(configuration);
+                            throw t;
+                        }
+                    }
                 } else {
-                    sharedRealm.cancelTransaction();
+                    if (fileExists) {
+                        // Primary key problem only exists before we release sync.
+                        sharedRealm = SharedRealm.getInstance(configuration);
+                        Table.migratePrimaryKeyTableIfNeeded(sharedRealm);
+                    }
+                }
+            } finally {
+                if (sharedRealm != null) {
+                    sharedRealm.close();
                 }
             }
-            sharedRealm.close();
+
+            // We are holding the lock, and we can set the invalidated configuration since there is no global ref to it.
+            this.configuration = configuration;
+        } else {
+            // Throws exception if validation failed.
+            validateConfiguration(configuration);
         }
 
         if (refAndCount.localRealm.get() == null) {
@@ -142,39 +339,26 @@ private RealmCache(RealmConfiguration config) {
 
             if (realmClass == Realm.class) {
                 // RealmMigrationNeededException might be thrown here.
-                realm = Realm.createInstance(configuration, cache.typedColumnIndicesArray);
+                realm = Realm.createInstance(this);
             } else if (realmClass == DynamicRealm.class) {
-                realm = DynamicRealm.createInstance(configuration);
+                realm = DynamicRealm.createInstance(this);
             } else {
                 throw new IllegalArgumentException(WRONG_REALM_CLASS_MESSAGE);
             }
 
             // The Realm instance has been created without exceptions. Cache and reference count can be updated now.
-
-            // The cache is not in the map yet. Add it to the map after the Realm instance created successfully.
-            if (!isCacheInMap) {
-                cachesMap.put(configuration.getPath(), cache);
-            }
             refAndCount.localRealm.set(realm);
             refAndCount.localCount.set(0);
-        }
 
-        Integer refCount = refAndCount.localCount.get();
-        if (refCount == 0) {
-            if (realmClass == Realm.class && refAndCount.globalCount == 0) {
-                final BaseRealm realm = refAndCount.localRealm.get();
-                // Stores a copy of local ColumnIndices as a global cache.
-                RealmCache.storeColumnIndices(cache.typedColumnIndicesArray, realm.schema.cloneColumnIndices());
-            }
             // This is the first instance in current thread, increase the global count.
             refAndCount.globalCount++;
         }
-        refAndCount.localCount.set(refCount + 1);
 
-        @SuppressWarnings("unchecked")
-        E realm = (E) refAndCount.localRealm.get();
+        Integer refCount = refAndCount.localCount.get();
+        refAndCount.localCount.set(refCount + 1);
 
-        return realm;
+        //noinspection unchecked
+        return (E) refAndCount.localRealm.get();
     }
 
     /**
@@ -183,22 +367,16 @@ private RealmCache(RealmConfiguration config) {
      *
      * @param realm Realm instance to be released from cache.
      */
-    static synchronized void release(BaseRealm realm) {
+    synchronized void release(BaseRealm realm) {
         String canonicalPath = realm.getPath();
-        RealmCache cache = cachesMap.get(canonicalPath);
-        Integer refCount = null;
-        RefAndCount refAndCount = null;
-
-        if (cache != null) {
-            refAndCount = cache.refAndCountMap.get(RealmCacheType.valueOf(realm.getClass()));
-            refCount = refAndCount.localCount.get();
-        }
+        RefAndCount refAndCount = refAndCountMap.get(RealmCacheType.valueOf(realm.getClass()));
+        Integer refCount = refAndCount.localCount.get();
         if (refCount == null) {
             refCount = 0;
         }
 
         if (refCount <= 0) {
-            RealmLog.warn("%s has been closed already.", canonicalPath);
+            RealmLog.warn("%s has been closed already. refCount is %s", canonicalPath, refCount);
             return;
         }
 
@@ -219,23 +397,15 @@ static synchronized void release(BaseRealm realm) {
                         " got corrupted.");
             }
 
-            // Clears the column indices cache if needed.
-            if (realm instanceof Realm && refAndCount.globalCount == 0) {
-                // All typed Realm instances of this file are cleared from cache.
-                Arrays.fill(cache.typedColumnIndicesArray, null);
-            }
-
-            int totalRefCount = 0;
-            for (RealmCacheType type : RealmCacheType.values()) {
-                totalRefCount += cache.refAndCountMap.get(type).globalCount;
-            }
-
             // No more local reference to this Realm in current thread, close the instance.
             realm.doClose();
 
-            // No more instance of typed Realm and dynamic Realm. Remove the configuration from cache.
-            if (totalRefCount == 0) {
-                cachesMap.remove(canonicalPath);
+            // No more instance of typed Realm and dynamic Realm.
+            if (getTotalGlobalRefCount() == 0) {
+                // We keep the cache in the caches list even when its global counter reaches 0. It will be reused when
+                // next time a Realm instance with the same path is opened. By not removing it, the lock on
+                // cachesList is not needed here.
+                configuration = null;
                 ObjectServerFacade.getFacade(realm.getConfiguration().isSyncConfiguration())
                         .realmClosed(realm.getConfiguration());
             }
@@ -287,41 +457,23 @@ private void validateConfiguration(RealmConfiguration newConfiguration) {
      * @param configuration the {@link RealmConfiguration} of {@link Realm} or {@link DynamicRealm}.
      * @param callback the callback will be executed with the global reference count.
      */
-    static synchronized void invokeWithGlobalRefCount(RealmConfiguration configuration, Callback callback) {
-        RealmCache cache = cachesMap.get(configuration.getPath());
-        if (cache == null) {
-            callback.onResult(0);
-            return;
-        }
-        int totalRefCount = 0;
-        for (RealmCacheType type : RealmCacheType.values()) {
-            totalRefCount += cache.refAndCountMap.get(type).globalCount;
+    static void invokeWithGlobalRefCount(RealmConfiguration configuration, Callback callback) {
+        // NOTE: Although getCache is locked on the cacheMap, this whole method needs to be lock with it as
+        // well. Since we need to ensure there is no Realm instance can be opened when this method is called (for
+        // deleteRealm).
+        // Recursive lock cannot be avoided here.
+        synchronized (cachesList) {
+            RealmCache cache = getCache(configuration.getPath(), false);
+            if (cache == null) {
+                callback.onResult(0);
+                return;
+            }
+            cache.doInvokeWithGlobalRefCount(callback);
         }
-        callback.onResult(totalRefCount);
     }
 
-    /**
-     * Updates the schema cache in the typed Realm for {@code pathOfRealm}.
-     *
-     * @param realm the instance that contains the schema cache to be updated.
-     */
-    static synchronized void updateSchemaCache(Realm realm) {
-        final RealmCache cache = cachesMap.get(realm.getPath());
-        if (cache == null) {
-            // Called during initialization. just skip it.
-            return;
-        }
-        final RefAndCount refAndCount = cache.refAndCountMap.get(RealmCacheType.TYPED_REALM);
-        if (refAndCount.localRealm.get() == null) {
-            // Called during initialization. just skip it.
-            // We can reach here if the DynamicRealm instance is initialized first.
-            return;
-        }
-        final ColumnIndices[] globalCacheArray = cache.typedColumnIndicesArray;
-        final ColumnIndices createdCacheEntry = realm.updateSchemaCache(globalCacheArray);
-        if (createdCacheEntry != null) {
-            RealmCache.storeColumnIndices(globalCacheArray, createdCacheEntry);
-        }
+    private synchronized void doInvokeWithGlobalRefCount(Callback callback) {
+        callback.onResult(getTotalGlobalRefCount());
     }
 
     /**
@@ -329,7 +481,7 @@ static synchronized void updateSchemaCache(Realm realm) {
      *
      * @param callback the callback will be executed.
      */
-    static synchronized void invokeWithLock(Callback0 callback) {
+    synchronized void invokeWithLock(Callback0 callback) {
         callback.onCall();
     }
 
@@ -337,120 +489,128 @@ static synchronized void invokeWithLock(Callback0 callback) {
      * Copies Realm database file from Android asset directory to the directory given in the {@link RealmConfiguration}.
      * Copy is performed only at the first time when there is no Realm database file.
      *
+     * WARNING: This method is not thread-safe so external synchronization is required before using it.
+     *
      * @param configuration configuration object for Realm instance.
      * @throws RealmFileException if copying the file fails.
      */
-    private static void copyAssetFileIfNeeded(RealmConfiguration configuration) {
-        IOException exceptionWhenClose = null;
-        if (configuration.hasAssetFile()) {
-            File realmFile = new File(configuration.getRealmDirectory(), configuration.getRealmFileName());
-            if (realmFile.exists()) {
-                return;
-            }
+    private static void copyAssetFileIfNeeded(final RealmConfiguration configuration) {
+        final File realmFileFromAsset = configuration.hasAssetFile() ?
+                new File(configuration.getRealmDirectory(), configuration.getRealmFileName())
+                : null;
+        final String syncServerCertificateAssetName = ObjectServerFacade.getFacade(
+                configuration.isSyncConfiguration()).getSyncServerCertificateAssetName(configuration);
+        final boolean certFileExists = !Util.isEmptyString(syncServerCertificateAssetName);
+
+        if (realmFileFromAsset!= null || certFileExists) {
+            OsObjectStore.callWithLock(configuration, new Runnable() {
+                @Override
+                public void run() {
+                    if (realmFileFromAsset != null) {
+                        copyFileIfNeeded(configuration.getAssetFilePath(), realmFileFromAsset);
+                    }
 
-            InputStream inputStream = null;
-            FileOutputStream outputStream = null;
-            try {
-                inputStream = configuration.getAssetFile();
-                if (inputStream == null) {
-                    throw new RealmFileException(RealmFileException.Kind.ACCESS_ERROR,
-                            "Invalid input stream to asset file.");
-                }
+                    // Copy Sync Server certificate path if available
+                    if (certFileExists) {
+                        String syncServerCertificateFilePath = ObjectServerFacade.getFacade(
+                                configuration.isSyncConfiguration()).getSyncServerCertificateFilePath(configuration);
 
-                outputStream = new FileOutputStream(realmFile);
-                byte[] buf = new byte[4096];
-                int bytesRead;
-                while ((bytesRead = inputStream.read(buf)) > -1) {
-                    outputStream.write(buf, 0, bytesRead);
+                        File certificateFile = new File(syncServerCertificateFilePath);
+                        copyFileIfNeeded(syncServerCertificateAssetName, certificateFile);
+                    }
                 }
-            } catch (IOException e) {
+            });
+        }
+    }
+
+    private static void copyFileIfNeeded(String assetFileName, File file) {
+        if (file.exists()) {
+            return;
+        }
+
+        IOException exceptionWhenClose = null;
+        InputStream inputStream = null;
+        FileOutputStream outputStream = null;
+        try {
+            inputStream = BaseRealm.applicationContext.getAssets().open(assetFileName);
+            if (inputStream == null) {
                 throw new RealmFileException(RealmFileException.Kind.ACCESS_ERROR,
-                        "Could not resolve the path to the Realm asset file.", e);
-            } finally {
-                if (inputStream != null) {
-                    try {
-                        inputStream.close();
-                    } catch (IOException e) {
-                        exceptionWhenClose = e;
-                    }
+                        "Invalid input stream to the asset file: " + assetFileName);
+            }
+
+            outputStream = new FileOutputStream(file);
+            byte[] buf = new byte[4096];
+            int bytesRead;
+            while ((bytesRead = inputStream.read(buf)) > -1) {
+                outputStream.write(buf, 0, bytesRead);
+            }
+        } catch (IOException e) {
+            throw new RealmFileException(RealmFileException.Kind.ACCESS_ERROR,
+                    "Could not resolve the path to the asset file: " + assetFileName, e);
+        } finally {
+            if (inputStream != null) {
+                try {
+                    inputStream.close();
+                } catch (IOException e) {
+                    exceptionWhenClose = e;
                 }
-                if (outputStream != null) {
-                    try {
-                        outputStream.close();
-                    } catch (IOException e) {
-                        // Ignores this one if there was an exception when close inputStream.
-                        if (exceptionWhenClose == null) {
-                            exceptionWhenClose = e;
-                        }
+            }
+            if (outputStream != null) {
+                try {
+                    outputStream.close();
+                } catch (IOException e) {
+                    // Ignores this one if there was an exception when close inputStream.
+                    if (exceptionWhenClose == null) {
+                        exceptionWhenClose = e;
                     }
                 }
             }
+        }
 
-            // No other exception has been thrown, only the exception when close. So, throw it.
-            if (exceptionWhenClose != null) {
-                throw new RealmFileException(RealmFileException.Kind.ACCESS_ERROR, exceptionWhenClose);
-            }
+        // No other exception has been thrown, only the exception when close. So, throw it.
+        if (exceptionWhenClose != null) {
+            throw new RealmFileException(RealmFileException.Kind.ACCESS_ERROR, exceptionWhenClose);
         }
     }
 
     static int getLocalThreadCount(RealmConfiguration configuration) {
-        RealmCache cache = cachesMap.get(configuration.getPath());
+        RealmCache cache = getCache(configuration.getPath(), false);
         if (cache == null) {
             return 0;
-        } else {
-            int totalRefCount = 0;
-            for (RealmCacheType type : RealmCacheType.values()) {
-                Integer localCount = cache.refAndCountMap.get(type).localCount.get();
-                totalRefCount += (localCount != null) ? localCount : 0;
-            }
-            return totalRefCount;
         }
+
+        // Access local ref count only, no need to by synchronized.
+        int totalRefCount = 0;
+        for (RefAndCount refAndCount : cache.refAndCountMap.values()) {
+            Integer localCount = refAndCount.localCount.get();
+            totalRefCount += (localCount != null) ? localCount : 0;
+        }
+        return totalRefCount;
+    }
+
+    public RealmConfiguration getConfiguration() {
+        return configuration;
     }
 
     /**
-     * Finds an entry for specified schema version in the array.
-     *
-     * @param array target array of schema cache.
-     * @param schemaVersion requested version of the schema.
-     * @return {@link ColumnIndices} instance for specified schema version. {@code null} if not found.
+     * @return the total global ref count.
      */
-    public static ColumnIndices findColumnIndices(ColumnIndices[] array, long schemaVersion) {
-        for (int i = array.length - 1; 0 <= i; i--) {
-            final ColumnIndices candidate = array[i];
-            if (candidate != null && candidate.getSchemaVersion() == schemaVersion) {
-                return candidate;
-            }
+    private int getTotalGlobalRefCount() {
+        int totalRefCount = 0;
+        for (RefAndCount refAndCount : refAndCountMap.values()) {
+            totalRefCount += refAndCount.globalCount;
         }
-        return null;
+
+        return totalRefCount;
     }
 
     /**
-     * Stores the schema cache to the array.
-     * <p>
-     * If the {@code array} has an empty slot ({@code == null}), this method stores
-     * the {@code columnIndices} to it. Otherwise, the entry of the oldest schema version is
-     * replaced.
-     *
-     * @param array target array.
-     * @param columnIndices the item to be stored into the {@code array}.
-     * @return the index in the {@code array} where the {@code columnIndices} was stored.
+     * If a Realm instance is GCed but `Realm.close()` is not called before, we still want to track the cache for
+     * debugging. Adding them to the list to keep the strong ref of the cache to prevent the cache gets GCed.
      */
-    private static int storeColumnIndices(ColumnIndices[] array, ColumnIndices columnIndices) {
-        long oldestSchemaVersion = Long.MAX_VALUE;
-        int candidateIndex = -1;
-        for (int i = array.length - 1; 0 <= i; i--) {
-            if (array[i] == null) {
-                array[i] = columnIndices;
-                return i;
-            }
-
-            ColumnIndices target = array[i];
-            if (target.getSchemaVersion() <= oldestSchemaVersion) {
-                oldestSchemaVersion = target.getSchemaVersion();
-                candidateIndex = i;
-            }
+    void leak() {
+        if (!isLeaked.getAndSet(true)) {
+            leakedCaches.add(this);
         }
-        array[candidateIndex] = columnIndices;
-        return candidateIndex;
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java b/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java
index fac6e8f70b..165592e2c8 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmChangeListener.java
@@ -16,6 +16,7 @@
 
 package io.realm;
 
+
 /**
  * RealmChangeListener can be registered with a {@link Realm}, {@link RealmResults} or {@link RealmObject}
  * to receive a notification about updates.
@@ -42,6 +43,5 @@
     /**
      * Called when a transaction is committed.
      */
-    void onChange(T element);
-
+    void onChange(T t);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCollection.java b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
index 7d6d866549..7516d2b3bc 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCollection.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCollection.java
@@ -20,6 +20,10 @@
 import java.util.Collections;
 import java.util.Date;
 
+import javax.annotation.Nullable;
+
+import io.realm.internal.ManagableObject;
+
 
 /**
  * {@code RealmCollection} is the root of the collection hierarchy that Realm supports. It defines operations on data
@@ -31,7 +35,7 @@
  *
  * @param <E> type of {@link RealmObject} stored in the collection.
  */
-public interface RealmCollection<E extends RealmModel> extends Collection<E> {
+public interface RealmCollection<E> extends Collection<E>, ManagableObject {
 
     /**
      * Returns a {@link RealmQuery}, which can be used to query for specific objects from this collection.
@@ -52,6 +56,7 @@
      * @throws java.lang.IllegalArgumentException if the field is not a number type.
      * @throws java.lang.IllegalStateException if the Realm has been closed or called from an incorrect thread.
      */
+    @Nullable
     Number min(String fieldName);
 
     /**
@@ -64,6 +69,7 @@
      * @throws java.lang.IllegalArgumentException if the field is not a number type.
      * @throws java.lang.IllegalStateException if the Realm has been closed or called from an incorrect thread.
      */
+    @Nullable
     Number max(String fieldName);
 
     /**
@@ -100,6 +106,7 @@
      * @throws java.lang.IllegalArgumentException if fieldName is not a Date field.
      * @throws java.lang.IllegalStateException if the Realm has been closed or called from an incorrect thread.
      */
+    @Nullable
     Date maxDate(String fieldName);
 
     /**
@@ -113,6 +120,7 @@
      * @throws java.lang.IllegalArgumentException if fieldName is not a Date field.
      * @throws java.lang.IllegalStateException if the Realm has been closed or called from an incorrect thread.
      */
+    @Nullable
     Date minDate(String fieldName);
 
     /**
@@ -144,6 +152,7 @@
      *
      * @return {@code true} if it is still valid to use or an unmanaged collection, {@code false} otherwise.
      */
+    @Override
     boolean isValid();
 
     /**
@@ -159,6 +168,7 @@
      *
      * @return {@code true} if this is a managed {@link RealmCollection}, {@code false} otherwise.
      */
+    @Override
     boolean isManaged();
 
     /**
@@ -173,5 +183,5 @@
      * support {@code null} elements.
      */
     @Override
-    boolean contains(Object object);
+    boolean contains(@Nullable Object object);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index fd8312fde2..766a47e23e 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -17,24 +17,26 @@
 package io.realm;
 
 import android.content.Context;
-import android.text.TextUtils;
 
 import java.io.File;
 import java.io.IOException;
-import java.io.InputStream;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
+import java.util.Locale;
 import java.util.Set;
 
+import javax.annotation.Nullable;
+
 import io.realm.annotations.RealmModule;
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmFileException;
+import io.realm.internal.OsRealmConfig;
 import io.realm.internal.RealmCore;
 import io.realm.internal.RealmProxyMediator;
-import io.realm.internal.SharedRealm;
+import io.realm.internal.Util;
 import io.realm.internal.modules.CompositeMediator;
 import io.realm.internal.modules.FilterableMediator;
 import io.realm.rx.RealmObservableFactory;
@@ -52,7 +54,7 @@
  * <p>
  * A minimal configuration can be created using:
  * <p>
- * {@code RealmConfiguration config = new RealmConfiguration.Builder(getContext()).build())}
+ * {@code RealmConfiguration config = new RealmConfiguration.Builder().build()}
  * <p>
  * This will create a RealmConfiguration with the following properties.
  * <ul>
@@ -93,25 +95,35 @@
     private final long schemaVersion;
     private final RealmMigration migration;
     private final boolean deleteRealmIfMigrationNeeded;
-    private final SharedRealm.Durability durability;
+    private final OsRealmConfig.Durability durability;
     private final RealmProxyMediator schemaMediator;
     private final RxObservableFactory rxObservableFactory;
     private final Realm.Transaction initialDataTransaction;
+    private final boolean readOnly;
+    private final CompactOnLaunchCallback compactOnLaunch;
+    /**
+     * Whether this RealmConfiguration is intended to open a
+     * recovery Realm produced after an offline/online client reset.
+     */
+    private final boolean isRecoveryConfiguration;
 
     // We need to enumerate all parameters since SyncConfiguration and RealmConfiguration supports different
     // subsets of them.
-    protected RealmConfiguration(File realmDirectory,
-            String realmFileName,
+    protected RealmConfiguration(@Nullable File realmDirectory,
+            @Nullable String realmFileName,
             String canonicalPath,
-            String assetFilePath,
-            byte[] key,
+            @Nullable String assetFilePath,
+            @Nullable byte[] key,
             long schemaVersion,
-            RealmMigration migration,
+            @Nullable RealmMigration migration,
             boolean deleteRealmIfMigrationNeeded,
-            SharedRealm.Durability durability,
+            OsRealmConfig.Durability durability,
             RealmProxyMediator schemaMediator,
-            RxObservableFactory rxObservableFactory,
-            Realm.Transaction initialDataTransaction) {
+            @Nullable RxObservableFactory rxObservableFactory,
+            @Nullable Realm.Transaction initialDataTransaction,
+            boolean readOnly,
+            @Nullable CompactOnLaunchCallback compactOnLaunch,
+            boolean isRecoveryConfiguration) {
         this.realmDirectory = realmDirectory;
         this.realmFileName = realmFileName;
         this.canonicalPath = canonicalPath;
@@ -124,6 +136,9 @@ protected RealmConfiguration(File realmDirectory,
         this.schemaMediator = schemaMediator;
         this.rxObservableFactory = rxObservableFactory;
         this.initialDataTransaction = initialDataTransaction;
+        this.readOnly = readOnly;
+        this.compactOnLaunch = compactOnLaunch;
+        this.isRecoveryConfiguration = isRecoveryConfiguration;
     }
 
     public File getRealmDirectory() {
@@ -150,7 +165,7 @@ public boolean shouldDeleteRealmIfMigrationNeeded() {
         return deleteRealmIfMigrationNeeded;
     }
 
-    public SharedRealm.Durability getDurability() {
+    public OsRealmConfig.Durability getDurability() {
         return durability;
     }
 
@@ -159,7 +174,8 @@ public boolean shouldDeleteRealmIfMigrationNeeded() {
      *
      * @return the mediator of the schema.
      */
-    RealmProxyMediator getSchemaMediator() {
+    // Protected for testing with mockito.
+    protected RealmProxyMediator getSchemaMediator() {
         return schemaMediator;
     }
 
@@ -178,17 +194,27 @@ RealmProxyMediator getSchemaMediator() {
      * @return {@code true} if there is asset file, {@code false} otherwise.
      */
     boolean hasAssetFile() {
-        return !TextUtils.isEmpty(assetFilePath);
+        return !Util.isEmptyString(assetFilePath);
     }
 
     /**
-     * Returns input stream object to the Realm asset file.
+     * Returns the path to the Realm asset file.
      *
-     * @return input stream to the asset file.
-     * @throws IOException if copying the file fails.
+     * @return path to the asset file relative to the asset directory.
      */
-    InputStream getAssetFile() throws IOException {
-        return BaseRealm.applicationContext.getAssets().open(assetFilePath);
+    String getAssetFilePath() {
+        return assetFilePath;
+    }
+
+    /**
+     * Returns a callback to determine if the Realm file should be compacted before being returned to the user.
+     *
+     * @return a callback called when opening a Realm for the first time during the life of a process to determine if
+     * it should be compacted before being returned to the user. It is passed the total file size (data + free space)
+     * and the total bytes used by data in the file.
+     */
+    public CompactOnLaunchCallback getCompactOnLaunchCallback() {
+        return compactOnLaunch;
     }
 
     /**
@@ -200,10 +226,27 @@ InputStream getAssetFile() throws IOException {
         return schemaMediator.getModelClasses();
     }
 
+    /**
+     * Returns the absolute path to where the Realm file will be saved.
+     *
+     * @return the absolute path to the Realm file defined by this configuration.
+     */
     public String getPath() {
         return canonicalPath;
     }
 
+    /**
+     * Checks if the Realm file defined by this configuration already exists.
+     * <p>
+     * WARNING: This method is just a point-in-time check. Unless protected by external synchronization another
+     * thread or process might have created or deleted the Realm file right after this method has returned.
+     *
+     * @return {@code true} if the Realm file exists, {@code false} otherwise.
+     */
+    boolean realmExists() {
+        return new File(canonicalPath).exists();
+    }
+
     /**
      * Returns the {@link RxObservableFactory} that is used to create Rx Observables from Realm objects.
      *
@@ -220,6 +263,24 @@ public RxObservableFactory getRxFactory() {
         return rxObservableFactory;
     }
 
+    /**
+     * Returns whether this Realm is read-only or not. Read-only Realms cannot be modified and will throw an
+     * {@link IllegalStateException} if {@link Realm#beginTransaction()} is called on it.
+     *
+     * @return {@code true} if this Realm is read only, {@code false} if not.
+     */
+    public boolean isReadOnly() {
+        return readOnly;
+    }
+
+    /**
+     * @return {@code true} if this configuration is intended to open a backup Realm (as a result of a client reset).
+     * @see <a href="https://realm.io/docs/java/latest/api/io/realm/ClientResetRequiredError.html">ClientResetRequiredError</a>
+     */
+    public boolean isRecoveryConfiguration() {
+        return isRecoveryConfiguration;
+    }
+
     @Override
     public boolean equals(Object obj) {
         if (this == obj) { return true; }
@@ -229,38 +290,50 @@ public boolean equals(Object obj) {
 
         if (schemaVersion != that.schemaVersion) { return false; }
         if (deleteRealmIfMigrationNeeded != that.deleteRealmIfMigrationNeeded) { return false; }
-        if (!realmDirectory.equals(that.realmDirectory)) { return false; }
-        if (!realmFileName.equals(that.realmFileName)) { return false; }
+        if (readOnly != that.readOnly) { return false; }
+        if (isRecoveryConfiguration != that.isRecoveryConfiguration) { return false; }
+        if (realmDirectory != null ? !realmDirectory.equals(that.realmDirectory) : that.realmDirectory != null) {
+            return false;
+        }
+        if (realmFileName != null ? !realmFileName.equals(that.realmFileName) : that.realmFileName != null) {
+            return false;
+        }
         if (!canonicalPath.equals(that.canonicalPath)) { return false; }
+        if (assetFilePath != null ? !assetFilePath.equals(that.assetFilePath) : that.assetFilePath != null) {
+            return false;
+        }
         if (!Arrays.equals(key, that.key)) { return false; }
-        if (!durability.equals(that.durability)) { return false; }
-        if (migration != null ? !migration.equals(that.migration) : that.migration != null) { return false; }
-        //noinspection SimplifiableIfStatement
+        if (migration != null ? !migration.equals(that.migration) : that.migration != null) {
+            return false;
+        }
+        if (durability != that.durability) { return false; }
+        if (!schemaMediator.equals(that.schemaMediator)) { return false; }
         if (rxObservableFactory != null ? !rxObservableFactory.equals(that.rxObservableFactory) : that.rxObservableFactory != null) {
             return false;
         }
         if (initialDataTransaction != null ? !initialDataTransaction.equals(that.initialDataTransaction) : that.initialDataTransaction != null) {
             return false;
         }
-
-        return schemaMediator.equals(that.schemaMediator);
+        return compactOnLaunch != null ? compactOnLaunch.equals(that.compactOnLaunch) : that.compactOnLaunch == null;
     }
 
-
     @Override
     public int hashCode() {
-        int result = realmDirectory.hashCode();
-        result = 31 * result + realmFileName.hashCode();
+        int result = realmDirectory != null ? realmDirectory.hashCode() : 0;
+        result = 31 * result + (realmFileName != null ? realmFileName.hashCode() : 0);
         result = 31 * result + canonicalPath.hashCode();
-        result = 31 * result + (key != null ? Arrays.hashCode(key) : 0);
-        result = 31 * result + (int) schemaVersion;
+        result = 31 * result + (assetFilePath != null ? assetFilePath.hashCode() : 0);
+        result = 31 * result + Arrays.hashCode(key);
+        result = 31 * result + (int) (schemaVersion ^ (schemaVersion >>> 32));
         result = 31 * result + (migration != null ? migration.hashCode() : 0);
         result = 31 * result + (deleteRealmIfMigrationNeeded ? 1 : 0);
-        result = 31 * result + schemaMediator.hashCode();
         result = 31 * result + durability.hashCode();
+        result = 31 * result + schemaMediator.hashCode();
         result = 31 * result + (rxObservableFactory != null ? rxObservableFactory.hashCode() : 0);
         result = 31 * result + (initialDataTransaction != null ? initialDataTransaction.hashCode() : 0);
-
+        result = 31 * result + (readOnly ? 1 : 0);
+        result = 31 * result + (compactOnLaunch != null ? compactOnLaunch.hashCode() : 0);
+        result = 31 * result + (isRecoveryConfiguration ? 1 : 0);
         return result;
     }
 
@@ -292,7 +365,7 @@ protected static RealmProxyMediator createSchemaMediator(Set<Object> modules,
     private static RealmProxyMediator getModuleMediator(String fullyQualifiedModuleClassName) {
         String[] moduleNameParts = fullyQualifiedModuleClassName.split("\\.");
         String moduleSimpleName = moduleNameParts[moduleNameParts.length - 1];
-        String mediatorName = String.format("io.realm.%s%s", moduleSimpleName, "Mediator");
+        String mediatorName = String.format(Locale.US, "io.realm.%s%s", moduleSimpleName, "Mediator");
         Class<?> clazz;
         //noinspection TryWithIdenticalCatches
         try {
@@ -315,7 +388,7 @@ private static RealmProxyMediator getModuleMediator(String fullyQualifiedModuleC
     public String toString() {
         //noinspection StringBufferReplaceableByString
         StringBuilder stringBuilder = new StringBuilder();
-        stringBuilder.append("realmDirectory: ").append(realmDirectory.toString());
+        stringBuilder.append("realmDirectory: ").append(realmDirectory != null ? realmDirectory.toString() : "");
         stringBuilder.append("\n");
         stringBuilder.append("realmFileName : ").append(realmFileName);
         stringBuilder.append("\n");
@@ -332,6 +405,10 @@ public String toString() {
         stringBuilder.append("durability: ").append(durability);
         stringBuilder.append("\n");
         stringBuilder.append("schemaMediator: ").append(schemaMediator);
+        stringBuilder.append("\n");
+        stringBuilder.append("readOnly: ").append(readOnly);
+        stringBuilder.append("\n");
+        stringBuilder.append("compactOnLaunch: ").append(compactOnLaunch);
 
         return stringBuilder.toString();
     }
@@ -345,7 +422,7 @@ public String toString() {
     static synchronized boolean isRxJavaAvailable() {
         if (rxJavaAvailable == null) {
             try {
-                Class.forName("rx.Observable");
+                Class.forName("io.reactivex.Flowable");
                 rxJavaAvailable = true;
             } catch (ClassNotFoundException ignore) {
                 rxJavaAvailable = false;
@@ -382,11 +459,13 @@ boolean isSyncConfiguration() {
         private long schemaVersion;
         private RealmMigration migration;
         private boolean deleteRealmIfMigrationNeeded;
-        private SharedRealm.Durability durability;
+        private OsRealmConfig.Durability durability;
         private HashSet<Object> modules = new HashSet<Object>();
         private HashSet<Class<? extends RealmModel>> debugSchema = new HashSet<Class<? extends RealmModel>>();
         private RxObservableFactory rxFactory;
         private Realm.Transaction initialDataTransaction;
+        private boolean readOnly;
+        private CompactOnLaunchCallback compactOnLaunch;
 
         /**
          * Creates an instance of the Builder for the RealmConfiguration.
@@ -400,6 +479,7 @@ public Builder() {
         }
 
         Builder(Context context) {
+            //noinspection ConstantConditions
             if (context == null) {
                 throw new IllegalStateException("Call `Realm.init(Context)` before creating a RealmConfiguration");
             }
@@ -415,7 +495,9 @@ private void initializeBuilder(Context context) {
             this.schemaVersion = 0;
             this.migration = null;
             this.deleteRealmIfMigrationNeeded = false;
-            this.durability = SharedRealm.Durability.FULL;
+            this.durability = OsRealmConfig.Durability.FULL;
+            this.readOnly = false;
+            this.compactOnLaunch = null;
             if (DEFAULT_MODULE != null) {
                 this.modules.add(DEFAULT_MODULE);
             }
@@ -425,6 +507,7 @@ private void initializeBuilder(Context context) {
          * Sets the filename for the Realm file.
          */
         public Builder name(String filename) {
+            //noinspection ConstantConditions
             if (filename == null || filename.isEmpty()) {
                 throw new IllegalArgumentException("A non-empty filename must be provided");
             }
@@ -441,6 +524,7 @@ public Builder name(String filename) {
          * @throws IllegalArgumentException if {@code directory} is null, not writable or a file.
          */
         public Builder directory(File directory) {
+            //noinspection ConstantConditions
             if (directory == null) {
                 throw new IllegalArgumentException("Non-null 'dir' required.");
             }
@@ -462,11 +546,13 @@ public Builder directory(File directory) {
          * Sets the {@value io.realm.RealmConfiguration#KEY_LENGTH} bytes key used to encrypt and decrypt the Realm file.
          */
         public Builder encryptionKey(byte[] key) {
+            //noinspection ConstantConditions
             if (key == null) {
                 throw new IllegalArgumentException("A non-null key must be provided");
             }
             if (key.length != KEY_LENGTH) {
-                throw new IllegalArgumentException(String.format("The provided key must be %s bytes. Yours was: %s",
+                throw new IllegalArgumentException(String.format(Locale.US,
+                        "The provided key must be %s bytes. Yours was: %s",
                         KEY_LENGTH, key.length));
             }
             this.key = Arrays.copyOf(key, key.length);
@@ -496,6 +582,7 @@ public Builder schemaVersion(long schemaVersion) {
          * will be thrown.
          */
         public Builder migration(RealmMigration migration) {
+            //noinspection ConstantConditions
             if (migration == null) {
                 throw new IllegalArgumentException("A non-null migration must be provided");
             }
@@ -533,11 +620,11 @@ public Builder deleteRealmIfMigrationNeeded() {
          * reference to the in-memory Realm object with the specific name as long as you want the data to last.
          */
         public Builder inMemory() {
-            if (!TextUtils.isEmpty(assetFilePath)) {
+            if (!Util.isEmptyString(assetFilePath)) {
                 throw new RealmException("Realm can not use in-memory configuration if asset file is present.");
             }
 
-            this.durability = SharedRealm.Durability.MEM_ONLY;
+            this.durability = OsRealmConfig.Durability.MEM_ONLY;
 
             return this;
         }
@@ -561,6 +648,7 @@ public Builder inMemory() {
         public Builder modules(Object baseModule, Object... additionalModules) {
             modules.clear();
             addModule(baseModule);
+            //noinspection ConstantConditions
             if (additionalModules != null) {
                 for (int i = 0; i < additionalModules.length; i++) {
                     Object module = additionalModules[i];
@@ -598,32 +686,71 @@ public Builder initialData(Realm.Transaction transaction) {
          * When opening the Realm for the first time, instead of creating an empty file,
          * the Realm file will be copied from the provided asset file and used instead.
          * <p>
-         * <p>This cannot be configured to clear and recreate schema by calling {@link #deleteRealmIfMigrationNeeded()}
-         * at the same time as doing so will delete the copied asset schema.
-         * <p>
+         * This cannot be combined with {@link #deleteRealmIfMigrationNeeded()} as doing so would just result in the
+         * copied file being deleted.
          * <p>
          * WARNING: This could potentially be a lengthy operation and should ideally be done on a background thread.
          *
          * @param assetFile path to the asset database file.
          * @throws IllegalStateException if this is configured to clear its schema by calling {@link #deleteRealmIfMigrationNeeded()}.
          */
-        public Builder assetFile(final String assetFile) {
-            if (TextUtils.isEmpty(assetFile)) {
+        public Builder assetFile(String assetFile) {
+            if (Util.isEmptyString(assetFile)) {
                 throw new IllegalArgumentException("A non-empty asset file path must be provided");
             }
-            if (durability == SharedRealm.Durability.MEM_ONLY) {
+            if (durability == OsRealmConfig.Durability.MEM_ONLY) {
                 throw new RealmException("Realm can not use in-memory configuration if asset file is present.");
             }
             if (this.deleteRealmIfMigrationNeeded) {
                 throw new IllegalStateException("Realm cannot use an asset file when previously configured to clear its schema in migration by calling deleteRealmIfMigrationNeeded().");
             }
-
             this.assetFilePath = assetFile;
 
             return this;
         }
 
+        /**
+         * Setting this will cause the Realm to become read only and all write transactions made against this Realm will
+         * fail with an {@link IllegalStateException}.
+         * <p>
+         * This in particular mean that {@link #initialData(Realm.Transaction)} will not work in combination with a
+         * read only Realm and setting this will result in a {@link IllegalStateException} being thrown.
+         * </p>
+         * Marking a Realm as read only only applies to the Realm in this process. Other processes can still
+         * write to the Realm.
+         */
+        public Builder readOnly() {
+            this.readOnly = true;
+            return this;
+        }
+
+        /**
+         * Setting this will cause Realm to compact the Realm file if the Realm file has grown too large and a
+         * significant amount of space can be recovered. See {@link DefaultCompactOnLaunchCallback} for details.
+         */
+        public Builder compactOnLaunch() {
+            return compactOnLaunch(new DefaultCompactOnLaunchCallback());
+        }
+
+        /**
+         * Sets this to determine if the Realm file should be compacted before returned to the user. It is passed the
+         * total file size (data + free space) and the bytes used by data in the file.
+         *
+         * @param compactOnLaunch a callback called when opening a Realm for the first time during the life of a process
+         *                        to determine if it should be compacted before being returned to the user. It is passed
+         *                        the total file size (data + free space) and the bytes used by data in the file.
+         */
+        public Builder compactOnLaunch(CompactOnLaunchCallback compactOnLaunch) {
+            //noinspection ConstantConditions
+            if (compactOnLaunch == null) {
+                throw new IllegalArgumentException("A non-null compactOnLaunch must be provided");
+            }
+            this.compactOnLaunch = compactOnLaunch;
+            return this;
+        }
+
         private void addModule(Object module) {
+            //noinspection ConstantConditions
             if (module != null) {
                 checkModule(module);
                 modules.add(module);
@@ -635,13 +762,15 @@ private void addModule(Object module) {
          * create a module. These classes must be available in the default module. Calling this will remove any
          * previously configured modules.
          */
-        Builder schema(Class<? extends RealmModel> firstClass, Class<? extends RealmModel>... additionalClasses) {
+        final Builder schema(Class<? extends RealmModel> firstClass, Class<? extends RealmModel>... additionalClasses) {
+            //noinspection ConstantConditions
             if (firstClass == null) {
                 throw new IllegalArgumentException("A non-null class must be provided");
             }
             modules.clear();
             modules.add(DEFAULT_MODULE_MEDIATOR);
             debugSchema.add(firstClass);
+            //noinspection ConstantConditions
             if (additionalClasses != null) {
                 Collections.addAll(debugSchema, additionalClasses);
             }
@@ -655,6 +784,23 @@ Builder schema(Class<? extends RealmModel> firstClass, Class<? extends RealmMode
          * @return the created {@link RealmConfiguration}.
          */
         public RealmConfiguration build() {
+            // Check that readOnly() was applied to legal configuration. Right now it should only be allowed if
+            // an assetFile is configured
+            if (readOnly) {
+                if (initialDataTransaction != null) {
+                    throw new IllegalStateException("This Realm is marked as read-only. Read-only Realms cannot use initialData(Realm.Transaction).");
+                }
+                if (assetFilePath == null) {
+                    throw new IllegalStateException("Only Realms provided using 'assetFile(path)' can be marked read-only. No such Realm was provided.");
+                }
+                if (deleteRealmIfMigrationNeeded) {
+                    throw new IllegalStateException("'deleteRealmIfMigrationNeeded()' and read-only Realms cannot be combined");
+                }
+                if (compactOnLaunch != null) {
+                    throw new IllegalStateException("'compactOnLaunch()' and read-only Realms cannot be combined");
+                }
+            }
+
             if (rxFactory == null && isRxJavaAvailable()) {
                 rxFactory = new RealmObservableFactory();
             }
@@ -670,7 +816,10 @@ public RealmConfiguration build() {
                     durability,
                     createSchemaMediator(modules, debugSchema),
                     rxFactory,
-                    initialDataTransaction
+                    initialDataTransaction,
+                    readOnly,
+                    compactOnLaunch,
+                    false
             );
         }
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmFieldType.java b/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
index b66639dc4c..2514255c69 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmFieldType.java
@@ -19,7 +19,44 @@
 import java.nio.ByteBuffer;
 
 import io.realm.internal.Keep;
+import io.realm.internal.Property;
 
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_BINARY;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_BOOLEAN;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_DATE;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_DOUBLE;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_FLOAT;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_INTEGER;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_LINKING_OBJECTS;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_LIST;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_OBJECT;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_STRING;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_UNSUPPORTED_DATE;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_UNSUPPORTED_MIXED;
+import static io.realm.RealmFieldTypeConstants.CORE_TYPE_VALUE_UNSUPPORTED_TABLE;
+import static io.realm.RealmFieldTypeConstants.LIST_OFFSET;
+import static io.realm.RealmFieldTypeConstants.MAX_CORE_TYPE_VALUE;
+
+
+interface RealmFieldTypeConstants {
+    int LIST_OFFSET = Property.TYPE_ARRAY;
+
+    int CORE_TYPE_VALUE_INTEGER = 0;
+    int CORE_TYPE_VALUE_BOOLEAN = 1;
+    int CORE_TYPE_VALUE_STRING = 2;
+    int CORE_TYPE_VALUE_BINARY = 4;
+    int CORE_TYPE_VALUE_UNSUPPORTED_TABLE = 5;
+    int CORE_TYPE_VALUE_UNSUPPORTED_MIXED = 6;
+    int CORE_TYPE_VALUE_UNSUPPORTED_DATE = 7;
+    int CORE_TYPE_VALUE_DATE = 8;
+    int CORE_TYPE_VALUE_FLOAT = 9;
+    int CORE_TYPE_VALUE_DOUBLE = 10;
+    int CORE_TYPE_VALUE_OBJECT = 12;
+    int CORE_TYPE_VALUE_LIST = 13;
+    int CORE_TYPE_VALUE_LINKING_OBJECTS = 14;
+
+    int MAX_CORE_TYPE_VALUE = CORE_TYPE_VALUE_LINKING_OBJECTS;
+}
 
 /**
  * List of the types used by Realm's underlying storage engine.
@@ -31,28 +68,38 @@
 @Keep
 public enum RealmFieldType {
     // Makes sure numbers match with <realm/column_type.hpp>.
-    INTEGER(0),
-    BOOLEAN(1),
-    STRING(2),
-    BINARY(4),
-    UNSUPPORTED_TABLE(5),
-    UNSUPPORTED_MIXED(6),
-    UNSUPPORTED_DATE(7),
-    DATE(8),
-    FLOAT(9),
-    DOUBLE(10),
-    OBJECT(12),
-    LIST(13);
-    // BACKLINK(14); Not exposed until needed.
+    INTEGER(CORE_TYPE_VALUE_INTEGER),
+    BOOLEAN(CORE_TYPE_VALUE_BOOLEAN),
+    STRING(CORE_TYPE_VALUE_STRING),
+    BINARY(CORE_TYPE_VALUE_BINARY),
+    DATE(CORE_TYPE_VALUE_DATE),
+    FLOAT(CORE_TYPE_VALUE_FLOAT),
+    DOUBLE(CORE_TYPE_VALUE_DOUBLE),
+    OBJECT(CORE_TYPE_VALUE_OBJECT),
+
+    LIST(CORE_TYPE_VALUE_LIST),
+    LINKING_OBJECTS(CORE_TYPE_VALUE_LINKING_OBJECTS),
+
+    INTEGER_LIST(CORE_TYPE_VALUE_INTEGER + LIST_OFFSET),
+    BOOLEAN_LIST(CORE_TYPE_VALUE_BOOLEAN + LIST_OFFSET),
+    STRING_LIST(CORE_TYPE_VALUE_STRING + LIST_OFFSET),
+    BINARY_LIST(CORE_TYPE_VALUE_BINARY + LIST_OFFSET),
+    DATE_LIST(CORE_TYPE_VALUE_DATE + LIST_OFFSET),
+    FLOAT_LIST(CORE_TYPE_VALUE_FLOAT + LIST_OFFSET),
+    DOUBLE_LIST(CORE_TYPE_VALUE_DOUBLE + LIST_OFFSET);
 
     // Primitive array for fast mapping between between native values and their Realm type.
-    private static RealmFieldType[] typeList = new RealmFieldType[15];
+    private static final RealmFieldType[] basicTypes = new RealmFieldType[MAX_CORE_TYPE_VALUE + 1];
+    private static final RealmFieldType[] listTypes = new RealmFieldType[MAX_CORE_TYPE_VALUE + 1];
 
     static {
-        RealmFieldType[] columnTypes = values();
-        for (int i = 0; i < columnTypes.length; i++) {
-            int v = columnTypes[i].nativeValue;
-            typeList[v] = columnTypes[i];
+        for (RealmFieldType columnType : values()) {
+            final int nativeValue = columnType.nativeValue;
+            if (nativeValue < LIST_OFFSET) {
+                basicTypes[nativeValue] = columnType;
+            } else {
+                listTypes[nativeValue - LIST_OFFSET] = columnType;
+            }
         }
     }
 
@@ -79,29 +126,39 @@ public int getNativeValue() {
      */
     public boolean isValid(Object obj) {
         switch (nativeValue) {
-            case 0:
+            case CORE_TYPE_VALUE_INTEGER:
                 return (obj instanceof Long || obj instanceof Integer || obj instanceof Short || obj instanceof Byte);
-            case 1:
+            case CORE_TYPE_VALUE_BOOLEAN:
                 return (obj instanceof Boolean);
-            case 2:
+            case CORE_TYPE_VALUE_STRING:
                 return (obj instanceof String);
-            case 4:
+            case CORE_TYPE_VALUE_BINARY:
                 return (obj instanceof byte[] || obj instanceof ByteBuffer);
-            case 5:
-                return (obj == null || obj instanceof Object[][]);
-            case 7:
-                return (obj instanceof java.util.Date); // The unused DateTime.
-            case 8:
+            case CORE_TYPE_VALUE_DATE:
                 return (obj instanceof java.util.Date);
-            case 9:
+            case CORE_TYPE_VALUE_FLOAT:
                 return (obj instanceof Float);
-            case 10:
+            case CORE_TYPE_VALUE_DOUBLE:
                 return (obj instanceof Double);
-            case 12:
+            case CORE_TYPE_VALUE_OBJECT:
+                return false;
+            case CORE_TYPE_VALUE_LIST:
                 return false;
-            case 13:
+            case CORE_TYPE_VALUE_LINKING_OBJECTS:
                 return false;
-            case 14:
+            case CORE_TYPE_VALUE_INTEGER + LIST_OFFSET:
+                return false;
+            case CORE_TYPE_VALUE_BOOLEAN + LIST_OFFSET:
+                return false;
+            case CORE_TYPE_VALUE_STRING + LIST_OFFSET:
+                return false;
+            case CORE_TYPE_VALUE_BINARY + LIST_OFFSET:
+                return false;
+            case CORE_TYPE_VALUE_DATE + LIST_OFFSET:
+                return false;
+            case CORE_TYPE_VALUE_FLOAT + LIST_OFFSET:
+                return false;
+            case CORE_TYPE_VALUE_DOUBLE + LIST_OFFSET:
                 return false;
             default:
                 throw new RuntimeException("Unsupported Realm type:  " + this);
@@ -116,12 +173,21 @@ public boolean isValid(Object obj) {
      * @throws IllegalArgumentException if value isn't valid.
      */
     public static RealmFieldType fromNativeValue(int value) {
-        if (0 <= value && value < typeList.length) {
-            RealmFieldType e = typeList[value];
+        if (0 <= value && value < basicTypes.length) {
+            RealmFieldType e = basicTypes[value];
             if (e != null) {
                 return e;
             }
         }
+        if (LIST_OFFSET <= value) {
+            final int elementValue = value - LIST_OFFSET;
+            if (elementValue < listTypes.length) {
+                RealmFieldType e = listTypes[elementValue];
+                if (e != null) {
+                    return e;
+                }
+            }
+        }
         throw new IllegalArgumentException("Invalid native Realm type: " + value);
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index ec33d39900..267d9aff0b 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -25,12 +25,20 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;
+import java.util.Locale;
 import java.util.NoSuchElementException;
 
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+import io.reactivex.Flowable;
+import io.reactivex.Observable;
 import io.realm.internal.InvalidRow;
-import io.realm.internal.LinkView;
+import io.realm.internal.OsList;
+import io.realm.internal.OsObjectStore;
+import io.realm.internal.OsResults;
 import io.realm.internal.RealmObjectProxy;
-import rx.Observable;
+import io.realm.rx.CollectionChange;
 
 
 /**
@@ -51,18 +59,23 @@
  * @param <E> the class of objects in list.
  */
 
-public class RealmList<E extends RealmModel> extends AbstractList<E> implements OrderedRealmCollection<E> {
+public class RealmList<E> extends AbstractList<E> implements OrderedRealmCollection<E> {
 
-    private static final String ONLY_IN_MANAGED_MODE_MESSAGE = "This method is only available in managed mode";
-    private static final String NULL_OBJECTS_NOT_ALLOWED_MESSAGE = "RealmList does not accept null values";
-    public static final String REMOVE_OUTSIDE_TRANSACTION_ERROR = "Objects can only be removed from inside a write transaction";
+    private static final String ONLY_IN_MANAGED_MODE_MESSAGE = "This method is only available in managed mode.";
+    static final String ALLOWED_ONLY_FOR_REALM_MODEL_ELEMENT_MESSAGE = "This feature is available only when the element type is implementing RealmModel.";
+    public static final String REMOVE_OUTSIDE_TRANSACTION_ERROR = "Objects can only be removed from inside a write transaction.";
 
-    private final io.realm.internal.Collection collection;
+    @Nullable
     protected Class<E> clazz;
+    @Nullable
     protected String className;
-    final LinkView view;
-    protected BaseRealm realm;
+
+    // Always null if RealmList is unmanaged, always non-null if managed.
+    final ManagedListOperator<E> osListOperator;
+    final protected BaseRealm realm;
     private List<E> unmanagedList;
+    // Used for listeners on RealmList<RealmModel>
+    private OsResults osResults;
 
     /**
      * Creates a RealmList in unmanaged mode, where the elements are not controlled by a Realm.
@@ -72,8 +85,8 @@
      * Use {@link io.realm.Realm#copyToRealm(Iterable)} to properly persist its elements in Realm.
      */
     public RealmList() {
-        collection = null;
-        view = null;
+        realm = null;
+        osListOperator = null;
         unmanagedList = new ArrayList<>();
     }
 
@@ -87,34 +100,37 @@ public RealmList() {
      * @param objects initial objects in the list.
      */
     public RealmList(E... objects) {
+        //noinspection ConstantConditions
         if (objects == null) {
             throw new IllegalArgumentException("The objects argument cannot be null");
         }
-        collection = null;
-        view = null;
+        realm = null;
+        osListOperator = null;
         unmanagedList = new ArrayList<>(objects.length);
         Collections.addAll(unmanagedList, objects);
     }
 
     /**
-     * Creates a RealmList from a LinkView, so its elements are managed by Realm.
+     * Creates a RealmList from a OsList, so its elements are managed by Realm.
      *
      * @param clazz type of elements in the Array.
-     * @param linkView backing LinkView.
+     * @param osList backing {@link OsList}.
      * @param realm reference to Realm containing the data.
      */
-    RealmList(Class<E> clazz, LinkView linkView, BaseRealm realm) {
-        this.collection = new io.realm.internal.Collection(realm.sharedRealm, linkView, null);
+    RealmList(Class<E> clazz, OsList osList, BaseRealm realm) {
         this.clazz = clazz;
-        this.view = linkView;
+        osListOperator = getOperator(realm, osList, clazz, null);
         this.realm = realm;
     }
 
-    RealmList(String className, LinkView linkView, BaseRealm realm) {
-        this.collection = new io.realm.internal.Collection(realm.sharedRealm, linkView, null);
-        this.view = linkView;
+    RealmList(String className, OsList osList, BaseRealm realm) {
         this.realm = realm;
         this.className = className;
+        osListOperator = getOperator(realm, osList, null, className);
+    }
+
+    OsList getOsList() {
+        return osListOperator.getOsList();
     }
 
     /**
@@ -141,7 +157,7 @@ public boolean isManaged() {
     }
 
     private boolean isAttached() {
-        return view != null && view.isAttached();
+        return osListOperator != null && osListOperator.isValid();
     }
 
     /**
@@ -158,22 +174,18 @@ private boolean isAttached() {
      * </ol>
      *
      * @param location the index at which to insert.
-     * @param object the object to add.
+     * @param element the element to add.
      * @throws IllegalStateException if Realm instance has been closed or container object has been removed.
      * @throws IndexOutOfBoundsException if {@code location < 0 || location > size()}.
      */
     @Override
-    public void add(int location, E object) {
-        checkValidObject(object);
+    public void add(int location, @Nullable E element) {
+        //noinspection ConstantConditions
         if (isManaged()) {
-            checkValidView();
-            if (location < 0 || location > size()) {
-                throw new IndexOutOfBoundsException("Invalid index " + location + ", size is " + size());
-            }
-            RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded(object);
-            view.insert(location, proxy.realmGet$proxyState().getRow$realm().getIndex());
+            checkValidRealm();
+            osListOperator.insert(location, element);
         } else {
-            unmanagedList.add(location, object);
+            unmanagedList.add(location, element);
         }
         modCount++;
     }
@@ -194,12 +206,10 @@ public void add(int location, E object) {
      * @throws IllegalStateException if Realm instance has been closed or parent object has been removed.
      */
     @Override
-    public boolean add(E object) {
-        checkValidObject(object);
+    public boolean add(@Nullable E object) {
         if (isManaged()) {
-            checkValidView();
-            RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded(object);
-            view.add(proxy.realmGet$proxyState().getRow$realm().getIndex());
+            checkValidRealm();
+            osListOperator.append(object);
         } else {
             unmanagedList.add(object);
         }
@@ -225,66 +235,17 @@ public boolean add(E object) {
      * @throws IndexOutOfBoundsException if {@code location < 0 || location >= size()}.
      */
     @Override
-    public E set(int location, E object) {
-        checkValidObject(object);
+    public E set(int location, @Nullable E object) {
         E oldObject;
         if (isManaged()) {
-            checkValidView();
-            RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded(object);
-            oldObject = get(location);
-            view.set(location, proxy.realmGet$proxyState().getRow$realm().getIndex());
-            return oldObject;
+            checkValidRealm();
+            oldObject = osListOperator.set(location, object);
         } else {
             oldObject = unmanagedList.set(location, object);
         }
         return oldObject;
     }
 
-    // Transparently copies an unmanaged object or managed object from another Realm to the Realm backing this RealmList.
-    private E copyToRealmIfNeeded(E object) {
-        if (object instanceof RealmObjectProxy) {
-            RealmObjectProxy proxy = (RealmObjectProxy) object;
-
-            if (proxy instanceof DynamicRealmObject) {
-                String listClassName = StandardRealmSchema.getSchemaForTable(view.getTargetTable());
-                if (proxy.realmGet$proxyState().getRealm$realm() == realm) {
-                    String objectClassName = ((DynamicRealmObject) object).getType();
-                    if (listClassName.equals(objectClassName)) {
-                        // Same Realm instance and same target table
-                        return object;
-                    } else {
-                        // Different target table
-                        throw new IllegalArgumentException(String.format("The object has a different type from list's." +
-                                " Type of the list is '%s', type of object is '%s'.", listClassName, objectClassName));
-                    }
-                } else if (realm.threadId == proxy.realmGet$proxyState().getRealm$realm().threadId) {
-                    // We don't support moving DynamicRealmObjects across Realms automatically. The overhead is too big as
-                    // you have to run a full schema validation for each object.
-                    // And copying from another Realm instance pointed to the same Realm file is not supported as well.
-                    throw new IllegalArgumentException("Cannot copy DynamicRealmObject between Realm instances.");
-                } else {
-                    throw new IllegalStateException("Cannot copy an object to a Realm instance created in another thread.");
-                }
-            } else {
-                // Object is already in this realm
-                if (proxy.realmGet$proxyState().getRow$realm() != null && proxy.realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
-                    if (realm != proxy.realmGet$proxyState().getRealm$realm()) {
-                        throw new IllegalArgumentException("Cannot copy an object from another Realm instance.");
-                    }
-                    return object;
-                }
-            }
-        }
-
-        // At this point the object can only be a typed object, so the backing Realm cannot be a DynamicRealm.
-        Realm realm = (Realm) this.realm;
-        if (realm.getTable(object.getClass()).hasPrimaryKey()) {
-            return realm.copyToRealmOrUpdate(object);
-        } else {
-            return realm.copyToRealm(object);
-        }
-    }
-
     /**
      * Moves an object from one position to another, while maintaining a fixed sized list.
      * RealmObjects will be shifted so no {@code null} values are introduced.
@@ -297,11 +258,16 @@ private E copyToRealmIfNeeded(E object) {
      */
     public void move(int oldPos, int newPos) {
         if (isManaged()) {
-            checkValidView();
-            view.move(oldPos, newPos);
+            checkValidRealm();
+            osListOperator.move(oldPos, newPos);
         } else {
-            checkIndex(oldPos);
-            checkIndex(newPos);
+            final int listSize = unmanagedList.size();
+            if (oldPos < 0 || listSize <= oldPos) {
+                throw new IndexOutOfBoundsException("Invalid index " + oldPos + ", size is " + listSize);
+            }
+            if (newPos < 0 || listSize <= newPos) {
+                throw new IndexOutOfBoundsException("Invalid index " + newPos + ", size is " + listSize);
+            }
             E object = unmanagedList.remove(oldPos);
             if (newPos > oldPos) {
                 unmanagedList.add(newPos - 1, object);
@@ -322,8 +288,8 @@ public void move(int oldPos, int newPos) {
     @Override
     public void clear() {
         if (isManaged()) {
-            checkValidView();
-            view.clear();
+            checkValidRealm();
+            osListOperator.removeAll();
         } else {
             unmanagedList.clear();
         }
@@ -342,9 +308,9 @@ public void clear() {
     public E remove(int location) {
         E removedItem;
         if (isManaged()) {
-            checkValidView();
+            checkValidRealm();
             removedItem = get(location);
-            view.remove(location);
+            osListOperator.remove(location);
         } else {
             removedItem = unmanagedList.remove(location);
         }
@@ -370,7 +336,7 @@ public E remove(int location) {
      * @throws NullPointerException if {@code object} is {@code null}.
      */
     @Override
-    public boolean remove(Object object) {
+    public boolean remove(@Nullable Object object) {
         if (isManaged() && !realm.isInTransaction()) {
             throw new IllegalStateException(REMOVE_OUTSIDE_TRANSACTION_ERROR);
         }
@@ -407,7 +373,7 @@ public boolean removeAll(Collection<?> collection) {
     @Override
     public boolean deleteFirstFromRealm() {
         if (isManaged()) {
-            if (size() > 0) {
+            if (!osListOperator.isEmpty()) {
                 deleteFromRealm(0);
                 modCount++;
                 return true;
@@ -425,8 +391,8 @@ public boolean deleteFirstFromRealm() {
     @Override
     public boolean deleteLastFromRealm() {
         if (isManaged()) {
-            if (size() > 0) {
-                deleteFromRealm(size() - 1);
+            if (!osListOperator.isEmpty()) {
+                osListOperator.deleteLast();
                 modCount++;
                 return true;
             } else {
@@ -446,11 +412,11 @@ public boolean deleteLastFromRealm() {
      * @throws IndexOutOfBoundsException if {@code location < 0 || location >= size()}.
      */
     @Override
+    @Nullable
     public E get(int location) {
         if (isManaged()) {
-            checkValidView();
-            long rowIndex = view.getTargetRowIndex(location);
-            return realm.get(clazz, className, rowIndex);
+            checkValidRealm();
+            return osListOperator.get(location);
         } else {
             return unmanagedList.get(location);
         }
@@ -460,6 +426,7 @@ public E get(int location) {
      * {@inheritDoc}
      */
     @Override
+    @Nullable
     public E first() {
         return firstImpl(true, null);
     }
@@ -468,14 +435,16 @@ public E first() {
      * {@inheritDoc}
      */
     @Override
-    public E first(E defaultValue) {
+    @Nullable
+    public E first(@Nullable E defaultValue) {
         return firstImpl(false, defaultValue);
     }
 
-    private E firstImpl(boolean shouldThrow, E defaultValue) {
+    @Nullable
+    private E firstImpl(boolean shouldThrow, @Nullable E defaultValue) {
         if (isManaged()) {
-            checkValidView();
-            if (!view.isEmpty()) {
+            checkValidRealm();
+            if (!osListOperator.isEmpty()) {
                 return get(0);
             }
         } else if (unmanagedList != null && !unmanagedList.isEmpty()) {
@@ -493,6 +462,7 @@ private E firstImpl(boolean shouldThrow, E defaultValue) {
      * {@inheritDoc}
      */
     @Override
+    @Nullable
     public E last() {
         return lastImpl(true, null);
     }
@@ -501,15 +471,17 @@ public E last() {
      * {@inheritDoc}
      */
     @Override
-    public E last(E defaultValue) {
+    @Nullable
+    public E last(@Nullable E defaultValue) {
         return lastImpl(false, defaultValue);
     }
 
-    private E lastImpl(boolean shouldThrow, E defaultValue) {
+    @Nullable
+    private E lastImpl(boolean shouldThrow, @Nullable E defaultValue) {
         if (isManaged()) {
-            checkValidView();
-            if (!view.isEmpty()) {
-                return get((int) view.size() - 1);
+            checkValidRealm();
+            if (!osListOperator.isEmpty()) {
+                return get(osListOperator.size() - 1);
             }
         } else if (unmanagedList != null && !unmanagedList.isEmpty()) {
             return unmanagedList.get(unmanagedList.size() - 1);
@@ -568,8 +540,8 @@ private E lastImpl(boolean shouldThrow, E defaultValue) {
     @Override
     public void deleteFromRealm(int location) {
         if (isManaged()) {
-            checkValidView();
-            view.removeTargetRow(location);
+            checkValidRealm();
+            osListOperator.delete(location);
             modCount++;
         } else {
             throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
@@ -585,9 +557,8 @@ public void deleteFromRealm(int location) {
     @Override
     public int size() {
         if (isManaged()) {
-            checkValidView();
-            long size = view.size();
-            return size < Integer.MAX_VALUE ? (int) size : Integer.MAX_VALUE;
+            checkValidRealm();
+            return osListOperator.size();
         } else {
             return unmanagedList.size();
         }
@@ -603,7 +574,10 @@ public int size() {
     @Override
     public RealmQuery<E> where() {
         if (isManaged()) {
-            checkValidView();
+            checkValidRealm();
+            if (!osListOperator.forRealmModel()) {
+                throw new UnsupportedOperationException(ALLOWED_ONLY_FOR_REALM_MODEL_ELEMENT_MESSAGE);
+            }
             return RealmQuery.createQueryFromList(this);
         } else {
             throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
@@ -614,24 +588,20 @@ public int size() {
      * {@inheritDoc}
      */
     @Override
+    @Nullable
     public Number min(String fieldName) {
-        if (isManaged()) {
-            return this.where().min(fieldName);
-        } else {
-            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
-        }
+        // where() throws if not managed
+        return where().min(fieldName);
     }
 
     /**
      * {@inheritDoc}
      */
     @Override
+    @Nullable
     public Number max(String fieldName) {
-        if (isManaged()) {
-            return this.where().max(fieldName);
-        } else {
-            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
-        }
+        // where() throws if not managed
+        return this.where().max(fieldName);
     }
 
     /**
@@ -639,11 +609,8 @@ public Number max(String fieldName) {
      */
     @Override
     public Number sum(String fieldName) {
-        if (isManaged()) {
-            return this.where().sum(fieldName);
-        } else {
-            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
-        }
+        // where() throws if not managed
+        return this.where().sum(fieldName);
     }
 
     /**
@@ -651,35 +618,28 @@ public Number sum(String fieldName) {
      */
     @Override
     public double average(String fieldName) {
-        if (isManaged()) {
-            return this.where().average(fieldName);
-        } else {
-            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
-        }
+        // where() throws if not managed
+        return this.where().average(fieldName);
     }
 
     /**
      * {@inheritDoc}
      */
     @Override
+    @Nullable
     public Date maxDate(String fieldName) {
-        if (isManaged()) {
-            return this.where().maximumDate(fieldName);
-        } else {
-            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
-        }
+        // where() throws if not managed
+        return this.where().maximumDate(fieldName);
     }
 
     /**
      * {@inheritDoc}
      */
     @Override
+    @Nullable
     public Date minDate(String fieldName) {
-        if (isManaged()) {
-            return this.where().minimumDate(fieldName);
-        } else {
-            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
-        }
+        // where() throws if not managed
+        return this.where().minimumDate(fieldName);
     }
 
     /**
@@ -688,9 +648,9 @@ public Date minDate(String fieldName) {
     @Override
     public boolean deleteAllFromRealm() {
         if (isManaged()) {
-            checkValidView();
-            if (size() > 0) {
-                view.removeAllTargetRows();
+            checkValidRealm();
+            if (!osListOperator.isEmpty()) {
+                osListOperator.deleteAll();
                 modCount++;
                 return true;
             } else {
@@ -728,7 +688,7 @@ public boolean load() {
      * @return {@code true} if this list contains the specified element otherwise {@code false}.
      */
     @Override
-    public boolean contains(Object object) {
+    public boolean contains(@Nullable Object object) {
         if (isManaged()) {
             realm.checkIfValid();
 
@@ -740,12 +700,7 @@ public boolean contains(Object object) {
                 }
             }
 
-            for (E e : this) {
-                if (e.equals(object)) {
-                    return true;
-                }
-            }
-            return false;
+            return super.contains(object);
         } else {
             return unmanagedList.contains(object);
         }
@@ -755,6 +710,7 @@ public boolean contains(Object object) {
      * {@inheritDoc}
      */
     @Override
+    @Nonnull
     public Iterator<E> iterator() {
         if (isManaged()) {
             return new RealmItr();
@@ -767,6 +723,7 @@ public boolean contains(Object object) {
      * {@inheritDoc}
      */
     @Override
+    @Nonnull
     public ListIterator<E> listIterator() {
         return listIterator(0);
     }
@@ -775,6 +732,7 @@ public boolean contains(Object object) {
      * {@inheritDoc}
      */
     @Override
+    @Nonnull
     public ListIterator<E> listIterator(int location) {
         if (isManaged()) {
             return new RealmListItr(location);
@@ -783,24 +741,8 @@ public boolean contains(Object object) {
         }
     }
 
-    private void checkValidObject(E object) {
-        if (object == null) {
-            throw new IllegalArgumentException(NULL_OBJECTS_NOT_ALLOWED_MESSAGE);
-        }
-    }
-
-    private void checkIndex(int location) {
-        int size = size();
-        if (location < 0 || location >= size) {
-            throw new IndexOutOfBoundsException("Invalid index " + location + ", size is " + size);
-        }
-    }
-
-    private void checkValidView() {
+    private void checkValidRealm() {
         realm.checkIfValid();
-        if (view == null || !view.isAttached()) {
-            throw new IllegalStateException("Realm instance has been closed or this object or its parent has been deleted.");
-        }
     }
 
     /**
@@ -811,55 +753,119 @@ private void checkValidView() {
         if (!isManaged()) {
             throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
         }
-        checkValidView();
+        checkValidRealm();
+        if (!osListOperator.forRealmModel()) {
+            throw new UnsupportedOperationException(ALLOWED_ONLY_FOR_REALM_MODEL_ELEMENT_MESSAGE);
+        }
         if (className != null) {
             return new OrderedRealmCollectionSnapshot<>(
                     realm,
-                    new io.realm.internal.Collection(realm.sharedRealm, view, null),
+                    new OsResults(realm.sharedRealm, osListOperator.getOsList(), null),
                     className);
         } else {
+            // 'clazz' is non-null when 'dynamicClassName' is null.
+            //noinspection ConstantConditions
             return new OrderedRealmCollectionSnapshot<>(
                     realm,
-                    new io.realm.internal.Collection(realm.sharedRealm, view, null),
+                    new OsResults(realm.sharedRealm, osListOperator.getOsList(), null),
                     clazz);
         }
     }
 
     @Override
     public String toString() {
-        StringBuilder sb = new StringBuilder();
-        sb.append(isManaged() ? clazz.getSimpleName() : getClass().getSimpleName());
-        sb.append("@[");
-        if (isManaged() && !isAttached()) {
-            sb.append("invalid");
+        final String separator = ",";
+        final StringBuilder sb = new StringBuilder();
+
+        if (!isManaged()) {
+            // Build String for unmanaged RealmList
+
+            // Unmanaged RealmList does not know actual element type.
+            sb.append("RealmList<?>@[");
+            // Print list values
+            final int size = size();
+            for (int i = 0; i < size; i++) {
+                final E value = get(i);
+                if (value instanceof RealmModel) {
+                    sb.append(System.identityHashCode(value));
+                } else {
+                    if (value instanceof byte[]) {
+                        sb.append("byte[").append(((byte[]) value).length).append("]");
+                    } else {
+                        sb.append(value);
+                    }
+                }
+                sb.append(separator);
+            }
+            if (0 < size()) {
+                sb.setLength(sb.length() - separator.length());
+            }
+            sb.append("]");
         } else {
-            for (int i = 0; i < size(); i++) {
-                if (isManaged()) {
-                    sb.append(((RealmObjectProxy) get(i)).realmGet$proxyState().getRow$realm().getIndex());
+            // Build String for managed RealmList
+
+            // Determines type of List
+            sb.append("RealmList<");
+            if (className != null) {
+                sb.append(className);
+            } else {
+                // 'clazz' is non-null when 'dynamicClassName' is null.
+                //noinspection ConstantConditions,unchecked
+                if (isClassForRealmModel(clazz)) {
+                    //noinspection ConstantConditions,unchecked
+                    sb.append(realm.getSchema().getSchemaForClass((Class<RealmModel>) clazz).getClassName());
                 } else {
-                    sb.append(System.identityHashCode(get(i)));
+                    if (clazz == byte[].class) {
+                        sb.append(clazz.getSimpleName());
+                    } else {
+                        sb.append(clazz.getName());
+                    }
+                }
+            }
+            sb.append(">@[");
+
+            //Print list values
+            if (!isAttached()) {
+                sb.append("invalid");
+            } else if (isClassForRealmModel(clazz)) {
+                for (int i = 0; i < size(); i++) {
+                    //noinspection ConstantConditions
+                    sb.append(((RealmObjectProxy) get(i)).realmGet$proxyState().getRow$realm().getIndex());
+                    sb.append(separator);
+                }
+                if (0 < size()) {
+                    sb.setLength(sb.length() - separator.length());
+                }
+            } else {
+                for (int i = 0; i < size(); i++) {
+                    final E value = get(i);
+                    if (value instanceof byte[]) {
+                        sb.append("byte[").append(((byte[]) value).length).append("]");
+                    } else {
+                        sb.append(value);
+                    }
+                    sb.append(separator);
                 }
-                if (i < size() - 1) {
-                    sb.append(',');
+                if (0 < size()) {
+                    sb.setLength(sb.length() - separator.length());
                 }
             }
+            sb.append("]");
         }
-        sb.append("]");
         return sb.toString();
     }
 
-
     /**
-     * Returns an Rx Observable that monitors changes to this RealmList. It will emit the current RealmList when
+     * Returns an Rx Flowable that monitors changes to this RealmList. It will emit the current RealmList when
      * subscribed to. RealmList will continually be emitted as the RealmList is updated -
      * {@code onComplete} will never be called.
      * <p>
-     * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
+     * If you would like the {@code asFlowable()} to stop emitting items you can instruct RxJava to
      * only emit only the first item by using the {@code first()} operator:
      * <p>
      * <pre>
      * {@code
-     * list.asObservable()
+     * list.asFlowable()
      *      .first()
      *      .subscribe( ... ) // You only get the results once
      * }
@@ -875,21 +881,49 @@ public String toString() {
      * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
      */
     @SuppressWarnings("unchecked")
-    public Observable<RealmList<E>> asObservable() {
+    public Flowable<RealmList<E>> asFlowable() {
         if (realm instanceof Realm) {
             return realm.configuration.getRxFactory().from((Realm) realm, this);
         } else if (realm instanceof DynamicRealm) {
-            DynamicRealm dynamicRealm = (DynamicRealm) realm;
-            RealmList<DynamicRealmObject> dynamicList = (RealmList<DynamicRealmObject>) this;
             @SuppressWarnings("UnnecessaryLocalVariable")
-            Observable results = realm.configuration.getRxFactory().from(dynamicRealm, dynamicList);
+            Flowable<RealmList<E>> results = realm.configuration.getRxFactory().from((DynamicRealm) realm, this);
             return results;
         } else {
-            throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava.");
+            throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava2.");
         }
     }
 
-    private void checkForAddRemoveListener(Object listener, boolean checkListener) {
+    /**
+     * Returns an Rx Observable that monitors changes to this RealmList. It will emit the current RealmList when
+     * subscribed. For each update to the RealmList a pair consisting of the RealmList and the
+     * {@link OrderedCollectionChangeSet} will be sent. The changeset will be {@code null} the first
+     * time an RealmList is emitted.
+     * <p>
+     * RealmList will continually be emitted as the RealmList is updated - {@code onComplete} will never be called.
+     * <p>
+     * * Note that when the {@link Realm} is accessed from threads other than where it was created,
+     * {@link IllegalStateException} will be thrown. Care should be taken when using different schedulers
+     * with {@code subscribeOn()} and {@code observeOn()}. Consider using {@code Realm.where().find*Async()}
+     * instead.
+     *
+     * @return RxJava Observable that only calls {@code onNext}. It will never call {@code onComplete} or {@code OnError}.
+     * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath or the
+     * corresponding Realm instance doesn't support RxJava.
+     * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
+     */
+    public Observable<CollectionChange<RealmList<E>>> asChangesetObservable() {
+        if (realm instanceof Realm) {
+            return realm.configuration.getRxFactory().changesetsFrom((Realm) realm, this);
+        } else if (realm instanceof DynamicRealm) {
+            DynamicRealm dynamicRealm = (DynamicRealm) realm;
+            RealmList<DynamicRealmObject> dynamicResults = (RealmList<DynamicRealmObject>) this;
+            return (Observable) realm.configuration.getRxFactory().changesetsFrom(dynamicRealm, dynamicResults);
+        } else {
+            throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava2.");
+        }
+    }
+
+    private void checkForAddRemoveListener(@Nullable Object listener, boolean checkListener) {
         if (checkListener && listener == null) {
             throw new IllegalArgumentException("Listener should not be null");
         }
@@ -899,6 +933,31 @@ private void checkForAddRemoveListener(Object listener, boolean checkListener) {
 
     /**
      * Adds a change listener to this {@link RealmList}.
+     * <p>
+     * Registering a change listener will not prevent the underlying RealmList from being garbage collected.
+     * If the RealmList is garbage collected, the change listener will stop being triggered. To avoid this, keep a
+     * strong reference for as long as appropriate e.g. in a class variable.
+     * <p>
+     * <pre>
+     * {@code
+     * public class MyActivity extends Activity {
+     *
+     *     private RealmList<Dog> dogs; // Strong reference to keep listeners alive
+     *
+     *     \@Override
+     *     protected void onCreate(Bundle savedInstanceState) {
+     *       super.onCreate(savedInstanceState);
+     *       dogs = realm.where(Person.class).findFirst().getDogs();
+     *       dogs.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Dog>>() {
+     *           \@Override
+     *           public void onChange(RealmList<Dog> dogs, OrderedCollectionChangeSet changeSet) {
+     *               // React to change
+     *           }
+     *       });
+     *     }
+     * }
+     * }
+     * </pre>
      *
      * @param listener the change listener to be notified.
      * @throws IllegalArgumentException if the change listener is {@code null}.
@@ -907,7 +966,11 @@ private void checkForAddRemoveListener(Object listener, boolean checkListener) {
      */
     public void addChangeListener(OrderedRealmCollectionChangeListener<RealmList<E>> listener) {
         checkForAddRemoveListener(listener, true);
-        collection.addListener(this, listener);
+        if (osListOperator.forRealmModel()) {
+            getOrCreateOsResultsForListener().addListener(this, listener);
+        } else {
+            osListOperator.getOsList().addListener(this, listener);
+        }
     }
 
     /**
@@ -920,11 +983,40 @@ public void addChangeListener(OrderedRealmCollectionChangeListener<RealmList<E>>
      */
     public void removeChangeListener(OrderedRealmCollectionChangeListener<RealmList<E>> listener) {
         checkForAddRemoveListener(listener, true);
-        collection.removeListener(this, listener);
+        if (osListOperator.forRealmModel()) {
+            getOrCreateOsResultsForListener().removeListener(this, listener);
+        } else {
+            osListOperator.getOsList().removeListener(this, listener);
+        }
     }
 
     /**
      * Adds a change listener to this {@link RealmList}.
+     * <p>
+     * Registering a change listener will not prevent the underlying RealmList from being garbage collected.
+     * If the RealmList is garbage collected, the change listener will stop being triggered. To avoid this, keep a
+     * strong reference for as long as appropriate e.g. in a class variable.
+     * <p>
+     * <pre>
+     * {@code
+     * public class MyActivity extends Activity {
+     *
+     *     private RealmList<Dog> dogs; // Strong reference to keep listeners alive
+     *
+     *     \@Override
+     *     protected void onCreate(Bundle savedInstanceState) {
+     *       super.onCreate(savedInstanceState);
+     *       dogs = realm.where(Person.class).findFirst().getDogs();
+     *       dogs.addChangeListener(new RealmChangeListener<RealmList<Dog>>() {
+     *           \@Override
+     *           public void onChange(RealmList<Dog> dogs) {
+     *               // React to change
+     *           }
+     *       });
+     *     }
+     * }
+     * }
+     * </pre>
      *
      * @param listener the change listener to be notified.
      * @throws IllegalArgumentException if the change listener is {@code null}.
@@ -933,7 +1025,11 @@ public void removeChangeListener(OrderedRealmCollectionChangeListener<RealmList<
      */
     public void addChangeListener(RealmChangeListener<RealmList<E>> listener) {
         checkForAddRemoveListener(listener, true);
-        collection.addListener(this, listener);
+        if (osListOperator.forRealmModel()) {
+            getOrCreateOsResultsForListener().addListener(this, listener);
+        } else {
+            osListOperator.getOsList().addListener(this, listener);
+        }
     }
 
     /**
@@ -946,7 +1042,11 @@ public void addChangeListener(RealmChangeListener<RealmList<E>> listener) {
      */
     public void removeChangeListener(RealmChangeListener<RealmList<E>> listener) {
         checkForAddRemoveListener(listener, true);
-        collection.removeListener(this, listener);
+        if (osListOperator.forRealmModel()) {
+            getOrCreateOsResultsForListener().removeListener(this, listener);
+        } else {
+            osListOperator.getOsList().removeListener(this, listener);
+        }
     }
 
     /**
@@ -957,7 +1057,11 @@ public void removeChangeListener(RealmChangeListener<RealmList<E>> listener) {
      */
     public void removeAllChangeListeners() {
         checkForAddRemoveListener(null, false);
-        collection.removeAllListeners();
+        if (osListOperator.forRealmModel()) {
+            getOrCreateOsResultsForListener().removeAllListeners();
+        } else {
+            osListOperator.getOsList().removeAllListeners();
+        }
     }
 
     // Custom RealmList iterator.
@@ -986,7 +1090,7 @@ public void removeAllChangeListeners() {
          */
         @Override
         public boolean hasNext() {
-            realm.checkIfValid();
+            checkValidRealm();
             checkConcurrentModification();
             return cursor != size();
         }
@@ -995,8 +1099,9 @@ public boolean hasNext() {
          * {@inheritDoc}
          */
         @Override
+        @Nullable
         public E next() {
-            realm.checkIfValid();
+            checkValidRealm();
             checkConcurrentModification();
             int i = cursor;
             try {
@@ -1015,7 +1120,7 @@ public E next() {
          */
         @Override
         public void remove() {
-            realm.checkIfValid();
+            checkValidRealm();
             if (lastRet < 0) {
                 throw new IllegalStateException("Cannot call remove() twice. Must call next() in between.");
             }
@@ -1068,6 +1173,7 @@ public boolean hasPrevious() {
          * {@inheritDoc}
          */
         @Override
+        @Nullable
         public E previous() {
             checkConcurrentModification();
             int i = cursor - 1;
@@ -1101,7 +1207,7 @@ public int previousIndex() {
          * {@inheritDoc}
          */
         @Override
-        public void set(E e) {
+        public void set(@Nullable E e) {
             realm.checkIfValid();
             if (lastRet < 0) {
                 throw new IllegalStateException();
@@ -1120,10 +1226,10 @@ public void set(E e) {
          * Adding a new object to the RealmList. If the object is not already manage by Realm it will be transparently
          * copied using {@link Realm#copyToRealmOrUpdate(RealmModel)}
          *
-         * @see #add(RealmModel)
+         * @see #add(Object)
          */
         @Override
-        public void add(E e) {
+        public void add(@Nullable E e) {
             realm.checkIfValid();
             checkConcurrentModification();
             try {
@@ -1137,4 +1243,680 @@ public void add(E e) {
             }
         }
     }
+
+    private static boolean isClassForRealmModel(Class<?> clazz) {
+        return RealmModel.class.isAssignableFrom(clazz);
+    }
+
+    private ManagedListOperator<E> getOperator(BaseRealm realm, OsList osList, @Nullable Class<E> clazz, @Nullable String className) {
+        if (clazz == null || isClassForRealmModel(clazz)) {
+            return new RealmModelListOperator<>(realm, osList, clazz, className);
+        }
+        if (clazz == String.class) {
+            //noinspection unchecked
+            return (ManagedListOperator<E>) new StringListOperator(realm, osList, (Class<String>) clazz);
+        }
+        if (clazz == Long.class || clazz == Integer.class || clazz == Short.class || clazz == Byte.class) {
+            return new LongListOperator<>(realm, osList, clazz);
+        }
+        if (clazz == Boolean.class) {
+            //noinspection unchecked
+            return (ManagedListOperator<E>) new BooleanListOperator(realm, osList, (Class<Boolean>) clazz);
+        }
+        if (clazz == byte[].class) {
+            //noinspection unchecked
+            return (ManagedListOperator<E>) new BinaryListOperator(realm, osList, (Class<byte[]>) clazz);
+        }
+        if (clazz == Double.class) {
+            //noinspection unchecked
+            return (ManagedListOperator<E>) new DoubleListOperator(realm, osList, (Class<Double>) clazz);
+        }
+        if (clazz == Float.class) {
+            //noinspection unchecked
+            return (ManagedListOperator<E>) new FloatListOperator(realm, osList, (Class<Float>) clazz);
+        }
+        if (clazz == Date.class) {
+            //noinspection unchecked
+            return (ManagedListOperator<E>) new DateListOperator(realm, osList, (Class<Date>) clazz);
+        }
+        throw new IllegalArgumentException("Unexpected value class: " + clazz.getName());
+    }
+
+    // TODO: Object Store is not able to merge change set for links list. Luckily since we were still using LinkView
+    // when ship the fine grain notifications, the listener on RealmList is actually added to a OS Results which is
+    // created from the link view. OS Results is computing the change set by comparing the old/new collection. So it
+    // will give the right results if you remove all elements from a RealmList then add all them back and add one more
+    // new element. By right results it means the change set only include one insertion. But if the listener is on the
+    // OS List, the change set will include all ranges of th list. So we keep the old behaviour for
+    // RealmList<RealmModel> for now. See https://github.com/realm/realm-object-store/issues/541
+    private OsResults getOrCreateOsResultsForListener() {
+        if (osResults == null) {
+            this.osResults = new OsResults(realm.sharedRealm, osListOperator.getOsList(), null);
+        }
+        return osResults;
+    }
+}
+
+/**
+ * This class provides facade for against {@link OsList}. {@link OsList} is used for both {@link RealmModel}s
+ * and values, but there are some subtle differences in actual operation.
+ * <p>
+ * This class provides common interface for them.
+ * <p>
+ * You need to use appropriate sub-class for underlying field type.
+ *
+ * @param <T> class of element which is returned on read operation.
+ */
+abstract class ManagedListOperator<T> {
+    static final String NULL_OBJECTS_NOT_ALLOWED_MESSAGE = "RealmList does not accept null values.";
+    static final String INVALID_OBJECT_TYPE_MESSAGE = "Unacceptable value type. Acceptable: %1$s, actual: %2$s .";
+
+    final BaseRealm realm;
+    final OsList osList;
+    @Nullable
+    final Class<T> clazz;
+
+    ManagedListOperator(BaseRealm realm, OsList osList, @Nullable Class<T> clazz) {
+        this.realm = realm;
+        this.clazz = clazz;
+        this.osList = osList;
+    }
+
+    public abstract boolean forRealmModel();
+
+    public final OsList getOsList() {
+        return osList;
+    }
+
+    public final boolean isValid() {
+        return osList.isValid();
+    }
+
+    public final int size() {
+        final long actualSize = osList.size();
+        return actualSize < Integer.MAX_VALUE ? (int) actualSize : Integer.MAX_VALUE;
+    }
+
+    public final boolean isEmpty() {
+        return osList.isEmpty();
+    }
+
+    protected abstract void checkValidValue(@Nullable Object value);
+
+    @Nullable
+    public abstract T get(int index);
+
+    public final void append(@Nullable Object value) {
+        checkValidValue(value);
+
+        if (value == null) {
+            appendNull();
+        } else {
+            appendValue(value);
+        }
+    }
+
+    private void appendNull() {
+        osList.addNull();
+    }
+
+    abstract protected void appendValue(Object value);
+
+    public final void insert(int index, @Nullable Object value) {
+        checkValidValue(value);
+
+        if (value == null) {
+            insertNull(index);
+        } else {
+            insertValue(index, value);
+        }
+
+    }
+
+    protected void insertNull(int index) {
+        osList.insertNull(index);
+    }
+
+    protected abstract void insertValue(int index, Object value);
+
+    @Nullable
+    public final T set(int index, @Nullable Object value) {
+        checkValidValue(value);
+
+        //noinspection unchecked
+        final T oldObject = get(index);
+        if (value == null) {
+            setNull(index);
+        } else {
+            setValue(index, value);
+        }
+        return oldObject;
+    }
+
+    protected void setNull(int index) {
+        osList.setNull(index);
+    }
+
+    abstract protected void setValue(int index, Object value);
+
+    final void move(int oldPos, int newPos) {
+        osList.move(oldPos, newPos);
+    }
+
+    final void remove(int index) {
+        osList.remove(index);
+    }
+
+    final void removeAll() {
+        osList.removeAll();
+    }
+
+    final void delete(int index) {
+        osList.delete(index);
+    }
+
+    final void deleteLast() {
+        osList.delete(osList.size() - 1);
+    }
+
+    final void deleteAll() {
+        osList.deleteAll();
+    }
+
+}
+
+/**
+ * A subclass of {@link ManagedListOperator} that deal with {@link RealmModel} list field.
+ */
+final class RealmModelListOperator<T> extends ManagedListOperator<T> {
+
+    @Nullable
+    private final String className;
+
+    RealmModelListOperator(BaseRealm realm, OsList osList, @Nullable Class<T> clazz, @Nullable String className) {
+        super(realm, osList, clazz);
+        this.className = className;
+    }
+
+    @Override
+    public boolean forRealmModel() {
+        return true;
+    }
+
+    @Override
+    public T get(int index) {
+        //noinspection unchecked
+        return (T) realm.get((Class<? extends RealmModel>) clazz, className, osList.getUncheckedRow(index));
+    }
+
+    @Override
+    protected void checkValidValue(@Nullable Object value) {
+        if (value == null) {
+            throw new IllegalArgumentException(NULL_OBJECTS_NOT_ALLOWED_MESSAGE);
+        }
+        if (!(value instanceof RealmModel)) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.ENGLISH, INVALID_OBJECT_TYPE_MESSAGE,
+                            "java.lang.String",
+                            value.getClass().getName()));
+        }
+    }
+
+    private void checkInsertIndex(int index) {
+        final int size = size();
+        if (index < 0 || size < index) {
+            throw new IndexOutOfBoundsException("Invalid index " + index + ", size is " + osList.size());
+        }
+    }
+
+    @Override
+    public void appendValue(Object value) {
+        final RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded((RealmModel) value);
+        osList.addRow(proxy.realmGet$proxyState().getRow$realm().getIndex());
+    }
+
+    @Override
+    protected void insertNull(int index) {
+        throw new RuntimeException("Should not reach here.");
+    }
+
+    @Override
+    public void insertValue(int index, Object value) {
+        // need to check in advance to avoid unnecessary copy of unmanaged object into Realm.
+        checkInsertIndex(index);
+
+        RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded((RealmModel) value);
+        osList.insertRow(index, proxy.realmGet$proxyState().getRow$realm().getIndex());
+    }
+
+    @Override
+    protected void setNull(int index) {
+        throw new RuntimeException("Should not reach here.");
+    }
+
+    @Override
+    protected void setValue(int index, Object value) {
+        RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded((RealmModel) value);
+        osList.setRow(index, proxy.realmGet$proxyState().getRow$realm().getIndex());
+    }
+
+    // Transparently copies an unmanaged object or managed object from another Realm to the Realm backing this RealmList.
+    private <E extends RealmModel> E copyToRealmIfNeeded(E object) {
+        if (object instanceof RealmObjectProxy) {
+            RealmObjectProxy proxy = (RealmObjectProxy) object;
+
+            if (proxy instanceof DynamicRealmObject) {
+                //noinspection ConstantConditions
+                @Nonnull
+                String listClassName = className;
+                if (proxy.realmGet$proxyState().getRealm$realm() == realm) {
+                    String objectClassName = ((DynamicRealmObject) object).getType();
+                    if (listClassName.equals(objectClassName)) {
+                        // Same Realm instance and same target table
+                        return object;
+                    } else {
+                        // Different target table
+                        throw new IllegalArgumentException(String.format(Locale.US,
+                                "The object has a different type from list's." +
+                                        " Type of the list is '%s', type of object is '%s'.", listClassName, objectClassName));
+                    }
+                } else if (realm.threadId == proxy.realmGet$proxyState().getRealm$realm().threadId) {
+                    // We don't support moving DynamicRealmObjects across Realms automatically. The overhead is too big as
+                    // you have to run a full schema validation for each object.
+                    // And copying from another Realm instance pointed to the same Realm file is not supported as well.
+                    throw new IllegalArgumentException("Cannot copy DynamicRealmObject between Realm instances.");
+                } else {
+                    throw new IllegalStateException("Cannot copy an object to a Realm instance created in another thread.");
+                }
+            } else {
+                // Object is already in this realm
+                if (proxy.realmGet$proxyState().getRow$realm() != null && proxy.realmGet$proxyState().getRealm$realm().getPath().equals(realm.getPath())) {
+                    if (realm != proxy.realmGet$proxyState().getRealm$realm()) {
+                        throw new IllegalArgumentException("Cannot copy an object from another Realm instance.");
+                    }
+                    return object;
+                }
+            }
+        }
+
+        // At this point the object can only be a typed object, so the backing Realm cannot be a DynamicRealm.
+        Realm realm = (Realm) this.realm;
+        if (OsObjectStore.getPrimaryKeyForObject(realm.getSharedRealm(),
+                realm.getConfiguration().getSchemaMediator().getSimpleClassName(object.getClass())) != null) {
+            return realm.copyToRealmOrUpdate(object);
+        } else {
+            return realm.copyToRealm(object);
+        }
+    }
+}
+
+/**
+ * A subclass of {@link ManagedListOperator} that deal with {@link String} list field.
+ */
+final class StringListOperator extends ManagedListOperator<String> {
+
+    StringListOperator(BaseRealm realm, OsList osList, Class<String> clazz) {
+        super(realm, osList, clazz);
+    }
+
+    @Override
+    public boolean forRealmModel() {
+        return false;
+    }
+
+    @Nullable
+    @Override
+    public String get(int index) {
+        return (String) osList.getValue(index);
+    }
+
+    @Override
+    protected void checkValidValue(@Nullable Object value) {
+        if (value == null) {
+            // null is always valid (but schema may reject null on insertion).
+            return;
+        }
+        if (!(value instanceof String)) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.ENGLISH, INVALID_OBJECT_TYPE_MESSAGE,
+                            "java.lang.String",
+                            value.getClass().getName()));
+        }
+    }
+
+    @Override
+    public void appendValue(Object value) {
+        osList.addString((String) value);
+    }
+
+    @Override
+    public void insertValue(int index, Object value) {
+        osList.insertString(index, (String) value);
+    }
+
+    @Override
+    protected void setValue(int index, Object value) {
+        osList.setString(index, (String) value);
+    }
+}
+
+/**
+ * A subclass of {@link ManagedListOperator} that deal with {@code long} list field.
+ */
+final class LongListOperator<T> extends ManagedListOperator<T> {
+
+    LongListOperator(BaseRealm realm, OsList osList, Class<T> clazz) {
+        super(realm, osList, clazz);
+    }
+
+    @Override
+    public boolean forRealmModel() {
+        return false;
+    }
+
+    @Nullable
+    @Override
+    public T get(int index) {
+        final Long value = (Long) osList.getValue(index);
+        if (value == null) {
+            return null;
+        }
+        if (clazz == Long.class) {
+            //noinspection unchecked
+            return (T) value;
+        }
+        if (clazz == Integer.class) {
+            //noinspection unchecked,UnnecessaryBoxing,ConstantConditions
+            return clazz.cast(Integer.valueOf(value.intValue()));
+        }
+        if (clazz == Short.class) {
+            //noinspection unchecked,UnnecessaryBoxing,ConstantConditions
+            return clazz.cast(Short.valueOf(value.shortValue()));
+        }
+        if (clazz == Byte.class) {
+            //noinspection unchecked,UnnecessaryBoxing,ConstantConditions
+            return clazz.cast(Byte.valueOf(value.byteValue()));
+        }
+        //noinspection ConstantConditions
+        throw new IllegalStateException("Unexpected element type: " + clazz.getName());
+    }
+
+    @Override
+    protected void checkValidValue(@Nullable Object value) {
+        if (value == null) {
+            // null is always valid (but schema may reject null on insertion).
+            return;
+        }
+        if (!(value instanceof Number)) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.ENGLISH, INVALID_OBJECT_TYPE_MESSAGE,
+                            "java.lang.Long, java.lang.Integer, java.lang.Short, java.lang.Byte",
+                            value.getClass().getName()));
+        }
+    }
+
+    @Override
+    public void appendValue(Object value) {
+        osList.addLong(((Number) value).longValue());
+    }
+
+    @Override
+    public void insertValue(int index, Object value) {
+        osList.insertLong(index, ((Number) value).longValue());
+    }
+
+    @Override
+    protected void setValue(int index, Object value) {
+        osList.setLong(index, ((Number) value).longValue());
+    }
+}
+
+/**
+ * A subclass of {@link ManagedListOperator} that deal with {@code boolean} list field.
+ */
+final class BooleanListOperator extends ManagedListOperator<Boolean> {
+
+    BooleanListOperator(BaseRealm realm, OsList osList, Class<Boolean> clazz) {
+        super(realm, osList, clazz);
+    }
+
+    @Override
+    public boolean forRealmModel() {
+        return false;
+    }
+
+    @Nullable
+    @Override
+    public Boolean get(int index) {
+        return (Boolean) osList.getValue(index);
+    }
+
+    @Override
+    protected void checkValidValue(@Nullable Object value) {
+        if (value == null) {
+            // null is always valid (but schema may reject null on insertion).
+            return;
+        }
+        if (!(value instanceof Boolean)) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.ENGLISH, INVALID_OBJECT_TYPE_MESSAGE,
+                            "java.lang.Boolean",
+                            value.getClass().getName()));
+        }
+    }
+
+    @Override
+    public void appendValue(Object value) {
+        osList.addBoolean((Boolean) value);
+    }
+
+    @Override
+    public void insertValue(int index, Object value) {
+        osList.insertBoolean(index, (Boolean) value);
+    }
+
+    @Override
+    protected void setValue(int index, Object value) {
+        osList.setBoolean(index, (Boolean) value);
+    }
+}
+
+/**
+ * A subclass of {@link ManagedListOperator} that deal with {@code byte[]} list field.
+ */
+final class BinaryListOperator extends ManagedListOperator<byte[]> {
+
+    BinaryListOperator(BaseRealm realm, OsList osList, Class<byte[]> clazz) {
+        super(realm, osList, clazz);
+    }
+
+    @Override
+    public boolean forRealmModel() {
+        return false;
+    }
+
+    @Nullable
+    @Override
+    public byte[] get(int index) {
+        return (byte[]) osList.getValue(index);
+    }
+
+    @Override
+    protected void checkValidValue(@Nullable Object value) {
+        if (value == null) {
+            // null is always valid (but schema may reject null on insertion).
+            return;
+        }
+        if (!(value instanceof byte[])) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.ENGLISH, INVALID_OBJECT_TYPE_MESSAGE,
+                            "byte[]",
+                            value.getClass().getName()));
+        }
+    }
+
+    @Override
+    public void appendValue(Object value) {
+        osList.addBinary((byte[]) value);
+    }
+
+    @Override
+    public void insertValue(int index, Object value) {
+        osList.insertBinary(index, (byte[]) value);
+    }
+
+    @Override
+    protected void setValue(int index, Object value) {
+        osList.setBinary(index, (byte[]) value);
+    }
+}
+
+/**
+ * A subclass of {@link ManagedListOperator} that deal with {@code double} list field.
+ */
+final class DoubleListOperator extends ManagedListOperator<Double> {
+
+    DoubleListOperator(BaseRealm realm, OsList osList, Class<Double> clazz) {
+        super(realm, osList, clazz);
+    }
+
+    @Override
+    public boolean forRealmModel() {
+        return false;
+    }
+
+    @Nullable
+    @Override
+    public Double get(int index) {
+        return (Double) osList.getValue(index);
+    }
+
+    @Override
+    protected void checkValidValue(@Nullable Object value) {
+        if (value == null) {
+            // null is always valid (but schema may reject null on insertion).
+            return;
+        }
+        if (!(value instanceof Number)) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.ENGLISH, INVALID_OBJECT_TYPE_MESSAGE,
+                            "java.lang.Number",
+                            value.getClass().getName()));
+        }
+    }
+
+    @Override
+    public void appendValue(Object value) {
+        osList.addDouble(((Number) value).doubleValue());
+    }
+
+    @Override
+    public void insertValue(int index, Object value) {
+        osList.insertDouble(index, ((Number) value).doubleValue());
+    }
+
+    @Override
+    protected void setValue(int index, Object value) {
+        osList.setDouble(index, ((Number) value).doubleValue());
+    }
+}
+
+/**
+ * A subclass of {@link ManagedListOperator} that deal with {@code float} list field.
+ */
+final class FloatListOperator extends ManagedListOperator<Float> {
+
+    FloatListOperator(BaseRealm realm, OsList osList, Class<Float> clazz) {
+        super(realm, osList, clazz);
+    }
+
+    @Override
+    public boolean forRealmModel() {
+        return false;
+    }
+
+    @Nullable
+    @Override
+    public Float get(int index) {
+        return (Float) osList.getValue(index);
+    }
+
+    @Override
+    protected void checkValidValue(@Nullable Object value) {
+        if (value == null) {
+            // null is always valid (but schema may reject null on insertion).
+            return;
+        }
+        if (!(value instanceof Number)) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.ENGLISH, INVALID_OBJECT_TYPE_MESSAGE,
+                            "java.lang.Number",
+                            value.getClass().getName()));
+        }
+    }
+
+    @Override
+    public void appendValue(Object value) {
+        osList.addFloat(((Number) value).floatValue());
+    }
+
+    @Override
+    public void insertValue(int index, Object value) {
+        osList.insertFloat(index, ((Number) value).floatValue());
+    }
+
+    @Override
+    protected void setValue(int index, Object value) {
+        osList.setFloat(index, ((Number) value).floatValue());
+    }
+}
+
+/**
+ * A subclass of {@link ManagedListOperator} that deal with {@link Date} list field.
+ */
+final class DateListOperator extends ManagedListOperator<Date> {
+
+    DateListOperator(BaseRealm realm, OsList osList, Class<Date> clazz) {
+        super(realm, osList, clazz);
+    }
+
+    @Override
+    public boolean forRealmModel() {
+        return false;
+    }
+
+    @Nullable
+    @Override
+    public Date get(int index) {
+        return (Date) osList.getValue(index);
+    }
+
+    @Override
+    protected void checkValidValue(@Nullable Object value) {
+        if (value == null) {
+            // null is always valid (but schema may reject null on insertion).
+            return;
+        }
+        if (!(value instanceof Date)) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.ENGLISH, INVALID_OBJECT_TYPE_MESSAGE,
+                            "java.util.Date",
+                            value.getClass().getName()));
+        }
+    }
+
+    @Override
+    public void appendValue(Object value) {
+        osList.addDate((Date) value);
+    }
+
+    @Override
+    public void insertValue(int index, Object value) {
+        osList.insertDate(index, (Date) value);
+    }
+
+    @Override
+    protected void setValue(int index, Object value) {
+        osList.setDate(index, (Date) value);
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmMigration.java b/realm/realm-library/src/main/java/io/realm/RealmMigration.java
index 5140a3bf6a..44e98f30ca 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmMigration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmMigration.java
@@ -42,7 +42,7 @@
  *     }
  *
  *     if (oldVersion < newVersion) {
- *         throw new IllegalStateException(String.format("Migration missing from v%d to v%d", oldVersion, newVersion));
+ *         throw new IllegalStateException(String.format(Locale.US, "Migration missing from v%d to v%d", oldVersion, newVersion));
  *     }
  *   }
  * }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObject.java b/realm/realm-library/src/main/java/io/realm/RealmObject.java
index 74025c2544..2b6162e6aa 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObject.java
@@ -18,12 +18,14 @@
 
 import android.app.IntentService;
 
+import io.reactivex.Flowable;
+import io.reactivex.Observable;
 import io.realm.annotations.RealmClass;
 import io.realm.internal.InvalidRow;
+import io.realm.internal.ManagableObject;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
-import rx.Observable;
-
+import io.realm.rx.ObjectChange;
 
 /**
  * In Realm you define your RealmObject classes by sub-classing RealmObject and adding fields to be persisted. You then
@@ -49,9 +51,9 @@
  * The types <code>short</code>, <code>int</code>, and <code>long</code> are mapped to <code>long</code> when storing
  * within a Realm.
  * <p>
- * The only restriction a RealmObject has is that fields are not allowed to be final, transient' or volatile.
+ * The only restriction a RealmObject has is that fields are not allowed to be final or volatile.
  * Any method as well as public fields are allowed. When providing custom constructors, a public constructor with
- * no arguments must be declared and be empty.
+ * no arguments must be declared.
  * <p>
  * Fields annotated with {@link io.realm.annotations.Ignore} don't have these restrictions and don't require either a
  * getter or setter.
@@ -66,7 +68,10 @@
  */
 
 @RealmClass
-public abstract class RealmObject implements RealmModel {
+public abstract class RealmObject implements RealmModel, ManagableObject {
+    static final String MSG_NULL_OBJECT = "'model' is null.";
+    static final String MSG_DELETED_OBJECT = "the object is already deleted.";
+    static final String MSG_DYNAMIC_OBJECT = "the object is an instance of DynamicRealmObject. Use DynamicRealmObject.getDynamicRealm() instead.";
 
     /**
      * Deletes the object from the Realm it is currently associated to.
@@ -119,7 +124,7 @@ public final void deleteFromRealm() {
      * when observed.
      * <pre>
      * {@code
-     * realm.where(BannerRealm.class).equalTo("type", type).findFirstAsync().asObservable()
+     * realm.where(BannerRealm.class).equalTo("type", type).findFirstAsync().asFlowable()
      *      .filter(result.isLoaded() && result.isValid())
      *      .first()
      * }
@@ -128,6 +133,7 @@ public final void deleteFromRealm() {
      * @return {@code true} if the object is still accessible or an unmanaged object, {@code false} otherwise.
      * @see <a href="https://github.com/realm/realm-java/tree/master/examples/rxJavaExample">Examples using Realm with RxJava</a>
      */
+    @Override
     public final boolean isValid() {
         return RealmObject.isValid(this);
     }
@@ -256,8 +262,9 @@ public final boolean isLoaded() {
      *
      * @return {@code true} if the object is managed, {@code false} if it is unmanaged.
      */
+    @Override
     public boolean isManaged() {
-        return isManaged(this);
+        return RealmObject.isManaged(this);
     }
 
     /**
@@ -283,6 +290,49 @@ public boolean isManaged() {
         return object instanceof RealmObjectProxy;
     }
 
+    /**
+     * Returns {@link Realm} instance where this {@link RealmObject} belongs.
+     * <p>
+     * You <b>must not</b> call {@link Realm#close()} against returned instance.
+     *
+     * @return {@link Realm} instance where this object belongs to or {@code null} if this object is unmanaged.
+     * @throws IllegalStateException if this object is an instance of {@link DynamicRealmObject}
+     * or this object was already deleted or the corresponding {@link Realm} was already closed.
+     */
+    public Realm getRealm() {
+        return getRealm(this);
+    }
+
+    /**
+     * returns {@link Realm} instance where the {@code model} belongs.
+     * <p>
+     * You <b>must not</b> call {@link Realm#close()} against returned instance.
+     *
+     * @param model an {@link RealmModel} instance other than {@link DynamicRealmObject}.
+     * @return {@link Realm} instance where the {@code model} belongs or {@code null} if the {@code model} is unmanaged.
+     * @throws IllegalArgumentException if the {@code model} is {@code null}.
+     * @throws IllegalStateException if the {@code model}  is an instance of {@link DynamicRealmObject}
+     * or this object was already deleted or the corresponding {@link Realm} was already closed.
+     */
+    public static Realm getRealm(RealmModel model) {
+        if (model == null) {
+            throw new IllegalArgumentException(MSG_NULL_OBJECT);
+        }
+        if (model instanceof DynamicRealmObject) {
+            throw new IllegalStateException(MSG_DYNAMIC_OBJECT);
+        }
+        if (!(model instanceof RealmObjectProxy)) {
+            return null;
+        }
+        final BaseRealm realm = ((RealmObjectProxy) model).realmGet$proxyState().getRealm$realm();
+        realm.checkIfValid();
+        if (!RealmObject.isValid(model)) {
+            throw new IllegalStateException(MSG_DELETED_OBJECT);
+        }
+
+        return (Realm) realm;
+    }
+
     /**
      * Makes an asynchronous query blocking. This will also trigger any registered listeners.
      * <p>
@@ -316,6 +366,31 @@ public final boolean load() {
      * Adds a change listener to this RealmObject to get detailed information about changes. The listener will be
      * triggered if any value field or referenced RealmObject field is changed, or the RealmList field itself is
      * changed.
+     * <p>
+     * Registering a change listener will not prevent the underlying RealmObject from being garbage collected.
+     * If the RealmObject is garbage collected, the change listener will stop being triggered. To avoid this, keep a
+     * strong reference for as long as appropriate e.g. in a class variable.
+     * <p>
+     * <pre>
+     * {@code
+     * public class MyActivity extends Activity {
+     *
+     *     private Person person; // Strong reference to keep listeners alive
+     *
+     *     \@Override
+     *     protected void onCreate(Bundle savedInstanceState) {
+     *       super.onCreate(savedInstanceState);
+     *       person = realm.where(Person.class).findFirst();
+     *       person.addChangeListener(new RealmObjectChangeListener<Person>() {
+     *           \@Override
+     *           public void onChange(Person person, ObjectChangeSet changeSet) {
+     *               // React to change
+     *           }
+     *       });
+     *     }
+     * }
+     * }
+     * </pre>
      *
      * @param listener the change listener to be notified.
      * @throws IllegalArgumentException if the change listener is {@code null} or the object is an unmanaged object.
@@ -330,6 +405,31 @@ public final boolean load() {
     /**
      * Adds a change listener to this RealmObject that will be triggered if any value field or referenced RealmObject
      * field is changed, or the RealmList field itself is changed.
+     * <p>
+     * Registering a change listener will not prevent the underlying RealmObject from being garbage collected.
+     * If the RealmObject is garbage collected, the change listener will stop being triggered. To avoid this, keep a
+     * strong reference for as long as appropriate e.g. in a class variable.
+     * <p>
+     * <pre>
+     * {@code
+     * public class MyActivity extends Activity {
+     *
+     *     private Person person; // Strong reference to keep listeners alive
+     *
+     *     \@Override
+     *     protected void onCreate(Bundle savedInstanceState) {
+     *       super.onCreate(savedInstanceState);
+     *       person = realm.where(Person.class).findFirst();
+     *       person.addChangeListener(new RealmChangeListener<Person>() {
+     *           \@Override
+     *           public void onChange(Person person) {
+     *               // React to change
+     *           }
+     *       });
+     *     }
+     * }
+     * }
+     * </pre>
      *
      * @param listener the change listener to be notified.
      * @throws IllegalArgumentException if the change listener is {@code null} or the object is an unmanaged object.
@@ -345,6 +445,32 @@ public final boolean load() {
      * Adds a change listener to a RealmObject to get detailed information about the changes. The listener will be
      * triggered if any value field or referenced RealmObject field is changed, or the RealmList field itself is
      * changed.
+     * <p>
+     * Registering a change listener will not prevent the underlying RealmObject from being garbage collected.
+     * If the RealmObject is garbage collected, the change listener will stop being triggered. To avoid this, keep a
+     * strong reference for as long as appropriate e.g. in a class variable.
+     * <p>
+     * <pre>
+     * {@code
+     * public class MyActivity extends Activity {
+     *
+     *     private Person person; // Strong reference to keep listeners alive
+     *
+     *     \@Override
+     *     protected void onCreate(Bundle savedInstanceState) {
+     *       super.onCreate(savedInstanceState);
+     *       person = realm.where(Person.class).findFirst();
+     *       person.addChangeListener(new RealmObjectChangeListener<Person>() {
+     *           \@Override
+     *           public void onChange(Person person, ObjectChangeSet changeSet) {
+     *               // React to change
+     *           }
+     *       });
+     *     }
+     * }
+     * }
+     * </pre>
+     *
      *
      * @param object RealmObject to add listener to.
      * @param listener the change listener to be notified.
@@ -354,9 +480,11 @@ public final boolean load() {
      * @throws IllegalStateException if you try to add a listener inside a transaction.
      */
     public static <E extends RealmModel> void addChangeListener(E object, RealmObjectChangeListener<E> listener) {
+        //noinspection ConstantConditions
         if (object == null) {
             throw new IllegalArgumentException("Object should not be null");
         }
+        //noinspection ConstantConditions
         if (listener == null) {
             throw new IllegalArgumentException("Listener should not be null");
         }
@@ -375,6 +503,31 @@ public final boolean load() {
     /**
      * Adds a change listener to a RealmObject that will be triggered if any value field or referenced RealmObject field
      * is changed, or the RealmList field itself is changed.
+     * <p>
+     * Registering a change listener will not prevent the underlying RealmObject from being garbage collected.
+     * If the RealmObject is garbage collected, the change listener will stop being triggered. To avoid this, keep a
+     * strong reference for as long as appropriate e.g. in a class variable.
+     * <p>
+     * <pre>
+     * {@code
+     * public class MyActivity extends Activity {
+     *
+     *     private Person person; // Strong reference to keep listeners alive
+     *
+     *     \@Override
+     *     protected void onCreate(Bundle savedInstanceState) {
+     *       super.onCreate(savedInstanceState);
+     *       person = realm.where(Person.class).findFirst();
+     *       person.addChangeListener(new RealmChangeListener<Person>() {
+     *           \@Override
+     *           public void onChange(Person person) {
+     *               // React to change
+     *           }
+     *       });
+     *     }
+     * }
+     * }
+     * </pre>
      *
      * @param object RealmObject to add listener to.
      * @param listener the change listener to be notified.
@@ -384,7 +537,7 @@ public final boolean load() {
      * @throws IllegalStateException if you try to add a listener inside a transaction.
      */
     public static <E extends RealmModel> void addChangeListener(E object, RealmChangeListener<E> listener) {
-        addChangeListener(object, new ProxyState.RealmChangeListenerWrapper<E>(listener));
+        addChangeListener(object, new ProxyState.RealmChangeListenerWrapper<>(listener));
     }
 
     /**
@@ -419,9 +572,11 @@ public final void removeChangeListener(RealmChangeListener listener) {
      * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
      */
     public static <E extends RealmModel> void removeChangeListener(E object, RealmObjectChangeListener listener) {
+        //noinspection ConstantConditions
         if (object == null) {
             throw new IllegalArgumentException("Object should not be null");
         }
+        //noinspection ConstantConditions
         if (listener == null) {
             throw new IllegalArgumentException("Listener should not be null");
         }
@@ -447,17 +602,7 @@ public final void removeChangeListener(RealmChangeListener listener) {
      * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
      */
     public static <E extends RealmModel> void removeChangeListener(E object, RealmChangeListener<E> listener) {
-        removeChangeListener(object, new ProxyState.RealmChangeListenerWrapper<E>(listener));
-    }
-
-    /**
-     * Removes all registered listeners.
-     *
-     * @deprecated Use {@link #removeAllChangeListeners()} instead.
-     */
-    @Deprecated
-    public final void removeChangeListeners() {
-        RealmObject.removeChangeListeners(this);
+        removeChangeListener(object, new ProxyState.RealmChangeListenerWrapper<>(listener));
     }
 
     /**
@@ -467,18 +612,6 @@ public final void removeAllChangeListeners() {
         RealmObject.removeAllChangeListeners(this);
     }
 
-    /**
-     * Removes all registered listeners from the given RealmObject.
-     *
-     * @param object RealmObject to remove all listeners from.
-     * @throws IllegalArgumentException if object is {@code null} or isn't managed by Realm.
-     * @deprecated Use {@link RealmObject#removeAllChangeListeners(RealmModel)} instead.
-     */
-    @Deprecated
-    public static <E extends RealmModel> void removeChangeListeners(E object) {
-        removeAllChangeListeners(object);
-    }
-
     /**
      * Removes all registered listeners from the given RealmObject.
      *
@@ -498,19 +631,19 @@ public final void removeAllChangeListeners() {
     }
 
     /**
-     * Returns an RxJava Observable that monitors changes to this RealmObject. It will emit the current object when
+     * Returns an RxJava Flowable that monitors changes to this RealmObject. It will emit the current object when
      * subscribed to. Object updates will continually be emitted as the RealmObject is updated -
      * {@code onComplete} will never be called.
      * <p>
-     * When chaining a RealmObject observable use {@code obj.<MyRealmObjectClass>asObservable()} to pass on
+     * When chaining a RealmObject flowable use {@code obj.<MyRealmObjectClass>asFlowable()} to pass on
      * type information, otherwise the type of the following observables will be {@code RealmObject}.
      * <p>
-     * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
+     * If you would like the {@code asFlowable()} to stop emitting items you can instruct RxJava to
      * only emit only the first item by using the {@code first()} operator:
      * <p>
      * <pre>
      * {@code
-     * obj.asObservable()
+     * obj.asFlowable()
      *      .filter(obj -> obj.isLoaded())
      *      .first()
      *      .subscribe( ... ) // You only get the object once
@@ -529,25 +662,47 @@ public final void removeAllChangeListeners() {
      * corresponding Realm instance doesn't support RxJava.
      * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
      */
-    public final <E extends RealmObject> Observable<E> asObservable() {
+    public final <E extends RealmObject> Flowable<E> asFlowable() {
         //noinspection unchecked
-        return (Observable<E>) RealmObject.asObservable(this);
+        return (Flowable<E>) RealmObject.asFlowable(this);
     }
 
     /**
-     * Returns an RxJava Observable that monitors changes to this RealmObject. It will emit the current object when
+     * Returns an Rx Observable that monitors changes to this RealmObject. It will emit the current RealmObject when
+     * subscribed to. For each update to the RealmObject a pair consisting of the RealmObject and the
+     * {@link ObjectChangeSet} will be sent. The changeset will be {@code null} the first
+     * time the RealmObject is emitted.
+     * <p>
+     * The RealmObject will continually be emitted as it is updated - {@code onComplete} will never be called.
+     * <p>
+     * Note that when the {@link Realm} is accessed from threads other than where it was created,
+     * {@link IllegalStateException} will be thrown. Care should be taken when using different schedulers
+     * with {@code subscribeOn()} and {@code observeOn()}. Consider using {@code Realm.where().find*Async()}
+     * instead.
+     *
+     * @return RxJava Observable that only calls {@code onNext}. It will never call {@code onComplete} or {@code OnError}.
+     * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath or the
+     * corresponding Realm instance doesn't support RxJava.
+     * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
+     */
+    public final <E extends RealmObject> Observable<ObjectChange<E>> asChangesetObservable() {
+        return (Observable) RealmObject.asChangesetObservable(this);
+    }
+
+    /**
+     * Returns an RxJava Flowable that monitors changes to this RealmObject. It will emit the current object when
      * subscribed to. Object updates will continuously be emitted as the RealmObject is updated -
      * {@code onComplete} will never be called.
      * <p>
-     * When chaining a RealmObject observable use {@code obj.<MyRealmObjectClass>asObservable()} to pass on
+     * When chaining a RealmObject observable use {@code obj.<MyRealmObjectClass>asFlowable()} to pass on
      * type information, otherwise the type of the following observables will be {@code RealmObject}.
      * <p>
-     * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
+     * If you would like the {@code asFlowable()} to stop emitting items you can instruct RxJava to
      * emit only the first item by using the {@code first()} operator:
      * <p>
      * <pre>
      * {@code
-     * obj.asObservable()
+     * obj.asFlowable()
      *      .filter(obj -> obj.isLoaded())
      *      .first()
      *      .subscribe( ... ) // You only get the object once
@@ -559,7 +714,7 @@ public final void removeAllChangeListeners() {
      * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath.
      * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
      */
-    public static <E extends RealmModel> Observable<E> asObservable(E object) {
+    public static <E extends RealmModel> Flowable<E> asFlowable(E object) {
         if (object instanceof RealmObjectProxy) {
             RealmObjectProxy proxy = (RealmObjectProxy) object;
             BaseRealm realm = proxy.realmGet$proxyState().getRealm$realm();
@@ -569,7 +724,7 @@ public final void removeAllChangeListeners() {
                 DynamicRealm dynamicRealm = (DynamicRealm) realm;
                 DynamicRealmObject dynamicObject = (DynamicRealmObject) object;
                 @SuppressWarnings("unchecked")
-                Observable<E> observable = (Observable<E>) realm.configuration.getRxFactory().from(dynamicRealm, dynamicObject);
+                Flowable<E> observable = (Flowable<E>) realm.configuration.getRxFactory().from(dynamicRealm, dynamicObject);
                 return observable;
             } else {
                 throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava." +
@@ -580,4 +735,44 @@ public final void removeAllChangeListeners() {
             throw new IllegalArgumentException("Cannot create Observables from unmanaged RealmObjects");
         }
     }
+
+
+    /**
+     * Returns an Rx Observable that monitors changes to this RealmObject. It will emit the current RealmObject when
+     * subscribed to. For each update to the RealmObject a pair consisting of the RealmObject and the
+     * {@link ObjectChangeSet} will be sent. The changeset will be {@code null} the first
+     * time the RealmObject is emitted.
+     * <p>
+     * The RealmObject will continually be emitted as it is updated - {@code onComplete} will never be called.
+     * <p>
+     * Note that when the {@link Realm} is accessed from threads other than where it was created,
+     * {@link IllegalStateException} will be thrown. Care should be taken when using different schedulers
+     * with {@code subscribeOn()} and {@code observeOn()}. Consider using {@code Realm.where().find*Async()}
+     * instead.
+     *
+     * @param object RealmObject class that is being observed. Must be this class or its super types.
+     * @return RxJava Observable that only calls {@code onNext}. It will never call {@code onComplete} or {@code OnError}.
+     * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath or the
+     * corresponding Realm instance doesn't support RxJava.
+     * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
+     */
+    public static <E extends RealmModel> Observable<ObjectChange<E>> asChangesetObservable(E object) {
+        if (object instanceof RealmObjectProxy) {
+            RealmObjectProxy proxy = (RealmObjectProxy) object;
+            BaseRealm realm = proxy.realmGet$proxyState().getRealm$realm();
+            if (realm instanceof Realm) {
+                return realm.configuration.getRxFactory().changesetsFrom((Realm) realm, object);
+            } else if (realm instanceof DynamicRealm) {
+                DynamicRealm dynamicRealm = (DynamicRealm) realm;
+                DynamicRealmObject dynamicObject = (DynamicRealmObject) object;
+                return (Observable) realm.configuration.getRxFactory().changesetsFrom(dynamicRealm, dynamicObject);
+            } else {
+                throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava." +
+                        " See https://realm.io/docs/java/latest/#rxjava for more details.");
+            }
+        } else {
+            // TODO Is this true? Should we just return Observable.just(object) ?
+            throw new IllegalArgumentException("Cannot create Observables from unmanaged RealmObjects");
+        }
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectChangeListener.java b/realm/realm-library/src/main/java/io/realm/RealmObjectChangeListener.java
index af172a0e16..22ce4211d9 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectChangeListener.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectChangeListener.java
@@ -16,6 +16,8 @@
 
 package io.realm;
 
+import javax.annotation.Nullable;
+
 import io.realm.annotations.LinkingObjects;
 
 /**
@@ -51,8 +53,8 @@
      * <p>
      * Changes to {@link LinkingObjects} annotated {@link RealmResults} fields will not be monitored, nor reported
      * through this change listener.
-     * @param object the {@code RealmObject} this listener is registered to.
+     * @param t the {@code RealmObject} this listener is registered to.
      * @param changeSet the detailed information about the changes.
      */
-    void onChange(T object, ObjectChangeSet changeSet);
+    void onChange(T t, @Nullable ObjectChangeSet changeSet);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index bed6061e1f..3442f1074e 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -1,4 +1,3 @@
-package io.realm;
 /*
  * Copyright 2017 Realm Inc.
  *
@@ -15,25 +14,88 @@
  * limitations under the License.
  */
 
+package io.realm;
 
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.Locale;
+import java.util.Map;
 import java.util.Set;
 
+import javax.annotation.Nullable;
+
 import io.realm.annotations.Required;
+import io.realm.internal.ColumnInfo;
+import io.realm.internal.OsObject;
+import io.realm.internal.OsObjectStore;
 import io.realm.internal.Table;
+import io.realm.internal.fields.FieldDescriptor;
 
 
 /**
- * Class for interacting with the schema for a given RealmObject class. This makes it possible to
+ * Class for interacting with the schema for a given RealmObject class. This makes it possible to inspect,
  * add, delete or change the fields for given class.
+ * <p>
+ * If this {@link RealmObjectSchema} is retrieved from an immutable {@link RealmSchema}, this {@link RealmObjectSchema}
+ * will be immutable as well.
  *
  * @see io.realm.RealmMigration
  */
 public abstract class RealmObjectSchema {
 
+    static final Map<Class<?>, FieldMetaData> SUPPORTED_SIMPLE_FIELDS;
+
+    static {
+        Map<Class<?>, FieldMetaData> m = new HashMap<>();
+        m.put(String.class, new FieldMetaData(RealmFieldType.STRING, RealmFieldType.STRING_LIST, true));
+        m.put(short.class, new FieldMetaData(RealmFieldType.INTEGER, RealmFieldType.INTEGER_LIST, false));
+        m.put(Short.class, new FieldMetaData(RealmFieldType.INTEGER, RealmFieldType.INTEGER_LIST, true));
+        m.put(int.class, new FieldMetaData(RealmFieldType.INTEGER, RealmFieldType.INTEGER_LIST, false));
+        m.put(Integer.class, new FieldMetaData(RealmFieldType.INTEGER, RealmFieldType.INTEGER_LIST, true));
+        m.put(long.class, new FieldMetaData(RealmFieldType.INTEGER, RealmFieldType.INTEGER_LIST, false));
+        m.put(Long.class, new FieldMetaData(RealmFieldType.INTEGER, RealmFieldType.INTEGER_LIST, true));
+        m.put(float.class, new FieldMetaData(RealmFieldType.FLOAT, RealmFieldType.FLOAT_LIST, false));
+        m.put(Float.class, new FieldMetaData(RealmFieldType.FLOAT, RealmFieldType.FLOAT_LIST, true));
+        m.put(double.class, new FieldMetaData(RealmFieldType.DOUBLE, RealmFieldType.DOUBLE_LIST, false));
+        m.put(Double.class, new FieldMetaData(RealmFieldType.DOUBLE, RealmFieldType.DOUBLE_LIST, true));
+        m.put(boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, RealmFieldType.BOOLEAN_LIST, false));
+        m.put(Boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, RealmFieldType.BOOLEAN_LIST, true));
+        m.put(byte.class, new FieldMetaData(RealmFieldType.INTEGER, RealmFieldType.INTEGER_LIST, false));
+        m.put(Byte.class, new FieldMetaData(RealmFieldType.INTEGER, RealmFieldType.INTEGER_LIST, true));
+        m.put(byte[].class, new FieldMetaData(RealmFieldType.BINARY, RealmFieldType.BINARY_LIST, true));
+        m.put(Date.class, new FieldMetaData(RealmFieldType.DATE, RealmFieldType.DATE_LIST, true));
+        SUPPORTED_SIMPLE_FIELDS = Collections.unmodifiableMap(m);
+    }
+
+    static final Map<Class<?>, FieldMetaData> SUPPORTED_LINKED_FIELDS;
+
+    static {
+        Map<Class<?>, FieldMetaData> m = new HashMap<>();
+        m.put(RealmObject.class, new FieldMetaData(RealmFieldType.OBJECT, null, false));
+        m.put(RealmList.class, new FieldMetaData(RealmFieldType.LIST, null, false));
+        SUPPORTED_LINKED_FIELDS = Collections.unmodifiableMap(m);
+    }
+
+    final RealmSchema schema;
+    final BaseRealm realm;
+    final Table table;
+    private final ColumnInfo columnInfo;
+
     /**
-     * Release the object schema and any of native resources it might hold.
+     * Creates a schema object for a given Realm class.
+     *
+     * @param realm Realm holding the objects.
+     * @param table table representation of the Realm class
+     * @param columnInfo mapping between field names and column indexes for the given table
      */
-    public abstract void close();
+    RealmObjectSchema(BaseRealm realm, RealmSchema schema, Table table, ColumnInfo columnInfo) {
+        this.schema = schema;
+        this.realm = realm;
+        this.table = table;
+        this.columnInfo = columnInfo;
+    }
 
     /**
      * Returns the name of the RealmObject class being represented by this schema.
@@ -45,7 +107,9 @@
      *
      * @return the name of the RealmObject class represented by this schema.
      */
-    public abstract String getClassName();
+    public String getClassName() {
+        return table.getClassName();
+    }
 
     /**
      * Sets a new name for this RealmObject class. This is equivalent to renaming it.
@@ -53,7 +117,8 @@
      * @param className the new name for this class.
      * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56
      * characters.
-     * @see StandardRealmSchema#rename(String, String)
+     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
+     * @see RealmSchema#rename(String, String)
      */
     public abstract RealmObjectSchema setClassName(String className);
 
@@ -71,6 +136,7 @@
      * @param attributes set of attributes for this field.
      * @return the updated schema.
      * @throws IllegalArgumentException if the type isn't supported, field name is illegal or a field with that name
+     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
      * already exists.
      */
     public abstract RealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes);
@@ -82,25 +148,58 @@
      * @param objectSchema schema for the Realm type being referenced.
      * @return the updated schema.
      * @throws IllegalArgumentException if field name is illegal or a field with that name already exists.
+     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
      */
     public abstract RealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema);
 
     /**
-     * Adds a new field that references a {@link RealmList}.
+     * Adds a new field that contains a {@link RealmList} with references to other Realm model classes.
+     * <p>
+     * If the list contains primitive types, use {@link #addRealmListField(String, Class)} instead.
      *
      * @param fieldName name of the field to add.
      * @param objectSchema schema for the Realm type being referenced.
      * @return the updated schema.
      * @throws IllegalArgumentException if the field name is illegal or a field with that name already exists.
+     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
      */
     public abstract RealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema);
 
+    /**
+     * Adds a new field that references a {@link RealmList} with primitive values. See {@link RealmObject} for the
+     * list of supported types.
+     * <p>
+     * Nullability of elements are defined by using the correct class e.g., {@code Integer.class} instead of
+     * {@code int.class}. Alternatively {@link #setRequired(String, boolean)} can be used.
+     * <p>
+     * Example:
+     * <pre>
+     * {@code
+     * // Defines the list of Strings as being non null.
+     * RealmObjectSchema schema = schema.create("Person")
+     *     .addRealmListField("children", String.class)
+     *     .setRequired("children", true)
+     * }
+     * </pre>
+     * If the list contains references to other Realm classes, use
+     * {@link #addRealmListField(String, RealmObjectSchema)} instead.
+     *
+     * @param fieldName name of the field to add.
+     * @param primitiveType simple type of elements in the array.
+     * @return the updated schema.
+     * @throws IllegalArgumentException if the field name is illegal, a field with that name already exists or
+     * the element type isn't supported.
+     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
+     */
+    public abstract RealmObjectSchema addRealmListField(String fieldName, Class<?> primitiveType);
+
     /**
      * Removes a field from the class.
      *
      * @param fieldName field name to remove.
      * @return the updated schema.
      * @throws IllegalArgumentException if field name doesn't exist.
+     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
      */
     public abstract RealmObjectSchema removeField(String fieldName);
 
@@ -111,6 +210,7 @@
      * @param newFieldName the new field name.
      * @return the updated schema.
      * @throws IllegalArgumentException if field name doesn't exist or if the new field name already exists.
+     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
      */
     public abstract RealmObjectSchema renameField(String currentFieldName, String newFieldName);
 
@@ -120,7 +220,9 @@
      * @param fieldName field name to test.
      * @return {@code true} if the field exists, {@code false} otherwise.
      */
-    public abstract boolean hasField(String fieldName);
+    public boolean hasField(String fieldName) {
+        return table.getColumnIndex(fieldName) != Table.NO_MATCH;
+    }
 
     /**
      * Adds an index to a given field. This is the equivalent of adding the {@link io.realm.annotations.Index}
@@ -130,6 +232,7 @@
      * @return the updated schema.
      * @throws IllegalArgumentException if field name doesn't exist, the field cannot be indexed or it already has a
      * index defined.
+     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
      */
     public abstract RealmObjectSchema addIndex(String fieldName);
 
@@ -141,7 +244,11 @@
      * @throws IllegalArgumentException if field name doesn't exist.
      * @see io.realm.annotations.Index
      */
-    public abstract boolean hasIndex(String fieldName);
+    public boolean hasIndex(String fieldName) {
+        checkLegalName(fieldName);
+        checkFieldExists(fieldName);
+        return table.hasSearchIndex(table.getColumnIndex(fieldName));
+    }
 
     /**
      * Removes an index from a given field. This is the same as removing the {@code @Index} annotation on the field.
@@ -149,6 +256,7 @@
      * @param fieldName field to remove index from.
      * @return the updated schema.
      * @throws IllegalArgumentException if field name doesn't exist or the field doesn't have an index.
+     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
      */
     public abstract RealmObjectSchema removeIndex(String fieldName);
 
@@ -161,6 +269,7 @@
      * @return the updated schema.
      * @throws IllegalArgumentException if field name doesn't exist, the field cannot be a primary key or it already
      * has a primary key defined.
+     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable or this method is called on a synced Realm.
      */
     public abstract RealmObjectSchema addPrimaryKey(String fieldName);
 
@@ -171,18 +280,23 @@
      *
      * @return the updated schema.
      * @throws IllegalArgumentException if the class doesn't have a primary key defined.
+     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
      */
     public abstract RealmObjectSchema removePrimaryKey();
 
     /**
      * Sets a field to be required i.e., it is not allowed to hold {@code null} values. This is equivalent to switching
      * between boxed types and their primitive variant e.g., {@code Integer} to {@code int}.
+     * <p>
+     * If the type of designated field is a list of values (not {@link RealmObject}s , specified nullability
+     * only affects its elements, not the field itself. Value list itself is always non-nullable.
      *
      * @param fieldName name of field in the class.
      * @param required {@code true} if field should be required, {@code false} otherwise.
      * @return the updated schema.
      * @throws IllegalArgumentException if the field name doesn't exist, cannot have the {@link Required} annotation or
      * the field already have been set as required.
+     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
      * @see Required
      */
     public abstract RealmObjectSchema setRequired(String fieldName, boolean required);
@@ -190,11 +304,15 @@
     /**
      * Sets a field to be nullable i.e., it should be able to hold {@code null} values. This is equivalent to switching
      * between primitive types and their boxed variant e.g., {@code int} to {@code Integer}.
+     * <p>
+     * If the type of designated field is a list of values (not {@link RealmObject}s , specified nullability
+     * only affects its elements, not the field itself. Value list itself is always non-nullable.
      *
      * @param fieldName name of field in the class.
      * @param nullable {@code true} if field should be nullable, {@code false} otherwise.
      * @return the updated schema.
      * @throws IllegalArgumentException if the field name doesn't exist, or cannot be set as nullable.
+     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
      */
     public abstract RealmObjectSchema setNullable(String fieldName, boolean nullable);
 
@@ -206,7 +324,10 @@
      * @throws IllegalArgumentException if field name doesn't exist.
      * @see #setRequired(String, boolean)
      */
-    public abstract boolean isRequired(String fieldName);
+    public boolean isRequired(String fieldName) {
+        long columnIndex = getColumnIndex(fieldName);
+        return !table.isColumnNullable(columnIndex);
+    }
 
     /**
      * Checks if a given field is nullable i.e., it is allowed to contain {@code null} values.
@@ -216,7 +337,10 @@
      * @throws IllegalArgumentException if field name doesn't exist.
      * @see #setNullable(String, boolean)
      */
-    public abstract boolean isNullable(String fieldName);
+    public boolean isNullable(String fieldName) {
+        long columnIndex = getColumnIndex(fieldName);
+        return table.isColumnNullable(columnIndex);
+    }
 
     /**
      * Checks if a given field is the primary key field.
@@ -226,7 +350,10 @@
      * @throws IllegalArgumentException if field name doesn't exist.
      * @see #addPrimaryKey(String)
      */
-    public abstract boolean isPrimaryKey(String fieldName);
+    public boolean isPrimaryKey(String fieldName) {
+        checkFieldExists(fieldName);
+        return fieldName.equals(OsObjectStore.getPrimaryKeyForObject(realm.sharedRealm, getClassName()));
+    }
 
     /**
      * Checks if the class has a primary key defined.
@@ -234,7 +361,9 @@
      * @return {@code true} if a primary key is defined, {@code false} otherwise.
      * @see io.realm.annotations.PrimaryKey
      */
-    public abstract boolean hasPrimaryKey();
+    public boolean hasPrimaryKey() {
+        return OsObjectStore.getPrimaryKeyForObject(realm.sharedRealm, getClassName()) != null;
+    }
 
     /**
      * Returns the name of the primary key field.
@@ -242,35 +371,102 @@
      * @return the name of the primary key field.
      * @throws IllegalStateException if the class doesn't have a primary key defined.
      */
-    public abstract String getPrimaryKey();
+    public String getPrimaryKey() {
+        String pkField = OsObjectStore.getPrimaryKeyForObject(realm.sharedRealm, getClassName());
+        if (pkField == null) {
+            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
+        }
+        return pkField;
+    }
 
     /**
      * Returns all fields in this class.
      *
      * @return a list of all the fields in this class.
      */
-    public abstract Set<String> getFieldNames();
+    public Set<String> getFieldNames() {
+        int columnCount = (int) table.getColumnCount();
+        Set<String> columnNames = new LinkedHashSet<>(columnCount);
+        for (int i = 0; i < columnCount; i++) {
+            String name = table.getColumnName(i);
+            if (!OsObject.isObjectIdColumn(name)) {
+                columnNames.add(name);
+            }
+        }
+        return columnNames;
+    }
 
     /**
      * Runs a transformation function on each RealmObject instance of the current class. The object will be represented
      * as a {@link DynamicRealmObject}.
      *
+     * @param function transformation function.
      * @return this schema.
+     * @throws UnsupportedOperationException if this {@link RealmObjectSchema} is immutable.
      */
     public abstract RealmObjectSchema transform(Function function);
 
     /**
      * Returns the type used by the underlying storage engine to represent this field.
      *
+     * @param fieldName name of the target field.
      * @return the underlying type used by Realm to represent this field.
      */
-    public abstract RealmFieldType getFieldType(String fieldName);
+    public RealmFieldType getFieldType(String fieldName) {
+        long columnIndex = getColumnIndex(fieldName);
+        return table.getColumnType(columnIndex);
+    }
+
+    /**
+     * Get a parser for a field descriptor.
+     *
+     * @param fieldDescription fieldName or link path to a field name.
+     * @param validColumnTypes valid field type for the last field in a linked field
+     * @return a FieldDescriptor
+     */
+    protected final FieldDescriptor getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
+        return FieldDescriptor.createStandardFieldDescriptor(getSchemaConnector(), getTable(), fieldDescription, validColumnTypes);
+    }
+
+    RealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
+        long columnIndex = table.addColumn(type, name, (required) ? Table.NOT_NULLABLE : Table.NULLABLE);
+
+        if (indexed) { table.addSearchIndex(columnIndex); }
+
+        if (primary) {
+            OsObjectStore.setPrimaryKeyForObject(realm.sharedRealm, getClassName(), name);
+        }
 
-    abstract long[] getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes);
+        return this;
+    }
+
+    RealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
+        table.addColumnLink(
+                type,
+                name,
+                realm.getSharedRealm().getTable(Table.getTableNameForClass(linkedTo.getClassName())));
+        return this;
+    }
 
-    abstract RealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required);
+    long getAndCheckFieldIndex(String fieldName) {
+        long index = columnInfo.getColumnIndex(fieldName);
+        if (index < 0) {
+            throw new IllegalArgumentException("Field does not exist: " + fieldName);
+        }
+        return index;
+    }
 
-    abstract RealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo);
+    Table getTable() {
+        return table;
+    }
+
+    static final Map<Class<?>, FieldMetaData> getSupportedSimpleFields() {
+        return SUPPORTED_SIMPLE_FIELDS;
+    }
+
+    private SchemaConnector getSchemaConnector() {
+        return new SchemaConnector(schema);
+    }
 
     /**
      * Function interface, used when traversing all objects of the current class and apply a function on each.
@@ -281,17 +477,94 @@
         void apply(DynamicRealmObject obj);
     }
 
-    // Tuple containing data about each supported Java type.
-    protected static class FieldMetaData {
-        protected final RealmFieldType realmType;
-        protected final boolean defaultNullable;
+    /**
+     * Returns the column index in the underlying table for the given field name.
+     * <b>FOR TESTING USE ONLY!</b>
+     *
+     * @param fieldName field name to find index for.
+     * @return column index or -1 if it doesn't exists.
+     */
+    //@VisibleForTesting(otherwise = VisibleForTesting.NONE)
+    long getFieldIndex(String fieldName) {
+        return columnInfo.getColumnIndex(fieldName);
+    }
 
-        protected FieldMetaData(RealmFieldType realmType, boolean defaultNullable) {
-            this.realmType = realmType;
-            this.defaultNullable = defaultNullable;
+    static void checkLegalName(String fieldName) {
+        //noinspection ConstantConditions
+        if (fieldName == null || fieldName.isEmpty()) {
+            throw new IllegalArgumentException("Field name can not be null or empty");
+        }
+        if (fieldName.contains(".")) {
+            throw new IllegalArgumentException("Field name can not contain '.'");
+        }
+        if (fieldName.length() > 63) {
+            throw new IllegalArgumentException("Field name is currently limited to max 63 characters.");
         }
     }
 
-    abstract Table getTable();
-    abstract long getAndCheckFieldIndex(String fieldName);
+    void checkFieldExists(String fieldName) {
+        if (table.getColumnIndex(fieldName) == Table.NO_MATCH) {
+            throw new IllegalArgumentException("Field name doesn't exist on object '" + getClassName() + "': " + fieldName);
+        }
+    }
+
+    long getColumnIndex(String fieldName) {
+        long columnIndex = table.getColumnIndex(fieldName);
+        if (columnIndex == -1) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.US,
+                            "Field name '%s' does not exist on schema for '%s'",
+                            fieldName, getClassName()
+                    ));
+        }
+        return columnIndex;
+    }
+
+    static final class DynamicColumnIndices extends ColumnInfo {
+        private final Table table;
+
+        DynamicColumnIndices(Table table) {
+            super(null, false);
+            this.table = table;
+        }
+
+        @Override
+        public long getColumnIndex(String columnName) {
+            return table.getColumnIndex(columnName);
+        }
+
+        @Override
+        public ColumnDetails getColumnDetails(String columnName) {
+            throw new UnsupportedOperationException("DynamicColumnIndices do not support 'getColumnDetails'");
+        }
+
+        @Override
+        public void copyFrom(ColumnInfo src) {
+            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
+        }
+
+        @Override
+        protected ColumnInfo copy(boolean immutable) {
+            throw new UnsupportedOperationException("DynamicColumnIndices cannot be copied");
+        }
+
+
+        @Override
+        protected void copy(ColumnInfo src, ColumnInfo dst) {
+            throw new UnsupportedOperationException("DynamicColumnIndices cannot copy");
+        }
+    }
+
+    // Tuple containing data about each supported Java type.
+    static final class FieldMetaData {
+        final RealmFieldType fieldType; // Underlying Realm type for fields with this type
+        final RealmFieldType listType; // Underlying Realm type for RealmLists containing this type
+        final boolean defaultNullable;
+
+        FieldMetaData(RealmFieldType fieldType, @Nullable RealmFieldType listType, boolean defaultNullable) {
+            this.fieldType = fieldType;
+            this.listType = listType;
+            this.defaultNullable = defaultNullable;
+        }
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index e9fbfdd5cb..89fafb6b95 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -19,16 +19,20 @@
 
 import java.util.Collections;
 import java.util.Date;
+import java.util.Locale;
+
+import javax.annotation.Nullable;
 
 import io.realm.annotations.Required;
-import io.realm.internal.Collection;
-import io.realm.internal.LinkView;
+import io.realm.internal.OsResults;
+import io.realm.internal.OsList;
 import io.realm.internal.PendingRow;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.SortDescriptor;
 import io.realm.internal.Table;
 import io.realm.internal.TableQuery;
+import io.realm.internal.fields.FieldDescriptor;
 
 
 /**
@@ -49,7 +53,7 @@
  * @see Realm#where(Class)
  * @see RealmResults#where()
  */
-public class RealmQuery<E extends RealmModel> {
+public class RealmQuery<E> {
 
     private final Table table;
     private final BaseRealm realm;
@@ -57,10 +61,12 @@
     private final RealmObjectSchema schema;
     private Class<E> clazz;
     private String className;
-    private LinkView linkView;
+    private final boolean forValues;
+    private final OsList osList;
+
     private static final String TYPE_MISMATCH = "Field '%s': type mismatch - %s expected.";
     private static final String EMPTY_VALUES = "Non-empty 'values' must be provided.";
-    static final String ASYNC_QUERY_WRONG_THREAD_MESSAGE = "Async query cannot be created on current thread.";
+    private static final String ASYNC_QUERY_WRONG_THREAD_MESSAGE = "Async query cannot be created on current thread.";
 
     /**
      * Creates a query for objects of a given class from a {@link Realm}.
@@ -70,7 +76,7 @@
      * @return {@link RealmQuery} object. After building the query call one of the {@code find*} methods
      * to run it.
      */
-    public static <E extends RealmModel> RealmQuery<E> createQuery(Realm realm, Class<E> clazz) {
+    static <E extends RealmModel> RealmQuery<E> createQuery(Realm realm, Class<E> clazz) {
         return new RealmQuery<>(realm, clazz);
     }
 
@@ -82,7 +88,7 @@
      * @return {@link RealmQuery} object. After building the query call one of the {@code find*} methods
      * to run it.
      */
-    public static <E extends RealmModel> RealmQuery<E> createDynamicQuery(DynamicRealm realm, String className) {
+    static <E extends RealmModel> RealmQuery<E> createDynamicQuery(DynamicRealm realm, String className) {
         return new RealmQuery<>(realm, className);
     }
 
@@ -93,14 +99,12 @@
      * @return {@link RealmQuery} object. After building the query call one of the {@code find*} methods
      * to run it.
      */
-
     @SuppressWarnings("unchecked")
-    public static <E extends RealmModel> RealmQuery<E> createQueryFromResult(RealmResults<E> queryResults) {
-        if (queryResults.classSpec != null) {
-            return new RealmQuery<>(queryResults, queryResults.classSpec);
-        } else {
-            return new RealmQuery(queryResults, queryResults.className);
-        }
+    static <E> RealmQuery<E> createQueryFromResult(RealmResults<E> queryResults) {
+        //noinspection ConstantConditions
+        return (queryResults.classSpec == null)
+                ? new RealmQuery(queryResults, queryResults.className)
+                : new RealmQuery<>(queryResults, queryResults.classSpec);
     }
 
     /**
@@ -111,64 +115,102 @@
      * to run it.
      */
     @SuppressWarnings("unchecked")
-    public static <E extends RealmModel> RealmQuery<E> createQueryFromList(RealmList<E> list) {
-        if (list.clazz != null) {
-            return new RealmQuery(list.realm, list.view, list.clazz);
-        } else {
-            return new RealmQuery(list.realm, list.view, list.className);
-        }
+    static <E> RealmQuery<E> createQueryFromList(RealmList<E> list) {
+        //noinspection ConstantConditions
+        return (list.clazz == null)
+                ? new RealmQuery(list.realm, list.getOsList(), list.className)
+                : new RealmQuery(list.realm, list.getOsList(), list.clazz);
+    }
+
+    private static boolean isClassForRealmModel(Class<?> clazz) {
+        return RealmModel.class.isAssignableFrom(clazz);
     }
 
     private RealmQuery(Realm realm, Class<E> clazz) {
         this.realm = realm;
         this.clazz = clazz;
-        this.schema = realm.getSchema().getSchemaForClass(clazz);
-        this.table = schema.getTable();
-        this.linkView = null;
-        this.query = table.where();
+        this.forValues = !isClassForRealmModel(clazz);
+        if (forValues) {
+            // TODO implement this
+            this.schema = null;
+            this.table = null;
+            this.osList = null;
+            this.query = null;
+        } else {
+            //noinspection unchecked
+            this.schema = realm.getSchema().getSchemaForClass((Class<? extends RealmModel>) clazz);
+            this.table = schema.getTable();
+            this.osList = null;
+            this.query = table.where();
+        }
     }
 
     private RealmQuery(RealmResults<E> queryResults, Class<E> clazz) {
         this.realm = queryResults.realm;
         this.clazz = clazz;
-        this.schema = realm.getSchema().getSchemaForClass(clazz);
-        this.table = queryResults.getTable();
-        this.linkView = null;
-        this.query = queryResults.getCollection().where();
+        this.forValues = !isClassForRealmModel(clazz);
+        if (forValues) {
+            // TODO implement this
+            this.schema = null;
+            this.table = null;
+            this.osList = null;
+            this.query = null;
+        } else {
+            //noinspection unchecked
+            this.schema = realm.getSchema().getSchemaForClass((Class<? extends RealmModel>) clazz);
+            this.table = queryResults.getTable();
+            this.osList = null;
+            this.query = queryResults.getOsResults().where();
+        }
     }
 
-    private RealmQuery(BaseRealm realm, LinkView linkView, Class<E> clazz) {
+    private RealmQuery(BaseRealm realm, OsList osList, Class<E> clazz) {
         this.realm = realm;
         this.clazz = clazz;
-        this.schema = realm.getSchema().getSchemaForClass(clazz);
-        this.table = schema.getTable();
-        this.linkView = linkView;
-        this.query = linkView.where();
+        this.forValues = !isClassForRealmModel(clazz);
+        if (forValues) {
+            // TODO implement this
+            this.schema = null;
+            this.table = null;
+            this.osList = null;
+            this.query = null;
+        } else {
+            //noinspection unchecked
+            this.schema = realm.getSchema().getSchemaForClass((Class<? extends RealmModel>) clazz);
+            this.table = schema.getTable();
+            this.osList = osList;
+            this.query = osList.getQuery();
+        }
     }
 
     private RealmQuery(BaseRealm realm, String className) {
         this.realm = realm;
         this.className = className;
+        this.forValues = false;
         this.schema = realm.getSchema().getSchemaForClass(className);
         this.table = schema.getTable();
         this.query = table.where();
+        this.osList = null;
     }
 
     private RealmQuery(RealmResults<DynamicRealmObject> queryResults, String className) {
         this.realm = queryResults.realm;
         this.className = className;
+        this.forValues = false;
         this.schema = realm.getSchema().getSchemaForClass(className);
         this.table = schema.getTable();
-        this.query = queryResults.getCollection().where();
+        this.query = queryResults.getOsResults().where();
+        this.osList = null;
     }
 
-    private RealmQuery(BaseRealm realm, LinkView linkView, String className) {
+    private RealmQuery(BaseRealm realm, OsList osList, String className) {
         this.realm = realm;
         this.className = className;
+        this.forValues = false;
         this.schema = realm.getSchema().getSchemaForClass(className);
         this.table = schema.getTable();
-        this.linkView = linkView;
-        this.query = linkView.where();
+        this.query = osList.getQuery();
+        this.osList = osList;
     }
 
     /**
@@ -182,8 +224,8 @@ public boolean isValid() {
             return false;
         }
 
-        if (linkView != null) {
-            return linkView.isAttached();
+        if (osList != null) {
+            return osList.isValid();
         }
         return table != null && table.isValid();
     }
@@ -203,10 +245,10 @@ public boolean isValid() {
     public RealmQuery<E> isNull(String fieldName) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName);
 
         // Checks that fieldName has the correct type is done in C++.
-        this.query.isNull(columnIndices);
+        this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         return this;
     }
 
@@ -221,10 +263,10 @@ public boolean isValid() {
     public RealmQuery<E> isNotNull(String fieldName) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName);
 
         // Checks that fieldName has the correct type is done in C++.
-        this.query.isNotNull(columnIndices);
+        this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         return this;
     }
 
@@ -236,7 +278,7 @@ public boolean isValid() {
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> equalTo(String fieldName, String value) {
+    public RealmQuery<E> equalTo(String fieldName, @Nullable String value) {
         return this.equalTo(fieldName, value, Case.SENSITIVE);
     }
 
@@ -249,15 +291,15 @@ public boolean isValid() {
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> equalTo(String fieldName, String value, Case casing) {
+    public RealmQuery<E> equalTo(String fieldName, @Nullable String value, Case casing) {
         realm.checkIfValid();
 
         return equalToWithoutThreadValidation(fieldName, value, casing);
     }
 
-    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, String value, Case casing) {
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
-        this.query.equalTo(columnIndices, value, casing);
+    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, @Nullable String value, Case casing) {
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value, casing);
         return this;
     }
 
@@ -269,18 +311,18 @@ public boolean isValid() {
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> equalTo(String fieldName, Byte value) {
+    public RealmQuery<E> equalTo(String fieldName, @Nullable Byte value) {
         realm.checkIfValid();
 
         return equalToWithoutThreadValidation(fieldName, value);
     }
 
-    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Byte value) {
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, @Nullable Byte value) {
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
-            this.query.isNull(columnIndices);
+            this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.equalTo(columnIndices, value);
+            this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -293,14 +335,14 @@ public boolean isValid() {
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> equalTo(String fieldName, byte[] value) {
+    public RealmQuery<E> equalTo(String fieldName, @Nullable byte[] value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.BINARY);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.BINARY);
         if (value == null) {
-            this.query.isNull(columnIndices);
+            this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.equalTo(columnIndices, value);
+            this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -313,18 +355,18 @@ public boolean isValid() {
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> equalTo(String fieldName, Short value) {
+    public RealmQuery<E> equalTo(String fieldName, @Nullable Short value) {
         realm.checkIfValid();
 
         return equalToWithoutThreadValidation(fieldName, value);
     }
 
-    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Short value) {
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, @Nullable Short value) {
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
-            this.query.isNull(columnIndices);
+            this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.equalTo(columnIndices, value);
+            this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -337,18 +379,18 @@ public boolean isValid() {
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> equalTo(String fieldName, Integer value) {
+    public RealmQuery<E> equalTo(String fieldName, @Nullable Integer value) {
         realm.checkIfValid();
 
         return equalToWithoutThreadValidation(fieldName, value);
     }
 
-    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Integer value) {
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, @Nullable Integer value) {
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
-            this.query.isNull(columnIndices);
+            this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.equalTo(columnIndices, value);
+            this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -361,18 +403,18 @@ public boolean isValid() {
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> equalTo(String fieldName, Long value) {
+    public RealmQuery<E> equalTo(String fieldName, @Nullable Long value) {
         realm.checkIfValid();
 
         return equalToWithoutThreadValidation(fieldName, value);
     }
 
-    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Long value) {
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, @Nullable Long value) {
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
-            this.query.isNull(columnIndices);
+            this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.equalTo(columnIndices, value);
+            this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -385,18 +427,18 @@ public boolean isValid() {
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> equalTo(String fieldName, Double value) {
+    public RealmQuery<E> equalTo(String fieldName, @Nullable Double value) {
         realm.checkIfValid();
 
         return equalToWithoutThreadValidation(fieldName, value);
     }
 
-    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Double value) {
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, @Nullable Double value) {
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
         if (value == null) {
-            this.query.isNull(columnIndices);
+            this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.equalTo(columnIndices, value);
+            this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -409,18 +451,18 @@ public boolean isValid() {
      * @return The query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> equalTo(String fieldName, Float value) {
+    public RealmQuery<E> equalTo(String fieldName, @Nullable Float value) {
         realm.checkIfValid();
 
         return equalToWithoutThreadValidation(fieldName, value);
     }
 
-    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Float value) {
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, @Nullable Float value) {
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
         if (value == null) {
-            this.query.isNull(columnIndices);
+            this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.equalTo(columnIndices, value);
+            this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -433,18 +475,18 @@ public boolean isValid() {
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> equalTo(String fieldName, Boolean value) {
+    public RealmQuery<E> equalTo(String fieldName, @Nullable Boolean value) {
         realm.checkIfValid();
 
         return equalToWithoutThreadValidation(fieldName, value);
     }
 
-    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Boolean value) {
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.BOOLEAN);
+    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, @Nullable Boolean value) {
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.BOOLEAN);
         if (value == null) {
-            this.query.isNull(columnIndices);
+            this.query.isNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.equalTo(columnIndices, value);
+            this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -457,15 +499,15 @@ public boolean isValid() {
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> equalTo(String fieldName, Date value) {
+    public RealmQuery<E> equalTo(String fieldName, @Nullable Date value) {
         realm.checkIfValid();
 
         return equalToWithoutThreadValidation(fieldName, value);
     }
 
-    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Date value) {
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
-        this.query.equalTo(columnIndices, value);
+    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, @Nullable Date value) {
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -495,6 +537,7 @@ public boolean isValid() {
     public RealmQuery<E> in(String fieldName, String[] values, Case casing) {
         realm.checkIfValid();
 
+        //noinspection ConstantConditions
         if (values == null || values.length == 0) {
             throw new IllegalArgumentException(EMPTY_VALUES);
         }
@@ -517,6 +560,7 @@ public boolean isValid() {
     public RealmQuery<E> in(String fieldName, Byte[] values) {
         realm.checkIfValid();
 
+        //noinspection ConstantConditions
         if (values == null || values.length == 0) {
             throw new IllegalArgumentException(EMPTY_VALUES);
         }
@@ -539,6 +583,7 @@ public boolean isValid() {
     public RealmQuery<E> in(String fieldName, Short[] values) {
         realm.checkIfValid();
 
+        //noinspection ConstantConditions
         if (values == null || values.length == 0) {
             throw new IllegalArgumentException(EMPTY_VALUES);
         }
@@ -561,6 +606,7 @@ public boolean isValid() {
     public RealmQuery<E> in(String fieldName, Integer[] values) {
         realm.checkIfValid();
 
+        //noinspection ConstantConditions
         if (values == null || values.length == 0) {
             throw new IllegalArgumentException(EMPTY_VALUES);
         }
@@ -583,6 +629,7 @@ public boolean isValid() {
     public RealmQuery<E> in(String fieldName, Long[] values) {
         realm.checkIfValid();
 
+        //noinspection ConstantConditions
         if (values == null || values.length == 0) {
             throw new IllegalArgumentException(EMPTY_VALUES);
         }
@@ -605,6 +652,7 @@ public boolean isValid() {
     public RealmQuery<E> in(String fieldName, Double[] values) {
         realm.checkIfValid();
 
+        //noinspection ConstantConditions
         if (values == null || values.length == 0) {
             throw new IllegalArgumentException(EMPTY_VALUES);
         }
@@ -627,6 +675,7 @@ public boolean isValid() {
     public RealmQuery<E> in(String fieldName, Float[] values) {
         realm.checkIfValid();
 
+        //noinspection ConstantConditions
         if (values == null || values.length == 0) {
             throw new IllegalArgumentException(EMPTY_VALUES);
         }
@@ -649,6 +698,7 @@ public boolean isValid() {
     public RealmQuery<E> in(String fieldName, Boolean[] values) {
         realm.checkIfValid();
 
+        //noinspection ConstantConditions
         if (values == null || values.length == 0) {
             throw new IllegalArgumentException(EMPTY_VALUES);
         }
@@ -671,6 +721,7 @@ public boolean isValid() {
     public RealmQuery<E> in(String fieldName, Date[] values) {
         realm.checkIfValid();
 
+        //noinspection ConstantConditions
         if (values == null || values.length == 0) {
             throw new IllegalArgumentException(EMPTY_VALUES);
         }
@@ -689,7 +740,7 @@ public boolean isValid() {
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> notEqualTo(String fieldName, String value) {
+    public RealmQuery<E> notEqualTo(String fieldName, @Nullable String value) {
         return this.notEqualTo(fieldName, value, Case.SENSITIVE);
     }
 
@@ -702,14 +753,14 @@ public boolean isValid() {
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> notEqualTo(String fieldName, String value, Case casing) {
+    public RealmQuery<E> notEqualTo(String fieldName, @Nullable String value, Case casing) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
-        if (columnIndices.length > 1 && !casing.getValue()) {
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        if (fd.length() > 1 && !casing.getValue()) {
             throw new IllegalArgumentException("Link queries cannot be case insensitive - coming soon.");
         }
-        this.query.notEqualTo(columnIndices, value, casing);
+        this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value, casing);
         return this;
     }
 
@@ -721,14 +772,14 @@ public boolean isValid() {
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> notEqualTo(String fieldName, Byte value) {
+    public RealmQuery<E> notEqualTo(String fieldName, @Nullable Byte value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
-            this.query.isNotNull(columnIndices);
+            this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.notEqualTo(columnIndices, value);
+            this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -741,14 +792,14 @@ public boolean isValid() {
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> notEqualTo(String fieldName, byte[] value) {
+    public RealmQuery<E> notEqualTo(String fieldName, @Nullable byte[] value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.BINARY);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.BINARY);
         if (value == null) {
-            this.query.isNotNull(columnIndices);
+            this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.notEqualTo(columnIndices, value);
+            this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -761,14 +812,14 @@ public boolean isValid() {
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> notEqualTo(String fieldName, Short value) {
+    public RealmQuery<E> notEqualTo(String fieldName, @Nullable Short value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
-            this.query.isNotNull(columnIndices);
+            this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.notEqualTo(columnIndices, value);
+            this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -781,14 +832,14 @@ public boolean isValid() {
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> notEqualTo(String fieldName, Integer value) {
+    public RealmQuery<E> notEqualTo(String fieldName, @Nullable Integer value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
-            this.query.isNotNull(columnIndices);
+            this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.notEqualTo(columnIndices, value);
+            this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -801,14 +852,14 @@ public boolean isValid() {
      * @return the query object
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> notEqualTo(String fieldName, Long value) {
+    public RealmQuery<E> notEqualTo(String fieldName, @Nullable Long value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
-            this.query.isNotNull(columnIndices);
+            this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.notEqualTo(columnIndices, value);
+            this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -821,14 +872,14 @@ public boolean isValid() {
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> notEqualTo(String fieldName, Double value) {
+    public RealmQuery<E> notEqualTo(String fieldName, @Nullable Double value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
         if (value == null) {
-            this.query.isNotNull(columnIndices);
+            this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.notEqualTo(columnIndices, value);
+            this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -841,14 +892,14 @@ public boolean isValid() {
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> notEqualTo(String fieldName, Float value) {
+    public RealmQuery<E> notEqualTo(String fieldName, @Nullable Float value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
         if (value == null) {
-            this.query.isNotNull(columnIndices);
+            this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.notEqualTo(columnIndices, value);
+            this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -861,14 +912,14 @@ public boolean isValid() {
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> notEqualTo(String fieldName, Boolean value) {
+    public RealmQuery<E> notEqualTo(String fieldName, @Nullable Boolean value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.BOOLEAN);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.BOOLEAN);
         if (value == null) {
-            this.query.isNotNull(columnIndices);
+            this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.equalTo(columnIndices, !value);
+            this.query.equalTo(fd.getColumnIndices(), fd.getNativeTablePointers(), !value);
         }
         return this;
     }
@@ -881,14 +932,14 @@ public boolean isValid() {
      * @return the query object.
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
-    public RealmQuery<E> notEqualTo(String fieldName, Date value) {
+    public RealmQuery<E> notEqualTo(String fieldName, @Nullable Date value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
         if (value == null) {
-            this.query.isNotNull(columnIndices);
+            this.query.isNotNull(fd.getColumnIndices(), fd.getNativeTablePointers());
         } else {
-            this.query.notEqualTo(columnIndices, value);
+            this.query.notEqualTo(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         }
         return this;
     }
@@ -904,8 +955,8 @@ public boolean isValid() {
     public RealmQuery<E> greaterThan(String fieldName, int value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
-        this.query.greaterThan(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.greaterThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -920,8 +971,8 @@ public boolean isValid() {
     public RealmQuery<E> greaterThan(String fieldName, long value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
-        this.query.greaterThan(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.greaterThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -936,8 +987,8 @@ public boolean isValid() {
     public RealmQuery<E> greaterThan(String fieldName, double value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
-        this.query.greaterThan(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        this.query.greaterThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -952,8 +1003,8 @@ public boolean isValid() {
     public RealmQuery<E> greaterThan(String fieldName, float value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
-        this.query.greaterThan(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        this.query.greaterThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -968,8 +1019,8 @@ public boolean isValid() {
     public RealmQuery<E> greaterThan(String fieldName, Date value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
-        this.query.greaterThan(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        this.query.greaterThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -984,8 +1035,8 @@ public boolean isValid() {
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, int value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
-        this.query.greaterThanOrEqual(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.greaterThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1000,8 +1051,8 @@ public boolean isValid() {
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, long value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
-        this.query.greaterThanOrEqual(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.greaterThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1016,8 +1067,8 @@ public boolean isValid() {
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, double value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
-        this.query.greaterThanOrEqual(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        this.query.greaterThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1032,8 +1083,8 @@ public boolean isValid() {
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, float value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
-        this.query.greaterThanOrEqual(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        this.query.greaterThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1048,8 +1099,8 @@ public boolean isValid() {
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, Date value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
-        this.query.greaterThanOrEqual(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        this.query.greaterThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1064,8 +1115,8 @@ public boolean isValid() {
     public RealmQuery<E> lessThan(String fieldName, int value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
-        this.query.lessThan(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.lessThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1080,8 +1131,8 @@ public boolean isValid() {
     public RealmQuery<E> lessThan(String fieldName, long value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
-        this.query.lessThan(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.lessThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1096,8 +1147,8 @@ public boolean isValid() {
     public RealmQuery<E> lessThan(String fieldName, double value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
-        this.query.lessThan(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        this.query.lessThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1112,8 +1163,8 @@ public boolean isValid() {
     public RealmQuery<E> lessThan(String fieldName, float value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
-        this.query.lessThan(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        this.query.lessThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1128,8 +1179,8 @@ public boolean isValid() {
     public RealmQuery<E> lessThan(String fieldName, Date value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
-        this.query.lessThan(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        this.query.lessThan(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1144,8 +1195,8 @@ public boolean isValid() {
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, int value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
-        this.query.lessThanOrEqual(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.lessThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1160,8 +1211,8 @@ public boolean isValid() {
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, long value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
-        this.query.lessThanOrEqual(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.lessThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1176,8 +1227,8 @@ public boolean isValid() {
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, double value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
-        this.query.lessThanOrEqual(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        this.query.lessThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1192,8 +1243,8 @@ public boolean isValid() {
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, float value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
-        this.query.lessThanOrEqual(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        this.query.lessThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1208,8 +1259,8 @@ public boolean isValid() {
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, Date value) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
-        this.query.lessThanOrEqual(columnIndices, value);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        this.query.lessThanOrEqual(fd.getColumnIndices(), fd.getNativeTablePointers(), value);
         return this;
     }
 
@@ -1225,8 +1276,8 @@ public boolean isValid() {
     public RealmQuery<E> between(String fieldName, int from, int to) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
-        this.query.between(columnIndices, from, to);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.between(fd.getColumnIndices(), from, to);
         return this;
     }
 
@@ -1242,8 +1293,8 @@ public boolean isValid() {
     public RealmQuery<E> between(String fieldName, long from, long to) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
-        this.query.between(columnIndices, from, to);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
+        this.query.between(fd.getColumnIndices(), from, to);
         return this;
     }
 
@@ -1259,8 +1310,8 @@ public boolean isValid() {
     public RealmQuery<E> between(String fieldName, double from, double to) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
-        this.query.between(columnIndices, from, to);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
+        this.query.between(fd.getColumnIndices(), from, to);
         return this;
     }
 
@@ -1276,8 +1327,8 @@ public boolean isValid() {
     public RealmQuery<E> between(String fieldName, float from, float to) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
-        this.query.between(columnIndices, from, to);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
+        this.query.between(fd.getColumnIndices(), from, to);
         return this;
     }
 
@@ -1293,8 +1344,8 @@ public boolean isValid() {
     public RealmQuery<E> between(String fieldName, Date from, Date to) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
-        this.query.between(columnIndices, from, to);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
+        this.query.between(fd.getColumnIndices(), from, to);
         return this;
     }
 
@@ -1323,8 +1374,8 @@ public boolean isValid() {
     public RealmQuery<E> contains(String fieldName, String value, Case casing) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
-        this.query.contains(columnIndices, value, casing);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        this.query.contains(fd.getColumnIndices(), fd.getNativeTablePointers(), value, casing);
         return this;
     }
 
@@ -1352,8 +1403,8 @@ public boolean isValid() {
     public RealmQuery<E> beginsWith(String fieldName, String value, Case casing) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
-        this.query.beginsWith(columnIndices, value, casing);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        this.query.beginsWith(fd.getColumnIndices(), fd.getNativeTablePointers(), value, casing);
         return this;
     }
 
@@ -1381,8 +1432,8 @@ public boolean isValid() {
     public RealmQuery<E> endsWith(String fieldName, String value, Case casing) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
-        this.query.endsWith(columnIndices, value, casing);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        this.query.endsWith(fd.getColumnIndices(), fd.getNativeTablePointers(), value, casing);
         return this;
     }
 
@@ -1418,8 +1469,8 @@ public boolean isValid() {
     public RealmQuery<E> like(String fieldName, String value, Case casing) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
-        this.query.like(columnIndices, value, casing);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
+        this.query.like(fd.getColumnIndices(), fd.getNativeTablePointers(), value, casing);
         return this;
     }
 
@@ -1497,8 +1548,9 @@ public boolean isValid() {
     public RealmQuery<E> isEmpty(String fieldName) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST);
-        this.query.isEmpty(columnIndices);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST, RealmFieldType.LINKING_OBJECTS);
+        this.query.isEmpty(fd.getColumnIndices(), fd.getNativeTablePointers());
+
         return this;
     }
 
@@ -1513,8 +1565,9 @@ public boolean isValid() {
     public RealmQuery<E> isNotEmpty(String fieldName) {
         realm.checkIfValid();
 
-        long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST);
-        this.query.isNotEmpty(columnIndices);
+        FieldDescriptor fd = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST, RealmFieldType.LINKING_OBJECTS);
+        this.query.isNotEmpty(fd.getColumnIndices(), fd.getNativeTablePointers());
+
         return this;
     }
 
@@ -1533,7 +1586,7 @@ public boolean isValid() {
     public RealmResults<E> distinct(String fieldName) {
         realm.checkIfValid();
 
-        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(query.getTable(), fieldName);
+        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(getSchemaConnector(), query.getTable(), fieldName);
         return createRealmResults(query, null, distinctDescriptor, true);
     }
 
@@ -1554,7 +1607,7 @@ public boolean isValid() {
         realm.checkIfValid();
 
         realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
-        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(query.getTable(), fieldName);
+        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(getSchemaConnector(), query.getTable(), fieldName);
         return createRealmResults(query, null, distinctDescriptor, false);
     }
 
@@ -1577,7 +1630,7 @@ public boolean isValid() {
 
         fieldNames[0] = firstFieldName;
         System.arraycopy(remainingFieldNames, 0, fieldNames, 1, remainingFieldNames.length);
-        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(table, fieldNames);
+        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(getSchemaConnector(), table, fieldNames);
         return createRealmResults(query, null, distinctDescriptor, true);
     }
 
@@ -1602,12 +1655,14 @@ public Number sum(String fieldName) {
             case DOUBLE:
                 return query.sumDouble(columnIndex);
             default:
-                throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "int, float or double"));
+                throw new IllegalArgumentException(String.format(Locale.US,
+                        TYPE_MISMATCH, fieldName, "int, float or double"));
         }
     }
 
     /**
      * Returns the average of a given field.
+     * Does not support dotted field notation.
      *
      * @param fieldName the field to calculate average on. Only number fields are supported.
      * @return the average for the given field amongst objects in query results. This will be of type double for all
@@ -1627,7 +1682,8 @@ public double average(String fieldName) {
             case FLOAT:
                 return query.averageFloat(columnIndex);
             default:
-                throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "int, float or double"));
+                throw new IllegalArgumentException(String.format(Locale.US,
+                        TYPE_MISMATCH, fieldName, "int, float or double"));
         }
     }
 
@@ -1640,6 +1696,7 @@ public double average(String fieldName) {
      * values are ignored.
      * @throws java.lang.IllegalArgumentException if the field is not a number type.
      */
+    @Nullable
     public Number min(String fieldName) {
         realm.checkIfValid();
 
@@ -1652,7 +1709,8 @@ public Number min(String fieldName) {
             case DOUBLE:
                 return this.query.minimumDouble(columnIndex);
             default:
-                throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "int, float or double"));
+                throw new IllegalArgumentException(String.format(Locale.US,
+                        TYPE_MISMATCH, fieldName, "int, float or double"));
         }
     }
 
@@ -1665,6 +1723,7 @@ public Number min(String fieldName) {
      * {@code null} values are ignored.
      * @throws java.lang.UnsupportedOperationException if the query is not valid ("syntax error").
      */
+    @Nullable
     public Date minimumDate(String fieldName) {
         realm.checkIfValid();
 
@@ -1681,6 +1740,7 @@ public Date minimumDate(String fieldName) {
      * values are ignored.
      * @throws java.lang.IllegalArgumentException if the field is not a number type.
      */
+    @Nullable
     public Number max(String fieldName) {
         realm.checkIfValid();
 
@@ -1693,7 +1753,8 @@ public Number max(String fieldName) {
             case DOUBLE:
                 return this.query.maximumDouble(columnIndex);
             default:
-                throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "int, float or double"));
+                throw new IllegalArgumentException(String.format(Locale.US,
+                        TYPE_MISMATCH, fieldName, "int, float or double"));
         }
     }
 
@@ -1706,6 +1767,7 @@ public Number max(String fieldName) {
      * {@code null} values are ignored.
      * @throws java.lang.UnsupportedOperationException if the query is not valid ("syntax error").
      */
+    @Nullable
     public Date maximumDate(String fieldName) {
         realm.checkIfValid();
 
@@ -1740,8 +1802,7 @@ public long count() {
     }
 
     /**
-     * Finds all objects that fulfill the query conditions and sorted by specific field name.
-     * This method is only available from a Looper thread.
+     * Finds all objects that fulfill the query conditions. This method is only available from a Looper thread.
      *
      * @return immediately an empty {@link RealmResults}. Users need to register a listener
      * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
@@ -1771,7 +1832,7 @@ public long count() {
     public RealmResults<E> findAllSorted(String fieldName, Sort sortOrder) {
         realm.checkIfValid();
 
-        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(query.getTable(), fieldName, sortOrder);
+        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(getSchemaConnector(), query.getTable(), fieldName, sortOrder);
         return createRealmResults(query, sortDescriptor, null, true);
     }
 
@@ -1788,7 +1849,7 @@ public long count() {
         realm.checkIfValid();
 
         realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
-        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(query.getTable(), fieldName, sortOrder);
+        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(getSchemaConnector(), query.getTable(), fieldName, sortOrder);
         return createRealmResults(query, sortDescriptor, null, false);
     }
 
@@ -1838,7 +1899,7 @@ public long count() {
     public RealmResults<E> findAllSorted(String[] fieldNames, Sort[] sortOrders) {
         realm.checkIfValid();
 
-        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(query.getTable(), fieldNames, sortOrders);
+        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(getSchemaConnector(), query.getTable(), fieldNames, sortOrders);
         return createRealmResults(query, sortDescriptor, null, true);
     }
 
@@ -1861,7 +1922,7 @@ private boolean isDynamicQuery() {
         realm.checkIfValid();
 
         realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
-        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(query.getTable(), fieldNames, sortOrders);
+        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(getSchemaConnector(), query.getTable(), fieldNames, sortOrders);
         return createRealmResults(query, sortDescriptor, null, false);
     }
 
@@ -1905,11 +1966,18 @@ private boolean isDynamicQuery() {
      * @return the object found or {@code null} if no object matches the query conditions.
      * @see io.realm.RealmObject
      */
+    @Nullable
     public E findFirst() {
         realm.checkIfValid();
 
+        if (forValues) {
+            // TODO implement this;
+            return null;
+        }
+
         long tableRowIndex = getSourceRowIndexForFirstObject();
-        return (tableRowIndex < 0) ? null : realm.get(clazz, className, tableRowIndex);
+        //noinspection unchecked
+        return (tableRowIndex < 0) ? null : (E) realm.get((Class<? extends RealmModel>) clazz, className, tableRowIndex);
     }
 
     /**
@@ -1925,12 +1993,16 @@ public E findFirst() {
     public E findFirstAsync() {
         realm.checkIfValid();
 
+        if (forValues) {
+            throw new UnsupportedOperationException("findFirstAsync() available only when type parameter 'E' is implementing RealmModel.");
+        }
+
         realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
         Row row;
         if (realm.isInTransaction()) {
             // It is not possible to create async query inside a transaction. So immediately query the first object.
             // See OS Results::prepare_async()
-            row = new Collection(realm.sharedRealm, query).firstUncheckedRow();
+            row = new OsResults(realm.sharedRealm, query).firstUncheckedRow();
         } else {
             // prepares an empty reference of the RealmObject which is backed by a pending query,
             // then update it once the query complete in the background.
@@ -1945,8 +2017,11 @@ public E findFirstAsync() {
             //noinspection unchecked
             result = (E) new DynamicRealmObject(realm, row);
         } else {
-            result = realm.getConfiguration().getSchemaMediator().newInstance(
-                    clazz, realm, row, realm.getSchema().getColumnInfo(clazz),
+            //noinspection unchecked
+            final Class<? extends RealmModel> modelClass = (Class<? extends RealmModel>) clazz;
+            //noinspection unchecked
+            result = (E) realm.getConfiguration().getSchemaMediator().newInstance(
+                    modelClass, realm, row, realm.getSchema().getColumnInfo(modelClass),
                     false, Collections.<String>emptyList());
         }
 
@@ -1959,15 +2034,15 @@ public E findFirstAsync() {
     }
 
     private RealmResults<E> createRealmResults(TableQuery query,
-            SortDescriptor sortDescriptor,
-            SortDescriptor distinctDescriptor,
+            @Nullable SortDescriptor sortDescriptor,
+            @Nullable SortDescriptor distinctDescriptor,
             boolean loadResults) {
         RealmResults<E> results;
-        Collection collection = new Collection(realm.sharedRealm, query, sortDescriptor, distinctDescriptor);
+        OsResults osResults = new OsResults(realm.sharedRealm, query, sortDescriptor, distinctDescriptor);
         if (isDynamicQuery()) {
-            results = new RealmResults<>(realm, collection, className);
+            results = new RealmResults<>(realm, osResults, className);
         } else {
-            results = new RealmResults<>(realm, collection, clazz);
+            results = new RealmResults<>(realm, osResults, clazz);
         }
         if (loadResults) {
             results.load();
@@ -1978,4 +2053,8 @@ public E findFirstAsync() {
     private long getSourceRowIndexForFirstObject() {
         return this.query.find();
     }
+
+    private SchemaConnector getSchemaConnector() {
+        return new SchemaConnector(realm.getSchema());
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index 60c8c3b1fa..9a553a092f 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -17,15 +17,20 @@
 package io.realm;
 
 
+import android.annotation.SuppressLint;
 import android.os.Looper;
 
-import io.realm.internal.Collection;
+import io.reactivex.Flowable;
+import io.reactivex.Observable;
+
+import javax.annotation.Nullable;
+
+import io.realm.internal.CheckedRow;
+import io.realm.internal.OsResults;
 import io.realm.internal.Row;
-import io.realm.internal.SortDescriptor;
 import io.realm.internal.Table;
 import io.realm.internal.UncheckedRow;
-import rx.Observable;
-
+import io.realm.rx.CollectionChange;
 
 /**
  * This class holds all the matches of a {@link RealmQuery} for a given Realm. The objects are not copied from
@@ -54,26 +59,35 @@
  * @see RealmQuery#findAll()
  * @see Realm#executeTransaction(Realm.Transaction)
  */
-public class RealmResults<E extends RealmModel> extends OrderedRealmCollectionImpl<E> {
+public class RealmResults<E> extends OrderedRealmCollectionImpl<E> {
+
+    // Called from Realm Proxy classes
+    @SuppressLint("unused")
     static <T extends RealmModel> RealmResults<T> createBacklinkResults(BaseRealm realm, Row row, Class<T> srcTableType, String srcFieldName) {
-        if (!(row instanceof UncheckedRow)) {
-            throw new IllegalArgumentException("Row is " + row.getClass());
-        }
         UncheckedRow uncheckedRow = (UncheckedRow) row;
         Table srcTable = realm.getSchema().getTable(srcTableType);
-        return new RealmResults<T>(
+        return new RealmResults<>(
                 realm,
-                Collection.createBacklinksCollection(realm.sharedRealm, uncheckedRow, srcTable, srcFieldName),
+                OsResults.createBacklinksCollection(realm.sharedRealm, uncheckedRow, srcTable, srcFieldName),
                 srcTableType);
     }
 
+    // Abandon typing information, all ye who enter here
+    static RealmResults<DynamicRealmObject> createDynamicBacklinkResults(DynamicRealm realm, CheckedRow row, Table srcTable, String srcFieldName) {
+        final String srcClassName = Table.getClassNameForTable(srcTable.getName());
+        //noinspection ConstantConditions
+        return new RealmResults<>(
+                realm,
+                OsResults.createBacklinksCollection(realm.sharedRealm, row, srcTable, srcFieldName),
+                srcClassName);
+    }
 
-    RealmResults(BaseRealm realm, Collection collection, Class<E> clazz) {
-        super(realm, collection, clazz);
+    RealmResults(BaseRealm realm, OsResults osResults, Class<E> clazz) {
+        super(realm, osResults, clazz);
     }
 
-    RealmResults(BaseRealm realm, Collection collection, String className) {
-        super(realm, collection, className);
+    RealmResults(BaseRealm realm, OsResults osResults, String className) {
+        super(realm, osResults, className);
     }
 
     /**
@@ -103,7 +117,7 @@
     @Override
     public boolean isLoaded() {
         realm.checkIfValid();
-        return collection.isLoaded();
+        return osResults.isLoaded();
     }
 
     /**
@@ -114,17 +128,42 @@ public boolean isLoaded() {
      */
     @Override
     public boolean load() {
-        // The Collection doesn't have to be loaded before accessing it if the query has not returned.
-        // Instead, accessing the Collection will just trigger the execution of query if needed. We add this flag is
+        // The OsResults doesn't have to be loaded before accessing it if the query has not returned.
+        // Instead, accessing the OsResults will just trigger the execution of query if needed. We add this flag is
         // only to keep the original behavior of those APIs. eg.: For a async RealmResults, before query returns, the
         // size() call should return 0 instead of running the query get the real size.
         realm.checkIfValid();
-        collection.load();
+        osResults.load();
         return true;
     }
 
     /**
      * Adds a change listener to this {@link RealmResults}.
+     * <p>
+     * Registering a change listener will not prevent the underlying RealmResults from being garbage collected.
+     * If the RealmResults is garbage collected, the change listener will stop being triggered. To avoid this, keep a
+     * strong reference for as long as appropriate e.g. in a class variable.
+     * <p>
+     * <pre>
+     * {@code
+     * public class MyActivity extends Activity {
+     *
+     *     private RealmResults<Person> results; // Strong reference to keep listeners alive
+     *
+     *     \@Override
+     *     protected void onCreate(Bundle savedInstanceState) {
+     *       super.onCreate(savedInstanceState);
+     *       results = realm.where(Person.class).findAllAsync();
+     *       results.addChangeListener(new RealmChangeListener<RealmResults<Person>>() {
+     *           \@Override
+     *           public void onChange(RealmResults<Person> persons) {
+     *               // React to change
+     *           }
+     *       });
+     *     }
+     * }
+     * }
+     * </pre>
      *
      * @param listener the change listener to be notified.
      * @throws IllegalArgumentException if the change listener is {@code null}.
@@ -133,11 +172,36 @@ public boolean load() {
      */
     public void addChangeListener(RealmChangeListener<RealmResults<E>> listener) {
         checkForAddRemoveListener(listener, true);
-        collection.addListener(this, listener);
+        osResults.addListener(this, listener);
     }
 
     /**
      * Adds a change listener to this {@link RealmResults}.
+     * <p>
+     * Registering a change listener will not prevent the underlying RealmResults from being garbage collected.
+     * If the RealmResults is garbage collected, the change listener will stop being triggered. To avoid this, keep a
+     * strong reference for as long as appropriate e.g. in a class variable.
+     * <p>
+     * <pre>
+     * {@code
+     * public class MyActivity extends Activity {
+     *
+     *     private RealmResults<Person> results; // Strong reference to keep listeners alive
+     *
+     *     \@Override
+     *     protected void onCreate(Bundle savedInstanceState) {
+     *       super.onCreate(savedInstanceState);
+     *       results = realm.where(Person.class).findAllAsync();
+     *       results.addChangeListener(new OrderedRealmCollectionChangeListener<RealmResults<Person>>() {
+     *           \@Override
+     *           public void onChange(RealmResults<Person> persons, OrderedCollectionChangeSet changeSet) {
+     *               // React to change
+     *           }
+     *       });
+     *     }
+     * }
+     * }
+     * </pre>
      *
      * @param listener the change listener to be notified.
      * @throws IllegalArgumentException if the change listener is {@code null}.
@@ -146,10 +210,10 @@ public void addChangeListener(RealmChangeListener<RealmResults<E>> listener) {
      */
     public void addChangeListener(OrderedRealmCollectionChangeListener<RealmResults<E>> listener) {
         checkForAddRemoveListener(listener, true);
-        collection.addListener(this, listener);
+        osResults.addListener(this, listener);
     }
 
-    private void checkForAddRemoveListener(Object listener, boolean checkListener) {
+    private void checkForAddRemoveListener(@Nullable Object listener, boolean checkListener) {
         if (checkListener && listener == null) {
             throw new IllegalArgumentException("Listener should not be null");
         }
@@ -165,16 +229,7 @@ private void checkForAddRemoveListener(Object listener, boolean checkListener) {
      */
     public void removeAllChangeListeners() {
         checkForAddRemoveListener(null, false);
-        collection.removeAllListeners();
-    }
-
-    /**
-     * Use {@link #removeAllChangeListeners()} instead.
-     */
-    @SuppressWarnings("unused")
-    @Deprecated
-    public void removeChangeListeners() {
-        removeAllChangeListeners();
+        osResults.removeAllListeners();
     }
 
     /**
@@ -187,7 +242,7 @@ public void removeChangeListeners() {
      */
     public void removeChangeListener(RealmChangeListener<RealmResults<E>> listener) {
         checkForAddRemoveListener(listener, true);
-        collection.removeListener(this, listener);
+        osResults.removeListener(this, listener);
     }
 
     /**
@@ -200,20 +255,20 @@ public void removeChangeListener(RealmChangeListener<RealmResults<E>> listener)
      */
     public void removeChangeListener(OrderedRealmCollectionChangeListener<RealmResults<E>> listener) {
         checkForAddRemoveListener(listener, true);
-        collection.removeListener(this, listener);
+        osResults.removeListener(this, listener);
     }
 
     /**
-     * Returns an Rx Observable that monitors changes to this RealmResults. It will emit the current RealmResults when
+     * Returns an Rx Flowable that monitors changes to this RealmResults. It will emit the current RealmResults when
      * subscribed to. RealmResults will continually be emitted as the RealmResults are updated -
      * {@code onComplete} will never be called.
      * <p>
-     * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
+     * If you would like the {@code asFlowable()} to stop emitting items you can instruct RxJava to
      * only emit only the first item by using the {@code first()} operator:
      * <p>
      * <pre>
      * {@code
-     * realm.where(Foo.class).findAllAsync().asObservable()
+     * realm.where(Foo.class).findAllAsync().asFlowable()
      *      .filter(results -> results.isLoaded())
      *      .first()
      *      .subscribe( ... ) // You only get the results once
@@ -231,46 +286,46 @@ public void removeChangeListener(OrderedRealmCollectionChangeListener<RealmResul
      * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
      */
     @SuppressWarnings("unchecked")
-    public Observable<RealmResults<E>> asObservable() {
+    public Flowable<RealmResults<E>> asFlowable() {
         if (realm instanceof Realm) {
             return realm.configuration.getRxFactory().from((Realm) realm, this);
         } else if (realm instanceof DynamicRealm) {
             DynamicRealm dynamicRealm = (DynamicRealm) realm;
             RealmResults<DynamicRealmObject> dynamicResults = (RealmResults<DynamicRealmObject>) this;
             @SuppressWarnings("UnnecessaryLocalVariable")
-            Observable results = realm.configuration.getRxFactory().from(dynamicRealm, dynamicResults);
+            Flowable results = realm.configuration.getRxFactory().from(dynamicRealm, dynamicResults);
             return results;
         } else {
-            throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava.");
+            throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava2.");
         }
     }
 
     /**
-     * @deprecated use {@link RealmQuery#distinct(String)} on the return value of {@link #where()} instead. This will
-     * be removed in coming 3.x.x minor releases.
-     */
-    @Deprecated
-    public RealmResults<E> distinct(String fieldName) {
-        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(collection.getTable(), fieldName);
-        Collection distinctCollection = collection.distinct(distinctDescriptor);
-        return createLoadedResults(distinctCollection);
-    }
-
-    /**
-     * @deprecated use {@link RealmQuery#distinctAsync(String)} on the return value of {@link #where()} instead. This
-     * will be removed in coming 3.x.x minor releases.
-     */
-    @Deprecated
-    public RealmResults<E> distinctAsync(String fieldName) {
-        return where().distinctAsync(fieldName);
-    }
-
-    /**
-     * @deprecated use {@link RealmQuery#distinct(String, String...)} on the return value of {@link #where()} instead.
-     * This will be removed in coming 3.x.x minor releases.
+     * Returns an Rx Observable that monitors changes to this RealmResults. It will emit the current RealmResults when
+     * subscribed. For each update to the RealmResult a pair consisting of the RealmResults and the
+     * {@link OrderedCollectionChangeSet} will be sent. The changeset will be {@code null} the first
+     * time an RealmResults is emitted.
+     * <p>
+     * RealmResults will continually be emitted as the RealmResults are updated - {@code onComplete} will never be called.
+     * <p>Note that when the {@link Realm} is accessed from threads other than where it was created,
+     * {@link IllegalStateException} will be thrown. Care should be taken when using different schedulers
+     * with {@code subscribeOn()} and {@code observeOn()}. Consider using {@code Realm.where().find*Async()}
+     * instead.
+     *
+     * @return RxJava Observable that only calls {@code onNext}. It will never call {@code onComplete} or {@code OnError}.
+     * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath or the
+     * corresponding Realm instance doesn't support RxJava.
+     * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
      */
-    @Deprecated
-    public RealmResults<E> distinct(String firstFieldName, String... remainingFieldNames) {
-        return where().distinct(firstFieldName, remainingFieldNames);
+    public Observable<CollectionChange<RealmResults<E>>> asChangesetObservable() {
+        if (realm instanceof Realm) {
+            return realm.configuration.getRxFactory().changesetsFrom((Realm) realm, this);
+        } else if (realm instanceof DynamicRealm) {
+            DynamicRealm dynamicRealm = (DynamicRealm) realm;
+            RealmResults<DynamicRealmObject> dynamicResults = (RealmResults<DynamicRealmObject>) this;
+            return (Observable) realm.configuration.getRxFactory().changesetsFrom(dynamicRealm, dynamicResults);
+        } else {
+            throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava2.");
+        }
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmSchema.java b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
index 0968433c78..bd789c569f 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmSchema.java
@@ -16,59 +16,114 @@
 
 package io.realm;
 
+import java.util.HashMap;
+import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
 
+import javax.annotation.Nullable;
+
 import io.realm.internal.ColumnIndices;
 import io.realm.internal.ColumnInfo;
-import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Table;
-
+import io.realm.internal.Util;
+import io.realm.internal.util.Pair;
 
 /**
- * Class for interacting with the Realm schema using a dynamic API. This makes it possible
- * to add, delete and change the classes in the Realm.
+ * Class for interacting with the Realm schema. This makes it possible to inspect, add, delete and change the classes in
+ * the Realm.
+ * <p>
+ * {@link Realm#getSchema()} returns an immutable {@code RealmSchema} which can only be used for inspecting. Use
+ * {@link DynamicRealm#getSchema()} to get a mutable schema.
  * <p>
  * All changes must happen inside a write transaction for the particular Realm.
  *
  * @see RealmMigration
  */
 public abstract class RealmSchema {
-    private ColumnIndices columnIndices; // Cached field look up
+    static final String EMPTY_STRING_MSG = "Null or empty class names are not allowed";
+
+    // Caches Dynamic Class objects given as Strings to Realm Tables
+    private final Map<String, Table> dynamicClassToTable = new HashMap<>();
+    // Caches Class objects (both model classes and proxy classes) to Realm Tables
+    private final Map<Class<? extends RealmModel>, Table> classToTable = new HashMap<>();
+    // Caches Class objects (both model classes and proxy classes) to their Schema object
+    private final Map<Class<? extends RealmModel>, RealmObjectSchema> classToSchema = new HashMap<>();
+    // Caches Class Strings to their Schema object
+    private final Map<String, RealmObjectSchema> dynamicClassToSchema = new HashMap<>();
+
+    final BaseRealm realm;
+    // Cached field look up
+    private final ColumnIndices columnIndices;
 
     /**
-     * Release the schema and any of native resources it might hold.
+     * Creates a wrapper to easily manipulate the current schema of a Realm.
      */
-    public abstract void close();
+    RealmSchema(BaseRealm realm, @Nullable ColumnIndices columnIndices) {
+        this.realm = realm;
+        this.columnIndices = columnIndices;
+    }
 
     /**
-     * Returns the Realm schema for a given class.
+     * Returns the {@link RealmObjectSchema} for a given class. If this {@link RealmSchema} is immutable, an immutable
+     * {@link RealmObjectSchema} will be returned. Otherwise, it returns an mutable {@link RealmObjectSchema}.
      *
      * @param className name of the class
      * @return schema object for that class or {@code null} if the class doesn't exists.
      */
+    @Nullable
     public abstract RealmObjectSchema get(String className);
 
     /**
-     * Returns the {@link RealmObjectSchema}s for all RealmObject classes that can be saved in this Realm.
+     * Returns the {@link RealmObjectSchema}s for all RealmObject classes that can be saved in this Realm. If this
+     * {@link RealmSchema} is immutable, an immutable {@link RealmObjectSchema} set will be returned. Otherwise, it
+     * returns an mutable {@link RealmObjectSchema} set.
      *
      * @return the set of all classes in this Realm or no RealmObject classes can be saved in the Realm.
      */
-    public abstract Set<RealmObjectSchema> getAll();
+    public Set<RealmObjectSchema> getAll() {
+        int tableCount = (int) realm.getSharedRealm().size();
+        Set<RealmObjectSchema> schemas = new LinkedHashSet<>(tableCount);
+        for (int i = 0; i < tableCount; i++) {
+            RealmObjectSchema objectSchema = get(Table.getClassNameForTable(realm.getSharedRealm().getTableName(i)));
+            if (objectSchema != null) {
+                schemas.add(objectSchema);
+            }
+        }
+        return schemas;
+    }
 
     /**
      * Adds a new class to the Realm.
      *
      * @param className name of the class.
      * @return a Realm schema object for that class.
+     * @throws UnsupportedOperationException if this {@link RealmSchema} is immutable.
      */
     public abstract RealmObjectSchema create(String className);
 
+    /**
+     * Adds a new class to the Realm with a primary key field defined.
+     *
+     * @param className           name of the class.
+     * @param primaryKeyFieldName name of the primary key field.
+     * @param fieldType           type of field to add. Only {@code byte}, {@code short}, {@code int}, {@code long}
+     *                            and their boxed types or the {@code String} is supported.
+     * @param attributes          set of attributes for this field. This method implicitly adds
+     *                            {@link FieldAttribute#PRIMARY_KEY} and {@link FieldAttribute#INDEXED} attributes to
+     *                            the field.
+     * @throws UnsupportedOperationException if this {@link RealmSchema} is immutable.
+     * @return a Realm schema object for that class.
+     */
+    public abstract RealmObjectSchema createWithPrimaryKeyField(String className, String primaryKeyFieldName, Class<?> fieldType,
+                                                       FieldAttribute... attributes);
+
     /**
      * Removes a class from the Realm. All data will be removed. Removing a class while other classes point
      * to it will throw an {@link IllegalStateException}. Removes those classes or fields first.
      *
      * @param className name of the class to remove.
+     * @throws UnsupportedOperationException if this {@link RealmSchema} is immutable.
      */
     public abstract void remove(String className);
 
@@ -78,6 +133,7 @@
      * @param oldClassName old class name.
      * @param newClassName new class name.
      * @return a schema object for renamed class.
+     * @throws UnsupportedOperationException if this {@link RealmSchema} is immutable.
      */
     public abstract RealmObjectSchema rename(String oldClassName, String newClassName);
 
@@ -87,39 +143,101 @@
      * @param className class name to check.
      * @return {@code true} if the class already exists. {@code false} otherwise.
      */
-    public abstract boolean contains(String className);
+    public boolean contains(String className) {
+        return realm.getSharedRealm().hasTable(Table.getTableNameForClass(className));
+    }
 
-    final void setInitialColumnIndices(ColumnIndices columnIndices) {
-        if (this.columnIndices != null) {
-            throw new IllegalStateException("An instance of ColumnIndices is already set.");
+    void checkNotEmpty(String str, String error) {
+        //noinspection ConstantConditions
+        if (str == null || str.isEmpty()) {
+            throw new IllegalArgumentException(error);
         }
-        this.columnIndices = columnIndices.clone();
     }
 
-    final void setInitialColumnIndices(long version, Map<Class<? extends RealmModel>, ColumnInfo> columnInfoMap) {
-        if (this.columnIndices != null) {
-            throw new IllegalStateException("An instance of ColumnIndices is already set.");
+    void checkHasTable(String className, String errorMsg) {
+        String internalTableName = Table.getTableNameForClass(className);
+        if (!realm.getSharedRealm().hasTable(internalTableName)) {
+            throw new IllegalArgumentException(errorMsg);
         }
-        columnIndices = new ColumnIndices(version, columnInfoMap);
     }
 
-    /**
-     * Updates all {@link ColumnInfo} elements in {@code columnIndices}.
-     *
-     * <p>
-     * The ColumnInfo elements are shared between all {@link RealmObject}s created by the Realm instance
-     * which owns this RealmSchema. Updating them also means updating indices information in those {@link RealmObject}s.
-     *
-     * @param schemaVersion new schema version.
-     * @param mediator mediator for the Realm.
-     */
-    void updateColumnIndices(ColumnIndices schemaVersion, RealmProxyMediator mediator) {
-        columnIndices.copyFrom(schemaVersion, mediator);
+    Table getTable(String className) {
+        String tableName = Table.getTableNameForClass(className);
+        Table table = dynamicClassToTable.get(tableName);
+        if (table != null) { return table; }
+
+        table = realm.getSharedRealm().getTable(tableName);
+        dynamicClassToTable.put(tableName, table);
+
+        return table;
     }
 
-    final ColumnIndices cloneColumnIndices() {
-        checkIndices();
-        return columnIndices.clone();
+    Table getTable(Class<? extends RealmModel> clazz) {
+        Table table = classToTable.get(clazz);
+        if (table != null) { return table; }
+
+        Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
+        if (isProxyClass(originalClass, clazz)) {
+            // If passed 'clazz' is the proxy, try again with model class.
+            table = classToTable.get(originalClass);
+        }
+        if (table == null) {
+            String tableName = Table.getTableNameForClass(
+                    realm.getConfiguration().getSchemaMediator().getSimpleClassName(originalClass));
+            table = realm.getSharedRealm().getTable(tableName);
+            classToTable.put(originalClass, table);
+        }
+        if (isProxyClass(originalClass, clazz)) {
+            // 'clazz' is the proxy class for 'originalClass'.
+            classToTable.put(clazz, table);
+        }
+
+        return table;
+    }
+
+    // Returns an immutable RealmObjectSchema for internal usage only.
+    RealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
+        RealmObjectSchema classSchema = classToSchema.get(clazz);
+        if (classSchema != null) { return classSchema; }
+
+        Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
+        if (isProxyClass(originalClass, clazz)) {
+            // If passed 'clazz' is the proxy, try again with model class.
+            classSchema = classToSchema.get(originalClass);
+        }
+        if (classSchema == null) {
+            Table table = getTable(clazz);
+            classSchema = new ImmutableRealmObjectSchema(realm, this, table, getColumnInfo(originalClass));
+            classToSchema.put(originalClass, classSchema);
+        }
+        if (isProxyClass(originalClass, clazz)) {
+            // 'clazz' is the proxy class for 'originalClass'.
+            classToSchema.put(clazz, classSchema);
+        }
+
+        return classSchema;
+    }
+
+    // Returns an immutable RealmObjectSchema for internal usage only.
+    RealmObjectSchema getSchemaForClass(String className) {
+        String tableName = Table.getTableNameForClass(className);
+        RealmObjectSchema dynamicSchema = dynamicClassToSchema.get(tableName);
+        if (dynamicSchema == null || !dynamicSchema.getTable().isValid() || !dynamicSchema.getClassName().equals(className)) {
+            if (!realm.getSharedRealm().hasTable(tableName)) {
+                throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
+            }
+            dynamicSchema = new ImmutableRealmObjectSchema(realm, this, realm.getSharedRealm().getTable(tableName));
+            dynamicClassToSchema.put(tableName, dynamicSchema);
+        }
+        return dynamicSchema;
+    }
+
+    private boolean isProxyClass(Class<? extends RealmModel> modelClass, Class<? extends RealmModel> testee) {
+        return modelClass.equals(testee);
+    }
+
+    final boolean haveColumnInfo() {
+        return columnIndices != null;
     }
 
     final ColumnInfo getColumnInfo(Class<? extends RealmModel> clazz) {
@@ -127,27 +245,35 @@ final ColumnInfo getColumnInfo(Class<? extends RealmModel> clazz) {
         return columnIndices.getColumnInfo(clazz);
     }
 
-    final long getSchemaVersion() {
+    protected final ColumnInfo getColumnInfo(String className) {
         checkIndices();
-        return this.columnIndices.getSchemaVersion();
+        return columnIndices.getColumnInfo(className);
     }
 
-    final boolean isProxyClass(Class<? extends RealmModel> modelClass, Class<? extends RealmModel> testee) {
-        return modelClass.equals(testee);
+    final void putToClassNameToSchemaMap(String name, RealmObjectSchema objectSchema) {
+        dynamicClassToSchema.put(name, objectSchema);
     }
 
-    static String getSchemaForTable(Table table) {
-        return table.getName().substring(Table.TABLE_PREFIX.length());
+    final RealmObjectSchema removeFromClassNameToSchemaMap(String name) {
+        return dynamicClassToSchema.remove(name);
     }
 
     private void checkIndices() {
-        if (this.columnIndices == null) {
+        if (!haveColumnInfo()) {
             throw new IllegalStateException("Attempt to use column index before set.");
         }
     }
 
-    abstract Table getTable(Class<? extends RealmModel> clazz);
-    abstract Table getTable(String className);
-    abstract RealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz);
-    abstract RealmObjectSchema getSchemaForClass(String className);
+    /**
+     * Called when schema changed. Clear all cached tables and refresh column indices.
+     */
+    void refresh() {
+        if (columnIndices != null) {
+            columnIndices.refresh();
+        }
+        dynamicClassToTable.clear();
+        classToTable.clear();
+        classToSchema.clear();
+        dynamicClassToSchema.clear();
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/SchemaConnector.java b/realm/realm-library/src/main/java/io/realm/SchemaConnector.java
new file mode 100644
index 0000000000..5a695e474c
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/SchemaConnector.java
@@ -0,0 +1,55 @@
+package io.realm;
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import io.realm.internal.ColumnInfo;
+import io.realm.internal.fields.FieldDescriptor;
+
+
+/**
+ * This is a proxy, whose sole reason for existence, is to make package protected
+ * methods on Schema, visible outside the io.realm package.
+ *
+ * The class is in the package, so it has access to package protected methods.
+ * The class is <b>not</b> outside the package.
+ * The class implements one or more interfaces visible to package-external clients, that need them.
+ *
+ * I suggest creating instances of this through a factory method in the service class.
+ * That will make it easy to lazily instantiate a singleton should that become advisable.
+ */
+class SchemaConnector implements FieldDescriptor.SchemaProxy {
+    private final RealmSchema schema;
+
+    public SchemaConnector(RealmSchema schema) {
+        this.schema = schema;
+    }
+
+    @Override
+    public boolean hasCache() {
+        return schema.haveColumnInfo();
+    }
+
+    @Override
+    public ColumnInfo getColumnInfo(String tableName) {
+        return schema.getColumnInfo(tableName);
+    }
+
+    @Override
+    public long getNativeTablePtr(String targetTable) {
+        return schema.getTable(targetTable).getNativePtr();
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/StandardRealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/StandardRealmObjectSchema.java
deleted file mode 100644
index d46fb453ea..0000000000
--- a/realm/realm-library/src/main/java/io/realm/StandardRealmObjectSchema.java
+++ /dev/null
@@ -1,829 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-
-import io.realm.annotations.Required;
-import io.realm.internal.RealmProxyMediator;
-import io.realm.internal.Table;
-
-
-class StandardRealmObjectSchema extends RealmObjectSchema {
-
-    private static final Map<Class<?>, FieldMetaData> SUPPORTED_SIMPLE_FIELDS;
-
-    static {
-        Map<Class<?>, FieldMetaData> m = new HashMap<>();
-        m.put(String.class, new FieldMetaData(RealmFieldType.STRING, true));
-        m.put(short.class, new FieldMetaData(RealmFieldType.INTEGER, false));
-        m.put(Short.class, new FieldMetaData(RealmFieldType.INTEGER, true));
-        m.put(int.class, new FieldMetaData(RealmFieldType.INTEGER, false));
-        m.put(Integer.class, new FieldMetaData(RealmFieldType.INTEGER, true));
-        m.put(long.class, new FieldMetaData(RealmFieldType.INTEGER, false));
-        m.put(Long.class, new FieldMetaData(RealmFieldType.INTEGER, true));
-        m.put(float.class, new FieldMetaData(RealmFieldType.FLOAT, false));
-        m.put(Float.class, new FieldMetaData(RealmFieldType.FLOAT, true));
-        m.put(double.class, new FieldMetaData(RealmFieldType.DOUBLE, false));
-        m.put(Double.class, new FieldMetaData(RealmFieldType.DOUBLE, true));
-        m.put(boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, false));
-        m.put(Boolean.class, new FieldMetaData(RealmFieldType.BOOLEAN, true));
-        m.put(byte.class, new FieldMetaData(RealmFieldType.INTEGER, false));
-        m.put(Byte.class, new FieldMetaData(RealmFieldType.INTEGER, true));
-        m.put(byte[].class, new FieldMetaData(RealmFieldType.BINARY, true));
-        m.put(Date.class, new FieldMetaData(RealmFieldType.DATE, true));
-        SUPPORTED_SIMPLE_FIELDS = Collections.unmodifiableMap(m);
-    }
-
-    private static final Map<Class<?>, FieldMetaData> SUPPORTED_LINKED_FIELDS;
-
-    static {
-        Map<Class<?>, FieldMetaData> m = new HashMap<>();
-        m.put(RealmObject.class, new FieldMetaData(RealmFieldType.OBJECT, false));
-        m.put(RealmList.class, new FieldMetaData(RealmFieldType.LIST, false));
-        SUPPORTED_LINKED_FIELDS = Collections.unmodifiableMap(m);
-    }
-
-    private final BaseRealm realm;
-    private final Map<String, Long> columnIndices;
-    private final Table table;
-
-    /**
-     * Creates a schema object for a given Realm class.
-     *
-     * @param realm Realm holding the objects.
-     * @param table table representation of the Realm class
-     * @param columnIndices mapping between field names and column indexes for the given table
-     */
-    StandardRealmObjectSchema(BaseRealm realm, Table table, Map<String, Long> columnIndices) {
-        this.realm = realm;
-        this.table = table;
-        this.columnIndices = columnIndices;
-    }
-
-    @Override
-    Table getTable() {
-        return table;
-    }
-
-    /**
-     * There are no resources here that need closing.
-     */
-    @Override
-    public void close() { }
-
-    /**
-     * Returns the name of the RealmObject class being represented by this schema.
-     * <p>
-     * <ul>
-     * <li>When using a typed {@link Realm} this name is the same as the {@link RealmObject} class.</li>
-     * <li>When using a {@link DynamicRealm} this is the name used in all API methods requiring a class name.</li>
-     * </ul>
-     *
-     * @return the name of the RealmObject class represented by this schema.
-     */
-    @Override
-    public String getClassName() {
-        return table.getName().substring(Table.TABLE_PREFIX.length());
-    }
-
-    /**
-     * Sets a new name for this RealmObject class. This is equivalent to renaming it. When
-     * {@link StandardRealmObjectSchema#table} has a primary key, this will transfer the primary key for the new class name.
-     *
-     * @param className the new name for this class.
-     * @throws IllegalArgumentException if className is {@code null} or an empty string, or its length exceeds 56
-     * characters.
-     * @see StandardRealmSchema#rename(String, String)
-     */
-    @Override
-    public StandardRealmObjectSchema setClassName(String className) {
-        realm.checkNotInSync(); // renaming a table is not permitted
-        checkEmpty(className);
-        String internalTableName = Table.TABLE_PREFIX + className;
-        if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
-            throw new IllegalArgumentException("Class name is too long. Limit is 56 characters: \'" + className + "\' (" + Integer.toString(className.length()) + ")");
-        }
-        if (realm.sharedRealm.hasTable(internalTableName)) {
-            throw new IllegalArgumentException("Class already exists: " + className);
-        }
-        // in case this table has a primary key, we need to transfer it after renaming the table.
-        String oldTableName = null;
-        String pkField = null;
-        if (table.hasPrimaryKey()) {
-            oldTableName = table.getName();
-            pkField = getPrimaryKey();
-            table.setPrimaryKey(null);
-        }
-        realm.sharedRealm.renameTable(table.getName(), internalTableName);
-        if (pkField != null && !pkField.isEmpty()) {
-            try {
-                table.setPrimaryKey(pkField);
-            } catch (Exception e) {
-                // revert the table name back when something goes wrong
-                realm.sharedRealm.renameTable(table.getName(), oldTableName);
-                throw e;
-            }
-        }
-        return this;
-    }
-
-    /**
-     * Adds a new simple field to the RealmObject class. The type must be one supported by Realm. See
-     * {@link RealmObject} for the list of supported types. If the field should allow {@code null} values use the boxed
-     * type instead e.g., {@code Integer.class} instead of {@code int.class}.
-     * <p>
-     * To add fields that reference other RealmObjects or RealmLists use
-     * {@link #addRealmObjectField(String, RealmObjectSchema)} or {@link #addRealmListField(String, RealmObjectSchema)}
-     * instead.
-     *
-     * @param fieldName name of the field to add.
-     * @param fieldType type of field to add. See {@link RealmObject} for the full list.
-     * @param attributes set of attributes for this field.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if the type isn't supported, field name is illegal or a field with that name
-     * already exists.
-     */
-    @Override
-    public StandardRealmObjectSchema addField(String fieldName, Class<?> fieldType, FieldAttribute... attributes) {
-        FieldMetaData metadata = SUPPORTED_SIMPLE_FIELDS.get(fieldType);
-        if (metadata == null) {
-            if (SUPPORTED_LINKED_FIELDS.containsKey(fieldType)) {
-                throw new IllegalArgumentException("Use addRealmObjectField() instead to add fields that link to other RealmObjects: " + fieldName);
-            } else {
-                throw new IllegalArgumentException(String.format("Realm doesn't support this field type: %s(%s)",
-                        fieldName, fieldType));
-            }
-        }
-
-        checkNewFieldName(fieldName);
-        boolean nullable = metadata.defaultNullable;
-        if (containsAttribute(attributes, FieldAttribute.REQUIRED)) {
-            nullable = false;
-        }
-
-        long columnIndex = table.addColumn(metadata.realmType, fieldName, nullable);
-        try {
-            addModifiers(fieldName, attributes);
-        } catch (Exception e) {
-            // Modifiers have been removed by the addModifiers method()
-            table.removeColumn(columnIndex);
-            throw e;
-        }
-        return this;
-    }
-
-    /**
-     * Adds a new field that references another {@link RealmObject}.
-     *
-     * @param fieldName name of the field to add.
-     * @param objectSchema schema for the Realm type being referenced.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if field name is illegal or a field with that name already exists.
-     */
-    @Override
-    public StandardRealmObjectSchema addRealmObjectField(String fieldName, RealmObjectSchema objectSchema) {
-        checkLegalName(fieldName);
-        checkFieldNameIsAvailable(fieldName);
-        table.addColumnLink(RealmFieldType.OBJECT, fieldName, realm.sharedRealm.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
-        return this;
-    }
-
-    /**
-     * Adds a new field that references a {@link RealmList}.
-     *
-     * @param fieldName name of the field to add.
-     * @param objectSchema schema for the Realm type being referenced.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if the field name is illegal or a field with that name already exists.
-     */
-    @Override
-    public StandardRealmObjectSchema addRealmListField(String fieldName, RealmObjectSchema objectSchema) {
-        checkLegalName(fieldName);
-        checkFieldNameIsAvailable(fieldName);
-        table.addColumnLink(RealmFieldType.LIST, fieldName, realm.sharedRealm.getTable(Table.TABLE_PREFIX + objectSchema.getClassName()));
-        return this;
-    }
-
-    /**
-     * Removes a field from the class.
-     *
-     * @param fieldName field name to remove.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if field name doesn't exist.
-     */
-    @Override
-    public StandardRealmObjectSchema removeField(String fieldName) {
-        realm.checkNotInSync(); // destructive modification of a schema is not permitted
-        checkLegalName(fieldName);
-        if (!hasField(fieldName)) {
-            throw new IllegalStateException(fieldName + " does not exist.");
-        }
-        long columnIndex = getColumnIndex(fieldName);
-        if (table.getPrimaryKey() == columnIndex) {
-            table.setPrimaryKey(null);
-        }
-        table.removeColumn(columnIndex);
-        return this;
-    }
-
-    /**
-     * Renames a field from one name to another.
-     *
-     * @param currentFieldName field name to rename.
-     * @param newFieldName the new field name.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if field name doesn't exist or if the new field name already exists.
-     */
-    @Override
-    public StandardRealmObjectSchema renameField(String currentFieldName, String newFieldName) {
-        realm.checkNotInSync(); // destructive modification of a schema is not permitted
-        checkLegalName(currentFieldName);
-        checkFieldExists(currentFieldName);
-        checkLegalName(newFieldName);
-        checkFieldNameIsAvailable(newFieldName);
-        long columnIndex = getColumnIndex(currentFieldName);
-        table.renameColumn(columnIndex, newFieldName);
-
-        // ATTENTION: We don't need to re-set the PK table here since the column index won't be changed when renaming.
-
-        return this;
-    }
-
-    /**
-     * Tests if the class has field defined with the given name.
-     *
-     * @param fieldName field name to test.
-     * @return {@code true} if the field exists, {@code false} otherwise.
-     */
-    @Override
-    public boolean hasField(String fieldName) {
-        return table.getColumnIndex(fieldName) != Table.NO_MATCH;
-    }
-
-    /**
-     * Adds an index to a given field. This is the equivalent of adding the {@link io.realm.annotations.Index}
-     * annotation on the field.
-     *
-     * @param fieldName field to add index to.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be indexed or it already has a
-     * index defined.
-     */
-    @Override
-    public StandardRealmObjectSchema addIndex(String fieldName) {
-        checkLegalName(fieldName);
-        checkFieldExists(fieldName);
-        long columnIndex = getColumnIndex(fieldName);
-        if (table.hasSearchIndex(columnIndex)) {
-            throw new IllegalStateException(fieldName + " already has an index.");
-        }
-        table.addSearchIndex(columnIndex);
-        return this;
-    }
-
-    /**
-     * Checks if a given field has an index defined.
-     *
-     * @param fieldName existing field name to check.
-     * @return {@code true} if field is indexed, {@code false} otherwise.
-     * @throws IllegalArgumentException if field name doesn't exist.
-     * @see io.realm.annotations.Index
-     */
-    @Override
-    public boolean hasIndex(String fieldName) {
-        checkLegalName(fieldName);
-        checkFieldExists(fieldName);
-        return table.hasSearchIndex(table.getColumnIndex(fieldName));
-    }
-
-
-    /**
-     * Removes an index from a given field. This is the same as removing the {@code @Index} annotation on the field.
-     *
-     * @param fieldName field to remove index from.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if field name doesn't exist or the field doesn't have an index.
-     */
-    @Override
-    public StandardRealmObjectSchema removeIndex(String fieldName) {
-        realm.checkNotInSync(); // Destructive modifications are not permitted.
-        checkLegalName(fieldName);
-        checkFieldExists(fieldName);
-        long columnIndex = getColumnIndex(fieldName);
-        if (!table.hasSearchIndex(columnIndex)) {
-            throw new IllegalStateException("Field is not indexed: " + fieldName);
-        }
-        table.removeSearchIndex(columnIndex);
-        return this;
-    }
-
-    /**
-     * Adds a primary key to a given field. This is the same as adding the {@link io.realm.annotations.PrimaryKey}
-     * annotation on the field. Further, this implicitly adds {@link io.realm.annotations.Index} annotation to the field
-     * as well.
-     *
-     * @param fieldName field to set as primary key.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if field name doesn't exist, the field cannot be a primary key or it already
-     * has a primary key defined.
-     */
-    @Override
-    public StandardRealmObjectSchema addPrimaryKey(String fieldName) {
-        checkLegalName(fieldName);
-        checkFieldExists(fieldName);
-        if (table.hasPrimaryKey()) {
-            throw new IllegalStateException("A primary key is already defined");
-        }
-        table.setPrimaryKey(fieldName);
-        long columnIndex = getColumnIndex(fieldName);
-        if (!table.hasSearchIndex(columnIndex)) {
-            // No exception will be thrown since adding PrimaryKey implies the column has an index.
-            table.addSearchIndex(columnIndex);
-        }
-        return this;
-    }
-
-    /**
-     * Removes the primary key from this class. This is the same as removing the {@link io.realm.annotations.PrimaryKey}
-     * annotation from the class. Further, this implicitly removes {@link io.realm.annotations.Index} annotation from
-     * the field as well.
-     *
-     * @return the updated schema.
-     * @throws IllegalArgumentException if the class doesn't have a primary key defined.
-     */
-    @Override
-    public StandardRealmObjectSchema removePrimaryKey() {
-        realm.checkNotInSync(); // Destructive modifications are not permitted.
-        if (!table.hasPrimaryKey()) {
-            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
-        }
-        long columnIndex = table.getPrimaryKey();
-        if (table.hasSearchIndex(columnIndex)) {
-            table.removeSearchIndex(columnIndex);
-        }
-        table.setPrimaryKey("");
-        return this;
-    }
-
-    /**
-     * Sets a field to be required i.e., it is not allowed to hold {@code null} values. This is equivalent to switching
-     * between boxed types and their primitive variant e.g., {@code Integer} to {@code int}.
-     *
-     * @param fieldName name of field in the class.
-     * @param required {@code true} if field should be required, {@code false} otherwise.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if the field name doesn't exist, cannot have the {@link Required} annotation or
-     * the field already have been set as required.
-     * @see Required
-     */
-    @Override
-    public StandardRealmObjectSchema setRequired(String fieldName, boolean required) {
-        long columnIndex = table.getColumnIndex(fieldName);
-        boolean currentColumnRequired = isRequired(fieldName);
-        RealmFieldType type = table.getColumnType(columnIndex);
-
-        if (type == RealmFieldType.OBJECT) {
-            throw new IllegalArgumentException("Cannot modify the required state for RealmObject references: " + fieldName);
-        }
-        if (type == RealmFieldType.LIST) {
-            throw new IllegalArgumentException("Cannot modify the required state for RealmList references: " + fieldName);
-        }
-        if (required && currentColumnRequired) {
-            throw new IllegalStateException("Field is already required: " + fieldName);
-        }
-        if (!required && !currentColumnRequired) {
-            throw new IllegalStateException("Field is already nullable: " + fieldName);
-        }
-
-        if (required) {
-            table.convertColumnToNotNullable(columnIndex);
-        } else {
-            table.convertColumnToNullable(columnIndex);
-        }
-        return this;
-    }
-
-    /**
-     * Sets a field to be nullable i.e., it should be able to hold {@code null} values. This is equivalent to switching
-     * between primitive types and their boxed variant e.g., {@code int} to {@code Integer}.
-     *
-     * @param fieldName name of field in the class.
-     * @param nullable {@code true} if field should be nullable, {@code false} otherwise.
-     * @return the updated schema.
-     * @throws IllegalArgumentException if the field name doesn't exist, or cannot be set as nullable.
-     */
-    @Override
-    public StandardRealmObjectSchema setNullable(String fieldName, boolean nullable) {
-        setRequired(fieldName, !nullable);
-        return this;
-    }
-
-    /**
-     * Checks if a given field is required i.e., it is not allowed to contain {@code null} values.
-     *
-     * @param fieldName field to check.
-     * @return {@code true} if it is required, {@code false} otherwise.
-     * @throws IllegalArgumentException if field name doesn't exist.
-     * @see #setRequired(String, boolean)
-     */
-    @Override
-    public boolean isRequired(String fieldName) {
-        long columnIndex = getColumnIndex(fieldName);
-        return !table.isColumnNullable(columnIndex);
-    }
-
-    /**
-     * Checks if a given field is nullable i.e., it is allowed to contain {@code null} values.
-     *
-     * @param fieldName field to check.
-     * @return {@code true} if it is required, {@code false} otherwise.
-     * @throws IllegalArgumentException if field name doesn't exist.
-     * @see #setNullable(String, boolean)
-     */
-    @Override
-    public boolean isNullable(String fieldName) {
-        long columnIndex = getColumnIndex(fieldName);
-        return table.isColumnNullable(columnIndex);
-    }
-
-    /**
-     * Checks if a given field is the primary key field.
-     *
-     * @param fieldName field to check.
-     * @return {@code true} if it is the primary key field, {@code false} otherwise.
-     * @throws IllegalArgumentException if field name doesn't exist.
-     * @see #addPrimaryKey(String)
-     */
-    @Override
-    public boolean isPrimaryKey(String fieldName) {
-        long columnIndex = getColumnIndex(fieldName);
-        return columnIndex == table.getPrimaryKey();
-    }
-
-    /**
-     * Checks if the class has a primary key defined.
-     *
-     * @return {@code true} if a primary key is defined, {@code false} otherwise.
-     * @see io.realm.annotations.PrimaryKey
-     */
-    @Override
-    public boolean hasPrimaryKey() {
-        return table.hasPrimaryKey();
-    }
-
-    /**
-     * Returns the name of the primary key field.
-     *
-     * @return the name of the primary key field.
-     * @throws IllegalStateException if the class doesn't have a primary key defined.
-     */
-    @Override
-    public String getPrimaryKey() {
-        if (!table.hasPrimaryKey()) {
-            throw new IllegalStateException(getClassName() + " doesn't have a primary key.");
-        }
-        return table.getColumnName(table.getPrimaryKey());
-    }
-
-    /**
-     * Returns all fields in this class.
-     *
-     * @return a list of all the fields in this class.
-     */
-    @Override
-    public Set<String> getFieldNames() {
-        int columnCount = (int) table.getColumnCount();
-        Set<String> columnNames = new LinkedHashSet<>(columnCount);
-        for (int i = 0; i < columnCount; i++) {
-            columnNames.add(table.getColumnName(i));
-        }
-        return columnNames;
-    }
-
-    /**
-     * Runs a transformation function on each RealmObject instance of the current class. The object will be represented
-     * as a {@link DynamicRealmObject}.
-     *
-     * @return this schema.
-     */
-    @Override
-    public StandardRealmObjectSchema transform(Function function) {
-        if (function != null) {
-            long size = table.size();
-            for (long i = 0; i < size; i++) {
-                function.apply(new DynamicRealmObject(realm, table.getCheckedRow(i)));
-            }
-        }
-
-        return this;
-    }
-
-    /**
-     * Returns the type used by the underlying storage engine to represent this field.
-     *
-     * @return the underlying type used by Realm to represent this field.
-     */
-    @Override
-    public RealmFieldType getFieldType(String fieldName) {
-        long columnIndex = getColumnIndex(fieldName);
-        return table.getColumnType(columnIndex);
-    }
-
-    @Override
-    StandardRealmObjectSchema add(String name, RealmFieldType type, boolean primary, boolean indexed, boolean required) {
-        long columnIndex = table.addColumn(type, name, (required) ? Table.NOT_NULLABLE : Table.NULLABLE);
-
-        if (indexed) { table.addSearchIndex(columnIndex); }
-
-        if (primary) { table.setPrimaryKey(name); }
-
-        return this;
-    }
-
-    @Override
-    StandardRealmObjectSchema add(String name, RealmFieldType type, RealmObjectSchema linkedTo) {
-        table.addColumnLink(
-                type,
-                name,
-                realm.getSharedRealm().getTable(StandardRealmSchema.TABLE_PREFIX + linkedTo.getClassName()));
-        return this;
-    }
-
-    /**
-     * Returns the column indices for the given field name. If a linked field is defined, the column index for
-     * each field is returned.
-     *
-     * @param fieldDescription fieldName or link path to a field name.
-     * @param validColumnTypes valid field type for the last field in a linked field
-     * @return list of column indices.
-     */
-    // TODO: consider another caching strategy so linked classes are included in the cache.
-    @Override
-    long[] getColumnIndices(String fieldDescription, RealmFieldType... validColumnTypes) {
-        if (fieldDescription == null || fieldDescription.equals("")) {
-            throw new IllegalArgumentException("Invalid query: field name is empty");
-        }
-        if (fieldDescription.endsWith(".")) {
-            throw new IllegalArgumentException("Invalid query: field name must not end with a period ('.')");
-        }
-        String[] names = fieldDescription.split("\\.");
-
-        //final RealmProxyMediator mediator = realm.getConfiguration().getSchemaMediator();
-
-        long[] columnIndices = new long[names.length];
-        Table currentTable = table;
-        RealmFieldType columnType;
-        String columnName;
-        String tableName;
-        for (int i = 0; /* loop exits in the middle */ ; i++) {
-            columnName = names[i];
-            if (columnName.length() <= 0) {
-                throw new IllegalArgumentException(String.format(
-                        "Invalid query: empty column name in field '%s'.  " +
-                                "A field name must not begin with, end with, or contain adjacent periods ('.').",
-                                fieldDescription));
-            }
-
-            tableName = getTableName(currentTable);
-            long index = currentTable.getColumnIndex(columnName);
-            if (index < 0) {
-                throw new IllegalArgumentException(
-                        String.format("Invalid query: field '%s' does not exist in table '%s'.",
-                                columnName, tableName));
-            }
-            columnIndices[i] = index;
-
-            columnType = currentTable.getColumnType(index);
-
-            if (i >= names.length - 1) { break; }
-
-            if ((columnType != RealmFieldType.OBJECT) && (columnType != RealmFieldType.LIST)) {
-                throw new IllegalArgumentException(
-                        String.format("Invalid query: field '%s' in table '%s' is of type '%s'.  It must be a LIST or OBJECT type.",
-                                columnName, tableName, columnType.toString()));
-            }
-
-            currentTable = currentTable.getLinkTarget(index);
-        }
-
-        if ((validColumnTypes != null) && (validColumnTypes.length > 0) && !isValidType(columnType, validColumnTypes)) {
-            throw new IllegalArgumentException(
-                    String.format("Invalid query: field '%s' in table '%s' is of invalid type '%s'.",
-                            columnName, tableName, columnType.toString()));
-        }
-
-        return columnIndices;
-    }
-
-    /**
-     * Returns the column index in the underlying table for the given field name.
-     *
-     * @param fieldName field name to find index for.
-     * @return column index or null if it doesn't exists.
-     */
-    Long getFieldIndex(String fieldName) {
-        return columnIndices.get(fieldName);
-    }
-
-    /**
-     * Returns the column index in the underlying table for the given field name.
-     *
-     * @param fieldName field name to find index for.
-     * @return column index.
-     * @throws IllegalArgumentException if the field does not exists.
-     */
-    @Override
-    long getAndCheckFieldIndex(String fieldName) {
-        Long index = columnIndices.get(fieldName);
-        if (index == null) {
-            throw new IllegalArgumentException("Field does not exist: " + fieldName);
-        }
-        return index;
-    }
-
-    private String getTableName(Table table) {
-        return table.getName().substring(StandardRealmSchema.TABLE_PREFIX.length());
-    }
-
-    // Invariant: Field was just added. This method is responsible for cleaning up attributes if it fails.
-    private void addModifiers(String fieldName, FieldAttribute[] attributes) {
-        boolean indexAdded = false;
-        try {
-            if (attributes != null && attributes.length > 0) {
-                if (containsAttribute(attributes, FieldAttribute.INDEXED)) {
-                    addIndex(fieldName);
-                    indexAdded = true;
-                }
-
-                if (containsAttribute(attributes, FieldAttribute.PRIMARY_KEY)) {
-                    // Note : adding primary key implies application of FieldAttribute.INDEXED attribute.
-                    addPrimaryKey(fieldName);
-                    indexAdded = true;
-                }
-
-                // REQUIRED is being handled when adding the column using addField through the nullable parameter.
-            }
-        } catch (Exception e) {
-            // If something went wrong, revert all attributes.
-            long columnIndex = getColumnIndex(fieldName);
-            if (indexAdded) {
-                table.removeSearchIndex(columnIndex);
-            }
-            throw (RuntimeException) e;
-        }
-    }
-
-    private boolean containsAttribute(FieldAttribute[] attributeList, FieldAttribute attribute) {
-        if (attributeList == null || attributeList.length == 0) {
-            return false;
-        }
-        for (int i = 0; i < attributeList.length; i++) {
-            if (attributeList[i] == attribute) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private void checkNewFieldName(String fieldName) {
-        checkLegalName(fieldName);
-        checkFieldNameIsAvailable(fieldName);
-    }
-
-    private void checkLegalName(String fieldName) {
-        if (fieldName == null || fieldName.isEmpty()) {
-            throw new IllegalArgumentException("Field name can not be null or empty");
-        }
-        if (fieldName.contains(".")) {
-            throw new IllegalArgumentException("Field name can not contain '.'");
-        }
-    }
-
-    private void checkFieldNameIsAvailable(String fieldName) {
-        if (table.getColumnIndex(fieldName) != Table.NO_MATCH) {
-            throw new IllegalArgumentException("Field already exists in '" + getClassName() + "': " + fieldName);
-        }
-    }
-
-    private void checkFieldExists(String fieldName) {
-        if (table.getColumnIndex(fieldName) == Table.NO_MATCH) {
-            throw new IllegalArgumentException("Field name doesn't exist on object '" + getClassName() + "': " + fieldName);
-        }
-    }
-
-    private long getColumnIndex(String fieldName) {
-        long columnIndex = table.getColumnIndex(fieldName);
-        if (columnIndex == -1) {
-            throw new IllegalArgumentException(
-                    String.format("Field name '%s' does not exist on schema for '%s",
-                            fieldName, getClassName()
-                    ));
-        }
-        return columnIndex;
-    }
-
-    private void checkEmpty(String str) {
-        if (str == null || str.isEmpty()) {
-            throw new IllegalArgumentException("Null or empty class names are not allowed");
-        }
-    }
-
-    private boolean isValidType(RealmFieldType columnType, RealmFieldType[] validColumnTypes) {
-        for (int i = 0; i < validColumnTypes.length; i++) {
-            if (validColumnTypes[i] == columnType) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    public static final class DynamicColumnMap implements Map<String, Long> {
-        private final Table table;
-
-        DynamicColumnMap(Table table) {
-            this.table = table;
-        }
-
-        @Override
-        public Long get(Object key) {
-            long ret = table.getColumnIndex((String) key);
-            return ret < 0 ? null : ret;
-        }
-
-        @Override
-        public void clear() {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public boolean containsKey(Object key) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public boolean containsValue(Object value) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public Set<Entry<String, Long>> entrySet() {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public boolean isEmpty() {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public Set<String> keySet() {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public Long put(String key, Long value) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public void putAll(Map<? extends String, ? extends Long> map) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public Long remove(Object key) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public int size() {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public Collection<Long> values() {
-            throw new UnsupportedOperationException();
-        }
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java b/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
deleted file mode 100644
index bcec1169fb..0000000000
--- a/realm/realm-library/src/main/java/io/realm/StandardRealmSchema.java
+++ /dev/null
@@ -1,280 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import java.util.HashMap;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-
-import io.realm.internal.Table;
-import io.realm.internal.Util;
-
-
-/**
- * Class for interacting with the Realm schema using a dynamic API. This makes it possible
- * to add, delete and change the classes in the Realm.
- * <p>
- * All changes must happen inside a write transaction for the particular Realm.
- *
- * @see io.realm.RealmMigration
- */
-class StandardRealmSchema extends RealmSchema {
-
-    static final String TABLE_PREFIX = Table.TABLE_PREFIX;
-    private static final String EMPTY_STRING_MSG = "Null or empty class names are not allowed";
-
-    // Caches Dynamic Class objects given as Strings to Realm Tables
-    private final Map<String, Table> dynamicClassToTable = new HashMap<>();
-    // Caches Class objects (both model classes and proxy classes) to Realm Tables
-    private final Map<Class<? extends RealmModel>, Table> classToTable = new HashMap<>();
-    // Caches Class objects (both model classes and proxy classes) to their Schema object
-    private final Map<Class<? extends RealmModel>, StandardRealmObjectSchema> classToSchema = new HashMap<>();
-    // Caches Class Strings to their Schema object
-    private final Map<String, StandardRealmObjectSchema> dynamicClassToSchema = new HashMap<>();
-
-    private final BaseRealm realm;
-
-    /**
-     * Creates a wrapper to easily manipulate the current schema of a Realm.
-     */
-    StandardRealmSchema(BaseRealm realm) {
-        this.realm = realm;
-    }
-
-    @Override
-    public void close() { }
-
-    /**
-     * Returns the Realm schema for a given class.
-     *
-     * @param className name of the class
-     * @return schema object for that class or {@code null} if the class doesn't exists.
-     */
-    @Override
-    public RealmObjectSchema get(String className) {
-        checkEmpty(className, EMPTY_STRING_MSG);
-
-        String internalClassName = TABLE_PREFIX + className;
-        if (!realm.getSharedRealm().hasTable(internalClassName)) { return null; }
-
-        Table table = realm.getSharedRealm().getTable(internalClassName);
-        StandardRealmObjectSchema.DynamicColumnMap columnIndices = new StandardRealmObjectSchema.DynamicColumnMap(table);
-        return new StandardRealmObjectSchema(realm, table, columnIndices);
-    }
-
-    /**
-     * Returns the {@link StandardRealmObjectSchema} for all RealmObject classes that can be saved in this Realm.
-     *
-     * @return the set of all classes in this Realm or no RealmObject classes can be saved in the Realm.
-     */
-    @Override
-    public Set<RealmObjectSchema> getAll() {
-        int tableCount = (int) realm.getSharedRealm().size();
-        Set<RealmObjectSchema> schemas = new LinkedHashSet<>(tableCount);
-        for (int i = 0; i < tableCount; i++) {
-            String tableName = realm.getSharedRealm().getTableName(i);
-            if (!Table.isModelTable(tableName)) {
-                continue;
-            }
-            Table table = realm.getSharedRealm().getTable(tableName);
-            StandardRealmObjectSchema.DynamicColumnMap columnIndices = new StandardRealmObjectSchema.DynamicColumnMap(table);
-            schemas.add(new StandardRealmObjectSchema(realm, table, columnIndices));
-        }
-        return schemas;
-    }
-
-    /**
-     * Adds a new class to the Realm.
-     *
-     * @param className name of the class.
-     * @return a Realm schema object for that class.
-     */
-    @Override
-    public RealmObjectSchema create(String className) {
-        // Adding a class is always permitted.
-        checkEmpty(className, EMPTY_STRING_MSG);
-
-        String internalTableName = TABLE_PREFIX + className;
-        if (internalTableName.length() > Table.TABLE_MAX_LENGTH) {
-            throw new IllegalArgumentException("Class name is too long. Limit is 56 characters: " + className.length());
-        }
-        if (realm.getSharedRealm().hasTable(internalTableName)) {
-            throw new IllegalArgumentException("Class already exists: " + className);
-        }
-        Table table = realm.getSharedRealm().getTable(internalTableName);
-        StandardRealmObjectSchema.DynamicColumnMap columnIndices = new StandardRealmObjectSchema.DynamicColumnMap(table);
-        return new StandardRealmObjectSchema(realm, table, columnIndices);
-    }
-
-    /**
-     * Checks if a given class already exists in the schema.
-     *
-     * @param className class name to check.
-     * @return {@code true} if the class already exists. {@code false} otherwise.
-     */
-    @Override
-    public boolean contains(String className) {
-        return realm.getSharedRealm().hasTable(Table.TABLE_PREFIX + className);
-    }
-
-    /**
-     * Removes a class from the Realm. All data will be removed. Removing a class while other classes point
-     * to it will throw an {@link IllegalStateException}. Removes those classes or fields first.
-     *
-     * @param className name of the class to remove.
-     */
-    @Override
-    public void remove(String className) {
-        realm.checkNotInSync(); // Destructive modifications are not permitted.
-        checkEmpty(className, EMPTY_STRING_MSG);
-        String internalTableName = TABLE_PREFIX + className;
-        checkHasTable(className, "Cannot remove class because it is not in this Realm: " + className);
-        Table table = getTable(className);
-        if (table.hasPrimaryKey()) {
-            table.setPrimaryKey(null);
-        }
-        realm.getSharedRealm().removeTable(internalTableName);
-    }
-
-    /**
-     * Renames a class already in the Realm.
-     *
-     * @param oldClassName old class name.
-     * @param newClassName new class name.
-     * @return a schema object for renamed class.
-     */
-    @Override
-    public RealmObjectSchema rename(String oldClassName, String newClassName) {
-        realm.checkNotInSync(); // Destructive modifications are not permitted.
-        checkEmpty(oldClassName, "Class names cannot be empty or null");
-        checkEmpty(newClassName, "Class names cannot be empty or null");
-        String oldInternalName = TABLE_PREFIX + oldClassName;
-        String newInternalName = TABLE_PREFIX + newClassName;
-        checkHasTable(oldClassName, "Cannot rename class because it doesn't exist in this Realm: " + oldClassName);
-        if (realm.getSharedRealm().hasTable(newInternalName)) {
-            throw new IllegalArgumentException(oldClassName + " cannot be renamed because the new class already exists: " + newClassName);
-        }
-
-        // Checks if there is a primary key defined for the old class.
-        Table oldTable = getTable(oldClassName);
-        String pkField = null;
-        if (oldTable.hasPrimaryKey()) {
-            pkField = oldTable.getColumnName(oldTable.getPrimaryKey());
-            oldTable.setPrimaryKey(null);
-        }
-
-        realm.getSharedRealm().renameTable(oldInternalName, newInternalName);
-        Table table = realm.getSharedRealm().getTable(newInternalName);
-
-        // Sets the primary key for the new class if necessary.
-        if (pkField != null) {
-            table.setPrimaryKey(pkField);
-        }
-
-        StandardRealmObjectSchema.DynamicColumnMap columnIndices = new StandardRealmObjectSchema.DynamicColumnMap(table);
-        return new StandardRealmObjectSchema(realm, table, columnIndices);
-    }
-
-    private void checkEmpty(String str, String error) {
-        if (str == null || str.isEmpty()) {
-            throw new IllegalArgumentException(error);
-        }
-    }
-
-    private void checkHasTable(String className, String errorMsg) {
-        String internalTableName = TABLE_PREFIX + className;
-        if (!realm.getSharedRealm().hasTable(internalTableName)) {
-            throw new IllegalArgumentException(errorMsg);
-        }
-    }
-
-    @Override
-    Table getTable(String className) {
-        className = Table.TABLE_PREFIX + className;
-        Table table = dynamicClassToTable.get(className);
-        if (table != null) { return table; }
-
-        if (!realm.getSharedRealm().hasTable(className)) {
-            throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
-        }
-        table = realm.getSharedRealm().getTable(className);
-        dynamicClassToTable.put(className, table);
-
-        return table;
-    }
-
-    @Override
-    Table getTable(Class<? extends RealmModel> clazz) {
-        Table table = classToTable.get(clazz);
-        if (table != null) { return table; }
-
-        Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
-        if (isProxyClass(originalClass, clazz)) {
-            // If passed 'clazz' is the proxy, try again with model class.
-            table = classToTable.get(originalClass);
-        }
-        if (table == null) {
-            table = realm.getSharedRealm().getTable(realm.getConfiguration().getSchemaMediator().getTableName(originalClass));
-            classToTable.put(originalClass, table);
-        }
-        if (isProxyClass(originalClass, clazz)) {
-            // 'clazz' is the proxy class for 'originalClass'.
-            classToTable.put(clazz, table);
-        }
-
-        return table;
-    }
-
-    @Override
-    StandardRealmObjectSchema getSchemaForClass(Class<? extends RealmModel> clazz) {
-        StandardRealmObjectSchema classSchema = classToSchema.get(clazz);
-        if (classSchema != null) { return classSchema; }
-
-        Class<? extends RealmModel> originalClass = Util.getOriginalModelClass(clazz);
-        if (isProxyClass(originalClass, clazz)) {
-            // If passed 'clazz' is the proxy, try again with model class.
-            classSchema = classToSchema.get(originalClass);
-        }
-        if (classSchema == null) {
-            Table table = getTable(clazz);
-            classSchema = new StandardRealmObjectSchema(realm, table, getColumnInfo(originalClass).getIndicesMap());
-            classToSchema.put(originalClass, classSchema);
-        }
-        if (isProxyClass(originalClass, clazz)) {
-            // 'clazz' is the proxy class for 'originalClass'.
-            classToSchema.put(clazz, classSchema);
-        }
-        return classSchema;
-    }
-
-    @Override
-    StandardRealmObjectSchema getSchemaForClass(String className) {
-        className = Table.TABLE_PREFIX + className;
-        StandardRealmObjectSchema dynamicSchema = dynamicClassToSchema.get(className);
-        if (dynamicSchema == null) {
-            if (!realm.getSharedRealm().hasTable(className)) {
-                throw new IllegalArgumentException("The class " + className + " doesn't exist in this Realm.");
-            }
-            Table table = realm.getSharedRealm().getTable(className);
-            StandardRealmObjectSchema.DynamicColumnMap columnIndices = new StandardRealmObjectSchema.DynamicColumnMap(table);
-            dynamicSchema = new StandardRealmObjectSchema(realm, table, columnIndices);
-            dynamicClassToSchema.put(className, dynamicSchema);
-        }
-        return dynamicSchema;
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java
index bad9719003..716c0266c6 100644
--- a/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmFileException.java
@@ -15,6 +15,8 @@
  */
 package io.realm.exceptions;
 
+import java.util.Locale;
+
 import io.realm.internal.Keep;
 import io.realm.internal.SharedRealm;
 
@@ -58,7 +60,12 @@
         /**
          * Thrown if the file needs to be upgraded to a new format, but upgrades have been explicitly disabled.
          */
-        FORMAT_UPGRADE_REQUIRED;
+        FORMAT_UPGRADE_REQUIRED,
+        /**
+         * Thrown if an attempt was made to open an Realm file created with Realm Object Server 1.*, which is
+         * not compatible with Realm Object Server 2.*. This exception should automatically be handled by Realm.
+         */
+        INCOMPATIBLE_SYNC_FILE;
 
         // Created from byte values by JNI.
         static Kind getKind(byte value) {
@@ -77,6 +84,8 @@ static Kind getKind(byte value) {
                     return FORMAT_UPGRADE_REQUIRED;
                 case SharedRealm.FILE_EXCEPTION_KIND_BAD_HISTORY:
                     return BAD_HISTORY;
+                case SharedRealm.FILE_EXCEPTION_INCOMPATIBLE_SYNC_FILE:
+                    return INCOMPATIBLE_SYNC_FILE;
                 default:
                     throw new RuntimeException("Unknown value for RealmFileException kind.");
             }
@@ -118,6 +127,6 @@ public Kind getKind() {
 
     @Override
     public String toString() {
-        return String.format("%s Kind: %s.", super.toString(), kind);
+        return String.format(Locale.US, "%s Kind: %s.", super.toString(), kind);
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java b/realm/realm-library/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java
index aadcdc7bf7..53bd85bef6 100644
--- a/realm/realm-library/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/RealmMigrationNeededException.java
@@ -18,9 +18,12 @@
 
 import java.io.File;
 
+import javax.annotation.Nullable;
+
 import io.realm.internal.Keep;
 
 
+// Constructed from JNI
 @Keep
 public final class RealmMigrationNeededException extends RuntimeException {
 
@@ -31,11 +34,6 @@ public RealmMigrationNeededException(String canonicalRealmPath, String detailMes
         this.canonicalRealmPath = canonicalRealmPath;
     }
 
-    public RealmMigrationNeededException(String canonicalRealmPath, String detailMessage, Throwable throwable) {
-        super(detailMessage, throwable);
-        this.canonicalRealmPath = canonicalRealmPath;
-    }
-
     /**
      * Returns the canonical path to the Realm file that needs to be migrated.
      * <p>
diff --git a/realm/realm-library/src/main/java/io/realm/exceptions/package-info.java b/realm/realm-library/src/main/java/io/realm/exceptions/package-info.java
new file mode 100644
index 0000000000..adb8fb5282
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/exceptions/package-info.java
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+@javax.annotation.ParametersAreNonnullByDefault
+package io.realm.exceptions;
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Capabilities.java b/realm/realm-library/src/main/java/io/realm/internal/Capabilities.java
index 5eaa72a770..8b8fea4e14 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Capabilities.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Capabilities.java
@@ -16,6 +16,9 @@
 
 package io.realm.internal;
 
+import javax.annotation.Nullable;
+
+
 /**
  * To describe what the Realm instance can do associated with the thread it is created on.
  * The capabilities are determined when the Realm gets created. This interface could be called from another thread which
@@ -34,5 +37,11 @@
      *
      * @param exceptionMessage message which is contained in the exception.
      */
-    void checkCanDeliverNotification(String exceptionMessage);
+    void checkCanDeliverNotification(@Nullable String exceptionMessage);
+
+    /**
+     * Multiple threads might be able to deliver notifications, but the Main thread in GUI applications often have
+     * special rules that need to be enforced.
+     */
+    boolean isMainThread();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
index a3d474beaf..115130670b 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
@@ -16,6 +16,8 @@
 
 package io.realm.internal;
 
+import java.util.Locale;
+
 import io.realm.RealmFieldType;
 
 
@@ -55,19 +57,6 @@ public static CheckedRow get(NativeContext context, Table table, long index) {
         return new CheckedRow(context, table, nativeRowPointer);
     }
 
-    /**
-     * Gets the row object associated to an index in a {@link LinkView}.
-     *
-     * @param context the Realm context.
-     * @param linkView the {@link LinkView} holding the row.
-     * @param index the index of the row.
-     * @return a checked instance of {@link Row} for the {@link LinkView} and index specified.
-     */
-    public static CheckedRow get(NativeContext context, LinkView linkView, long index) {
-        long nativeRowPointer = linkView.nativeGetRow(linkView.getNativePtr(), index);
-        return new CheckedRow(context, linkView.getTargetTable(), nativeRowPointer);
-    }
-
     /**
      * Converts a {@link UncheckedRow} to a {@link CheckedRow}.
      *
@@ -108,6 +97,28 @@ public void setNull(long columnIndex) {
         }
     }
 
+    @Override
+    public OsList getModelList(long columnIndex) {
+        RealmFieldType fieldType = getTable().getColumnType(columnIndex);
+        if (fieldType != RealmFieldType.LIST) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.US, "Field '%s' is not a 'RealmList'.",
+                            getTable().getColumnName(columnIndex)));
+        }
+        return super.getModelList(columnIndex);
+    }
+
+    @Override
+    public OsList getValueList(long columnIndex, RealmFieldType fieldType) {
+        final RealmFieldType actualFieldType = getTable().getColumnType(columnIndex);
+        if (fieldType != actualFieldType) {
+            throw new IllegalArgumentException(
+                    String.format(Locale.US, "The type of field '%1$s' is not 'RealmFieldType.%2$s'.",
+                            getTable().getColumnName(columnIndex), fieldType.name()));
+        }
+        return super.getValueList(columnIndex, fieldType);
+    }
+
     @Override
     protected native long nativeGetColumnCount(long nativeTablePtr);
 
@@ -144,9 +155,6 @@ public void setNull(long columnIndex) {
     @Override
     protected native byte[] nativeGetByteArray(long nativePtr, long columnIndex);
 
-    @Override
-    protected native long nativeGetLinkView(long nativePtr, long columnIndex);
-
     @Override
     protected native void nativeSetLong(long nativeRowPtr, long columnIndex, long value);
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
index 069e5b0004..98f47c2485 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnIndices.java
@@ -16,76 +16,123 @@
 
 package io.realm.internal;
 
+
 import java.util.HashMap;
+import java.util.Locale;
 import java.util.Map;
+import java.util.Set;
 
-import io.realm.RealmModel;
+import javax.annotation.Nonnull;
 
+import io.realm.RealmModel;
+import io.realm.exceptions.RealmException;
 
 /**
- * Utility class used to cache the mapping between object field names and their column indices.
+ * Utility class used to cache the mapping between object field names and their column indices. The
+ * {@code ColumnIndices} instance is dedicated to a single {@link io.realm.BaseRealm} instance. Different Realm
+ * instances will never share the same column indices cache. The column info cache is loaded lazily. A
+ * {@link ColumnInfo} will be added to the cache when the relevant Realm object gets accessed.
+ * <p>
+ * This class can be mutated, after construction, in two ways:
+ * <ul>
+ * <li>the {@code copyFrom} method</li>
+ * <li>mutating one of the ColumnInfo object to which this instance holds a reference</li>
+ * </ul>
+ * Immutable instances of this class protect against the first possibility by throwing on calls
+ * to {@code copyFrom}.  {@see ColumnInfo} for its mutability contract.
+ *
+ * There are two, redundant, lookup methods, for schema members: by Class and by String.
+ * Query lookups must be done by the name of the class and use the String-keyed lookup table.
+ * Although it would be possible to use the same table to look up ColumnInfo by Class, the
+ * class lookup is very fast and on a hot path, so we maintain the redundant table.
  */
-public final class ColumnIndices implements Cloneable {
-    private long schemaVersion;
-    private Map<Class<? extends RealmModel>, ColumnInfo> classes;
+public final class ColumnIndices {
+    // Class to ColumnInfo map
+    private final Map<Class<? extends RealmModel>, ColumnInfo> classToColumnInfoMap =
+            new HashMap<Class<? extends RealmModel>, ColumnInfo>();
+    // Class name to ColumnInfo map. All the elements in this map should be existing in classToColumnInfoMap.
+    private final Map<String, ColumnInfo> simpleClassNameToColumnInfoMap =
+            new HashMap<String, ColumnInfo>();
 
-    public ColumnIndices(long schemaVersion, Map<Class<? extends RealmModel>, ColumnInfo> classes) {
-        this.schemaVersion = schemaVersion;
-        this.classes = classes;
-    }
+    private final RealmProxyMediator mediator;
+    // Due to the nature of Object Store's Realm::m_schema, SharedRealm's OsObjectSchemaInfo object is fixed after set.
+    private final OsSchemaInfo osSchemaInfo;
 
-    public long getSchemaVersion() {
-        return schemaVersion;
-    }
 
     /**
-     * Returns {@link ColumnInfo} for the given class or {@code null} if no mapping exists.
+     * Create a mutable ColumnIndices initialized with the ColumnInfo objects in the passed map.
+     *
+     * @param mediator the {@link RealmProxyMediator} used for the corresponding Realm.
+     * @param osSchemaInfo the corresponding Realm's {@link OsSchemaInfo}.
      */
-    public ColumnInfo getColumnInfo(Class<? extends RealmModel> clazz) {
-        return classes.get(clazz);
+    public ColumnIndices(RealmProxyMediator mediator, OsSchemaInfo osSchemaInfo) {
+        this.mediator = mediator;
+        this.osSchemaInfo = osSchemaInfo;
     }
 
     /**
-     * Returns the column index for a given field on a clazz or {@code -1} if no such field exists.
+     * Returns the {@link ColumnInfo} for the passed class.
+     *
+     * @param clazz the class for which to get the ColumnInfo.
+     * @return the corresponding {@link ColumnInfo} object.
+     * @throws io.realm.exceptions.RealmException if the class cannot be found in the schema.
      */
-    public long getColumnIndex(Class<? extends RealmModel> clazz, String fieldName) {
-        final ColumnInfo columnInfo = classes.get(clazz);
-        if (columnInfo != null) {
-            Long index = columnInfo.getIndicesMap().get(fieldName);
-            return (index != null) ? index : -1;
-        } else {
-            return -1;
+    @Nonnull
+    public ColumnInfo getColumnInfo(Class<? extends RealmModel> clazz) {
+        ColumnInfo columnInfo = classToColumnInfoMap.get(clazz);
+        if (columnInfo == null) {
+            columnInfo = mediator.createColumnInfo(clazz, osSchemaInfo);
+            classToColumnInfoMap.put(clazz, columnInfo);
         }
+        return columnInfo;
     }
 
-    @Override
-    public ColumnIndices clone() {
-        try {
-            final ColumnIndices clone = (ColumnIndices) super.clone();
-            clone.classes = duplicateColumnInfoMap();
-            return clone;
-        } catch (CloneNotSupportedException e) {
-            throw new RuntimeException(e);
+    /**
+     * Returns the {@link ColumnInfo} for the passed class name.
+     *
+     * @param simpleClassName the simple name of the class for which to get the ColumnInfo.
+     * @return the corresponding {@link ColumnInfo} object.
+     * @throws io.realm.exceptions.RealmException if the class cannot be found in the schema.
+     */
+    @Nonnull
+    public ColumnInfo getColumnInfo(String simpleClassName) {
+        ColumnInfo columnInfo = simpleClassNameToColumnInfoMap.get(simpleClassName);
+        if (columnInfo == null) {
+            Set<Class<? extends RealmModel>> modelClasses = mediator.getModelClasses();
+            for (Class<? extends RealmModel> modelClass : modelClasses) {
+                if (mediator.getSimpleClassName(modelClass).equals(simpleClassName)) {
+                    columnInfo = getColumnInfo(modelClass);
+                    simpleClassNameToColumnInfoMap.put(simpleClassName, columnInfo);
+                    break;
+                }
+            }
+        }
+        if (columnInfo == null) {
+            throw new RealmException(
+                    String.format(Locale.US, "'%s' doesn't exist in current schema.", simpleClassName));
         }
+        return columnInfo;
     }
 
-    private Map<Class<? extends RealmModel>, ColumnInfo> duplicateColumnInfoMap() {
-        final Map<Class<? extends RealmModel>, ColumnInfo> copy = new HashMap<Class<? extends RealmModel>, ColumnInfo>();
-        for (Map.Entry<Class<? extends RealmModel>, ColumnInfo> entry : classes.entrySet()) {
-            copy.put(entry.getKey(), entry.getValue().clone());
+    /**
+     * Refreshes all the existing {@link ColumnInfo} in the cache.
+     */
+    public void refresh() {
+        for (Map.Entry<Class<? extends RealmModel>, ColumnInfo> entry : classToColumnInfoMap.entrySet()) {
+            ColumnInfo newColumnInfo = mediator.createColumnInfo(entry.getKey(), osSchemaInfo);
+            entry.getValue().copyFrom(newColumnInfo);
         }
-        return copy;
     }
 
-    public void copyFrom(ColumnIndices other, RealmProxyMediator mediator) {
-        for (Map.Entry<Class<? extends RealmModel>, ColumnInfo> entry : classes.entrySet()) {
-            final ColumnInfo otherColumnInfo = other.getColumnInfo(entry.getKey());
-            if (otherColumnInfo == null) {
-                throw new IllegalStateException("Failed to copy ColumnIndices cache: "
-                        + Table.tableNameToClassName(mediator.getTableName(entry.getKey())));
-            }
-            entry.getValue().copyColumnInfoFrom(otherColumnInfo);
+    @Override
+    public String toString() {
+        StringBuilder buf = new StringBuilder("ColumnIndices[");
+        boolean commaNeeded = false;
+        for (Map.Entry<Class<? extends RealmModel>, ColumnInfo> entry : classToColumnInfoMap.entrySet()) {
+            if (commaNeeded) { buf.append(","); }
+            buf.append(entry.getKey().getSimpleName()).append("->").append(entry.getValue());
+            commaNeeded = true;
         }
-        this.schemaVersion = other.schemaVersion;
+        return buf.append("]").toString();
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
index fe39118f01..c56343a1fa 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ColumnInfo.java
@@ -16,60 +16,235 @@
 
 package io.realm.internal;
 
+import java.util.HashMap;
 import java.util.Map;
 
-import io.realm.exceptions.RealmMigrationNeededException;
+import javax.annotation.Nullable;
 
+import io.realm.RealmFieldType;
 
-public abstract class ColumnInfo implements Cloneable {
-    private Map<String, Long> indicesMap;
 
-    protected final long getValidColumnIndex(String realmPath, Table table,
-            String className, String columnName) {
-        final long columnIndex = table.getColumnIndex(columnName);
-        if (columnIndex == -1) {
-            throw new RealmMigrationNeededException(realmPath,
-                    "Field '" + columnName + "' not found for type " + className);
+/**
+ * The Subclasses of this are a fast cache of column indices, for proxy object.
+ * <p>
+ * The fast cache functionality is implemented in the Proxy classes generated by {@code RealmProxyClassGenerator}.
+ * Every proxy object will hold an reference of its {@code ColumnInfo}. The ref to the {@code ColumnInfo} instance is
+ * maintained by the {@link ColumnIndices}. As long as the reference in proxy object has been set, it should never be
+ * changed. When schema changes, the relevant {@code ColumnInfo} instance's content will be refreshed therefore the
+ * proxy object could have the latest column indices. Be sure to understand what is going on there,
+ * before changing things here.
+ * <p>
+ * While the use of the fields in {@code ColumnDetails} is consistent, there are three subtly different cases:
+ * <ul>
+ * <li>If the column type is a simple type, the {@code linkedClassName} field is {@code null}</li>
+ * <li>If the column type is OBJECT or LINK, the {@code linkedClassName} field is the class name of the OBJECT/LINK type</li>
+ * <li>If the column type is LINKING_OBJECT, the {@code linkedClassName} field is the class name of the backlink source table
+ * and the column index field is the index of the backlink source field, in the source table</li>
+ * </ul>
+ * <p>
+ * The instance of this class is dedicated to a single {@link SharedRealm} instance. Thus this is not supposed to be
+ * used across threads.
+ * An instance can be mutated, after construction, in four ways:
+ * <ul>
+ * <li>the {@code copyFrom} method</li>
+ * <li>as the dst parameter of the two-argument copy method</li>
+ * <li>using the {@code addColumnDetails} method</li>
+ * <li>using the {@code addBacklinkDetails} method</li>
+ * </ul>
+ * Immutable instances of this class protect against the first possibility by throwing on calls
+ * to {@code copyFrom}.  There are no checks against the other three mutations.  In order to comply
+ * with the effectively-final contract:
+ * <ul>
+ * <li>the methods {@code addColumnDetails} and {@code addBacklinkDetails} must be called
+ * only from within instance constructors</li>
+ * <li>an immutable instance must never be the dst parameter of the two-argument copy method</li>
+ * </ul>
+ */
+public abstract class ColumnInfo {
+
+    // Immutable column information
+    public static final class ColumnDetails {
+        public final long columnIndex;
+        public final RealmFieldType columnType;
+        public final String linkedClassName;
+
+        private ColumnDetails(long columnIndex, RealmFieldType columnType, @Nullable String linkedClassName) {
+            // invariant: (columnType == OBJECT || columnType == LIST || columnType == LINKING_OBJECTS) == (linkedClassName != null)
+            this.columnIndex = columnIndex;
+            this.columnType = columnType;
+            this.linkedClassName = linkedClassName;
+        }
+
+        ColumnDetails(Property property) {
+            this(property.getColumnIndex(), property.getType(), property.getLinkedObjectName());
+        }
+
+        @Override
+        public String toString() {
+            StringBuilder buf = new StringBuilder("ColumnDetails[");
+            buf.append(columnIndex);
+            buf.append(", ").append(columnType);
+            buf.append(", ").append(linkedClassName);
+            return buf.append("]").toString();
         }
-        return columnIndex;
     }
 
+
+    private final Map<String, ColumnDetails> indicesMap;
+    private final boolean mutable;
+
     /**
-     * Returns a map from column name to column index.
+     * Create a new, empty instance
      *
-     * @return a map from column name to column index. Do not modify returned map because it may be
-     * shared among other {@link ColumnInfo} instances.
+     * @param mapSize the expected number of columns in the map.
      */
-    public Map<String, Long> getIndicesMap() {
-        return indicesMap;
+    protected ColumnInfo(int mapSize) {
+        this(mapSize, true);
     }
 
-    protected final void setIndicesMap(Map<String, Long> indicesMap) {
-        this.indicesMap = indicesMap;
+    /**
+     * Create an exact copy of the passed instance.
+     *
+     * @param src the instance to copy
+     * @param mutable false to make this instance effectively final
+     */
+    protected ColumnInfo(@Nullable ColumnInfo src, boolean mutable) {
+        this((src == null) ? 0 : src.indicesMap.size(), mutable);
+        // ColumnDetails are immutable and may be re-used.
+        if (src != null) {
+            indicesMap.putAll(src.indicesMap);
+        }
+    }
+
+    private ColumnInfo(int mapSize, boolean mutable) {
+        this.indicesMap = new HashMap<>(mapSize);
+        this.mutable = mutable;
     }
 
     /**
-     * Copies the column index value from other {@link ColumnInfo} object.
+     * Get the mutability state of the instance.
      *
-     * @param other the class of {@code other} must be exactly the same as this instance.
-     * It must not be {@code null}.
-     * @throws IllegalArgumentException if {@code other} has different class than this.
+     * @return true if the instance is mutable
+     */
+    public final boolean isMutable() {
+        return mutable;
+    }
+
+    /**
+     * Returns the index, in the described table, for the named column.
+     *
+     * @return column index.
      */
-    public abstract void copyColumnInfoFrom(ColumnInfo other);
+    public long getColumnIndex(String columnName) {
+        ColumnDetails details = indicesMap.get(columnName);
+        return (details == null) ? -1 : details.columnIndex;
+    }
 
     /**
-     * Returns a shallow copy of this instance.
+     * Returns the {@link ColumnDetails}, in the described table, of the named column.
      *
-     * @return shallow copy.
+     * @return {@link ColumnDetails} or {@code null} if not found.
+     */
+    @Nullable
+    public ColumnDetails getColumnDetails(String columnName) {
+        return indicesMap.get(columnName);
+    }
+
+    /**
+     * Makes this ColumnInfo an exact copy of {@code src}.
+     *
+     * @param src The source for the copy.  This instance will be an exact copy of {@code src} after return.
+     * {@code src} must not be {@code null}.
+     * @throws IllegalArgumentException if {@code other} has different class than this.
      */
+    public void copyFrom(ColumnInfo src) {
+        if (!mutable) {
+            throw new UnsupportedOperationException("Attempt to modify an immutable ColumnInfo");
+        }
+        if (null == src) {
+            throw new NullPointerException("Attempt to copy null ColumnInfo");
+        }
+
+        indicesMap.clear();
+        indicesMap.putAll(src.indicesMap);
+        copy(src, this);
+    }
+
     @Override
-    public ColumnInfo clone() {
-        try {
-            return (ColumnInfo) super.clone();
-        } catch (CloneNotSupportedException e) {
-            throw new RuntimeException(e);
+    public String toString() {
+        StringBuilder buf = new StringBuilder("ColumnInfo[");
+        buf.append(mutable).append(",");
+        if (indicesMap != null) {
+            boolean commaNeeded = false;
+            for (Map.Entry<String, ColumnDetails> entry : indicesMap.entrySet()) {
+                if (commaNeeded) { buf.append(","); }
+                buf.append(entry.getKey()).append("->").append(entry.getValue());
+                commaNeeded = true;
+            }
         }
+        return buf.append("]").toString();
+    }
+
+    /**
+     * Create a new object that is an exact copy of {@code src}.
+     * This is the generic factory for ColumnInfo objects.
+     * Subclasses are expected to override it with a proxy to a copy constructor.
+     *
+     * @param mutable false to make an immutable copy.
+     */
+    protected abstract ColumnInfo copy(boolean mutable);
+
+    /**
+     * Make {@code dst} into an exact copy of {@code src}.
+     * Intended for use only by subclasses.
+     * NOTE: there is no protection against calling this method with an "immutable" instance as dst!
+     *
+     * @param src The source for the copy
+     * @param dst The destination of the copy.  Will be an exact copy of src after return.
+     */
+    protected abstract void copy(ColumnInfo src, ColumnInfo dst);
+
+    /**
+     * Add a new column to the indexMap.
+     * <p>
+     * <b>For use only in subclass constructors!</b>.
+     * Must be called from within the subclass constructor, to maintain the effectively-final contract.
+     * <p>
+     * No validation done here.  Presuming that all necessary validation takes place in {@code Proxy.validateTable}.
+     *
+     * @param columnName The name of the column whose index is sought.
+     * @param objectSchemaInfo the {@link OsObjectSchemaInfo} for the corresponding {@code RealmObject}.
+     * @return the index of the column in the table
+     */
+    protected final long addColumnDetails(String columnName, OsObjectSchemaInfo objectSchemaInfo) {
+        Property property = objectSchemaInfo.getProperty(columnName);
+        indicesMap.put(columnName, new ColumnDetails(property));
+        return property.getColumnIndex();
+    }
+
+    /**
+     * Add a new backlink to the indexMap.
+     * <b>For use only by subclasses!</b>.
+     * Must be called from within the subclass constructor, to maintain the effectively-final contract.
+     *
+     * @param schemaInfo the {@link OsSchemaInfo} of the corresponding {@code Realm} instance.
+     * @param columnName The name of the backlink column.
+     * @param sourceTableName The name of the backlink source class.
+     * @param sourceColumnName The name of the backlink source field.
+     */
+    protected final void addBacklinkDetails(OsSchemaInfo schemaInfo, String columnName, String sourceTableName, String sourceColumnName) {
+        long columnIndex = schemaInfo.getObjectSchemaInfo(sourceTableName).getProperty(sourceColumnName).getColumnIndex();
+        indicesMap.put(columnName, new ColumnDetails(columnIndex, RealmFieldType.LINKING_OBJECTS, sourceTableName));
     }
 
-    ;
+    /**
+     * Returns the {@link Map} that is the implementation for this object.
+     * <b>FOR TESTING USE ONLY!</b>
+     *
+     * @return the column details map.
+     */
+    @SuppressWarnings("ReturnOfCollectionOrArrayField")
+    public Map<String, ColumnDetails> getIndicesMap() {
+        return indicesMap;
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/FieldDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/FieldDescriptor.java
deleted file mode 100644
index 13d815aa42..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/FieldDescriptor.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.realm.internal;
-
-import java.util.Arrays;
-
-import io.realm.RealmFieldType;
-
-
-/**
- * Class describing a single field possible several links away.
- */
-public class FieldDescriptor {
-
-    private long[] columnIndices;
-    private RealmFieldType fieldType;
-    private String fieldName;
-    private boolean searchIndex;
-
-    public FieldDescriptor(Table table, String fieldDescription, boolean allowLink, boolean allowList) {
-        if (fieldDescription == null || fieldDescription.isEmpty()) {
-            throw new IllegalArgumentException("Non-empty field name must be provided");
-        }
-        if (fieldDescription.startsWith(".") || fieldDescription.endsWith(".")) {
-            throw new IllegalArgumentException("Illegal field name. It cannot start or end with a '.': " + fieldDescription);
-        }
-        if (fieldDescription.contains(".")) {
-            // Resolves field description down to last field name
-            String[] names = fieldDescription.split("\\.");
-            long[] columnIndices = new long[names.length];
-            for (int i = 0; i < names.length - 1; i++) {
-                long index = table.getColumnIndex(names[i]);
-                if (index == Table.NO_MATCH) {
-                    throw new IllegalArgumentException(
-                            String.format("Invalid field name: '%s' does not refer to a class.", names[i]));
-                }
-                RealmFieldType type = table.getColumnType(index);
-                if (!allowLink && type == RealmFieldType.OBJECT) {
-                    throw new IllegalArgumentException(
-                            String.format("'RealmObject' field '%s' is not a supported link field here.", names[i]));
-                } else if (!allowList && type == RealmFieldType.LIST) {
-                    throw new IllegalArgumentException(
-                            String.format("'RealmList' field '%s' is not a supported link field here.", names[i]));
-                } else if (type == RealmFieldType.OBJECT || type == RealmFieldType.LIST) {
-                    table = table.getLinkTarget(index);
-                    columnIndices[i] = index;
-                } else {
-                    throw new IllegalArgumentException(
-                            String.format("Invalid field name: '%s' does not refer to a class.", names[i]));
-                }
-            }
-
-            // Check if last field name is a valid field
-            String columnName = names[names.length - 1];
-            long columnIndex = table.getColumnIndex(columnName);
-            columnIndices[names.length - 1] = columnIndex;
-            if (columnIndex == Table.NO_MATCH) {
-                throw new IllegalArgumentException(
-                        String.format("'%s' is not a field name in class '%s'.", columnName, table.getName()));
-            }
-
-            this.fieldType = table.getColumnType(columnIndex);
-            this.fieldName = columnName;
-            this.columnIndices = columnIndices;
-            this.searchIndex = table.hasSearchIndex(columnIndex);
-        } else {
-            long fieldIndex = table.getColumnIndex(fieldDescription);
-            if (fieldIndex == Table.NO_MATCH) {
-                throw new IllegalArgumentException(String.format("Field '%s' does not exist.", fieldDescription));
-            }
-            this.fieldType = table.getColumnType(fieldIndex);
-            this.fieldName = fieldDescription;
-            this.columnIndices = new long[] {fieldIndex};
-            this.searchIndex = table.hasSearchIndex(fieldIndex);
-        }
-    }
-
-    public long[] getColumnIndices() {
-        return Arrays.copyOf(columnIndices, columnIndices.length);
-    }
-
-    public RealmFieldType getFieldType() {
-        return fieldType;
-    }
-
-    public String getFieldName() {
-        return fieldName;
-    }
-
-    public boolean hasSearchIndex() {
-        return searchIndex;
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java b/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java
index a6819bdba4..42f160d1d9 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/InvalidRow.java
@@ -105,7 +105,12 @@ public boolean isNullLink(long columnIndex) {
     }
 
     @Override
-    public LinkView getLinkList(long columnIndex) {
+    public OsList getModelList(long columnIndex) {
+        throw getStubException();
+    }
+
+    @Override
+    public OsList getValueList(long columnIndex, RealmFieldType fieldType) {
         throw getStubException();
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Keep.java b/realm/realm-library/src/main/java/io/realm/internal/Keep.java
index 57ddfcf83d..c9a92e55db 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Keep.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Keep.java
@@ -26,6 +26,8 @@
  * This annotation is used to mark the classes to be kept by ProGuard/DexGuard.
  * The ProGuard configuration must have '-keep class io.realm.internal.Keep'
  * and '-keep,includedescriptorclasses @io.realm.internal.Keep class * { *; }'.
+ * <p>
+ * NOTE: The outer class and the inner class have to be both annotated by this if they need to be kept.
  */
 @Retention(RetentionPolicy.CLASS)
 @Target(ElementType.TYPE)
diff --git a/realm/realm-library/src/main/java/io/realm/internal/LinkView.java b/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
deleted file mode 100644
index 2562bf88dc..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
+++ /dev/null
@@ -1,197 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import io.realm.RealmFieldType;
-
-
-/**
- * The LinkView class represents a core {@link RealmFieldType#LIST}.
- */
-public class LinkView implements NativeObject {
-
-    private final NativeContext context;
-    final Table parent;
-    final long columnIndexInParent;
-    private final long nativePtr;
-    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
-
-    public LinkView(NativeContext context, Table parent, long columnIndexInParent, long nativeLinkViewPtr) {
-        this.context = context;
-        this.parent = parent;
-        this.columnIndexInParent = columnIndexInParent;
-        this.nativePtr = nativeLinkViewPtr;
-
-        context.addReference(this);
-    }
-
-
-    @Override
-    public long getNativePtr() {
-        return nativePtr;
-    }
-
-    @Override
-    public long getNativeFinalizerPtr() {
-        return nativeFinalizerPtr;
-    }
-
-    /**
-     * Returns a non-checking {@link Row}. Incorrect use of this Row will cause a hard Realm Core crash (SIGSEGV).
-     * Only use this method if you are sure that input parameters are valid, otherwise use {@link #getCheckedRow(long)}
-     * which will throw appropriate exceptions if used incorrectly.
-     *
-     * @param index the index of row to fetch.
-     * @return the unsafe row wrapper object.
-     */
-    public UncheckedRow getUncheckedRow(long index) {
-        return UncheckedRow.getByRowIndex(context, this, index);
-    }
-
-    /**
-     * Returns a wrapper for {@link Row} access. All access will be error checked at the JNI layer and will throw an
-     * appropriate {@link RuntimeException} if used incorrectly.
-     * <p>
-     * If error checking is done elsewhere, consider using {@link #getUncheckedRow(long)} for better performance.
-     *
-     * @param index the index of row to fetch.
-     * @return the safe row wrapper object.
-     */
-    public CheckedRow getCheckedRow(long index) {
-        return CheckedRow.get(context, this, index);
-    }
-
-    /**
-     * Returns the row index in the underlying table.
-     */
-    public long getTargetRowIndex(long linkViewIndex) {
-        return nativeGetTargetRowIndex(nativePtr, linkViewIndex);
-    }
-
-    public void add(long rowIndex) {
-        checkImmutable();
-        nativeAdd(nativePtr, rowIndex);
-    }
-
-    public void insert(long pos, long rowIndex) {
-        checkImmutable();
-        nativeInsert(nativePtr, pos, rowIndex);
-    }
-
-    public void set(long pos, long rowIndex) {
-        checkImmutable();
-        nativeSet(nativePtr, pos, rowIndex);
-    }
-
-    public void move(long oldPos, long newPos) {
-        checkImmutable();
-        nativeMove(nativePtr, oldPos, newPos);
-    }
-
-    public void remove(long pos) {
-        checkImmutable();
-        nativeRemove(nativePtr, pos);
-    }
-
-    public void clear() {
-        checkImmutable();
-        nativeClear(nativePtr);
-    }
-
-    public boolean contains(long tableRowIndex) {
-        long index = nativeFind(nativePtr, tableRowIndex);
-        return (index != Table.NO_MATCH);
-    }
-
-    public long size() {
-        return nativeSize(nativePtr);
-    }
-
-    public boolean isEmpty() {
-        return nativeIsEmpty(nativePtr);
-    }
-
-    public TableQuery where() {
-        long nativeQueryPtr = nativeWhere(nativePtr);
-        return new TableQuery(this.context, this.getTargetTable(), nativeQueryPtr);
-    }
-
-    public boolean isAttached() {
-        return nativeIsAttached(nativePtr);
-    }
-
-    /**
-     * Removes all target rows pointed to by links in this link view, and clear this link view.
-     */
-    public void removeAllTargetRows() {
-        checkImmutable();
-        nativeRemoveAllTargetRows(nativePtr);
-    }
-
-    /**
-     * Removes target row from both the Realm and the LinkView.
-     */
-    public void removeTargetRow(int index) {
-        checkImmutable();
-        nativeRemoveTargetRow(nativePtr, index);
-    }
-
-    public Table getTargetTable() {
-        long nativeTablePointer = nativeGetTargetTable(nativePtr);
-        return new Table(this.parent, nativeTablePointer);
-    }
-
-    private void checkImmutable() {
-        if (parent.isImmutable()) {
-            throw new IllegalStateException("Changing Realm data can only be done from inside a write transaction.");
-        }
-    }
-
-    native long nativeGetRow(long nativeLinkViewPtr, long pos);
-
-    private native long nativeGetTargetRowIndex(long nativeLinkViewPtr, long linkViewIndex);
-
-    public static native void nativeAdd(long nativeLinkViewPtr, long rowIndex);
-
-    private native void nativeInsert(long nativeLinkViewPtr, long pos, long rowIndex);
-
-    private native void nativeSet(long nativeLinkViewPtr, long pos, long rowIndex);
-
-    private native void nativeMove(long nativeLinkViewPtr, long oldPos, long newPos);
-
-    private native void nativeRemove(long nativeLinkViewPtr, long pos);
-
-    public static native void nativeClear(long nativeLinkViewPtr);
-
-    private native long nativeSize(long nativeLinkViewPtr);
-
-    private native boolean nativeIsEmpty(long nativeLinkViewPtr);
-
-    protected native long nativeWhere(long nativeLinkViewPtr);
-
-    private native boolean nativeIsAttached(long nativeLinkViewPtr);
-
-    private native long nativeFind(long nativeLinkViewPtr, long targetRowIndex);
-
-    private native void nativeRemoveTargetRow(long nativeLinkViewPtr, long rowIndex);
-
-    private native void nativeRemoveAllTargetRows(long nativeLinkViewPtr);
-
-    private native long nativeGetTargetTable(long nativeLinkViewPtr);
-
-    private static native long nativeGetFinalizerPtr();
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ManagableObject.java b/realm/realm-library/src/main/java/io/realm/internal/ManagableObject.java
new file mode 100644
index 0000000000..884da88dbb
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/ManagableObject.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal;
+
+/**
+ * This internal interface represents a java object that corresponds to data
+ * that may be managed in the Realm core. It specifies the operations common to all such objects.
+ */
+public interface ManagableObject {
+
+    /**
+     * Checks to see if this object is managed by Realm..
+     *
+     * @return {@code true} if this is a managed Realm object, {@code false} otherwise.
+     */
+    boolean isManaged();
+
+    /**
+     * Checks to see if the managed object is still valid to use.
+     * That is if it that it hasn't been deleted nor has the {@link io.realm.Realm} been closed.
+     * It will always return {@code true} for unmanaged objects.
+     *
+     * @return {@code true} if this object is unmanaged or is still valid for use, {@code false} otherwise.
+     */
+    boolean isValid();
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/NativeContext.java b/realm/realm-library/src/main/java/io/realm/internal/NativeContext.java
index f559678b76..be40d7ac3f 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/NativeContext.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/NativeContext.java
@@ -27,10 +27,10 @@
 // test_destructor_thread_safety.cpp. Explicit call of SharedGroup::close() or Table::detach() is also not thread-safe
 // with respect to destruction of other accessors.
 public class NativeContext {
-    private final static ReferenceQueue<NativeObject> referenceQueue = new ReferenceQueue<NativeObject>();
-    private final static Thread finalizingThread = new Thread(new FinalizerRunnable(referenceQueue));
+    private static final ReferenceQueue<NativeObject> referenceQueue = new ReferenceQueue<NativeObject>();
+    private static final Thread finalizingThread = new Thread(new FinalizerRunnable(referenceQueue));
     // Dummy context which will be used by native objects which's destructors are always thread safe.
-    final static NativeContext dummyContext = new NativeContext();
+    static final NativeContext dummyContext = new NativeContext();
 
     static {
         finalizingThread.setName("RealmFinalizingDaemon");
diff --git a/realm/realm-library/src/main/java/io/realm/internal/NativeObject.java b/realm/realm-library/src/main/java/io/realm/internal/NativeObject.java
index ce326dbf9b..ac8f32d2c4 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/NativeObject.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/NativeObject.java
@@ -21,7 +21,9 @@
  * It specifies the operations common to all such objects.
  * All Java classes wrapping a core class should implement NativeObject.
  */
-interface NativeObject {
+public interface NativeObject {
+    long NULLPTR = 0L;
+
     /**
      * Gets the pointer of a native object.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
index 7493da59d9..2e4cce938a 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
@@ -19,6 +19,7 @@
 import android.content.Context;
 
 import java.lang.reflect.InvocationTargetException;
+import java.net.URI;
 
 import io.realm.RealmConfiguration;
 import io.realm.exceptions.RealmException;
@@ -66,8 +67,8 @@ public void init(Context context) {
     public void realmClosed(RealmConfiguration configuration) {
     }
 
-    public String[] getUserAndServerUrl(RealmConfiguration config) {
-        return new String[4];
+    public Object[] getUserAndServerUrl(RealmConfiguration config) {
+        return new Object[8];
     }
 
     public static ObjectServerFacade getFacade(boolean needSyncFacade) {
@@ -86,6 +87,32 @@ public static ObjectServerFacade getSyncFacadeIfPossible() {
     }
 
     // If no session yet exists for this path. Wrap a new Java Session around an existing OS one.
-    public void wrapObjectStoreSessionIfRequired(RealmConfiguration config) {
+    public void wrapObjectStoreSessionIfRequired(OsRealmConfig config) {
+    }
+
+    public String getSyncServerCertificateAssetName(RealmConfiguration config) {
+        return null;
+    }
+
+    public String getSyncServerCertificateFilePath(RealmConfiguration config) {
+        return null;
+    }
+
+    /**
+     * Block until all latest changes have been downloaded from the server.
+     *
+     * @throws {@code DownloadingRealmInterruptedException} if the thread was interrupted while blocked waiting for
+     * this to complete.
+     */
+    @SuppressWarnings("JavaDoc")
+    public void downloadRemoteChanges(RealmConfiguration config) {
+        // Do nothing
+    }
+
+    /**
+     * Check if an exception is a {@code DownloadingRealmInterruptedException}
+     */
+    public boolean wasDownloadInterrupted(Throwable throwable) {
+        return false;
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObservableCollection.java b/realm/realm-library/src/main/java/io/realm/internal/ObservableCollection.java
new file mode 100644
index 0000000000..7004df192c
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObservableCollection.java
@@ -0,0 +1,72 @@
+package io.realm.internal;
+
+import javax.annotation.Nullable;
+
+import io.realm.OrderedCollectionChangeSet;
+import io.realm.OrderedRealmCollectionChangeListener;
+import io.realm.RealmChangeListener;
+
+// Helper class for supporting add change listeners on OsResults & OsList.
+@Keep
+interface ObservableCollection {
+
+    class CollectionObserverPair<T> extends ObserverPairList.ObserverPair<T, Object> {
+        public CollectionObserverPair(T observer, Object listener) {
+            super(observer, listener);
+        }
+
+        public void onChange(T observer, @Nullable OrderedCollectionChangeSet changes) {
+            if (listener instanceof OrderedRealmCollectionChangeListener) {
+                //noinspection unchecked
+                ((OrderedRealmCollectionChangeListener<T>) listener).onChange(observer, changes);
+            } else if (listener instanceof RealmChangeListener) {
+                //noinspection unchecked
+                ((RealmChangeListener<T>) listener).onChange(observer);
+            } else {
+                throw new RuntimeException("Unsupported listener type: " + listener);
+            }
+        }
+    }
+
+    class RealmChangeListenerWrapper<T> implements OrderedRealmCollectionChangeListener<T> {
+        private final RealmChangeListener<T> listener;
+
+        RealmChangeListenerWrapper(RealmChangeListener<T> listener) {
+            this.listener = listener;
+        }
+
+        @Override
+        public void onChange(T collection, @Nullable OrderedCollectionChangeSet changes) {
+            listener.onChange(collection);
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            return obj instanceof RealmChangeListenerWrapper &&
+                    listener == ((RealmChangeListenerWrapper) obj).listener;
+        }
+
+        @Override
+        public int hashCode() {
+            return listener.hashCode();
+        }
+    }
+
+    class Callback implements ObserverPairList.Callback<CollectionObserverPair> {
+        private final OrderedCollectionChangeSet changeSet;
+
+        Callback(@Nullable OrderedCollectionChangeSet changeSet) {
+            this.changeSet = changeSet;
+        }
+
+        @Override
+        public void onCalled(CollectionObserverPair pair, Object observer) {
+            //noinspection unchecked
+            pair.onChange(observer, changeSet);
+        }
+    }
+
+    // Called by JNI
+    @SuppressWarnings("SameParameterValue")
+    void notifyChangeListeners(long nativeChangeSetPtr);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObserverPairList.java b/realm/realm-library/src/main/java/io/realm/internal/ObserverPairList.java
index 876b031b9d..1a0c65a773 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ObserverPairList.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObserverPairList.java
@@ -71,6 +71,7 @@ public int hashCode() {
 
             int result = 17;
             result = 31 * result + ((observer != null) ? observer.hashCode() : 0);
+            //noinspection ConstantConditions
             result = 31 * result + ((listener != null) ? listener.hashCode() : 0);
             return result;
         }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/CollectionChangeSet.java b/realm/realm-library/src/main/java/io/realm/internal/OsCollectionChangeSet.java
similarity index 91%
rename from realm/realm-library/src/main/java/io/realm/internal/CollectionChangeSet.java
rename to realm/realm-library/src/main/java/io/realm/internal/OsCollectionChangeSet.java
index 9064f8fcde..986c18ba6d 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/CollectionChangeSet.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsCollectionChangeSet.java
@@ -16,16 +16,18 @@
 
 package io.realm.internal;
 
+import javax.annotation.Nullable;
+
 import io.realm.OrderedCollectionChangeSet;
 
 
 /**
  * Implementation of {@link OrderedCollectionChangeSet}. This class holds a pointer to the Object Store's
- * CollectionChangeSet and read from it only when needed. Creating an Java object from JNI when the collection
+ * OsCollectionChangeSet and read from it only when needed. Creating an Java object from JNI when the collection
  * notification arrives, is avoided since we also support the collection listeners without a change set parameter,
  * parsing the change set may not be necessary all the time.
  */
-public class CollectionChangeSet implements OrderedCollectionChangeSet, NativeObject {
+public class OsCollectionChangeSet implements OrderedCollectionChangeSet, NativeObject {
 
     // Used in JNI.
     @SuppressWarnings("WeakerAccess")
@@ -42,7 +44,7 @@
     private static long finalizerPtr = nativeGetFinalizerPtr();
     private final long nativePtr;
 
-    public CollectionChangeSet(long nativePtr) {
+    public OsCollectionChangeSet(long nativePtr) {
         this.nativePtr = nativePtr;
         NativeContext.dummyContext.addReference(this);
     }
@@ -110,6 +112,7 @@ public long getNativeFinalizerPtr() {
 
     // Convert long array returned by the nativeGetXxxRanges() to Range array.
     private Range[] longArrayToRangeArray(int[] longArray) {
+        //noinspection ConstantConditions
         if (longArray == null) {
             // Returns a size 0 array so we know JNI gets called.
             return new Range[0];
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsList.java b/realm/realm-library/src/main/java/io/realm/internal/OsList.java
new file mode 100644
index 0000000000..bedf3e928a
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsList.java
@@ -0,0 +1,341 @@
+package io.realm.internal;
+
+import java.util.Date;
+
+import javax.annotation.Nullable;
+
+import io.realm.OrderedRealmCollectionChangeListener;
+import io.realm.RealmChangeListener;
+
+/**
+ * Java wrapper of Object Store List class. This backs managed versions of RealmList.
+ */
+public class OsList implements NativeObject, ObservableCollection {
+
+    private final long nativePtr;
+    private final NativeContext context;
+    private final Table targetTable;
+    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
+    private final ObserverPairList<CollectionObserverPair> observerPairs =
+            new ObserverPairList<CollectionObserverPair>();
+
+    public OsList(UncheckedRow row, long columnIndex) {
+        SharedRealm sharedRealm = row.getTable().getSharedRealm();
+        long[] ptrs = nativeCreate(sharedRealm.getNativePtr(), row.getNativePtr(), columnIndex);
+
+        this.nativePtr = ptrs[0];
+        this.context = sharedRealm.context;
+        context.addReference(this);
+
+        if (ptrs[1] != 0) {
+            targetTable = new Table(sharedRealm, ptrs[1]);
+        } else {
+            targetTable = null;
+        }
+    }
+
+    @Override
+    public long getNativePtr() {
+        return nativePtr;
+    }
+
+    @Override
+    public long getNativeFinalizerPtr() {
+        return nativeFinalizerPtr;
+    }
+
+    public UncheckedRow getUncheckedRow(long index) {
+        return targetTable.getUncheckedRowByPointer(nativeGetRow(nativePtr, index));
+    }
+
+    public void addRow(long targetRowIndex) {
+        nativeAddRow(nativePtr, targetRowIndex);
+    }
+
+    public void insertRow(long pos, long targetRowIndex) {
+        nativeInsertRow(nativePtr, pos, targetRowIndex);
+    }
+
+    public void setRow(long pos, long targetRowIndex) {
+        nativeSetRow(nativePtr, pos, targetRowIndex);
+    }
+
+    public void addNull() {
+        nativeAddNull(nativePtr);
+    }
+
+    public void insertNull(long pos) {
+        nativeInsertNull(nativePtr, pos);
+    }
+
+    public void setNull(long pos) {
+        nativeSetNull(nativePtr, pos);
+    }
+
+    public void addLong(long value) {
+        nativeAddLong(nativePtr, value);
+    }
+
+    public void insertLong(long pos, long value) {
+        nativeInsertLong(nativePtr, pos, value);
+    }
+
+    public void setLong(long pos, long value) {
+        nativeSetLong(nativePtr, pos, value);
+    }
+
+    public void addDouble(double value) {
+        nativeAddDouble(nativePtr, value);
+    }
+
+    public void insertDouble(long pos, double value) {
+        nativeInsertDouble(nativePtr, pos, value);
+    }
+
+    public void setDouble(long pos, double value) {
+        nativeSetDouble(nativePtr, pos, value);
+    }
+
+    public void addFloat(float value) {
+        nativeAddFloat(nativePtr, value);
+    }
+
+    public void insertFloat(long pos, float value) {
+        nativeInsertFloat(nativePtr, pos, value);
+    }
+
+    public void setFloat(long pos, float value) {
+        nativeSetFloat(nativePtr, pos, value);
+    }
+
+    public void addBoolean(boolean value) {
+        nativeAddBoolean(nativePtr, value);
+    }
+
+    public void insertBoolean(long pos, boolean value) {
+        nativeInsertBoolean(nativePtr, pos, value);
+    }
+
+    public void setBoolean(long pos, boolean value) {
+        nativeSetBoolean(nativePtr, pos, value);
+    }
+
+    public void addBinary(@Nullable byte[] value) {
+        nativeAddBinary(nativePtr, value);
+    }
+
+    public void insertBinary(long pos, @Nullable byte[] value) {
+        nativeInsertBinary(nativePtr, pos, value);
+    }
+
+    public void setBinary(long pos, @Nullable byte[] value) {
+        nativeSetBinary(nativePtr, pos, value);
+    }
+
+    public void addString(@Nullable String value) {
+        nativeAddString(nativePtr, value);
+    }
+
+    public void insertString(long pos, @Nullable String value) {
+        nativeInsertString(nativePtr, pos, value);
+    }
+
+    public void setString(long pos, @Nullable String value) {
+        nativeSetString(nativePtr, pos, value);
+    }
+
+    public void addDate(@Nullable Date value) {
+        if (value == null) {
+            nativeAddNull(nativePtr);
+        } else {
+            nativeAddDate(nativePtr, value.getTime());
+        }
+    }
+
+    public void insertDate(long pos, @Nullable Date value) {
+        if (value == null) {
+            nativeInsertNull(nativePtr, pos);
+        } else {
+            nativeInsertDate(nativePtr, pos, value.getTime());
+        }
+    }
+
+    public void setDate(long pos, @Nullable Date value) {
+        if (value == null) {
+            nativeSetNull(nativePtr, pos);
+        } else {
+            nativeSetDate(nativePtr, pos, value.getTime());
+        }
+    }
+
+    @Nullable
+    public Object getValue(long pos) {
+        return nativeGetValue(nativePtr, pos);
+    }
+
+    public void move(long sourceIndex, long targetIndex) {
+        nativeMove(nativePtr, sourceIndex, targetIndex);
+    }
+
+    public void remove(long index) {
+        nativeRemove(nativePtr, index);
+    }
+
+    public void removeAll() {
+        nativeRemoveAll(nativePtr);
+    }
+
+    public long size() {
+        return nativeSize(nativePtr);
+    }
+
+    public boolean isEmpty() {
+        return nativeSize(nativePtr) <= 0;
+    }
+
+    /**
+     * @return a {@link TableQuery} based on this list.
+     */
+    public TableQuery getQuery() {
+        return new TableQuery(context, targetTable, nativeGetQuery(nativePtr));
+    }
+
+    public boolean isValid() {
+        return nativeIsValid(nativePtr);
+    }
+
+    public void delete(long index) {
+        nativeDelete(nativePtr, index);
+    }
+
+    public void deleteAll() {
+        nativeDeleteAll(nativePtr);
+    }
+
+    public Table getTargetTable() {
+        return targetTable;
+    }
+
+    public <T> void addListener(T observer, OrderedRealmCollectionChangeListener<T> listener) {
+        if (observerPairs.isEmpty()) {
+            nativeStartListening(nativePtr);
+        }
+        CollectionObserverPair<T> collectionObserverPair = new CollectionObserverPair<T>(observer, listener);
+        observerPairs.add(collectionObserverPair);
+    }
+
+    public <T> void addListener(T observer, RealmChangeListener<T> listener) {
+        addListener(observer, new RealmChangeListenerWrapper<T>(listener));
+    }
+
+    public <T> void removeListener(T observer, OrderedRealmCollectionChangeListener<T> listener) {
+        observerPairs.remove(observer, listener);
+        if (observerPairs.isEmpty()) {
+            nativeStopListening(nativePtr);
+        }
+    }
+
+    public <T> void removeListener(T observer, RealmChangeListener<T> listener) {
+        removeListener(observer, new RealmChangeListenerWrapper<T>(listener));
+    }
+
+    public void removeAllListeners() {
+        observerPairs.clear();
+        nativeStopListening(nativePtr);
+    }
+
+    // Called by JNI
+    @Override
+    public void notifyChangeListeners(long nativeChangeSetPtr) {
+        if (nativeChangeSetPtr == 0) {
+            // First time "query" returns. Do nothing.
+            return;
+        }
+        observerPairs.foreach(new Callback(new OsCollectionChangeSet(nativeChangeSetPtr)));
+    }
+
+    private static native long nativeGetFinalizerPtr();
+
+    // TODO: nativeTablePtr is not necessary. It is used to create FieldDescriptor which should be generated from
+    // OsSchemaInfo.
+    // Returns {nativeListPtr, nativeTablePtr}
+    private static native long[] nativeCreate(long nativeSharedRealmPtr, long nativeRowPtr, long columnIndex);
+
+    private static native long nativeGetRow(long nativePtr, long index);
+
+    private static native void nativeAddRow(long nativePtr, long targetRowIndex);
+
+    private static native void nativeInsertRow(long nativePtr, long pos, long targetRowIndex);
+
+    private static native void nativeSetRow(long nativePtr, long pos, long targetRowIndex);
+
+    private static native void nativeMove(long nativePtr, long sourceIndex, long targetIndex);
+
+    private static native void nativeRemove(long nativePtr, long index);
+
+    private static native void nativeRemoveAll(long nativePtr);
+
+    private static native long nativeSize(long nativePtr);
+
+    private static native long nativeGetQuery(long nativePtr);
+
+    private static native boolean nativeIsValid(long nativePtr);
+
+    private static native void nativeDelete(long nativePtr, long index);
+
+    private static native void nativeDeleteAll(long nativePtr);
+
+    private static native void nativeAddNull(long nativePtr);
+
+    private static native void nativeInsertNull(long nativePtr, long pos);
+
+    private static native void nativeSetNull(long nativePtr, long pos);
+
+    private static native void nativeAddLong(long nativePtr, long value);
+
+    private static native void nativeInsertLong(long nativePtr, long pos, long value);
+
+    private static native void nativeSetLong(long nativePtr, long pos, long value);
+
+    private static native void nativeAddDouble(long nativePtr, double value);
+
+    private static native void nativeInsertDouble(long nativePtr, long pos, double value);
+
+    private static native void nativeSetDouble(long nativePtr, long pos, double value);
+
+    private static native void nativeAddFloat(long nativePtr, float value);
+
+    private static native void nativeInsertFloat(long nativePtr, long pos, float value);
+
+    private static native void nativeSetFloat(long nativePtr, long pos, float value);
+
+    private static native void nativeAddBoolean(long nativePtr, boolean value);
+
+    private static native void nativeInsertBoolean(long nativePtr, long pos, boolean value);
+
+    private static native void nativeSetBoolean(long nativePtr, long pos, boolean value);
+
+    private static native void nativeAddBinary(long nativePtr, @Nullable byte[] value);
+
+    private static native void nativeInsertBinary(long nativePtr, long pos, @Nullable byte[] value);
+
+    private static native void nativeSetBinary(long nativePtr, long pos, @Nullable byte[] value);
+
+    private static native void nativeAddDate(long nativePtr, long value);
+
+    private static native void nativeInsertDate(long nativePtr, long pos, long value);
+
+    private static native void nativeSetDate(long nativePtr, long pos, long value);
+
+    private static native void nativeAddString(long nativePtr, @Nullable String value);
+
+    private static native void nativeInsertString(long nativePtr, long pos, @Nullable String value);
+
+    private static native void nativeSetString(long nativePtr, long pos, @Nullable String value);
+
+    private static native Object nativeGetValue(long nativePtr, long pos);
+
+    private native void nativeStartListening(long nativePtr);
+
+    private native void nativeStopListening(long nativePtr);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsObject.java b/realm/realm-library/src/main/java/io/realm/internal/OsObject.java
index 33e1807b04..8422bc5bfb 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsObject.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsObject.java
@@ -16,17 +16,23 @@
 
 package io.realm.internal;
 
+import javax.annotation.Nullable;
+
 import io.realm.ObjectChangeSet;
+import io.realm.RealmFieldType;
 import io.realm.RealmModel;
 import io.realm.RealmObjectChangeListener;
+import io.realm.exceptions.RealmException;
 
 
 /**
- * Java wrapper for Object Store's {@code Object} class. Currently it is only used for object notifications.
+ * Java wrapper for Object Store's {@code Object} class.
  */
-@KeepMember
+@Keep
 public class OsObject implements NativeObject {
 
+    private static final String OBJECT_ID_COLUMN_NAME = nativeGetObjectIdColumName();
+
     private static class OsObjectChangeSet implements ObjectChangeSet {
         final String[] changedFields;
         final boolean deleted;
@@ -63,7 +69,7 @@ public ObjectObserverPair(T observer, RealmObjectChangeListener<T> listener) {
             super(observer, listener);
         }
 
-        public void onChange(T observer, ObjectChangeSet changeSet) {
+        public void onChange(T observer, @Nullable ObjectChangeSet changeSet) {
             listener.onChange(observer, changeSet);
         }
     }
@@ -142,9 +148,107 @@ public void setObserverPairs(ObserverPairList<ObjectObserverPair> pairs) {
         }
     }
 
+    // TODO: consider to return a OsObject instead when integrating with Object Store's object accessor.
+    /**
+     * Create an object in the given table which doesn't have a primary key column defined.
+     *
+     * @param table the table where the object is created. This table must be atached to {@link SharedRealm}.
+     * @return a newly created {@code UncheckedRow}.
+     */
+    public static UncheckedRow create(Table table) {
+        final SharedRealm sharedRealm = table.getSharedRealm();
+        return new UncheckedRow(sharedRealm.context, table,
+                nativeCreateNewObject(sharedRealm.getNativePtr(), table.getNativePtr()));
+    }
+
+    /**
+     * Create a row in the given table which doesn't have a primary key column defined.
+     * This is used for the fast bulk insertion.
+     *
+     * @param table the table where the object is created.
+     * @return a newly created row's index.
+     */
+    public static long createRow(Table table) {
+        final SharedRealm sharedRealm = table.getSharedRealm();
+        return nativeCreateRow(sharedRealm.getNativePtr(), table.getNativePtr());
+    }
+
+    private static long getAndVerifyPrimaryKeyColumnIndex(Table table) {
+        String pkField = OsObjectStore.getPrimaryKeyForObject(table.getSharedRealm(), table.getClassName());
+        if (pkField == null) {
+            throw new IllegalStateException(table.getName() + " has no primary key defined.");
+        }
+        return table.getColumnIndex(pkField);
+    }
+
+    // TODO: consider to return a OsObject instead when integrating with Object Store's object accessor.
+    /**
+     * Create an object in the given table which has a primary key column defined, and set the primary key with given
+     * value.
+     *
+     * @param table the table where the object is created. This table must be atached to {@link SharedRealm}.
+     * @return a newly created {@code UncheckedRow}.
+     */
+    public static UncheckedRow createWithPrimaryKey(Table table, @Nullable Object primaryKeyValue) {
+        long primaryKeyColumnIndex = getAndVerifyPrimaryKeyColumnIndex(table);
+        RealmFieldType type = table.getColumnType(primaryKeyColumnIndex);
+        final SharedRealm sharedRealm = table.getSharedRealm();
+
+        if (type == RealmFieldType.STRING) {
+            if (primaryKeyValue != null && !(primaryKeyValue instanceof String)) {
+                throw new IllegalArgumentException("Primary key value is not a String: " + primaryKeyValue);
+            }
+            return new UncheckedRow(sharedRealm.context, table,
+                    nativeCreateNewObjectWithStringPrimaryKey(sharedRealm.getNativePtr(), table.getNativePtr(),
+                            primaryKeyColumnIndex, (String) primaryKeyValue));
+
+        } else if (type == RealmFieldType.INTEGER) {
+            long value = primaryKeyValue == null ? 0 : Long.parseLong(primaryKeyValue.toString());
+            return new UncheckedRow(sharedRealm.context, table,
+                    nativeCreateNewObjectWithLongPrimaryKey(sharedRealm.getNativePtr(), table.getNativePtr(),
+                            primaryKeyColumnIndex, value, primaryKeyValue == null));
+        } else {
+            throw new RealmException("Cannot check for duplicate rows for unsupported primary key type: " + type);
+        }
+    }
+
+    /**
+     * Create an object in the given table which has a primary key column defined, and set the primary key with given
+     * value.
+     * This is used for the fast bulk insertion.
+     *
+     * @param table the table where the object is created.
+     * @param primaryKeyColumnIndex the column index of primary key field.
+     * @param primaryKeyValue the primary key value.
+     * @return a newly created {@code UncheckedRow}.
+     */
+    // FIXME: Proxy could just pass the pk index here which is much faster.
+    public static long createRowWithPrimaryKey(Table table, long primaryKeyColumnIndex, Object primaryKeyValue) {
+        RealmFieldType type = table.getColumnType(primaryKeyColumnIndex);
+        final SharedRealm sharedRealm = table.getSharedRealm();
+
+        if (type == RealmFieldType.STRING) {
+            if (primaryKeyValue != null && !(primaryKeyValue instanceof String)) {
+                throw new IllegalArgumentException("Primary key value is not a String: " + primaryKeyValue);
+            }
+            return nativeCreateRowWithStringPrimaryKey(sharedRealm.getNativePtr(), table.getNativePtr(),
+                    primaryKeyColumnIndex, (String) primaryKeyValue);
+
+        } else if (type == RealmFieldType.INTEGER) {
+            long value = primaryKeyValue == null ? 0 : Long.parseLong(primaryKeyValue.toString());
+            return nativeCreateRowWithLongPrimaryKey(sharedRealm.getNativePtr(), table.getNativePtr(),
+                    primaryKeyColumnIndex, value, primaryKeyValue == null);
+        } else {
+            throw new RealmException("Cannot check for duplicate rows for unsupported primary key type: " + type);
+        }
+    }
+
+    public static boolean isObjectIdColumn(String columnName) {
+        return OBJECT_ID_COLUMN_NAME.equals(columnName);
+    }
+
     // Called by JNI
     @SuppressWarnings("unused")
-    @KeepMember
     private void notifyChangeListeners(String[] changedFields) {
         observerPairs.foreach(new Callback(changedFields));
     }
@@ -156,4 +260,32 @@ private void notifyChangeListeners(String[] changedFields) {
     private native void nativeStartListening(long nativePtr);
 
     private native void nativeStopListening(long nativePtr);
+
+    private static native long nativeCreateNewObject(long sharedRealmPtr, long tablePtr);
+
+    private static native long nativeCreateRow(long sharedRealmPtr, long tablePtr);
+
+
+    // Return a pointer to newly created Row. We may need to return a OsObject pointer in the future.
+    private static native long nativeCreateNewObjectWithLongPrimaryKey(long sharedRealmPtr,
+                                                                       long tablePtr, long pk_column_index,
+                                                                       long primaryKeyValue, boolean isNullValue);
+
+    // Return a index of newly created Row.
+    private static native long nativeCreateRowWithLongPrimaryKey(long sharedRealmPtr,
+                                                                 long tablePtr, long pk_column_index,
+                                                                 long primaryKeyValue, boolean isNullValue);
+
+    // Return a pointer to newly created Row. We may need to return a OsObject pointer in the future.
+    private static native long nativeCreateNewObjectWithStringPrimaryKey(long sharedRealmPtr,
+                                                                         long tablePtr, long pk_column_index,
+                                                                         @Nullable String primaryKeyValue);
+
+    // Return a index of newly created Row.
+    private static native long nativeCreateRowWithStringPrimaryKey(long sharedRealmPtr,
+                                                                   long tablePtr, long pk_column_index,
+                                                                   String primaryKeyValue);
+
+    // Return sync::object_id_column_name
+    private static native String nativeGetObjectIdColumName();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java b/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java
new file mode 100644
index 0000000000..dc23ee4f0f
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsObjectSchemaInfo.java
@@ -0,0 +1,212 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal;
+
+
+import javax.annotation.Nullable;
+
+import io.realm.RealmFieldType;
+
+/**
+ * Immutable Java wrapper for Object Store ObjectSchema.
+ *
+ * @see OsSchemaInfo
+ */
+public class OsObjectSchemaInfo implements NativeObject {
+
+    public static class Builder {
+        private final String className;
+        private final long[] persistedPropertyPtrArray;
+        private int persistedPropertyPtrCurPos = 0;
+        private final long[] computedPropertyPtrArray;
+        private int computedPropertyPtrCurPos = 0;
+
+        /**
+         * Creates an empty builder for {@code OsObjectSchemaInfo}. This constructor is intended to be used by
+         * the validation of schema, object schemas and properties through the object store.
+         *
+         * @param className name of the class
+         */
+        public Builder(String className, int persistedPropertyCapacity, int computedPropertyCapacity) {
+            this.className = className;
+            this.persistedPropertyPtrArray = new long[persistedPropertyCapacity];
+            this.computedPropertyPtrArray = new long[computedPropertyCapacity];
+        }
+
+        /**
+         * Adds a persisted non-link, non value list property to this builder.
+         *
+         * @param name the name of the property.
+         * @param type the type of the property.
+         * @param isPrimaryKey set to true if this property is the primary key.
+         * @param isIndexed set to true if this property needs an index.
+         * @param isRequired set to true if this property is not nullable.
+         * @return this {@code OsObjectSchemaInfo}.
+         */
+        public Builder addPersistedProperty(String name, RealmFieldType type, boolean isPrimaryKey, boolean isIndexed,
+                boolean isRequired) {
+            long propertyPtr = Property.nativeCreatePersistedProperty(name,
+                    Property.convertFromRealmFieldType(type, isRequired), isPrimaryKey, isIndexed);
+            persistedPropertyPtrArray[persistedPropertyPtrCurPos] = propertyPtr;
+            persistedPropertyPtrCurPos++;
+            return this;
+        }
+
+        /**
+         * Adds a persisted value list property to this builder.
+         *
+         * @param name the name of the property.
+         * @param type the type of the property. It must be one of value list type.
+         * @param isRequired set to true if this property is not nullable.
+         * @return this {@code OsObjectSchemaInfo}.
+         */
+        public Builder addPersistedValueListProperty(String name, RealmFieldType type, boolean isRequired) {
+            long propertyPtr = Property.nativeCreatePersistedProperty(name,
+                    Property.convertFromRealmFieldType(type, isRequired), !Property.PRIMARY_KEY, !Property.INDEXED);
+            persistedPropertyPtrArray[persistedPropertyPtrCurPos] = propertyPtr;
+            persistedPropertyPtrCurPos++;
+            return this;
+        }
+
+        /**
+         * Adds a persisted link property to this {@code OsObjectSchemaInfo}. A persisted link property will be stored
+         * in the Realm file's schema.
+         *
+         * @param name the name of the link property.
+         * @param type the type of the link property. Can only be {@link RealmFieldType#OBJECT} or
+         * {@link RealmFieldType#LIST}.
+         * @return this {@code OsObjectSchemaInfo.Builder}.
+         */
+        public Builder addPersistedLinkProperty(String name, RealmFieldType type, String linkedClassName) {
+            long propertyPtr = Property.nativeCreatePersistedLinkProperty(name,
+                    Property.convertFromRealmFieldType(type, false), linkedClassName);
+            persistedPropertyPtrArray[persistedPropertyPtrCurPos] = propertyPtr;
+            persistedPropertyPtrCurPos++;
+            return this;
+        }
+
+        /**
+         * Adds a computed link property to this {@code OsObjectSchemaInfo}. A computed link property doesn't store
+         * information in the Realm file's schema. This property type will always be
+         * {@link RealmFieldType#LINKING_OBJECTS}.
+         *
+         * @param name the name of the link property.
+         * @param targetClassname The class name of the property links to.
+         * @param targetFieldName The field name of the property links to.
+         * @return this {@code OsObjectSchemaInfo.Builder}.
+         */
+        public Builder addComputedLinkProperty(String name, String targetClassname, String targetFieldName) {
+            long propertyPtr = Property.nativeCreateComputedLinkProperty(name, targetClassname, targetFieldName);
+            computedPropertyPtrArray[computedPropertyPtrCurPos] = propertyPtr;
+            computedPropertyPtrCurPos++;
+            return this;
+        }
+
+        /**
+         * Creates {@link OsObjectSchemaInfo} object from this builder. After calling, this {@code Builder} becomes
+         * invalid. All the property pointers will be freed.
+         *
+         * @return a newly created {@link OsObjectSchemaInfo}.
+         */
+        public OsObjectSchemaInfo build() {
+            if (persistedPropertyPtrCurPos == -1 || computedPropertyPtrCurPos == -1) {
+                throw new IllegalStateException("'OsObjectSchemaInfo.build()' has been called before on this object.");
+            }
+            OsObjectSchemaInfo info = new OsObjectSchemaInfo(className);
+            nativeAddProperties(info.nativePtr, persistedPropertyPtrArray, computedPropertyPtrArray);
+            persistedPropertyPtrCurPos = -1;
+            computedPropertyPtrCurPos = -1;
+            return info;
+        }
+    }
+
+    private long nativePtr;
+    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
+
+    /**
+     * Creates an empty schema object using object store. This constructor is intended to be used by
+     * the validation of schema, object schemas and properties through the object store.
+     *
+     * @param className name of the class
+     */
+    private OsObjectSchemaInfo(String className) {
+        this(nativeCreateRealmObjectSchema(className));
+    }
+
+    /**
+     * Creates a java wrapper class for given {@code ObjectSchema} pointer. This java wrapper will take the ownership of
+     * the object's memory and release it through phantom reference.
+     *
+     * @param nativePtr pointer to the {@code ObjectSchema} object.
+     */
+    OsObjectSchemaInfo(long nativePtr) {
+        this.nativePtr = nativePtr;
+        NativeContext.dummyContext.addReference(this);
+    }
+
+    /**
+     * @return the class name of this {@code OsObjectSchema} represents for.
+     */
+    public String getClassName() {
+        return nativeGetClassName(nativePtr);
+    }
+
+    /**
+     * Returns a property by the given name.
+     *
+     * @param propertyName the name of the property.
+     * @return a {@link Property} object.
+     */
+    public Property getProperty(String propertyName) {
+        return new Property(nativeGetProperty(nativePtr, propertyName));
+    }
+
+    /**
+     * Returns the primary key property for this {@code ObjectSchema}.
+     *
+     * @return a {@link Property} object of the primary key property, {@code null} if this {@code ObjectSchema} doesn't
+     * contains a primary key.
+     */
+    public @Nullable Property getPrimaryKeyProperty() {
+        long propertyPtr = nativeGetPrimaryKeyProperty(nativePtr);
+        return propertyPtr == 0 ? null : new Property(nativeGetPrimaryKeyProperty(nativePtr));
+    }
+
+    @Override
+    public long getNativePtr() {
+        return nativePtr;
+    }
+
+    @Override
+    public long getNativeFinalizerPtr() {
+        return nativeFinalizerPtr;
+    }
+
+    private static native long nativeCreateRealmObjectSchema(String className);
+
+    private static native long nativeGetFinalizerPtr();
+
+    // Add properties to the ObjectSchema and delete property pointers.
+    private static native void nativeAddProperties(long nativePtr, long[] persistedPropPtrs, long[] computedPropPtrs);
+
+    private static native String nativeGetClassName(long nativePtr);
+
+    // Throw ISE if the property doesn't exist.
+    private static native long nativeGetProperty(long nativePtr, String propertyName);
+
+    // Return nullptr if it doesn't have a primary key.
+    private static native long nativeGetPrimaryKeyProperty(long nativePtr);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsObjectStore.java b/realm/realm-library/src/main/java/io/realm/internal/OsObjectStore.java
new file mode 100644
index 0000000000..aa2b9f8192
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsObjectStore.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import javax.annotation.Nullable;
+
+import io.realm.RealmConfiguration;
+
+/**
+ * Java wrapper for methods in object_store.hpp.
+ */
+public class OsObjectStore {
+
+    public final static long SCHEMA_NOT_VERSIONED = -1;
+
+    /**
+     * Sets the primary key field for the given class.
+     * <p>
+     * NOTE: The search index has to be added to the field before calling this method.
+     *
+     * @throws IllegalStateException if it is not in a transaction.
+     * @throws IllegalStateException if the given class doesn't exist.
+     * @throws IllegalStateException if the given field doesn't exist.
+     * @throws IllegalStateException if the given field is not a valid type for primary key.
+     * @throws IllegalStateException if there are duplicated values for the given field.
+     */
+    public static void setPrimaryKeyForObject(SharedRealm sharedRealm, String className,
+                                              @Nullable String primaryKeyFieldName) {
+        nativeSetPrimaryKeyForObject(sharedRealm.getNativePtr(), className, primaryKeyFieldName);
+    }
+
+    public static @Nullable String getPrimaryKeyForObject(SharedRealm sharedRealm, String className) {
+        return nativeGetPrimaryKeyForObject(sharedRealm.getNativePtr(), className);
+    }
+
+    /**
+     * Sets the schema version to the given {@link SharedRealm}. This method will create meta tables if they don't exist.
+     * @throws IllegalStateException if it is not in a transaction.
+     */
+    public static void setSchemaVersion(SharedRealm sharedRealm, long schemaVersion) {
+        nativeSetSchemaVersion(sharedRealm.getNativePtr(), schemaVersion);
+    }
+
+    /**
+     * Returns the schema version of the given {@link SharedRealm}. If meta tables don't exist, this will return
+     * {@link #SCHEMA_NOT_VERSIONED}.
+     */
+    public static long getSchemaVersion(SharedRealm sharedRealm) {
+        return nativeGetSchemaVersion(sharedRealm.getNativePtr());
+    }
+
+    /**
+     * Deletes the table with the given class name.
+     *
+     * @return {@code true} if the table has been deleted. {@code false} if the table doesn't exist.
+     * @throws IllegalStateException if it is not in a transaction.
+     */
+    public static boolean deleteTableForObject(SharedRealm sharedRealm, String className) {
+        return nativeDeleteTableForObject(sharedRealm.getNativePtr(), className);
+    }
+
+    /**
+     * Try to grab an exclusive lock on the given Realm file. If the lock can be acquired, the {@code runnable} will be
+     * executed while the lock is held. The lock will ensure no one else can read from or write to the Realm file at the
+     * same time.
+     *
+     * @param configuration to specify the realm path.
+     * @param runnable to run with lock.
+     * @return {@code true} if the lock can be acquired and the {@code runnable} has been executed.
+     */
+    public static boolean callWithLock(RealmConfiguration configuration, Runnable runnable) {
+        return nativeCallWithLock(configuration.getPath(), runnable);
+    }
+
+    private native static void nativeSetPrimaryKeyForObject(long sharedRealmPtr, String className,
+                                                             @Nullable String primaryKeyFieldName);
+
+    private native static @Nullable String nativeGetPrimaryKeyForObject(long sharedRealmPtr, String className);
+
+    private native static void nativeSetSchemaVersion(long sharedRealmPtr, long schemaVersion);
+
+    private native static long nativeGetSchemaVersion(long sharedRealmPtr);
+
+    private native static boolean nativeDeleteTableForObject(long sharedRealmPtr, String className);
+
+    private native static boolean nativeCallWithLock(String realmPath, Runnable runnable);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java b/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
new file mode 100644
index 0000000000..afc199fe72
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsRealmConfig.java
@@ -0,0 +1,302 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+import javax.annotation.Nullable;
+
+import io.realm.CompactOnLaunchCallback;
+import io.realm.RealmConfiguration;
+import io.realm.log.RealmLog;
+
+/**
+ * Java wrapper of Object Store's Realm::Config.
+ */
+public class OsRealmConfig implements NativeObject {
+
+    public enum Durability {
+        FULL(0),
+        MEM_ONLY(1);
+
+        final int value;
+
+        Durability(int value) {
+            this.value = value;
+        }
+    }
+
+    public enum SchemaMode {
+        SCHEMA_MODE_AUTOMATIC(SCHEMA_MODE_VALUE_AUTOMATIC),
+        SCHEMA_MODE_IMMUTABLE(SCHEMA_MODE_VALUE_IMMUTABLE),
+        SCHEMA_MODE_READONLY(SCHEMA_MODE_VALUE_READONLY),
+        SCHEMA_MODE_RESET_FILE(SCHEMA_MODE_VALUE_RESET_FILE),
+        SCHEMA_MODE_ADDITIVE(SCHEMA_MODE_VALUE_ADDITIVE),
+        SCHEMA_MODE_MANUAL(SCHEMA_MODE_VALUE_MANUAL);
+
+        final byte value;
+
+        SchemaMode(byte value) {
+            this.value = value;
+        }
+
+        public byte getNativeValue() {
+            return value;
+        }
+    }
+
+    public enum SyncSessionStopPolicy {
+        IMMEDIATELY(SYNCSESSION_STOP_POLICY_VALUE_IMMEDIATELY), // Immediately stop the session as soon as all Realms/Sessions go out of scope.
+        LIVE_INDEFINITELY(SYNCSESSION_STOP_POLICY_VALUE_LIVE_INDEFINETELY),   // Never stop the session.
+        AFTER_CHANGES_UPLOADED(SYNCSESSION_STOP_POLICY_VALUE_AFTER_CHANGES_UPLOADED); // Once all Realms/Sessions go out of scope, wait for uploads to complete and stop.
+
+        final byte value;
+
+        SyncSessionStopPolicy(byte value) {
+            this.value = value;
+        }
+
+        public byte getNativeValue() {
+            return value;
+        }
+    }
+
+    /**
+     * Builder class for creating {@code OsRealmConfig}. The {@code OsRealmConfig} instance should only be created by
+     * {@link SharedRealm}.
+     */
+    public static class Builder {
+        private RealmConfiguration configuration;
+        private OsSchemaInfo schemaInfo = null;
+        private SharedRealm.MigrationCallback migrationCallback = null;
+        private SharedRealm.InitializationCallback initializationCallback = null;
+        private boolean autoUpdateNotification = false;
+
+        /**
+         * Initialize a {@link OsRealmConfig.Builder} with a given {@link RealmConfiguration}.
+         */
+        public Builder(RealmConfiguration configuration) {
+            this.configuration = configuration;
+        }
+
+        /**
+         * Sets the schema which Object Store initializes the Realm with.
+         *
+         * @param schemaInfo {@code null} to initialize the Realm in dynamic schema mode. Otherwise Object Store will
+         *                   initialize the Realm with given schema and handle migration with it.
+         * @return this {@link OsRealmConfig.Builder}.
+         */
+        public Builder schemaInfo(@Nullable OsSchemaInfo schemaInfo) {
+            this.schemaInfo = schemaInfo;
+            return this;
+        }
+
+        /**
+         * Sets the callback when manual migration needed.
+         *
+         * @param migrationCallback callback to be set.
+         * @return this {@link OsRealmConfig.Builder}.
+         */
+        public Builder migrationCallback(@Nullable SharedRealm.MigrationCallback migrationCallback) {
+            this.migrationCallback = migrationCallback;
+            return this;
+        }
+
+        /**
+         * Sets the callback which will be called when the Realm is created and the schema has just been initialized.
+         *
+         * @param initializationCallback the callback to be set.
+         * @return this {@link OsRealmConfig.Builder}.
+         */
+        public Builder initializationCallback(@Nullable SharedRealm.InitializationCallback initializationCallback) {
+            this.initializationCallback = initializationCallback;
+            return this;
+        }
+
+        /**
+         * Set to {@code false} to disable the background worker thread for producing change notifications. Change
+         * notifications are enabled by default.
+         *
+         * @param autoUpdateNotification {@code false} to disable. {@code true} to enable it.
+         * @return this {@link OsRealmConfig.Builder}.
+         */
+        public Builder autoUpdateNotification(boolean autoUpdateNotification) {
+            this.autoUpdateNotification = autoUpdateNotification;
+            return this;
+        }
+
+        // Package private because of the OsRealmConfig needs to carry the NativeContext. This should only be called
+        // by the SharedRealm.
+        OsRealmConfig build() {
+            return new OsRealmConfig(configuration, autoUpdateNotification, schemaInfo,
+                    migrationCallback, initializationCallback);
+        }
+    }
+
+    private static final byte SCHEMA_MODE_VALUE_AUTOMATIC = 0;
+    private static final byte SCHEMA_MODE_VALUE_IMMUTABLE = 1;
+    private static final byte SCHEMA_MODE_VALUE_READONLY = 2;
+    private static final byte SCHEMA_MODE_VALUE_RESET_FILE = 3;
+    private static final byte SCHEMA_MODE_VALUE_ADDITIVE = 4;
+    private static final byte SCHEMA_MODE_VALUE_MANUAL = 5;
+    private static final byte SYNCSESSION_STOP_POLICY_VALUE_IMMEDIATELY = 0;
+    private static final byte SYNCSESSION_STOP_POLICY_VALUE_LIVE_INDEFINETELY = 1;
+    private static final byte SYNCSESSION_STOP_POLICY_VALUE_AFTER_CHANGES_UPLOADED = 2;
+
+    private final static long nativeFinalizerPtr = nativeGetFinalizerPtr();
+
+    private final RealmConfiguration realmConfiguration;
+    private final URI resolvedRealmURI;
+    private final long nativePtr;
+    // Every SharedRealm instance has to be created from an OsRealmConfig instance. And the SharedRealm's NativeContext
+    // object will be the same as the context here. This is because of we may create different SharedRealm instances
+    // with different shared_ptrs which are point to the same SharedGroup object. It could happen when we create
+    // SharedRealm for migration/initialization callback. The context has to be the same object for those cases for
+    // core destructor's thread safety.
+    private final NativeContext context = new NativeContext();
+
+    // Hold a ref to callbacks to make sure they won't be GCed before getting called.
+    // JNI should only hold a weak ref in the lambda functions.
+    @SuppressWarnings({"FieldCanBeLocal", "unused"})
+    private final CompactOnLaunchCallback compactOnLaunchCallback;
+    @SuppressWarnings({"FieldCanBeLocal", "unused"})
+    private final SharedRealm.MigrationCallback migrationCallback;
+    @SuppressWarnings({"FieldCanBeLocal", "unused"})
+    private final SharedRealm.InitializationCallback initializationCallback;
+
+    private OsRealmConfig(final RealmConfiguration config,
+                          boolean autoUpdateNotification,
+                          @Nullable OsSchemaInfo schemaInfo,
+                          @Nullable SharedRealm.MigrationCallback migrationCallback,
+                          @Nullable SharedRealm.InitializationCallback initializationCallback) {
+        this.realmConfiguration = config;
+        this.nativePtr = nativeCreate(config.getPath(), false, true);
+        NativeContext.dummyContext.addReference(this);
+
+        // Retrieve Sync settings first. We need syncRealmUrl to identify if this is a SyncConfig
+        Object[] syncConfigurationOptions = ObjectServerFacade.getSyncFacadeIfPossible().getUserAndServerUrl(realmConfiguration);
+        String syncUserIdentifier = (String) syncConfigurationOptions[0];
+        String syncRealmUrl = (String) syncConfigurationOptions[1];
+        String syncRealmAuthUrl = (String) syncConfigurationOptions[2];
+        String syncRefreshToken = (String) syncConfigurationOptions[3];
+        boolean syncClientValidateSsl = (Boolean.TRUE.equals(syncConfigurationOptions[4]));
+        String syncSslTrustCertificatePath = (String) syncConfigurationOptions[5];
+        Byte sessionStopPolicy = (Byte) syncConfigurationOptions[6];
+        boolean isPartial = (Boolean.TRUE.equals(syncConfigurationOptions[7]));
+
+        // Set encryption key
+        byte[] key = config.getEncryptionKey();
+        if (key != null) {
+            nativeSetEncryptionKey(nativePtr, key);
+        }
+
+        // Set durability
+        nativeSetInMemory(nativePtr, config.getDurability() == Durability.MEM_ONLY);
+
+        // Set auto update notification
+        nativeEnableChangeNotification(nativePtr, autoUpdateNotification);
+
+        // Set schema related params.
+        SchemaMode schemaMode = SchemaMode.SCHEMA_MODE_MANUAL;
+        if (config.isRecoveryConfiguration()) {
+            schemaMode = SchemaMode.SCHEMA_MODE_IMMUTABLE;
+        } else if (config.isReadOnly()) {
+            schemaMode = SchemaMode.SCHEMA_MODE_READONLY;
+        } else if (syncRealmUrl != null) {
+            schemaMode = SchemaMode.SCHEMA_MODE_ADDITIVE;
+        } else if (config.shouldDeleteRealmIfMigrationNeeded()) {
+            schemaMode = SchemaMode.SCHEMA_MODE_RESET_FILE;
+        }
+        final long schemaVersion = config.getSchemaVersion();
+        final long nativeSchemaPtr = schemaInfo == null ? 0 : schemaInfo.getNativePtr();
+        this.migrationCallback = migrationCallback;
+        nativeSetSchemaConfig(nativePtr, schemaMode.getNativeValue(), schemaVersion, nativeSchemaPtr, migrationCallback);
+
+        // Compact on launch
+        this.compactOnLaunchCallback = config.getCompactOnLaunchCallback();
+        if (compactOnLaunchCallback != null) {
+            nativeSetCompactOnLaunchCallback(nativePtr, compactOnLaunchCallback);
+        }
+
+        // Initial data transaction
+        this.initializationCallback = initializationCallback;
+        if (initializationCallback != null) {
+            nativeSetInitializationCallback(nativePtr, initializationCallback);
+        }
+
+        URI resolvedRealmURI  = null;
+        // Set sync config
+        if (syncRealmUrl != null) {
+            String resolvedSyncRealmUrl = nativeCreateAndSetSyncConfig(nativePtr, syncRealmUrl, syncRealmAuthUrl, syncUserIdentifier,
+                    syncRefreshToken, isPartial, sessionStopPolicy);
+            try {
+                resolvedRealmURI = new URI(resolvedSyncRealmUrl);
+            } catch (URISyntaxException e) {
+                RealmLog.error(e, "Cannot create a URI from the Realm URL address");
+            }
+            nativeSetSyncConfigSslSettings(nativePtr, syncClientValidateSsl, syncSslTrustCertificatePath);
+        }
+        this.resolvedRealmURI = resolvedRealmURI;
+    }
+
+    @Override
+    public long getNativePtr() {
+        return nativePtr;
+    }
+
+    @Override
+    public long getNativeFinalizerPtr() {
+        return nativeFinalizerPtr;
+    }
+
+    public RealmConfiguration getRealmConfiguration() {
+        return realmConfiguration;
+    }
+
+    public URI getResolvedRealmURI() {
+        return resolvedRealmURI;
+    }
+
+    NativeContext getContext() {
+        return context;
+    }
+
+    private static native long nativeCreate(String path, boolean enableCache, boolean enableFormatUpdate);
+
+    private static native void nativeSetEncryptionKey(long nativePtr, byte[] key);
+
+    private static native void nativeSetInMemory(long nativePtr, boolean inMem);
+
+    private native void nativeSetSchemaConfig(long nativePtr, byte schemaMode, long schemaVersion,
+                                              long schemaInfoPtr,
+                                              @Nullable SharedRealm.MigrationCallback migrationCallback);
+
+    private static native void nativeSetCompactOnLaunchCallback(long nativePtr, CompactOnLaunchCallback callback);
+
+    private native void nativeSetInitializationCallback(long nativePtr, SharedRealm.InitializationCallback callback);
+
+    private static native void nativeEnableChangeNotification(long nativePtr, boolean enableNotification);
+
+    private static native String nativeCreateAndSetSyncConfig(long nativePtr, String syncRealmUrl,
+                                                            String authUrl, String userId, String refreshToken, boolean isPartial, byte sessionStopPolicy);
+
+    private static native void nativeSetSyncConfigSslSettings(long nativePtr,
+                                                              boolean validateSsl, String trustCertificatePath);
+
+    private static native long nativeGetFinalizerPtr();
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Collection.java b/realm/realm-library/src/main/java/io/realm/internal/OsResults.java
similarity index 72%
rename from realm/realm-library/src/main/java/io/realm/internal/Collection.java
rename to realm/realm-library/src/main/java/io/realm/internal/OsResults.java
index 635a6e52a9..ce294974ea 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Collection.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsResults.java
@@ -20,98 +20,42 @@
 import java.util.Date;
 import java.util.NoSuchElementException;
 
-import io.realm.OrderedCollectionChangeSet;
+import javax.annotation.Nullable;
+
 import io.realm.OrderedRealmCollectionChangeListener;
 import io.realm.RealmChangeListener;
 
 
 /**
  * Java wrapper of Object Store Results class.
- * It is the backend of binding's query results, link lists and back links.
+ * It is the backend of binding's query results and back links.
  */
-@Keep
-public class Collection implements NativeObject {
+public class OsResults implements NativeObject, ObservableCollection {
 
     private static final String CLOSED_REALM_MESSAGE =
             "This Realm instance has already been closed, making it unusable.";
 
-    private static class CollectionObserverPair<T> extends ObserverPairList.ObserverPair<T, Object> {
-        public CollectionObserverPair(T observer, Object listener) {
-            super(observer, listener);
-        }
-
-        public void onChange(T observer, OrderedCollectionChangeSet changes) {
-            if (listener instanceof OrderedRealmCollectionChangeListener) {
-                //noinspection unchecked
-                ((OrderedRealmCollectionChangeListener<T>) listener).onChange(observer, changes);
-            } else if (listener instanceof RealmChangeListener) {
-                //noinspection unchecked
-                ((RealmChangeListener<T>) listener).onChange(observer);
-            } else {
-                throw new RuntimeException("Unsupported listener type: " + listener);
-            }
-        }
-    }
-
-    private static class RealmChangeListenerWrapper<T> implements OrderedRealmCollectionChangeListener<T> {
-        private final RealmChangeListener<T> listener;
-
-        RealmChangeListenerWrapper(RealmChangeListener<T> listener) {
-            this.listener = listener;
-        }
-
-        @Override
-        public void onChange(T collection, OrderedCollectionChangeSet changes) {
-            listener.onChange(collection);
-        }
-
-        @Override
-        public boolean equals(Object obj) {
-            return obj instanceof RealmChangeListenerWrapper &&
-                    listener == ((RealmChangeListenerWrapper) obj).listener;
-        }
-
-        @Override
-        public int hashCode() {
-            return listener.hashCode();
-        }
-    }
-
-    private static class Callback implements ObserverPairList.Callback<CollectionObserverPair> {
-        private final OrderedCollectionChangeSet changeSet;
-
-        Callback(OrderedCollectionChangeSet changeSet) {
-            this.changeSet = changeSet;
-        }
-
-        @Override
-        public void onCalled(CollectionObserverPair pair, Object observer) {
-            //noinspection unchecked
-            pair.onChange(observer, changeSet);
-        }
-    }
-
-    // Custom Collection iterator. It ensures that we only iterate on a Realm collection that hasn't changed.
+    // Custom OsResults iterator. It ensures that we only iterate on a Realm OsResults that hasn't changed.
     public static abstract class Iterator<T> implements java.util.Iterator<T> {
-        Collection iteratorCollection;
+        OsResults iteratorOsResults;
         protected int pos = -1;
 
-        public Iterator(Collection collection) {
-            if (collection.sharedRealm.isClosed()) {
+        public Iterator(OsResults osResults) {
+            if (osResults.sharedRealm.isClosed()) {
                 throw new IllegalStateException(CLOSED_REALM_MESSAGE);
             }
 
-            this.iteratorCollection = collection;
+            this.iteratorOsResults = osResults;
 
-            if (collection.isSnapshot) {
+            if (osResults.isSnapshot) {
                 // No need to detach a snapshot.
                 return;
             }
 
-            if (collection.sharedRealm.isInTransaction()) {
+            if (osResults.sharedRealm.isInTransaction()) {
                 detach();
             } else {
-                iteratorCollection.sharedRealm.addIterator(this);
+                iteratorOsResults.sharedRealm.addIterator(this);
             }
         }
 
@@ -121,18 +65,19 @@ public Iterator(Collection collection) {
         @Override
         public boolean hasNext() {
             checkValid();
-            return pos + 1 < iteratorCollection.size();
+            return pos + 1 < iteratorOsResults.size();
         }
 
         /**
          * {@inheritDoc}
          */
         @Override
+        @Nullable
         public T next() {
             checkValid();
             pos++;
-            if (pos >= iteratorCollection.size()) {
-                throw new NoSuchElementException("Cannot access index " + pos + " when size is " + iteratorCollection.size() +
+            if (pos >= iteratorOsResults.size()) {
+                throw new NoSuchElementException("Cannot access index " + pos + " when size is " + iteratorOsResults.size() +
                         ". Remember to check hasNext() before using next().");
             }
             return get(pos);
@@ -150,7 +95,7 @@ public void remove() {
         }
 
         void detach() {
-            iteratorCollection = iteratorCollection.createSnapshot();
+            iteratorOsResults = iteratorOsResults.createSnapshot();
         }
 
         // The iterator becomes invalid after receiving a remote change notification. In Java, the destruction of
@@ -158,18 +103,19 @@ void detach() {
         // like what realm-cocoa does, we will have a massive overhead since all the iterators created in the previous
         // event loop need to be detached.
         void invalidate() {
-            iteratorCollection = null;
+            iteratorOsResults = null;
         }
 
         void checkValid() {
-            if (iteratorCollection == null) {
+            if (iteratorOsResults == null) {
                 throw new ConcurrentModificationException(
                         "No outside changes to a Realm is allowed while iterating a living Realm collection.");
             }
         }
 
+        @Nullable
         T get(int pos) {
-            return convertRowToObject(iteratorCollection.getUncheckedRow(pos));
+            return convertRowToObject(iteratorOsResults.getUncheckedRow(pos));
         }
 
         // Returns the RealmModel by given row in this list. This has to be implemented in the upper layer since
@@ -180,13 +126,13 @@ T get(int pos) {
     // Custom Realm collection list iterator.
     public static abstract class ListIterator<T> extends Iterator<T> implements java.util.ListIterator<T> {
 
-        public ListIterator(Collection collection, int start) {
-            super(collection);
-            if (start >= 0 && start <= iteratorCollection.size()) {
+        public ListIterator(OsResults osResults, int start) {
+            super(osResults);
+            if (start >= 0 && start <= iteratorOsResults.size()) {
                 pos = start - 1;
             } else {
                 throw new IndexOutOfBoundsException("Starting location must be a valid index: [0, "
-                        + (iteratorCollection.size() - 1) + "]. Yours was " + start);
+                        + (iteratorOsResults.size() - 1) + "]. Yours was " + start);
             }
         }
 
@@ -197,7 +143,7 @@ public ListIterator(Collection collection, int start) {
          */
         @Override
         @Deprecated
-        public void add(T object) {
+        public void add(@Nullable T object) {
             throw new UnsupportedOperationException("Adding an element is not supported. Use Realm.createObject() instead.");
         }
 
@@ -223,6 +169,7 @@ public int nextIndex() {
          * {@inheritDoc}
          */
         @Override
+        @Nullable
         public T previous() {
             checkValid();
             try {
@@ -251,7 +198,7 @@ public int previousIndex() {
          */
         @Override
         @Deprecated
-        public void set(T object) {
+        public void set(@Nullable T object) {
             throw new UnsupportedOperationException("Replacing and element is not supported.");
         }
     }
@@ -329,17 +276,17 @@ static Mode getByValue(byte value) {
         }
     }
 
-    public static Collection createBacklinksCollection(SharedRealm realm, UncheckedRow row, Table srcTable, String srcFieldName) {
+    public static OsResults createBacklinksCollection(SharedRealm realm, UncheckedRow row, Table srcTable, String srcFieldName) {
         long backlinksPtr = nativeCreateResultsFromBacklinks(
                 realm.getNativePtr(),
                 row.getNativePtr(),
                 srcTable.getNativePtr(),
                 srcTable.getColumnIndex(srcFieldName));
-        return new Collection(realm, srcTable, backlinksPtr, true);
+        return new OsResults(realm, srcTable, backlinksPtr, true);
     }
 
-    public Collection(SharedRealm sharedRealm, TableQuery query,
-            SortDescriptor sortDescriptor, SortDescriptor distinctDescriptor) {
+    public OsResults(SharedRealm sharedRealm, TableQuery query,
+                     @Nullable SortDescriptor sortDescriptor, @Nullable SortDescriptor distinctDescriptor) {
         query.validateQuery();
 
         this.nativePtr = nativeCreateResults(sharedRealm.getNativePtr(), query.getNativePtr(),
@@ -353,32 +300,31 @@ public Collection(SharedRealm sharedRealm, TableQuery query,
         this.loaded = false;
     }
 
-    public Collection(SharedRealm sharedRealm, TableQuery query, SortDescriptor sortDescriptor) {
+    public OsResults(SharedRealm sharedRealm, TableQuery query, @Nullable SortDescriptor sortDescriptor) {
         this(sharedRealm, query, sortDescriptor, null);
     }
 
-    public Collection(SharedRealm sharedRealm, TableQuery query) {
+    public OsResults(SharedRealm sharedRealm, TableQuery query) {
         this(sharedRealm, query, null, null);
     }
 
-    public Collection(SharedRealm sharedRealm, LinkView linkView, SortDescriptor sortDescriptor) {
-        this.nativePtr = nativeCreateResultsFromLinkView(sharedRealm.getNativePtr(), linkView.getNativePtr(),
-                sortDescriptor);
+    public OsResults(SharedRealm sharedRealm, OsList osList, @Nullable SortDescriptor sortDescriptor) {
+        this.nativePtr = nativeCreateResultsFromList(sharedRealm.getNativePtr(), osList.getNativePtr(), sortDescriptor);
 
         this.sharedRealm = sharedRealm;
         this.context = sharedRealm.context;
-        this.table = linkView.getTargetTable();
+        this.table = osList.getTargetTable();
         this.context.addReference(this);
-        // Collection created from LinkView is loaded by default. So that the listener will be triggered first time
-        // with empty change set.
+        // OsResults created from OsList is loaded by default. So that the listener won't be triggered with empty
+        // change set.
         this.loaded = true;
     }
 
-    private Collection(SharedRealm sharedRealm, Table table, long nativePtr) {
+    private OsResults(SharedRealm sharedRealm, Table table, long nativePtr) {
         this(sharedRealm, table, nativePtr, false);
     }
 
-    private Collection(SharedRealm sharedRealm, Table table, long nativePtr, boolean loaded) {
+    OsResults(SharedRealm sharedRealm, Table table, long nativePtr, boolean loaded) {
         this.sharedRealm = sharedRealm;
         this.context = sharedRealm.context;
         this.table = table;
@@ -387,13 +333,13 @@ private Collection(SharedRealm sharedRealm, Table table, long nativePtr, boolean
         this.loaded = loaded;
     }
 
-    public Collection createSnapshot() {
+    public OsResults createSnapshot() {
         if (isSnapshot) {
             return this;
         }
-        Collection collection = new Collection(sharedRealm, table, nativeCreateSnapshot(nativePtr));
-        collection.isSnapshot = true;
-        return collection;
+        OsResults osResults = new OsResults(sharedRealm, table, nativeCreateSnapshot(nativePtr));
+        osResults.isSnapshot = true;
+        return osResults;
     }
 
     @Override
@@ -451,12 +397,12 @@ public void clear() {
         nativeClear(nativePtr);
     }
 
-    public Collection sort(SortDescriptor sortDescriptor) {
-        return new Collection(sharedRealm, table, nativeSort(nativePtr, sortDescriptor));
+    public OsResults sort(SortDescriptor sortDescriptor) {
+        return new OsResults(sharedRealm, table, nativeSort(nativePtr, sortDescriptor));
     }
 
-    public Collection distinct(SortDescriptor distinctDescriptor) {
-        return new Collection(sharedRealm, table, nativeDistinct(nativePtr, distinctDescriptor));
+    public OsResults distinct(SortDescriptor distinctDescriptor) {
+        return new OsResults(sharedRealm, table, nativeDistinct(nativePtr, distinctDescriptor));
     }
 
     public boolean contains(UncheckedRow row) {
@@ -468,11 +414,6 @@ public int indexOf(UncheckedRow row) {
         return (index > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) index;
     }
 
-    public int indexOf(long sourceRowIndex) {
-        long index = nativeIndexOfBySourceRowIndex(nativePtr, sourceRowIndex);
-        return (index > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) index;
-    }
-
     public void delete(long index) {
         nativeDelete(nativePtr, index);
     }
@@ -518,8 +459,8 @@ public boolean isValid() {
     }
 
     // Called by JNI
-    @SuppressWarnings("unused")
-    private void notifyChangeListeners(long nativeChangeSetPtr) {
+    @Override
+    public void notifyChangeListeners(long nativeChangeSetPtr) {
         if (nativeChangeSetPtr == 0 && isLoaded()) {
             return;
         }
@@ -529,7 +470,7 @@ private void notifyChangeListeners(long nativeChangeSetPtr) {
         // So it is possible it deliver a non-empty change set for the first async query returns. In this case, we
         // return an empty change set to user since it is considered as the first time async query returns.
         observerPairs.foreach(new Callback(nativeChangeSetPtr == 0 || !wasLoaded ?
-                null : new CollectionChangeSet(nativeChangeSetPtr)));
+                null : new OsCollectionChangeSet(nativeChangeSetPtr)));
     }
 
     public Mode getMode() {
@@ -546,7 +487,6 @@ public Mode getMode() {
     //    change set since it is considered as query first returned.
     // 3. If the listener triggered with empty change set after load() called for async queries, it is treated as the
     //    same case as 1).
-    // TODO: Results built from a LinkView has not been considered yet. Maybe it should bet set as loaded when create.
     public boolean isLoaded() {
         return loaded;
     }
@@ -561,10 +501,10 @@ public void load() {
     private static native long nativeGetFinalizerPtr();
 
     private static native long nativeCreateResults(long sharedRealmNativePtr, long queryNativePtr,
-            SortDescriptor sortDesc, SortDescriptor distinctDesc);
+            @Nullable SortDescriptor sortDesc, @Nullable SortDescriptor distinctDesc);
 
-    private static native long nativeCreateResultsFromLinkView(long sharedRealmNativePtr, long linkViewPtr,
-            SortDescriptor sortDesc);
+    private static native long nativeCreateResultsFromList(long sharedRealmPtr, long listPtr,
+                                                           @Nullable SortDescriptor sortDesc);
 
     private static native long nativeCreateSnapshot(long nativePtr);
 
@@ -592,7 +532,7 @@ private static native long nativeCreateResultsFromLinkView(long sharedRealmNativ
 
     private static native void nativeDelete(long nativePtr, long index);
 
-    // Non-static, we need this Collection object in JNI.
+    // Non-static, we need this OsResults object in JNI.
     private native void nativeStartListening(long nativePtr);
 
     private native void nativeStopListening(long nativePtr);
@@ -601,8 +541,6 @@ private static native long nativeCreateResultsFromLinkView(long sharedRealmNativ
 
     private static native long nativeIndexOf(long nativePtr, long rowNativePtr);
 
-    private static native long nativeIndexOfBySourceRowIndex(long nativePtr, long sourceRowIndex);
-
     private static native boolean nativeIsValid(long nativePtr);
 
     private static native byte nativeGetMode(long nativePtr);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsSchemaInfo.java b/realm/realm-library/src/main/java/io/realm/internal/OsSchemaInfo.java
new file mode 100644
index 0000000000..4585c514b5
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsSchemaInfo.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+/**
+ * Java wrapper for the Object Store Schema object.
+ * <p>
+ * When it is created from java binding, it is used for initializing/validating the schemas through Object Store. It
+ * won't contain the column indices information.
+ * <p>
+ * When this is get from the Object Store {@code SharedRealm} instance, this represents the real schema of the Realm
+ * file. It will contain all the schema information as well as the information about the column indices.
+ */
+public class OsSchemaInfo implements NativeObject {
+    private long nativePtr;
+    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
+    // Hold the ref to the SharedRealm to ensure the SharedRealm won't be freed before this gets GCed.
+    @SuppressWarnings("unused")
+    private final SharedRealm sharedRealm;
+
+    /**
+     * Constructs a {@code OsSchemaInfo} object from a given {@code OsObjectSchemaInfo} list.
+     *
+     * @param objectSchemaInfoList all the object schemas should be contained in this {@code OsObjectSchemaInfo}.
+     */
+    public OsSchemaInfo(java.util.Collection<OsObjectSchemaInfo> objectSchemaInfoList) {
+        this.nativePtr = nativeCreateFromList(convertObjectSchemaInfoListToNativePointerArray(objectSchemaInfoList));
+        NativeContext.dummyContext.addReference(this);
+        this.sharedRealm = null;
+    }
+
+    /**
+     * Constructs a {@code OsSchemaInfo} and bind its life cycle with the given {@code ShareRealm}. The native pointer
+     * held by this instance points to the reference of ObjectStore's {@code Realm::m_schema}. It will be valid
+     * as long as the {@code SharedRealm} instance is not GCed.
+     * <p>
+     * This should only be called by {@link SharedRealm}.
+     *
+     * @param nativePtr the pointer to the Object Store's {@code Realm::m_schema}.
+     * @param sharedRealm the {@code SharedRealm} instance which is owning the schema object.
+     */
+    OsSchemaInfo(long nativePtr, SharedRealm sharedRealm) {
+        this.nativePtr = nativePtr;
+        this.sharedRealm = sharedRealm;
+    }
+
+    private static long[] convertObjectSchemaInfoListToNativePointerArray(
+            java.util.Collection<OsObjectSchemaInfo> objectSchemaInfoList) {
+        long[] schemaNativePointers = new long[objectSchemaInfoList.size()];
+        int i = 0;
+        for (OsObjectSchemaInfo info : objectSchemaInfoList) {
+            schemaNativePointers[i] = info.getNativePtr();
+            i++;
+        }
+
+        return schemaNativePointers;
+    }
+
+    public OsObjectSchemaInfo getObjectSchemaInfo(String className) {
+        return new OsObjectSchemaInfo(nativeGetObjectSchemaInfo(nativePtr, className));
+    }
+
+    @Override
+    public long getNativePtr() {
+        return nativePtr;
+    }
+
+    @Override
+    public long getNativeFinalizerPtr() {
+        return nativeFinalizerPtr;
+    }
+
+    private static native long nativeCreateFromList(long[] objectSchemaPtrs);
+
+    private static native long nativeGetFinalizerPtr();
+
+    // Throw ISE if the object schema doesn't exist.
+    private static native long nativeGetObjectSchemaInfo(long nativePtr, String className);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OutOfMemoryError.java b/realm/realm-library/src/main/java/io/realm/internal/OutOfMemoryError.java
deleted file mode 100644
index 88b664f797..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/OutOfMemoryError.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-
-/**
- * Can be thrown when Realm runs out of memory.
- * A JVM that catches this will be able to cleanup, e.g. release other resources to avoid also running out of memory.
- */
-@SuppressWarnings("serial")
-@Keep
-public class OutOfMemoryError extends Error {
-
-    public OutOfMemoryError() {
-        super();
-    }
-
-    public OutOfMemoryError(String message) {
-        super(message);
-    }
-
-    public OutOfMemoryError(String message, Throwable cause) {
-        super(message, cause);
-    }
-
-    public OutOfMemoryError(Throwable cause) {
-        super(cause);
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java b/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
index 63a86d2bb0..ccdad47857 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
@@ -3,6 +3,8 @@
 import java.lang.ref.WeakReference;
 import java.util.Date;
 
+import javax.annotation.Nullable;
+
 import io.realm.RealmChangeListener;
 import io.realm.RealmFieldType;
 
@@ -30,15 +32,15 @@
             "The query has been executed. This 'PendingRow' is not valid anymore.";
 
     private SharedRealm sharedRealm;
-    private Collection pendingCollection;
+    private OsResults pendingOsResults;
     private RealmChangeListener<PendingRow> listener;
     private WeakReference<FrontEnd> frontEndRef;
     private boolean returnCheckedRow;
 
-    public PendingRow(SharedRealm sharedRealm, TableQuery query, SortDescriptor sortDescriptor,
+    public PendingRow(SharedRealm sharedRealm, TableQuery query, @Nullable SortDescriptor sortDescriptor,
             final boolean returnCheckedRow) {
         this.sharedRealm = sharedRealm;
-        pendingCollection = new Collection(sharedRealm, query, sortDescriptor, null);
+        pendingOsResults = new OsResults(sharedRealm, query, sortDescriptor, null);
 
         listener = new RealmChangeListener<PendingRow>() {
             @Override
@@ -46,7 +48,7 @@ public void onChange(PendingRow pendingRow) {
                 notifyFrontEnd();
             }
         };
-        pendingCollection.addListener(this, listener);
+        pendingOsResults.addListener(this, listener);
         this.returnCheckedRow = returnCheckedRow;
         sharedRealm.addPendingRow(this);
     }
@@ -132,7 +134,12 @@ public boolean isNullLink(long columnIndex) {
     }
 
     @Override
-    public LinkView getLinkList(long columnIndex) {
+    public OsList getModelList(long columnIndex) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public OsList getValueList(long columnIndex, RealmFieldType fieldType) {
         throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
     }
 
@@ -207,8 +214,8 @@ public boolean hasColumn(String fieldName) {
     }
 
     private void clearPendingCollection() {
-        pendingCollection.removeListener(this, listener);
-        pendingCollection = null;
+        pendingOsResults.removeListener(this, listener);
+        pendingOsResults = null;
         listener = null;
         sharedRealm.removePendingRow(this);
     }
@@ -224,9 +231,9 @@ private void notifyFrontEnd() {
             return;
         }
 
-        if (pendingCollection.isValid()) {
+        if (pendingOsResults.isValid()) {
             // PendingRow will always get the first Row of the query since we only support findFirst.
-            UncheckedRow uncheckedRow = pendingCollection.firstUncheckedRow();
+            UncheckedRow uncheckedRow = pendingOsResults.firstUncheckedRow();
             // Clear the pending collection immediately in case beginTransaction is called in the listener which will
             // execute the query again.
             clearPendingCollection();
@@ -247,7 +254,7 @@ private void notifyFrontEnd() {
 
     // Execute the query immediately and call frontend's onQueryFinished().
     public void executeQuery() {
-        if (pendingCollection == null) {
+        if (pendingOsResults == null) {
             throw new IllegalStateException(QUERY_EXECUTED_MESSAGE);
         }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Property.java b/realm/realm-library/src/main/java/io/realm/internal/Property.java
new file mode 100644
index 0000000000..0bcff85f24
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/Property.java
@@ -0,0 +1,224 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+
+import java.util.Locale;
+
+import io.realm.RealmFieldType;
+
+import static io.realm.RealmFieldType.BINARY_LIST;
+import static io.realm.RealmFieldType.BOOLEAN_LIST;
+import static io.realm.RealmFieldType.DATE_LIST;
+import static io.realm.RealmFieldType.DOUBLE_LIST;
+import static io.realm.RealmFieldType.FLOAT_LIST;
+import static io.realm.RealmFieldType.INTEGER_LIST;
+import static io.realm.RealmFieldType.STRING_LIST;
+
+
+/**
+ * Class for handling properties/fields.
+ */
+
+public class Property implements NativeObject {
+    public static final boolean PRIMARY_KEY = true;
+    public static final boolean REQUIRED = true;
+    public static final boolean INDEXED = true;
+
+    @SuppressWarnings("WeakerAccess")
+    public static final int TYPE_INT = 0;
+    @SuppressWarnings("WeakerAccess")
+    public static final int TYPE_BOOL = 1;
+    @SuppressWarnings("WeakerAccess")
+    public static final int TYPE_STRING = 2;
+    @SuppressWarnings("WeakerAccess")
+    public static final int TYPE_DATA = 3;
+    @SuppressWarnings("WeakerAccess")
+    public static final int TYPE_DATE = 4;
+    @SuppressWarnings("WeakerAccess")
+    public static final int TYPE_FLOAT = 5;
+    @SuppressWarnings("WeakerAccess")
+    public static final int TYPE_DOUBLE = 6;
+    @SuppressWarnings("WeakerAccess")
+    public static final int TYPE_OBJECT = 7;
+    @SuppressWarnings("WeakerAccess")
+    public static final int TYPE_LINKING_OBJECTS = 8;
+    @SuppressWarnings("WeakerAccess")
+    public static final int TYPE_REQUIRED = 0;
+    @SuppressWarnings("WeakerAccess")
+    public static final int TYPE_NULLABLE = 64;
+    @SuppressWarnings("WeakerAccess")
+    public static final int TYPE_ARRAY = 128;
+
+    private long nativePtr;
+    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
+
+    Property(long nativePtr) {
+        this.nativePtr = nativePtr;
+        NativeContext.dummyContext.addReference(this);
+    }
+
+    static int convertFromRealmFieldType(RealmFieldType fieldType, boolean isRequired) {
+        int type;
+        switch (fieldType) {
+            case OBJECT:
+                type = TYPE_OBJECT | TYPE_NULLABLE;
+                return type;
+            case LIST:
+                type = TYPE_OBJECT | TYPE_ARRAY;
+                return type;
+            case LINKING_OBJECTS:
+                type = TYPE_LINKING_OBJECTS | TYPE_ARRAY;
+                return type;
+            case INTEGER:
+                type = TYPE_INT;
+                break;
+            case BOOLEAN:
+                type = TYPE_BOOL;
+                break;
+            case STRING:
+                type = TYPE_STRING;
+                break;
+            case BINARY:
+                type = TYPE_DATA;
+                break;
+            case DATE:
+                type = TYPE_DATE;
+                break;
+            case FLOAT:
+                type = TYPE_FLOAT;
+                break;
+            case DOUBLE:
+                type = TYPE_DOUBLE;
+                break;
+            case INTEGER_LIST:
+                //noinspection PointlessBitwiseExpression
+                type = TYPE_INT | TYPE_ARRAY;
+                break;
+            case BOOLEAN_LIST:
+                type = TYPE_BOOL | TYPE_ARRAY;
+                break;
+            case STRING_LIST:
+                type = TYPE_STRING | TYPE_ARRAY;
+                break;
+            case BINARY_LIST:
+                type = TYPE_DATA | TYPE_ARRAY;
+                break;
+            case DATE_LIST:
+                type = TYPE_DATE | TYPE_ARRAY;
+                break;
+            case FLOAT_LIST:
+                type = TYPE_FLOAT | TYPE_ARRAY;
+                break;
+            case DOUBLE_LIST:
+                type = TYPE_DOUBLE | TYPE_ARRAY;
+                break;
+            default:
+                throw new IllegalArgumentException(
+                        String.format(Locale.US, "Unsupported filed type: '%s'.", fieldType.name()));
+
+        }
+        int requiredFlag = isRequired ? TYPE_REQUIRED : TYPE_NULLABLE;
+        return type | requiredFlag;
+    }
+
+    private static RealmFieldType convertToRealmFieldType(int propertyType) {
+        // Clear the nullable flag
+        switch (propertyType & ~TYPE_NULLABLE) {
+            case  TYPE_OBJECT:
+                return RealmFieldType.OBJECT;
+            case TYPE_OBJECT | TYPE_ARRAY:
+                return RealmFieldType.LIST;
+            case TYPE_LINKING_OBJECTS | TYPE_ARRAY:
+                return RealmFieldType.LINKING_OBJECTS;
+            case TYPE_INT:
+                return RealmFieldType.INTEGER;
+            case TYPE_BOOL:
+                return RealmFieldType.BOOLEAN;
+            case TYPE_STRING:
+                return RealmFieldType.STRING;
+            case TYPE_DATA:
+                return RealmFieldType.BINARY;
+            case TYPE_DATE:
+                return RealmFieldType.DATE;
+            case TYPE_FLOAT:
+                return RealmFieldType.FLOAT;
+            case TYPE_DOUBLE:
+                return RealmFieldType.DOUBLE;
+            //noinspection PointlessBitwiseExpression
+            case TYPE_INT | TYPE_ARRAY:
+                return INTEGER_LIST;
+            case TYPE_BOOL | TYPE_ARRAY:
+                return BOOLEAN_LIST;
+            case TYPE_STRING | TYPE_ARRAY:
+                return STRING_LIST;
+            case TYPE_DATA | TYPE_ARRAY:
+                return BINARY_LIST;
+            case TYPE_DATE | TYPE_ARRAY:
+                return DATE_LIST;
+            case TYPE_FLOAT | TYPE_ARRAY:
+                return FLOAT_LIST;
+            case TYPE_DOUBLE | TYPE_ARRAY:
+                return DOUBLE_LIST;
+            default:
+                throw new IllegalArgumentException(
+                        String.format(Locale.US, "Unsupported property type: '%d'", propertyType));
+
+        }
+    }
+
+    public RealmFieldType getType() {
+        return convertToRealmFieldType(nativeGetType(nativePtr));
+    }
+
+    public String getLinkedObjectName() {
+        return nativeGetLinkedObjectName(nativePtr);
+    }
+
+    public long getColumnIndex() {
+        return nativeGetColumnIndex(nativePtr);
+    }
+
+    @Override
+    public long getNativePtr() {
+        return nativePtr;
+    }
+
+    @Override
+    public long getNativeFinalizerPtr() {
+        return nativeFinalizerPtr;
+    }
+
+    private static native long nativeGetFinalizerPtr();
+
+    // nativeCreateXxxProperty will be called by OsObjectSchemaInfo directly to avoid creating temporary Property
+    // objects.
+    static native long nativeCreatePersistedProperty(
+            String name, int type, boolean isPrimary, boolean isIndexed);
+
+    static native long nativeCreatePersistedLinkProperty(String name, int type, String linkedToName);
+
+    static native long nativeCreateComputedLinkProperty(
+            String name, String sourceClassName, String sourceFieldName);
+
+    private static native int nativeGetType(long nativePtr);
+
+    private static native long nativeGetColumnIndex(long nativePtr);
+
+    // Return null if the property is not OBJECT, LIST or LINKING_OBJECT type.
+    private static native String nativeGetLinkedObjectName(long nativePtr);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ProxyUtils.java b/realm/realm-library/src/main/java/io/realm/internal/ProxyUtils.java
new file mode 100644
index 0000000000..7b9da29d3d
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/ProxyUtils.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal;
+
+import java.util.Map;
+
+import io.realm.RealmFieldType;
+import io.realm.exceptions.RealmMigrationNeededException;
+
+public class ProxyUtils {
+
+    public static void verifyField(SharedRealm sharedRealm, Map<String, RealmFieldType> columnTypes, String fieldName, RealmFieldType fieldType, String fieldSimpleType) {
+        if (!columnTypes.containsKey(fieldName)) {
+            throw new RealmMigrationNeededException(
+                    sharedRealm.getPath(),
+                    String.format("Missing field '%s' in existing Realm file. Either remove field or migrate using io.realm.internal.Table.addColumn().", fieldName));
+        }
+        if (columnTypes.get(fieldName) != fieldType) {
+            throw new RealmMigrationNeededException(
+                    sharedRealm.getPath(),
+                    String.format("Invalid type '%s' for field '%s' in existing Realm file.", fieldSimpleType, fieldName));
+        }
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java b/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
index 279c559606..06864b403a 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
@@ -20,6 +20,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import javax.annotation.Nullable;
+
 import io.realm.RealmChangeListener;
 
 
@@ -53,6 +55,7 @@ public RealmObserverPair(T observer, RealmChangeListener<T> listener) {
         }
 
         private void onChange(T observer) {
+            //noinspection ConstantConditions
             if (observer != null) {
                 listener.onChange(observer);
             }
@@ -71,7 +74,7 @@ public void onCalled(RealmObserverPair pair, Object observer) {
                 }
             };
 
-    protected RealmNotifier(SharedRealm sharedRealm) {
+    protected RealmNotifier(@Nullable SharedRealm sharedRealm) {
         this.sharedRealm = sharedRealm;
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
index 50c2c72983..188a6f96b2 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmProxyMediator.java
@@ -29,8 +29,6 @@
 import io.realm.Realm;
 import io.realm.RealmModel;
 import io.realm.RealmObject;
-import io.realm.RealmObjectSchema;
-import io.realm.RealmSchema;
 import io.realm.exceptions.RealmException;
 
 
@@ -46,26 +44,21 @@
 public abstract class RealmProxyMediator {
 
     /**
-     * Creates a object schema for the given RealmObject class.
+     * Returns a map of model classes to their schema information which are defined in this mediator. Classes which have
+     * same class name but in different packages should have different names in the {@code OsObjectSchemaInfo}.
      *
-     * @param clazz the {@link RealmObject} model class to create object schema for.
-     * @param realmSchema the {@link RealmSchema} to associate the object schema with.
-     * @return the object schema.
+     * @return the map with classes and their schema information.
      */
-    public abstract RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema realmSchema);
+    public abstract Map<Class<? extends RealmModel>, OsObjectSchemaInfo> getExpectedObjectSchemaInfoMap();
 
     /**
-     * Validates the backing table in Realm for the given RealmObject class.
+     * Creates {@link ColumnInfo} for the given RealmObject class.
      *
-     * @param clazz the {@link RealmObject} model class to validate.
-     * @param sharedRealm the wrapper object of underlying native database to validate against.
-     * @param allowExtraColumns if {@code} false, {@link io.realm.exceptions.RealmMigrationNeededException}
-     * is thrown when the column count it more than expected.
+     * @param clazz which {@link RealmObject} model class to create the column info of.
+     * @param osSchemaInfo the {@link OsSchemaInfo} for the corresponding Realm instance.
      * @return the field indices map.
      */
-    public abstract ColumnInfo validateTable(Class<? extends RealmModel> clazz,
-            SharedRealm sharedRealm,
-            boolean allowExtraColumns);
+    public abstract ColumnInfo createColumnInfo(Class<? extends RealmModel> clazz, OsSchemaInfo osSchemaInfo);
 
     /**
      * Returns a map of non-obfuscated object field names to their internal Realm name.
@@ -76,14 +69,24 @@ public abstract ColumnInfo validateTable(Class<? extends RealmModel> clazz,
     public abstract List<String> getFieldNames(Class<? extends RealmModel> clazz);
 
     /**
-     * Returns the name that Realm should use for all its internal tables. This is the un-obfuscated name of the
+     * Returns the name that Realm should use for all its internal tables. This is the un-obfuscated simple name of the
      * class.
      *
-     * @param clazz the {@link RealmObject} class reference.
+     * @param clazz the {@link RealmModel} or the Realm object proxy class reference.
+     * @return the simple name of an RealmObject class (before it has been obfuscated).
+     */
+    public final String getSimpleClassName(Class<? extends RealmModel> clazz) {
+        return getSimpleClassNameImpl(Util.getOriginalModelClass(clazz));
+    }
+
+    /**
+     * Returns the name that Realm should use for all its internal tables. This is the un-obfuscated simple name of the
+     * class.
+     *
+     * @param clazz the {@link RealmModel} class reference.
      * @return the simple name of an RealmObject class (before it has been obfuscated).
-     * @throws java.lang.NullPointerException if null is given as argument.
      */
-    public abstract String getTableName(Class<? extends RealmModel> clazz);
+    protected abstract String getSimpleClassNameImpl(Class<? extends RealmModel> clazz);
 
     /**
      * Creates a new instance of an {@link RealmObjectProxy} for the given RealmObject class.
@@ -226,12 +229,19 @@ public int hashCode() {
     }
 
     protected static void checkClass(Class<? extends RealmModel> clazz) {
+        //noinspection ConstantConditions
         if (clazz == null) {
             throw new NullPointerException("A class extending RealmObject must be provided");
         }
     }
 
     protected static RealmException getMissingProxyClassException(Class<? extends RealmModel> clazz) {
-        return new RealmException(clazz + " is not part of the schema for this Realm.");
+        return new RealmException(
+                String.format("'%s' is not part of the schema for this Realm.", clazz.toString()));
+    }
+
+    protected static RealmException getMissingProxyClassException(String className) {
+        return new RealmException(
+                String.format("'%s' is not part of the schema for this Realm.", className));
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Row.java b/realm/realm-library/src/main/java/io/realm/internal/Row.java
index 1e448d2058..681d818999 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Row.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Row.java
@@ -18,6 +18,8 @@
 
 import java.util.Date;
 
+import javax.annotation.Nullable;
+
 import io.realm.RealmFieldType;
 
 
@@ -79,7 +81,9 @@
 
     boolean isNullLink(long columnIndex);
 
-    LinkView getLinkList(long columnIndex);
+    OsList getModelList(long columnIndex);
+
+    OsList getValueList(long columnIndex, RealmFieldType fieldType);
 
     void setLong(long columnIndex, long value);
 
@@ -91,9 +95,9 @@
 
     void setDate(long columnIndex, Date date);
 
-    void setString(long columnIndex, String value);
+    void setString(long columnIndex, @Nullable String value);
 
-    void setBinaryByteArray(long columnIndex, byte[] data);
+    void setBinaryByteArray(long columnIndex, @Nullable byte[] data);
 
     void setLink(long columnIndex, long value);
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index 21b041baec..bdb0cb3505 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -23,100 +23,16 @@
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
 
+import javax.annotation.Nullable;
+
 import io.realm.RealmConfiguration;
+import io.realm.exceptions.RealmException;
 import io.realm.internal.android.AndroidCapabilities;
 import io.realm.internal.android.AndroidRealmNotifier;
 
-
+@Keep
 public final class SharedRealm implements Closeable, NativeObject {
 
-    // Const value for RealmFileException conversion
-    public static final byte FILE_EXCEPTION_KIND_ACCESS_ERROR = 0;
-    public static final byte FILE_EXCEPTION_KIND_BAD_HISTORY = 1;
-    public static final byte FILE_EXCEPTION_KIND_PERMISSION_DENIED = 2;
-    public static final byte FILE_EXCEPTION_KIND_EXISTS = 3;
-    public static final byte FILE_EXCEPTION_KIND_NOT_FOUND = 4;
-    public static final byte FILE_EXCEPTION_KIND_INCOMPATIBLE_LOCK_FILE = 5;
-    public static final byte FILE_EXCEPTION_KIND_FORMAT_UPGRADE_REQUIRED = 6;
-    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
-
-    public static void initialize(File tempDirectory) {
-        if (SharedRealm.temporaryDirectory != null) {
-            // already initialized
-            return;
-        }
-        if (tempDirectory == null) {
-            throw new IllegalArgumentException("'tempDirectory' must not be null.");
-        }
-
-        String temporaryDirectoryPath = tempDirectory.getAbsolutePath();
-        if (!tempDirectory.isDirectory() && !tempDirectory.mkdirs() && !tempDirectory.isDirectory()) {
-            throw new IOException("failed to create temporary directory: " + temporaryDirectoryPath);
-        }
-
-        if (!temporaryDirectoryPath.endsWith("/")) {
-            temporaryDirectoryPath += "/";
-        }
-        nativeInit(temporaryDirectoryPath);
-        SharedRealm.temporaryDirectory = tempDirectory;
-    }
-
-    public static File getTemporaryDirectory() {
-        return temporaryDirectory;
-    }
-
-    private volatile static File temporaryDirectory;
-
-    public enum Durability {
-        FULL(0),
-        MEM_ONLY(1);
-
-        final int value;
-
-        Durability(int value) {
-            this.value = value;
-        }
-    }
-
-    // Public for static checking in JNI
-    @SuppressWarnings("WeakerAccess")
-    public static final byte SCHEMA_MODE_VALUE_AUTOMATIC = 0;
-    @SuppressWarnings("WeakerAccess")
-    public static final byte SCHEMA_MODE_VALUE_READONLY = 1;
-    @SuppressWarnings("WeakerAccess")
-    public static final byte SCHEMA_MODE_VALUE_RESET_FILE = 2;
-    @SuppressWarnings("WeakerAccess")
-    public static final byte SCHEMA_MODE_VALUE_ADDITIVE = 3;
-    @SuppressWarnings("WeakerAccess")
-    public static final byte SCHEMA_MODE_VALUE_MANUAL = 4;
-
-    @SuppressWarnings("WeakerAccess")
-    public enum SchemaMode {
-        SCHEMA_MODE_AUTOMATIC(SCHEMA_MODE_VALUE_AUTOMATIC),
-        SCHEMA_MODE_READONLY(SCHEMA_MODE_VALUE_READONLY),
-        SCHEMA_MODE_RESET_FILE(SCHEMA_MODE_VALUE_RESET_FILE),
-        SCHEMA_MODE_ADDITIVE(SCHEMA_MODE_VALUE_ADDITIVE),
-        SCHEMA_MODE_MANUAL(SCHEMA_MODE_VALUE_MANUAL);
-
-        final byte value;
-
-        SchemaMode(byte value) {
-            this.value = value;
-        }
-
-        public byte getNativeValue() {
-            return value;
-        }
-    }
-
-    private final List<WeakReference<PendingRow>> pendingRows = new CopyOnWriteArrayList<>();
-    public final List<WeakReference<Collection>> collections = new CopyOnWriteArrayList<>();
-    public final List<WeakReference<Collection.Iterator>> iterators = new ArrayList<>();
-
-    // JNI will only hold a weak global ref to this.
-    public final RealmNotifier realmNotifier;
-    public final Capabilities capabilities;
-
     public static class VersionID implements Comparable<VersionID> {
         public final long version;
         public final long index;
@@ -128,6 +44,7 @@ public byte getNativeValue() {
 
         @Override
         public int compareTo(@SuppressWarnings("NullableProblems") VersionID another) {
+            //noinspection ConstantConditions
             if (another == null) {
                 throw new IllegalArgumentException("Version cannot be compared to a null value.");
             }
@@ -170,81 +87,164 @@ public int hashCode() {
         }
     }
 
-    public interface SchemaVersionListener {
-        void onSchemaVersionChanged(long currentVersion);
+    /**
+     * The migration callback which will be called when manual migration is needed.
+     */
+    @Keep
+    public interface MigrationCallback {
+
+        /**
+         * Callback function.
+         *
+         * @param sharedRealm the same {@link SharedRealm} instance which has been created from the same
+         *                    {@link OsRealmConfig} instance.
+         * @param oldVersion  the schema version of the existing Realm file.
+         * @param newVersion  the expected schema version after migration.
+         */
+        void onMigrationNeeded(SharedRealm sharedRealm, long oldVersion, long newVersion);
+    }
+
+    /**
+     * Callback function to be executed when the schema is created.
+     */
+    @Keep
+    public interface InitializationCallback {
+        /**
+         * @param sharedRealm a {@link SharedRealm} instance which is in transaction state.
+         */
+        void onInit(SharedRealm sharedRealm);
+    }
+
+    /**
+     * Callback function to be called from JNI by Object Store when the schema is changed.
+     */
+    @Keep
+    public interface SchemaChangedCallback {
+        // Called from JNI
+        @SuppressWarnings("unused")
+        void onSchemaChanged();
+    }
+
+    /**
+     * Callback function to be called from JNI by Object Store when the partial sync results returned.
+     */
+    @Keep
+    public abstract static class PartialSyncCallback {
+        private final String className;
+
+        protected PartialSyncCallback(String className) {
+            this.className = className;
+        }
+
+        public abstract void onSuccess(OsResults results);
+
+        public abstract void onError(RealmException error);
     }
 
-    private final RealmConfiguration configuration;
+    // Const value for RealmFileException conversion
+    public static final byte FILE_EXCEPTION_KIND_ACCESS_ERROR = 0;
+    public static final byte FILE_EXCEPTION_KIND_BAD_HISTORY = 1;
+    public static final byte FILE_EXCEPTION_KIND_PERMISSION_DENIED = 2;
+    public static final byte FILE_EXCEPTION_KIND_EXISTS = 3;
+    public static final byte FILE_EXCEPTION_KIND_NOT_FOUND = 4;
+    public static final byte FILE_EXCEPTION_KIND_INCOMPATIBLE_LOCK_FILE = 5;
+    public static final byte FILE_EXCEPTION_KIND_FORMAT_UPGRADE_REQUIRED = 6;
+    public static final byte FILE_EXCEPTION_INCOMPATIBLE_SYNC_FILE = 7;
 
-    final private long nativePtr;
+    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
+    private final long nativePtr;
+    private final OsRealmConfig osRealmConfig;
     final NativeContext context;
-    private long lastSchemaVersion;
-    private final SchemaVersionListener schemaChangeListener;
+    private final OsSchemaInfo schemaInfo;
+    private static volatile File temporaryDirectory;
+    // JNI will only hold a weak global ref to this.
+    public final RealmNotifier realmNotifier;
+    public final Capabilities capabilities;
 
-    private SharedRealm(long nativeConfigPtr,
-            RealmConfiguration configuration,
-            SchemaVersionListener schemaVersionListener) {
+    private final List<WeakReference<PendingRow>> pendingRows = new CopyOnWriteArrayList<>();
+    // Package protected for testing
+    final List<WeakReference<OsResults.Iterator>> iterators = new ArrayList<>();
+
+    private SharedRealm(OsRealmConfig osRealmConfig) {
         Capabilities capabilities = new AndroidCapabilities();
         RealmNotifier realmNotifier = new AndroidRealmNotifier(this, capabilities);
 
-        this.nativePtr = nativeGetSharedRealm(nativeConfigPtr, realmNotifier);
-        this.configuration = configuration;
+        this.nativePtr = nativeGetSharedRealm(osRealmConfig.getNativePtr(), realmNotifier);
+        this.osRealmConfig = osRealmConfig;
+        this.schemaInfo = new OsSchemaInfo(nativeGetSchemaInfo(nativePtr), this);
+        this.context = osRealmConfig.getContext();
+        this.context.addReference(this);
 
         this.capabilities = capabilities;
         this.realmNotifier = realmNotifier;
-        this.schemaChangeListener = schemaVersionListener;
-        context = new NativeContext();
-        context.addReference(this);
-        this.lastSchemaVersion = schemaVersionListener == null ? -1L : getSchemaVersion();
         nativeSetAutoRefresh(nativePtr, capabilities.canDeliverNotification());
     }
 
-    // This will create a SharedRealm where autoChangeNotifications is false,
-    // If autoChangeNotifications is true, an additional SharedGroup might be created in the OS's external commit helper.
-    // That is not needed for some cases: eg.: An extra opened SharedGroup will cause a compact failure.
+    /**
+     * Creates a {@code SharedRealm} instance from a given Object Store's {@code SharedRealm} pointer. This is used to
+     * create {@code SharedRealm} from the callback functions. When this is called, there is another
+     * {@code SharedRealm} instance with the same {@link OsRealmConfig} which has been created before. Although they
+     * are different {@code shared_ptr}, they point to the same {@code SharedGroup} instance. The {@code context} has
+     * to be the same one to ensure core's destructor thread safety.
+     */
+    private SharedRealm(long nativeSharedRealmPtr, OsRealmConfig osRealmConfig) {
+        this.nativePtr = nativeSharedRealmPtr;
+        this.osRealmConfig = osRealmConfig;
+        this.schemaInfo = new OsSchemaInfo(nativeGetSchemaInfo(nativePtr), this);
+        this.context = osRealmConfig.getContext();
+        this.context.addReference(this);
+
+        this.capabilities = new AndroidCapabilities();
+        // This instance should never need notifications.
+        this.realmNotifier = null;
+        nativeSetAutoRefresh(nativePtr, false);
+    }
+
+
+    /**
+     * Creates a {@code SharedRealm} instance in dynamic schema mode.
+     */
     public static SharedRealm getInstance(RealmConfiguration config) {
-        return getInstance(config, null, false);
-    }
-
-
-    public static SharedRealm getInstance(RealmConfiguration config, SchemaVersionListener schemaVersionListener,
-            boolean autoChangeNotifications) {
-        String[] syncUserConf = ObjectServerFacade.getSyncFacadeIfPossible().getUserAndServerUrl(config);
-        String syncUserIdentifier = syncUserConf[0];
-        String syncRealmUrl = syncUserConf[1];
-        String syncRealmAuthUrl = syncUserConf[2];
-        String syncRefreshToken = syncUserConf[3];
-        boolean enable_caching = false; // Handled in Java currently
-        boolean disableFormatUpgrade = false; // TODO Double negatives :/
-
-        long nativeConfigPtr = nativeCreateConfig(
-                config.getPath(),
-                config.getEncryptionKey(),
-                syncRealmUrl != null ? SchemaMode.SCHEMA_MODE_ADDITIVE.getNativeValue() : SchemaMode.SCHEMA_MODE_MANUAL.getNativeValue(),
-                config.getDurability() == Durability.MEM_ONLY,
-                enable_caching,
-                config.getSchemaVersion(),
-                disableFormatUpgrade,
-                autoChangeNotifications,
-                syncRealmUrl,
-                syncRealmAuthUrl,
-                syncUserIdentifier,
-                syncRefreshToken);
-
-        try {
-            ObjectServerFacade.getSyncFacadeIfPossible().wrapObjectStoreSessionIfRequired(config);
-
-            return new SharedRealm(nativeConfigPtr, config, schemaVersionListener);
-        } finally {
-            nativeCloseConfig(nativeConfigPtr);
+        OsRealmConfig.Builder builder = new OsRealmConfig.Builder(config);
+        return getInstance(builder);
+    }
+
+    /**
+     * Creates a {@code ShareRealm} instance from the given {@link OsRealmConfig.Builder}.
+     */
+    public static SharedRealm getInstance(OsRealmConfig.Builder configBuilder) {
+        OsRealmConfig osRealmConfig = configBuilder.build();
+        ObjectServerFacade.getSyncFacadeIfPossible().wrapObjectStoreSessionIfRequired(osRealmConfig);
+
+        return new SharedRealm(osRealmConfig);
+    }
+
+    public static void initialize(File tempDirectory) {
+        if (SharedRealm.temporaryDirectory != null) {
+            // already initialized
+            return;
+        }
+
+        String temporaryDirectoryPath = tempDirectory.getAbsolutePath();
+        if (!tempDirectory.isDirectory() && !tempDirectory.mkdirs() && !tempDirectory.isDirectory()) {
+            throw new IOException("failed to create temporary directory: " + temporaryDirectoryPath);
+        }
+
+        if (!temporaryDirectoryPath.endsWith("/")) {
+            temporaryDirectoryPath += "/";
         }
+        nativeInit(temporaryDirectoryPath);
+        SharedRealm.temporaryDirectory = tempDirectory;
+    }
+
+    public static File getTemporaryDirectory() {
+        return temporaryDirectory;
     }
 
     public void beginTransaction() {
         detachIterators();
         executePendingRowQueries();
         nativeBeginTransaction(nativePtr);
-        invokeSchemaChangeListenerIfSchemaChanged();
     }
 
     public void commitTransaction() {
@@ -259,35 +259,54 @@ public boolean isInTransaction() {
         return nativeIsInTransaction(nativePtr);
     }
 
-    public void setSchemaVersion(long schemaVersion) {
-        nativeSetVersion(nativePtr, schemaVersion);
-    }
-
-    public long getSchemaVersion() {
-        return nativeGetVersion(nativePtr);
+    public boolean hasTable(String name) {
+        return nativeHasTable(nativePtr, name);
     }
 
-    // FIXME: This should be removed, migratePrimaryKeyTableIfNeeded is using it which should be in Object Store instead?
-    long getGroupNative() {
-        return nativeReadGroup(nativePtr);
+    /**
+     * Gets an existing {@link Table} with the given name.
+     *
+     * @param name the name of table.
+     * @return a {@link Table} object.
+     * @throws IllegalArgumentException if the table doesn't exist.
+     */
+    public Table getTable(String name) {
+        long tablePtr = nativeGetTable(nativePtr, name);
+        return new Table(this, tablePtr);
     }
 
-    public boolean hasTable(String name) {
-        return nativeHasTable(nativePtr, name);
+    /**
+     * Creates a {@link Table} with then given name. Native assertion will happen if the table with the same name
+     * exists.
+     *
+     * @param name the name of table.
+     * @return a created {@link Table} object.
+     */
+    public Table createTable(String name) {
+        return new Table(this, nativeCreateTable(nativePtr, name));
     }
 
-    public Table getTable(String name) {
-        return new Table(this, nativeGetTable(nativePtr, name));
+    /**
+     * Creates a {@link Table} and adds a primary key field to it. Native assertion will happen if the table with the
+     * same name exists.
+     *
+     * @param tableName           the name of table.
+     * @param primaryKeyFieldName the name of primary key field.
+     * @param isStringType        if this is true, the primary key field will be create as a string field. Otherwise it will
+     *                            be created as an integer field.
+     * @param isNullable          if the primary key field is nullable or not.
+     * @return a newly created {@link Table} object.
+     */
+    public Table createTableWithPrimaryKey(String tableName, String primaryKeyFieldName, boolean isStringType,
+                                           boolean isNullable) {
+        return new Table(this, nativeCreateTableWithPrimaryKeyField(nativePtr, tableName, primaryKeyFieldName,
+                isStringType, isNullable));
     }
 
     public void renameTable(String oldName, String newName) {
         nativeRenameTable(nativePtr, oldName, newName);
     }
 
-    public void removeTable(String name) {
-        nativeRemoveTable(nativePtr, name);
-    }
-
     public String getTableName(int index) {
         return nativeGetTableName(nativePtr, index);
     }
@@ -297,7 +316,7 @@ public long size() {
     }
 
     public String getPath() {
-        return configuration.getPath();
+        return osRealmConfig.getRealmConfiguration().getPath();
     }
 
     public boolean isEmpty() {
@@ -306,7 +325,6 @@ public boolean isEmpty() {
 
     public void refresh() {
         nativeRefresh(nativePtr);
-        invokeSchemaChangeListenerIfSchemaChanged();
     }
 
     public SharedRealm.VersionID getVersionID() {
@@ -314,15 +332,11 @@ public void refresh() {
         return new SharedRealm.VersionID(versionId[0], versionId[1]);
     }
 
-    public long getLastSnapshotVersion() {
-        return nativeGetSnapshotVersion(nativePtr);
-    }
-
     public boolean isClosed() {
         return nativeIsClosed(nativePtr);
     }
 
-    public void writeCopy(File file, byte[] key) {
+    public void writeCopy(File file, @Nullable byte[] key) {
         if (file.isFile() && file.exists()) {
             throw new IllegalArgumentException("The destination file must not exist");
         }
@@ -341,14 +355,6 @@ public boolean compact() {
         return nativeCompact(nativePtr);
     }
 
-    /**
-     * Updates the underlying schema based on the schema description.
-     * Calling this method must be done from inside a write transaction.
-     */
-    public void updateSchema(long schemaNativePointer, long version) {
-        nativeUpdateSchema(nativePtr, schemaNativePointer, version);
-    }
-
     public void setAutoRefresh(boolean enabled) {
         capabilities.checkCanDeliverNotification(null);
         nativeSetAutoRefresh(nativePtr, enabled);
@@ -358,8 +364,12 @@ public boolean isAutoRefresh() {
         return nativeIsAutoRefresh(nativePtr);
     }
 
-    public boolean requiresMigration(long schemaNativePointer) {
-        return nativeRequiresMigration(nativePtr, schemaNativePointer);
+    public void registerPartialSyncQuery(String query, PartialSyncCallback callback) {
+        nativeRegisterPartialSyncQuery(nativePtr, callback.className, query, callback);
+    }
+
+    public RealmConfiguration getConfiguration() {
+        return osRealmConfig.getRealmConfiguration();
     }
 
     @Override
@@ -384,31 +394,35 @@ public long getNativeFinalizerPtr() {
         return nativeFinalizerPtr;
     }
 
-    public void invokeSchemaChangeListenerIfSchemaChanged() {
-        if (schemaChangeListener == null) {
-            return;
-        }
+    /**
+     * @return the {@link OsSchemaInfo} of this {@code SharedRealm}.
+     */
+    public OsSchemaInfo getSchemaInfo() {
+        return schemaInfo;
+    }
 
-        final long before = lastSchemaVersion;
-        final long current = getSchemaVersion();
-        if (current != before) {
-            lastSchemaVersion = current;
-            schemaChangeListener.onSchemaVersionChanged(current);
-        }
+    /**
+     * Registers a {@link SchemaChangedCallback} with JNI {@code BindingContext}.
+     *
+     * @param callback to be registered. It will be held as a weak ref in the JNI. The caller needs to hold a strong ref
+     *                 to the callback to ensure it won't be GCed before calling.
+     */
+    public void registerSchemaChangedCallback(SchemaChangedCallback callback) {
+        nativeRegisterSchemaChangedCallback(nativePtr, callback);
     }
 
     // addIterator(), detachIterators() and invalidateIterators() are used to make RealmResults stable iterators work.
     // The iterator will iterate on a snapshot Results if it is accessed inside a transaction.
     // See https://github.com/realm/realm-java/issues/3883 for more information.
     // Should only be called by Iterator's constructor.
-    void addIterator(Collection.Iterator iterator) {
+    void addIterator(OsResults.Iterator iterator) {
         iterators.add(new WeakReference<>(iterator));
     }
 
     // The detaching should happen before transaction begins.
-    void detachIterators() {
-        for (WeakReference<Collection.Iterator> iteratorRef : iterators) {
-            Collection.Iterator iterator = iteratorRef.get();
+    private void detachIterators() {
+        for (WeakReference<OsResults.Iterator> iteratorRef : iterators) {
+            OsResults.Iterator iterator = iteratorRef.get();
             if (iterator != null) {
                 iterator.detach();
             }
@@ -418,8 +432,8 @@ void detachIterators() {
 
     // Invalidates all iterators when a remote change notification is received.
     void invalidateIterators() {
-        for (WeakReference<Collection.Iterator> iteratorRef : iterators) {
-            Collection.Iterator iterator = iteratorRef.get();
+        for (WeakReference<OsResults.Iterator> iteratorRef : iterators) {
+            OsResults.Iterator iterator = iteratorRef.get();
             if (iterator != null) {
                 iterator.invalidate();
             }
@@ -435,7 +449,7 @@ void invalidateIterators() {
     // calling the Object Store begin_transaction to avoid the problem.
     // Add pending row to the list when it is created. It should be called in the PendingRow constructor.
     void addPendingRow(PendingRow pendingRow) {
-       pendingRows.add(new WeakReference<PendingRow>(pendingRow));
+        pendingRows.add(new WeakReference<PendingRow>(pendingRow));
     }
 
     // Remove pending row from the list. It should be called when pending row's query finished.
@@ -459,18 +473,51 @@ private void executePendingRowQueries() {
         pendingRows.clear();
     }
 
-    private static native void nativeInit(String temporaryDirectoryPath);
+    /**
+     * Called from JNI when the expected schema doesn't match the existing one.
+     *
+     * @param callback   the {@link MigrationCallback} in the {@link RealmConfiguration}.
+     * @param oldVersion the schema version of the existing Realm file.
+     */
+    @SuppressWarnings("unused")
+    private static void runMigrationCallback(long nativeSharedRealmPtr, OsRealmConfig osRealmConfig, MigrationCallback callback,
+                                             long oldVersion) {
+        callback.onMigrationNeeded(new SharedRealm(nativeSharedRealmPtr, osRealmConfig), oldVersion,
+                osRealmConfig.getRealmConfiguration().getSchemaVersion());
+    }
 
-    // Keep last session as an 'object' to avoid any reference to sync code
-    private static native long nativeCreateConfig(String realmPath, byte[] key, byte schemaMode, boolean inMemory,
-            boolean cache, long schemaVersion, boolean disableFormatUpgrade,
-            boolean autoChangeNotification,
-            String syncServerURL,
-            String syncServerAuthURL,
-            String syncUserIdentity,
-            String syncRefreshToken);
+    /**
+     * Called from JNI when the schema is created the first time.
+     *
+     * @param callback to be executed with a given in-transact {@link SharedRealm}.
+     */
+    @SuppressWarnings("unused")
+    private static void runInitializationCallback(long nativeSharedRealmPtr, OsRealmConfig osRealmConfig, InitializationCallback callback) {
+        callback.onInit(new SharedRealm(nativeSharedRealmPtr, osRealmConfig));
+    }
+
+    /**
+     * Called from JNI when the partial sync callback is invoked from the ObjectStore.
+     *
+     * @param error            if the partial sync query failed to register.
+     * @param nativeResultsPtr pointer to the {@code Results} of the partial sync query.
+     * @param callback         the callback registered from the user to notify the success/error of the partial sync query.
+     */
+    @SuppressWarnings("unused")
+    private void runPartialSyncRegistrationCallback(@Nullable String error, long nativeResultsPtr,
+                                                    PartialSyncCallback callback) {
+        if (error != null) {
+            callback.onError(new RealmException(error));
+        } else {
+            @SuppressWarnings("ConstantConditions")
+            Table table = getTable(Table.getTableNameForClass(callback.className));
+            OsResults results = new OsResults(this, table, nativeResultsPtr, true);
+            callback.onSuccess(results);
+        }
+    }
 
-    private static native void nativeCloseConfig(long nativeConfigPtr);
+
+    private static native void nativeInit(String temporaryDirectoryPath);
 
     private static native long nativeGetSharedRealm(long nativeConfigPtr, RealmNotifier notifier);
 
@@ -486,33 +533,33 @@ private static native long nativeCreateConfig(String realmPath, byte[] key, byte
 
     private static native boolean nativeIsInTransaction(long nativeSharedRealmPtr);
 
-    private static native long nativeGetVersion(long nativeSharedRealmPtr);
-
-    private static native long nativeGetSnapshotVersion(long nativeSharedRealmPtr);
-
-    private static native void nativeSetVersion(long nativeSharedRealmPtr, long version);
-
-    private static native long nativeReadGroup(long nativeSharedRealmPtr);
-
     private static native boolean nativeIsEmpty(long nativeSharedRealmPtr);
 
     private static native void nativeRefresh(long nativeSharedRealmPtr);
 
     private static native long[] nativeGetVersionID(long nativeSharedRealmPtr);
 
+    // Throw IAE if the table doesn't exist.
     private static native long nativeGetTable(long nativeSharedRealmPtr, String tableName);
 
+    // Throw IAE if the table exists already.
+    private static native long nativeCreateTable(long nativeSharedRealmPtr, String tableName);
+
+    // Throw IAE if the table exists already.
+    // If isStringType is false, the PK field will be created as an integer PK field.
+    private static native long nativeCreateTableWithPrimaryKeyField(long nativeSharedRealmPtr, String tableName,
+                                                                    String primaryKeyFieldName,
+                                                                    boolean isStringType, boolean isNullable);
+
     private static native String nativeGetTableName(long nativeSharedRealmPtr, int index);
 
     private static native boolean nativeHasTable(long nativeSharedRealmPtr, String tableName);
 
     private static native void nativeRenameTable(long nativeSharedRealmPtr, String oldTableName, String newTableName);
 
-    private static native void nativeRemoveTable(long nativeSharedRealmPtr, String tableName);
-
     private static native long nativeSize(long nativeSharedRealmPtr);
 
-    private static native void nativeWriteCopy(long nativeSharedRealmPtr, String path, byte[] key);
+    private static native void nativeWriteCopy(long nativeSharedRealmPtr, String path, @Nullable byte[] key);
 
     private static native boolean nativeWaitForChange(long nativeSharedRealmPtr);
 
@@ -520,13 +567,17 @@ private static native long nativeCreateConfig(String realmPath, byte[] key, byte
 
     private static native boolean nativeCompact(long nativeSharedRealmPtr);
 
-    private static native void nativeUpdateSchema(long nativePtr, long nativeSchemaPtr, long version);
-
     private static native void nativeSetAutoRefresh(long nativePtr, boolean enabled);
 
     private static native boolean nativeIsAutoRefresh(long nativePtr);
 
-    private static native boolean nativeRequiresMigration(long nativePtr, long nativeSchemaPtr);
-
     private static native long nativeGetFinalizerPtr();
+
+    // Return the pointer to the Realm::m_schema.
+    private static native long nativeGetSchemaInfo(long nativePtr);
+
+    private static native void nativeRegisterSchemaChangedCallback(long nativePtr, SchemaChangedCallback callback);
+
+    private native void nativeRegisterPartialSyncQuery(
+            long nativeSharedRealmPtr, String className, String query, PartialSyncCallback callback);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java
index 3df785ef92..ff80eb74d9 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java
@@ -17,10 +17,16 @@
 package io.realm.internal;
 
 import java.util.Arrays;
-import java.util.List;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Locale;
+import java.util.Set;
+
+import javax.annotation.Nullable;
 
 import io.realm.RealmFieldType;
 import io.realm.Sort;
+import io.realm.internal.fields.FieldDescriptor;
 
 
 /**
@@ -30,113 +36,114 @@
  * NOTE: Since the column indices are determined when constructing the object with the given table's status, the indices
  * could be wrong when schema changes. Always create and consume the instance when needed, DON'T store a SortDescriptor
  * and use it whenever the ShareGroup can be in different versions.
+ * <p>
+ * Sort descriptors do not support Linking Objects, either internally or as terminal types.
  */
-@KeepMember
+@Keep
 public class SortDescriptor {
-
-    private final long[][] columnIndices;
-    private final boolean[] ascendings;
-    private final Table table;
-
-    final static List<RealmFieldType> validFieldTypesForSort = Arrays.asList(
+    //@VisibleForTesting
+    final static Set<RealmFieldType> SORT_VALID_FIELD_TYPES = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
             RealmFieldType.BOOLEAN, RealmFieldType.INTEGER, RealmFieldType.FLOAT, RealmFieldType.DOUBLE,
-            RealmFieldType.STRING, RealmFieldType.DATE);
-    final static List<RealmFieldType> validFieldTypesForDistinct = Arrays.asList(
-            RealmFieldType.BOOLEAN, RealmFieldType.INTEGER, RealmFieldType.STRING, RealmFieldType.DATE);
+            RealmFieldType.STRING, RealmFieldType.DATE)));
 
-    // Internal use only. For JNI testing.
-    SortDescriptor(Table table, long[] columnIndices) {
-        this(table, new long[][] {columnIndices}, null);
-    }
+    //@VisibleForTesting
+    final static Set<RealmFieldType> DISTINCT_VALID_FIELD_TYPES = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(
+            RealmFieldType.BOOLEAN, RealmFieldType.INTEGER, RealmFieldType.STRING, RealmFieldType.DATE)));
 
-    private SortDescriptor(Table table, long[][] columnIndices, Sort[] sortOrders) {
-        if (sortOrders != null) {
-            ascendings = new boolean[sortOrders.length];
-            for (int i = 0; i < sortOrders.length; i++) {
-                ascendings[i] = sortOrders[i].getValue();
-            }
-        } else {
-            ascendings = null;
-        }
-
-        this.columnIndices = columnIndices;
-        this.table = table;
+    public static SortDescriptor getInstanceForSort(FieldDescriptor.SchemaProxy proxy, Table table, String fieldDescription, Sort sortOrder) {
+        return getInstanceForSort(proxy, table, new String[] {fieldDescription}, new Sort[] {sortOrder});
     }
 
-    public static SortDescriptor getInstanceForSort(Table table, String fieldDescription, Sort sortOrder) {
-        return getInstanceForSort(table, new String[] {fieldDescription}, new Sort[] {sortOrder});
-    }
-
-    public static SortDescriptor getInstanceForSort(Table table, String[] fieldDescriptions, Sort[] sortOrders) {
-        if (fieldDescriptions == null || fieldDescriptions.length == 0) {
-            throw new IllegalArgumentException("You must provide at least one field name.");
-        }
+    public static SortDescriptor getInstanceForSort(FieldDescriptor.SchemaProxy proxy, Table table, String[] fieldDescriptions, Sort[] sortOrders) {
+        //noinspection ConstantConditions
         if (sortOrders == null || sortOrders.length == 0) {
             throw new IllegalArgumentException("You must provide at least one sort order.");
         }
         if (fieldDescriptions.length != sortOrders.length) {
             throw new IllegalArgumentException("Number of fields and sort orders do not match.");
         }
+        return getInstance(proxy, table, fieldDescriptions, sortOrders, FieldDescriptor.OBJECT_LINK_FIELD_TYPE, SORT_VALID_FIELD_TYPES, "Sort is not supported");
+    }
 
-        long[][] columnIndices = new long[fieldDescriptions.length][];
-        for (int i = 0; i < fieldDescriptions.length; i++) {
-            FieldDescriptor descriptor = new FieldDescriptor(table, fieldDescriptions[i], true, false);
-            checkFieldTypeForSort(descriptor, fieldDescriptions[i]);
-            columnIndices[i] = descriptor.getColumnIndices();
-        }
-
-        return new SortDescriptor(table, columnIndices, sortOrders);
+    public static SortDescriptor getInstanceForDistinct(FieldDescriptor.SchemaProxy proxy, Table table, String fieldDescription) {
+        return getInstanceForDistinct(proxy, table, new String[] {fieldDescription});
     }
 
-    public static SortDescriptor getInstanceForDistinct(Table table, String fieldDescription) {
-        return getInstanceForDistinct(table, new String[] {fieldDescription});
+    public static SortDescriptor getInstanceForDistinct(FieldDescriptor.SchemaProxy proxy, Table table, String[] fieldDescriptions) {
+        return getInstance(proxy, table, fieldDescriptions, null, FieldDescriptor.NO_LINK_FIELD_TYPE, DISTINCT_VALID_FIELD_TYPES, "Distinct is not supported");
     }
 
-    public static SortDescriptor getInstanceForDistinct(Table table, String[] fieldDescriptions) {
+    private static SortDescriptor getInstance(
+            FieldDescriptor.SchemaProxy proxy,
+            Table table,
+            String[] fieldDescriptions,
+            @Nullable Sort[] sortOrders,
+            Set<RealmFieldType> legalInternalTypes,
+            Set<RealmFieldType> legalTerminalTypes,
+            String message) {
+
+        //noinspection ConstantConditions
         if (fieldDescriptions == null || fieldDescriptions.length == 0) {
             throw new IllegalArgumentException("You must provide at least one field name.");
         }
 
         long[][] columnIndices = new long[fieldDescriptions.length][];
+
+        // Force aggressive parsing of the FieldDescriptors, so that only valid SortDescriptor objects are created.
         for (int i = 0; i < fieldDescriptions.length; i++) {
-            FieldDescriptor descriptor = new FieldDescriptor(table, fieldDescriptions[i], false, false);
-            checkFieldTypeForDistinct(descriptor, fieldDescriptions[i]);
+            FieldDescriptor descriptor = FieldDescriptor.createFieldDescriptor(proxy, table, fieldDescriptions[i], legalInternalTypes, null);
+            checkFieldType(descriptor, legalTerminalTypes, message, fieldDescriptions[i]);
             columnIndices[i] = descriptor.getColumnIndices();
         }
 
-        return new SortDescriptor(table, columnIndices, null);
+        return new SortDescriptor(table, columnIndices, sortOrders);
+    }
+
+    // Internal use only. For JNI testing.
+    //@VisibleForTesting
+    static SortDescriptor getTestInstance(Table table, long[] columnIndices) {
+        return new SortDescriptor(table, new long[][] {columnIndices}, null);
     }
 
-    private static void checkFieldTypeForSort(FieldDescriptor descriptor, String fieldDescriptions) {
-        if (!validFieldTypesForSort.contains(descriptor.getFieldType())) {
-            throw new IllegalArgumentException(String.format(
-                    "Sort is not supported on '%s' field '%s' in '%s'.", descriptor.toString(), descriptor.getFieldName(),
-                    fieldDescriptions));
+    // could do this in the field descriptor, but this provides a better error message
+    private static void checkFieldType(FieldDescriptor descriptor, Set<RealmFieldType> legalTerminalTypes, String message, String fieldDescriptions) {
+        if (!legalTerminalTypes.contains(descriptor.getFinalColumnType())) {
+            throw new IllegalArgumentException(String.format(Locale.US,
+                    "%s on '%s' field '%s' in '%s'.", message, descriptor.getFinalColumnType(), descriptor.getFinalColumnName(), fieldDescriptions));
         }
     }
 
-    private static void checkFieldTypeForDistinct(FieldDescriptor descriptor, String fieldDescriptions) {
-        if (!validFieldTypesForDistinct.contains(descriptor.getFieldType())) {
-            throw new IllegalArgumentException(String.format(
-                    "Distinct is not supported on '%s' field '%s' in '%s'.",
-                    descriptor.getFieldType().toString(), descriptor.getFieldName(), fieldDescriptions));
+
+    private final Table table;
+    private final long[][] columnIndices;
+    private final boolean[] ascendings;
+
+    private SortDescriptor(Table table, long[][] columnIndices, @Nullable Sort[] sortOrders) {
+        this.table = table;
+        this.columnIndices = columnIndices;
+        if (sortOrders != null) {
+            ascendings = new boolean[sortOrders.length];
+            for (int i = 0; i < sortOrders.length; i++) {
+                ascendings[i] = sortOrders[i].getValue();
+            }
+        } else {
+            ascendings = null;
         }
     }
 
     // Called by JNI.
-    @KeepMember
+    @SuppressWarnings("unused")
     long[][] getColumnIndices() {
         return columnIndices;
     }
 
     // Called by JNI.
-    @KeepMember
+    @SuppressWarnings("unused")
     boolean[] getAscendings() {
         return ascendings;
     }
 
     // Called by JNI.
-    @KeepMember
     @SuppressWarnings("unused")
     private long getTablePtr() {
         return table.getNativePtr();
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index 67e744ca3e..0135e69f60 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -18,8 +18,9 @@
 
 import java.util.Date;
 
+import javax.annotation.Nullable;
+
 import io.realm.RealmFieldType;
-import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmPrimaryKeyConstraintException;
 
 
@@ -28,58 +29,25 @@
  * (define/insert/delete/update) a table has. All the native communications to the Realm C++ library are also handled by
  * this class.
  */
-public class Table implements TableSchema, NativeObject {
-
-    enum PivotType {
-        COUNT(0),
-        SUM(1),
-        AVG(2),
-        MIN(3),
-        MAX(4);
-
-        final int value; // Package protected, accessible from Table
-
-        PivotType(int value) {
-            this.value = value;
-        }
-    }
+public class Table implements NativeObject {
 
-    public static final int TABLE_MAX_LENGTH = 56; // Max length of class names without prefix
-    public static final String TABLE_PREFIX = Util.getTablePrefix();
+    private static final String TABLE_PREFIX = Util.getTablePrefix();
+    private static final int TABLE_NAME_MAX_LENGTH = 63; // Max length of table names
+    public static final int CLASS_NAME_MAX_LENGTH = TABLE_NAME_MAX_LENGTH - TABLE_PREFIX.length(); // Max length of class names
     public static final long INFINITE = -1;
     public static final boolean NULLABLE = true;
     public static final boolean NOT_NULLABLE = false;
     public static final int NO_MATCH = -1;
 
-    private static final String PRIMARY_KEY_TABLE_NAME = "pk";
-    private static final String PRIMARY_KEY_CLASS_COLUMN_NAME = "pk_table";
-    private static final long PRIMARY_KEY_CLASS_COLUMN_INDEX = 0;
-    private static final String PRIMARY_KEY_FIELD_COLUMN_NAME = "pk_property";
-    private static final long PRIMARY_KEY_FIELD_COLUMN_INDEX = 1;
-    private static final long NO_PRIMARY_KEY = -2;
+    public static final int MAX_BINARY_SIZE = 0xFFFFF8 - 8/*array header size*/;
+    public static final int MAX_STRING_SIZE = 0xFFFFF8 - 8/*array header size*/ - 1;
 
-    private long nativePtr;
     private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
-    final NativeContext context;
-    private final SharedRealm sharedRealm;
-    private long cachedPrimaryKeyColumnIndex = NO_MATCH;
 
-    /**
-     * Constructs a Table base object. It can be used to register columns in this table. Registering into table is
-     * allowed only for empty tables. It creates a native reference of the object and keeps a reference to it.
-     */
-    public Table() {
-        this.context = new NativeContext();
-        // Native methods work will be initialized here. Generated classes will
-        // have nothing to do with the native functions. Generated Java Table
-        // classes will work as a wrapper on top of table.
-        this.nativePtr = createNative();
-        if (nativePtr == 0) {
-            throw new java.lang.OutOfMemoryError("Out of native memory.");
-        }
-        this.sharedRealm = null;
-        context.addReference(this);
-    }
+    private final long nativePtr;
+    private final NativeContext context;
+
+    private final SharedRealm sharedRealm;
 
     Table(Table parent, long nativePointer) {
         this(parent.sharedRealm, nativePointer);
@@ -102,8 +70,8 @@ public long getNativeFinalizerPtr() {
         return nativeFinalizerPtr;
     }
 
-    public long getNativeTablePointer() {
-        return nativePtr;
+    public Table getTable() {
+        return this;
     }
 
     /*
@@ -132,7 +100,28 @@ private void verifyColumnName(String name) {
      */
     public long addColumn(RealmFieldType type, String name, boolean isNullable) {
         verifyColumnName(name);
-        return nativeAddColumn(nativePtr, type.getNativeValue(), name, isNullable);
+        switch (type) {
+            case INTEGER:
+            case BOOLEAN:
+            case STRING:
+            case BINARY:
+            case DATE:
+            case FLOAT:
+            case DOUBLE:
+                return nativeAddColumn(nativePtr, type.getNativeValue(), name, isNullable);
+
+            case INTEGER_LIST:
+            case BOOLEAN_LIST:
+            case STRING_LIST:
+            case BINARY_LIST:
+            case DATE_LIST:
+            case FLOAT_LIST:
+            case DOUBLE_LIST:
+                return nativeAddPrimitiveListColumn(nativePtr, type.getNativeValue() - 128, name, isNullable);
+
+            default:
+                throw new IllegalArgumentException("Unsupported type: " + type);
+        }
     }
 
     /**
@@ -140,7 +129,6 @@ public long addColumn(RealmFieldType type, String name, boolean isNullable) {
      *
      * @return the index of the new column.
      */
-    @Override
     public long addColumn(RealmFieldType type, String name) {
         return addColumn(type, name, false);
     }
@@ -156,40 +144,30 @@ public long addColumnLink(RealmFieldType type, String name, Table table) {
     }
 
     /**
-     * Removes a column in the table dynamically. If {@code columnIndex} is smaller than the primary
-     * key column index, {@link #invalidateCachedPrimaryKeyIndex()} will be called to recalculate the
-     * primary key column index.
+     * Removes a column in the table dynamically.
      * <p>
-     * <p>It should be noted if {@code columnIndex} is the same as the primary key column index,
+     * It should be noted if {@code columnIndex} is the same as the primary key column index,
      * the primary key column is removed from the meta table.
      *
      * @param columnIndex the column index to be removed.
      */
-    @Override
     public void removeColumn(long columnIndex) {
+        final String className = getClassName();
         // Checks the PK column index before removing a column. We don't know if we're hitting a PK col,
         // but it should be noted that once a column is removed, there is no way we can find whether
         // a PK exists or not.
-        final long oldPkColumnIndex = getPrimaryKey();
+        final String columnName = getColumnName(columnIndex);
+        final String pkName = OsObjectStore.getPrimaryKeyForObject(sharedRealm, getClassName());
 
         // First removes a column. If there is no error, we can proceed. Otherwise, it will stop here.
         nativeRemoveColumn(nativePtr, columnIndex);
 
-        // Checks if a PK exists and takes actions if there is. This is same as hasPrimaryKey(), but
-        // this relies on the local cache.
-        if (oldPkColumnIndex >= 0) {
-
+        // Checks if a PK exists and takes actions if there is.
+        if (columnName.equals(pkName)) {
             // In case we're hitting PK column, we should remove the PK as it is either 1) a user has
             // forgotten to remove PK or 2) removeColumn gets called before setPrimaryKey(null) is called.
             // Since there is no danger in removing PK twice, we'll do it here to be on safe side.
-            if (oldPkColumnIndex == columnIndex) {
-                setPrimaryKey(null);
-
-                // But if you remove a column with a smaller index than that of PK column, you need to
-                // recalculate the PK column index as core could have changed its column index.
-            } else if (oldPkColumnIndex > columnIndex) {
-                invalidateCachedPrimaryKeyIndex();
-            }
+            OsObjectStore.setPrimaryKeyForObject(sharedRealm, className, null);
         }
     }
 
@@ -200,35 +178,20 @@ public void removeColumn(long columnIndex) {
      * @param columnIndex the column index to be renamed.
      * @param newName a new name replacing the old column name.
      * @throws IllegalArgumentException if {@code newFieldName} is an empty string, or exceeds field name length limit.
-     * @throws IllegalStateException if a PrimaryKey column name could not be found in the meta table, but {@link #getPrimaryKey()} returns an index.
      */
-    @Override
     public void renameColumn(long columnIndex, String newName) {
         verifyColumnName(newName);
         // Gets the old column name. We'll assume that the old column name is *NOT* an empty string.
         final String oldName = nativeGetColumnName(nativePtr, columnIndex);
-        // Also old pk index. Once a column name changes, there is no way you can find the column name
-        // by old name.
-        final long oldPkColumnIndex = getPrimaryKey();
+        final String pkName = OsObjectStore.getPrimaryKeyForObject(sharedRealm, getClassName());
 
         // Then let's try to rename a column. If an error occurs for some reasons, we'll throw.
         nativeRenameColumn(nativePtr, columnIndex, newName);
 
         // Renames a primary key. At this point, renaming the column name should have been fine.
-        if (oldPkColumnIndex == columnIndex) {
+        if (oldName.equals(pkName)) {
             try {
-                String className = tableNameToClassName(getName());
-                Table pkTable = getPrimaryKeyTable();
-                if (pkTable == null) {
-                    throw new IllegalStateException(
-                            "Table is not created from a SharedRealm, primary key is not available");
-                }
-                long pkRowIndex = pkTable.findFirstString(PRIMARY_KEY_CLASS_COLUMN_INDEX, className);
-                if (pkRowIndex != NO_MATCH) {
-                    nativeSetString(pkTable.nativePtr, PRIMARY_KEY_FIELD_COLUMN_INDEX, pkRowIndex, newName, false);
-                } else {
-                    throw new IllegalStateException("Non-existent PrimaryKey column cannot be renamed");
-                }
+                OsObjectStore.setPrimaryKeyForObject(sharedRealm, getClassName(), newName);
             } catch (Exception e) {
                 // We failed to rename the pk meta table. roll back the column name, not pk meta table
                 // then rethrow.
@@ -238,6 +201,15 @@ public void renameColumn(long columnIndex, String newName) {
         }
     }
 
+    /**
+     * Inserts a column at the given {@code columnIndex}.
+     * WARNING: This is only for internal testing purpose. Don't expose this to public API.
+     */
+    public void insertColumn(long columnIndex, RealmFieldType type, String name) {
+        verifyColumnName(name);
+        nativeInsertColumn(nativePtr, columnIndex, type.getNativeValue(), name);
+    }
+
     /**
      * Checks whether the specific column is nullable?
      *
@@ -254,7 +226,7 @@ public boolean isColumnNullable(long columnIndex) {
      * @param columnIndex the column index.
      */
     public void convertColumnToNullable(long columnIndex) {
-        nativeConvertColumnToNullable(nativePtr, columnIndex);
+        nativeConvertColumnToNullable(nativePtr, columnIndex, isPrimaryKey(columnIndex));
     }
 
     /**
@@ -263,7 +235,7 @@ public void convertColumnToNullable(long columnIndex) {
      * @param columnIndex the column index.
      */
     public void convertColumnToNotNullable(long columnIndex) {
-        nativeConvertColumnToNotNullable(nativePtr, columnIndex);
+        nativeConvertColumnToNotNullable(nativePtr, columnIndex, isPrimaryKey(columnIndex));
     }
 
     // Table Size and deletion. AutoGenerated subclasses are nothing to do with this
@@ -350,239 +322,6 @@ public void moveLastOver(long rowIndex) {
         nativeMoveLastOver(nativePtr, rowIndex);
     }
 
-    /**
-     * Adds an empty row to the table which doesn't have a primary key defined.
-     * <p>
-     * NOTE: To add a table with a primary key defined, use {@link #addEmptyRowWithPrimaryKey(Object)} instead. This
-     * won't check if this table has a primary key.
-     *
-     * @return row index.
-     */
-    public long addEmptyRow() {
-        checkImmutable();
-        return nativeAddEmptyRow(nativePtr, 1);
-    }
-
-    /**
-     * Adds an empty row to the table and set the primary key with the given value. Equivalent to call
-     * {@link #addEmptyRowWithPrimaryKey(Object, boolean)} with {@code validation = true}.
-     *
-     * @param primaryKeyValue the primary key value
-     * @return the row index.
-     */
-    public long addEmptyRowWithPrimaryKey(Object primaryKeyValue) {
-        return addEmptyRowWithPrimaryKey(primaryKeyValue, true);
-    }
-
-    /**
-     * Adds an empty row to the table and set the primary key with the given value.
-     *
-     * @param primaryKeyValue the primary key value.
-     * @param validation set to {@code false} to skip all validations. This is currently used by bulk insert which
-     * has its own validations.
-     * @return the row index.
-     */
-    public long addEmptyRowWithPrimaryKey(Object primaryKeyValue, boolean validation) {
-        if (validation) {
-            checkImmutable();
-            checkHasPrimaryKey();
-        }
-
-        long primaryKeyColumnIndex = getPrimaryKey();
-        RealmFieldType type = getColumnType(primaryKeyColumnIndex);
-        long rowIndex;
-
-        // Adds with primary key initially set.
-        if (primaryKeyValue == null) {
-            switch (type) {
-                case STRING:
-                case INTEGER:
-                    if (validation && findFirstNull(primaryKeyColumnIndex) != NO_MATCH) {
-                        throwDuplicatePrimaryKeyException("null");
-                    }
-                    rowIndex = nativeAddEmptyRow(nativePtr, 1);
-                    if (type == RealmFieldType.STRING) {
-                        nativeSetStringUnique(nativePtr, primaryKeyColumnIndex, rowIndex, null);
-                    } else {
-                        nativeSetNullUnique(nativePtr, primaryKeyColumnIndex, rowIndex);
-                    }
-                    break;
-
-                default:
-                    throw new RealmException("Cannot check for duplicate rows for unsupported primary key type: " + type);
-            }
-
-        } else {
-            switch (type) {
-                case STRING:
-                    if (!(primaryKeyValue instanceof String)) {
-                        throw new IllegalArgumentException("Primary key value is not a String: " + primaryKeyValue);
-                    }
-                    if (validation && findFirstString(primaryKeyColumnIndex, (String) primaryKeyValue) != NO_MATCH) {
-                        throwDuplicatePrimaryKeyException(primaryKeyValue);
-                    }
-                    rowIndex = nativeAddEmptyRow(nativePtr, 1);
-                    nativeSetStringUnique(nativePtr, primaryKeyColumnIndex, rowIndex, (String) primaryKeyValue);
-                    break;
-
-                case INTEGER:
-                    long pkValue;
-                    try {
-                        pkValue = Long.parseLong(primaryKeyValue.toString());
-                    } catch (RuntimeException e) {
-                        throw new IllegalArgumentException("Primary key value is not a long: " + primaryKeyValue);
-                    }
-                    if (validation && findFirstLong(primaryKeyColumnIndex, pkValue) != NO_MATCH) {
-                        throwDuplicatePrimaryKeyException(pkValue);
-                    }
-                    rowIndex = nativeAddEmptyRow(nativePtr, 1);
-                    nativeSetLongUnique(nativePtr, primaryKeyColumnIndex, rowIndex, pkValue);
-                    break;
-
-                default:
-                    throw new RealmException("Cannot check for duplicate rows for unsupported primary key type: " + type);
-            }
-        }
-        return rowIndex;
-    }
-
-    @SuppressWarnings("WeakerAccess")
-    public long addEmptyRows(long rows) {
-        checkImmutable();
-        if (rows < 1) {
-            throw new IllegalArgumentException("'rows' must be > 0.");
-        }
-        if (hasPrimaryKey()) {
-            if (rows > 1) {
-                throw new RealmException("Multiple empty rows cannot be created if a primary key is defined for the table.");
-            }
-            return addEmptyRow();
-        }
-        return nativeAddEmptyRow(nativePtr, rows);
-    }
-
-    /**
-     * Appends the specified row to the end of the table. For internal testing usage only.
-     *
-     * @param values values.
-     * @return the row index of the appended row.
-     * @deprecated Remove this functions since it doesn't seem to be useful. And this function does deal with tables
-     * with primary key defined well. Primary key has to be set with `setXxxUnique` as the first thing to do after row
-     * added.
-     */
-    protected long add(Object... values) {
-        long rowIndex = addEmptyRow();
-
-        checkImmutable();
-
-        // Checks values types.
-        int columns = (int) getColumnCount();
-        if (columns != values.length) {
-            throw new IllegalArgumentException("The number of value parameters (" +
-                    String.valueOf(values.length) +
-                    ") does not match the number of columns in the table (" +
-                    String.valueOf(columns) + ").");
-        }
-        RealmFieldType colTypes[] = new RealmFieldType[columns];
-        for (int columnIndex = 0; columnIndex < columns; columnIndex++) {
-            Object value = values[columnIndex];
-            RealmFieldType colType = getColumnType(columnIndex);
-            colTypes[columnIndex] = colType;
-            if (!colType.isValid(value)) {
-                // String representation of the provided value type.
-                String providedType;
-                if (value == null) {
-                    providedType = "null";
-                } else {
-                    providedType = value.getClass().toString();
-                }
-
-                throw new IllegalArgumentException("Invalid argument no " + String.valueOf(1 + columnIndex) +
-                        ". Expected a value compatible with column type " + colType + ", but got " + providedType + ".");
-            }
-        }
-
-        // Inserts values.
-        for (long columnIndex = 0; columnIndex < columns; columnIndex++) {
-            Object value = values[(int) columnIndex];
-            switch (colTypes[(int) columnIndex]) {
-                case BOOLEAN:
-                    nativeSetBoolean(nativePtr, columnIndex, rowIndex, (Boolean) value, false);
-                    break;
-                case INTEGER:
-                    if (value == null) {
-                        checkDuplicatedNullForPrimaryKeyValue(columnIndex, rowIndex);
-                        nativeSetNull(nativePtr, columnIndex, rowIndex, false);
-                    } else {
-                        long intValue = ((Number) value).longValue();
-                        checkIntValueIsLegal(columnIndex, rowIndex, intValue);
-                        nativeSetLong(nativePtr, columnIndex, rowIndex, intValue, false);
-                    }
-                    break;
-                case FLOAT:
-                    nativeSetFloat(nativePtr, columnIndex, rowIndex, (Float) value, false);
-                    break;
-                case DOUBLE:
-                    nativeSetDouble(nativePtr, columnIndex, rowIndex, (Double) value, false);
-                    break;
-                case STRING:
-                    if (value == null) {
-                        checkDuplicatedNullForPrimaryKeyValue(columnIndex, rowIndex);
-                        nativeSetNull(nativePtr, columnIndex, rowIndex, false);
-                    } else {
-                        String stringValue = (String) value;
-                        checkStringValueIsLegal(columnIndex, rowIndex, stringValue);
-                        nativeSetString(nativePtr, columnIndex, rowIndex, (String) value, false);
-                    }
-                    break;
-                case DATE:
-                    if (value == null) { throw new IllegalArgumentException("Null Date is not allowed."); }
-                    nativeSetTimestamp(nativePtr, columnIndex, rowIndex, ((Date) value).getTime(), false);
-                    break;
-                case BINARY:
-                    if (value == null) { throw new IllegalArgumentException("Null Array is not allowed"); }
-                    nativeSetByteArray(nativePtr, columnIndex, rowIndex, (byte[]) value, false);
-                    break;
-                case UNSUPPORTED_MIXED:
-                case UNSUPPORTED_TABLE:
-                default:
-                    throw new RuntimeException("Unexpected columnType: " + String.valueOf(colTypes[(int) columnIndex]));
-            }
-        }
-        return rowIndex;
-    }
-
-    private boolean isPrimaryKeyColumn(long columnIndex) {
-        return columnIndex == getPrimaryKey();
-    }
-
-    /**
-     * Returns the column index for the primary key.
-     *
-     * @return the column index or {@code #NO_MATCH} if no primary key is set.
-     */
-    public long getPrimaryKey() {
-        if (cachedPrimaryKeyColumnIndex >= 0 || cachedPrimaryKeyColumnIndex == NO_PRIMARY_KEY) {
-            return cachedPrimaryKeyColumnIndex;
-        } else {
-            Table pkTable = getPrimaryKeyTable();
-            if (pkTable == null) {
-                return NO_PRIMARY_KEY; // Free table = No primary key.
-            }
-
-            String className = tableNameToClassName(getName());
-            long rowIndex = pkTable.findFirstString(PRIMARY_KEY_CLASS_COLUMN_INDEX, className);
-            if (rowIndex != NO_MATCH) {
-                String pkColumnName = pkTable.getUncheckedRow(rowIndex).getString(PRIMARY_KEY_FIELD_COLUMN_INDEX);
-                cachedPrimaryKeyColumnIndex = getColumnIndex(pkColumnName);
-            } else {
-                cachedPrimaryKeyColumnIndex = NO_PRIMARY_KEY;
-            }
-
-            return cachedPrimaryKeyColumnIndex;
-        }
-    }
-
     /**
      * Checks if a given column is a primary key column.
      *
@@ -590,53 +329,7 @@ public long getPrimaryKey() {
      * @return {@code true} if column is a primary key, {@code false} otherwise.
      */
     private boolean isPrimaryKey(long columnIndex) {
-        return columnIndex >= 0 && columnIndex == getPrimaryKey();
-    }
-
-    /**
-     * Checks if a table has a primary key.
-     *
-     * @return {@code true} if primary key is defined, {@code false} otherwise.
-     */
-    public boolean hasPrimaryKey() {
-        return getPrimaryKey() >= 0;
-    }
-
-    void checkStringValueIsLegal(long columnIndex, long rowToUpdate, String value) {
-        if (isPrimaryKey(columnIndex)) {
-            long rowIndex = findFirstString(columnIndex, value);
-            if (rowIndex != rowToUpdate && rowIndex != NO_MATCH) {
-                throwDuplicatePrimaryKeyException(value);
-            }
-        }
-    }
-
-    void checkIntValueIsLegal(long columnIndex, long rowToUpdate, long value) {
-        if (isPrimaryKeyColumn(columnIndex)) {
-            long rowIndex = findFirstLong(columnIndex, value);
-            if (rowIndex != rowToUpdate && rowIndex != NO_MATCH) {
-                throwDuplicatePrimaryKeyException(value);
-            }
-        }
-    }
-
-    // Checks if it is ok to use null value for given row and column.
-    void checkDuplicatedNullForPrimaryKeyValue(long columnIndex, long rowToUpdate) {
-        if (isPrimaryKeyColumn(columnIndex)) {
-            RealmFieldType type = getColumnType(columnIndex);
-            switch (type) {
-                case STRING:
-                case INTEGER:
-                    long rowIndex = findFirstNull(columnIndex);
-                    if (rowIndex != rowToUpdate && rowIndex != NO_MATCH) {
-                        throwDuplicatePrimaryKeyException("null");
-                    }
-                    break;
-                default:
-                    // Since it is sufficient to check the existence of duplicated null values
-                    // on PrimaryKey in supported types only, this part is left empty.
-            }
-        }
+        return getColumnName(columnIndex).equals(OsObjectStore.getPrimaryKeyForObject(sharedRealm, getClassName()));
     }
 
     /**
@@ -653,6 +346,10 @@ public static void throwDuplicatePrimaryKeyException(Object value) {
     // Getters
     //
 
+    SharedRealm getSharedRealm() {
+        return sharedRealm;
+    }
+
     public long getLong(long columnIndex, long rowIndex) {
         return nativeGetLong(nativePtr, columnIndex, rowIndex);
     }
@@ -743,10 +440,15 @@ public CheckedRow getCheckedRow(long index) {
 
     public void setLong(long columnIndex, long rowIndex, long value, boolean isDefault) {
         checkImmutable();
-        checkIntValueIsLegal(columnIndex, rowIndex, value);
         nativeSetLong(nativePtr, columnIndex, rowIndex, value, isDefault);
     }
 
+    // must not be called on a primary key field
+    public void incrementLong(long columnIndex, long rowIndex, long value) {
+        checkImmutable();
+        nativeIncrementLong(nativePtr, columnIndex, rowIndex, value);
+    }
+
     public void setBoolean(long columnIndex, long rowIndex, boolean value, boolean isDefault) {
         checkImmutable();
         nativeSetBoolean(nativePtr, columnIndex, rowIndex, value, isDefault);
@@ -775,13 +477,11 @@ public void setDate(long columnIndex, long rowIndex, Date date, boolean isDefaul
      * @param rowIndex 0 based index value of the cell row.
      * @param value a String value to set in the cell.
      */
-    public void setString(long columnIndex, long rowIndex, String value, boolean isDefault) {
+    public void setString(long columnIndex, long rowIndex, @Nullable String value, boolean isDefault) {
         checkImmutable();
         if (value == null) {
-            checkDuplicatedNullForPrimaryKeyValue(columnIndex, rowIndex);
             nativeSetNull(nativePtr, columnIndex, rowIndex, isDefault);
         } else {
-            checkStringValueIsLegal(columnIndex, rowIndex, value);
             nativeSetString(nativePtr, columnIndex, rowIndex, value, isDefault);
         }
     }
@@ -798,7 +498,6 @@ public void setLink(long columnIndex, long rowIndex, long value, boolean isDefau
 
     public void setNull(long columnIndex, long rowIndex, boolean isDefault) {
         checkImmutable();
-        checkDuplicatedNullForPrimaryKeyValue(columnIndex, rowIndex);
         nativeSetNull(nativePtr, columnIndex, rowIndex, isDefault);
     }
 
@@ -812,48 +511,6 @@ public void removeSearchIndex(long columnIndex) {
         nativeRemoveSearchIndex(nativePtr, columnIndex);
     }
 
-    /**
-     * Defines a primary key for this table. This needs to be called manually before inserting data into the table.
-     *
-     * @param columnName the name of the field that will function primary key. "" or {@code null} will remove any
-     * previous set magic key.
-     * @throws io.realm.exceptions.RealmException if it is not possible to set the primary key due to the column
-     * not having distinct values (i.e. violating the primary key constraint).
-     */
-    public void setPrimaryKey(String columnName) {
-        Table pkTable = getPrimaryKeyTable();
-        if (pkTable == null) {
-            throw new RealmException("Primary keys are only supported if Table is part of a Group");
-        }
-        cachedPrimaryKeyColumnIndex = nativeSetPrimaryKey(pkTable.nativePtr, nativePtr, columnName);
-    }
-
-    public void setPrimaryKey(long columnIndex) {
-        setPrimaryKey(nativeGetColumnName(nativePtr, columnIndex));
-    }
-
-    private Table getPrimaryKeyTable() {
-        if (sharedRealm == null) {
-            return null;
-        }
-        Table pkTable = sharedRealm.getTable(PRIMARY_KEY_TABLE_NAME);
-        if (pkTable.getColumnCount() == 0) {
-            checkImmutable();
-            long columnIndex = pkTable.addColumn(RealmFieldType.STRING, PRIMARY_KEY_CLASS_COLUMN_NAME);
-            pkTable.addSearchIndex(columnIndex);
-            pkTable.addColumn(RealmFieldType.STRING, PRIMARY_KEY_FIELD_COLUMN_NAME);
-        }
-
-        return pkTable;
-    }
-
-    /**
-     * Invalidates a cached primary key column index for the table.
-     */
-    private void invalidateCachedPrimaryKeyIndex() {
-        cachedPrimaryKeyColumnIndex = NO_MATCH;
-    }
-
     /*
      * 1) Migration required to fix https://github.com/realm/realm-java/issues/1059
      * This will convert INTEGER column to the corresponding STRING column if needed.
@@ -862,24 +519,12 @@ private void invalidateCachedPrimaryKeyIndex() {
      * 2) Migration required to fix: https://github.com/realm/realm-java/issues/1703
      * This will remove the prefix "class_" from all table names in the pk_column
      * Any database created on Realm-Java 0.84.1 and below will have this error.
+     *
+     * The native method will begin a transaction and make the migration if needed.
+     * This function should not be called in a transaction.
      */
-    public static boolean migratePrimaryKeyTableIfNeeded(SharedRealm sharedRealm) {
-        if (sharedRealm == null || !sharedRealm.isInTransaction()) {
-            throwImmutable();
-        }
-        if (!sharedRealm.hasTable(PRIMARY_KEY_TABLE_NAME)) {
-            return false;
-        }
-        Table pkTable = sharedRealm.getTable(PRIMARY_KEY_TABLE_NAME);
-        return nativeMigratePrimaryKeyTableIfNeeded(sharedRealm.getGroupNative(), pkTable.nativePtr);
-    }
-
-    public static boolean primaryKeyTableNeedsMigration(SharedRealm sharedRealm) {
-        if (!sharedRealm.hasTable(PRIMARY_KEY_TABLE_NAME)) {
-            return false;
-        }
-        Table pkTable = sharedRealm.getTable(PRIMARY_KEY_TABLE_NAME);
-        return nativePrimaryKeyTableNeedsMigration(pkTable.nativePtr);
+    public static void migratePrimaryKeyTableIfNeeded(SharedRealm sharedRealm) {
+        nativeMigratePrimaryKeyTableIfNeeded(sharedRealm.getNativePtr());
     }
 
     public boolean hasSearchIndex(long columnIndex) {
@@ -905,12 +550,6 @@ void checkImmutable() {
         }
     }
 
-    private void checkHasPrimaryKey() {
-        if (!hasPrimaryKey()) {
-            throw new IllegalStateException(getName() + " has no primary key defined");
-        }
-    }
-
     //
     // Count
     //
@@ -981,40 +620,26 @@ public long findFirstNull(long columnIndex) {
         return nativeFindFirstNull(nativePtr, columnIndex);
     }
 
-    // Experimental feature
-    public long lowerBoundLong(long columnIndex, long value) {
-        return nativeLowerBoundInt(nativePtr, columnIndex, value);
-    }
-
-    public long upperBoundLong(long columnIndex, long value) {
-        return nativeUpperBoundInt(nativePtr, columnIndex, value);
-    }
-
-    public Table pivot(long stringCol, long intCol, PivotType pivotType) {
-        if (!this.getColumnType(stringCol).equals(RealmFieldType.STRING)) {
-            throw new UnsupportedOperationException("Group by column must be of type String");
-        }
-        if (!this.getColumnType(intCol).equals(RealmFieldType.INTEGER)) {
-            throw new UnsupportedOperationException("Aggregation column must be of type Int");
-        }
-        Table result = new Table();
-        nativePivot(nativePtr, stringCol, intCol, pivotType.value, result.nativePtr);
-        return result;
-    }
-
     //
 
     /**
      * Returns the table name as it is in the associated group.
      *
-     * @return Name of the the table or null if it not part of a group.
+     * @return Name of the the table or {@code null} if it not part of a group.
      */
+    @Nullable
     public String getName() {
         return nativeGetName(nativePtr);
     }
 
-    public String toJson() {
-        return nativeToJson(nativePtr);
+    /**
+     * Returns the class name for the table.
+     *
+     * @return Name of the the table or {@code null} if it not part of a group.
+     */
+    @Nullable
+    public String getClassName() {
+        return getClassNameForTable(getName());
     }
 
     @Override
@@ -1026,10 +651,6 @@ public String toString() {
             stringBuilder.append(getName());
             stringBuilder.append(" ");
         }
-        if (hasPrimaryKey()) {
-            String pkFieldName = getColumnName(getPrimaryKey());
-            stringBuilder.append("has \'").append(pkFieldName).append("\' field as a PrimaryKey, and ");
-        }
         stringBuilder.append("contains ");
         stringBuilder.append(columnCount);
         stringBuilder.append(" columns: ");
@@ -1050,7 +671,7 @@ public String toString() {
     }
 
     private static void throwImmutable() {
-        throw new IllegalStateException("Changing Realm data can only be done from inside a transaction.");
+        throw new IllegalStateException("Cannot modify managed objects outside of a write transaction.");
     }
 
     /**
@@ -1066,48 +687,40 @@ public boolean hasSameSchema(Table table) {
         return nativeHasSameSchema(this.nativePtr, table.nativePtr);
     }
 
-    /**
-     * Checks if a given table name is a name for a model table.
-     */
-    public static boolean isModelTable(String tableName) {
-        return tableName.startsWith(TABLE_PREFIX);
-    }
-
-    /**
-     * Reports the current versioning counter for the table. The versioning counter is guaranteed to
-     * change when the contents of the table changes after advance_read() or promote_to_write(), or
-     * immediately after calls to methods which change the table.
-     *
-     * @return version_counter for the table.
-     */
-    public long getVersion() {
-        return nativeVersion(nativePtr);
-    }
-
-    public static String tableNameToClassName(String tableName) {
-        if (!tableName.startsWith(Table.TABLE_PREFIX)) {
-            return tableName;
+    @Nullable
+    public static String getClassNameForTable(@Nullable String name) {
+        if (name == null) { return null; }
+        if (!name.startsWith(TABLE_PREFIX)) {
+            return name;
         }
-        return tableName.substring(Table.TABLE_PREFIX.length());
+        return name.substring(TABLE_PREFIX.length());
     }
 
-    protected native long createNative();
+    public static String getTableNameForClass(String name) {
+        //noinspection ConstantConditions
+        if (name == null) { return null; }
+        return TABLE_PREFIX + name;
+    }
 
     private native boolean nativeIsValid(long nativeTablePtr);
 
     private native long nativeAddColumn(long nativeTablePtr, int type, String name, boolean isNullable);
 
+    private native long nativeAddPrimitiveListColumn(long nativeTablePtr, int type, String name, boolean isNullable);
+
     private native long nativeAddColumnLink(long nativeTablePtr, int type, String name, long targetTablePtr);
 
     private native void nativeRenameColumn(long nativeTablePtr, long columnIndex, String name);
 
     private native void nativeRemoveColumn(long nativeTablePtr, long columnIndex);
 
+    private static native void nativeInsertColumn(long nativeTablePtr, long columnIndex, int type, String name);
+
     private native boolean nativeIsColumnNullable(long nativePtr, long columnIndex);
 
-    private native void nativeConvertColumnToNullable(long nativeTablePtr, long columnIndex);
+    private native void nativeConvertColumnToNullable(long nativeTablePtr, long columnIndex, boolean isPrimaryKey);
 
-    private native void nativeConvertColumnToNotNullable(long nativePtr, long columnIndex);
+    private native void nativeConvertColumnToNotNullable(long nativePtr, long columnIndex, boolean isPrimaryKey);
 
     private native long nativeSize(long nativeTablePtr);
 
@@ -1123,10 +736,6 @@ public static String tableNameToClassName(String tableName) {
 
     private native void nativeMoveLastOver(long nativeTablePtr, long rowIndex);
 
-    public static native long nativeAddEmptyRow(long nativeTablePtr, long rows);
-
-    private native long nativeGetSortedViewMulti(long nativeTableViewPtr, long[] columnIndices, boolean[] ascending);
-
     private native long nativeGetLong(long nativeTablePtr, long columnIndex, long rowIndex);
 
     private native boolean nativeGetBoolean(long nativeTablePtr, long columnIndex, long rowIndex);
@@ -1143,8 +752,6 @@ public static String tableNameToClassName(String tableName) {
 
     private native long nativeGetLink(long nativePtr, long columnIndex, long rowIndex);
 
-    public static native long nativeGetLinkView(long nativePtr, long columnIndex, long rowIndex);
-
     private native long nativeGetLinkTarget(long nativePtr, long columnIndex);
 
     private native boolean nativeIsNull(long nativePtr, long columnIndex, long rowIndex);
@@ -1153,7 +760,7 @@ public static String tableNameToClassName(String tableName) {
 
     public static native void nativeSetLong(long nativeTablePtr, long columnIndex, long rowIndex, long value, boolean isDefault);
 
-    public static native void nativeSetLongUnique(long nativeTablePtr, long columnIndex, long rowIndex, long value);
+    public static native void nativeIncrementLong(long nativeTablePtr, long columnIndex, long rowIndex, long value);
 
     public static native void nativeSetBoolean(long nativeTablePtr, long columnIndex, long rowIndex, boolean value, boolean isDefault);
 
@@ -1165,22 +772,13 @@ public static String tableNameToClassName(String tableName) {
 
     public static native void nativeSetString(long nativeTablePtr, long columnIndex, long rowIndex, String value, boolean isDefault);
 
-    public static native void nativeSetStringUnique(long nativeTablePtr, long columnIndex, long rowIndex, String value);
-
     public static native void nativeSetNull(long nativeTablePtr, long columnIndex, long rowIndex, boolean isDefault);
 
-    // Use nativeSetStringUnique(null) for String column!
-    public static native void nativeSetNullUnique(long nativeTablePtr, long columnIndex, long rowIndex);
-
     public static native void nativeSetByteArray(long nativePtr, long columnIndex, long rowIndex, byte[] data, boolean isDefault);
 
     public static native void nativeSetLink(long nativeTablePtr, long columnIndex, long rowIndex, long value, boolean isDefault);
 
-    private native long nativeSetPrimaryKey(long privateKeyTableNativePtr, long nativePtr, String columnName);
-
-    private static native boolean nativeMigratePrimaryKeyTableIfNeeded(long groupNativePtr, long primaryKeyTableNativePtr);
-
-    private static native boolean nativePrimaryKeyTableNeedsMigration(long primaryKeyTableNativePtr);
+    private static native void nativeMigratePrimaryKeyTableIfNeeded(long sharedRealmPtr);
 
     private native void nativeAddSearchIndex(long nativePtr, long columnIndex);
 
@@ -1216,21 +814,9 @@ public static String tableNameToClassName(String tableName) {
 
     public static native long nativeFindFirstNull(long nativeTablePtr, long columnIndex);
 
-    // FIXME: Disabled in cpp code, see comments there
-    // private native long nativeFindAllTimestamp(long nativePtr, long columnIndex, long dateTimeValue);
-    private native long nativeLowerBoundInt(long nativePtr, long columnIndex, long value);
-
-    private native long nativeUpperBoundInt(long nativePtr, long columnIndex, long value);
-
-    private native void nativePivot(long nativeTablePtr, long stringCol, long intCol, int pivotType, long resultPtr);
-
     private native String nativeGetName(long nativeTablePtr);
 
-    private native String nativeToJson(long nativeTablePtr);
-
     private native boolean nativeHasSameSchema(long thisTable, long otherTable);
 
-    private native long nativeVersion(long nativeTablePtr);
-
     private static native long nativeGetFinalizerPtr();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
index 8d0be81e47..9de705eae5 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
@@ -18,18 +18,25 @@
 
 import java.util.Date;
 
+import javax.annotation.Nullable;
+
 import io.realm.Case;
 import io.realm.Sort;
+import io.realm.log.RealmLog;
 
 
 public class TableQuery implements NativeObject {
-    protected boolean DEBUG = false;
+    private static final boolean DEBUG = false;
 
-    protected long nativePtr;
     private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
-    protected final Table table;
+
+    // See documentation in that NativeContext for an explanation of how this is used
+    @SuppressWarnings("unused")
     private final NativeContext context;
 
+    private final Table table;
+    private final long nativePtr;
+
     // All actions (find(), findAll(), sum(), etc.) must call validateQuery() before performing
     // the actual action. The other methods must set queryValidated to false in order to enforce
     // the first action to validate the syntax of the query.
@@ -38,7 +45,7 @@
     // TODO: Can we protect this?
     public TableQuery(NativeContext context, Table table, long nativeQueryPtr) {
         if (DEBUG) {
-            System.err.println("++++++ new TableQuery, ptr= " + nativeQueryPtr);
+            RealmLog.debug("New TableQuery: ptr=%x", nativeQueryPtr);
         }
         this.context = context;
         this.table = table;
@@ -100,38 +107,38 @@ public TableQuery not() {
 
     // Queries for integer values.
 
-    public TableQuery equalTo(long[] columnIndexes, long value) {
-        nativeEqual(nativePtr, columnIndexes, value);
+    public TableQuery equalTo(long[] columnIndexes, long[] tablePtrs, long value) {
+        nativeEqual(nativePtr, columnIndexes, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery notEqualTo(long[] columnIndex, long value) {
-        nativeNotEqual(nativePtr, columnIndex, value);
+    public TableQuery notEqualTo(long[] columnIndex, long[] tablePtrs, long value) {
+        nativeNotEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThan(long[] columnIndex, long value) {
-        nativeGreater(nativePtr, columnIndex, value);
+    public TableQuery greaterThan(long[] columnIndex, long[] tablePtrs, long value) {
+        nativeGreater(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThanOrEqual(long[] columnIndex, long value) {
-        nativeGreaterEqual(nativePtr, columnIndex, value);
+    public TableQuery greaterThanOrEqual(long[] columnIndex, long[] tablePtrs, long value) {
+        nativeGreaterEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThan(long[] columnIndex, long value) {
-        nativeLess(nativePtr, columnIndex, value);
+    public TableQuery lessThan(long[] columnIndex, long[] tablePtrs, long value) {
+        nativeLess(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThanOrEqual(long[] columnIndex, long value) {
-        nativeLessEqual(nativePtr, columnIndex, value);
+    public TableQuery lessThanOrEqual(long[] columnIndex, long[] tablePtrs, long value) {
+        nativeLessEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
@@ -144,38 +151,38 @@ public TableQuery between(long[] columnIndex, long value1, long value2) {
 
     // Queries for float values.
 
-    public TableQuery equalTo(long[] columnIndex, float value) {
-        nativeEqual(nativePtr, columnIndex, value);
+    public TableQuery equalTo(long[] columnIndex, long[] tablePtrs, float value) {
+        nativeEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery notEqualTo(long[] columnIndex, float value) {
-        nativeNotEqual(nativePtr, columnIndex, value);
+    public TableQuery notEqualTo(long[] columnIndex, long[] tablePtrs, float value) {
+        nativeNotEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThan(long[] columnIndex, float value) {
-        nativeGreater(nativePtr, columnIndex, value);
+    public TableQuery greaterThan(long[] columnIndex, long[] tablePtrs, float value) {
+        nativeGreater(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThanOrEqual(long[] columnIndex, float value) {
-        nativeGreaterEqual(nativePtr, columnIndex, value);
+    public TableQuery greaterThanOrEqual(long[] columnIndex, long[] tablePtrs, float value) {
+        nativeGreaterEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThan(long[] columnIndex, float value) {
-        nativeLess(nativePtr, columnIndex, value);
+    public TableQuery lessThan(long[] columnIndex, long[] tablePtrs, float value) {
+        nativeLess(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThanOrEqual(long[] columnIndex, float value) {
-        nativeLessEqual(nativePtr, columnIndex, value);
+    public TableQuery lessThanOrEqual(long[] columnIndex, long[] tablePtrs, float value) {
+        nativeLessEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
@@ -188,38 +195,38 @@ public TableQuery between(long[] columnIndex, float value1, float value2) {
 
     // Queries for double values.
 
-    public TableQuery equalTo(long[] columnIndex, double value) {
-        nativeEqual(nativePtr, columnIndex, value);
+    public TableQuery equalTo(long[] columnIndex, long[] tablePtrs, double value) {
+        nativeEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery notEqualTo(long[] columnIndex, double value) {
-        nativeNotEqual(nativePtr, columnIndex, value);
+    public TableQuery notEqualTo(long[] columnIndex, long[] tablePtrs, double value) {
+        nativeNotEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThan(long[] columnIndex, double value) {
-        nativeGreater(nativePtr, columnIndex, value);
+    public TableQuery greaterThan(long[] columnIndex, long[] tablePtrs, double value) {
+        nativeGreater(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThanOrEqual(long[] columnIndex, double value) {
-        nativeGreaterEqual(nativePtr, columnIndex, value);
+    public TableQuery greaterThanOrEqual(long[] columnIndex, long[] tablePtrs, double value) {
+        nativeGreaterEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThan(long[] columnIndex, double value) {
-        nativeLess(nativePtr, columnIndex, value);
+    public TableQuery lessThan(long[] columnIndex, long[] tablePtrs, double value) {
+        nativeLess(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThanOrEqual(long[] columnIndex, double value) {
-        nativeLessEqual(nativePtr, columnIndex, value);
+    public TableQuery lessThanOrEqual(long[] columnIndex, long[] tablePtrs, double value) {
+        nativeLessEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
@@ -232,8 +239,8 @@ public TableQuery between(long[] columnIndex, double value1, double value2) {
 
     // Query for boolean values.
 
-    public TableQuery equalTo(long[] columnIndex, boolean value) {
-        nativeEqual(nativePtr, columnIndex, value);
+    public TableQuery equalTo(long[] columnIndex, long[] tablePtrs, boolean value) {
+        nativeEqual(nativePtr, columnIndex, tablePtrs, value);
         queryValidated = false;
         return this;
     }
@@ -242,52 +249,58 @@ public TableQuery equalTo(long[] columnIndex, boolean value) {
 
     private static final String DATE_NULL_ERROR_MESSAGE = "Date value in query criteria must not be null.";
 
-    public TableQuery equalTo(long[] columnIndex, Date value) {
+    public TableQuery equalTo(long[] columnIndex, long[] tablePtrs, @Nullable Date value) {
         if (value == null) {
-            nativeIsNull(nativePtr, columnIndex);
+            nativeIsNull(nativePtr, columnIndex, tablePtrs);
         } else {
-            nativeEqualTimestamp(nativePtr, columnIndex, value.getTime());
+            nativeEqualTimestamp(nativePtr, columnIndex, tablePtrs, value.getTime());
         }
         queryValidated = false;
         return this;
     }
 
-    public TableQuery notEqualTo(long[] columnIndex, Date value) {
+    public TableQuery notEqualTo(long[] columnIndex, long[] tablePtrs, Date value) {
+        //noinspection ConstantConditions
         if (value == null) { throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE); }
-        nativeNotEqualTimestamp(nativePtr, columnIndex, value.getTime());
+        nativeNotEqualTimestamp(nativePtr, columnIndex, tablePtrs, value.getTime());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThan(long[] columnIndex, Date value) {
+    public TableQuery greaterThan(long[] columnIndex, long[] tablePtrs, Date value) {
+        //noinspection ConstantConditions
         if (value == null) { throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE); }
-        nativeGreaterTimestamp(nativePtr, columnIndex, value.getTime());
+        nativeGreaterTimestamp(nativePtr, columnIndex, tablePtrs, value.getTime());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery greaterThanOrEqual(long[] columnIndex, Date value) {
+    public TableQuery greaterThanOrEqual(long[] columnIndex, long[] tablePtrs, Date value) {
+        //noinspection ConstantConditions
         if (value == null) { throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE); }
-        nativeGreaterEqualTimestamp(nativePtr, columnIndex, value.getTime());
+        nativeGreaterEqualTimestamp(nativePtr, columnIndex, tablePtrs, value.getTime());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThan(long[] columnIndex, Date value) {
+    public TableQuery lessThan(long[] columnIndex, long[] tablePtrs, Date value) {
+        //noinspection ConstantConditions
         if (value == null) { throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE); }
-        nativeLessTimestamp(nativePtr, columnIndex, value.getTime());
+        nativeLessTimestamp(nativePtr, columnIndex, tablePtrs, value.getTime());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery lessThanOrEqual(long[] columnIndex, Date value) {
+    public TableQuery lessThanOrEqual(long[] columnIndex, long[] tablePtrs, Date value) {
+        //noinspection ConstantConditions
         if (value == null) { throw new IllegalArgumentException(DATE_NULL_ERROR_MESSAGE); }
-        nativeLessEqualTimestamp(nativePtr, columnIndex, value.getTime());
+        nativeLessEqualTimestamp(nativePtr, columnIndex, tablePtrs, value.getTime());
         queryValidated = false;
         return this;
     }
 
     public TableQuery between(long[] columnIndex, Date value1, Date value2) {
+        //noinspection ConstantConditions
         if (value1 == null || value2 == null) {
             throw new IllegalArgumentException("Date values in query criteria must not be null."); // Different text
         }
@@ -298,104 +311,102 @@ public TableQuery between(long[] columnIndex, Date value1, Date value2) {
 
     // Queries for Binary values.
 
-    public TableQuery equalTo(long[] columnIndices, byte[] value) {
-        nativeEqual(nativePtr, columnIndices, value);
+    public TableQuery equalTo(long[] columnIndices, long[] tablePtrs, byte[] value) {
+        nativeEqual(nativePtr, columnIndices, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery notEqualTo(long[] columnIndices, byte[] value) {
-        nativeNotEqual(nativePtr, columnIndices, value);
+    public TableQuery notEqualTo(long[] columnIndices, long[] tablePtrs, byte[] value) {
+        nativeNotEqual(nativePtr, columnIndices, tablePtrs, value);
         queryValidated = false;
         return this;
     }
 
-    // Query for String values.
-
-    private static final String STRING_NULL_ERROR_MESSAGE = "String value in query criteria must not be null.";
-
     // Equals
-    public TableQuery equalTo(long[] columnIndexes, String value, Case caseSensitive) {
-        nativeEqual(nativePtr, columnIndexes, value, caseSensitive.getValue());
+    public TableQuery equalTo(long[] columnIndexes, long[] tablePtrs, @Nullable String value, Case caseSensitive) {
+        nativeEqual(nativePtr, columnIndexes, tablePtrs, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery equalTo(long[] columnIndexes, String value) {
-        nativeEqual(nativePtr, columnIndexes, value, true);
+    public TableQuery equalTo(long[] columnIndexes, long[] tablePtrs, String value) {
+        nativeEqual(nativePtr, columnIndexes, tablePtrs, value, true);
         queryValidated = false;
         return this;
     }
 
     // Not Equals
-    public TableQuery notEqualTo(long[] columnIndex, String value, Case caseSensitive) {
-        nativeNotEqual(nativePtr, columnIndex, value, caseSensitive.getValue());
+    public TableQuery notEqualTo(long[] columnIndex, long[] tablePtrs, @Nullable String value, Case caseSensitive) {
+        nativeNotEqual(nativePtr, columnIndex, tablePtrs, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery notEqualTo(long[] columnIndex, String value) {
-        nativeNotEqual(nativePtr, columnIndex, value, true);
+    public TableQuery notEqualTo(long[] columnIndex, long[] tablePtrs, @Nullable String value) {
+        nativeNotEqual(nativePtr, columnIndex, tablePtrs, value, true);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery beginsWith(long[] columnIndices, String value, Case caseSensitive) {
-        nativeBeginsWith(nativePtr, columnIndices, value, caseSensitive.getValue());
+    public TableQuery beginsWith(long[] columnIndices, long[] tablePtrs, String value, Case caseSensitive) {
+        nativeBeginsWith(nativePtr, columnIndices, tablePtrs, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery beginsWith(long[] columnIndices, String value) {
-        nativeBeginsWith(nativePtr, columnIndices, value, true);
+    public TableQuery beginsWith(long[] columnIndices, long[] tablePtrs, String value) {
+        nativeBeginsWith(nativePtr, columnIndices, tablePtrs, value, true);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery endsWith(long[] columnIndices, String value, Case caseSensitive) {
-        nativeEndsWith(nativePtr, columnIndices, value, caseSensitive.getValue());
+    public TableQuery endsWith(long[] columnIndices, long[] tablePtrs, String value, Case caseSensitive) {
+        nativeEndsWith(nativePtr, columnIndices, tablePtrs, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery endsWith(long[] columnIndices, String value) {
-        nativeEndsWith(nativePtr, columnIndices, value, true);
+    public TableQuery endsWith(long[] columnIndices, long[] tablePtrs, String value) {
+        nativeEndsWith(nativePtr, columnIndices, tablePtrs, value, true);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery like(long[] columnIndices, String value, Case caseSensitive) {
-        nativeLike(nativePtr, columnIndices, value, caseSensitive.getValue());
+    public TableQuery like(long[] columnIndices, long[] tablePtrs, String value, Case caseSensitive) {
+        nativeLike(nativePtr, columnIndices, tablePtrs, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery like(long[] columnIndices, String value) {
-        nativeLike(nativePtr, columnIndices, value, true);
+    public TableQuery like(long[] columnIndices, long[] tablePtrs, String value) {
+        nativeLike(nativePtr, columnIndices, tablePtrs, value, true);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery contains(long[] columnIndices, String value, Case caseSensitive) {
-        nativeContains(nativePtr, columnIndices, value, caseSensitive.getValue());
+    public TableQuery contains(long[] columnIndices, long[] tablePtrs, String value, Case caseSensitive) {
+        nativeContains(nativePtr, columnIndices, tablePtrs, value, caseSensitive.getValue());
         queryValidated = false;
         return this;
     }
 
-    public TableQuery contains(long[] columnIndices, String value) {
-        nativeContains(nativePtr, columnIndices, value, true);
+    public TableQuery contains(long[] columnIndices, long[] tablePtrs, String value) {
+        nativeContains(nativePtr, columnIndices, tablePtrs, value, true);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery isEmpty(long[] columnIndices) {
-        nativeIsEmpty(nativePtr, columnIndices);
+    public TableQuery isEmpty(long[] columnIndices, long[] tablePtrs) {
+        nativeIsEmpty(nativePtr, columnIndices, tablePtrs);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery isNotEmpty(long[] columnIndices) {
-        return not().isEmpty(columnIndices);
+    public TableQuery isNotEmpty(long[] columnIndices, long[] tablePtrs) {
+        nativeIsNotEmpty(nativePtr, columnIndices, tablePtrs);
+        queryValidated = false;
+        return this;
     }
 
     // Searching methods.
@@ -414,27 +425,6 @@ public long find() {
         return nativeFind(nativePtr, 0);
     }
 
-    /**
-     * Imports a row from a worker thread to the caller thread.
-     *
-     * @param handoverRowPtr pointer to the handover row object
-     * @param sharedRealm the SharedRealm on the caller thread.
-     * @return the row pointer on the caller thread.
-     */
-    public static long importHandoverRow(long handoverRowPtr, SharedRealm sharedRealm) {
-        return nativeImportHandoverRowIntoSharedGroup(handoverRowPtr, sharedRealm.getNativePtr());
-    }
-
-    /**
-     * Handovers the query, so it can be used by other SharedGroup (in different thread)
-     *
-     * @param sharedRealm the SharedGroup holding the query
-     * @return native pointer to the handover query
-     */
-    public long handoverQuery(SharedRealm sharedRealm) {
-        return nativeHandoverQuery(sharedRealm.getNativePtr(), nativePtr);
-    }
-
     //
     // Aggregation methods
     //
@@ -604,14 +594,14 @@ public Date minimumDate(long columnIndex) {
     }
 
     // isNull and isNotNull
-    public TableQuery isNull(long[] columnIndices) {
-        nativeIsNull(nativePtr, columnIndices);
+    public TableQuery isNull(long[] columnIndices, long[] tablePtrs) {
+        nativeIsNull(nativePtr, columnIndices, tablePtrs);
         queryValidated = false;
         return this;
     }
 
-    public TableQuery isNotNull(long[] columnIndices) {
-        nativeIsNotNull(nativePtr, columnIndices);
+    public TableQuery isNotNull(long[] columnIndices, long[] tablePtrs) {
+        nativeIsNotNull(nativePtr, columnIndices, tablePtrs);
         queryValidated = false;
         return this;
     }
@@ -635,17 +625,6 @@ public long remove() {
         return nativeRemove(nativePtr);
     }
 
-    /**
-     * Converts a list of sort orders to their native values.
-     */
-    public static boolean[] getNativeSortOrderValues(Sort[] sortOrders) {
-        boolean[] nativeValues = new boolean[sortOrders.length];
-        for (int i = 0; i < sortOrders.length; i++) {
-            nativeValues[i] = sortOrders[i].getValue();
-        }
-        return nativeValues;
-    }
-
     private void throwImmutable() {
         throw new IllegalStateException("Mutable method call during read transaction.");
     }
@@ -660,81 +639,83 @@ private void throwImmutable() {
 
     private native void nativeNot(long nativeQueryPtr);
 
-    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
-    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
-    private native void nativeGreater(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeGreater(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
-    private native void nativeGreaterEqual(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeGreaterEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
-    private native void nativeLess(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeLess(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
-    private native void nativeLessEqual(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeLessEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
     private native void nativeBetween(long nativeQueryPtr, long[] columnIndex, long value1, long value2);
 
-    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, float value);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, float value);
 
-    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, float value);
+    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, float value);
 
-    private native void nativeGreater(long nativeQueryPtr, long[] columnIndex, float value);
+    private native void nativeGreater(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, float value);
 
-    private native void nativeGreaterEqual(long nativeQueryPtr, long[] columnIndex, float value);
+    private native void nativeGreaterEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, float value);
 
-    private native void nativeLess(long nativeQueryPtr, long[] columnIndex, float value);
+    private native void nativeLess(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, float value);
 
-    private native void nativeLessEqual(long nativeQueryPtr, long[] columnIndex, float value);
+    private native void nativeLessEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, float value);
 
     private native void nativeBetween(long nativeQueryPtr, long[] columnIndex, float value1, float value2);
 
-    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, double value);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, double value);
 
-    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, double value);
+    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, double value);
 
-    private native void nativeGreater(long nativeQueryPtr, long[] columnIndex, double value);
+    private native void nativeGreater(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, double value);
 
-    private native void nativeGreaterEqual(long nativeQueryPtr, long[] columnIndex, double value);
+    private native void nativeGreaterEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, double value);
 
-    private native void nativeLess(long nativeQueryPtr, long[] columnIndex, double value);
+    private native void nativeLess(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, double value);
 
-    private native void nativeLessEqual(long nativeQueryPtr, long[] columnIndex, double value);
+    private native void nativeLessEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, double value);
 
     private native void nativeBetween(long nativeQueryPtr, long[] columnIndex, double value1, double value2);
 
-    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, boolean value);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, boolean value);
 
-    private native void nativeEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
-    private native void nativeNotEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeNotEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
-    private native void nativeGreaterTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeGreaterTimestamp(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
-    private native void nativeGreaterEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeGreaterEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
-    private native void nativeLessTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeLessTimestamp(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
-    private native void nativeLessEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long value);
+    private native void nativeLessEqualTimestamp(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, long value);
 
     private native void nativeBetweenTimestamp(long nativeQueryPtr, long[] columnIndex, long value1, long value2);
 
-    private native void nativeEqual(long nativeQueryPtr, long[] columnIndices, byte[] value);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndices, long[] tablePtrs, byte[] value);
+
+    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndices, long[] tablePtrs, byte[] value);
 
-    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndices, byte[] value);
+    private native void nativeEqual(long nativeQueryPtr, long[] columnIndexes, long[] tablePtrs, @Nullable String value, boolean caseSensitive);
 
-    private native void nativeEqual(long nativeQueryPtr, long[] columnIndexes, String value, boolean caseSensitive);
+    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, long[] tablePtrs, @Nullable String value, boolean caseSensitive);
 
-    private native void nativeNotEqual(long nativeQueryPtr, long[] columnIndex, String value, boolean caseSensitive);
+    private native void nativeBeginsWith(long nativeQueryPtr, long[] columnIndices, long[] tablePtrs, String value, boolean caseSensitive);
 
-    private native void nativeBeginsWith(long nativeQueryPtr, long[] columnIndices, String value, boolean caseSensitive);
+    private native void nativeEndsWith(long nativeQueryPtr, long[] columnIndices, long[] tablePtrs, String value, boolean caseSensitive);
 
-    private native void nativeEndsWith(long nativeQueryPtr, long[] columnIndices, String value, boolean caseSensitive);
+    private native void nativeLike(long nativeQueryPtr, long[] columnIndices, long[] tablePtrs, String value, boolean caseSensitive);
 
-    private native void nativeLike(long nativeQueryPtr, long[] columnIndices, String value, boolean caseSensitive);
+    private native void nativeContains(long nativeQueryPtr, long[] columnIndices, long[] tablePtrs, String value, boolean caseSensitive);
 
-    private native void nativeContains(long nativeQueryPtr, long[] columnIndices, String value, boolean caseSensitive);
+    private native void nativeIsEmpty(long nativePtr, long[] columnIndices, long[] tablePtrs);
 
-    private native void nativeIsEmpty(long nativePtr, long[] columnIndices);
+    private native void nativeIsNotEmpty(long nativePtr, long[] columnIndices, long[] tablePtrs);
 
     private native long nativeFind(long nativeQueryPtr, long fromTableRow);
 
@@ -768,17 +749,13 @@ private void throwImmutable() {
 
     private native Long nativeMinimumTimestamp(long nativeQueryPtr, long columnIndex, long start, long end, long limit);
 
-    private native void nativeIsNull(long nativePtr, long[] columnIndices);
+    private native void nativeIsNull(long nativePtr, long[] columnIndices, long[] tablePtrs);
 
-    private native void nativeIsNotNull(long nativePtr, long[] columnIndices);
+    private native void nativeIsNotNull(long nativePtr, long[] columnIndice, long[] tablePtr);
 
     private native long nativeCount(long nativeQueryPtr, long start, long end, long limit);
 
     private native long nativeRemove(long nativeQueryPtr);
 
-    private native long nativeHandoverQuery(long callerSharedRealmPtr, long nativeQueryPtr);
-
-    private static native long nativeImportHandoverRowIntoSharedGroup(long handoverRowPtr, long callerSharedRealmPtr);
-
     private static native long nativeGetFinalizerPtr();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableSchema.java b/realm/realm-library/src/main/java/io/realm/internal/TableSchema.java
deleted file mode 100644
index 47200f336d..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/TableSchema.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-
-import io.realm.RealmFieldType;
-
-
-public interface TableSchema {
-
-    long addColumn(RealmFieldType type, String name);
-
-    void removeColumn(long columnIndex);
-
-    void renameColumn(long columnIndex, String newName);
-
-    /*
-    // FIXME the column information classes should be here as well.
-    // There is currently no path based implementation in core, so we should consider adding them with Spec, or wait for a core implementation.
-
-    long getColumnCount();
-
-    String getColumnName(long columnIndex);
-
-    long getColumnIndex(String name);
-
-    ColumnType getColumnType(long columnIndex);
-    */
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
index 48f2e77233..c7e035b89c 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
@@ -18,6 +18,8 @@
 
 import java.util.Date;
 
+import javax.annotation.Nullable;
+
 import io.realm.RealmFieldType;
 
 
@@ -25,8 +27,8 @@
  * Wrapper around a Row in Realm Core.
  * <p>
  * IMPORTANT: All access to methods using this class are non-checking. Safety guarantees are given by the
- * annotation processor and {@link RealmProxyMediator#validateTable(Class, SharedRealm, boolean)}
- * which is called before the typed API can be used.
+ * annotation processor and Object Store's typed Realm schema validation which is called before the typed API can be
+ * used.
  * <p>
  * For low-level access to Row data where error checking is required, use {@link CheckedRow}.
  */
@@ -88,19 +90,6 @@ static UncheckedRow getByRowPointer(NativeContext context, Table table, long nat
         return new UncheckedRow(context, table, nativeRowPointer);
     }
 
-    /**
-     * Gets the row object associated to an index in a LinkView.
-     *
-     * @param context the Realm context.
-     * @param linkView the LinkView holding the row.
-     * @param index the index of the row.
-     * @return an instance of Row for the LinkView and index specified.
-     */
-    static UncheckedRow getByRowIndex(NativeContext context, LinkView linkView, long index) {
-        long nativeRowPointer = linkView.nativeGetRow(linkView.getNativePtr(), index);
-        return new UncheckedRow(context, linkView.getTargetTable(), nativeRowPointer);
-    }
-
     @Override
     public long getColumnCount() {
         return nativeGetColumnCount(nativePtr);
@@ -114,6 +103,7 @@ public String getColumnName(long columnIndex) {
 
     @Override
     public long getColumnIndex(String columnName) {
+        //noinspection ConstantConditions
         if (columnName == null) {
             throw new IllegalArgumentException("Column name can not be null.");
         }
@@ -183,9 +173,13 @@ public boolean isNullLink(long columnIndex) {
     }
 
     @Override
-    public LinkView getLinkList(long columnIndex) {
-        long nativeLinkViewPtr = nativeGetLinkView(nativePtr, columnIndex);
-        return new LinkView(context, parent, columnIndex, nativeLinkViewPtr);
+    public OsList getModelList(long columnIndex) {
+        return new OsList(this, columnIndex);
+    }
+
+    @Override
+    public OsList getValueList(long columnIndex, RealmFieldType fieldType) {
+        return new OsList(this, columnIndex);
     }
 
     // Setters
@@ -193,7 +187,6 @@ public LinkView getLinkList(long columnIndex) {
     @Override
     public void setLong(long columnIndex, long value) {
         parent.checkImmutable();
-        getTable().checkIntValueIsLegal(columnIndex, getIndex(), value);
         nativeSetLong(nativePtr, columnIndex, value);
     }
 
@@ -218,6 +211,7 @@ public void setDouble(long columnIndex, double value) {
     @Override
     public void setDate(long columnIndex, Date date) {
         parent.checkImmutable();
+        //noinspection ConstantConditions
         if (date == null) {
             throw new IllegalArgumentException("Null Date is not allowed.");
         }
@@ -232,19 +226,17 @@ public void setDate(long columnIndex, Date date) {
      * @param value the value to to a row
      */
     @Override
-    public void setString(long columnIndex, String value) {
+    public void setString(long columnIndex, @Nullable String value) {
         parent.checkImmutable();
         if (value == null) {
-            getTable().checkDuplicatedNullForPrimaryKeyValue(columnIndex, getIndex());
             nativeSetNull(nativePtr, columnIndex);
         } else {
-            getTable().checkStringValueIsLegal(columnIndex, getIndex(), value);
             nativeSetString(nativePtr, columnIndex, value);
         }
     }
 
     @Override
-    public void setBinaryByteArray(long columnIndex, byte[] data) {
+    public void setBinaryByteArray(long columnIndex, @Nullable byte[] data) {
         parent.checkImmutable();
         nativeSetByteArray(nativePtr, columnIndex, data);
     }
@@ -274,7 +266,6 @@ public boolean isNull(long columnIndex) {
     @Override
     public void setNull(long columnIndex) {
         parent.checkImmutable();
-        getTable().checkDuplicatedNullForPrimaryKeyValue(columnIndex, getIndex());
         nativeSetNull(nativePtr, columnIndex);
     }
 
@@ -330,8 +321,6 @@ public boolean hasColumn(String fieldName) {
 
     protected native byte[] nativeGetByteArray(long nativePtr, long columnIndex);
 
-    protected native long nativeGetLinkView(long nativePtr, long columnIndex);
-
     protected native void nativeSetLong(long nativeRowPtr, long columnIndex, long value);
 
     protected native void nativeSetBoolean(long nativeRowPtr, long columnIndex, boolean value);
@@ -346,7 +335,7 @@ public boolean hasColumn(String fieldName) {
 
     protected native void nativeSetString(long nativeRowPtr, long columnIndex, String value);
 
-    protected native void nativeSetByteArray(long nativePtr, long columnIndex, byte[] data);
+    protected native void nativeSetByteArray(long nativePtr, long columnIndex, @Nullable byte[] data);
 
     protected native void nativeSetLink(long nativeRowPtr, long columnIndex, long value);
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Util.java b/realm/realm-library/src/main/java/io/realm/internal/Util.java
index 2fc7778786..6dc7389628 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Util.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Util.java
@@ -23,8 +23,12 @@
 import java.io.StringWriter;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Locale;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import javax.annotation.Nullable;
+
+import io.realm.RealmConfiguration;
 import io.realm.RealmModel;
 import io.realm.RealmObject;
 import io.realm.log.RealmLog;
@@ -90,46 +94,49 @@ public static boolean isEmulator() {
                 || "google_sdk".equals(Build.PRODUCT);
     }
 
+    public static boolean isEmptyString(@Nullable String str) {
+        return str == null || str.length() == 0;
+    }
+
+    /**
+     * To delete Realm and related temporary files. This must be called in
+     * {@link OsObjectStore#callWithLock(RealmConfiguration, Runnable)}'s callback.
+     *
+     * @return {@code true} if the realm file is deleted. Temporary file deletion failure will not impact the return
+     * value, instead, a warning will be logged.
+     */
     public static boolean deleteRealm(String canonicalPath, File realmFolder, String realmFileName) {
-        boolean realmDeleted = true;
         final String management = ".management";
         File managementFolder = new File(realmFolder, realmFileName + management);
+        File realmFile = new File(canonicalPath);
 
         // Deletes files in management directory and the directory.
         // There is no subfolders in the management directory.
         File[] files = managementFolder.listFiles();
         if (files != null) {
             for (File file : files) {
-                realmDeleted = realmDeleted && file.delete();
+                boolean deleteResult = file.delete();
+                if (!deleteResult) {
+                    RealmLog.warn( String.format(Locale.ENGLISH,"Realm temporary file at %s cannot be deleted",
+                            file.getAbsolutePath()));
+                }
             }
         }
-        realmDeleted = realmDeleted && managementFolder.delete();
-
-        // Deletes specific files in root directory.
-        return realmDeleted && deletes(canonicalPath, realmFolder, realmFileName);
-    }
+        if (managementFolder.exists() && !managementFolder.delete()) {
+            RealmLog.warn( String.format(Locale.ENGLISH,"Realm temporary folder at %s cannot be deleted",
+                    managementFolder.getAbsolutePath()));
+        }
 
-    private static boolean deletes(String canonicalPath, File rootFolder, String realmFileName) {
-        final AtomicBoolean realmDeleted = new AtomicBoolean(true);
-
-        List<File> filesToDelete = Arrays.asList(
-                new File(rootFolder, realmFileName),
-                new File(rootFolder, realmFileName + ".lock"),
-                // Old core log file naming styles
-                new File(rootFolder, realmFileName + ".log_a"),
-                new File(rootFolder, realmFileName + ".log_b"),
-                new File(rootFolder, realmFileName + ".log"),
-                new File(canonicalPath));
-        for (File fileToDelete : filesToDelete) {
-            if (fileToDelete.exists()) {
-                boolean deleteResult = fileToDelete.delete();
-                if (!deleteResult) {
-                    realmDeleted.set(false);
-                    RealmLog.warn("Could not delete the file %s", fileToDelete);
-                }
+        boolean realmDeleted;
+        if (realmFile.exists()) {
+            realmDeleted = realmFile.delete();
+            if (!realmDeleted) {
+                RealmLog.warn(String.format(Locale.ENGLISH,"Realm file at %s cannot be deleted",
+                        realmFile.getAbsolutePath()));
             }
+        } else {
+            realmDeleted = true;
         }
-        return realmDeleted.get();
+        return realmDeleted;
     }
-
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/android/AndroidCapabilities.java b/realm/realm-library/src/main/java/io/realm/internal/android/AndroidCapabilities.java
index 78ea5a92dc..0a2d95496e 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/android/AndroidCapabilities.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/android/AndroidCapabilities.java
@@ -17,6 +17,9 @@
 
 import android.os.Looper;
 
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import javax.annotation.Nullable;
+
 import io.realm.internal.Capabilities;
 
 
@@ -25,22 +28,29 @@
  */
 public class AndroidCapabilities implements Capabilities {
 
-    private final boolean hasLooper;
+    // Public so it can be set from tests.
+    // If set, it will treat the current looper thread as the main thread.
+    // It is up to the caller to handle any race conditions around this. Right now only
+    // RunInLooperThread.java does this as part of setting up the test.
+    @SuppressFBWarnings("MS_SHOULD_BE_FINAL")
+    public static boolean EMULATE_MAIN_THREAD = false;
+
+    private final Looper looper;
     private final boolean isIntentServiceThread;
 
     public AndroidCapabilities() {
-        hasLooper = Looper.myLooper() != null;
+        looper = Looper.myLooper();
         isIntentServiceThread = isIntentServiceThread();
     }
 
     @Override
     public boolean canDeliverNotification() {
-        return hasLooper && !isIntentServiceThread;
+        return hasLooper() && !isIntentServiceThread;
     }
 
     @Override
-    public void checkCanDeliverNotification(String exceptionMessage) {
-        if (!hasLooper) {
+    public void checkCanDeliverNotification(@Nullable String exceptionMessage) {
+        if (!hasLooper()) {
             throw new IllegalStateException(exceptionMessage == null ? "" : (exceptionMessage + " ") +
                     "Realm cannot be automatically updated on a thread without a looper.");
         }
@@ -50,6 +60,15 @@ public void checkCanDeliverNotification(String exceptionMessage) {
         }
     }
 
+    @Override
+    public boolean isMainThread() {
+        return looper != null && (EMULATE_MAIN_THREAD || looper == Looper.getMainLooper());
+    }
+
+    private boolean hasLooper() {
+        return looper != null;
+    }
+
     private static boolean isIntentServiceThread() {
         // Tries to determine if a thread is an IntentService thread. No public API can detect this,
         // so use the thread name as a heuristic:
diff --git a/realm/realm-library/src/main/java/io/realm/internal/android/AndroidRealmNotifier.java b/realm/realm-library/src/main/java/io/realm/internal/android/AndroidRealmNotifier.java
index c17e2fbb65..5e4f2e067a 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/android/AndroidRealmNotifier.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/android/AndroidRealmNotifier.java
@@ -3,6 +3,8 @@
 import android.os.Handler;
 import android.os.Looper;
 
+import javax.annotation.Nullable;
+
 import io.realm.internal.Capabilities;
 import io.realm.internal.Keep;
 import io.realm.internal.RealmNotifier;
@@ -16,7 +18,7 @@
 public class AndroidRealmNotifier extends RealmNotifier {
     private Handler handler;
 
-    public AndroidRealmNotifier(SharedRealm sharedRealm, Capabilities capabilities) {
+    public AndroidRealmNotifier(@Nullable SharedRealm sharedRealm, Capabilities capabilities) {
         super(sharedRealm);
         if (capabilities.canDeliverNotification()) {
             handler = new Handler(Looper.myLooper());
diff --git a/realm/realm-library/src/main/java/io/realm/internal/android/ISO8601Utils.java b/realm/realm-library/src/main/java/io/realm/internal/android/ISO8601Utils.java
index 1a2c0fba4c..d430757548 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/android/ISO8601Utils.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/android/ISO8601Utils.java
@@ -158,6 +158,10 @@ public static Date parse(String date, ParsePosition pos) throws ParseException {
             } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {
                 String timezoneOffset = date.substring(offset);
                 offset += timezoneOffset.length();
+                // Convert 2-digit time zone designator to 4-digit designator
+                if (timezoneOffset.length() == 3) {
+                    timezoneOffset += "00";
+                }
                 // 18-Jun-2015, tatu: Minor simplification, skip offset of "+0000"/"+00:00"
                 if ("+0000".equals(timezoneOffset) || "+00:00".equals(timezoneOffset)) {
                     timezone = TIMEZONE_Z;
diff --git a/realm/realm-library/src/main/java/io/realm/internal/android/JsonUtils.java b/realm/realm-library/src/main/java/io/realm/internal/android/JsonUtils.java
index 0e46e4c077..455bb9cfaa 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/android/JsonUtils.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/android/JsonUtils.java
@@ -24,6 +24,8 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import javax.annotation.Nullable;
+
 import io.realm.exceptions.RealmException;
 
 
@@ -39,9 +41,10 @@
      * - "/Date(<long>[+-Zone])/"
      *
      * @param date the String input of date of the the supported types.
-     * @return the Date object or null if invalid input.
+     * @return the Date object or {@code null} if invalid input.
      * @throws NumberFormatException if date is not a proper long or has an illegal format.
      */
+    @Nullable
     public static Date stringToDate(String date) {
         if (date == null || date.length() == 0) { return null; }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/android/package-info.java b/realm/realm-library/src/main/java/io/realm/internal/android/package-info.java
new file mode 100644
index 0000000000..7a299ffd78
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/android/package-info.java
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+@javax.annotation.ParametersAreNonnullByDefault
+package io.realm.internal.android;
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java b/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
index 2d5ceee378..397b170b7f 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/async/RealmThreadPoolExecutor.java
@@ -19,7 +19,6 @@
 import java.io.File;
 import java.io.FileFilter;
 import java.util.concurrent.ArrayBlockingQueue;
-import java.util.concurrent.Callable;
 import java.util.concurrent.Future;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
@@ -113,36 +112,6 @@ private RealmThreadPoolExecutor(int corePoolSize, int maxPoolSize) {
         return future;
     }
 
-    /**
-     * Submits a runnable for updating a query.
-     *
-     * @param task the task to submit
-     * @return a future representing pending completion of the task
-     */
-    public Future<?> submitQueryUpdate(Runnable task) {
-        return super.submit(new BgPriorityRunnable(task));
-    }
-
-    /**
-     * Submits a runnable for executing a query.
-     *
-     * @param task the task to submit
-     * @return a future representing pending completion of the task
-     */
-    public <T> Future<T> submitQuery(Callable<T> task) {
-        return super.submit(new BgPriorityCallable<T>(task));
-    }
-
-    /**
-     * Submits a runnable for executing a network request.
-     *
-     * @param task the task to submit
-     * @return a future representing pending completion of the task
-     */
-    public Future<?> submitNetworkRequest(Runnable task) {
-        return super.submit(new BgPriorityRunnable(task));
-    }
-
     /**
      * Method invoked prior to executing the given Runnable to pause execution of the thread.
      *
diff --git a/realm/realm-library/src/main/java/io/realm/internal/fields/CachedFieldDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/fields/CachedFieldDescriptor.java
new file mode 100644
index 0000000000..0849a2e30b
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/fields/CachedFieldDescriptor.java
@@ -0,0 +1,94 @@
+package io.realm.internal.fields;
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+import java.util.Locale;
+import java.util.Set;
+
+import io.realm.RealmFieldType;
+import io.realm.internal.ColumnInfo;
+import io.realm.internal.NativeObject;
+
+
+/**
+ * Parses the passed field description (@see parseFieldDescription(String) and returns the information
+ * necessary for RealmQuery predicates to select the specified records.
+ * Because the values returned by this method will, immediately, be handed to native code, they are
+ * in coordinated arrays, not a List&lt;ColumnDeatils&gt;
+ * There are two kinds of records.  If return[1][i] is NativeObject.NULLPTR, return[0][i] contains
+ * the column index for the i-th element in the dotted field description path.
+ * If return[1][i] is *not* NativeObject.NULLPTR, it is a pointer to the source table for a backlink
+ * and return[0][i] is the column index of the source column in that table.
+ */
+class CachedFieldDescriptor extends FieldDescriptor {
+    private final SchemaProxy schema;
+    private final String className;
+
+    /**
+     * @param schema the associated Realm Schema
+     * @param className the starting Table: where(Table.class)
+     * @param fieldDescription fieldName or link path to a field name.
+     */
+    CachedFieldDescriptor(SchemaProxy schema, String className, String fieldDescription, Set<RealmFieldType> validInternalColumnTypes, Set<RealmFieldType> validFinalColumnTypes) {
+        super(fieldDescription, validInternalColumnTypes, validFinalColumnTypes);
+        this.className = className;
+        this.schema = schema;
+    }
+
+    @Override
+    protected void compileFieldDescription(List<String> fields) {
+        final int nFields = fields.size();
+        long[] columnIndices = new long[nFields];
+        long[] tableNativePointers = new long[nFields];
+
+        String currentClassName = className;
+        String currentColumnName = null;
+        RealmFieldType currentColumnType = null;
+        for (int i = 0; i < nFields; i++) {
+            currentColumnName = fields.get(i);
+            if ((currentColumnName == null) || (currentColumnName.length() <= 0)) {
+                throw new IllegalArgumentException(
+                        "Invalid query: Field descriptor contains an empty field.  A field description may not begin with or contain adjacent periods ('.').");
+            }
+
+            final ColumnInfo columnInfo = schema.getColumnInfo(currentClassName);
+            if (columnInfo == null) {
+                throw new IllegalArgumentException(
+                        String.format(Locale.US, "Invalid query: class '%s' not found in this schema.", currentClassName));
+            }
+
+            final ColumnInfo.ColumnDetails details = columnInfo.getColumnDetails(currentColumnName);
+            if (details == null) {
+                throw new IllegalArgumentException(
+                        String.format(Locale.US, "Invalid query: field '%s' not found in class '%s'.", currentColumnName, currentClassName));
+            }
+
+            currentColumnType = details.columnType;
+            // we don't check the type of the last field in the chain since it is done in the C++ code
+            if (i < nFields - 1) {
+                verifyInternalColumnType(currentClassName, currentColumnName, currentColumnType);
+                currentClassName = details.linkedClassName;
+            }
+            columnIndices[i] = details.columnIndex;
+            tableNativePointers[i] = (currentColumnType != RealmFieldType.LINKING_OBJECTS)
+                    ? NativeObject.NULLPTR
+                    : schema.getNativeTablePtr(details.linkedClassName);
+        }
+
+        setCompilationResults(currentClassName, currentColumnName, currentColumnType, columnIndices, tableNativePointers);
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/fields/DynamicFieldDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/fields/DynamicFieldDescriptor.java
new file mode 100644
index 0000000000..7328073b28
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/fields/DynamicFieldDescriptor.java
@@ -0,0 +1,81 @@
+package io.realm.internal.fields;
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+import java.util.Locale;
+import java.util.Set;
+
+import io.realm.RealmFieldType;
+import io.realm.internal.Table;
+
+
+/**
+ * A field descriptor that uses dynamic table lookup.
+ * Use when cache cannot be trusted...
+ */
+class DynamicFieldDescriptor extends FieldDescriptor {
+    private final Table table;
+
+    /**
+     * Build a dynamic field descriptor for the passed field description string.
+     *
+     * @param table the start table.
+     * @param fieldDescription the field description.
+     * @param validInternalColumnTypes valid types for the last field in the field description.
+     * @param validFinalColumnTypes valid types for the last field in the field description.
+     */
+    DynamicFieldDescriptor(Table table, String fieldDescription, Set<RealmFieldType> validInternalColumnTypes, Set<RealmFieldType> validFinalColumnTypes) {
+        super(fieldDescription, validInternalColumnTypes, validFinalColumnTypes);
+        this.table = table;
+    }
+
+    @Override
+    protected void compileFieldDescription(List<String> fields) {
+        final int nFields = fields.size();
+        long[] columnIndices = new long[nFields];
+
+        Table currentTable = table;
+        String currentClassName = null;
+        String currentColumnName = null;
+        RealmFieldType currentColumnType = null;
+        for (int i = 0; i < nFields; i++) {
+            currentColumnName = fields.get(i);
+            if ((currentColumnName == null) || (currentColumnName.length() <= 0)) {
+                throw new IllegalArgumentException(
+                        "Invalid query: Field descriptor contains an empty field.  A field description may not begin with or contain adjacent periods ('.').");
+            }
+
+            currentClassName = currentTable.getClassName();
+
+            final long columnIndex = currentTable.getColumnIndex(currentColumnName);
+            if (columnIndex < 0) {
+                throw new IllegalArgumentException(
+                        String.format(Locale.US, "Invalid query: field '%s' not found in table '%s'.", currentColumnName, currentClassName));
+            }
+
+            currentColumnType = currentTable.getColumnType(columnIndex);
+            if (i < nFields - 1) {
+                verifyInternalColumnType(currentClassName, currentColumnName, currentColumnType);
+                currentTable = currentTable.getLinkTarget(columnIndex);
+            }
+
+            columnIndices[i] = columnIndex;
+        }
+
+        setCompilationResults(currentClassName, currentColumnName, currentColumnType, columnIndices, new long[nFields]);
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/fields/FieldDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/fields/FieldDescriptor.java
new file mode 100644
index 0000000000..41f0e51aa1
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/fields/FieldDescriptor.java
@@ -0,0 +1,288 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal.fields;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Set;
+
+import io.realm.RealmFieldType;
+import io.realm.internal.ColumnInfo;
+import io.realm.internal.Table;
+
+
+/**
+ * Class describing a single field, possibly several links away, e.g.:
+ * <ul>
+ * </li> "someField"
+ * </li> "someRealmObjectField.someField"
+ * </li> "someRealmListField.someField"
+ * </li> "someLinkingObjectField.someField"
+ * </li> "someRealmObjectField.someRealmListField.someLinkingObjectField.someField"
+ * </ul>
+ */
+public abstract class FieldDescriptor {
+    public interface SchemaProxy {
+        boolean hasCache();
+
+        ColumnInfo getColumnInfo(String tableName);
+
+        long getNativeTablePtr(String targetTable);
+    }
+
+    public static final Set<RealmFieldType> ALL_LINK_FIELD_TYPES;
+
+    static {
+        Set<RealmFieldType> s = new HashSet<>(3);
+        s.add(RealmFieldType.OBJECT);
+        s.add(RealmFieldType.LIST);
+        s.add(RealmFieldType.LINKING_OBJECTS);
+        ALL_LINK_FIELD_TYPES = Collections.unmodifiableSet(s);
+    }
+
+    public static final Set<RealmFieldType> SIMPLE_LINK_FIELD_TYPES;
+
+    static {
+        Set<RealmFieldType> s = new HashSet<>(2);
+        s.add(RealmFieldType.OBJECT);
+        s.add(RealmFieldType.LIST);
+        SIMPLE_LINK_FIELD_TYPES = Collections.unmodifiableSet(s);
+    }
+
+    public static final Set<RealmFieldType> LIST_LINK_FIELD_TYPE;
+
+    static {
+        Set<RealmFieldType> s = new HashSet<>(1);
+        s.add(RealmFieldType.LIST);
+        LIST_LINK_FIELD_TYPE = Collections.unmodifiableSet(s);
+    }
+
+    public static final Set<RealmFieldType> OBJECT_LINK_FIELD_TYPE;
+
+    static {
+        Set<RealmFieldType> s = new HashSet<>(1);
+        s.add(RealmFieldType.OBJECT);
+        OBJECT_LINK_FIELD_TYPE = Collections.unmodifiableSet(s);
+    }
+
+    public static final Set<RealmFieldType> NO_LINK_FIELD_TYPE = Collections.emptySet();
+
+    /**
+     * Convenience method to allow var-arg specification of valid final column types
+     *
+     * @param schema Proxy to schema info
+     * @param table the start table
+     * @param fieldDescription dot-separated column names
+     * @param validFinalColumnTypes legal types for the last column
+     * @return the Field descriptor
+     */
+    public static FieldDescriptor createStandardFieldDescriptor(
+            SchemaProxy schema,
+            Table table,
+            String fieldDescription,
+            RealmFieldType... validFinalColumnTypes) {
+        return createFieldDescriptor(schema, table, fieldDescription, null, new HashSet<>(Arrays.asList(validFinalColumnTypes)));
+    }
+
+    /**
+     * Factory method for field descriptors.
+     *
+     * @param schema Proxy to schema info
+     * @param table the start table
+     * @param fieldDescription dot-separated column names
+     * @param validFinalColumnTypes legal types for the last column
+     * @return the Field descriptor
+     * <p>
+     * TODO:
+     * I suspect that choosing the parsing strategy based on whether there is a ref to a ColumnIndices
+     * around or not, is bad architecture.  Almost certainly, there should be a schema that has
+     * ColumnIndices and one that does not and the strategies below should belong to the first
+     * and second, respectively.  --gbm
+     */
+    public static FieldDescriptor createFieldDescriptor(
+            SchemaProxy schema,
+            Table table,
+            String fieldDescription,
+            Set<RealmFieldType> validInternalColumnTypes,
+            Set<RealmFieldType> validFinalColumnTypes) {
+        return ((schema == null) || !schema.hasCache())
+                ? new DynamicFieldDescriptor(table, fieldDescription, (null != validInternalColumnTypes) ? validInternalColumnTypes : SIMPLE_LINK_FIELD_TYPES, validFinalColumnTypes)
+                : new CachedFieldDescriptor(schema, table.getClassName(), fieldDescription, (null != validInternalColumnTypes) ? validInternalColumnTypes : ALL_LINK_FIELD_TYPES, validFinalColumnTypes);
+    }
+
+
+    private final List<String> fields;
+    private final Set<RealmFieldType> validInternalColumnTypes;
+    private final Set<RealmFieldType> validFinalColumnTypes;
+
+    private String finalColumnName;
+    private RealmFieldType finalColumnType;
+    private long[] columnIndices;
+    private long[] nativeTablePointers;
+
+    /**
+     * @param fieldDescription fieldName or link path to a field name.
+     * @param validInternalColumnTypes valid internal link types.
+     * @param validFinalColumnTypes valid field types for the last field in a linked field
+     */
+    protected FieldDescriptor(
+            String fieldDescription, Set<RealmFieldType>
+            validInternalColumnTypes,
+            Set<RealmFieldType> validFinalColumnTypes) {
+        this.fields = parseFieldDescription(fieldDescription);
+        int nFields = fields.size();
+        if (nFields <= 0) {
+            throw new IllegalArgumentException("Invalid query: Empty field descriptor");
+        }
+        this.validInternalColumnTypes = validInternalColumnTypes;
+        this.validFinalColumnTypes = validFinalColumnTypes;
+    }
+
+    /**
+     * The number of columnNames in the field description.
+     * The returned number is the size of the array returned by
+     * {@code getColumnIndices} and {@code getNativeTablePointers}
+     *
+     * @return the number of fields.
+     */
+    public final int length() {
+        return fields.size();
+    }
+
+    /**
+     * Return a java array of column indices for the columns named in the description.
+     * If the column at ret[i] is a LinkingObjects column, ret[i] (the column index)
+     * is the index for the <b>source</b> column in the <b>source</b> table.
+     *
+     * The return is an array because it will be, immediately, passed to native code
+     *
+     * @return an array of column indices.
+     */
+    public final long[] getColumnIndices() {
+        compileIfNecessary();
+        return Arrays.copyOf(columnIndices, columnIndices.length);
+    }
+
+    /**
+     * Return a java array of native table pointers.  For most columns the table will be identified by
+     * the type of the column: no further information is needed.  In that case, this array will contain
+     * NativeObject.NULLPTR.  If, however, a column is a LinkingObjects column the <b>source</b> table
+     * cannot be inferred, so the returned array contains the native pointer to it.
+     *
+     * The return is an array because it will be, immediately, passed to native code
+     *
+     * @return an array of native table pointers.
+     */
+    public final long[] getNativeTablePointers() {
+        compileIfNecessary();
+        return Arrays.copyOf(nativeTablePointers, nativeTablePointers.length);
+    }
+
+    /**
+     * Getter for the name of the final column in the descriptor.
+     *
+     * @return the name of the final column
+     */
+    public final String getFinalColumnName() {
+        compileIfNecessary();
+        return finalColumnName;
+    }
+
+    /**
+     * Getter for the type of the final column in the descriptor.
+     *
+     * @return the type of the final column
+     */
+    public final RealmFieldType getFinalColumnType() {
+        compileIfNecessary();
+        return finalColumnType;
+    }
+
+    /**
+     * Subclasses implement this method with a compilation strategy.
+     */
+    protected abstract void compileFieldDescription(List<String> fields);
+
+    /**
+     * Verify that the named link column, in the named table, of the specified type, is one of the legal internal column types.
+     *
+     * @param tableName Name of the table containing the column: used in error messages
+     * @param columnName Name of the column whose type is being tested: used in error messages
+     * @param columnType The type of the column: examined for validity.
+     */
+    protected final void verifyInternalColumnType(String tableName, String columnName, RealmFieldType columnType) {
+        verifyColumnType(tableName, columnName, columnType, validInternalColumnTypes);
+    }
+
+    /**
+     * Store the results of compiling the field description.
+     * Subclasses call this as the last action in
+     *
+     * @param finalClassName the name of the final table in the field description.
+     * @param finalColumnName the name of the final column in the field description.
+     * @param finalColumnType the type of the final column in the field description: MAY NOT BE {@code null}!
+     * @param columnIndices the array of columnIndices.
+     * @param nativeTablePointers the array of table pointers
+     */
+    protected final void setCompilationResults(
+            String finalClassName,
+            String finalColumnName,
+            RealmFieldType finalColumnType,
+            long[] columnIndices,
+            long[] nativeTablePointers) {
+        if ((validFinalColumnTypes != null) && (validFinalColumnTypes.size() > 0)) {
+            verifyColumnType(finalClassName, finalColumnName, finalColumnType, validFinalColumnTypes);
+        }
+        this.finalColumnName = finalColumnName;
+        this.finalColumnType = finalColumnType;
+        this.columnIndices = columnIndices;
+        this.nativeTablePointers = nativeTablePointers;
+    }
+
+    /**
+     * Parse the passed field description into its components.
+     * This must be standard across implementations and is, therefore, implemented in the base class.
+     *
+     * @param fieldDescription a field description.
+     * @return the parse tree: a list of column names
+     */
+    private List<String> parseFieldDescription(String fieldDescription) {
+        if (fieldDescription == null || fieldDescription.equals("")) {
+            throw new IllegalArgumentException("Invalid query: field name is empty");
+        }
+        if (fieldDescription.endsWith(".")) {
+            throw new IllegalArgumentException("Invalid query: field name must not end with a period ('.')");
+        }
+        return Arrays.asList(fieldDescription.split("\\."));
+    }
+
+    private void verifyColumnType(String className, String columnName, RealmFieldType columnType, Set<RealmFieldType> validTypes) {
+        if (!validTypes.contains(columnType)) {
+            throw new IllegalArgumentException(String.format(Locale.US,
+                    "Invalid query: field '%s' in class '%s' is of invalid type '%s'.",
+                    columnName, className, columnType.toString()));
+        }
+    }
+
+    private void compileIfNecessary() {
+        if (finalColumnType == null) {
+            compileFieldDescription(fields);
+        }
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
index 81218ae82e..08df441f79 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/CompositeMediator.java
@@ -31,13 +31,12 @@
 
 import io.realm.Realm;
 import io.realm.RealmModel;
-import io.realm.RealmObjectSchema;
-import io.realm.RealmSchema;
 import io.realm.internal.ColumnInfo;
+import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.OsSchemaInfo;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Row;
-import io.realm.internal.SharedRealm;
 import io.realm.internal.Util;
 
 
@@ -50,6 +49,7 @@
 
     public CompositeMediator(RealmProxyMediator... mediators) {
         final HashMap<Class<? extends RealmModel>, RealmProxyMediator> tempMediators = new HashMap<>();
+        //noinspection ConstantConditions
         if (mediators != null) {
             for (RealmProxyMediator mediator : mediators) {
                 for (Class<? extends RealmModel> realmClass : mediator.getModelClasses()) {
@@ -61,16 +61,19 @@ public CompositeMediator(RealmProxyMediator... mediators) {
     }
 
     @Override
-    public RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema schema) {
-        RealmProxyMediator mediator = getMediator(clazz);
-        return mediator.createRealmObjectSchema(clazz, schema);
+    public Map<Class<? extends RealmModel>, OsObjectSchemaInfo> getExpectedObjectSchemaInfoMap() {
+        Map<Class<? extends RealmModel>, OsObjectSchemaInfo> infoMap =
+                new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>();
+        for (RealmProxyMediator mediator : mediators.values()) {
+            infoMap.putAll(mediator.getExpectedObjectSchemaInfoMap());
+        }
+        return infoMap;
     }
 
     @Override
-    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm,
-            boolean allowExtraColumns) {
+    public ColumnInfo createColumnInfo(Class<? extends RealmModel> clazz, OsSchemaInfo osSchemaInfo) {
         RealmProxyMediator mediator = getMediator(clazz);
-        return mediator.validateTable(clazz, sharedRealm, allowExtraColumns);
+        return mediator.createColumnInfo(clazz, osSchemaInfo);
     }
 
     @Override
@@ -80,9 +83,9 @@ public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm s
     }
 
     @Override
-    public String getTableName(Class<? extends RealmModel> clazz) {
+    protected String getSimpleClassNameImpl(Class<? extends RealmModel> clazz) {
         RealmProxyMediator mediator = getMediator(clazz);
-        return mediator.getTableName(clazz);
+        return mediator.getSimpleClassName(clazz);
     }
 
     @Override
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
index 3f4f6fa471..ef9fb5654c 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/FilterableMediator.java
@@ -24,6 +24,7 @@
 import java.io.IOException;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
@@ -31,13 +32,12 @@
 
 import io.realm.Realm;
 import io.realm.RealmModel;
-import io.realm.RealmObjectSchema;
-import io.realm.RealmSchema;
 import io.realm.internal.ColumnInfo;
+import io.realm.internal.OsObjectSchemaInfo;
+import io.realm.internal.OsSchemaInfo;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.Row;
-import io.realm.internal.SharedRealm;
 import io.realm.internal.Util;
 
 
@@ -60,6 +60,7 @@ public FilterableMediator(RealmProxyMediator originalMediator, Collection<Class<
         this.originalMediator = originalMediator;
 
         Set<Class<? extends RealmModel>> tempAllowedClasses = new HashSet<>();
+        //noinspection ConstantConditions
         if (originalMediator != null) {
             Set<Class<? extends RealmModel>> originalClasses = originalMediator.getModelClasses();
             for (Class<? extends RealmModel> clazz : allowedClasses) {
@@ -71,21 +72,23 @@ public FilterableMediator(RealmProxyMediator originalMediator, Collection<Class<
         this.allowedClasses = Collections.unmodifiableSet(tempAllowedClasses);
     }
 
-    public RealmProxyMediator getOriginalMediator() {
-        return originalMediator;
-    }
-
     @Override
-    public RealmObjectSchema createRealmObjectSchema(Class<? extends RealmModel> clazz, RealmSchema schema) {
-        checkSchemaHasClass(clazz);
-        return originalMediator.createRealmObjectSchema(clazz, schema);
+    public Map<Class<? extends RealmModel>, OsObjectSchemaInfo> getExpectedObjectSchemaInfoMap() {
+        Map<Class<? extends RealmModel>, OsObjectSchemaInfo> infoMap =
+                new HashMap<Class<? extends RealmModel>, OsObjectSchemaInfo>();
+        for (Map.Entry<Class<? extends RealmModel>, OsObjectSchemaInfo> entry :
+                originalMediator.getExpectedObjectSchemaInfoMap().entrySet()) {
+            if (allowedClasses.contains(entry.getKey())) {
+                infoMap.put(entry.getKey(), entry.getValue());
+            }
+        }
+        return infoMap;
     }
 
     @Override
-    public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm sharedRealm,
-            boolean allowExtraColumns) {
+    public ColumnInfo createColumnInfo(Class<? extends RealmModel> clazz, OsSchemaInfo osSchemaInfo) {
         checkSchemaHasClass(clazz);
-        return originalMediator.validateTable(clazz, sharedRealm, allowExtraColumns);
+        return originalMediator.createColumnInfo(clazz, osSchemaInfo);
     }
 
     @Override
@@ -95,9 +98,9 @@ public ColumnInfo validateTable(Class<? extends RealmModel> clazz, SharedRealm s
     }
 
     @Override
-    public String getTableName(Class<? extends RealmModel> clazz) {
+    protected String getSimpleClassNameImpl(Class<? extends RealmModel> clazz) {
         checkSchemaHasClass(clazz);
-        return originalMediator.getTableName(clazz);
+        return originalMediator.getSimpleClassName(clazz);
     }
 
     @Override
diff --git a/realm/realm-library/src/main/java/io/realm/internal/modules/package-info.java b/realm/realm-library/src/main/java/io/realm/internal/modules/package-info.java
new file mode 100644
index 0000000000..45bff9867d
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/modules/package-info.java
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+@javax.annotation.ParametersAreNonnullByDefault
+package io.realm.internal.modules;
diff --git a/realm/realm-library/src/main/java/io/realm/internal/package-info.java b/realm/realm-library/src/main/java/io/realm/internal/package-info.java
new file mode 100644
index 0000000000..1a99e92ef6
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/package-info.java
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+@javax.annotation.ParametersAreNonnullByDefault
+package io.realm.internal;
diff --git a/realm/realm-library/src/main/java/io/realm/internal/util/Pair.java b/realm/realm-library/src/main/java/io/realm/internal/util/Pair.java
new file mode 100644
index 0000000000..b57b6c0ae3
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/util/Pair.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.util;
+
+/**
+ * Container to ease passing around a tuple of two objects. This object provides a sensible
+ * implementation of equals(), returning true if equals() is true on each of the contained
+ * objects.
+ */
+public class Pair<F, S> {
+    /**
+     * Implementation notes:
+     *
+     * Copy from the Android framework to avoid the dependency on Android classes + slight adjustment
+     * to support older versions of Android.
+     *
+     * Original source: https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/util/Pair.java
+     */
+    public F first;
+    public S second;
+
+    /**
+     * Constructor for a Pair.
+     *
+     * @param first the first object in the Pair.
+     * @param second the second object in the pair.
+     */
+    public Pair(F first, S second) {
+        this.first = first;
+        this.second = second;
+    }
+
+    /**
+     * Checks the two objects for equality by delegating to their respective
+     * {@link Object#equals(Object)} methods.
+     *
+     * @param o the {@link Pair} to which this one is to be checked for equality.
+     * @return true if the underlying objects of the Pair are both considered
+     *         equal.
+     */
+    @Override
+    public boolean equals(Object o) {
+        if (!(o instanceof Pair)) {
+            return false;
+        }
+        Pair<?, ?> p = (Pair<?, ?>) o;
+        return equals(p.first, first) && (equals(p.second, second));
+    }
+
+    private boolean equals(Object a, Object b) {
+        return (a == b) || (a != null && a.equals(b));
+    }
+
+    /**
+     * Compute a hash code using the hash codes of the underlying objects.
+     *
+     * @return a hashcode of the Pair.
+     */
+    @Override
+    public int hashCode() {
+        return (first == null ? 0 : first.hashCode()) ^ (second == null ? 0 : second.hashCode());
+    }
+
+    @Override
+    public String toString() {
+        return "Pair{" + String.valueOf(first) + " " + String.valueOf(second) + "}";
+    }
+
+    /**
+     * Convenience method for creating an appropriately typed pair.
+     *
+     * @param a the first object in the Pair.
+     * @param b the second object in the pair.
+     * @return a Pair that is templatized with the types of a and b.
+     */
+    public static <A, B> Pair <A, B> create(A a, B b) {
+        return new Pair<>(a, b);
+    }
+}
\ No newline at end of file
diff --git a/realm/realm-library/src/main/java/io/realm/log/RealmLog.java b/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
index e24211efca..62a09e760f 100644
--- a/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
+++ b/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
@@ -18,6 +18,10 @@
 
 import android.util.Log;
 
+import java.util.Locale;
+
+import javax.annotation.Nullable;
+
 
 /**
  * Global logger used by all Realm components.
@@ -34,6 +38,7 @@
      * @param logger the reference to a {@link RealmLogger} implementation.
      */
     public static void add(RealmLogger logger) {
+        //noinspection ConstantConditions
         if (logger == null) {
             throw new IllegalArgumentException("A non-null logger has to be provided");
         }
@@ -46,6 +51,9 @@ public static void add(RealmLogger logger) {
      * @param level see {@link LogLevel}.
      */
     public static void setLevel(int level) {
+        if (level < LogLevel.ALL || level > LogLevel.OFF) {
+            throw new IllegalArgumentException("Invalid log level: " + level);
+        }
         nativeSetLogLevel(level);
     }
 
@@ -64,6 +72,7 @@ public static int getLevel() {
      * @return {@code true} if the logger was removed, {@code false} otherwise.
      */
     public static boolean remove(RealmLogger logger) {
+        //noinspection ConstantConditions
         if (logger == null) {
             throw new IllegalArgumentException("A non-null logger has to be provided");
         }
@@ -113,7 +122,7 @@ public static void trace(String message, Object... args) {
      * @param message optional message.
      * @param args optional args used to format the message using {@link String#format(String, Object...)}.
      */
-    public static void trace(Throwable throwable, String message, Object... args) {
+    public static void trace(@Nullable Throwable throwable, @Nullable String message, Object... args) {
         log(LogLevel.TRACE, throwable, message, args);
     }
 
@@ -122,7 +131,7 @@ public static void trace(Throwable throwable, String message, Object... args) {
      *
      * @param throwable exception to log.
      */
-    public static void debug(Throwable throwable) {
+    public static void debug(@Nullable Throwable throwable) {
         debug(throwable, null);
     }
 
@@ -143,7 +152,7 @@ public static void debug(String message, Object... args) {
      * @param message optional message.
      * @param args optional args used to format the message using {@link String#format(String, Object...)}.
      */
-    public static void debug(Throwable throwable, String message, Object... args) {
+    public static void debug(@Nullable Throwable throwable, @Nullable String message, Object... args) {
         log(LogLevel.DEBUG, throwable, message, args);
     }
 
@@ -173,7 +182,7 @@ public static void info(String message, Object... args) {
      * @param message optional message.
      * @param args optional args used to format the message using {@link String#format(String, Object...)}.
      */
-    public static void info(Throwable throwable, String message, Object... args) {
+    public static void info(@Nullable Throwable throwable, @Nullable String message, Object... args) {
         log(LogLevel.INFO, throwable, message, args);
     }
 
@@ -203,7 +212,7 @@ public static void warn(String message, Object... args) {
      * @param message optional message.
      * @param args optional args used to format the message using {@link String#format(String, Object...)}.
      */
-    public static void warn(Throwable throwable, String message, Object... args) {
+    public static void warn(@Nullable Throwable throwable, @Nullable String message, Object... args) {
         log(LogLevel.WARN, throwable, message, args);
     }
 
@@ -233,7 +242,7 @@ public static void error(String message, Object... args) {
      * @param message optional message.
      * @param args optional args used to format the message using {@link String#format(String, Object...)}.
      */
-    public static void error(Throwable throwable, String message, Object... args) {
+    public static void error(@Nullable Throwable throwable, @Nullable String message, Object... args) {
         log(LogLevel.ERROR, throwable, message, args);
     }
 
@@ -263,15 +272,19 @@ public static void fatal(String message, Object... args) {
      * @param message optional message.
      * @param args optional args used to format the message using {@link String#format(String, Object...)}.
      */
-    public static void fatal(Throwable throwable, String message, Object... args) {
+    public static void fatal(@Nullable Throwable throwable, @Nullable String message, Object... args) {
         log(LogLevel.FATAL, throwable, message, args);
     }
 
     // Formats the message, parses the stacktrace of given throwable and passes them to nativeLog.
-    private static void log(int level, Throwable throwable, String message, Object... args) {
+    private static void log(int level, @Nullable Throwable throwable, @Nullable String message, @Nullable Object... args) {
+        if (level < getLevel()) {
+            return;
+        }
+
         StringBuilder stringBuilder = new StringBuilder();
-        if (args != null && args.length > 0) {
-            message = String.format(message, args);
+        if (message != null && args != null && args.length > 0) {
+            message = String.format(Locale.US, message, args);
         }
         if (throwable != null) {
             stringBuilder.append(Log.getStackTraceString(throwable));
@@ -293,14 +306,14 @@ private static void log(int level, Throwable throwable, String message, Object..
 
     private static native void nativeRegisterDefaultLogger();
 
-    private static native void nativeLog(int level, String tag, Throwable throwable, String message);
+    private static native void nativeLog(int level, String tag, @Nullable Throwable throwable, @Nullable String message);
 
     private static native void nativeSetLogLevel(int level);
 
     private static native int nativeGetLogLevel();
 
     // Methods below are used for testing core logger bridge only.
-    static native long nativeCreateCoreLoggerBridge(String tag);
+    static native long nativeCreateCoreLoggerBridge(@SuppressWarnings("SameParameterValue") String tag);
 
     static native void nativeCloseCoreLoggerBridge(long nativePtr);
 
diff --git a/realm/realm-library/src/main/java/io/realm/log/RealmLogger.java b/realm/realm-library/src/main/java/io/realm/log/RealmLogger.java
index 2fbd6d7a97..8cc0f60785 100644
--- a/realm/realm-library/src/main/java/io/realm/log/RealmLogger.java
+++ b/realm/realm-library/src/main/java/io/realm/log/RealmLogger.java
@@ -16,6 +16,8 @@
 
 package io.realm.log;
 
+import javax.annotation.Nullable;
+
 import io.realm.internal.Keep;
 
 
@@ -35,5 +37,5 @@
      * @param throwable optional exception to log.
      * @param message optional additional message.
      */
-    void log(int level, String tag, Throwable throwable, String message);
+    void log(int level, String tag, @Nullable Throwable throwable, @Nullable String message);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/log/package-info.java b/realm/realm-library/src/main/java/io/realm/log/package-info.java
new file mode 100644
index 0000000000..58d15bfbea
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/log/package-info.java
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+@javax.annotation.ParametersAreNonnullByDefault
+package io.realm.log;
diff --git a/realm/realm-library/src/main/java/io/realm/package-info.java b/realm/realm-library/src/main/java/io/realm/package-info.java
new file mode 100644
index 0000000000..bc9e4d2bbb
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/package-info.java
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+@javax.annotation.ParametersAreNonnullByDefault
+package io.realm;
diff --git a/realm/realm-library/src/main/java/io/realm/rx/CollectionChange.java b/realm/realm-library/src/main/java/io/realm/rx/CollectionChange.java
new file mode 100644
index 0000000000..13e25f59af
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/rx/CollectionChange.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.rx;
+
+import javax.annotation.Nullable;
+
+import io.realm.OrderedCollectionChangeSet;
+import io.realm.OrderedRealmCollection;
+import io.realm.RealmList;
+import io.realm.RealmResults;
+
+/**
+ * Container wrapping the result of a {@link io.realm.OrderedRealmCollectionChangeListener} being triggered.
+ * <p>
+ * This is used by {@link RealmResults#asChangesetObservable()}} and {@link RealmList#asChangesetObservable()} as
+ * RxJava is only capable of emitting one item, not multiple.
+ */
+public class CollectionChange<E extends OrderedRealmCollection> {
+
+    private final E collection;
+    private final OrderedCollectionChangeSet changeset;
+
+    /**
+     * Constructor for a CollectionChange.
+     *
+     * @param collection the collection that changed.
+     * @param changeset the changeset describing the change.
+     */
+    public CollectionChange(E collection, @Nullable OrderedCollectionChangeSet changeset) {
+        this.collection = collection;
+        this.changeset = changeset;
+    }
+
+    /**
+     * Returns the collection that was updated.
+     *
+     * @return collection that was updated.
+     */
+    public E getCollection() {
+        return collection;
+    }
+
+    /**
+     * Returns the changeset describing the update.
+     * <p>
+     * This will be {@code null} the first time the stream emits the collection as well as when a asynchronous query
+     * is loaded for the first time.
+     * <p>
+     * <pre>
+     * {@code
+     * // Example
+     * realm.where(Person.class).findAllAsync().asChangesetObservable()
+     *   .subscribe(new Consumer<CollectionChange>() {
+     *    \@Override
+     *     public void accept(CollectionChange item) throws Exception {
+     *       item.getChangeset(); // Will return null the first two times
+     *   }
+     * });
+     * }
+     * </pre>
+     *
+     * @return the changeset describing how the collection was updated.
+     */
+    @Nullable
+    public OrderedCollectionChangeSet getChangeset() {
+        return changeset;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        CollectionChange<?> that = (CollectionChange<?>) o;
+
+        if (!collection.equals(that.collection)) return false;
+        return changeset != null ? changeset.equals(that.changeset) : that.changeset == null;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = collection.hashCode();
+        result = 31 * result + (changeset != null ? changeset.hashCode() : 0);
+        return result;
+    }
+}
\ No newline at end of file
diff --git a/realm/realm-library/src/main/java/io/realm/rx/ObjectChange.java b/realm/realm-library/src/main/java/io/realm/rx/ObjectChange.java
new file mode 100644
index 0000000000..b65ad15599
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/rx/ObjectChange.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package io.realm.rx;
+
+import javax.annotation.Nullable;
+
+import io.realm.ObjectChangeSet;
+import io.realm.RealmModel;
+import io.realm.RealmObject;
+
+/**
+ * Container wrapping the result of a {@link io.realm.RealmObjectChangeListener} being triggered.
+ * <p>
+ * This is used by {@link RealmObject#asChangesetObservable()} and {@link RealmObject#asChangesetObservable(RealmModel)}
+ * as RxJava is only capable of emitting one item, not multiple.
+ */
+public class ObjectChange<E extends RealmModel> {
+
+    private final E object;
+    private final ObjectChangeSet changeset;
+
+    /**
+     * Constructor for a ObjectChange.
+     *
+     * @param object the object that was updated.
+     * @param changeset the changeset describing the update.
+     */
+    public ObjectChange(E object, @Nullable ObjectChangeSet changeset) {
+        this.object = object;
+        this.changeset = changeset;
+    }
+
+    public E getObject() {
+        return object;
+    }
+
+    /**
+     * Returns the changeset describing the update.
+     * <p>
+     * This will be {@code null} the first time the stream emits the object as well as when a asynchronous query
+     * is loaded for the first time.
+     * <p>
+     * <pre>
+     * {@code
+     * // Example
+     * realm.where(Person.class).findFirstAsync().asChangesetObservable()
+     *   .subscribe(new Consumer<ObjectChange>() {
+     *    \@Override
+     *     public void accept(ObjectChange item) throws Exception {
+     *       item.getChangeset(); // Will return null the first two times
+     *   }
+     * });
+     * }
+     * </pre>
+     *
+     * @return the changeset describing how the object was updated.
+     */
+    @Nullable
+    public ObjectChangeSet getChangeset() {
+        return changeset;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        ObjectChange<?> that = (ObjectChange<?>) o;
+
+        if (!object.equals(that.object)) return false;
+        return changeset != null ? changeset.equals(that.changeset) : that.changeset == null;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = object.hashCode();
+        result = 31 * result + (changeset != null ? changeset.hashCode() : 0);
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "ObjectChange{" +
+                "object=" + object +
+                ", changeset=" + changeset +
+                '}';
+    }
+}
\ No newline at end of file
diff --git a/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
index 72fd5ac68e..8b72dd0c12 100644
--- a/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
+++ b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
@@ -19,341 +19,576 @@
 import java.util.IdentityHashMap;
 import java.util.Map;
 
+import io.reactivex.BackpressureStrategy;
+import io.reactivex.Flowable;
+import io.reactivex.FlowableEmitter;
+import io.reactivex.FlowableOnSubscribe;
+import io.reactivex.Observable;
+import io.reactivex.ObservableEmitter;
+import io.reactivex.ObservableOnSubscribe;
+import io.reactivex.Single;
+import io.reactivex.disposables.Disposables;
 import io.realm.DynamicRealm;
 import io.realm.DynamicRealmObject;
+import io.realm.ObjectChangeSet;
+import io.realm.OrderedCollectionChangeSet;
+import io.realm.OrderedRealmCollectionChangeListener;
 import io.realm.Realm;
 import io.realm.RealmChangeListener;
 import io.realm.RealmConfiguration;
 import io.realm.RealmList;
 import io.realm.RealmModel;
 import io.realm.RealmObject;
+import io.realm.RealmObjectChangeListener;
 import io.realm.RealmQuery;
 import io.realm.RealmResults;
-import rx.Observable;
-import rx.Subscriber;
-import rx.functions.Action0;
-import rx.subscriptions.Subscriptions;
-
 
 /**
- * Factory class for creating Observables for RxJava (&lt;=1.1.*).
+ * Factory class for creating Observables for RxJava (&lt;=2.0.*).
  *
- * @see Realm#asObservable()
- * @see RealmObject#asObservable()
- * @see RealmResults#asObservable()
- * @see DynamicRealm#asObservable()
- * @see DynamicRealmObject#asObservable()
+ * @see Realm#asFlowable() ()
+ * @see RealmObject#asFlowable()
+ * @see RealmResults#asFlowable()
+ * @see DynamicRealm#asFlowable()
+ * @see DynamicRealmObject#asFlowable()
  */
 public class RealmObservableFactory implements RxObservableFactory {
 
     // Maps for storing strong references to Realm classes while they are subscribed to.
     // This is needed if users create Observables without manually maintaining a reference to them.
     // In that case RealmObjects/RealmResults/RealmLists might be GC'ed too early.
-    ThreadLocal<StrongReferenceCounter<RealmResults>> resultsRefs = new ThreadLocal<StrongReferenceCounter<RealmResults>>() {
+    private ThreadLocal<StrongReferenceCounter<RealmResults>> resultsRefs = new ThreadLocal<StrongReferenceCounter<RealmResults>>() {
         @Override
         protected StrongReferenceCounter<RealmResults> initialValue() {
-            return new StrongReferenceCounter<RealmResults>();
+            return new StrongReferenceCounter<>();
         }
     };
-    ThreadLocal<StrongReferenceCounter<RealmList>> listRefs = new ThreadLocal<StrongReferenceCounter<RealmList>>() {
+    private ThreadLocal<StrongReferenceCounter<RealmList>> listRefs = new ThreadLocal<StrongReferenceCounter<RealmList>>() {
         @Override
         protected StrongReferenceCounter<RealmList> initialValue() {
-            return new StrongReferenceCounter<RealmList>();
+            return new StrongReferenceCounter<>();
         }
     };
-    ThreadLocal<StrongReferenceCounter<RealmModel>> objectRefs = new ThreadLocal<StrongReferenceCounter<RealmModel>>() {
+    private ThreadLocal<StrongReferenceCounter<RealmModel>> objectRefs = new ThreadLocal<StrongReferenceCounter<RealmModel>>() {
         @Override
         protected StrongReferenceCounter<RealmModel> initialValue() {
-            return new StrongReferenceCounter<RealmModel>();
+            return new StrongReferenceCounter<>();
         }
     };
 
+    private static final BackpressureStrategy BACK_PRESSURE_STRATEGY = BackpressureStrategy.LATEST;
+
     @Override
-    public Observable<Realm> from(Realm realm) {
+    public Flowable<Realm> from(Realm realm) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
-        return Observable.create(new Observable.OnSubscribe<Realm>() {
+        return Flowable.create(new FlowableOnSubscribe <Realm>() {
             @Override
-            public void call(final Subscriber<? super Realm> subscriber) {
-                // Gets instance to make sure that the Realm is open for as long as the
-                // Observable is subscribed to it.
+            public void subscribe(final FlowableEmitter<Realm> emitter) throws Exception {
+                // Instance is cached by Realm, so no need to keep strong reference
                 final Realm observableRealm = Realm.getInstance(realmConfig);
                 final RealmChangeListener<Realm> listener = new RealmChangeListener<Realm>() {
                     @Override
                     public void onChange(Realm realm) {
-                        if (!subscriber.isUnsubscribed()) {
-                            subscriber.onNext(observableRealm);
+                        if (!emitter.isCancelled()) {
+                            emitter.onNext(realm);
                         }
                     }
                 };
                 observableRealm.addChangeListener(listener);
-                subscriber.add(Subscriptions.create(new Action0() {
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
                     @Override
-                    public void call() {
+                    public void run() {
                         observableRealm.removeChangeListener(listener);
                         observableRealm.close();
                     }
                 }));
-                subscriber.onNext(observableRealm);
+
+                // Emit current value immediately
+                emitter.onNext(observableRealm);
             }
-        });
+        }, BACK_PRESSURE_STRATEGY);
     }
 
     @Override
-    public Observable<DynamicRealm> from(DynamicRealm realm) {
+    public Flowable<DynamicRealm> from(DynamicRealm realm) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
-        return Observable.create(new Observable.OnSubscribe<DynamicRealm>() {
+        return Flowable.create(new FlowableOnSubscribe<DynamicRealm>() {
             @Override
-            public void call(final Subscriber<? super DynamicRealm> subscriber) {
-                // Gets instance to make sure that the Realm is open for as long as the
-                // Observable is subscribed to it.
+            public void subscribe(final FlowableEmitter<DynamicRealm> emitter) throws Exception {
+                // Instance is cached by Realm, so no need to keep strong reference
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
                 final RealmChangeListener<DynamicRealm> listener = new RealmChangeListener<DynamicRealm>() {
                     @Override
                     public void onChange(DynamicRealm realm) {
-                        if (!subscriber.isUnsubscribed()) {
-                            subscriber.onNext(observableRealm);
+                        if (!emitter.isCancelled()) {
+                            emitter.onNext(realm);
                         }
                     }
                 };
                 observableRealm.addChangeListener(listener);
-                subscriber.add(Subscriptions.create(new Action0() {
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
                     @Override
-                    public void call() {
+                    public void run() {
                         observableRealm.removeChangeListener(listener);
                         observableRealm.close();
                     }
                 }));
 
-                // Immediately calls onNext with the current value, as due to Realm's auto-update, it will be the latest
-                // value.
-                subscriber.onNext(observableRealm);
+                // Emit current value immediately
+                emitter.onNext(observableRealm);
             }
-        });
+        }, BACK_PRESSURE_STRATEGY);
     }
 
     @Override
-    public <E extends RealmModel> Observable<RealmResults<E>> from(final Realm realm, final RealmResults<E> results) {
+    public <E> Flowable<RealmResults<E>> from(final Realm realm, final RealmResults<E> results) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
-        return Observable.create(new Observable.OnSubscribe<RealmResults<E>>() {
+        return Flowable.create(new FlowableOnSubscribe<RealmResults<E>>() {
             @Override
-            public void call(final Subscriber<? super RealmResults<E>> subscriber) {
+            public void subscribe(final FlowableEmitter<RealmResults<E>> emitter) throws Exception {
                 // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final Realm observableRealm = Realm.getInstance(realmConfig);
                 resultsRefs.get().acquireReference(results);
-
                 final RealmChangeListener<RealmResults<E>> listener = new RealmChangeListener<RealmResults<E>>() {
                     @Override
-                    public void onChange(RealmResults<E> result) {
-                        if (!subscriber.isUnsubscribed()) {
-                            subscriber.onNext(results);
+                    public void onChange(RealmResults<E> results) {
+                        if (!emitter.isCancelled()) {
+                            emitter.onNext(results);
                         }
                     }
                 };
                 results.addChangeListener(listener);
-                subscriber.add(Subscriptions.create(new Action0() {
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
                     @Override
-                    public void call() {
+                    public void run() {
                         results.removeChangeListener(listener);
                         observableRealm.close();
                         resultsRefs.get().releaseReference(results);
                     }
                 }));
 
-                // Immediately calls onNext with the current value, as due to Realm's auto-update, it will be the latest
-                // value.
-                subscriber.onNext(results);
+                // Emit current value immediately
+                emitter.onNext(results);
+
+            }
+        }, BACK_PRESSURE_STRATEGY);
+    }
+
+    @Override
+    public <E> Observable<CollectionChange<RealmResults<E>>> changesetsFrom(Realm realm, final RealmResults<E> results) {
+        final RealmConfiguration realmConfig = realm.getConfiguration();
+        return Observable.create(new ObservableOnSubscribe<CollectionChange<RealmResults<E>>>() {
+            @Override
+            public void subscribe(final ObservableEmitter<CollectionChange<RealmResults<E>>> emitter) throws Exception {
+                // Gets instance to make sure that the Realm is open for as long as the
+                // Observable is subscribed to it.
+                final Realm observableRealm = Realm.getInstance(realmConfig);
+                resultsRefs.get().acquireReference(results);
+                final OrderedRealmCollectionChangeListener<RealmResults<E>> listener = new OrderedRealmCollectionChangeListener<RealmResults<E>>() {
+                    @Override
+                    public void onChange(RealmResults<E> e, OrderedCollectionChangeSet changeSet) {
+                        if (!emitter.isDisposed()) {
+                            emitter.onNext(new CollectionChange<RealmResults<E>>(results, changeSet));
+                        }
+                    }
+                };
+                results.addChangeListener(listener);
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        results.removeChangeListener(listener);
+                        observableRealm.close();
+                        resultsRefs.get().releaseReference(results);
+                    }
+                }));
+
+                // Emit current value immediately
+                emitter.onNext(new CollectionChange<>(results, null));
             }
         });
     }
 
     @Override
-    public Observable<RealmResults<DynamicRealmObject>> from(DynamicRealm realm, final RealmResults<DynamicRealmObject> results) {
+    public <E> Flowable<RealmResults<E>> from(DynamicRealm realm, final RealmResults<E> results) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
-        return Observable.create(new Observable.OnSubscribe<RealmResults<DynamicRealmObject>>() {
+        return Flowable.create(new FlowableOnSubscribe<RealmResults<E>>() {
             @Override
-            public void call(final Subscriber<? super RealmResults<DynamicRealmObject>> subscriber) {
+            public void subscribe(final FlowableEmitter<RealmResults<E>> emitter) throws Exception {
                 // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
                 resultsRefs.get().acquireReference(results);
+                final RealmChangeListener<RealmResults<E>> listener = new RealmChangeListener<RealmResults<E>>() {
+                    @Override
+                    public void onChange(RealmResults<E> results) {
+                        if (!emitter.isCancelled()) {
+                            emitter.onNext(results);
+                        }
+                    }
+                };
+                results.addChangeListener(listener);
 
-                final RealmChangeListener<RealmResults<DynamicRealmObject>> listener = new RealmChangeListener<RealmResults<DynamicRealmObject>>() {
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
                     @Override
-                    public void onChange(RealmResults<DynamicRealmObject> result) {
-                        if (!subscriber.isUnsubscribed()) {
-                            subscriber.onNext(results);
+                    public void run() {
+                        results.removeChangeListener(listener);
+                        observableRealm.close();
+                        resultsRefs.get().releaseReference(results);
+                    }
+                }));
+
+                // Emit current value immediately
+                emitter.onNext(results);
+
+            }
+        }, BACK_PRESSURE_STRATEGY);
+    }
+
+    @Override
+    public <E> Observable<CollectionChange<RealmResults<E>>> changesetsFrom(DynamicRealm realm, final RealmResults<E> results) {
+        final RealmConfiguration realmConfig = realm.getConfiguration();
+        return Observable.create(new ObservableOnSubscribe<CollectionChange<RealmResults<E>>>() {
+            @Override
+            public void subscribe(final ObservableEmitter<CollectionChange<RealmResults<E>>> emitter) throws Exception {
+                // Gets instance to make sure that the Realm is open for as long as the
+                // Observable is subscribed to it.
+                final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
+                resultsRefs.get().acquireReference(results);
+                final OrderedRealmCollectionChangeListener<RealmResults<E>> listener = new OrderedRealmCollectionChangeListener<RealmResults<E>>() {
+                    @Override
+                    public void onChange(RealmResults<E> results, OrderedCollectionChangeSet changeSet) {
+                        if (!emitter.isDisposed()) {
+                            emitter.onNext(new CollectionChange<>(results, changeSet));
                         }
                     }
                 };
                 results.addChangeListener(listener);
-                subscriber.add(Subscriptions.create(new Action0() {
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
                     @Override
-                    public void call() {
+                    public void run() {
                         results.removeChangeListener(listener);
                         observableRealm.close();
                         resultsRefs.get().releaseReference(results);
                     }
                 }));
 
-                // Immediately calls onNext with the current value, as due to Realm's auto-update, it will be the latest
-                // value.
-                subscriber.onNext(results);
+                // Emit current value immediately
+                emitter.onNext(new CollectionChange<>(results, null));
             }
         });
     }
 
     @Override
-    public <E extends RealmModel> Observable<RealmList<E>> from(Realm realm, final RealmList<E> list) {
+    public <E> Flowable<RealmList<E>> from(Realm realm, final RealmList<E> list) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
-        return Observable.create(new Observable.OnSubscribe<RealmList<E>>() {
+        return Flowable.create(new FlowableOnSubscribe<RealmList<E>>() {
             @Override
-            public void call(final Subscriber<? super RealmList<E>> subscriber) {
+            public void subscribe(final FlowableEmitter<RealmList<E>> emitter) throws Exception {
                 // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final Realm observableRealm = Realm.getInstance(realmConfig);
                 listRefs.get().acquireReference(list);
-
                 final RealmChangeListener<RealmList<E>> listener = new RealmChangeListener<RealmList<E>>() {
                     @Override
-                    public void onChange(RealmList<E> result) {
-                        if (!subscriber.isUnsubscribed()) {
-                            subscriber.onNext(list);
+                    public void onChange(RealmList<E> results) {
+                        if (!emitter.isCancelled()) {
+                            emitter.onNext(list);
                         }
                     }
                 };
                 list.addChangeListener(listener);
-                subscriber.add(Subscriptions.create(new Action0() {
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
                     @Override
-                    public void call() {
+                    public void run() {
                         list.removeChangeListener(listener);
                         observableRealm.close();
                         listRefs.get().releaseReference(list);
                     }
                 }));
 
-                // Immediately calls onNext with the current value, as due to Realm's auto-update, it will be the latest
-                // value.
-                subscriber.onNext(list);
+                // Emit current value immediately
+                emitter.onNext(list);
+
+            }
+        }, BACK_PRESSURE_STRATEGY);
+    }
+
+    @Override
+    public <E> Observable<CollectionChange<RealmList<E>>> changesetsFrom(Realm realm, final RealmList<E> list) {
+        final RealmConfiguration realmConfig = realm.getConfiguration();
+        return Observable.create(new ObservableOnSubscribe<CollectionChange<RealmList<E>>>() {
+            @Override
+            public void subscribe(final ObservableEmitter<CollectionChange<RealmList<E>>> emitter) throws Exception {
+                // Gets instance to make sure that the Realm is open for as long as the
+                // Observable is subscribed to it.
+                final Realm observableRealm = Realm.getInstance(realmConfig);
+                listRefs.get().acquireReference(list);
+                final OrderedRealmCollectionChangeListener<RealmList<E>> listener = new OrderedRealmCollectionChangeListener<RealmList<E>>() {
+                    @Override
+                    public void onChange(RealmList<E> results, OrderedCollectionChangeSet changeSet) {
+                        if (!emitter.isDisposed()) {
+                            emitter.onNext(new CollectionChange<>(results, changeSet));
+                        }
+                    }
+                };
+                list.addChangeListener(listener);
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        list.removeChangeListener(listener);
+                        observableRealm.close();
+                        listRefs.get().releaseReference(list);
+                    }
+                }));
+
+                // Emit current value immediately
+                emitter.onNext(new CollectionChange<>(list, null));
             }
         });
     }
 
     @Override
-    public Observable<RealmList<DynamicRealmObject>> from(DynamicRealm realm, final RealmList<DynamicRealmObject> list) {
+    public <E> Flowable<RealmList<E>> from(DynamicRealm realm, final RealmList<E> list) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
-        return Observable.create(new Observable.OnSubscribe<RealmList<DynamicRealmObject>>() {
+        return Flowable.create(new FlowableOnSubscribe<RealmList<E>>() {
             @Override
-            public void call(final Subscriber<? super RealmList<DynamicRealmObject>> subscriber) {
+            public void subscribe(final FlowableEmitter<RealmList<E>> emitter) throws Exception {
                 // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
                 listRefs.get().acquireReference(list);
+                final RealmChangeListener<RealmList<E>> listener = new RealmChangeListener<RealmList<E>>() {
+                    @Override
+                    public void onChange(RealmList<E> results) {
+                        if (!emitter.isCancelled()) {
+                            emitter.onNext(list);
+                        }
+                    }
+                };
+                list.addChangeListener(listener);
 
-                final RealmChangeListener<RealmList<DynamicRealmObject>> listener = new RealmChangeListener<RealmList<DynamicRealmObject>>() {
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
                     @Override
-                    public void onChange(RealmList<DynamicRealmObject> result) {
-                        if (!subscriber.isUnsubscribed()) {
-                            subscriber.onNext(list);
+                    public void run() {
+                        list.removeChangeListener(listener);
+                        observableRealm.close();
+                        listRefs.get().releaseReference(list);
+                    }
+                }));
+
+                // Emit current value immediately
+                emitter.onNext(list);
+
+            }
+        }, BACK_PRESSURE_STRATEGY);
+    }
+
+    @Override
+    public <E> Observable<CollectionChange<RealmList<E>>> changesetsFrom(DynamicRealm realm, final RealmList<E> list) {
+        final RealmConfiguration realmConfig = realm.getConfiguration();
+        return Observable.create(new ObservableOnSubscribe<CollectionChange<RealmList<E>>>() {
+            @Override
+            public void subscribe(final ObservableEmitter<CollectionChange<RealmList<E>>> emitter) throws Exception {
+                // Gets instance to make sure that the Realm is open for as long as the
+                // Observable is subscribed to it.
+                final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
+                listRefs.get().acquireReference(list);
+                final OrderedRealmCollectionChangeListener<RealmList<E>> listener = new OrderedRealmCollectionChangeListener<RealmList<E>>() {
+                    @Override
+                    public void onChange(RealmList<E> results, OrderedCollectionChangeSet changeSet) {
+                        if (!emitter.isDisposed()) {
+                            emitter.onNext(new CollectionChange<>(results, changeSet));
                         }
                     }
                 };
                 list.addChangeListener(listener);
-                subscriber.add(Subscriptions.create(new Action0() {
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
                     @Override
-                    public void call() {
+                    public void run() {
                         list.removeChangeListener(listener);
                         observableRealm.close();
                         listRefs.get().releaseReference(list);
                     }
                 }));
 
-                // Immediately calls onNext with the current value, as due to Realm's auto-update, it will be the latest
-                // value.
-                subscriber.onNext(list);
+                // Emit current value immediately
+                emitter.onNext(new CollectionChange<>(list, null));
             }
         });
     }
 
     @Override
-    public <E extends RealmModel> Observable<E> from(final Realm realm, final E object) {
+    public <E extends RealmModel> Flowable<E> from(final Realm realm, final E object) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
-        return Observable.create(new Observable.OnSubscribe<E>() {
+        return Flowable.create(new FlowableOnSubscribe<E>() {
             @Override
-            public void call(final Subscriber<? super E> subscriber) {
+            public void subscribe(final FlowableEmitter<E> emitter) throws Exception {
                 // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final Realm observableRealm = Realm.getInstance(realmConfig);
                 objectRefs.get().acquireReference(object);
-
                 final RealmChangeListener<E> listener = new RealmChangeListener<E>() {
                     @Override
-                    public void onChange(E object) {
-                        if (!subscriber.isUnsubscribed()) {
-                            subscriber.onNext(object);
+                    public void onChange(E obj) {
+                        if (!emitter.isCancelled()) {
+                            emitter.onNext(obj);
                         }
                     }
                 };
                 RealmObject.addChangeListener(object, listener);
-                subscriber.add(Subscriptions.create(new Action0() {
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
                     @Override
-                    public void call() {
+                    public void run() {
                         RealmObject.removeChangeListener(object, listener);
                         observableRealm.close();
                         objectRefs.get().releaseReference(object);
                     }
                 }));
 
-                // Immediately calls onNext with the current value, as due to Realm's auto-update, it will be the latest
-                // value.
-                subscriber.onNext(object);
+                // Emit current value immediately
+                emitter.onNext(object);
+
+            }
+        }, BACK_PRESSURE_STRATEGY);
+    }
+
+    @Override
+    public <E extends RealmModel> Observable<ObjectChange<E>> changesetsFrom(Realm realm, final E object) {
+        final RealmConfiguration realmConfig = realm.getConfiguration();
+        return Observable.create(new ObservableOnSubscribe<ObjectChange<E>>() {
+            @Override
+            public void subscribe(final ObservableEmitter<ObjectChange<E>> emitter) throws Exception {
+                // Gets instance to make sure that the Realm is open for as long as the
+                // Observable is subscribed to it.
+                final Realm observableRealm = Realm.getInstance(realmConfig);
+                objectRefs.get().acquireReference(object);
+                final RealmObjectChangeListener<E> listener = new RealmObjectChangeListener<E>() {
+                    @Override
+                    public void onChange(E obj, ObjectChangeSet changeSet) {
+                        if (!emitter.isDisposed()) {
+                            emitter.onNext(new ObjectChange<>(obj, changeSet));
+                        }
+                    }
+                };
+                RealmObject.addChangeListener(object, listener);
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        RealmObject.removeChangeListener(object, listener);
+                        observableRealm.close();
+                        objectRefs.get().releaseReference(object);
+                    }
+                }));
+
+                // Emit current value immediately
+                emitter.onNext(new ObjectChange<>(object, null));
             }
         });
     }
 
     @Override
-    public Observable<DynamicRealmObject> from(DynamicRealm realm, final DynamicRealmObject object) {
+    public Flowable<DynamicRealmObject> from(DynamicRealm realm, final DynamicRealmObject object) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
-        return Observable.create(new Observable.OnSubscribe<DynamicRealmObject>() {
+        return Flowable.create(new FlowableOnSubscribe<DynamicRealmObject>() {
             @Override
-            public void call(final Subscriber<? super DynamicRealmObject> subscriber) {
+            public void subscribe(final FlowableEmitter<DynamicRealmObject> emitter) throws Exception {
                 // Gets instance to make sure that the Realm is open for as long as the
                 // Observable is subscribed to it.
                 final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
                 objectRefs.get().acquireReference(object);
-
                 final RealmChangeListener<DynamicRealmObject> listener = new RealmChangeListener<DynamicRealmObject>() {
                     @Override
-                    public void onChange(DynamicRealmObject object) {
-                        if (!subscriber.isUnsubscribed()) {
-                            subscriber.onNext(object);
+                    public void onChange(DynamicRealmObject obj) {
+                        if (!emitter.isCancelled()) {
+                            emitter.onNext(obj);
                         }
                     }
                 };
                 RealmObject.addChangeListener(object, listener);
-                subscriber.add(Subscriptions.create(new Action0() {
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
                     @Override
-                    public void call() {
+                    public void run() {
                         RealmObject.removeChangeListener(object, listener);
                         observableRealm.close();
                         objectRefs.get().releaseReference(object);
                     }
                 }));
 
-                // Immediately calls onNext with the current value, as due to Realm's auto-update, it will be the latest
-                // value.
-                subscriber.onNext(object);
+                // Emit current value immediately
+                emitter.onNext(object);
+
+            }
+        }, BACK_PRESSURE_STRATEGY);
+    }
+
+    @Override
+    public Observable<ObjectChange<DynamicRealmObject>> changesetsFrom(DynamicRealm realm, final DynamicRealmObject object) {
+        final RealmConfiguration realmConfig = realm.getConfiguration();
+        return Observable.create(new ObservableOnSubscribe<ObjectChange<DynamicRealmObject>>() {
+            @Override
+            public void subscribe(final ObservableEmitter<ObjectChange<DynamicRealmObject>> emitter) throws Exception {
+                // Gets instance to make sure that the Realm is open for as long as the
+                // Observable is subscribed to it.
+                final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
+                objectRefs.get().acquireReference(object);
+                final RealmObjectChangeListener<DynamicRealmObject> listener = new RealmObjectChangeListener<DynamicRealmObject>() {
+                    @Override
+                    public void onChange(DynamicRealmObject obj, ObjectChangeSet changeSet) {
+                        if (!emitter.isDisposed()) {
+                            emitter.onNext(new ObjectChange<>(obj, changeSet));
+                        }
+                    }
+                };
+                object.addChangeListener(listener);
+
+                // Cleanup when stream is disposed
+                emitter.setDisposable(Disposables.fromRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        object.removeChangeListener(listener);
+                        observableRealm.close();
+                        objectRefs.get().releaseReference(object);
+                    }
+                }));
+
+                // Emit current value immediately
+                emitter.onNext(new ObjectChange<>(object, null));
             }
         });
     }
 
     @Override
-    public <E extends RealmModel> Observable<RealmQuery<E>> from(Realm realm, RealmQuery<E> query) {
+    public <E> Single<RealmQuery<E>> from(Realm realm, RealmQuery<E> query) {
         throw new RuntimeException("RealmQuery not supported yet.");
     }
 
     @Override
-    public Observable<RealmQuery<DynamicRealmObject>> from(DynamicRealm realm, RealmQuery<DynamicRealmObject> query) {
+    public <E> Single<RealmQuery<E>> from(DynamicRealm realm, RealmQuery<E> query) {
         throw new RuntimeException("RealmQuery not supported yet.");
     }
 
@@ -364,7 +599,7 @@ public boolean equals(Object o) {
 
     @Override
     public int hashCode() {
-        return 37;
+        return 37; // Random number
     }
 
 
diff --git a/realm/realm-library/src/main/java/io/realm/rx/RxObservableFactory.java b/realm/realm-library/src/main/java/io/realm/rx/RxObservableFactory.java
index efe20fbe92..e5784f42ac 100644
--- a/realm/realm-library/src/main/java/io/realm/rx/RxObservableFactory.java
+++ b/realm/realm-library/src/main/java/io/realm/rx/RxObservableFactory.java
@@ -16,16 +16,18 @@
 
 package io.realm.rx;
 
+import io.reactivex.Flowable;
+import io.reactivex.Observable;
+import io.reactivex.Single;
 import io.realm.DynamicRealm;
 import io.realm.DynamicRealmObject;
+import io.realm.OrderedCollectionChangeSet;
 import io.realm.Realm;
 import io.realm.RealmList;
 import io.realm.RealmModel;
 import io.realm.RealmObject;
 import io.realm.RealmQuery;
 import io.realm.RealmResults;
-import rx.Observable;
-
 
 /**
  * Factory interface for creating Rx Observables for Realm classes.
@@ -33,120 +35,205 @@
 public interface RxObservableFactory {
 
     /**
-     * Creates an Observable for a {@link Realm}. It should emit the initial state of the Realm when subscribed to and
+     * Creates a Flowable for a {@link Realm}. It should emit the initial state of the Realm when subscribed to and
      * on each subsequent update of the Realm.
      * <p>
-     * Realm observables are hot observables as Realms are automatically kept up to date.
+     * Realm flowables are hot as Realms are automatically kept up to date.
      *
      * @param realm {@link Realm} to listen to changes for.
      * @return Rx observable that emit all updates to the Realm.
      */
-    Observable<Realm> from(Realm realm);
+    Flowable<Realm> from(Realm realm);
 
     /**
-     * Creates an Observable for a {@link DynamicRealm}. It should emit the initial state of the Realm when subscribed
+     * Creates a Flowable for a {@link DynamicRealm}. It should emit the initial state of the Realm when subscribed
      * to and on each subsequent update of the Realm.
      * <p>
-     * DynamicRealm observables are hot observables as DynamicRealms are automatically kept up to date.
+     * DynamicRealm observables are hot as DynamicRealms are automatically kept up to date.
      *
      * @param realm {@link DynamicRealm} to listen to changes for.
      * @return Rx observable that emit all updates to the DynamicRealm.
      */
-    Observable<DynamicRealm> from(DynamicRealm realm);
+    Flowable<DynamicRealm> from(DynamicRealm realm);
 
     /**
-     * Creates an Observable for a {@link RealmResults}. It should emit the initial RealmResult when subscribed to and
+     * Creates a Flowable for a {@link RealmResults}. It should emit the initial RealmResult when subscribed to and
      * on each subsequent update of the RealmResults.
      * <p>
-     * RealmResults observables are hot observables as RealmResults are automatically kept up to date.
+     * RealmResults observables are hot as RealmResults are automatically kept up to date.
      *
      * @param results {@link RealmResults} to listen to changes for.
      * @param realm {@link Realm} instance results are coming from.
      * @param <E> type of RealmObject
      * @return Rx observable that emit all updates to the RealmObject.
      */
-    <E extends RealmModel> Observable<RealmResults<E>> from(Realm realm, RealmResults<E> results);
+    <E> Flowable<RealmResults<E>> from(Realm realm, RealmResults<E> results);
 
     /**
      * Creates an Observable for a {@link RealmResults}. It should emit the initial RealmResult when subscribed to and
+     * on each subsequent update of the RealmResults it should emit the RealmResults + the {@link OrderedCollectionChangeSet}
+     * that describes the update.
+     * <p>
+     * Changeset observables do not support backpressure as a changeset depends on the state of the previous
+     * changeset. Handling backpressure should therefor be left to users.
+     *
+     * @param results {@link RealmResults} to listen to changes for.
+     * @param realm {@link Realm} instance results are coming from.
+     * @param <E> type of RealmObject
+     * @return Rx observable that emit all updates + their changeset.
+     */
+    <E> Observable<CollectionChange<RealmResults<E>>> changesetsFrom(Realm realm, RealmResults<E> results);
+
+    /**
+     * Creates a Flowable for a {@link RealmResults}. It should emit the initial RealmResult when subscribed to and
      * on each subsequent update of the RealmResults.
      * <p>
-     * Realm observables are hot observables as RealmResults are automatically kept up to date.
+     * Realm observables are hot as RealmResults are automatically kept up to date.
      *
      * @param results {@link RealmResults} to listen to changes for.
      * @param realm {@link DynamicRealm} instance results are coming from.
      * @return Rx observable that emit all updates to the RealmResults.
      */
-    Observable<RealmResults<DynamicRealmObject>> from(DynamicRealm realm, RealmResults<DynamicRealmObject> results);
+    <E> Flowable<RealmResults<E>> from(DynamicRealm realm, RealmResults<E> results);
+
+    /**
+     * Creates an Observable for a {@link RealmResults}. It should emit the initial RealmResult when subscribed to and
+     * on each subsequent update of the RealmResults it should emit the RealmResults + the {@link OrderedCollectionChangeSet}
+     * that describes the update.
+     * <p>
+     * Changeset observables do not support backpressure as a changeset depends on the state of the previous
+     * changeset. Handling backpressure should therefor be left to users.
+     *
+     * @param results {@link RealmResults} to listen to changes for.
+     * @param realm {@link Realm} instance results are coming from.
+     * @return Rx observable that emit all updates + their changeset.
+     */
+    <E> Observable<CollectionChange<RealmResults<E>>> changesetsFrom(DynamicRealm realm, RealmResults<E> results);
 
     /**
      * Creates an Observable for a {@link RealmList}. It should emit the initial list when subscribed to and on each
      * subsequent update of the RealmList.
      * <p>
-     * RealmList observables are hot observables as RealmLists are automatically kept up to date.
+     * RealmList observables are hot as RealmLists are automatically kept up to date.
      * <p>
      * Note: {@link io.realm.RealmChangeListener} is currently not supported on RealmLists.
      *
      * @param list RealmObject to listen to changes for.
      * @param realm {@link Realm} instance list is coming from.
+     * @param <E> type of query target
+     */
+    <E> Flowable<RealmList<E>> from(Realm realm, RealmList<E> list);
+
+    /**
+     * Creates an Observable for a {@link RealmList}. It should emit the initial RealmList when subscribed to and
+     * on each subsequent update of the RealmIst it should emit the RealmList + the {@link OrderedCollectionChangeSet}
+     * that describes the update.
+     * <p>
+     * Changeset observables do not support backpressure as a changeset depends on the state of the previous
+     * changeset. Handling backpressure should therefor be left to users.
+     *
+     * @param list {@link RealmList} to listen to changes for.
+     * @param realm {@link Realm} instance list is coming from.
      * @param <E> type of RealmObject
+     * @return Rx observable that emit all updates + their changeset.
      */
-    <E extends RealmModel> Observable<RealmList<E>> from(Realm realm, RealmList<E> list);
+    <E> Observable<CollectionChange<RealmList<E>>> changesetsFrom(Realm realm, RealmList<E> list);
 
     /**
-     * Creates an Observable for a {@link RealmList}. It should emit the initial list when subscribed to and on each
+     * Creates a Flowable for a {@link RealmList}. It should emit the initial list when subscribed to and on each
      * subsequent update of the RealmList.
      * <p>
-     * RealmList observables are hot observables as RealmLists are automatically kept up to date.
+     * RealmList observables are hot as RealmLists are automatically kept up to date.
      * <p>
      * Note: {@link io.realm.RealmChangeListener} is currently not supported on RealmLists.
      *
      * @param list RealmList to listen to changes for.
      * @param realm {@link DynamicRealm} instance list is coming from.
      */
-    Observable<RealmList<DynamicRealmObject>> from(DynamicRealm realm, RealmList<DynamicRealmObject> list);
+    <E> Flowable<RealmList<E>> from(DynamicRealm realm, RealmList<E> list);
 
     /**
-     * Creates an Observable for a {@link RealmObject}. It should emit the initial object when subscribed to and on each
+     * Creates an Observable for a {@link RealmList}. It should emit the initial RealmList when subscribed to and
+     * on each subsequent update of the RealmList it should emit the RealmList + the {@link OrderedCollectionChangeSet}
+     * that describes the update.
+     * <p>
+     * Changeset observables do not support backpressure as a changeset depends on the state of the previous
+     * changeset. Handling backpressure should therefor be left to users.
+     *
+     * @param list {@link RealmList} to listen to changes for.
+     * @param realm {@link Realm} instance list is coming from.
+     * @return Rx observable that emit all updates + their changeset.
+     */
+    <E> Observable<CollectionChange<RealmList<E>>> changesetsFrom(DynamicRealm realm, RealmList<E> list);
+
+    /**
+     * Creates a Flowable for a {@link RealmObject}. It should emit the initial object when subscribed to and on each
      * subsequent update of the object.
      * <p>
-     * RealmObject observables are hot observables as RealmObjects are automatically kept up to date.
+     * RealmObject observables are hot as RealmObjects are automatically kept up to date.
+     *
+     * @param object RealmObject to listen to changes for.
+     * @param realm {@link Realm} instance object is coming from.
+     * @param <E> type of query target
+     */
+    <E extends RealmModel> Flowable<E> from(Realm realm, E object);
+
+    /**
+     * Creates an Observable for a {@link RealmObject}. It should emit the initial object when subscribed to and on each
+     * subsequent update of the object it should emit the object + the {@link io.realm.ObjectChangeSet} that describes
+     * the update.
+     * <p>
+     * Changeset observables do not support backpressure as a changeset depends on the state of the previous
+     * changeset. Handling backpressure should therefore be left to the user.
      *
      * @param object RealmObject to listen to changes for.
      * @param realm {@link Realm} instance object is coming from.
      * @param <E> type of RealmObject
      */
-    <E extends RealmModel> Observable<E> from(Realm realm, E object);
+    <E extends RealmModel> Observable<ObjectChange<E>> changesetsFrom(Realm realm, E object);
 
     /**
-     * Creates an Observable for a {@link DynamicRealmObject}. It should emit the initial object when subscribed to and
+     * Creates a Flowable for a {@link DynamicRealmObject}. It should emit the initial object when subscribed to and
      * on each subsequent update of the object.
      * <p>
-     * DynamicRealmObject observables are hot observables as DynamicRealmObjects automatically are kept up to date.
+     * DynamicRealmObject observables are hot as DynamicRealmObjects automatically are kept up to date.
      *
      * @param object DynamicRealmObject to listen to changes for.
      * @param realm {@link DynamicRealm} instance object is coming from.
      */
-    Observable<DynamicRealmObject> from(DynamicRealm realm, DynamicRealmObject object);
+    Flowable<DynamicRealmObject> from(DynamicRealm realm, DynamicRealmObject object);
+
+    /**
+     * Creates an Observable for a {@link RealmObject}. It should emit the initial object when subscribed to and on each
+     * subsequent update of the object it should emit the object + the {@link io.realm.ObjectChangeSet} that describes
+     * the update.
+     * <p>
+     * Changeset observables do not support backpressure as a changeset depends on the state of the previous
+     * changeset. Handling backpressure should therefore be left to the user.
+     *
+     * @param object RealmObject to listen to changes for.
+     * @param realm {@link Realm} instance object is coming from.
+     */
+    Observable<ObjectChange<DynamicRealmObject>> changesetsFrom(DynamicRealm realm, DynamicRealmObject object);
 
     /**
-     * Creates an Observable from a {@link RealmQuery}. It should emit the query and then complete.
+     * Creates a Single from a {@link RealmQuery}. It should emit the query and then complete.
      * <p>
      * A RealmQuery observable is cold.
      *
      * @param query RealmQuery to emit.
      * @param realm {@link Realm} instance query is coming from.
-     * @param <E> type of RealmObject
+     * @param <E> type of query target
      */
-    <E extends RealmModel> Observable<RealmQuery<E>> from(Realm realm, RealmQuery<E> query);
+    <E> Single<RealmQuery<E>> from(Realm realm, RealmQuery<E> query);
 
     /**
-     * Creates an Observable from a {@link RealmQuery}. It should emit the query and then complete.
+     * Creates a Single from a {@link RealmQuery}. It should emit the query and then complete.
      * <p>
      * A RealmQuery observable is cold.
      *
      * @param query RealmObject to listen to changes for.
      * @param realm {@link DynamicRealm} instance query is coming from.
      */
-    Observable<RealmQuery<DynamicRealmObject>> from(DynamicRealm realm, RealmQuery<DynamicRealmObject> query);
+    <E> Single<RealmQuery<E>> from(DynamicRealm realm, RealmQuery<E> query);
 }
diff --git a/realm/realm-library/src/main/java/io/realm/rx/package-info.java b/realm/realm-library/src/main/java/io/realm/rx/package-info.java
new file mode 100644
index 0000000000..0620fbea2d
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/rx/package-info.java
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+@javax.annotation.ParametersAreNonnullByDefault
+package io.realm.rx;
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ClientResetRequiredError.java b/realm/realm-library/src/objectServer/java/io/realm/ClientResetRequiredError.java
index f9a2fbe1e1..1ffc75acc7 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/ClientResetRequiredError.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/ClientResetRequiredError.java
@@ -26,15 +26,17 @@
  */
 public class ClientResetRequiredError extends ObjectServerError {
 
-    private final RealmConfiguration configuration;
+    private final SyncConfiguration originalConfiguration;
+    private final RealmConfiguration backupConfiguration;
     private final File backupFile;
     private final File originalFile;
 
-    public ClientResetRequiredError(ErrorCode errorCode, String errorMessage, String backupFilePath, RealmConfiguration configuration) {
+    ClientResetRequiredError(ErrorCode errorCode, String errorMessage, SyncConfiguration originalConfiguration, RealmConfiguration backupConfiguration) {
         super(errorCode, errorMessage);
-        this.configuration = configuration;
-        this.backupFile = new File(backupFilePath);
-        this.originalFile = new File(configuration.getPath());
+        this.originalConfiguration = originalConfiguration;
+        this.backupConfiguration = backupConfiguration;
+        this.backupFile = new File(backupConfiguration.getPath());
+        this.originalFile = new File(originalConfiguration.getPath());
     }
 
     /**
@@ -50,11 +52,11 @@ public ClientResetRequiredError(ErrorCode errorCode, String errorMessage, String
      */
     public void executeClientReset()  {
         synchronized (Realm.class) {
-            if (Realm.getGlobalInstanceCount(configuration) > 0) {
+            if (Realm.getGlobalInstanceCount(originalConfiguration) > 0) {
                 throw new IllegalStateException("Realm has not been fully closed. Client Reset cannot run before all " +
                         "instances have been closed.");
             }
-            nativeExecuteClientReset(configuration.getPath());
+            nativeExecuteClientReset(originalConfiguration.getPath());
         }
     }
 
@@ -70,6 +72,12 @@ public File getBackupFile() {
         return backupFile;
     }
 
+    /**
+     * @return the configuration that can be used to open the backup Realm offline.
+     */
+    public RealmConfiguration getBackupRealmConfiguration() {
+        return backupConfiguration;
+    }
     /**
      * Returns the location of the original Realm file. After the Client Reset has completed, the file at this location
      * will be deleted.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
index 1a5438ba92..100c89b613 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
@@ -16,12 +16,17 @@
 
 package io.realm;
 
+
+import java.io.IOException;
+
 /**
  * This class enumerate all potential errors related to using the Object Server or synchronizing data.
  */
 public enum ErrorCode {
 
-    // See https://github.com/realm/realm-sync/blob/master/doc/protocol_16.md
+    // See Client::Error in https://github.com/realm/realm-sync/blob/master/src/realm/sync/client.hpp
+    // See https://github.com/realm/realm-object-server/blob/master/object-server/doc/problems.md
+    // See https://github.com/realm/realm-sync/blob/develop/src/realm/sync/protocol.hpp
 
     // Realm Java errors (0-49)
     UNKNOWN(-1),                                // Catch-all
@@ -41,6 +46,15 @@
     REUSE_OF_SESSION_IDENT(107),     // Overlapping reuse of session identifier (BIND)
     BOUND_IN_OTHER_SESSION(108),     // Client file bound in other session (IDENT)
     BAD_MESSAGE_ORDER(109),          // Bad input message order
+    BAD_ORIGIN_FILE_IDENT(110),      // Bad origin file identifier in changeset header (DOWNLOAD)
+    BAD_SERVER_VERSION_DOWNLOAD(111),// Bad server version in changeset header (DOWNLOAD)
+    BAD_CHANGESET_DOWNLOAD(112),     // Bad changeset (DOWNLOAD)
+    BAD_REQUEST_IDENT(113),          // Bad request identifier (MARK)
+    BAD_ERROR_CODE(114),             // Bad error code (ERROR)
+    BAD_COMPRESSION(115),            // Bad compression (DOWNLOAD)
+    BAD_CLIENT_VERSION_DOWNLOAD(116),// Bad last integrated client version in changeset header (DOWNLOAD)
+    SSL_SERVER_CERT_REJECTED(117),   // SSL server certificate rejected
+    PONG_TIMEOUT(118),               // Timeout on reception of PONG response messsage
 
     // Session level errors (200 - 299)
     SESSION_CLOSED(200, Category.RECOVERABLE),      // Session closed (no error)
@@ -61,8 +75,55 @@
     DIVERGING_HISTORIES(211),                       // Diverging histories (IDENT)
     BAD_CHANGESET(212),                             // Bad changeset (UPLOAD)
     DISABLED_SESSION(213),                          // Disabled session
+    PARTIAL_SYNC_DISABLED(214),                     // Partial sync disabled (BIND)
 
     // 300 - 599 Reserved for Standard HTTP error codes
+    MULTIPLE_CHOICES(300),
+    MOVED_PERMANENTLY(301),
+    FOUND(302),
+    SEE_OTHER(303),
+    NOT_MODIFIED(304),
+    USE_PROXY(305),
+    TEMPORARY_REDIRECT(307),
+    PERMANENT_REDIRECT(308),
+    BAD_REQUEST(400),
+    UNAUTHORIZED(401),
+    PAYMENT_REQUIRED(402),
+    FORBIDDEN(403),
+    NOT_FOUND(404),
+    METHOD_NOT_ALLOWED(405),
+    NOT_ACCEPTABLE(406),
+    PROXY_AUTHENTICATION_REQUIRED(407),
+    REQUEST_TIMEOUT(408),
+    CONFLICT(409),
+    GONE(410),
+    LENGTH_REQUIRED(411),
+    PRECONDITION_FAILED(412),
+    PAYLOAD_TOO_LARGE(413),
+    URI_TOO_LONG(414),
+    UNSUPPORTED_MEDIA_TYPE(415),
+    RANGE_NOT_SATISFIABLE(416),
+    EXPECTATION_FAILED(417),
+    MISDIRECTED_REQUEST(421),
+    UNPROCESSABLE_ENTITY(422),
+    LOCKED(423),
+    FAILED_DEPENDENCY(424),
+    UPGRADE_REQUIRED(426),
+    PRECONDITION_REQUIRED(428),
+    TOO_MANY_REQUESTS(429),
+    REQUEST_HEADER_FIELDS_TOO_LARGE(431),
+    UNAVAILABLE_FOR_LEGAL_REASONS(451),
+    INTERNAL_SERVER_ERROR(500),
+    NOT_IMPLEMENTED(501),
+    BAD_GATEWAY(502),
+    SERVICE_UNAVAILABLE(503),
+    GATEWAY_TIMEOUT(504),
+    HTTP_VERSION_NOT_SUPPORTED(505),
+    VARIANT_ALSO_NEGOTIATES(506),
+    INSUFFICIENT_STORAGE(507),
+    LOOP_DETECTED(508),
+    NOT_EXTENDED(510),
+    NETWORK_AUTHENTICATION_REQUIRED(511),
 
     // Realm Authentication Server response errors (600 - 699)
     INVALID_PARAMETERS(601),
@@ -71,7 +132,14 @@
     UNKNOWN_ACCOUNT(612),
     EXISTING_ACCOUNT(613),
     ACCESS_DENIED(614),
-    EXPIRED_REFRESH_TOKEN(615);
+    EXPIRED_REFRESH_TOKEN(615),
+    INVALID_HOST(616),
+
+    // Other Realm Object Server response errors
+    EXPIRED_PERMISSION_OFFER(701),
+    AMBIGUOUS_PERMISSION_OFFER_TOKEN(702),
+    FILE_MAY_NOT_BE_SHARED(703),
+    SERVER_MISCONFIGURATION(801);
 
     private final int code;
     private final Category category;
@@ -127,6 +195,20 @@ public static ErrorCode fromInt(int errorCode) {
         throw new IllegalArgumentException("Unknown error code: " + errorCode);
     }
 
+    /**
+     * Helper method for mapping between {@link Exception} and {@link ErrorCode}.
+     * @param exception to be mapped as an {@link ErrorCode}.
+     * @return mapped {@link ErrorCode}.
+     */
+    public static ErrorCode fromException(Exception exception) {
+        // IOException are recoverable (with exponential backoff)
+        if (exception instanceof IOException) {
+            return ErrorCode.IO_EXCEPTION;
+        } else {
+            return ErrorCode.UNKNOWN;
+        }
+    }
+
     public enum Category {
         FATAL,          // Abort session as soon as possible
         RECOVERABLE,    // Still possible to recover the session by either rebinding or providing the required information.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java b/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java
index 272ead6c89..401a01f9af 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/ObjectServer.java
@@ -19,6 +19,10 @@
 import android.content.Context;
 import android.content.pm.PackageInfo;
 
+import java.io.File;
+import java.io.IOException;
+import java.util.Locale;
+
 import io.realm.internal.Keep;
 
 /**
@@ -41,7 +45,27 @@ public static void init(Context context) {
         // init the "sync_manager.cpp" metadata Realm, this is also needed later, when re try
         // to schedule a client reset. in realm-java#master this is already done, when initialising
         // the RealmFileUserStore (not available now on releases)
-        SyncManager.nativeInitializeSyncManager(context.getFilesDir().getPath());
+        if (SyncManager.Debug.separatedDirForSyncManager) {
+            try {
+                // Files.createTempDirectory is not available on JDK 6.
+                File dir = File.createTempFile("remote_sync_", "_" + android.os.Process.myPid(),
+                        context.getFilesDir());
+                if (!dir.delete()) {
+                    throw new IllegalStateException(String.format(Locale.US,
+                            "Temp file '%s' cannot be deleted.", dir.getPath()));
+                }
+                if (!dir.mkdir()) {
+                    throw new IllegalStateException(String.format(Locale.US,
+                            "Directory '%s' for SyncManager cannot be created. ",
+                            dir.getPath()));
+                }
+                SyncManager.nativeInitializeSyncManager(dir.getPath());
+            } catch (IOException e) {
+                throw new IllegalStateException(e);
+            }
+        } else {
+            SyncManager.nativeInitializeSyncManager(context.getFilesDir().getPath());
+        }
 
         // Configure default UserStore
         UserStore userStore = new RealmFileUserStore();
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ObjectServerError.java b/realm/realm-library/src/objectServer/java/io/realm/ObjectServerError.java
index 90cdc9c65b..b79eff13b1 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/ObjectServerError.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/ObjectServerError.java
@@ -16,6 +16,8 @@
 
 package io.realm;
 
+import javax.annotation.Nullable;
+
 import io.realm.internal.Util;
 
 /**
@@ -61,7 +63,7 @@ public ObjectServerError(ErrorCode errorCode, Throwable exception) {
      * @param errorMessage detailed error message.
      * @param exception underlying exception if the error was caused by this.
      */
-    public ObjectServerError(ErrorCode errorCode, String errorMessage, Throwable exception) {
+    public ObjectServerError(ErrorCode errorCode, @Nullable String errorMessage, @Nullable Throwable exception) {
         this.error = errorCode;
         this.errorMessage = errorMessage;
         this.exception = exception;
@@ -74,7 +76,7 @@ public ObjectServerError(ErrorCode errorCode, String errorMessage, Throwable exc
      * @param title Title for this type of error.
      * @param hint a hint for resolving the error.
      */
-    public ObjectServerError(ErrorCode errorCode, String title, String hint) {
+    public ObjectServerError(ErrorCode errorCode, String title, @Nullable String hint) {
         this(errorCode, (hint != null) ? title + " : " + hint : title, (Throwable) null);
     }
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java b/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java
new file mode 100644
index 0000000000..9d1acc3527
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/PermissionManager.java
@@ -0,0 +1,1386 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.os.Handler;
+
+import java.io.Closeable;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Deque;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+
+import io.realm.internal.OsRealmConfig;
+import io.realm.internal.Util;
+import io.realm.internal.permissions.BasePermissionApi;
+import io.realm.internal.permissions.ManagementModule;
+import io.realm.internal.permissions.PermissionChange;
+import io.realm.internal.permissions.PermissionModule;
+import io.realm.internal.permissions.PermissionOfferResponse;
+import io.realm.log.RealmLog;
+import io.realm.permissions.Permission;
+import io.realm.permissions.PermissionOffer;
+import io.realm.permissions.PermissionRequest;
+
+
+/**
+ * Helper class for interacting with Realm Object Server permissions for a {@link SyncUser}.
+ * <p>
+ * Current functionality supported by this class:
+ * <ul>
+ *     <li>List users existing permissions.</li>
+ *     <li>List default permissions.</li>
+ *     <li>Modify permissions for a Realm.</li>
+ *     <li>Create a permission offer that can be sent to others.</li>
+ *     <li>Accept permission offers sent by other users.</li>
+ * </ul>
+ * <p>
+ * This class depends on underlying Realms, so all data coming from this class is thread-confined and must be
+ * closed after use to avoid leaking resources.
+ *
+ * @see <a href="https://realm.io/docs/java/latest/#access-control">How to work with Access Controls</a>
+ */
+public class PermissionManager implements Closeable {
+
+    // Reference counted cache equivalent to how Realm instances work.
+    private static Map<String, ThreadLocal<Cache>> cache = new HashMap<>();
+
+    private static class Cache {
+        public PermissionManager pm = null;
+        public Integer instanceCounter = Integer.valueOf(0);
+    }
+
+    private static final Object cacheLock = new Object();
+
+    /**
+     * Return a thread confined, reference counted instance of the PermissionManager.
+     *
+     * @param syncUser user to create the PermissionManager for.
+     * @return a thread confined PermissionManager instance for the provided user.
+     */
+    static PermissionManager getInstance(SyncUser syncUser) {
+        synchronized (cacheLock) {
+            String userId = syncUser.getIdentity();
+            ThreadLocal<Cache> threadLocalCache = cache.get(userId);
+            if (threadLocalCache == null) {
+                threadLocalCache = new ThreadLocal<Cache>() {
+                    @Override
+                    protected Cache initialValue() {
+                        return new Cache();
+                    }
+                };
+                cache.put(userId, threadLocalCache);
+            }
+            Cache c = threadLocalCache.get();
+            if (c.instanceCounter == 0) {
+                c.pm = new PermissionManager(syncUser);
+            }
+            c.instanceCounter++;
+            return c.pm;
+        }
+    }
+
+    private enum RealmType {
+        DEFAULT_PERMISSION_REALM("__wildcardpermissions", true),
+        PERMISSION_REALM("__permission", false),
+        MANAGEMENT_REALM("__management", false);
+
+        private final String name;
+        private final boolean globalRealm;
+
+        RealmType(String realmName, boolean globalRealm) {
+            this.name = realmName;
+            this.globalRealm = globalRealm;
+        }
+
+        public String getName() {
+            return name;
+        }
+
+        public boolean isGlobalRealm() {
+            return globalRealm;
+        }
+    }
+
+    private final SyncUser user;
+
+    // Used to track the lifecycle of the PermissionManager
+    private RealmAsyncTask managementRealmOpenTask;
+    private RealmAsyncTask permissionRealmOpenTask;
+    private RealmAsyncTask defaultPermissionRealmOpenTask;
+    private boolean openInProgress = false;
+    private boolean closed;
+
+    private final long threadId;
+    private Handler handler = new Handler();
+    final SyncConfiguration managementRealmConfig;
+    final SyncConfiguration permissionRealmConfig;
+    final SyncConfiguration defaultPermissionRealmConfig;
+    private Realm permissionRealm;
+    private Realm managementRealm;
+    private Realm defaultPermissionRealm;
+
+    // Task list used to queue tasks until the underlying Realms are done opening (or failed doing so).
+    private Deque<PermissionManagerTask> delayedTasks = new LinkedList<>();
+
+    // List of tasks that are being processed. Used to keep strong references for listeners to work.
+    // The task must remove itself from this list once it either completes
+    // or fails.
+    private List<RealmAsyncTask> activeTasks = new ArrayList<>();
+
+    // Object Server Errors might be reported on another thread than the one running this PermissionManager
+    // In order to prevent race conditions, all blocks of code that read/write these errors should do
+    // so while holding the errorLock
+    private final Object errorLock = new Object();
+    private volatile ObjectServerError permissionRealmError = null;
+    private volatile ObjectServerError managementRealmError = null;
+    private volatile ObjectServerError defaultPermissionRealmError = null;
+
+    // A client reset was encountered in one of the Realms.
+    // This has invalidated the PermissionManager and it must be closed as soon as possible.
+    // This flag purely used to be able to send a proper error message to users.
+    private boolean clientReset = false;
+
+
+    // Cached result of the permission query. This will be filled, once the first PermissionAsyncTask has loaded
+    // the result.
+    private RealmResults<Permission> userPermissions;
+    private RealmResults<Permission> defaultPermissions;
+    private RealmResults<PermissionOffer> offers;
+
+    /**
+     * Creates a PermissionManager for the given user.
+     *
+     * This class is thread confined, so thread safety is not a concern since all internal
+     * communication is routed through the original Handler thread.
+     *
+     * @param user user to create manager for.
+     */
+    private PermissionManager(SyncUser user) {
+        this.user = user;
+        threadId = Thread.currentThread().getId();
+        managementRealmConfig = new SyncConfiguration.Builder(
+                user, getRealmUrl(RealmType.MANAGEMENT_REALM, user.getAuthenticationUrl()))
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        synchronized (errorLock) {
+                            managementRealmError = error;
+                        }
+                    }
+                })
+                .modules(new ManagementModule())
+                .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
+                .build();
+
+        permissionRealmConfig = new SyncConfiguration.Builder(
+                user, getRealmUrl(RealmType.PERMISSION_REALM, user.getAuthenticationUrl()))
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        RealmLog.error("Error in __permission:\n" + error.toString());
+                        synchronized (errorLock) {
+                            permissionRealmError = error;
+                        }
+                    }
+                })
+                .modules(new PermissionModule())
+                .waitForInitialRemoteData()
+                .readOnly()
+                .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
+                .build();
+
+        defaultPermissionRealmConfig = new SyncConfiguration.Builder(
+                user, getRealmUrl(RealmType.DEFAULT_PERMISSION_REALM, user.getAuthenticationUrl()))
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        RealmLog.error("Error in __wildcardpermissions:\n" + error.toString());
+                        synchronized (errorLock) {
+                            defaultPermissionRealmError = error;
+                        }
+                    }
+                })
+                .modules(new PermissionModule())
+                .waitForInitialRemoteData()
+                .readOnly()
+                .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
+                .build();
+    }
+
+    /**
+     * Retrieves the list of permissions for all Realms available to this user.
+     *
+     * @param callback callback notified when the permissions are ready. The returned {@link RealmResults} is a fully
+     * live query result, that will be auto-updated like any other {@link RealmResults}.
+     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
+     */
+    public RealmAsyncTask getPermissions(PermissionsCallback callback) {
+        checkIfValid();
+        checkCallbackNotNull(callback);
+        return addTask(new GetPermissionsAsyncTask(this, callback));
+    }
+
+    /**
+     * NOTE: Moved out of the public API until we know for sure how this is going to work.
+     *
+     * Returns default permissions for all Realms. The default permissions are the ones that will be used if no
+     * user specific permissions is in effect.
+     *
+     * @param callback callback notified when the permissions are ready. The returned {@link RealmResults} is a fully
+     * live query result, that will be auto-updated like any other {@link RealmResults}.
+     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
+     */
+    public RealmAsyncTask getDefaultPermissions(PermissionsCallback callback) {
+        checkIfValid();
+        checkCallbackNotNull(callback);
+        return addTask(new GetDefaultPermissionsAsyncTask(this, callback));
+    }
+
+    /**
+     * Applies a given set of permissions to a Realm.
+     * <p>
+     * A {@link PermissionRequest} object encapsulates a description of which users are granted what
+     * {@link io.realm.permissions.AccessLevel}s for which Realm(s).
+     * <p>
+     * Once the request is successfully handled, a {@link Permission} entry is created in each user's
+     * {@link PermissionManager} and can be found using {@link PermissionManager#getPermissions(PermissionsCallback)}.
+     *
+     * @param request request object describing which permissions to grant and to what Realm(s).
+     * @param callback callback when the request either succeeded or failed.
+     * @return async task representing the request. This can be used to cancel it if needed.
+     */
+    public RealmAsyncTask applyPermissions(PermissionRequest request, ApplyPermissionsCallback callback) {
+        checkIfValid();
+        checkCallbackNotNull(callback);
+        return addTask(new ApplyPermissionTask(this, request, callback));
+    }
+
+    /**
+     * Makes a permission offer to users. The offer is represented by an offer token and the permission changes
+     * described in the {@link PermissionOffer} do not take effect until the offer has been accepted by a user
+     * calling {@link #acceptOffer(String, AcceptOfferCallback)}.
+     * <p>
+     * A permission offer can be used as a flexible way of sharing Realms with other users that might not be known at the time
+     * of making the offer as well as enabling sharing across other channels like e-mail. If a specific user should be
+     * granted access, using {@link #applyPermissions(PermissionRequest, ApplyPermissionsCallback)} will be faster and quicker.
+     * <p>
+     * An offer can be accepted by multiple users.
+     *
+     * @param callback callback to be notified with the offer token once it is ready.
+     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
+     * @see <a href="https://realm.io/docs/realm-object-server/#permissions">Permissions description</a> for general
+     * documentation.
+     * @see <a href="https://realm.io/docs/java/latest/#modifying-permissions">Modifying permissions</a> for a more
+     * high level description.
+     */
+    public RealmAsyncTask makeOffer(PermissionOffer offer, MakeOfferCallback callback) {
+        checkIfValid();
+        checkCallbackNotNull(callback);
+        if (offer.isOfferCreated()) {
+            throw new IllegalStateException("Offer has already been created: " + offer);
+        }
+        return addTask(new MakeOfferAsyncTask(this, offer, callback));
+    }
+
+    /**
+     * Accepts a permission offer sent by another user. Once this offer is accepted successfully, the permissions
+     * described by the token will be granted.
+     *
+     * @param offerToken token representing the permission offer.
+     * @param callback with the permission details that were accepted.
+     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
+     */
+    public RealmAsyncTask acceptOffer(String offerToken, AcceptOfferCallback callback) {
+        checkIfValid();
+        checkCallbackNotNull(callback);
+        if (Util.isEmptyString(offerToken)) {
+            throw new IllegalArgumentException("Non-empty 'offerToken' required.");
+        }
+        return addTask(new AcceptOfferAsyncTask(this, offerToken, callback));
+    }
+
+    /**
+     * Revokes an existing offer. This will prevent any other users from accepting it. Users that already accepted it,
+     * will not be affected. Revocation cannot happen until the device has talked to the server. The callback will
+     * not be notified until this has happened.
+     *
+     * @param offerToken token that should be revoked.
+     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
+     */
+    public RealmAsyncTask revokeOffer(String offerToken, RevokeOfferCallback callback) {
+        checkIfValid();
+        checkCallbackNotNull(callback);
+        return addTask(new RevokeOfferAsyncTask(this, offerToken, callback));
+    }
+
+    /**
+     * Returns the list of offers created by this user. These offers can be revoked again by calling
+     * {@link #revokeOffer(String, RevokeOfferCallback)} or sent to other users by sending the
+     * {@link PermissionOffer#getToken()}.
+     *
+     * @return {@link RealmAsyncTask} that can be used to cancel the task if needed.
+     */
+    public RealmAsyncTask getCreatedOffers(OffersCallback callback) {
+        checkIfValid();
+        checkCallbackNotNull(callback);
+        return addTask(new GetOffersAsyncTask(this, callback));
+    }
+
+    // Queue the task if the underlying Realms are not ready yet, otherwise
+    // start the task by sending it to this thread handler. This is done
+    // in order to be able to provide the user with a RealmAsyncTask representation
+    // of the work being done.
+    private RealmAsyncTask addTask(PermissionManagerTask task) {
+        if (isReady()) {
+            activateTask(task);
+        } else {
+            delayTask(task);
+            openRealms();
+        }
+
+        return task;
+    }
+
+    // Park the task until all underlying Realms are ready
+    private void delayTask(PermissionManagerTask task) {
+        delayedTasks.add(task);
+    }
+
+    // Run any tasks that were delayed while the underlying Realms were being opened.
+    // PRECONDITION: Underlying Realms are no longer in the process of being opened.
+    private void runDelayedTasks() {
+        for (PermissionManagerTask delayedTask : delayedTasks) {
+            activateTask(delayedTask);
+        }
+        delayedTasks.clear();
+    }
+
+    // Activate a task. All tasks are controlled by the Handler in order to make it asynchronous.
+    // PRECONDITION: Underlying Realms are no longer in the process of being opened.
+    private void activateTask(PermissionManagerTask task) {
+        activeTasks.add(task);
+        handler.post(task);
+    }
+
+    // Open all underlying Realms asynchronously. Once they are all ready, all tasks added in the meantime are
+    // started. Any error will be reported through the `Callback.onError` callback if the Realms failed to open
+    // correctly.
+    private void openRealms() {
+        if (!openInProgress) {
+            openInProgress = true;
+            managementRealmOpenTask = Realm.getInstanceAsync(managementRealmConfig, new Realm.Callback() {
+                @Override
+                public void onSuccess(Realm realm) {
+                    managementRealm = realm;
+                    managementRealmOpenTask = null;
+                    checkIfRealmsAreOpenedAndRunDelayedTasks();
+                }
+
+                @Override
+                public void onError(Throwable exception) {
+                    synchronized (errorLock) {
+                        managementRealmError = new ObjectServerError(ErrorCode.UNKNOWN, exception);
+                        managementRealmOpenTask = null;
+                        checkIfRealmsAreOpenedAndRunDelayedTasks();
+                    }
+                }
+            });
+            permissionRealmOpenTask = Realm.getInstanceAsync(permissionRealmConfig, new Realm.Callback() {
+                @Override
+                public void onSuccess(Realm realm) {
+                    permissionRealm = realm;
+                    permissionRealmOpenTask = null;
+                    checkIfRealmsAreOpenedAndRunDelayedTasks();
+                }
+
+                @Override
+                public void onError(Throwable exception) {
+                    synchronized (errorLock) {
+                        permissionRealmError = new ObjectServerError(ErrorCode.UNKNOWN, exception);
+                        permissionRealmOpenTask = null;
+                        checkIfRealmsAreOpenedAndRunDelayedTasks();
+                    }
+                }
+            });
+            defaultPermissionRealmOpenTask = Realm.getInstanceAsync(defaultPermissionRealmConfig, new Realm.Callback() {
+                @Override
+                public void onSuccess(Realm realm) {
+                    defaultPermissionRealm = realm;
+                    defaultPermissionRealmOpenTask = null;
+                    checkIfRealmsAreOpenedAndRunDelayedTasks();
+                }
+
+                @Override
+                public void onError(Throwable exception) {
+                    synchronized (errorLock) {
+                        defaultPermissionRealmError = new ObjectServerError(ErrorCode.UNKNOWN, exception);
+                        defaultPermissionRealmOpenTask = null;
+                        checkIfRealmsAreOpenedAndRunDelayedTasks();
+                    }
+                }
+            });
+        }
+    }
+
+    private void checkIfRealmsAreOpenedAndRunDelayedTasks() {
+        synchronized (errorLock) {
+            if ((permissionRealm != null || permissionRealmError != null)
+                && (defaultPermissionRealm != null || defaultPermissionRealmError != null)
+                && (managementRealm != null || managementRealmError != null)) {
+                openInProgress = false;
+                runDelayedTasks();
+            }
+        }
+    }
+
+    private void checkCallbackNotNull(PermissionManagerBaseCallback callback) {
+        if (callback == null) {
+            throw new IllegalArgumentException("Non-null 'callback' required.");
+        }
+    }
+
+    private boolean isReady() {
+        return managementRealm != null && permissionRealm != null; // && defaultPermissionRealm != null;
+    }
+
+    private void checkIfValid() {
+        // Checks if we are in thread that created the PermissionManager.
+        if (threadId != Thread.currentThread().getId()) {
+            throw new IllegalStateException("PermissionManager was accessed from the wrong thread. It can only be " +
+                                            "accessed on the thread it was created on.");
+        }
+
+        if (closed) {
+            throw new IllegalStateException("PermissionManager has been closed. No further actions are possible.");
+        }
+    }
+
+    /**
+     * Closes the PermissionManager as well as any underlying Realms.
+     * Any active tasks in progress will be canceled.
+     */
+    @Override
+    public void close() {
+        checkIfValid();
+
+        // Multiple instances open, just decrement the reference count
+        synchronized (cacheLock) {
+            Cache cache = PermissionManager.cache.get(user.getIdentity()).get();
+            if (cache.instanceCounter > 1) {
+                cache.instanceCounter--;
+                return;
+            }
+
+            // Only one instance open. Do a full close
+            cache.instanceCounter = 0;
+            cache.pm = null;
+        }
+        closed = true;
+        delayedTasks.clear();
+
+        // If Realms are still being opened, abort that task
+        if (managementRealmOpenTask != null) {
+            managementRealmOpenTask.cancel();
+            managementRealmOpenTask = null;
+        }
+        if (permissionRealmOpenTask != null) {
+            permissionRealmOpenTask.cancel();
+            permissionRealmOpenTask = null;
+        }
+        if (defaultPermissionRealmOpenTask != null) {
+            defaultPermissionRealmOpenTask.cancel();
+            defaultPermissionRealmOpenTask = null;
+        }
+
+        // If Realms are opened. Close them.
+        if (managementRealm != null) {
+            managementRealm.close();
+        }
+
+        if (permissionRealm != null) {
+            permissionRealm.close();
+        }
+        if (defaultPermissionRealm != null) {
+            defaultPermissionRealm.close();
+        }
+    }
+
+    /**
+     * Checks if this PermissionManager is closed or not. If it is closed, all methods will report back an error.
+     *
+     * @return {@code true} if the PermissionManager is closed, {@code false} if it is still open.
+     */
+    public boolean isClosed() {
+        // Don't use `checkIfValid()` as it throws because closed might be false.
+        if (threadId != Thread.currentThread().getId()) {
+            throw new IllegalStateException("PermissionManager was accessed from the wrong thread. It can only be " +
+                    "accessed on the thread it was created on.");
+        }
+        return closed;
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        if (!closed) {
+            RealmLog.warn("PermissionManager was not correctly closed before being finalized.");
+        }
+        super.finalize();
+    }
+
+    // Creates the URL to the permission/management Realm based on the authentication URL.
+    private static String getRealmUrl(RealmType type, URL authUrl) {
+        String scheme = "realm";
+        if (authUrl.getProtocol().equalsIgnoreCase("https")) {
+            scheme = "realms";
+        }
+        try {
+            String path = (type.isGlobalRealm() ? "/" : "/~/") + type.getName();
+            return new URI(scheme, authUrl.getUserInfo(), authUrl.getHost(), authUrl.getPort(), path, null, null).toString();
+        } catch (URISyntaxException e) {
+            throw new IllegalArgumentException("Could not create URL to the " + type + " Realm", e);
+        }
+    }
+
+    // Task responsible for loading the Permissions result and returning it to the user.
+    // The Permission result is not considered available until the query has completed.
+    private class GetPermissionsAsyncTask extends PermissionManagerTask<RealmResults<Permission>> {
+
+        private final PermissionsCallback callback;
+        // Prevent permissions from being GC'ed until fully loaded.
+        private RealmResults<Permission> loadingPermissions;
+
+        GetPermissionsAsyncTask(PermissionManager permissionManager, PermissionsCallback callback) {
+            super(permissionManager, callback);
+            this.callback = callback;
+        }
+
+        @Override
+        public void run() {
+            if (checkAndReportInvalidState()) { return; }
+            if (userPermissions != null) {
+                // Permissions already loaded
+                notifyCallbackWithSuccess(userPermissions);
+            } else {
+                // TODO Right now multiple getPermission() calls will result in multiple
+                // queries being executed. The first one to return will be the one returned
+                // by all callbacks.
+                loadingPermissions = permissionRealm.where(Permission.class).findAllAsync();
+                loadingPermissions.addChangeListener(new RealmChangeListener <RealmResults<Permission>>() {
+                    @Override
+                    public void onChange(RealmResults <Permission> loadedPermissions) {
+                        RealmLog.error(String.format("1stCallback: Size: %s, Permissions: %s", loadedPermissions.size(), Arrays.toString(loadedPermissions.toArray())));
+                        // Don't report ready until both __permission and __management Realm are there
+                        if (loadedPermissions.size() > 1) {
+                            loadingPermissions.removeChangeListener(this);
+                            loadingPermissions = null;
+                            if (checkAndReportInvalidState()) { return; }
+                            if (userPermissions == null) {
+                                userPermissions = loadedPermissions;
+                            }
+                            notifyCallbackWithSuccess(userPermissions);
+                        }
+                    }
+                });
+            }
+        }
+
+        void notifyCallbackWithSuccess(RealmResults<Permission> permissions) {
+            try {
+                callback.onSuccess(permissions);
+            } finally {
+                activeTasks.remove(this);
+            }
+        }
+    }
+
+    // Task responsible for loading the Default Permissions result and returning it to the user.
+    // The Permission result is not considered available until the query has completed.
+    private class GetDefaultPermissionsAsyncTask extends PermissionManagerTask<RealmResults<Permission>> {
+
+        private final PermissionsCallback callback;
+        // Prevent permissions from being GC'ed until fully loaded.
+        private RealmResults<Permission> loadingPermissions;
+
+        GetDefaultPermissionsAsyncTask(PermissionManager permissionManager, PermissionsCallback callback) {
+            super(permissionManager, callback);
+            this.callback = callback;
+        }
+
+        @Override
+        public void run() {
+            if (checkAndReportInvalidState()) { return; }
+            if (defaultPermissions != null) {
+                notifyCallbackWithSuccess(defaultPermissions);
+            } else {
+                // Start loading permissions.
+                // TODO Right now multiple getPermission() calls will result in multiple
+                // queries being executed. The first one to return will be the one returned
+                // by all callbacks.
+                loadingPermissions = defaultPermissionRealm.where(Permission.class).findAllAsync();
+                loadingPermissions.addChangeListener(new RealmChangeListener <RealmResults<Permission>>() {
+                    @Override
+                    public void onChange(RealmResults <Permission> loadedPermissions) {
+                        // Wildcard permissions should contain 1 Realm as the default, namely __wildcardpermissions
+                        if (loadedPermissions.size() > 0) {
+                            loadingPermissions.removeChangeListener(this);
+                            if (checkAndReportInvalidState()) { return; }
+                            if (defaultPermissions == null) {
+                                defaultPermissions = loadedPermissions;
+                            }
+                            notifyCallbackWithSuccess(defaultPermissions);
+                        }
+                    }
+                });
+            }
+        }
+
+        void notifyCallbackWithSuccess(RealmResults<Permission> permissions) {
+            try {
+               callback.onSuccess(permissions);
+            } finally {
+                activeTasks.remove(this);
+            }
+        }
+    }
+
+    // Class encapsulating setting a Permission by writing a PermissionChange and waiting for it to
+    // be processed.
+    private class ApplyPermissionTask extends PermissionManagerTask<Void> {
+
+        private final PermissionChange unmanagedChangeRequest;
+        private final ApplyPermissionsCallback callback;
+        private final String changeRequestId;
+        private PermissionChange managedChangeRequest;
+        private RealmAsyncTask transactionTask;
+
+        public ApplyPermissionTask(PermissionManager manager, PermissionRequest request, ApplyPermissionsCallback callback) {
+            super(manager, callback);
+            this.unmanagedChangeRequest = PermissionChange.fromRequest(request);
+            this.changeRequestId = unmanagedChangeRequest.getId();
+            this.callback = callback;
+        }
+
+        @Override
+        public void run() {
+            if (checkAndReportInvalidState()) {
+                return;
+            }
+
+            // Save PermissionChange object. It will be synchronized to the server where it will be processed.
+            Realm.Transaction transaction = new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    if (checkAndReportInvalidState()) { return; }
+                    realm.insertOrUpdate(unmanagedChangeRequest);
+                }
+            };
+
+            // If the PermissionChange was successfully written to Realm, we need to wait for it to be processed.
+            // Register a ChangeListener on the object and wait for the proper response code, which can then be
+            // converted to a proper response to the user.
+            Realm.Transaction.OnSuccess onSuccess = new Realm.Transaction.OnSuccess() {
+                @Override
+                public void onSuccess() {
+                    if (checkAndReportInvalidState()) { return; }
+
+                    // Find PermissionChange object we just added
+                    managedChangeRequest = managementRealm.where(PermissionChange.class)
+                            .equalTo("id", changeRequestId)
+                            .findFirstAsync();
+
+
+                    // Wait for it to be processed
+                    RealmObject.addChangeListener(managedChangeRequest, new RealmChangeListener<PermissionChange>() {
+                        @Override
+                        public void onChange(PermissionChange permissionChange) {
+                            if (checkAndReportInvalidState()) {
+                                RealmObject.removeChangeListener(managedChangeRequest, this);
+                                return;
+                            }
+                            handleServerStatusChanges(permissionChange, new Runnable() {
+                                @Override
+                                public void run() {
+                                    notifyCallbackWithSuccess();
+                                }
+                            });
+                        }
+                    });
+                }
+            };
+
+            // Critical error: The PermissionChange could not be written to the Realm.
+            // Report it back to the user.
+            Realm.Transaction.OnError onError = new Realm.Transaction.OnError() {
+                @Override
+                public void onError(Throwable error) {
+                    if (checkAndReportInvalidState()) { return; }
+                    notifyCallbackWithError(new ObjectServerError(ErrorCode.UNKNOWN, error));
+                }
+            };
+
+            // Run
+            transactionTask = managementRealm.executeTransactionAsync(transaction, onSuccess, onError);
+        }
+
+        void notifyCallbackWithSuccess() {
+            try {
+                callback.onSuccess();
+            } finally {
+                activeTasks.remove(this);
+            }
+        }
+
+        @Override
+        public void cancel() {
+            super.cancel();
+            if (transactionTask != null) {
+                cancel();
+            }
+        }
+    }
+
+    private class MakeOfferAsyncTask extends PermissionManagerTask<String> {
+
+        private final PermissionOffer unmanagedOffer;
+        private final String offerId;
+        private final MakeOfferCallback callback;
+        private PermissionOffer managedOffer;
+        private RealmAsyncTask transactionTask;
+
+        public MakeOfferAsyncTask(PermissionManager permissionManager, PermissionOffer offer, MakeOfferCallback callback) {
+            super(permissionManager, callback);
+            this.unmanagedOffer = offer;
+            this.offerId = offer.getId();
+            this.callback = callback;
+        }
+
+        @Override
+        public void run() {
+            if (checkAndReportInvalidState()) {
+                return;
+            }
+
+            // Save PermissionOffer object. It will be synchronized to the server where it will be processed.
+            Realm.Transaction transaction = new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    if (checkAndReportInvalidState()) { return; }
+                    realm.insertOrUpdate(unmanagedOffer);
+                }
+            };
+
+            // If the PermissionOffer was successfully written to Realm, we need to wait for it to be processed.
+            // Register a ChangeListener on the object and wait for the proper response code, which can then be
+            // converted to a proper response to the user.
+            Realm.Transaction.OnSuccess onSuccess = new Realm.Transaction.OnSuccess() {
+                @Override
+                public void onSuccess() {
+                    if (checkAndReportInvalidState()) { return; }
+
+                    // Find PermissionChange object we just added
+                    // Wait for it to be processed
+                    managedOffer = managementRealm.where(PermissionOffer.class).equalTo("id", offerId).findFirstAsync();
+                    RealmObject.addChangeListener(managedOffer, new RealmChangeListener<PermissionOffer>() {
+                        @Override
+                        public void onChange(final PermissionOffer permissionOffer) {
+                            if (checkAndReportInvalidState()) {
+                                RealmObject.removeChangeListener(managedOffer, this);
+                                return;
+                            }
+                            handleServerStatusChanges(permissionOffer, new Runnable() {
+                                @Override
+                                public void run() {
+                                    notifyCallbackWithSuccess(permissionOffer.getToken());
+                                }
+                            });
+                        }
+                    });
+                }
+            };
+
+            // Critical error: The PermissionChange could not be written to the Realm.
+            // Report it back to the user.
+            Realm.Transaction.OnError onError = new Realm.Transaction.OnError() {
+                @Override
+                public void onError(Throwable error) {
+                    if (checkAndReportInvalidState()) { return; }
+                    notifyCallbackWithError(new ObjectServerError(ErrorCode.UNKNOWN, error));
+                }
+            };
+
+            // Run
+            transactionTask = managementRealm.executeTransactionAsync(transaction, onSuccess, onError);
+        }
+
+        void notifyCallbackWithSuccess(String token) {
+            try {
+                callback.onSuccess(token);
+            } finally {
+                activeTasks.remove(this);
+            }
+        }
+
+        @Override
+        public void cancel() {
+            super.cancel();
+            if (transactionTask != null) {
+                transactionTask.cancel();
+                transactionTask = null;
+            }
+        }
+    }
+
+    private class AcceptOfferAsyncTask extends PermissionManagerTask<Permission> {
+
+        private final PermissionOfferResponse unmanagedResponse;
+        private final String responseId;
+        private final AcceptOfferCallback callback;
+        private PermissionOfferResponse managedResponse;
+        private RealmAsyncTask transactionTask;
+        public RealmResults<Permission> grantedPermissionResults;
+
+        public AcceptOfferAsyncTask(PermissionManager permissionManager, String offerToken, AcceptOfferCallback callback) {
+            super(permissionManager, callback);
+            this.unmanagedResponse = new PermissionOfferResponse(offerToken);
+            this.responseId = unmanagedResponse.getId();
+            this.callback = callback;
+        }
+
+        @Override
+        public void run() {
+            if (checkAndReportInvalidState()) {
+                return;
+            }
+
+            // Save response object. It will be synchronized to the server where it will be processed.
+            Realm.Transaction transaction = new Realm.Transaction() {
+                @Override
+                public void execute(Realm realm) {
+                    if (checkAndReportInvalidState()) { return; }
+                    realm.insertOrUpdate(unmanagedResponse);
+                }
+            };
+
+            // If the response was successfully written to Realm, we need to wait for it to be processed.
+            // Register a ChangeListener on the object and wait for the proper response code, which can then be
+            // converted to a proper response to the user.
+            Realm.Transaction.OnSuccess onSuccess = new Realm.Transaction.OnSuccess() {
+                @Override
+                public void onSuccess() {
+                    if (checkAndReportInvalidState()) { return; }
+
+                    // Find PermissionOffer object we just added
+                    // Wait for it to be processed
+                    managedResponse = managementRealm.where(PermissionOfferResponse.class).equalTo("id", responseId).findFirstAsync();
+                    RealmObject.addChangeListener(managedResponse, new RealmChangeListener<PermissionOfferResponse>() {
+                        @Override
+                        public void onChange(final PermissionOfferResponse response) {
+                            if (checkAndReportInvalidState()) {
+                                RealmObject.removeChangeListener(managedResponse, this);
+                                return;
+                            }
+                            handleServerStatusChanges(response, new Runnable() {
+                                @Override
+                                public void run() {
+                                    grantedPermissionResults = permissionRealm.where(Permission.class).equalTo("path", response.getPath()).findAllAsync();
+                                    grantedPermissionResults.addChangeListener(new RealmChangeListener<RealmResults<Permission>>() {
+                                        @Override
+                                        public void onChange(RealmResults<Permission> permissions) {
+                                            if (!permissions.isEmpty()) {
+                                                grantedPermissionResults.removeChangeListener(this);
+                                                //noinspection ConstantConditions
+                                                notifyCallbackWithSuccess(managedResponse.getRealmUrl(), permissions.first());
+                                            }
+                                        }
+                                    });
+                                }
+                            });
+                        }
+                    });
+                }
+            };
+
+            // Critical error: The PermissionChange could not be written to the Realm.
+            // Report it back to the user.
+            Realm.Transaction.OnError onError = new Realm.Transaction.OnError() {
+                @Override
+                public void onError(Throwable error) {
+                    if (checkAndReportInvalidState()) { return; }
+                    notifyCallbackWithError(new ObjectServerError(ErrorCode.UNKNOWN, error));
+                }
+            };
+
+            // Run
+            transactionTask = managementRealm.executeTransactionAsync(transaction, onSuccess, onError);
+        }
+
+        void notifyCallbackWithSuccess(String url, Permission permission) {
+            try {
+                callback.onSuccess(url, permission);
+            } finally {
+                activeTasks.remove(this);
+            }
+        }
+
+        @Override
+        public void cancel() {
+            super.cancel();
+            if (transactionTask != null) {
+                transactionTask.cancel();
+                transactionTask = null;
+            }
+        }
+    }
+
+    // Class encapsulating all async tasks exposed by the PermissionManager.
+    // Made package protected instead of private to facilitate testing
+    // IMPORTANT:
+    // - All subclasses are responsible for removing themselves from the activeTaskList when done.
+    // - All callbacks should start by checking `if (checkAndReportInvalidState()) { return; }`
+    //   This will abort the task if it was canceled or failed. It will also remove the task from the activeTaskList.
+    abstract static class PermissionManagerTask<T> implements RealmAsyncTask, Runnable {
+
+        private final PermissionManagerBaseCallback callback;
+        private final PermissionManager permissionManager;
+        private volatile boolean canceled = false;
+        private static final String ERROR_MESSAGE_CLIENT_RESET = "The PermissionManager " +
+                "has been invalidated due to a server conflict. No further tasks can be scheduled. " +
+                "The app needs to be restarted to allow the PermissionManager to work again.";
+
+        public PermissionManagerTask(PermissionManager permissionManager, PermissionManagerBaseCallback callback) {
+            this.callback = callback;
+            this.permissionManager = permissionManager;
+        }
+
+        @Override
+        public abstract void run();
+
+        @Override
+        public void cancel() {
+            canceled = true;
+        }
+
+        @Override
+        public boolean isCancelled() {
+            return canceled;
+        }
+
+        /**
+         * Checks if we are in a state where we are not allowed to continue executing.
+         * If an invalid state is encountered, it will be reported to the error callback.
+         *
+         * This method will return {@code true} if an invalid state was encountered, {@code false}
+         * if it looks ok to continue.
+
+         * @return {@code true} if in a invalid state, {@code false} if in a valid one.
+         */
+        protected final boolean checkAndReportInvalidState() {
+            if (isCancelled()) {
+                permissionManager.activeTasks.remove(this);
+                return true;
+            }
+            // Closed check need to work around thread confinement
+            if (permissionManager.closed) {
+                ObjectServerError error = new ObjectServerError(ErrorCode.UNKNOWN,
+                        new IllegalStateException("PermissionManager has been closed"));
+                notifyCallbackWithError(error); // This will remove the task from the task list
+                return true;
+            }
+            if (permissionManager.clientReset) {
+                ObjectServerError error = new ObjectServerError(ErrorCode.CLIENT_RESET, ERROR_MESSAGE_CLIENT_RESET);
+                notifyCallbackWithError(error);
+                return true;
+            }
+
+            // We are juggling two different Realms. If only one fail, expose that error directly.
+            // Otherwise try to sensible join the two error messages before returning it to the user.
+            // TODO: Should we expose the underlying Realm errors directly? What else would make sense?
+            boolean managementErrorHappened;
+            boolean permissionErrorHappened;
+            boolean defaultPermissionErrorHappened;
+            ObjectServerError managementError;
+            ObjectServerError permissionError;
+            ObjectServerError defaultPermissionError;
+            synchronized (permissionManager.errorLock) {
+                // Only hold lock while making a safe copy of current error state
+                managementErrorHappened = (permissionManager.managementRealmError != null);
+                permissionErrorHappened = (permissionManager.permissionRealmError != null);
+                defaultPermissionErrorHappened = (permissionManager.defaultPermissionRealmError != null);
+                managementError = permissionManager.managementRealmError;
+                permissionError = permissionManager.permissionRealmError;
+                defaultPermissionError = permissionManager.defaultPermissionRealmError;
+            }
+
+            // Everything seems valid
+            if (!permissionErrorHappened && !managementErrorHappened) {// && !defaultPermissionErrorHappened) {
+                return false;
+            }
+
+            // Handle Client Reset if it happened in any of the Realms.
+            // A Client Reset is a fatal error for the PermissionManager, so all current and
+            // future tasks will exit as soon as possible after this event happened and report it
+            // through the error callback. Only action a user can take is to close the
+            // PermissionManager and re-open it again. Some data might be lost (like permission
+            // offers not yet processed). This is currently unavoidable.
+            // TODO: Eventually we might be able to recover the permission manager from this event
+            // but it will require some serious task management as we would need to do a full
+            // close, reschedule all tasks, and re-open behind users back. This is out of scope for
+            // now.
+            if (managementErrorHappened && managementError instanceof ClientResetRequiredError) {
+                ClientResetRequiredError cr = (ClientResetRequiredError) managementError;
+                permissionManager.managementRealm.close();
+                cr.executeClientReset();
+                permissionManager.clientReset = true;
+            }
+
+            if (permissionErrorHappened && permissionError instanceof ClientResetRequiredError) {
+                ClientResetRequiredError cr = (ClientResetRequiredError) permissionError;
+                permissionManager.permissionRealm.close();
+                cr.executeClientReset();
+                permissionManager.clientReset = true;
+            }
+
+            if (defaultPermissionErrorHappened && defaultPermissionError instanceof ClientResetRequiredError) {
+                ClientResetRequiredError cr = (ClientResetRequiredError) defaultPermissionError;
+                permissionManager.defaultPermissionRealm.close();
+                cr.executeClientReset();
+                permissionManager.clientReset = true;
+            }
+
+            // Handle errors
+            Map<String, ObjectServerError> errors = new LinkedHashMap<>();
+            if (permissionManager.clientReset) {
+                errors.put("ClientReset", new ObjectServerError(ErrorCode.CLIENT_RESET, ERROR_MESSAGE_CLIENT_RESET));
+            } else {
+                if (managementErrorHappened) { errors.put("Management Realm", managementError); }
+                if (permissionErrorHappened) { errors.put("Permission Realm", permissionError); }
+                if (defaultPermissionErrorHappened) { errors.put("Default Permission Realm", defaultPermissionError); }
+            }
+            notifyCallbackWithError(combineRealmErrors(errors)); // This will remove the task from the task list
+
+            return true;
+        }
+
+        /**
+         * Handle the status change from ROS and either call error or success callbacks.
+         */
+        protected void handleServerStatusChanges(BasePermissionApi obj, Runnable onSuccessDelegate) {
+            Integer statusCode = obj.getStatusCode();
+            if (statusCode != null) {
+                RealmObject.removeAllChangeListeners(obj);
+                if (statusCode > 0) {
+                    ErrorCode errorCode = ErrorCode.fromInt(statusCode);
+                    String errorMsg = obj.getStatusMessage();
+                    ObjectServerError error = new ObjectServerError(errorCode, errorMsg);
+                    notifyCallbackWithError(error);
+                } else if (statusCode == 0) {
+                    onSuccessDelegate.run();
+                } else {
+                    ErrorCode errorCode = ErrorCode.UNKNOWN;
+                    String errorMsg = "Illegal status code: " + statusCode;
+                    ObjectServerError error = new ObjectServerError(errorCode, errorMsg);
+                    notifyCallbackWithError(error);
+                }
+            }
+        }
+
+        protected final void notifyCallbackWithError(ObjectServerError e) {
+            RealmLog.debug("Error happened in PermissionManager for %s: %s",
+                    permissionManager.user.getIdentity(), e.toString());
+            try {
+                callback.onError(e);
+            } finally {
+                permissionManager.activeTasks.remove(this);
+            }
+        }
+
+        // Combine error messages. If they have the same ErrorCode, it will be re-used, otherwise
+        // we are forced to report back UNKNOWN as error code. The real error codes
+        // will be always part of the exception message.
+        private ObjectServerError combineRealmErrors(Map<String, ObjectServerError> errors) {
+
+            String errorMsg = combineErrorMessage(errors);
+            ErrorCode errorCode = combineErrorCodes(errors);
+
+            return new ObjectServerError(errorCode, errorMsg);
+        }
+
+        // Combine the text based error message from two ObjectServerErrrors.
+        private String combineErrorMessage(Map<String, ObjectServerError> errors) {
+            boolean multipleErrors = errors.size() > 1;
+            StringBuilder errorMsg = new StringBuilder(multipleErrors ? "Multiple errors occurred: " : "Error occurred in Realm: ");
+            for (Map.Entry<String, ObjectServerError> entry : errors.entrySet()) {
+                errorMsg.append('\n');
+                errorMsg.append(entry.getKey());
+                errorMsg.append('\n');
+                errorMsg.append(entry.getValue().toString());
+            }
+            return errorMsg.toString();
+        }
+
+        private ErrorCode combineErrorCodes(Map<String, ObjectServerError> errors) {
+            ErrorCode finalErrorCode = null;
+            for (ObjectServerError error : errors.values()) {
+                ErrorCode errorCode = error.getErrorCode();
+                if (finalErrorCode == null) {
+                    finalErrorCode = errorCode;
+                    continue;
+                }
+                if (errorCode == finalErrorCode) {
+                    continue;
+                }
+
+                // Multiple error codes. No good way to report this.
+                // The real error codes will still be in the error text.
+                finalErrorCode = ErrorCode.UNKNOWN;
+                break;
+            }
+            return finalErrorCode;
+        }
+
+    }
+
+    // Task responsible for loading the Permissions result and returning it to the user.
+    // The Permission result is not considered available until the query has completed.
+    private class GetOffersAsyncTask extends PermissionManagerTask<RealmResults<Permission>> {
+
+        private final OffersCallback callback;
+        // Prevent permissions from being GC'ed until fully loaded.
+        private RealmResults<PermissionOffer> loadingOffers;
+
+        GetOffersAsyncTask(PermissionManager permissionManager, OffersCallback callback) {
+            super(permissionManager, callback);
+            this.callback = callback;
+        }
+
+        @Override
+        public void run() {
+            if (checkAndReportInvalidState()) { return; }
+            if (offers != null) {
+                notifyCallbackWithSuccess(offers);
+            } else {
+                // We only want offers that have been created.
+                loadingOffers = managementRealm.where(PermissionOffer.class)
+                        .equalTo("statusCode", 0)
+                        .findAllAsync();
+                loadingOffers.addChangeListener(new RealmChangeListener<RealmResults<PermissionOffer>>() {
+                    @Override
+                    public void onChange(RealmResults<PermissionOffer> loadedOffers) {
+                        loadedOffers.removeChangeListener(this);
+                        if (checkAndReportInvalidState()) { return; }
+                        if (offers == null) {
+                            offers = loadedOffers;
+                        }
+                        notifyCallbackWithSuccess(offers);
+                    }
+                });
+            }
+        }
+
+        void notifyCallbackWithSuccess(RealmResults<PermissionOffer> permissions) {
+            try {
+                callback.onSuccess(permissions);
+            } finally {
+                activeTasks.remove(this);
+            }
+        }
+    }
+
+    private class RevokeOfferAsyncTask extends PermissionManagerTask<Permission> {
+
+        private final String offerToken;
+        private final RevokeOfferCallback callback;
+        private RealmResults<PermissionOffer> matchingOffers;
+
+        public RevokeOfferAsyncTask(PermissionManager permissionManager, String offerToken, RevokeOfferCallback callback) {
+            super(permissionManager, callback);
+            this.offerToken = offerToken;
+            this.callback = callback;
+        }
+
+        @Override
+        public void run() {
+            if (checkAndReportInvalidState()) {
+                return;
+            }
+            matchingOffers = managementRealm.where(PermissionOffer.class)
+                    .equalTo("token", offerToken)
+                    .findAllAsync();
+            matchingOffers.addChangeListener(new RealmChangeListener<RealmResults<PermissionOffer>>() {
+                @Override
+                public void onChange(final RealmResults<PermissionOffer> offers) {
+                    if (checkAndReportInvalidState()) { return; }
+                    if (!offers.isEmpty()) {
+                        managementRealm.executeTransactionAsync(new Realm.Transaction() {
+                            @Override
+                            public void execute(Realm realm) {
+                                if (checkAndReportInvalidState()) { return; }
+                                // Make 100% sure the offer is still in the Realm.
+                                // It could have been deleted between querying for it and the
+                                // transaction running. We will still call OnSuccess if the
+                                // offer was removed by someone else.
+                                RealmResults<PermissionOffer> offers = realm.where(PermissionOffer.class)
+                                        .equalTo("token", offerToken)
+                                        .findAll();
+                                if (!offers.isEmpty()) {
+                                    offers.deleteAllFromRealm();
+                                }
+                            }
+                        }, new Realm.Transaction.OnSuccess() {
+                            @Override
+                            public void onSuccess() {
+                                // Don't notify user about success before changes have been uploaded to the server.
+                                matchingOffers.removeAllChangeListeners();
+                                if (checkAndReportInvalidState()) { return; }
+                                final SyncSession session = SyncManager.getSession(managementRealmConfig);
+                                session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+                                    @Override
+                                    public void onChange(Progress progress) {
+                                        if (progress.isTransferComplete()) {
+                                            session.removeProgressListener(this);
+                                            handler.post(new Runnable() {
+                                                @Override
+                                                public void run() {
+                                                    if (checkAndReportInvalidState()) { return; }
+                                                    notifyCallbackWithSuccess();
+                                                }
+                                            });
+                                        }
+                                    }
+                                });
+                            }
+                        }, new Realm.Transaction.OnError() {
+                            @Override
+                            public void onError(Throwable error) {
+                                matchingOffers.removeAllChangeListeners();
+                                notifyCallbackWithError(new ObjectServerError(ErrorCode.UNKNOWN, error));
+
+                            }
+                        });
+                    }
+                }
+            });
+        }
+
+        void notifyCallbackWithSuccess() {
+            try {
+                callback.onSuccess();
+            } finally {
+                activeTasks.remove(this);
+            }
+        }
+    }
+
+    private interface PermissionManagerBaseCallback {
+        /**
+         * Called if an error happened while executing the task. The PermissionManager uses different underlying Realms,
+         * and this error will report errors from all of these Realms combining them as best as possible.
+         * <p>
+         * This means that if all Realms fail with the same error code, {@link ObjectServerError#getErrorCode()} will
+         * return that error code. If the underlying Realms fail for different reasons, {@link ErrorCode#UNKNOWN} will
+         * be returned. {@link ObjectServerError#getErrorMessage()} will always contain the full description of errors
+         * including the specific error code for each underlying Realm that failed.
+         *
+         * @param error error object describing what happened.
+         */
+        void onError(ObjectServerError error);
+    }
+
+    /**
+     * Callback used when loading a set of permissions.
+     */
+    public interface PermissionsCallback extends PermissionManagerBaseCallback {
+        /**
+         * Called when all known permissions are successfully loaded.
+         * <p>
+         * These permissions will continue to synchronize with the server in the background. Register a
+         * {@link RealmChangeListener} to be notified about any further changes.
+         *
+         * @param permissions The set of currently known permissions.
+         */
+        void onSuccess(RealmResults<Permission> permissions);
+    }
+
+    /**
+     * Callback used when modifying or creating new permissions.
+     */
+    public interface ApplyPermissionsCallback extends PermissionManagerBaseCallback {
+        /**
+         * Called when the permissions where successfully modified.
+         */
+        void onSuccess();
+    }
+
+    /**
+     * Callback used when making a permission offer for other users.
+     */
+    public interface MakeOfferCallback extends PermissionManagerBaseCallback {
+        /**
+         * Called when the offer was successfully created.
+         *
+         * @param offerToken token representing the offer that can be sent to other users.
+         */
+        void onSuccess(String offerToken);
+    }
+
+    /**
+     * Callback used when accepting a permission offer.
+     */
+    public interface AcceptOfferCallback extends PermissionManagerBaseCallback {
+        /**
+         * Called when the offer was successfully accepted. This means that this user can now access this Realm.
+         *
+         * @param realmUrl The url pointing to the Realm for which the offer was created.
+         * @param permission The permissions granted.
+         */
+        void onSuccess(String realmUrl, Permission permission);
+    }
+
+    /**
+     * Callback used when loading the list of {@link PermissionOffer}'s created by the user.
+     */
+    public interface OffersCallback extends PermissionManagerBaseCallback {
+        /**
+         * Called when all known offers are successfully loaded.
+         * <p>
+         * These offers will continue to synchronize with the server in the background. Register a
+         * {@link RealmChangeListener} to be notified about any further changes.
+         *
+         * @param offers The set of currently known offers.
+         */
+        void onSuccess(RealmResults<PermissionOffer> offers);
+    }
+
+    /**
+     * Callback used when revoking an existing offer.
+     */
+    public interface RevokeOfferCallback extends PermissionManagerBaseCallback {
+        /**
+         * Called when the offer was successfully revoked successfully modified.
+         */
+        void onSuccess();
+    }
+
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/Progress.java b/realm/realm-library/src/objectServer/java/io/realm/Progress.java
new file mode 100644
index 0000000000..77a6c01f78
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/Progress.java
@@ -0,0 +1,139 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import io.realm.log.RealmLog;
+
+
+/**
+ * Class used to encapsulate progress notifications when either downloading or uploading Realm data.
+ * Each instance of this class is an immutable snapshot of the current progress.
+ * <p>
+ * If the {@link ProgressListener} was registered with {@link ProgressMode#INDEFINITELY}, the progress reported by
+ * {@link #getFractionTransferred()} can both increase and decrease since more changes might be added while
+ * the progres listener is registered. This means it is possible for one notification to report
+ * {@code true} for {@link #isTransferComplete()}, and then on the next event report {@code false}.
+ * <p>
+ * If the {@link ProgressListener} was registered with {@link ProgressMode#CURRENT_CHANGES}, progress can only ever
+ * increase, and once {@link #isTransferComplete()} returns {@code true}, no further events will be generated.
+ *
+ * @see SyncSession#addDownloadProgressListener(ProgressMode, ProgressListener)
+ * @see SyncSession#addUploadProgressListener(ProgressMode, ProgressListener)
+ */
+public class Progress {
+
+    private final long transferredBytes;
+    private final long transferableBytes;
+
+    /**
+     * Creates a snapshot of the current progress when downloading or uploading changes.
+     *
+     * @param transferredBytes number of bytes transferred.
+     * @param transferableBytes total number of bytes that needs to be transferred (including those already transferred).
+     */
+    Progress(long transferredBytes, long transferableBytes) {
+        this.transferredBytes = transferredBytes;
+        this.transferableBytes = transferableBytes;
+    }
+
+    /**
+     * Returns the total number of bytes that has been transferred since the {@link ProgressListener} was added.
+     *
+     * @return the total number of bytes transferred since the {@link ProgressListener} was added.
+     */
+    public long getTransferredBytes() {
+        return transferredBytes;
+    }
+
+    /**
+     * Returns the total number of transferable bytes (bytes that have been transferred + bytes pending transfer).
+     * <p>
+     * If the {@link ProgressListener} is tracking downloads, this number represents the size of the changesets
+     * generated by all other clients using the Realm.
+     * <p>
+     * If the {@link ProgressListener} is tracking uploads, this number represents the size of changesets created
+     * locally.
+     *
+     * @return the total number of bytes that has been transferred + number of bytes still pending transfer.
+     */
+    public long getTransferableBytes() {
+        return transferableBytes;
+    }
+
+    /**
+     * The fraction of bytes transferred out of all transferable bytes. Counting from since the {@link ProgressListener}
+     * was added.
+     *
+     * @return a number between {@code 0.0} and {@code 1.0}, where {@code 0.0} represents that no data has been
+     * transferred yet, and {@code 1.0} that all data has been transferred.
+     */
+    public double getFractionTransferred() {
+        if (transferableBytes == 0) {
+            return 1.0D;
+        } else {
+            double percentage = (double) transferredBytes / (double) transferableBytes;
+            if (percentage > 1.0D) {
+                RealmLog.error("Invalid progress state: %s", this);
+                return 1.0D;
+            } else {
+                return percentage;
+            }
+        }
+    }
+
+    /**
+     * Returns {@code true} when all pending bytes have been transferred.
+     * <p>
+     * If the {@link ProgressListener} was registered with {@link ProgressMode#INDEFINITELY}, this method can return
+     * {@code false} for subsequent events after returning {@code true}.
+     * <p>
+     * If the {@link ProgressListener} was registered with {@link ProgressMode#CURRENT_CHANGES}, when this method
+     * returns {@code true}, no more progress events will be sent.
+     *
+     * @return {@code true} if all changes have been transferred, {@code false} otherwise.
+     */
+    public boolean isTransferComplete() {
+        return transferredBytes >= transferableBytes;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        Progress progress = (Progress) o;
+
+        if (transferredBytes != progress.transferredBytes) return false;
+        return transferableBytes == progress.transferableBytes;
+
+    }
+
+    @Override
+    public int hashCode() {
+        int result = (int) (transferredBytes ^ (transferredBytes >>> 32));
+        result = 31 * result + (int) (transferableBytes ^ (transferableBytes >>> 32));
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "Progress{" +
+                "transferredBytes=" + transferredBytes +
+                ", transferableBytes=" + transferableBytes +
+                '}';
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ProgressListener.java b/realm/realm-library/src/objectServer/java/io/realm/ProgressListener.java
new file mode 100644
index 0000000000..efda3478da
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/ProgressListener.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+
+/**
+ * Interface used when interested in updates on data either being uploaded to or downloaded from
+ * a Realm Object Server.
+ */
+public interface ProgressListener {
+    /**
+     * This method will be called periodically from the underlying Object Server Client responsible
+     * for uploading and downloading changes from the remote Object Server.
+     * <p>
+     * This callback will <i>not</i> happen on the UI thread, but on the worker thread controlling
+     * the Object Server Client. Use {@code Activity.runOnUiThread(Runnable)} or similar to update
+     * any UI elements.
+     * <p>
+     * <pre>
+     * {@code
+     * // Adding an upload progress listener that completes when all known changes have been
+     * // uploaded.
+     * session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+     *   \@Override
+     *    public void onChange(Progress progress) {
+     *      activity.runOnUiThread(new Runnable() {
+     *        \@Override
+     *         public void run() {
+     *           updateProgressBar(progress);
+     *         }
+     *      });
+     *      if (progress.isTransferComplete() {
+     *        session.removeProgressListener(this);
+     *      }
+     *    }
+     * });
+     * }
+     * </pre>
+     *
+     * @param progress an immutable progress change event with information about current progress. This object is thread safe.
+     */
+    void onChange(Progress progress);
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ProgressMode.java b/realm/realm-library/src/objectServer/java/io/realm/ProgressMode.java
new file mode 100644
index 0000000000..f80f63150d
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/ProgressMode.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+/**
+ * Enum describing how to listen to progress changes.
+ */
+public enum ProgressMode {
+    /**
+     * When registering the {@link ProgressListener}, it will record the current size of changes, and will only
+     * continue to report progress updates until those changes have been either downloaded or uploaded. After that
+     * the progress listener will not report any further changes.
+     * <p>
+     * This means that listeners registered in this mode should be done <i>before</i> changes are written to
+     * the Realm.
+     * <p>
+     * Progress reported in this mode will only ever increase.
+     * <p>
+     * This is useful when e.g. reporting progress when downloading a Realm for the first time.
+     */
+    CURRENT_CHANGES,
+
+    /**
+     * A {@link ProgressListener} registered in this mode, will continue to report progress changes, even
+     * if changes are being added after the listener was registered.
+     * <p>
+     * Progress reported in this mode can both increase and decrease, e.g. if large amounts of data is
+     * written after registering the listener.
+     * <p>
+     * This is useful when you want to track if all changes have been uploaded to the server from the device.
+     */
+    INDEFINITELY
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java b/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
index e208131397..255acb0218 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
@@ -20,8 +20,11 @@
 import java.util.Collection;
 import java.util.Collections;
 
+import javax.annotation.Nullable;
+
+
 /**
- * A User Store backed by a Realm file to store user.
+ * A User Store backed by a Realm file to store users.
  */
 public class RealmFileUserStore implements UserStore {
 
@@ -32,13 +35,14 @@
     public void put(SyncUser user) {
         String userJson = user.toJson();
         // create or update token (userJson) using identity
-        nativeUpdateOrCreateUser(user.getIdentity(), userJson, user.getSyncUser().getAuthenticationUrl().toString());
+        nativeUpdateOrCreateUser(user.getIdentity(), userJson, user.getAuthenticationUrl().toString());
     }
 
     /**
      * {@inheritDoc}
      */
     @Override
+    @Nullable
     public SyncUser getCurrent() {
         String userJson = nativeGetCurrentUser();
         return toSyncUserOrNull(userJson);
@@ -48,8 +52,9 @@ public SyncUser getCurrent() {
      * {@inheritDoc}
      */
     @Override
-    public SyncUser get(String identity) {
-        String userJson = nativeGetUser(identity);
+    @Nullable
+    public SyncUser get(String identity, String authUrl) {
+        String userJson = nativeGetUser(identity, authUrl);
         return toSyncUserOrNull(userJson);
     }
 
@@ -57,8 +62,8 @@ public SyncUser get(String identity) {
      * {@inheritDoc}
      */
     @Override
-    public void remove(String identity) {
-        nativeLogoutUser(identity);
+    public void remove(String identity, String authUrl) {
+        nativeLogoutUser(identity, authUrl);
     }
 
     /**
@@ -77,7 +82,16 @@ public void remove(String identity) {
         return Collections.emptyList();
     }
 
-    private static SyncUser toSyncUserOrNull(String userJson) {
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isActive(String identity, String authenticationUrl) {
+        return nativeIsActive(identity, authenticationUrl);
+    }
+
+    @Nullable
+    private static SyncUser toSyncUserOrNull(@Nullable String userJson) {
         if (userJson == null) {
             return null;
         }
@@ -88,11 +102,14 @@ private static SyncUser toSyncUserOrNull(String userJson) {
     protected static native String nativeGetCurrentUser();
 
     // returns json data (token) of the specified user
-    protected static native String nativeGetUser(String identity);
+    @Nullable
+    protected static native String nativeGetUser(String identity, String authUrl);
 
     protected static native String[] nativeGetAllUsers();
 
     protected static native void nativeUpdateOrCreateUser(String identity, String jsonToken, String url);
 
-    protected static native void nativeLogoutUser(String identity);
+    protected static native void nativeLogoutUser(String identity, String authUrl);
+
+    protected static native boolean nativeIsActive(String identity, String authUrl);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
index e2eb671721..61de76ff92 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
@@ -27,13 +27,18 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
+import java.util.Locale;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import javax.annotation.Nullable;
+
 import io.realm.annotations.RealmModule;
 import io.realm.exceptions.RealmException;
+import io.realm.internal.OsRealmConfig;
 import io.realm.internal.RealmProxyMediator;
-import io.realm.internal.SharedRealm;
+import io.realm.internal.Util;
+import io.realm.log.RealmLog;
 import io.realm.rx.RealmObservableFactory;
 import io.realm.rx.RxObservableFactory;
 
@@ -73,28 +78,49 @@
     static final int MAX_FULL_PATH_LENGTH = 256;
     static final int MAX_FILE_NAME_LENGTH = 255;
     private static final char[] INVALID_CHARS = {'<', '>', ':', '"', '/', '\\', '|', '?', '*'};
-
     private final URI serverUrl;
     private final SyncUser user;
     private final SyncSession.ErrorHandler errorHandler;
     private final boolean deleteRealmOnLogout;
+    private final boolean syncClientValidateSsl;
+    @Nullable
+    private final String serverCertificateAssetName;
+    @Nullable
+    private final String serverCertificateFilePath;
+    private final boolean waitForInitialData;
+    private final OsRealmConfig.SyncSessionStopPolicy sessionStopPolicy;
+    private final boolean isPartial;
 
     private SyncConfiguration(File directory,
                                 String filename,
                                 String canonicalPath,
+                                @Nullable
                                 String assetFilePath,
+                                @Nullable
                                 byte[] key,
                                 long schemaVersion,
+                                @Nullable
                                 RealmMigration migration,
                                 boolean deleteRealmIfMigrationNeeded,
-                                SharedRealm.Durability durability,
+                                OsRealmConfig.Durability durability,
                                 RealmProxyMediator schemaMediator,
+                                @Nullable
                                 RxObservableFactory rxFactory,
+                                @Nullable
                                 Realm.Transaction initialDataTransaction,
+                                boolean readOnly,
                                 SyncUser user,
                                 URI serverUrl,
                                 SyncSession.ErrorHandler errorHandler,
-                                boolean deleteRealmOnLogout
+                                boolean deleteRealmOnLogout,
+                                boolean syncClientValidateSsl,
+                                @Nullable
+                                String serverCertificateAssetName,
+                                @Nullable
+                                String serverCertificateFilePath,
+                                boolean waitForInitialData,
+                                OsRealmConfig.SyncSessionStopPolicy sessionStopPolicy,
+                                boolean isPartial
     ) {
         super(directory,
                 filename,
@@ -107,13 +133,69 @@ private SyncConfiguration(File directory,
                 durability,
                 schemaMediator,
                 rxFactory,
-                initialDataTransaction
+                initialDataTransaction,
+                readOnly,
+                null,
+                false
         );
 
         this.user = user;
         this.serverUrl = serverUrl;
         this.errorHandler = errorHandler;
         this.deleteRealmOnLogout = deleteRealmOnLogout;
+        this.syncClientValidateSsl = syncClientValidateSsl;
+        this.serverCertificateAssetName = serverCertificateAssetName;
+        this.serverCertificateFilePath = serverCertificateFilePath;
+        this.waitForInitialData = waitForInitialData;
+        this.sessionStopPolicy = sessionStopPolicy;
+        this.isPartial = isPartial;
+    }
+
+    /**
+     * Returns a {@link RealmConfiguration} appropriate to open a read-only, non-synced Realm to recover any pending changes.
+     * This is useful when trying to open a backup/recovery Realm (after a client reset).
+     *
+     * @param canonicalPath the absolute path to the Realm file defined by this configuration.
+     * @param encryptionKey the key used to encrypt/decrypt the Realm file.
+     * @param modules if specified it will restricts Realm schema to the provided module.
+     * @return RealmConfiguration that can be used offline
+     */
+    public static RealmConfiguration forRecovery(String canonicalPath, @Nullable byte[] encryptionKey, @Nullable Object... modules) {
+        HashSet<Object> validatedModules = new HashSet<>();
+        if (modules != null && modules.length > 0) {
+            for (Object module : modules) {
+                if (!module.getClass().isAnnotationPresent(RealmModule.class)) {
+                    throw new IllegalArgumentException(module.getClass().getCanonicalName() + " is not a RealmModule. " +
+                            "Add @RealmModule to the class definition.");
+                }
+                validatedModules.add(module);
+            }
+        } else {
+            if (Realm.getDefaultModule() != null) {
+                validatedModules.add(Realm.getDefaultModule());
+            }
+        }
+
+        RealmProxyMediator schemaMediator = createSchemaMediator(validatedModules, Collections.<Class<? extends RealmModel>>emptySet());
+        return forRecovery(canonicalPath, encryptionKey, schemaMediator);
+    }
+
+    /**
+     * Returns a {@link RealmConfiguration} appropriate to open a read-only, non-synced Realm to recover any pending changes.
+     * This is useful when trying to open a backup/recovery Realm (after a client reset).
+     *
+     * Note: This will use the default Realm module (composed of all {@link RealmModel}), and
+     * assume no encryption should be used as well.
+     *
+     * @param canonicalPath the absolute path to the Realm file defined by this configuration.
+     * @return RealmConfiguration that can be used offline
+     */
+    public static RealmConfiguration forRecovery(String canonicalPath) {
+        return forRecovery(canonicalPath, null);
+    }
+
+    static RealmConfiguration forRecovery(String canonicalPath, @Nullable byte[] encryptionKey, RealmProxyMediator schemaMediator) {
+        return new RealmConfiguration(null,null, canonicalPath,null, encryptionKey, 0,null, false, OsRealmConfig.Durability.FULL, schemaMediator, null, null, true, null, true);
     }
 
     static URI resolveServerUrl(URI serverUrl, String userIdentifier) {
@@ -146,9 +228,13 @@ public boolean equals(Object o) {
         SyncConfiguration that = (SyncConfiguration) o;
 
         if (deleteRealmOnLogout != that.deleteRealmOnLogout) return false;
+        if (syncClientValidateSsl != that.syncClientValidateSsl) return false;
         if (!serverUrl.equals(that.serverUrl)) return false;
         if (!user.equals(that.user)) return false;
         if (!errorHandler.equals(that.errorHandler)) return false;
+        if (serverCertificateAssetName != null ? !serverCertificateAssetName.equals(that.serverCertificateAssetName) : that.serverCertificateAssetName != null) return false;
+        if (serverCertificateFilePath != null ? !serverCertificateFilePath.equals(that.serverCertificateFilePath) : that.serverCertificateFilePath != null) return false;
+        if (waitForInitialData != that.waitForInitialData) return false;
         return true;
     }
 
@@ -157,8 +243,12 @@ public int hashCode() {
         int result = super.hashCode();
         result = 31 * result + serverUrl.hashCode();
         result = 31 * result + user.hashCode();
-        result = 31 * result + (deleteRealmOnLogout ? 1 : 0);
         result = 31 * result + errorHandler.hashCode();
+        result = 31 * result + (deleteRealmOnLogout ? 1 : 0);
+        result = 31 * result + (syncClientValidateSsl ? 1 : 0);
+        result = 31 * result + (serverCertificateAssetName != null ? serverCertificateAssetName.hashCode() : 0);
+        result = 31 * result + (serverCertificateFilePath != null ? serverCertificateFilePath.hashCode() : 0);
+        result = 31 * result + (waitForInitialData ? 1 : 0);
         return result;
     }
 
@@ -173,6 +263,8 @@ public String toString() {
         stringBuilder.append("errorHandler: " + errorHandler);
         stringBuilder.append("\n");
         stringBuilder.append("deleteRealmOnLogout: " + deleteRealmOnLogout);
+        stringBuilder.append("\n");
+        stringBuilder.append("waitForInitialRemoteData: " + waitForInitialData);
         return stringBuilder.toString();
     }
 
@@ -209,11 +301,82 @@ public boolean shouldDeleteRealmOnLogout() {
         return deleteRealmOnLogout;
     }
 
+    /**
+     * Returns the name of certificate stored under the {@code assets}, to be used to validate
+     * the TLS connection to the Realm Object Server.
+     *
+     * @return name of the certificate to be copied from the {@code assets}.
+     * @see #getServerCertificateFilePath()
+     */
+    @Nullable
+    public String getServerCertificateAssetName() {
+        return serverCertificateAssetName;
+    }
+
+    /**
+     * Returns the name of the certificate copied from {@code assets} into internal storage, so it
+     * can be used to validate the TLS connection to the Realm Object Server.
+     *
+     * @return absolute path to the certificate.
+     * @see #getServerCertificateAssetName()
+     */
+    @Nullable
+    public String getServerCertificateFilePath() {
+        return serverCertificateFilePath;
+    }
+
+    /**
+     * Whether the Realm Object Server certificate should be validated in order
+     * to establish a valid TLS connection.
+     *
+     * @return {@code true} to validate the remote certificate, or {@code false} to bypass certificate validation.
+     */
+    public boolean syncClientValidateSsl() {
+        return syncClientValidateSsl;
+    }
+
+    /**
+     * Returns {@code true} if the Realm will download all known changes from the remote server before being opened the
+     * first time.
+     *
+     * @return {@code true} if all remote changes will be downloaded before the Realm can be opened. {@code false} if
+     * the Realm can be opened immediately.
+     */
+    public boolean shouldWaitForInitialRemoteData() {
+        return waitForInitialData;
+    }
+
     @Override
     boolean isSyncConfiguration() {
         return true;
     }
 
+    /**
+     * NOTE: Only for internal usage. May change without warning.
+     *
+     * Returns the stop policy for the session for this Realm once the Realm has been closed.
+     *
+     * @return the stop policy used by the session once the Realm is closed.
+     */
+    public OsRealmConfig.SyncSessionStopPolicy getSessionStopPolicy() {
+        return sessionStopPolicy;
+    }
+
+    /**
+     * Whether this configuration is for a partial synchronization Realm.
+     * Partial synchronization allows a synchronized Realm to be opened in such a way that
+     * only objects requested by the user are synchronized to the device. You can use it by setting
+     * the {@link Builder#partialRealm()}, opening the Realm, and then calling
+     * {@link Realm#subscribeToObjects(Class, String, Realm.PartialSyncCallback)} with the type of
+     * object you're interested in, a string containing a query determining which objects you want
+     * to subscribe to, and a callback which will report the results.
+     *
+     * @return {@code true} to open a partial synchronization Realm {@code false} otherwise.
+     */
+    public boolean isPartialRealm() {
+        return isPartial;
+    }
+
     /**
      * Builder used to construct instances of a SyncConfiguration in a fluent manner.
      */
@@ -223,21 +386,33 @@ boolean isSyncConfiguration() {
         private boolean overrideDefaultFolder = false;
         private String fileName;
         private boolean overrideDefaultLocalFileName = false;
+        @Nullable
         private byte[] key;
         private long schemaVersion = 0;
         private HashSet<Object> modules = new HashSet<Object>();
         private HashSet<Class<? extends RealmModel>> debugSchema = new HashSet<Class<? extends RealmModel>>();
+        @Nullable
         private RxObservableFactory rxFactory;
+        @Nullable
         private Realm.Transaction initialDataTransaction;
-        private URI serverUrl;
-        private SyncUser user = null;
-        private SyncSession.ErrorHandler errorHandler = SyncManager.defaultSessionErrorHandler;
         private File defaultFolder;
         private String defaultLocalFileName;
-        private SharedRealm.Durability durability = SharedRealm.Durability.FULL;
-        private boolean deleteRealmOnLogout = false;
+        private OsRealmConfig.Durability durability = OsRealmConfig.Durability.FULL;
         private final Pattern pattern = Pattern.compile("^[A-Za-z0-9_\\-\\.]+$"); // for checking serverUrl
-
+        private boolean readOnly = false;
+        private boolean waitForServerChanges = false;
+        // sync specific
+        private boolean deleteRealmOnLogout = false;
+        private URI serverUrl;
+        private SyncUser user = null;
+        private SyncSession.ErrorHandler errorHandler = SyncManager.defaultSessionErrorHandler;
+        private boolean syncClientValidateSsl = true;
+        @Nullable
+        private String serverCertificateAssetName;
+        @Nullable
+        private String serverCertificateFilePath;
+        private OsRealmConfig.SyncSessionStopPolicy sessionStopPolicy = OsRealmConfig.SyncSessionStopPolicy.AFTER_CHANGES_UPLOADED;
+        private boolean isPartial = false;
         /**
          * Creates an instance of the Builder for the SyncConfiguration.
          * <p>
@@ -270,6 +445,7 @@ public Builder(SyncUser user, String uri) {
         }
 
         Builder(Context context, SyncUser user, String url) {
+            //noinspection ConstantConditions
             if (context == null) {
                 throw new IllegalStateException("Call `Realm.init(Context)` before creating a SyncConfiguration");
             }
@@ -283,6 +459,7 @@ public Builder(SyncUser user, String uri) {
         }
 
         private void validateAndSet(SyncUser user) {
+            //noinspection ConstantConditions
             if (user == null) {
                 throw new IllegalArgumentException("Non-null `user` required.");
             }
@@ -293,6 +470,7 @@ private void validateAndSet(SyncUser user) {
         }
 
         private void validateAndSet(String uri) {
+            //noinspection ConstantConditions
             if (uri == null) {
                 throw new IllegalArgumentException("Non-null 'uri' required.");
             }
@@ -383,6 +561,7 @@ private void validateAndSet(String uri) {
          * @throws IllegalArgumentException if file name is {@code null} or empty.
          */
         public Builder name(String filename) {
+            //noinspection ConstantConditions
             if (filename == null || filename.isEmpty()) {
                 throw new IllegalArgumentException("A non-empty filename must be provided");
             }
@@ -405,6 +584,7 @@ public Builder name(String filename) {
          * @throws IllegalArgumentException if the directory is not valid.
          */
         public Builder directory(File directory) {
+            //noinspection ConstantConditions
             if (directory == null) {
                 throw new IllegalArgumentException("Non-null 'directory' required.");
             }
@@ -432,11 +612,13 @@ public Builder directory(File directory) {
          * @throws IllegalArgumentException if key is invalid.
          */
         public Builder encryptionKey(byte[] key) {
+            //noinspection ConstantConditions
             if (key == null) {
                 throw new IllegalArgumentException("A non-null key must be provided");
             }
             if (key.length != KEY_LENGTH) {
-                throw new IllegalArgumentException(String.format("The provided key must be %s bytes. Yours was: %s",
+                throw new IllegalArgumentException(String.format(Locale.US,
+                        "The provided key must be %s bytes. Yours was: %s",
                         KEY_LENGTH, key.length));
             }
             this.key = Arrays.copyOf(key, key.length);
@@ -449,12 +631,14 @@ public Builder encryptionKey(byte[] key) {
          * previously configured modules.
          */
         SyncConfiguration.Builder schema(Class<? extends RealmModel> firstClass, Class<? extends RealmModel>... additionalClasses) {
+            //noinspection ConstantConditions
             if (firstClass == null) {
                 throw new IllegalArgumentException("A non-null class must be provided");
             }
             modules.clear();
             modules.add(DEFAULT_MODULE_MEDIATOR);
             debugSchema.add(firstClass);
+            //noinspection ConstantConditions
             if (additionalClasses != null) {
                 Collections.addAll(debugSchema, additionalClasses);
             }
@@ -462,16 +646,26 @@ public Builder encryptionKey(byte[] key) {
             return this;
         }
 
+        /**
+         * DEBUG method. This makes it possible to define different policies for when a session should be stopped when
+         * the Realm is closed.
+         *
+         * @param policy how a session for a Realm should behave when the Realm is closed.
+         */
+        SyncConfiguration.Builder sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy policy) {
+            sessionStopPolicy = policy;
+            return this;
+        }
+
+
         /**
          * Sets the schema version of the Realm.
          * <p>
-         * While synced Realms only support additive schema changes which can be applied without requiring a manual
-         * migration, the schema version must still be incremented as an indication to Realm that the change was
-         * intentional.
-         * <p>
-         * Failing to increment the schema version will cause Realm to throw a {@link io.realm.exceptions.RealmMigrationNeededException}
-         * when the Realm is opened and the changed schema will not be applied.
-         * <p>
+         * Synced Realms only support additive schema changes which can be applied without requiring a manual
+         * migration. The schema version will only be used as an indication to the underlying storage layer to remove
+         * or add indexes. These will be recalculated if the provided schema version differ from the version in the
+         * Realm file.
+         *
          * <b>WARNING:</b> There is no guarantee that the value inserted here is the same returned by {@link Realm#getVersion()}.
          * Due to the nature of synced Realms, the value can both be higher and lower.
          * <ul>
@@ -512,6 +706,7 @@ public Builder schemaVersion(long schemaVersion) {
         public Builder modules(Object baseModule, Object... additionalModules) {
             modules.clear();
             addModule(baseModule);
+            //noinspection ConstantConditions
             if (additionalModules != null) {
                 for (Object module : additionalModules) {
                     addModule(module);
@@ -552,7 +747,7 @@ public Builder initialData(Realm.Transaction transaction) {
          * reference to the in-memory Realm object with the specific name as long as you want the data to last.
          */
         public Builder inMemory() {
-            this.durability = SharedRealm.Durability.MEM_ONLY;
+            this.durability = OsRealmConfig.Durability.MEM_ONLY;
             return this;
         }
 
@@ -566,6 +761,7 @@ public Builder inMemory() {
          * @throws IllegalArgumentException if {@code null} is given as an error handler.
          */
         public Builder errorHandler(SyncSession.ErrorHandler errorHandler) {
+            //noinspection ConstantConditions
             if (errorHandler == null) {
                 throw new IllegalArgumentException("Non-null 'errorHandler' required.");
             }
@@ -573,13 +769,91 @@ public Builder errorHandler(SyncSession.ErrorHandler errorHandler) {
             return this;
         }
 
+        /**
+         * Provides the trusted root certificate(s) authority (CA) in {@code PEM} format, that should be used to
+         * validate the TLS connections to the Realm Object Server.
+         * <p>
+         * The file should be stored under {@code assets}, it will be copied at runtime into the internal storage.
+         * <p>
+         * Note: This is similar to passing the parameter {@code CAfile} to {@code SSL_CTX_load_verify_locations},
+         *       Therefore it is recommended to include only the root CA you trust, and not the entire list of root CA
+         *       as this file will be loaded at runtime.
+         *
+         *       It is your responsibility to download and verify the correct {@code PEM} for the root CA you trust.
+         *       An existing list by Mozilla exist that could be used https://mozillacaprogram.secure.force.com/CA/IncludedCACertificateReportPEMCSV
+         *
+         * @param filename the path under {@code assets} to the root CA.
+         * @see <a href="https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_load_verify_locations.html">SSL_CTX_load_verify_locations</a>
+         */
+        public Builder trustedRootCA(String filename) {
+            //noinspection ConstantConditions
+            if (filename == null || filename.isEmpty()) {
+                throw new IllegalArgumentException("A non-empty filename must be provided");
+            }
+            this.serverCertificateAssetName = filename;
+            return this;
+        }
+
+        /**
+         * This will disable TLS certificate verification for the remote Realm Object Server.
+         * It is not recommended to use this in production.
+         * <p>
+         * This might be useful in non-production environments where you use a self-signed certificate
+         * for testing.
+         */
+        public Builder disableSSLVerification() {
+            this.syncClientValidateSsl = false;
+            return this;
+        }
+
+        /*
+         * Setting this will cause the Realm to download all known changes from the server the first time a Realm is
+         * opened. The Realm will not open until all the data has been downloaded. This means that if a device is
+         * offline the Realm will not open.
+         * <p>
+         * Since downloading all changes can be an lengthy operation that might block the UI thread, Realms with this
+         * setting enabled should only be opened on background threads or with
+         * {@link Realm#getInstanceAsync(RealmConfiguration, Realm.Callback)} on the UI thread.
+         * <p>
+         * This check is only enforced the first time a Realm is created. If you otherwise want to make sure a Realm
+         * has the latest changes, use {@link SyncSession#downloadAllServerChanges()}.
+         */
+        public Builder waitForInitialRemoteData() {
+            this.waitForServerChanges = true;
+            return this;
+        }
+
+        /**
+         * Setting this will cause the Realm to become read only and all write transactions made against this Realm will
+         * fail with an {@link IllegalStateException}.
+         * <p>
+         * This in particular mean that {@link #initialData(Realm.Transaction)} will not work in combination with a
+         * read only Realm and setting this will result in a {@link IllegalStateException} being thrown.
+         * </p>
+         * Marking a Realm as read only only applies to the Realm in this process. Other processes and devices can still
+         * write to the Realm.
+         */
+        public SyncConfiguration.Builder readOnly() {
+            this.readOnly = true;
+            return this;
+        }
+
+        /**
+         * Setting this will open a partially synchronized Realm.
+         * @see #isPartialRealm()
+         */
+        public SyncConfiguration.Builder partialRealm() {
+            this.isPartial = true;
+            return this;
+        }
+
         private String MD5(String in) {
             try {
                 MessageDigest digest = MessageDigest.getInstance("MD5");
                 byte[] buf = digest.digest(in.getBytes("UTF-8"));
                 StringBuilder builder = new StringBuilder();
                 for (byte b : buf) {
-                    builder.append(String.format("%02X", b));
+                    builder.append(String.format(Locale.US, "%02X", b));
                 }
                 return builder.toString();
             } catch (NoSuchAlgorithmException e) {
@@ -614,6 +888,19 @@ public SyncConfiguration build() {
                 throw new IllegalStateException("serverUrl() and user() are both required.");
             }
 
+            // Check that readOnly() was applied to legal configuration. Right now it should only be allowd if
+            // an assetFile is configured
+            if (readOnly) {
+                if (initialDataTransaction != null) {
+                    throw new IllegalStateException("This Realm is marked as read-only. " +
+                            "Read-only Realms cannot use initialData(Realm.Transaction).");
+                }
+                if (!waitForServerChanges) {
+                    throw new IllegalStateException("A read-only Realms must be provided by some source. " +
+                            "'waitForInitialRemoteData()' wasn't enabled which is currently the only supported source.");
+                }
+            }
+
             // Check if the user has an identifier, if not, it cannot use /~/.
             if (serverUrl.toString().contains("/~/") && user.getIdentity() == null) {
                 throw new IllegalStateException("The serverUrl contains a /~/, but the user does not have an identity." +
@@ -645,14 +932,16 @@ public SyncConfiguration build() {
                     realmFileDirectory = new File(rootDir, user.getIdentity());
                     fullPathName = realmFileDirectory.getAbsolutePath() + File.pathSeparator + realmFileName;
                     if (fullPathName.length() > MAX_FULL_PATH_LENGTH) { // we are out of ideas
-                        throw new IllegalStateException(String.format("Full path name must not exceed %d characters: %s",
+                        throw new IllegalStateException(String.format(Locale.US,
+                                "Full path name must not exceed %d characters: %s",
                                 MAX_FULL_PATH_LENGTH, fullPathName));
                     }
                 }
             }
 
             if (realmFileName.length() > MAX_FILE_NAME_LENGTH) {
-                throw new IllegalStateException(String.format("File name exceed %d characters: %d", MAX_FILE_NAME_LENGTH,
+                throw new IllegalStateException(String.format(Locale.US,
+                        "File name exceed %d characters: %d", MAX_FILE_NAME_LENGTH,
                         realmFileName.length()));
             }
 
@@ -666,6 +955,18 @@ public SyncConfiguration build() {
                 throw new IllegalStateException("Could not create directory for saving the Realm: " + realmFileDirectory);
             }
 
+            if (!Util.isEmptyString(serverCertificateAssetName)) {
+                if (syncClientValidateSsl) {
+                    // Create the path where the serverCertificateAssetName will be copied
+                    // so we can supply it to the Sync client.
+                    // using getRealmDirectory avoid file collision between same filename from different users (Realms)
+                    String fileName = serverCertificateAssetName.substring(serverCertificateAssetName.lastIndexOf(File.separatorChar) + 1);
+                    serverCertificateFilePath = new File(realmFileDirectory, fileName).getAbsolutePath();
+                } else {
+                    RealmLog.warn("SSL Verification is disabled, the provided server certificate will not be used.");
+                }
+            }
+
             return new SyncConfiguration(
                     // Realm Configuration options
                     realmFileDirectory,
@@ -680,16 +981,24 @@ public SyncConfiguration build() {
                     createSchemaMediator(modules, debugSchema),
                     rxFactory,
                     initialDataTransaction,
+                    readOnly,
 
                     // Sync Configuration specific
                     user,
                     resolvedServerUrl,
                     errorHandler,
-                    deleteRealmOnLogout
+                    deleteRealmOnLogout,
+                    syncClientValidateSsl,
+                    serverCertificateAssetName,
+                    serverCertificateFilePath,
+                    waitForServerChanges,
+                    sessionStopPolicy,
+                    isPartial
             );
         }
 
         private void addModule(Object module) {
+            //noinspection ConstantConditions
             if (module != null) {
                 checkModule(module);
                 modules.add(module);
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java b/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
index 986e3bfc03..5bd7176a6d 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncCredentials.java
@@ -20,6 +20,9 @@
 import java.util.HashMap;
 import java.util.Map;
 
+import javax.annotation.Nullable;
+
+
 /**
  * Credentials represent a login with a 3rd party login provider in an OAuth2 login flow, and are used by the Realm
  * Object Server to verify the user and grant access.
@@ -73,7 +76,7 @@
      *
      * @param facebookToken a facebook userIdentifier acquired by logging into Facebook.
      * @return a set of credentials that can be used to log into the Object Server using
-     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
      * @throws IllegalArgumentException if user name is either {@code null} or empty.
      */
     public static SyncCredentials facebook(String facebookToken) {
@@ -86,7 +89,7 @@ public static SyncCredentials facebook(String facebookToken) {
      *
      * @param googleToken a google userIdentifier acquired by logging into Google.
      * @return a set of credentials that can be used to log into the Object Server using
-     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
      * @throws IllegalArgumentException if user name is either {@code null} or empty.
      */
     public static SyncCredentials google(String googleToken) {
@@ -101,10 +104,10 @@ public static SyncCredentials google(String googleToken) {
      * @param username username of the user.
      * @param password the users password.
      * @param createUser {@code true} if the user should be created, {@code false} otherwise. It is not possible to
-     *                   create a user twice when logging in, so this flag should only be set to {@code true} the first
-     *                   time a users log in.
+     * create a user twice when logging in, so this flag should only be set to {@code true} the first
+     * time a users log in.
      * @return a set of credentials that can be used to log into the Object Server using
-     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
      * @throws IllegalArgumentException if user name is either {@code null} or empty.
      */
     public static SyncCredentials usernamePassword(String username, String password, boolean createUser) {
@@ -122,7 +125,7 @@ public static SyncCredentials usernamePassword(String username, String password,
      * @param username username of the user.
      * @param password the users password.
      * @return a set of credentials that can be used to log into the Object Server using
-     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
      * @throws IllegalArgumentException if user name is either {@code null} or empty.
      */
     public static SyncCredentials usernamePassword(String username, String password) {
@@ -136,13 +139,13 @@ public static SyncCredentials usernamePassword(String username, String password)
      * @param userIdentifier String identifying the user. Usually a username or user token.
      * @param identityProvider provider used to verify the credentials.
      * @param userInfo data describing the user further or {@code null} if the user does not have any extra data. The
-     *              data will be serialized to JSON, so all values must be mappable to a valid JSON data type. Custom
-     *              classes will be converted using {@code toString()}.
+     * data will be serialized to JSON, so all values must be mappable to a valid JSON data type. Custom
+     * classes will be converted using {@code toString()}.
      * @return a set of credentials that can be used to log into the Object Server using
-     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
+     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}.
      * @throws IllegalArgumentException if any parameter is either {@code null} or empty.
      */
-    public static SyncCredentials custom(String userIdentifier, String identityProvider, Map<String, Object> userInfo) {
+    public static SyncCredentials custom(String userIdentifier, String identityProvider, @Nullable Map<String, Object> userInfo) {
         assertStringNotEmpty(userIdentifier, "userIdentifier");
         assertStringNotEmpty(identityProvider, "identityProvider");
         if (userInfo == null) {
@@ -154,27 +157,49 @@ public static SyncCredentials custom(String userIdentifier, String identityProvi
     /**
      * Creates credentials from an existing access token. Since an access token is the proof that a user already
      * has logged in. Credentials created this way are automatically assumed to have successfully logged in.
-     * This means that providing this credential to {@link SyncUser#login(SyncCredentials, String)} will always
+     * This means that providing these credentials to {@link SyncUser#login(SyncCredentials, String)} will always
      * succeed, but accessing any Realm after might fail if the token is no longer valid.
+     * <p>
+     * It is assumed that this user is not an administrator. Otherwise use {@link #accessToken(String, String, boolean)}.
      *
      * @param accessToken user's access token.
      * @param identifier user identifier.
      * @return a set of credentials that can be used to log into the Object Server using
-     *         {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}
+     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}
      */
     public static SyncCredentials accessToken(String accessToken, String identifier) {
+        return accessToken(accessToken, identifier, false);
+    }
+
+    /**
+     * Creates credentials from an existing access token. Since an access token is the proof that a user already
+     * has logged in. Credentials created this way are automatically assumed to have successfully logged in.
+     * This means that providing these credentials to {@link SyncUser#login(SyncCredentials, String)} will always
+     * succeed, but accessing any Realm after might fail if the token is no longer valid.
+     *
+     * @param accessToken user's access token.
+     * @param identifier user identifier.
+     * @param isAdmin {@code true} if the access token is an administrator's token, {@code false} if it is a
+     * non-privileged users. It is to <i>not</i> possible to upgrade a non-admin token to an admin token by setting this
+     * value. It is purely informational.
+     * @return a set of credentials that can be used to log into the Object Server using
+     * {@link SyncUser#loginAsync(SyncCredentials, String, SyncUser.Callback)}
+     */
+    public static SyncCredentials accessToken(String accessToken, String identifier, boolean isAdmin) {
         HashMap<String, Object> userInfo = new HashMap<String, Object>();
         userInfo.put("_token", accessToken);
+        userInfo.put("_isAdmin", isAdmin);
         return new SyncCredentials(identifier, IdentityProvider.ACCESS_TOKEN, userInfo);
     }
 
     private static void assertStringNotEmpty(String string, String message) {
+        //noinspection ConstantConditions
         if (string == null || "".equals(string)) {
             throw new IllegalArgumentException("Non-null '" + message + "' required.");
         }
     }
 
-    private SyncCredentials(String token, String identityProvider, Map<String, Object> userInfo) {
+    private SyncCredentials(String token, String identityProvider, @Nullable Map<String, Object> userInfo) {
         this.identityProvider = identityProvider;
         this.userIdentifier = token;
         this.userInfo = (userInfo == null) ? new HashMap<String, Object>() : userInfo;
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
index 8ef5862f5f..4ba4d0e5d9 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -16,13 +16,18 @@
 
 package io.realm;
 
-import java.util.HashMap;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
+import javax.annotation.Nullable;
+
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import io.realm.internal.Keep;
 import io.realm.internal.network.AuthenticationServer;
@@ -55,6 +60,11 @@
          */
         public static boolean skipOnlineChecking = false;
 
+        /**
+         * Set this to true to init a SyncManager with a directory named by the process ID. This is useful for
+         * integration tests which are emulating multiple sync client by using multiple processes.
+         */
+        public static boolean separatedDirForSyncManager = false;
     }
 
     /**
@@ -75,7 +85,7 @@ public void onError(SyncSession session, ObjectServerError error) {
                 return;
             }
 
-            String errorMsg = String.format("Session Error[%s]: %s",
+            String errorMsg = String.format(Locale.US, "Session Error[%s]: %s",
                     session.getConfiguration().getServerUrl(),
                     error.toString());
             switch (error.getErrorCode().getCategory()) {
@@ -91,7 +101,7 @@ public void onError(SyncSession session, ObjectServerError error) {
         }
     };
     // keeps track of SyncSession, using 'realm_path'. Java interface with the ObjectStore using the 'realm_path'
-    private static Map<String, SyncSession> sessions = new HashMap<String, SyncSession>();
+    private static Map<String, SyncSession> sessions = new ConcurrentHashMap<>();
     private static CopyOnWriteArrayList<AuthenticationListener> authListeners = new CopyOnWriteArrayList<AuthenticationListener>();
 
     // The Sync Client is lightweight, but consider creating/removing it when there is no sessions.
@@ -128,6 +138,7 @@ static void init(String appId, UserStore userStore) {
      * @throws IllegalArgumentException if {@code userStore} is {@code null}.
      */
     public static void setUserStore(UserStore userStore) {
+        //noinspection ConstantConditions
         if (userStore == null) {
             throw new IllegalArgumentException("Non-null 'userStore' required.");
         }
@@ -142,6 +153,7 @@ public static void setUserStore(UserStore userStore) {
      * @throws IllegalArgumentException if {@code listener} is {@code null}.
      */
     public static void addAuthenticationListener(AuthenticationListener listener) {
+        //noinspection ConstantConditions
         if (listener == null) {
             throw new IllegalArgumentException("Non-null 'listener' required.");
         }
@@ -154,6 +166,7 @@ public static void addAuthenticationListener(AuthenticationListener listener) {
      * @param listener listener to remove.
      */
     public static void removeAuthenticationListener(AuthenticationListener listener) {
+        //noinspection ConstantConditions
         if (listener == null) {
             return;
         }
@@ -165,7 +178,7 @@ public static void removeAuthenticationListener(AuthenticationListener listener)
      *
      * @param errorHandler the default error handler used when interacting with a Realm managed by a Realm Object Server.
      */
-    public static void setDefaultSessionErrorHandler(SyncSession.ErrorHandler errorHandler) {
+    public static void setDefaultSessionErrorHandler(@Nullable SyncSession.ErrorHandler errorHandler) {
         if (errorHandler == null) {
             defaultSessionErrorHandler = SESSION_NO_OP_ERROR_HANDLER;
         } else {
@@ -187,6 +200,7 @@ public static synchronized SyncSession getSession(SyncConfiguration syncConfigur
         // of the native session, the provided Java wrap, helps interact with the native session, when reporting error
         // or requesting an access_token for example.
 
+        //noinspection ConstantConditions
         if (syncConfiguration == null) {
             throw new IllegalArgumentException("A non-empty 'syncConfiguration' is required.");
         }
@@ -210,6 +224,7 @@ public static synchronized SyncSession getSession(SyncConfiguration syncConfigur
      */
     @SuppressWarnings("unused")
     private static synchronized void removeSession(SyncConfiguration syncConfiguration) {
+        //noinspection ConstantConditions
         if (syncConfiguration == null) {
             throw new IllegalArgumentException("A non-empty 'syncConfiguration' is required.");
         }
@@ -223,6 +238,25 @@ private static synchronized void removeSession(SyncConfiguration syncConfigurati
         }
     }
 
+    /**
+     * Retruns the all valid sessions belonging to the user.
+     *
+     * @param syncUser the user to use.
+     * @return the all valid sessions belonging to the user.
+     */
+    static List<SyncSession> getAllSessions(SyncUser syncUser) {
+        if (syncUser == null) {
+            throw new IllegalArgumentException("A non-empty 'syncUser' is required.");
+        }
+        ArrayList<SyncSession> allSessions = new ArrayList<SyncSession>();
+        for (SyncSession syncSession : sessions.values()) {
+            if (syncSession.getState() != SyncSession.State.ERROR && syncSession.getUser().equals(syncUser)) {
+                allSessions.add(syncSession);
+            }
+        }
+        return allSessions;
+    }
+
     static AuthenticationServer getAuthServer() {
         return authServer;
     }
@@ -235,7 +269,7 @@ static void setAuthServerImpl(AuthenticationServer authServerImpl) {
     }
 
     // Return the currently configured User store.
-    static UserStore getUserStore() {
+    public static UserStore getUserStore() {
         return userStore;
     }
 
@@ -258,7 +292,7 @@ static void notifyUserLoggedOut(SyncUser user) {
      * session to contact. If {@code path == null} all sessions are effected.
      */
     @SuppressWarnings("unused")
-    private static synchronized void notifyErrorHandler(int errorCode, String errorMessage, String path) {
+    private static synchronized void notifyErrorHandler(int errorCode, String errorMessage, @Nullable String path) {
         for (SyncSession syncSession : sessions.values()) {
             if (path == null || path.equals(syncSession.getConfiguration().getPath())) {
                 try {
@@ -278,6 +312,24 @@ private static synchronized void notifyNetworkIsBack() {
         }
     }
 
+    /**
+     * All progress listener events from native Sync are reported to this method.
+     * It costs 2 HashMap lookups for each listener triggered (one to find the session, one to
+     * find the progress listener), but it means we don't have to cache anything on the C++ side which
+     * can leak since we don't have control over the session lifecycle.
+     */
+    @SuppressWarnings("unused")
+    private static synchronized void notifyProgressListener(String localRealmPath, long listenerId, long transferedBytes, long transferableBytes) {
+        SyncSession session = sessions.get(localRealmPath);
+        if (session != null) {
+            try {
+                session.notifyProgressListener(listenerId, transferedBytes, transferableBytes);
+            } catch (Exception exception) {
+                RealmLog.error(exception);
+            }
+        }
+    }
+
     /**
      * This is called from the Object Store (through JNI) to request an {@code access_token} for
      * the session specified by sessionPath.
@@ -290,13 +342,13 @@ private static synchronized void notifyNetworkIsBack() {
      * @return a valid cached {@code access_token} if available or null.
      */
     @SuppressWarnings("unused")
-    private synchronized static String bindSessionWithConfig(String sessionPath) {
+    private synchronized static String bindSessionWithConfig(String sessionPath, String refreshToken) {
         final SyncSession syncSession = sessions.get(sessionPath);
         if (syncSession == null) {
             RealmLog.error("Matching Java SyncSession could not be found for: " + sessionPath);
         } else {
             try {
-                return syncSession.accessToken(authServer);
+                return syncSession.getAccessToken(authServer, refreshToken);
             } catch (Exception exception) {
                 RealmLog.error(exception);
             }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index b456318617..5ed82d663f 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -16,23 +16,37 @@
 
 package io.realm;
 
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.InterruptedIOException;
 import java.net.URI;
+import java.util.HashMap;
+import java.util.IdentityHashMap;
+import java.util.Iterator;
+import java.util.Locale;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Future;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
 
 import io.realm.internal.Keep;
-import io.realm.internal.KeepMember;
 import io.realm.internal.SyncObjectServerFacade;
+import io.realm.internal.Util;
+import io.realm.internal.android.AndroidCapabilities;
 import io.realm.internal.async.RealmAsyncTaskImpl;
 import io.realm.internal.network.AuthenticateResponse;
 import io.realm.internal.network.AuthenticationServer;
 import io.realm.internal.network.ExponentialBackoffTask;
 import io.realm.internal.network.NetworkStateReceiver;
-import io.realm.internal.objectserver.ObjectServerUser;
 import io.realm.internal.objectserver.Token;
+import io.realm.internal.util.Pair;
 import io.realm.log.RealmLog;
 
 /**
@@ -50,6 +64,8 @@
 public class SyncSession {
     private final static ScheduledThreadPoolExecutor REFRESH_TOKENS_EXECUTOR = new ScheduledThreadPoolExecutor(1);
     private final static long REFRESH_MARGIN_DELAY = TimeUnit.SECONDS.toMillis(10);
+    private final static int DIRECTION_DOWNLOAD = 1;
+    private final static int DIRECTION_UPLOAD = 2;
 
     private final SyncConfiguration configuration;
     private final ErrorHandler errorHandler;
@@ -59,6 +75,59 @@
     private RealmAsyncTask refreshTokenNetworkRequest;
     private AtomicBoolean onGoingAccessTokenQuery = new AtomicBoolean(false);
     private volatile boolean isClosed = false;
+    private final AtomicReference<WaitForSessionWrapper> waitingForServerChanges = new AtomicReference<>(null);
+
+    // Keeps track of how many times `uploadAllLocalChanges()` or `downloadAllServerChanges()` have
+    // been called. This is needed so we can correctly ignore canceled requests.
+    private final AtomicInteger waitCounter = new AtomicInteger(0);
+    private final Object waitForChangesMutex = new Object();
+
+    // We need JavaId -> Listener so C++ can trigger callbacks without keeping a reference to the
+    // jobject, which would require a similar map on the C++ side.
+    // We need Listener -> Token map in order to remove the progress listener in C++ from Java.
+    private final Map<Long, Pair<ProgressListener, Progress>> listenerIdToProgressListenerMap = new HashMap<>();
+    private final Map<ProgressListener, Long> progressListenerToOsTokenMap = new IdentityHashMap<>();
+    // Counter used to assign all ProgressListeners on this session with a unique id.
+    // ListenerId is created by Java to enable C++ to reference the java listener without holding
+    // a reference to the actual object.
+    // ListenerToken is the same concept, but created by OS and represents the listener.
+    // We can unfortunately not just use the ListenerToken, since we need it to be available before
+    // we register the listener.
+    private final AtomicLong progressListenerId = new AtomicLong(-1);
+
+    // represent different states as defined in SyncSession::PublicState 'sync_session.hpp'
+    private static final byte STATE_VALUE_WAITING_FOR_ACCESS_TOKEN = 0;
+    private static final byte STATE_VALUE_ACTIVE = 1;
+    private static final byte STATE_VALUE_DYING = 2;
+    private static final byte STATE_VALUE_INACTIVE = 3;
+    private static final byte STATE_VALUE_ERROR = 4;
+
+    private URI resolvedRealmURI;
+
+    public enum State {
+        WAITING_FOR_ACCESS_TOKEN(STATE_VALUE_WAITING_FOR_ACCESS_TOKEN),
+        ACTIVE(STATE_VALUE_ACTIVE),
+        DYING(STATE_VALUE_DYING),
+        INACTIVE(STATE_VALUE_INACTIVE),
+        ERROR(STATE_VALUE_ERROR);
+
+        final byte value;
+
+        State(byte value) {
+            this.value = value;
+        }
+
+        static State fromByte(byte value) {
+            State[] stateCodes = values();
+            for (State state : stateCodes) {
+                if (state.value == value) {
+                    return state;
+                }
+            }
+
+            throw new IllegalArgumentException("Unknown state code: " + value);
+        }
+    }
 
     SyncSession(SyncConfiguration configuration) {
         this.configuration = configuration;
@@ -94,7 +163,6 @@ public URI getServerUrl() {
     }
 
     // This callback will happen on the thread running the Sync Client.
-    @KeepMember
     void notifySessionError(int errorCode, String errorMessage) {
         if (errorHandler == null) {
             return;
@@ -102,14 +170,134 @@ void notifySessionError(int errorCode, String errorMessage) {
         ErrorCode errCode = ErrorCode.fromInt(errorCode);
         if (errCode == ErrorCode.CLIENT_RESET) {
             // errorMessage contains the path to the backed up file
+            RealmConfiguration backupRealmConfiguration = SyncConfiguration.forRecovery(errorMessage, configuration.getEncryptionKey(), configuration.getSchemaMediator());
             errorHandler.onError(this, new ClientResetRequiredError(errCode, "A Client Reset is required. " +
                     "Read more here: https://realm.io/docs/realm-object-server/#client-recovery-from-a-backup.",
-                    errorMessage, getConfiguration()));
+                    configuration, backupRealmConfiguration));
         } else {
             errorHandler.onError(this, new ObjectServerError(errCode, errorMessage));
         }
     }
 
+    /**
+     * Get the current session's state, as defined in {@link SyncSession.State}.
+     *
+     * Note that the state may change after this method returns, example: the authentication
+     * token will expire, causing the session to move to {@link State#WAITING_FOR_ACCESS_TOKEN}
+     * after it was in {@link State#ACTIVE}.
+     *
+     * @return the state of the session.
+     * @see SyncSession.State
+     */
+    @SuppressWarnings("unused")
+    public State getState() {
+        byte state = nativeGetState(configuration.getPath());
+        if (state == -1) {
+            // session was not found, probably the Realm was closed
+            throw new IllegalStateException("Could not find session, Realm was probably closed");
+        }
+        return State.fromByte(state);
+    }
+
+    synchronized void notifyProgressListener(long listenerId, long transferredBytes, long transferableBytes) {
+        Pair<ProgressListener, Progress> listener = listenerIdToProgressListenerMap.get(listenerId);
+        if (listener != null) {
+            Progress newProgressNotification = new Progress(transferredBytes, transferableBytes);
+            if (!newProgressNotification.equals(listener.second)) {
+                listener.second = newProgressNotification;
+                listener.first.onChange(newProgressNotification);
+            }
+        } else {
+            RealmLog.debug("Trying unknown listener failed: " + listenerId);
+        }
+    }
+    
+    /**
+     * Adds a progress listener tracking changes that need to be downloaded from the Realm Object
+     * Server.
+     * <p>
+     * The {@link ProgressListener} will be triggered immediately when registered, and periodically
+     * afterwards.
+     *
+     * @param mode type of mode used. See {@link ProgressMode} for more information.
+     * @param listener the listener to register.
+     */
+    public synchronized void addDownloadProgressListener(ProgressMode mode, ProgressListener listener) {
+        addProgressListener(mode, DIRECTION_DOWNLOAD, listener);
+    }
+
+    /**
+     * Adds a progress listener tracking changes that need to be uploaded from the device to the
+     * Realm Object Server.
+     * <p>
+     * The {@link ProgressListener} will be triggered immediately when registered, and periodically
+     * afterwards.
+     *
+     * @param mode type of mode used. See {@link ProgressMode} for more information.
+     * @param listener the listener to register.
+     */
+    public synchronized void addUploadProgressListener(ProgressMode mode, ProgressListener listener) {
+        addProgressListener(mode, DIRECTION_UPLOAD, listener);
+    }
+
+    /**
+     * Removes a progress listener. If the listener wasn't registered, this method will do nothing.
+     *
+     * @param listener listener to remove.
+     */
+    public synchronized void removeProgressListener(ProgressListener listener) {
+        //noinspection ConstantConditions
+        if (listener == null) {
+            return;
+        }
+        // If an exception is thrown somewhere in here, we will most likely leave the various
+        // maps in an inconsistent manner. Not much we can do about it.
+        Long token = progressListenerToOsTokenMap.remove(listener);
+        if (token != null) {
+            Iterator<Map.Entry<Long, Pair<ProgressListener, Progress>>> it = listenerIdToProgressListenerMap.entrySet().iterator();
+            while (it.hasNext()) {
+                Map.Entry<Long, Pair<ProgressListener, Progress>> entry = it.next();
+                if (entry.getValue().first.equals(listener)) {
+                    it.remove();
+                    break;
+                }
+            }
+            nativeRemoveProgressListener(configuration.getPath(), token);
+        }
+    }
+
+    private void addProgressListener(ProgressMode mode, int direction, ProgressListener listener) {
+        checkProgressListenerArguments(mode, listener);
+        boolean isStreaming = (mode == ProgressMode.INDEFINITELY);
+        long listenerId = progressListenerId.incrementAndGet();
+
+        // A listener might be triggered immediately as part of `nativeAddProgressListener`, so
+        // we need to make sure it can be found by SyncManager.notifyProgressListener()
+        listenerIdToProgressListenerMap.put(listenerId, new Pair<ProgressListener, Progress>(listener, null));
+        long listenerToken = nativeAddProgressListener(configuration.getPath(), listenerId , direction, isStreaming);
+        if (listenerToken == 0) {
+            // ObjectStore did not register the listener. This can happen if a
+            // listener is registered with ProgressMode.CURRENT_CHANGES and no changes actually
+            // exists. In that case the listener was triggered immediately and we just need
+            // to clean it up, since it will never be called again.
+            listenerIdToProgressListenerMap.remove(listenerId);
+        } else {
+            // Listener was properly registered.
+            progressListenerToOsTokenMap.put(listener, listenerToken);
+        }
+    }
+
+    private void checkProgressListenerArguments(ProgressMode mode, ProgressListener listener) {
+        //noinspection ConstantConditions
+        if (listener == null) {
+            throw new IllegalArgumentException("Non-null 'listener' required.");
+        }
+        //noinspection ConstantConditions
+        if (mode == null) {
+            throw new IllegalArgumentException("Non-null 'mode' required.");
+        }
+    }
+
     void close() {
         isClosed = true;
         if (networkRequest != null) {
@@ -118,6 +306,139 @@ void close() {
         clearScheduledAccessTokenRefresh();
     }
 
+    // This method will be called once all changes have been downloaded or uploaded.
+    // This method might be called on another thread than the one that called `downloadAllServerChanges` or
+    // `uploadAllLocalChanges()`
+    //
+    // Be very careful with synchronized blocks.
+    // If the native listener was successfully registered, Object Store guarantees that this method will be called at
+    // least once, even if the session is closed.
+    @SuppressWarnings("unused")
+    private void notifyAllChangesSent(int callbackId, Long errorcode, String errorMessage) {
+        WaitForSessionWrapper wrapper = waitingForServerChanges.get();
+        if (wrapper != null) {
+            // Only react to callback if the callback is "active"
+            // A callback can only become inactive if the thread was interrupted:
+            // 1. Call `downloadAllServerChanges()` (callback = 1)
+            // 2. Interrupt it
+            // 3. Call `uploadAllLocalChanges()` ( callback = 2)
+            // 4. Sync notifies session that callback:1 is done. It should be ignored.
+            if (waitCounter.get() == callbackId) {
+                wrapper.handleResult(errorcode, errorMessage);
+            }
+        }
+    }
+
+    /**
+     * Calling this method will block until all known remote changes have been downloaded and applied to the Realm.
+     * This will involve network access, so calling this method should only be done from a non-UI thread.
+     * <p>
+     * If the device is offline, this method might never return.
+     * <p>
+     * This method cannot be called before the session has been started.
+     *
+     * @throws IllegalStateException if called on the Android main thread.
+     * @throws InterruptedException if the thread was interrupted while downloading was in progress.
+     */
+    public void downloadAllServerChanges() throws InterruptedException {
+        checkIfNotOnMainThread("downloadAllServerChanges() cannot be called from the main thread.");
+
+        // Blocking only happens at the Java layer. To prevent deadlocking the underlying SyncSession we register
+        // an async listener there and let it callback to the Java Session when done. This feels icky at best, but
+        // since all operations on the SyncSession operate under a shared mutex, we would prevent all other actions on the
+        // session, including trying to stop it.
+        // In Java we cannot lock on the Session object either since it will prevent any attempt at modifying the
+        // lifecycle while it is in a waiting state. Thus we use a specialised mutex.
+        synchronized (waitForChangesMutex) {
+            waitForChanges(DIRECTION_DOWNLOAD);
+        }
+    }
+
+    /**
+     * Calling this method will block until all known local changes have been uploaded to the server.
+     * This will involve network access, so calling this method should only be done from a non-UI thread.
+     * <p>
+     * If the device is offline, this method might never return.
+     * <p>
+     * This method cannot be called before the session has been started.
+     *
+     * @throws IllegalStateException if called on the Android main thread.
+     * @throws InterruptedException if the thread was interrupted while downloading was in progress.
+     */
+    public void uploadAllLocalChanges() throws InterruptedException {
+        checkIfNotOnMainThread("uploadAllLocalChanges() cannot be called from the main thread.");
+
+        // Blocking only happens at the Java layer. To prevent deadlocking the underlying SyncSession we register
+        // an async listener there and let it callback to the Java Session when done. This feels icky at best, but
+        // since all operations on the SyncSession operate under a shared mutex, we would prevent all other actions on the
+        // session, including trying to stop it.
+        // In Java we cannot lock on the Session object either since it will prevent any attempt at modifying the
+        // lifecycle while it is in a waiting state. Thus we use a specialised mutex.
+        synchronized (waitForChangesMutex) {
+            waitForChanges(DIRECTION_UPLOAD);
+        }
+    }
+
+    public void setResolvedRealmURI(URI resolvedRealmURI) {
+        this.resolvedRealmURI = resolvedRealmURI;
+    }
+
+    /**
+     * This method should only be called when guarded by the {@link #waitForChangesMutex}.
+     * It will block into all changes have been either uploaded or downloaded depending on the chosen direction.
+     *
+     * @param direction either {@link #DIRECTION_DOWNLOAD} or {@link #DIRECTION_UPLOAD}
+     */
+    private void waitForChanges(int direction) throws InterruptedException {
+        if (direction != DIRECTION_DOWNLOAD && direction != DIRECTION_UPLOAD) {
+            throw new IllegalArgumentException("Unknown direction: " + direction);
+        }
+        if (!isClosed) {
+            String realmPath = configuration.getPath();
+            WaitForSessionWrapper wrapper = new WaitForSessionWrapper();
+            waitingForServerChanges.set(wrapper);
+            int callbackId = waitCounter.incrementAndGet();
+            boolean listenerRegistered = (direction == DIRECTION_DOWNLOAD)
+                    ? nativeWaitForDownloadCompletion(callbackId, realmPath)
+                    : nativeWaitForUploadCompletion(callbackId, realmPath);
+            if (!listenerRegistered) {
+                waitingForServerChanges.set(null);
+                String errorMsg = "";
+                switch (direction) {
+                    case DIRECTION_DOWNLOAD: errorMsg = "It was not possible to download all remote changes."; break;
+                    case DIRECTION_UPLOAD: errorMsg = "It was not possible upload all local changes."; break;
+                    default:
+                        throw new IllegalArgumentException("Unknown direction: " + direction);
+                }
+
+                throw new ObjectServerError(ErrorCode.UNKNOWN, errorMsg + " Has the SyncClient been started?");
+            }
+            try {
+                wrapper.waitForServerChanges();
+            } catch(InterruptedException e) {
+                waitingForServerChanges.set(null); // Ignore any results being sent if the wait was interrupted.
+                throw e;
+            }
+
+            // This might return after the session was closed. In that case, just ignore any result
+            try {
+                if (!isClosed) {
+                    if (!wrapper.isSuccess()) {
+                        wrapper.throwExceptionIfNeeded();
+                    }
+                }
+            } finally {
+                waitingForServerChanges.set(null);
+            }
+        }
+    }
+
+    private void checkIfNotOnMainThread(String errorMessage) {
+        if (new AndroidCapabilities().isMainThread()) {
+            throw new IllegalStateException(errorMessage);
+        }
+    }
+
     /**
      * Interface used to report any session errors.
      *
@@ -173,10 +494,11 @@ void close() {
         void onError(SyncSession session, ObjectServerError error);
     }
 
-    String accessToken(final AuthenticationServer authServer) {
+    // Return the access token for the Realm this Session is connected to.
+    String getAccessToken(final AuthenticationServer authServer, String refreshToken) {
         // check first if there's a valid access_token we can return immediately
-        if (getUser().getSyncUser().isAuthenticated(configuration)) {
-            Token accessToken = getUser().getSyncUser().getAccessToken(configuration.getServerUrl());
+        if (getUser().isRealmAuthenticated(configuration)) {
+            Token accessToken = getUser().getAccessToken(configuration);
             // start refreshing this token if a refresh is not going on
             if (!onGoingAccessTokenQuery.getAndSet(true)) {
                 scheduleRefreshAccessToken(authServer, accessToken.expiresMs());
@@ -184,6 +506,19 @@ String accessToken(final AuthenticationServer authServer) {
             return accessToken.value();
 
         } else {
+            // check and update if we received a new refresh_token
+            if (!Util.isEmptyString(refreshToken)) {
+                try {
+                    JSONObject refreshTokenJSON = new JSONObject(refreshToken);
+                    Token newRefreshToken = Token.from(refreshTokenJSON.getJSONObject("userToken"));
+                    if (newRefreshToken.hashCode() != getUser().getRefreshToken().hashCode()) {
+                        RealmLog.debug("Session[%s]: Access token updated", configuration.getPath());
+                        getUser().setRefreshToken(newRefreshToken);
+                    }
+                } catch (JSONException e) {
+                    RealmLog.error(e,"Session[%s]: Can not parse the refresh_token into a valid JSONObject: ", configuration.getPath());
+                }
+            }
             if (!onGoingAccessTokenQuery.getAndSet(true)) {
                 if (NetworkStateReceiver.isOnline(SyncObjectServerFacade.getApplicationContext())) {
                     authenticateRealm(authServer);
@@ -223,9 +558,9 @@ private void authenticateRealm(final AuthenticationServer authServer) {
             protected AuthenticateResponse execute() {
                 if (!isClosed && !Thread.currentThread().isInterrupted()) {
                     return authServer.loginToRealm(
-                            getUser().getAccessToken(),//refresh token in fact
-                            configuration.getServerUrl(),
-                            getUser().getSyncUser().getAuthenticationUrl()
+                            getUser().getRefreshToken(), //refresh token in fact
+                            resolvedRealmURI,
+                            getUser().getAuthenticationUrl()
                     );
                 }
                 return null;
@@ -235,14 +570,9 @@ protected AuthenticateResponse execute() {
             protected void onSuccess(AuthenticateResponse response) {
                 RealmLog.debug("Session[%s]: Access token acquired", configuration.getPath());
                 if (!isClosed && !Thread.currentThread().isInterrupted()) {
-                    ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(
-                            response.getAccessToken(),
-                            configuration.getPath(),
-                            configuration.shouldDeleteRealmOnLogout()
-                    );
-                    getUser().getSyncUser().addRealm(configuration.getServerUrl(), desc);
-                    // schedule a token refresh before it expires
-                    if (nativeRefreshAccessToken(configuration.getPath(), getUser().getSyncUser().getAccessToken(configuration.getServerUrl()).value(), configuration.getServerUrl().toString())) {
+                    URI realmUrl = configuration.getServerUrl();
+                    getUser().addRealm(configuration, response.getAccessToken());
+                    if (nativeRefreshAccessToken(configuration.getPath(), response.getAccessToken().value(), realmUrl.toString())) {
                         scheduleRefreshAccessToken(authServer, response.getAccessToken().expiresMs());
 
                     } else {
@@ -255,8 +585,14 @@ protected void onSuccess(AuthenticateResponse response) {
             @Override
             protected void onError(AuthenticateResponse response) {
                 onGoingAccessTokenQuery.set(false);
-                RealmLog.debug("Session[%s]: Failed to get access token (%d)", configuration.getPath(), response.getError().getErrorCode());
-                if (!isClosed && !Thread.currentThread().isInterrupted()) {
+                RealmLog.debug("Session[%s]: Failed to get access token (%s)", configuration.getPath(),
+                        response.getError().getErrorCode());
+                if (!isClosed
+                        && !Thread.currentThread().isInterrupted()
+                        // We might be interrupted while negotiating an access token with the Realm Object Server
+                        // This will result in a InterruptedIOException from OkHttp. We should ignore this as
+                        // well.
+                        && !(response.getError().getException() instanceof InterruptedIOException)) {
                     errorHandler.onError(SyncSession.this, response.getError());
                 }
             }
@@ -265,35 +601,35 @@ protected void onError(AuthenticateResponse response) {
     }
 
     private void scheduleRefreshAccessToken(final AuthenticationServer authServer, long expireDateInMs) {
-            // calculate the delay time before which we should refresh the access_token,
-            // we adjust to 10 second to proactively refresh the access_token before the session
-            // hit the expire date on the token
-            long refreshAfter =  expireDateInMs - System.currentTimeMillis() - REFRESH_MARGIN_DELAY;
-            if (refreshAfter < 0) {
-                // Token already expired
-                RealmLog.debug("Expires time already reached for the access token, refresh as soon as possible");
-                // we avoid refreshing directly to avoid an edge case where the client clock is ahead
-                // of the server, causing all access_token received from the server to be always
-                // expired, we will flood the server with refresh token requests then, so adding
-                // a bit of delay is the best effort in this case.
-                refreshAfter = REFRESH_MARGIN_DELAY;
-            }
+        // calculate the delay time before which we should refresh the access_token,
+        // we adjust to 10 second to proactively refresh the access_token before the session
+        // hit the expire date on the token
+        long refreshAfter =  expireDateInMs - System.currentTimeMillis() - REFRESH_MARGIN_DELAY;
+        if (refreshAfter < 0) {
+            // Token already expired
+            RealmLog.debug("Expires time already reached for the access token, refresh as soon as possible");
+            // we avoid refreshing directly to avoid an edge case where the client clock is ahead
+            // of the server, causing all access_token received from the server to be always
+            // expired, we will flood the server with refresh token requests then, so adding
+            // a bit of delay is the best effort in this case.
+            refreshAfter = REFRESH_MARGIN_DELAY;
+        }
 
-            RealmLog.debug("Scheduling an access_token refresh in " + (refreshAfter) + " milliseconds");
+        RealmLog.debug("Scheduling an access_token refresh in " + (refreshAfter) + " milliseconds");
 
-            if (refreshTokenTask != null) {
-                refreshTokenTask.cancel();
-            }
+        if (refreshTokenTask != null) {
+            refreshTokenTask.cancel();
+        }
 
-            ScheduledFuture<?> task = REFRESH_TOKENS_EXECUTOR.schedule(new Runnable() {
-                @Override
-                public void run() {
-                    if (!isClosed && !Thread.currentThread().isInterrupted()) {
-                        refreshAccessToken(authServer);
-                    }
+        ScheduledFuture<?> task = REFRESH_TOKENS_EXECUTOR.schedule(new Runnable() {
+            @Override
+            public void run() {
+                if (!isClosed && !Thread.currentThread().isInterrupted() && !refreshTokenTask.isCancelled()) {
+                    refreshAccessToken(authServer);
                 }
-            }, refreshAfter, TimeUnit.MILLISECONDS);
-            refreshTokenTask = new RealmAsyncTaskImpl(task, REFRESH_TOKENS_EXECUTOR);
+            }
+        }, refreshAfter, TimeUnit.MILLISECONDS);
+        refreshTokenTask = new RealmAsyncTaskImpl(task, REFRESH_TOKENS_EXECUTOR);
     }
 
     // Authenticate by getting access tokens for the specific Realm
@@ -305,7 +641,7 @@ private void refreshAccessToken(final AuthenticationServer authServer) {
             @Override
             protected AuthenticateResponse execute() {
                 if (!isClosed && !Thread.currentThread().isInterrupted()) {
-                    return authServer.refreshUser(getUser().getSyncUser().getUserToken(), configuration.getServerUrl(), getUser().getSyncUser().getAuthenticationUrl());
+                    return authServer.refreshUser(getUser().getRefreshToken(), resolvedRealmURI, getUser().getAuthenticationUrl());
                 }
                 return null;
             }
@@ -313,17 +649,12 @@ protected AuthenticateResponse execute() {
             @Override
             protected void onSuccess(AuthenticateResponse response) {
                 synchronized (SyncSession.this) {
-                    if (!isClosed && !Thread.currentThread().isInterrupted()) {
+                    if (!isClosed && !Thread.currentThread().isInterrupted() && !refreshTokenNetworkRequest.isCancelled()) {
                         RealmLog.debug("Access Token refreshed successfully, Sync URL: " + configuration.getServerUrl());
-                        if (nativeRefreshAccessToken(configuration.getPath(), response.getAccessToken().value(), configuration.getUser().getAuthenticationUrl().toString())) {
-                            // replaced the user old access_token
-                            ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(
-                                    response.getAccessToken(),
-                                    configuration.getPath(),
-                                    configuration.shouldDeleteRealmOnLogout()
-                            );
-                            getUser().getSyncUser().addRealm(configuration.getServerUrl(), desc);
-
+                        URI realmUrl = configuration.getServerUrl();
+                        if (nativeRefreshAccessToken(configuration.getPath(), response.getAccessToken().value(), realmUrl.toString())) {
+                            // replace the user old access_token
+                            getUser().addRealm(configuration, response.getAccessToken());
                             // schedule the next refresh
                             scheduleRefreshAccessToken(authServer, response.getAccessToken().expiresMs());
                         }
@@ -342,15 +673,67 @@ protected void onError(AuthenticateResponse response) {
         refreshTokenNetworkRequest = new RealmAsyncTaskImpl(task, SyncManager.NETWORK_POOL_EXECUTOR);
     }
 
-    private void clearScheduledAccessTokenRefresh() {
+    void clearScheduledAccessTokenRefresh() {
         if (refreshTokenTask != null) {
             refreshTokenTask.cancel();
         }
         if (refreshTokenNetworkRequest != null) {
             refreshTokenNetworkRequest.cancel();
         }
+        onGoingAccessTokenQuery.set(false);
     }
 
-    private static native boolean nativeRefreshAccessToken(String path, String accessToken, String authURL);
-}
+    // Wrapper class for handling the async operations of the underlying SyncSession calling
+    // `async_wait_for_download_completion` or `async_wait_for_upload_completion`
+    private static class WaitForSessionWrapper {
+
+        private final CountDownLatch waiter = new CountDownLatch(1);
+        private volatile boolean resultReceived = false;
+        private Long errorCode = null;
+        private String errorMessage;
+
+        /**
+         * Block until the wait either completes or is terminated for other reasons.
+         */
+        public void waitForServerChanges() throws InterruptedException {
+            if (!resultReceived) {
+                waiter.await();
+            }
+        }
+
+        /**
+         * Process the result of a waiting action. This will also unblock anyone who called {@link #waiter}.
+         *
+         * @param errorCode error code if an error occurred, {@code null} if changes were successfully downloaded.
+         * @param errorMessage error message (if any).
+         */
+        public void handleResult(Long errorCode, String errorMessage) {
+            this.errorCode = errorCode;
+            this.errorMessage = errorMessage;
+            this.resultReceived = true;
+            waiter.countDown();
+        }
+
+        public boolean isSuccess() {
+            return resultReceived && errorCode == null;
+        }
 
+        /**
+         * Will throw an exception if the wait was terminated with an error. If it was canceled, this method will
+         * do nothing.
+         */
+        public void throwExceptionIfNeeded() {
+            if (resultReceived && errorCode != null) {
+                throw new ObjectServerError(ErrorCode.UNKNOWN,
+                        String.format(Locale.US, "Internal error (%d): %s", errorCode, errorMessage));
+            }
+        }
+    }
+
+    private static native long nativeAddProgressListener(String localRealmPath, long listenerId, int direction, boolean isStreaming);
+    private static native void nativeRemoveProgressListener(String localRealmPath, long listenerToken);
+    private static native boolean nativeRefreshAccessToken(String localRealmPath, String accessToken, String realmUrl);
+    private native boolean nativeWaitForDownloadCompletion(int callbackId, String localRealmPath);
+    private native boolean nativeWaitForUploadCompletion(int callbackId, String localRealmPath);
+    private static native byte nativeGetState(String localRealmPath);
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
index b1a78314af..ce82386309 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -16,14 +16,9 @@
 
 package io.realm;
 
-import android.os.Handler;
-import android.os.Looper;
-
-import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
 
-import java.io.File;
 import java.net.MalformedURLException;
 import java.net.URI;
 import java.net.URISyntaxException;
@@ -31,20 +26,26 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.concurrent.Future;
 import java.util.concurrent.ThreadPoolExecutor;
 
+import javax.annotation.Nullable;
+
+import io.realm.internal.RealmNotifier;
 import io.realm.internal.Util;
+import io.realm.internal.android.AndroidCapabilities;
+import io.realm.internal.android.AndroidRealmNotifier;
 import io.realm.internal.async.RealmAsyncTaskImpl;
 import io.realm.internal.network.AuthenticateResponse;
 import io.realm.internal.network.AuthenticationServer;
+import io.realm.internal.network.ChangePasswordResponse;
 import io.realm.internal.network.ExponentialBackoffTask;
 import io.realm.internal.network.LogoutResponse;
-import io.realm.internal.objectserver.ObjectServerUser;
+import io.realm.internal.network.LookupUserIdResponse;
 import io.realm.internal.objectserver.Token;
 import io.realm.log.RealmLog;
-import io.realm.permissions.PermissionModule;
 
 /**
  * This class represents a user on the Realm Object Server. The credentials are provided by various 3rd party
@@ -58,42 +59,16 @@
  * as sensitive data.
  */
 public class SyncUser {
-
-    private static class ManagementConfig {
-        private SyncConfiguration managementRealmConfig;
-
-        synchronized SyncConfiguration initAndGetManagementRealmConfig(
-                ObjectServerUser syncUser, final SyncUser user) {
-            if (managementRealmConfig == null) {
-                managementRealmConfig = new SyncConfiguration.Builder(
-                        user, getManagementRealmUrl(syncUser.getAuthenticationUrl()))
-                        .errorHandler(new SyncSession.ErrorHandler() {
-                            @Override
-                            public void onError(SyncSession session, ObjectServerError error) {
-                                if (error.getErrorCode() == ErrorCode.CLIENT_RESET) {
-                                    RealmLog.error("Client Reset required for user's management Realm: " + user.toString());
-                                } else {
-                                    RealmLog.error(String.format("Unexpected error with %s's management Realm: %s",
-                                            user.getIdentity(),
-                                            error.toString()));
-                                }
-                            }
-                        })
-                        .modules(new PermissionModule())
-                        .build();
-            }
-
-            return managementRealmConfig;
-        }
-    }
-
-
-    private final ManagementConfig managementConfig = new ManagementConfig();
-
-    private final ObjectServerUser syncUser;
-
-    private SyncUser(ObjectServerUser user) {
-        this.syncUser = user;
+    private final String identity;
+    private Token refreshToken;
+    private final URL authenticationUrl;
+    // maps all RealmConfiguration and accessToken, using this SyncUser.
+    private final Map<SyncConfiguration, Token> realms = new HashMap<SyncConfiguration, Token>();
+
+    SyncUser(Token refreshToken, URL authenticationUrl) {
+        this.identity = refreshToken.identity();
+        this.authenticationUrl = authenticationUrl;
+        this.refreshToken = refreshToken;
     }
 
     /**
@@ -101,7 +76,7 @@ private SyncUser(ObjectServerUser user) {
      * A user is invalidated when he/she logs out or the user's access token expires.
      *
      * @return current {@link SyncUser} that has logged in and is still valid. {@code null} if no user is logged in or the user has
-     *         expired.
+     * expired.
      * @throws IllegalStateException if multiple users are logged in.
      */
     public static SyncUser currentUser() {
@@ -121,7 +96,7 @@ public static SyncUser currentUser() {
     public static Map<String, SyncUser> all() {
         UserStore userStore = SyncManager.getUserStore();
         Collection<SyncUser> storedUsers = userStore.allUsers();
-        Map<String, SyncUser> map = new HashMap<String, SyncUser>();
+        Map<String, SyncUser> map = new HashMap<>();
         for (SyncUser user : storedUsers) {
             if (user.isValid()) {
                 map.put(user.getIdentity(), user);
@@ -134,7 +109,6 @@ public static SyncUser currentUser() {
      * Loads a user that has previously been serialized using {@link #toJson()}.
      *
      * @param user JSON string representing the user.
-     *
      * @return the user object.
      * @throws IllegalArgumentException if the JSON couldn't be converted to a valid {@link SyncUser} object.
      */
@@ -143,21 +117,11 @@ public static SyncUser fromJson(String user) {
             JSONObject obj = new JSONObject(user);
             URL authUrl = new URL(obj.getString("authUrl"));
             Token userToken = Token.from(obj.getJSONObject("userToken"));//TODO rename to refresh_token
-            ObjectServerUser syncUser = new ObjectServerUser(userToken, authUrl);
-            JSONArray realmTokens = obj.getJSONArray("realms");
-            for (int i = 0; i < realmTokens.length(); i++) {
-                JSONObject token = realmTokens.getJSONObject(i);
-                URI uri = new URI(token.getString("uri"));
-                ObjectServerUser.AccessDescription realmDesc = ObjectServerUser.AccessDescription.fromJson(token.getJSONObject("description"));
-                syncUser.addRealm(uri, realmDesc);
-            }
-            return new SyncUser(syncUser);
+            return new SyncUser(userToken, authUrl);
         } catch (JSONException e) {
             throw new IllegalArgumentException("Could not parse user json: " + user, e);
         } catch (MalformedURLException e) {
             throw new IllegalArgumentException("URL in JSON not valid: " + user, e);
-        } catch (URISyntaxException e) {
-            throw new IllegalArgumentException("URI is not valid: " + user, e);
         }
     }
 
@@ -191,14 +155,14 @@ public static SyncUser login(final SyncCredentials credentials, final String aut
                 // the JSON response expected from the server.
                 String userIdentifier = credentials.getUserIdentifier();
                 String token = (String) credentials.getUserInfo().get("_token");
-                result = AuthenticateResponse.createValidResponseWithUser(userIdentifier, token);
+                boolean isAdmin = (Boolean) credentials.getUserInfo().get("_isAdmin");
+                result = AuthenticateResponse.createValidResponseWithUser(userIdentifier, token, isAdmin);
             } else {
                 final AuthenticationServer server = SyncManager.getAuthServer();
                 result = server.loginUser(credentials, authUrl);
             }
             if (result.isValid()) {
-                ObjectServerUser syncUser = new ObjectServerUser(result.getRefreshToken(), authUrl);
-                SyncUser user = new SyncUser(syncUser);
+                SyncUser user = new SyncUser(result.getRefreshToken(), authUrl);
                 RealmLog.info("Succeeded authenticating user.\n%s", user);
                 SyncManager.getUserStore().put(user);
                 SyncManager.notifyUserLoggedIn(user);
@@ -220,115 +184,76 @@ public static SyncUser login(final SyncCredentials credentials, final String aut
      * @param credentials credentials to use.
      * @param authenticationUrl server that the user is authenticated against.
      * @param callback callback when login has completed or failed. The callback will always happen on the same thread
-     *                 as this this method is called on.
+     * as this this method is called on.
+     * @return representation of the async task that can be used to cancel it if needed.
      * @throws IllegalArgumentException if not on a Looper thread.
      */
-    public static RealmAsyncTask loginAsync(final SyncCredentials credentials, final String authenticationUrl, final Callback callback) {
-        if (Looper.myLooper() == null) {
-            throw new IllegalStateException("Asynchronous login is only possible from looper threads.");
-        }
-        final Handler handler = new Handler(Looper.myLooper());
-        ThreadPoolExecutor networkPoolExecutor = SyncManager.NETWORK_POOL_EXECUTOR;
-        Future<?> authenticateRequest = networkPoolExecutor.submit(new Runnable() {
+    public static RealmAsyncTask loginAsync(final SyncCredentials credentials, final String authenticationUrl, final Callback<SyncUser> callback) {
+        checkLooperThread("Asynchronous login is only possible from looper threads.");
+        return new Request<SyncUser>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
             @Override
-            public void run() {
-                try {
-                    SyncUser user = login(credentials, authenticationUrl);
-                    postSuccess(user);
-                } catch (ObjectServerError e) {
-                    postError(e);
-                }
+            public SyncUser run() throws ObjectServerError {
+                return login(credentials, authenticationUrl);
             }
-
-            private void postError(final ObjectServerError error) {
-                if (callback != null) {
-                    handler.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            try {
-                                callback.onError(error);
-                            } catch (Exception e) {
-                                RealmLog.info("onError has thrown an exception but is ignoring it: %s",
-                                        Util.getStackTrace(e));
-                            }
-                        }
-                    });
-                }
-            }
-
-            private void postSuccess(final SyncUser user) {
-                if (callback != null) {
-                    handler.post(new Runnable() {
-                        @Override
-                        public void run() {
-                            callback.onSuccess(user);
-                        }
-                    });
-                }
-            }
-        });
-
-        return new RealmAsyncTaskImpl(authenticateRequest, networkPoolExecutor);
+        }.start();
     }
 
     /**
-     * Logs out the user from the Realm Object Server. Once the Object Server has confirmed the logout any registered
-     * {@link AuthenticationListener} will be notified and user credentials will be deleted from this device.
+     * Log a user out, destroying their server state, unregistering them from the SDK, and removing
+     * any synced Realms associated with them, from on-disk storage on next app launch (or directly
+     * if all instances are closed).
+     * If the user is already logged out or in an error state, this method does nothing.
      *
-     * @throws IllegalStateException if any Realms owned by this user is still open. They should be closed before
-     *         logging out.
-     */
-    /* FIXME: Add this back to the javadoc when enable SyncConfiguration.Builder#deleteRealmOnLogout()
-     <p>
-     Any Realms owned by the user will be deleted if {@link SyncConfiguration.Builder#deleteRealmOnLogout()} is
-     also set.
+     * This method should be called whenever the application is committed to not using a user again
+     * unless they are recreated. Failing to call this method may result in unused files and metadata
+     * needlessly taking up space.
+     *
+     * Once the Object Server has confirmed the logout any registered {@link AuthenticationListener}
+     * will be notified and user credentials will be deleted from this device.
      */
+//    /* FIXME: Add this back to the javadoc when enable SyncConfiguration.Builder#deleteRealmOnLogout()
+//     <p>
+//     Any Realms owned by the user will be deleted, when the application restart.
+//     */
+    // this is a fire and forget, end user should not worry about the state of the async query
+    @SuppressWarnings("FutureReturnValueIgnored")
     public void logout() {
         // Acquire lock to prevent users creating new instances
         synchronized (Realm.class) {
-            if (!syncUser.isLoggedIn()) {
-                return; // Already local/global logout status
+            if (!SyncManager.getUserStore().isActive(identity, authenticationUrl.toString())) {
+                return; // Already logged out status
             }
 
-            // Ensure that we can log out. If any Realm file is still open we should abort before doing anything
-            // else.
-            Collection<SyncSession> sessions = syncUser.getSessions();
-            for (SyncSession session : sessions) {
-                SyncConfiguration config = session.getConfiguration();
-                if (Realm.getGlobalInstanceCount(config) > 0) {
-                    throw new IllegalStateException("A Realm controlled by this user is still open. Close all Realms " +
-                            "before logging out: " + config.getPath());
-                }
-            }
-
-            SyncManager.getUserStore().remove(syncUser.getIdentity());
+            // Mark the user as logged out in the ObjectStore
+            SyncManager.getUserStore().remove(identity, authenticationUrl.toString());
 
-            // Delete all Realms if needed.
-            for (ObjectServerUser.AccessDescription desc : syncUser.getRealms()) {
-                // FIXME: This will always be false since SyncConfiguration.Builder.deleteRealmOnLogout() is
-                // disabled. Make sure this works for Realm opened in the client thread/other processes.
-                if (desc.deleteOnLogout) {
-                    File realmFile = new File(desc.localPath);
-                    if (realmFile.exists() && !Util.deleteRealm(desc.localPath, realmFile.getParentFile(), realmFile.getName())) {
-                        RealmLog.error("Could not delete Realm when user logged out: " + desc.localPath);
-                    }
+            // invalidate all pending refresh_token queries
+            for (SyncConfiguration syncConfiguration : realms.keySet()) {
+                SyncSession session = SyncManager.getSession(syncConfiguration);
+                if (session != null) {
+                    session.clearScheduledAccessTokenRefresh();
                 }
             }
 
             // Remove all local tokens, preventing further connections.
-            final Token userToken = syncUser.getUserToken();
-            syncUser.clearTokens();
-            syncUser.localLogout();
+            // don't remove identity as this SyncUser might be re-activated and we need
+            // to avoid throwing a mismatch SyncConfiguration in RealmCache if we have
+            // the similar SyncConfiguration using the same identity, but with different (new)
+            // refresh-token.
+            realms.clear();
 
             // Finally revoke server token. The local user is logged out in any case.
             final AuthenticationServer server = SyncManager.getAuthServer();
+            // don't reference directly the refreshToken inside the revoke request
+            // as it may revoke the newly acquired refresh_token
+            final Token refreshTokenToBeRevoked = refreshToken;
+
             ThreadPoolExecutor networkPoolExecutor = SyncManager.NETWORK_POOL_EXECUTOR;
-            //noinspection unused
-            final Future<?> future = networkPoolExecutor.submit(new ExponentialBackoffTask<LogoutResponse>() {
+            networkPoolExecutor.submit(new ExponentialBackoffTask<LogoutResponse>(3) {
 
                 @Override
                 protected LogoutResponse execute() {
-                    return server.logout(userToken, syncUser.getAuthenticationUrl());
+                    return server.logout(refreshTokenToBeRevoked, getAuthenticationUrl());
                 }
 
                 @Override
@@ -344,6 +269,195 @@ protected void onError(LogoutResponse response) {
         }
     }
 
+    /**
+     * Changes this user's password. This is done synchronously and involves the network, so calling this method on the
+     * Android UI thread will always crash.
+     * <p>
+     * <b>WARNING:</b> Changing a user's password through an authentication server that doesn't use HTTPS is a major
+     * security flaw, and should only be done while testing.
+     *
+     * @param newPassword the user's new password.
+     * @throws ObjectServerError if the password could not be changed.
+     */
+    public void changePassword(final String newPassword) throws ObjectServerError {
+        //noinspection ConstantConditions
+        if (newPassword == null) {
+            throw new IllegalArgumentException("Not-null 'newPassword' required.");
+        }
+        AuthenticationServer authServer = SyncManager.getAuthServer();
+        ChangePasswordResponse response = authServer.changePassword(refreshToken, newPassword, getAuthenticationUrl());
+        if (!response.isValid()) {
+            throw response.getError();
+        }
+    }
+
+    /**
+     * Changes another user's password. This is done synchronously and involves the network, so calling this method on the
+     * Android UI thread will always crash.
+     * <p>
+     * This user needs admin privilege in order to change someone else's password.
+     * <p>
+     * <b>WARNING:</b> Changing a user's password through an authentication server that doesn't use HTTPS is a major
+     * security flaw, and should only be done while testing.
+     *
+     * @param userId identity ({@link #getIdentity()}) of the user we want to change the password for.
+     * @param newPassword the user's new password.
+     * @throws ObjectServerError if the password could not be changed.
+     */
+    public void changePassword(final String userId, final String newPassword) throws ObjectServerError {
+        //noinspection ConstantConditions
+        if (newPassword == null) {
+            throw new IllegalArgumentException("Not-null 'newPassword' required.");
+        }
+
+        if (Util.isEmptyString(userId)) {
+            throw new IllegalArgumentException("None empty 'userId' required.");
+        }
+
+        if (userId.equals(getIdentity())) { // user want's to change his/her own password
+            changePassword(newPassword);
+
+        } else {
+            if (!isAdmin()) {
+                throw new IllegalStateException("User need to be admin in order to change another user's password.");
+            }
+
+            AuthenticationServer authServer = SyncManager.getAuthServer();
+            ChangePasswordResponse response = authServer.changePassword(refreshToken, userId, newPassword, getAuthenticationUrl());
+            if (!response.isValid()) {
+                throw response.getError();
+            }
+        }
+    }
+
+    /**
+     * Changes this user's password asynchronously.
+     * <p>
+     * <b>WARNING:</b> Changing a users password using an authentication server that doesn't use HTTPS is a major
+     * security flaw, and should only be done while testing.
+     *
+     * @param newPassword the user's new password.
+     * @param callback callback when login has completed or failed. The callback will always happen on the same thread
+     * as this method is called on.
+     * @return representation of the async task that can be used to cancel it if needed.
+     * @throws IllegalArgumentException if not on a Looper thread.
+     */
+    public RealmAsyncTask changePasswordAsync(final String newPassword, final Callback<SyncUser> callback) {
+        checkLooperThread("Asynchronous changing password is only possible from looper threads.");
+        //noinspection ConstantConditions
+        if (callback == null) {
+            throw new IllegalArgumentException("Non-null 'callback' required.");
+        }
+        return new Request<SyncUser>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
+            @Override
+            public SyncUser run() {
+                changePassword(newPassword);
+                return SyncUser.this;
+            }
+        }.start();
+    }
+
+    /**
+     * Changes another user's password asynchronously.
+     * <p>
+     * This user needs admin privilege in order to change someone else's password.
+     *
+     * <b>WARNING:</b> Changing a users password using an authentication server that doesn't use HTTPS is a major
+     * security flaw, and should only be done while testing.
+     *
+     * @param userId identity ({@link #getIdentity()}) of the user we want to change the password for.
+     * @param newPassword the user's new password.
+     * @param callback callback when login has completed or failed. The callback will always happen on the same thread
+     * as this method is called on.
+     * @return representation of the async task that can be used to cancel it if needed.
+     * @throws IllegalArgumentException if not on a Looper thread.
+     */
+    public RealmAsyncTask changePasswordAsync(final String userId, final String newPassword, final Callback<SyncUser> callback) {
+        checkLooperThread("Asynchronous changing password is only possible from looper threads.");
+        //noinspection ConstantConditions
+        if (callback == null) {
+            throw new IllegalArgumentException("Non-null 'callback' required.");
+        }
+
+        return new Request<SyncUser>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
+            @Override
+            public SyncUser run() {
+                changePassword(userId, newPassword);
+                return SyncUser.this;
+            }
+        }.start();
+    }
+
+    /**
+     * Given a Realm Object Server authentication provider and a provider identifier for a user (for example, a username), look up and return user information for that user.
+     *
+     * @param providerUserIdentity The username or identity of the user as issued by the authentication provider.
+     *                             In most cases this is different from the Realm Object Server-issued identity.
+     * @param provider The authentication provider {@link io.realm.SyncCredentials.IdentityProvider} that manages the user whose information is desired.
+     *
+     * @return {@code SyncUser} associated with the given identity provider and providerId, or {@code null} in case
+     * of an {@code invalid} provider or {@code providerId}.
+     * @throws ObjectServerError in case of an error.
+     */
+    public SyncUserInfo retrieveInfoForUser(final String providerUserIdentity, final String provider) throws ObjectServerError {
+        if (Util.isEmptyString(providerUserIdentity)) {
+            throw new IllegalArgumentException("'providerUserIdentity' cannot be empty.");
+        }
+
+        if (Util.isEmptyString(provider)) {
+            throw new IllegalArgumentException("'provider' cannot be empty.");
+        }
+
+        if (!isAdmin()) {
+            throw new IllegalArgumentException("SyncUser needs to be admin in order to lookup other users ID.");
+        }
+
+        AuthenticationServer authServer = SyncManager.getAuthServer();
+        LookupUserIdResponse response = authServer.retrieveUser(refreshToken, provider, providerUserIdentity, getAuthenticationUrl());
+        if (!response.isValid()) {
+            if (response.getError().getErrorCode() == ErrorCode.UNKNOWN_ACCOUNT) {
+                return null;
+            } else {
+                throw response.getError();
+            }
+        } else {
+            return SyncUserInfo.fromLookupUserIdResponse(response);
+        }
+    }
+
+    /**
+     * Given a Realm Object Server authentication provider and a provider identifier for a user (for example, a username), asynchronously look up and return user information for that user.
+     *
+     * @param providerUserIdentity The username or identity of the user as issued by the authentication provider.
+     *                             In most cases this is different from the Realm Object Server-issued identity.
+     * @param provider The authentication provider {@link io.realm.SyncCredentials.IdentityProvider} that manages the user whose information is desired.
+     *
+     * @return {@code SyncUser} associated with the given identity provider and providerId, or {@code null} in case
+     * of an {@code invalid} provider or {@code providerId}.
+     * @param callback callback when the lookup has completed or failed. The callback will always happen on the same thread
+     * as this method is called on.
+     * @return representation of the async task that can be used to cancel it if needed.
+     */
+    public RealmAsyncTask retrieveInfoForUserAsync(final String providerUserIdentity, final String provider, final Callback<SyncUserInfo> callback) {
+        checkLooperThread("Asynchronously retrieving user is only possible from looper threads.");
+        //noinspection ConstantConditions
+        if (callback == null) {
+            throw new IllegalArgumentException("Non-null 'callback' required.");
+        }
+
+        return new Request<SyncUserInfo>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
+            @Override
+            public SyncUserInfo run() throws ObjectServerError {
+                return retrieveInfoForUser(providerUserIdentity, provider);
+            }
+        }.start();
+    }
+
+    private static void checkLooperThread(String errorMessage) {
+        AndroidCapabilities capabilities = new AndroidCapabilities();
+        capabilities.checkCanDeliverNotification(errorMessage);
+    }
+
     /**
      * Returns a JSON token representing this user.
      * <p>
@@ -351,12 +465,18 @@ protected void onError(LogoutResponse response) {
      * should be treated as sensitive data.
      *
      * @return JSON string representing this user. It can be converted back into a real user object using
-     *         {@link #fromJson(String)}.
-     *
+     * {@link #fromJson(String)}.
      * @see #fromJson(String)
      */
     public String toJson() {
-        return syncUser.toJson();
+        JSONObject obj = new JSONObject();
+        try {
+            obj.put("authUrl", authenticationUrl);
+            obj.put("userToken", refreshToken.toJson());
+            return obj.toString();
+        } catch (JSONException e) {
+            throw new RuntimeException("Could not convert SyncUser to JSON", e);
+        }
     }
 
     /**
@@ -371,8 +491,18 @@ public String toJson() {
      * @return {@code true} if the User is logged into the Realm Object Server, {@code false} otherwise.
      */
     public boolean isValid() {
-        Token userToken = getSyncUser().getUserToken();
-        return syncUser.isLoggedIn() && userToken != null && userToken.expiresMs() > System.currentTimeMillis();
+        return refreshToken != null && refreshToken.expiresMs() > System.currentTimeMillis() && SyncManager.getUserStore().isActive(identity, authenticationUrl.toString());
+    }
+
+    /**
+     * Returns {@code true} if this user is an administrator on the Realm Object Server, {@code false} otherwise.
+     * <p>
+     * Administrators can access all Realms on the server as well as change the permissions of the Realms.
+     *
+     * @return {@code true} if the user is an administrator on the Realm Object Server, {@code false} otherwise.
+     */
+    public boolean isAdmin() {
+        return refreshToken.isAdmin();
     }
 
     /**
@@ -380,42 +510,60 @@ public boolean isValid() {
      * among all users on the Realm Object Server.
      *
      * @return identity of the user on the Realm Object Server. If the user has logged out or the login has expired
-     *         {@code null} is returned.
+     * {@code null} is returned.
      */
     public String getIdentity() {
-        return syncUser.getIdentity();
+        return identity;
     }
 
     /**
-     * Returns this user's access token. This is the users credential for accessing the Realm Object Server and should
+     * Returns this user's refresh token. This is the users credential for accessing the Realm Object Server and should
      * be treated as sensitive data.
      *
-     * @return the user's access token. If this user has logged out or the login has expired {@code null} is returned.
+     * @return the user's refresh token. If this user has logged out or the login has expired {@code null} is returned.
      */
-    public Token getAccessToken() {
-        Token userToken = syncUser.getUserToken();
-        return (userToken != null) ? userToken : null;
+    Token getRefreshToken() {
+        return refreshToken;
+    }
+
+    void setRefreshToken(Token refreshToken) {
+        this.refreshToken = refreshToken;
     }
 
     /**
-     * Returns an instance of the Management Realm owned by the user.
-     * <p>
-     * This Realm can be used to control access and permissions for Realms owned by the user. This includes
-     * giving other users access to Realms.
+     * Returns all the valid sessions belonging to the user.
+     *
+     * @return the all valid sessions belong to the user.
+     */
+    public List<SyncSession> allSessions() {
+        return SyncManager.getAllSessions(this);
+    }
+
+    /**
+     * Checks if the user has access to the given Realm. Being authenticated means that the
+     * user is known by the Realm Object Server and have been granted access to the given Realm.
      *
-     * @see <a href="https://realm.io/docs/realm-object-server/#permissions">How to control permissions</a>
+     * Authenticating will happen automatically as part of opening a Realm.
      */
-    public Realm getManagementRealm() {
-        return Realm.getInstance(managementConfig.initAndGetManagementRealmConfig(syncUser, this));
+    boolean isRealmAuthenticated(SyncConfiguration configuration) {
+        Token token = realms.get(configuration);
+        return token != null && token.expiresMs() > System.currentTimeMillis();
     }
 
+    Token getAccessToken(SyncConfiguration configuration) {
+        return realms.get(configuration);
+    }
+
+    void addRealm(SyncConfiguration syncConfiguration, Token accessToken) {
+        realms.put(syncConfiguration, accessToken);
+    }
     /**
      * Returns the {@link URL} where this user was authenticated.
      *
      * @return {@link URL} where the user was authenticated.
      */
     public URL getAuthenticationUrl() {
-        return syncUser.getAuthenticationUrl();
+        return authenticationUrl;
     }
 
     // Creates the URL to the permission Realm based on the authentication URL.
@@ -432,40 +580,124 @@ private static String getManagementRealmUrl(URL authUrl) {
         }
     }
 
+    /**
+     * Returns an instance of the {@link PermissionManager} for this user that makes it possible to see, modify and create
+     * permissions related to this users Realms.
+     * <p>
+     * Every instance returned by this method must be closed by calling {@link PermissionManager#close()} when it
+     * no longer is needed.
+     * <p>
+     * The {@link PermissionManager} can only be opened from the main tread, calling this method from any other thread
+     * will throw an {@link IllegalStateException}.
+     *
+     * @throws IllegalStateException if this method is not called from the UI thread.
+     * @return an instance of the PermissionManager.
+     */
+    public PermissionManager getPermissionManager() {
+        if (!new AndroidCapabilities().isMainThread()) {
+            throw new IllegalStateException("The PermissionManager can only be opened from the main thread.");
+        }
+        return PermissionManager.getInstance(this);
+    }
+
+    // what defines a user is it's identity(Token) and authURL (as required by the constructor)
+    //
+    // not the list of Realms it's managing, furthermore, trying to include the `realms` in the `hashCode` will
+    // end in a StackOverFlow, since we need to calculate the `hashCode` of the SyncConfiguration which itself
+    // contains a reference to the SyncUser.
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
 
-        SyncUser user = (SyncUser) o;
-
-        return syncUser.equals(user.syncUser);
+        SyncUser syncUser = (SyncUser) o;
 
+        if (!identity.equals(syncUser.identity)) return false;
+        return authenticationUrl.toExternalForm().equals(syncUser.authenticationUrl.toExternalForm());
     }
 
     @Override
     public int hashCode() {
-        return syncUser.hashCode();
+        int result = identity.hashCode();
+        result = 31 * result + authenticationUrl.toExternalForm().hashCode();
+        return result;
     }
 
     @Override
     public String toString() {
         StringBuilder sb = new StringBuilder("{");
-        sb.append("UserId: ").append(syncUser.getIdentity());
-        sb.append(", AuthUrl: ").append(syncUser.getAuthenticationUrl());
-        sb.append(", IsValid: ").append(isValid());
-        sb.append(", Sessions: ").append(syncUser.getSessions().size());
+        sb.append("UserId: ").append(identity);
+        sb.append(", AuthUrl: ").append(getAuthenticationUrl());
         sb.append("}");
         return sb.toString();
     }
 
-    // Expose internal representation for other package protected classes
-    ObjectServerUser getSyncUser() {
-        return syncUser;
+    // Class wrapping requests made against the auth server. Is also responsible for calling with success/error on the
+    // correct thread.
+    private static abstract class Request<T> {
+        @Nullable
+        private final Callback<T> callback;
+        private final RealmNotifier handler;
+        private final ThreadPoolExecutor networkPoolExecutor;
+
+        Request(ThreadPoolExecutor networkPoolExecutor, @Nullable Callback<T> callback) {
+            this.callback = callback;
+            this.handler = new AndroidRealmNotifier(null, new AndroidCapabilities());
+            this.networkPoolExecutor = networkPoolExecutor;
+        }
+
+        // Implements the request. Return the current sync user if the request succeeded. Otherwise throw an error.
+        public abstract T run() throws ObjectServerError;
+
+        // Start the request
+        public RealmAsyncTask start() {
+            Future<?> authenticateRequest = networkPoolExecutor.submit(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        postSuccess(Request.this.run());
+                    } catch (ObjectServerError e) {
+                        postError(e);
+                    } catch (Throwable e) {
+                        postError(new ObjectServerError(ErrorCode.UNKNOWN, "Unexpected error", e));
+                    }
+                }
+            });
+            return new RealmAsyncTaskImpl(authenticateRequest, networkPoolExecutor);
+        }
+
+        private void postError(final ObjectServerError error) {
+            boolean errorHandled = false;
+            if (callback != null) {
+                Runnable action = new Runnable() {
+                    @Override
+                    public void run() {
+                        callback.onError(error);
+                    }
+                };
+                errorHandled = handler.post(action);
+            }
+
+            if (!errorHandled) {
+                RealmLog.error(error, "An error was thrown, but could not be handled.");
+            }
+        }
+
+        private void postSuccess(final T result) {
+            if (callback != null) {
+                handler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        callback.onSuccess(result);
+                    }
+                });
+            }
+        }
     }
 
-    public interface Callback {
-        void onSuccess(SyncUser user);
+    public interface Callback<T> {
+        void onSuccess(T result);
+
         void onError(ObjectServerError error);
     }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUserInfo.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUserInfo.java
new file mode 100644
index 0000000000..a9a1369966
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUserInfo.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import java.util.Collections;
+import java.util.Map;
+
+import io.realm.internal.network.LookupUserIdResponse;
+
+/**
+ * POJO representing information about a user that was retrieved from a user lookup call.
+ * @see SyncUser#retrieveInfoForUser(String, String)
+ */
+
+public class SyncUserInfo {
+    private final String identity;
+    private final boolean isAdmin;
+    private final Map<String, String> metadata;
+    private final Map<String, String> accounts;
+
+    private SyncUserInfo(String identity, boolean isAdmin, Map<String, String> metadata, Map<String, String> accounts) {
+        this.identity = identity;
+        this.isAdmin = isAdmin;
+        this.metadata = Collections.unmodifiableMap(metadata);
+        this.accounts = Collections.unmodifiableMap(accounts);
+    }
+
+    static SyncUserInfo fromLookupUserIdResponse(LookupUserIdResponse response) {
+        return new SyncUserInfo(response.getUserId(), response.isAdmin(), response.getMetadata(), response.getAccounts());
+    }
+
+    /**
+     * @return the identity issued to this user by the Realm Object Server.
+     */
+    public String getIdentity() {
+        return identity;
+    }
+
+    /**
+     * @return whether the user is flagged on the Realm Object Server as an administrator.
+     */
+    public boolean isAdmin() {
+        return isAdmin;
+    }
+
+    /**
+     * Returns the metadata associated with the user. The metadata is a generic key/value map with
+     * the only restriction that a key must be non-empty.
+     *
+     * @return the metadata associated with this user.
+     */
+    public Map<String, String> getMetadata() {
+        return metadata;
+    }
+
+    /**
+     * Returns the accounts associated with this user. The map returned is a map of {@link SyncCredentials.IdentityProvider}
+     * and the providerId used in that provider.
+     * <p>
+     * Example being {@code ("password", "my@email.com") }, if the user created an account using the standard account creation
+     * supported by the Realm Object Server.
+     * <p>
+     * A user can have multiple accounts associated with it.
+     *
+     * @return the accounts associated with the user.
+     */
+    public Map<String, String> getAccounts() { return accounts; }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        SyncUserInfo that = (SyncUserInfo) o;
+
+        if (isAdmin != that.isAdmin) return false;
+        if (!identity.equals(that.identity)) return false;
+        return metadata.equals(that.metadata);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = identity.hashCode();
+        result = 31 * result + (isAdmin ? 1 : 0);
+        result = 31 * result + metadata.hashCode();
+        return result;
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/UserStore.java b/realm/realm-library/src/objectServer/java/io/realm/UserStore.java
index 7a7b488337..584f8e7ae4 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/UserStore.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/UserStore.java
@@ -18,6 +18,9 @@
 
 import java.util.Collection;
 
+import javax.annotation.Nullable;
+
+
 /**
  * Interface for classes responsible for saving and retrieving Object Server users again.
  * <p>
@@ -43,15 +46,18 @@
      * This method will throw an exception if more than one valid, logged in users exist.
      * @return {@link SyncUser} object or {@code null} if not found.
      */
+    @Nullable
     SyncUser getCurrent();
 
     /**
      * Retrieves specified {@link SyncUser}.
      *
      * @param identity identity of the user.
+     * @param authenticationUrl the URL of the authentication.
      * @return {@link SyncUser} object or {@code null} if not found.
      */
-    SyncUser get(String identity);
+    @Nullable
+    SyncUser get(String identity, String authenticationUrl);
 
     /**
      * Removes the user from the store.
@@ -59,8 +65,9 @@
      * If the user is not found, this method does nothing.
      *
      * @param identity identity of the user.
+     * @param authenticationUrl the URL of the authentication.
      */
-    void remove(String identity);
+    void remove(String identity, String authenticationUrl);
 
     /**
      * Returns a collection of all users saved in the User store.
@@ -68,4 +75,15 @@
      * @return Collection of all users. If no users exist, an empty collection is returned.
      */
     Collection<SyncUser> allUsers();
+
+    /**
+     * Returns the state of the specified user: {@code true} if active (not logged out), {@code false} otherwise.
+     * This method checks if the user was marked as logged out. If the user has expired but not actively logged out
+     * this method will return {@code true}.
+     *
+     * @param identity identity of the user.
+     * @param authenticationUrl the URL of the authentication.
+     * @return {@code true} if the user is not logged out, {@code false} otherwise.
+     */
+    boolean isActive(String identity, String authenticationUrl);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/exceptions/DownloadingRealmInterruptedException.java b/realm/realm-library/src/objectServer/java/io/realm/exceptions/DownloadingRealmInterruptedException.java
new file mode 100644
index 0000000000..0460d297d5
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/exceptions/DownloadingRealmInterruptedException.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.exceptions;
+
+import io.realm.SyncConfiguration;
+
+
+/**
+ * Exception class used when a Realm was interrupted while downloading the initial data set.
+ * This can only happen if {@link SyncConfiguration.Builder#waitForInitialRemoteData()} is set.
+ */
+public class DownloadingRealmInterruptedException extends RuntimeException {
+    public DownloadingRealmInterruptedException(SyncConfiguration syncConfig, Throwable exception) {
+        super("Realm was interrupted while downloading the latest changes from the server: " + syncConfig.getPath(),
+                exception);
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/exceptions/IncompatibleSyncedFileException.java b/realm/realm-library/src/objectServer/java/io/realm/exceptions/IncompatibleSyncedFileException.java
new file mode 100644
index 0000000000..2742b11ac7
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/exceptions/IncompatibleSyncedFileException.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.exceptions;
+
+import javax.annotation.Nullable;
+
+import io.realm.RealmConfiguration;
+import io.realm.RealmModel;
+import io.realm.SyncConfiguration;
+import io.realm.internal.Keep;
+
+/**
+ * An exception thrown when attempting to open an incompatible Synchronized Realm file. This usually happens
+ * when the Realm file was created with an older version of the SDK and automatic migration to the current version
+ * is not possible. When such an exception occurs, the original file is moved to a backup location and a new file is
+ * created instead. If you wish to migrate any data from the backup location, you can use {@link #getBackupRealmConfiguration()}
+ * to obtain a {@link RealmConfiguration} that can then be used to open the backup Realm. After that, retry
+ * opening the original Realm file (which now should be recreated as an empty file) and copy all data from the backup file to the new one.
+ * <pre>
+ * {@code
+ *  SyncConfiguration syncConfig = new SyncConfiguration.Builder(user, serverUri).build();
+ *  try {
+ *      Realm realm = Realm.getInstance(syncConfig);
+ *  } catch (IncompatibleSyncedFileException exception) {
+ *      RealmConfiguration backupConfig = exception.getBackupRealmConfiguration();
+ *      Realm backupRealm = Realm.getInstance(backupConfig);
+ *      realm = Realm.GetInstance(syncConfig);
+ *  }
+ * }
+ * </pre>
+ */
+@Keep
+public class IncompatibleSyncedFileException extends RealmFileException {
+    private final String path;
+
+    public IncompatibleSyncedFileException(String message, String recoveryPath) {
+        super(Kind.INCOMPATIBLE_SYNC_FILE, message);
+        this.path = recoveryPath;
+    }
+
+    /**
+     * Gets a {@link RealmConfiguration} instance that can be used to open the backup Realm file.
+     *
+     * Note: This will use the default Realm module (composed of all {@link RealmModel}), and
+     * assume no encryption should be used as well.
+     *
+     * @return A configuration object for the backup Realm.
+     */
+    public RealmConfiguration getBackupRealmConfiguration() {
+        return SyncConfiguration.forRecovery(path, null);
+    }
+
+    /**
+     * Gets a {@link RealmConfiguration} instance that can be used to open the backup Realm file.
+     *
+     * Note: This will use the default Realm module (composed of all {@link RealmModel}).
+     *
+     * @param encryptionKey Optional encryption key that was used to encrypt the original Realm file.
+     * @return A configuration object for the backup Realm.
+     */
+    public RealmConfiguration getBackupRealmConfiguration(@Nullable byte[] encryptionKey) {
+        return SyncConfiguration.forRecovery(path, encryptionKey);
+    }
+
+    /**
+     * Gets a {@link RealmConfiguration} instance that can be used to open the backup Realm file.
+     *
+     * @param encryptionKey Optional encryption key that was used to encrypt the original Realm file.
+     * @param modules restricts Realm schema to the provided module.
+     * @return A configuration object for the backup Realm.
+     */
+    public RealmConfiguration getBackupRealmConfiguration(@Nullable byte[] encryptionKey, Object... modules) {
+        return SyncConfiguration.forRecovery(path, encryptionKey, modules);
+    }
+
+    /**
+     * @return Absolute path to the backup Realm file.
+     */
+    public String getRecoveryPath() {
+        return path;
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
index c976c0bc08..2b8616e8d7 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
@@ -27,6 +27,9 @@
 import io.realm.RealmConfiguration;
 import io.realm.SyncConfiguration;
 import io.realm.SyncManager;
+import io.realm.SyncSession;
+import io.realm.SyncUser;
+import io.realm.exceptions.DownloadingRealmInterruptedException;
 import io.realm.exceptions.RealmException;
 import io.realm.internal.network.NetworkStateReceiver;
 
@@ -81,16 +84,18 @@ public void realmClosed(RealmConfiguration configuration) {
     }
 
     @Override
-    public String[] getUserAndServerUrl(RealmConfiguration config) {
+    public Object[] getUserAndServerUrl(RealmConfiguration config) {
         if (config instanceof SyncConfiguration) {
             SyncConfiguration syncConfig = (SyncConfiguration) config;
+            SyncUser user = syncConfig.getUser();
             String rosServerUrl = syncConfig.getServerUrl().toString();
-            String rosUserIdentity = syncConfig.getUser().getIdentity();
-            String syncRealmAuthUrl = syncConfig.getUser().getAuthenticationUrl().toString();
-            String rosRefreshToken = syncConfig.getUser().getAccessToken().value();
-            return new String[]{rosUserIdentity, rosServerUrl, syncRealmAuthUrl, rosRefreshToken};
+            String rosUserIdentity = user.getIdentity();
+            String syncRealmAuthUrl = user.getAuthenticationUrl().toString();
+            String rosSerializedUser = user.toJson();
+            byte sessionStopPolicy = syncConfig.getSessionStopPolicy().getNativeValue();
+            return new Object[]{rosUserIdentity, rosServerUrl, syncRealmAuthUrl, rosSerializedUser, syncConfig.syncClientValidateSsl(), syncConfig.getServerCertificateFilePath(), sessionStopPolicy, syncConfig.isPartialRealm()};
         } else {
-            return new String[4];
+            return new Object[8];
         }
     }
 
@@ -99,9 +104,30 @@ public static Context getApplicationContext() {
     }
 
     @Override
-    public void wrapObjectStoreSessionIfRequired(RealmConfiguration config) {
-        if (config instanceof SyncConfiguration) {
-            SyncManager.getSession((SyncConfiguration) config);
+    public void wrapObjectStoreSessionIfRequired(OsRealmConfig config) {
+        if (config.getRealmConfiguration() instanceof SyncConfiguration) {
+            SyncSession session = SyncManager.getSession((SyncConfiguration) config.getRealmConfiguration());
+            session.setResolvedRealmURI(config.getResolvedRealmURI());
+        }
+    }
+
+    @Override
+    public String getSyncServerCertificateAssetName(RealmConfiguration configuration) {
+        if (configuration instanceof SyncConfiguration) {
+            SyncConfiguration syncConfig = (SyncConfiguration) configuration;
+            return syncConfig.getServerCertificateAssetName();
+        } else {
+            throw new IllegalArgumentException(WRONG_TYPE_OF_CONFIGURATION);
+        }
+    }
+
+    @Override
+    public String getSyncServerCertificateFilePath(RealmConfiguration configuration) {
+        if (configuration instanceof SyncConfiguration) {
+            SyncConfiguration syncConfig = (SyncConfiguration) configuration;
+            return syncConfig.getServerCertificateFilePath();
+        } else {
+            throw new IllegalArgumentException(WRONG_TYPE_OF_CONFIGURATION);
         }
     }
 
@@ -129,4 +155,24 @@ private void invokeRemoveSession(SyncConfiguration syncConfig) {
             throw new RealmException("Could not remove session: " + syncConfig.toString(), e);
         }
     }
+
+    @Override
+    public void downloadRemoteChanges(RealmConfiguration config) {
+        if (config instanceof SyncConfiguration) {
+            SyncConfiguration syncConfig = (SyncConfiguration) config;
+            if (syncConfig.shouldWaitForInitialRemoteData()) {
+                SyncSession session = SyncManager.getSession(syncConfig);
+                try {
+                    session.downloadAllServerChanges();
+                } catch (InterruptedException e) {
+                    throw new DownloadingRealmInterruptedException(syncConfig, e);
+                }
+            }
+        }
+    }
+
+    @Override
+    public boolean wasDownloadInterrupted(Throwable throwable) {
+        return (throwable instanceof DownloadingRealmInterruptedException);
+    }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java
index a5ad8e9190..4285b565a6 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthServerResponse.java
@@ -24,7 +24,7 @@
 /**
  * Base class for all response types from the Realm Authentication Server.
  */
-public class AuthServerResponse {
+public abstract class AuthServerResponse {
 
     protected ObjectServerError error;
 
@@ -63,7 +63,14 @@ public static ObjectServerError createError(String response, int httpErrorCode)
             JSONObject obj = new JSONObject(response);
             String title = obj.optString("title", null);
             String hint = obj.optString("hint", null);
-            ErrorCode errorCode = ErrorCode.fromInt(obj.optInt("code", -1));
+            ErrorCode errorCode;
+            if (obj.has("code")) {
+                errorCode = ErrorCode.fromInt(obj.getInt("code"));
+            } else if (obj.has("status")) {
+                errorCode = ErrorCode.fromInt(obj.getInt("status"));
+            } else {
+                errorCode = ErrorCode.UNKNOWN;
+            }
             return new ObjectServerError(errorCode, title, hint);
         } catch (JSONException e) {
             return new ObjectServerError(ErrorCode.JSON_EXCEPTION, "Server failed with " +
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateRequest.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateRequest.java
index e921daec6c..bc333b9ab0 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateRequest.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateRequest.java
@@ -56,11 +56,11 @@ public static AuthenticateRequest userLogin(SyncCredentials credentials) {
     /**
      * Generates a request for refreshing a user token.
      */
-    public static AuthenticateRequest userRefresh(Token userToken, URI serverUrl) {
+    public static AuthenticateRequest userRefresh(Token userToken, String serverUrl) {
         return new AuthenticateRequest("realm",
                 userToken.value(),
                 SyncManager.APP_ID,
-                serverUrl.getPath(),
+                serverUrl,
                 Collections.<String, Object>emptyMap()
         );
     }
@@ -68,12 +68,12 @@ public static AuthenticateRequest userRefresh(Token userToken, URI serverUrl) {
     /**
      * Generates a request for accessing a Realm
      */
-    public static AuthenticateRequest realmLogin(Token userToken, URI serverUrl) {
+    public static AuthenticateRequest realmLogin(Token userToken, String serverUrl) {
         // Authenticate a given Realm path using an already logged in user.
         return new AuthenticateRequest("realm",
                 userToken.value(),
                 SyncManager.APP_ID,
-                serverUrl.getPath(),
+                serverUrl,
                 Collections.<String, Object>emptyMap()
         );
     }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateResponse.java
index e0140385cb..cf9c8d85fe 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateResponse.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticateResponse.java
@@ -20,6 +20,7 @@
 import org.json.JSONObject;
 
 import java.io.IOException;
+import java.util.Locale;
 
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
@@ -74,6 +75,13 @@ public static AuthenticateResponse from(ObjectServerError error) {
         return new AuthenticateResponse(error);
     }
 
+    /**
+     * Helper method for creating a failed response from an {@link Exception}.
+     */
+    public static AuthenticateResponse from(Exception exception) {
+        return AuthenticateResponse.from(new ObjectServerError(ErrorCode.fromException(exception), exception));
+    }
+
     /**
      * Helper method for creating a valid user login response. The user returned will be assumed to have all permissions
      * and doesn't expire.
@@ -81,10 +89,10 @@ public static AuthenticateResponse from(ObjectServerError error) {
      * @param identifier user identifier.
      * @param refreshToken user's refresh token.
      */
-    public static AuthenticateResponse createValidResponseWithUser(String identifier, String refreshToken) {
+    public static AuthenticateResponse createValidResponseWithUser(String identifier, String refreshToken, boolean isAdmin) {
         try {
             JSONObject response = new JSONObject();
-            response.put(JSON_FIELD_REFRESH_TOKEN, new Token(refreshToken, identifier, null, Long.MAX_VALUE, Token.Permission.ALL).toJson());
+            response.put(JSON_FIELD_REFRESH_TOKEN, new Token(refreshToken, identifier, null, Long.MAX_VALUE, Token.Permission.ALL, isAdmin).toJson());
             return new AuthenticateResponse(response.toString());
         } catch (JSONException e) {
             throw new RuntimeException(e);
@@ -125,14 +133,14 @@ private AuthenticateResponse(String serverResponse) {
             if (accessToken == null) {
                 message = "accessToken = null";
             } else {
-                message = String.format("Identity %s; Path %s", accessToken.identity(), accessToken.path());
+                message = String.format(Locale.US, "Identity %s; Path %s", accessToken.identity(), accessToken.path());
             }
         } catch (JSONException ex) {
             accessToken = null;
             refreshToken = null;
             //noinspection ThrowableInstanceNeverThrown
             error = new ObjectServerError(ErrorCode.JSON_EXCEPTION, ex);
-            message = String.format("Error %s", error.getErrorMessage());
+            message = String.format(Locale.US, "Error %s", error.getErrorMessage());
         }
         RealmLog.debug("AuthenticateResponse. " + message);
         setError(error);
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
index 3b74558cc6..8906515e83 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/AuthenticationServer.java
@@ -56,4 +56,21 @@
      * logged out as well.
      */
     LogoutResponse logout(Token userToken, URL authenticationUrl);
+
+    /**
+     * Changes a user's password.
+     */
+    ChangePasswordResponse changePassword(Token userToken, String newPassword, URL authenticationUrl);
+
+    /**
+     * Changes a user's password using admin account.
+     */
+    ChangePasswordResponse changePassword(Token adminToken, String userID, String newPassword, URL authenticationUrl);
+
+    /**
+     * Looks up a {@code SyncUser} using the identity provider {@link io.realm.SyncCredentials.IdentityProvider}
+     * used when the account was created and the username or email used to create the account for the first time
+     * what is needed will depend on what type of {@link SyncCredentials} was used.
+     */
+    LookupUserIdResponse retrieveUser(Token adminToken, String provider, String providerId, URL authenticationUrl);
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordRequest.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordRequest.java
new file mode 100644
index 0000000000..b3ee747053
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordRequest.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.network;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import io.realm.internal.objectserver.Token;
+
+/**
+ * This class encapsulates a request to change the password for a user on the Realm Authentication Server. It is
+ * responsible for constructing the JSON understood by the Realm Authentication Server.
+ */
+public class ChangePasswordRequest {
+
+    private final String token;
+    private final String newPassword;
+    private String userID; //optional, used to change the password when using the admin account.
+
+    public static ChangePasswordRequest create(Token userToken, String newPassword) {
+        return new ChangePasswordRequest(userToken.value(), newPassword);
+    }
+
+    public static ChangePasswordRequest create(Token adminToken, String userID, String newPassword) {
+        return new ChangePasswordRequest(adminToken.value(), newPassword, userID);
+    }
+
+    private ChangePasswordRequest(String token, String newPassword) {
+        this.token = token;
+        this.newPassword = newPassword;
+    }
+
+    private ChangePasswordRequest(String token, String newPassword, String userID) {
+        this.token = token;
+        this.newPassword = newPassword;
+        this.userID = userID;
+    }
+
+    /**
+     * Converts the request into a JSON payload.
+     */
+    public String toJson() {
+        try {
+            JSONObject request = new JSONObject();
+            if (userID != null) {
+                request.put("user_id", userID);
+            }
+            JSONObject data = new JSONObject();
+            data.put("new_password", newPassword);
+            request.put("data", data);
+            return request.toString();
+        } catch (JSONException e) {
+            throw new RuntimeException(e);
+        }
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordResponse.java
new file mode 100644
index 0000000000..777869ab6b
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ChangePasswordResponse.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal.network;
+
+import java.io.IOException;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import okhttp3.Response;
+
+/**
+ * Class wrapping the response from `/auth/password`
+ */
+public class ChangePasswordResponse extends AuthServerResponse {
+
+    /**
+     * Helper method for creating the proper change password response. This method will set the appropriate error
+     * depending on any HTTP response codes or I/O errors.
+     *
+     * @param response the server response.
+     * @return the change password response.
+     */
+    static ChangePasswordResponse from(Response response) {
+        if (response.isSuccessful()) {
+            return new ChangePasswordResponse();
+        }
+        try {
+            String serverResponse = response.body().string();
+            return new ChangePasswordResponse(AuthServerResponse.createError(serverResponse, response.code()));
+        } catch (IOException e) {
+            ObjectServerError error = new ObjectServerError(ErrorCode.IO_EXCEPTION, e);
+            return new ChangePasswordResponse(error);
+        }
+    }
+
+    /**
+     * Helper method for creating a failed response.
+     */
+    public static ChangePasswordResponse from(ObjectServerError objectServerError) {
+        return new ChangePasswordResponse(objectServerError);
+    }
+
+    /**
+     * Helper method for creating a failed response from an {@link Exception}.
+     */
+    public static ChangePasswordResponse from(Exception exception) {
+        return ChangePasswordResponse.from(new ObjectServerError(ErrorCode.fromException(exception), exception));
+    }
+
+    private ChangePasswordResponse() {
+        this.error = null;
+    }
+
+    private ChangePasswordResponse(ObjectServerError error) {
+        this.error = error;
+    }
+
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java
index 1e428dd190..a5686ae139 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java
@@ -24,6 +24,15 @@
  * Abstracts the concept of running an network task with incremental backoff. It will run forever until interrupted.
  */
 public abstract class ExponentialBackoffTask<T extends AuthServerResponse> implements Runnable {
+    private final int maxRetries;
+
+    public ExponentialBackoffTask(int maxRetries) {
+        this.maxRetries = maxRetries;
+    }
+
+    public ExponentialBackoffTask() {
+        this(Integer.MAX_VALUE - 1);
+    }
 
     // Task to perform
     protected abstract T execute();
@@ -69,7 +78,7 @@ public void run() {
                 onSuccess(response);
                 break;
             } else {
-                if (shouldAbortTask(response)) {
+                if (shouldAbortTask(response) || attempt == maxRetries + 1) {
                     onError(response);
                     break;
                 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutRequest.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutRequest.java
index 8cb67b56a9..49a30ade75 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutRequest.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutRequest.java
@@ -29,7 +29,7 @@
 
     private final String token;
 
-    public static LogoutRequest revoke(Token userToken) {
+    public static LogoutRequest create(Token userToken) {
         return new LogoutRequest(userToken.value());
     }
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutResponse.java
index 6a0181ca95..f13fbf6b2e 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutResponse.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LogoutResponse.java
@@ -56,6 +56,13 @@ public static LogoutResponse from(ObjectServerError error) {
         return new LogoutResponse(error);
     }
 
+    /**
+     * Helper method for creating a failed response from an {@link Exception}.
+     */
+    public static LogoutResponse from(Exception exception) {
+        return LogoutResponse.from(new ObjectServerError(ErrorCode.fromException(exception), exception));
+    }
+
     /**
      * Creates an unsuccessful authentication response. This should only happen in case of network or I/O
      * related issues.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/LookupUserIdResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LookupUserIdResponse.java
new file mode 100644
index 0000000000..810b4ee87f
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/LookupUserIdResponse.java
@@ -0,0 +1,154 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal.network;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.log.RealmLog;
+import okhttp3.Response;
+
+/**
+ * Class wrapping the response from `GET /auth/users/:userId`
+ */
+public class LookupUserIdResponse extends AuthServerResponse {
+
+    private static final String JSON_FIELD_USER_ID = "user_id";
+    private static final String JSON_FIELD_USER_IS_ADMIN = "is_admin";
+    private static final String JSON_FIELD_METADATA = "metadata";
+    private static final String JSON_FIELD_ACCOUNTS = "accounts";
+
+    private final String userId;
+    private final Boolean isAdmin;
+    private final Map<String, String> metadata;
+    private final Map<String, String> accounts;
+    /**
+     * Helper method for creating the proper lookup user response. This method will set the appropriate error
+     * depending on any HTTP response codes or I/O errors.
+     *
+     * @param response the server response.
+     * @return the user lookup response.
+     */
+    static LookupUserIdResponse from(Response response) {
+        String serverResponse;
+        try {
+            serverResponse = response.body().string();
+        } catch (IOException e) {
+            ObjectServerError error = new ObjectServerError(ErrorCode.IO_EXCEPTION, e);
+            return new LookupUserIdResponse(error);
+        }
+        if (!response.isSuccessful()) {
+            return new LookupUserIdResponse(AuthServerResponse.createError(serverResponse, response.code()));
+        } else {
+            return new LookupUserIdResponse(serverResponse);
+        }
+    }
+
+    /**
+     * Helper method for creating a failed response.
+     */
+    public static LookupUserIdResponse from(ObjectServerError objectServerError) {
+        return new LookupUserIdResponse(objectServerError);
+    }
+
+    /**
+     * Helper method for creating a failed response from an {@link Exception}.
+     */
+    public static LookupUserIdResponse from(Exception exception) {
+        return LookupUserIdResponse.from(new ObjectServerError(ErrorCode.fromException(exception), exception));
+    }
+
+    private LookupUserIdResponse(ObjectServerError error) {
+        RealmLog.debug("LookupUserIdResponse - Error: " + error);
+        setError(error);
+        this.error = error;
+        this.userId = null;
+        this.isAdmin = null;
+        this.metadata = new HashMap<>();
+        this.accounts = new HashMap<>();
+    }
+
+    private LookupUserIdResponse(String serverResponse) {
+        ObjectServerError error;
+        String userId;
+        Boolean isAdmin;
+        String message;
+        Map<String, String> metadata;
+        Map<String, String> accounts;
+        try {
+            JSONObject obj = new JSONObject(serverResponse);
+            userId = obj.getString(JSON_FIELD_USER_ID);
+            isAdmin = obj.getBoolean(JSON_FIELD_USER_IS_ADMIN);
+            metadata = jsonToMap(obj.getJSONArray(JSON_FIELD_METADATA), "key", "value");
+            accounts = jsonToMap(obj.getJSONArray(JSON_FIELD_ACCOUNTS), "provider", "provider_id");
+            error = null;
+
+            message = String.format(Locale.US, "Identity %s; Path %b", userId, isAdmin);
+
+        } catch (JSONException e) {
+            userId = null;
+            isAdmin = null;
+            metadata = new HashMap<>();
+            accounts = new HashMap<>();
+            error = new ObjectServerError(ErrorCode.JSON_EXCEPTION, e);
+            message = String.format(Locale.US, "Error %s", error.getErrorMessage());
+        }
+
+        RealmLog.debug("LookupUserIdResponse. " + message);
+        setError(error);
+        this.userId = userId;
+        this.isAdmin = isAdmin;
+        this.metadata = metadata;
+        this.accounts = accounts;
+    }
+
+    public String getUserId() {
+        return userId;
+    }
+
+    public boolean isAdmin() {
+        return isAdmin;
+    }
+
+    public Map<String, String> getMetadata() { return metadata; }
+
+    public Map<String, String> getAccounts() { return accounts; }
+
+    // Assume arrays of key/value irrespectively of what they are named.
+    // Throws if this is not the case
+    private static Map<String, String> jsonToMap(JSONArray array, String keyName, String valueName) throws JSONException {
+        Map<String, String> map = new HashMap<>();
+        if (array == null) {
+            return map;
+        }
+        for (int i = 0; i < array.length(); i++) {
+            JSONObject obj = array.getJSONObject(i);
+            if (obj.length() != 2) {
+                throw new IllegalStateException("Array object not a key/value object. Has " + obj.length() + " fields");
+            }
+            map.put(obj.getString(keyName), obj.getString(valueName));
+        }
+        return map;
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
index 40148acb8a..4783b3d42e 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
@@ -21,12 +21,12 @@
 import java.net.URL;
 import java.util.concurrent.TimeUnit;
 
-import io.realm.ErrorCode;
-import io.realm.ObjectServerError;
 import io.realm.SyncCredentials;
+import io.realm.internal.Util;
 import io.realm.internal.objectserver.Token;
 import io.realm.log.RealmLog;
 import okhttp3.Call;
+import okhttp3.ConnectionPool;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
@@ -36,11 +36,18 @@
 public class OkHttpAuthenticationServer implements AuthenticationServer {
 
     public static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
+    private static final String ACTION_LOGOUT = "revoke"; // Auth end point for logging out users
+    private static final String ACTION_CHANGE_PASSWORD = "password"; // Auth end point for changing passwords
+    private static final String ACTION_LOOKUP_USER_ID = "users/:provider:/:providerId:"; // Auth end point for looking up user id
 
     private final OkHttpClient client = new OkHttpClient.Builder()
-            .connectTimeout(10, TimeUnit.SECONDS)
-            .writeTimeout(10, TimeUnit.SECONDS)
+            .connectTimeout(15, TimeUnit.SECONDS)
+            .writeTimeout(15, TimeUnit.SECONDS)
             .readTimeout(30, TimeUnit.SECONDS)
+            // using custom Connection Pool to evict idle connection after 5 seconds rather than 5 minutes (which is the default)
+            // keeping idle connection on the pool will prevent the ROS to be stopped, since the HttpUtils#stopSyncServer query
+            // will not return before the tests timeout (ex 10 seconds for AuthTests)
+            .connectionPool(new ConnectionPool(5, 5, TimeUnit.SECONDS))
             .build();
 
     /**
@@ -52,58 +59,86 @@ public AuthenticateResponse loginUser(SyncCredentials credentials, URL authentic
             String requestBody = AuthenticateRequest.userLogin(credentials).toJson();
             return authenticate(authenticationUrl, requestBody);
         } catch (Exception e) {
-            return AuthenticateResponse.from(new ObjectServerError(ErrorCode.UNKNOWN, e));
+            return AuthenticateResponse.from(e);
         }
     }
 
     @Override
     public AuthenticateResponse loginToRealm(Token refreshToken, URI serverUrl, URL authenticationUrl) {
         try {
-            String requestBody = AuthenticateRequest.realmLogin(refreshToken, serverUrl).toJson();
+            String requestBody = AuthenticateRequest.realmLogin(refreshToken, serverUrl.getPath()).toJson();
             return authenticate(authenticationUrl, requestBody);
         } catch (Exception e) {
-            return AuthenticateResponse.from(new ObjectServerError(ErrorCode.UNKNOWN, e));
+            return AuthenticateResponse.from(e);
         }
     }
 
     @Override
     public AuthenticateResponse refreshUser(Token userToken, URI serverUrl, URL authenticationUrl) {
         try {
-            String requestBody = AuthenticateRequest.userRefresh(userToken, serverUrl).toJson();
+            String requestBody = AuthenticateRequest.userRefresh(userToken, serverUrl.getPath()).toJson();
             return authenticate(authenticationUrl, requestBody);
         } catch (Exception e) {
-            return AuthenticateResponse.from(new ObjectServerError(ErrorCode.UNKNOWN, e));
+            return AuthenticateResponse.from(e);
         }
     }
 
     @Override
     public LogoutResponse logout(Token userToken, URL authenticationUrl) {
         try {
-            String requestBody = LogoutRequest.revoke(userToken).toJson();
-            return logout(buildLogoutUrl(authenticationUrl), requestBody);
+            String requestBody = LogoutRequest.create(userToken).toJson();
+            return logout(buildActionUrl(authenticationUrl, ACTION_LOGOUT), userToken.value(), requestBody);
         } catch (Exception e) {
-            return LogoutResponse.from(new ObjectServerError(ErrorCode.UNKNOWN, e));
+            return LogoutResponse.from(e);
         }
     }
 
-    private static URL buildLogoutUrl(URL authenticationUrl) {
+    @Override
+    public ChangePasswordResponse changePassword(Token userToken, String newPassword, URL authenticationUrl) {
+        try {
+            String requestBody = ChangePasswordRequest.create(userToken, newPassword).toJson();
+            return changePassword(buildActionUrl(authenticationUrl, ACTION_CHANGE_PASSWORD), userToken.value(), requestBody);
+        } catch (Exception e) {
+            return ChangePasswordResponse.from(e);
+        }
+    }
+
+    @Override
+    public ChangePasswordResponse changePassword(Token adminToken, String userId, String newPassword, URL authenticationUrl) {
+        try {
+            String requestBody = ChangePasswordRequest.create(adminToken, userId, newPassword).toJson();
+            return changePassword(buildActionUrl(authenticationUrl, ACTION_CHANGE_PASSWORD), adminToken.value(), requestBody);
+        } catch (Exception e) {
+            return ChangePasswordResponse.from(e);
+        }
+    }
+
+    @Override
+    public LookupUserIdResponse retrieveUser(Token adminToken, String provider, String providerId, URL authenticationUrl) {
+        try {
+            String action = ACTION_LOOKUP_USER_ID
+                .replace(":provider:", provider)
+                .replace(":providerId:", providerId);
+            return lookupUserId(buildActionUrl(authenticationUrl, action), adminToken.value());
+        } catch (Exception e) {
+            return LookupUserIdResponse.from(e);
+        }
+    }
+
+    // Builds the URL for a specific auth endpoint
+    private static URL buildActionUrl(URL authenticationUrl, String action) {
         final String baseUrlString = authenticationUrl.toExternalForm();
         try {
-            if (baseUrlString.endsWith("/")) {
-                return new URL(baseUrlString + "revoke");
-            } else {
-                return new URL(baseUrlString + "/revoke");
-            }
+            String separator = baseUrlString.endsWith("/") ? "" : "/";
+            return new URL(baseUrlString + separator + action);
         } catch (MalformedURLException e) {
             throw new RuntimeException(e);
         }
     }
 
     private AuthenticateResponse authenticate(URL authenticationUrl, String requestBody) throws Exception {
-        Request request = new Request.Builder()
-                .url(authenticationUrl)
-                .addHeader("Content-Type", "application/json")
-                .addHeader("Accept", "application/json")
+        RealmLog.debug("Network request (authenticate): " + authenticationUrl);
+        Request request = newAuthRequest(authenticationUrl)
                 .post(RequestBody.create(JSON, requestBody))
                 .build();
         Call call = client.newCall(request);
@@ -111,15 +146,52 @@ private AuthenticateResponse authenticate(URL authenticationUrl, String requestB
         return AuthenticateResponse.from(response);
     }
 
-    private LogoutResponse logout(URL logoutUrl, String requestBody) throws Exception {
-        Request request = new Request.Builder()
-                .url(logoutUrl)
-                .addHeader("Content-Type", "application/json")
-                .addHeader("Accept", "application/json")
+    private LogoutResponse logout(URL logoutUrl, String authToken, String requestBody) throws Exception {
+        RealmLog.debug("Network request (logout): " + logoutUrl);
+        Request request = newAuthRequest(logoutUrl, authToken)
                 .post(RequestBody.create(JSON, requestBody))
                 .build();
         Call call = client.newCall(request);
         Response response = call.execute();
         return LogoutResponse.from(response);
     }
+
+    private ChangePasswordResponse changePassword(URL changePasswordUrl, String authToken, String requestBody) throws Exception {
+        RealmLog.debug("Network request (changePassword): " + changePasswordUrl);
+        Request request = newAuthRequest(changePasswordUrl, authToken)
+                .put(RequestBody.create(JSON, requestBody))
+                .build();
+        Call call = client.newCall(request);
+        Response response = call.execute();
+        return ChangePasswordResponse.from(response);
+    }
+
+    private LookupUserIdResponse lookupUserId(URL lookupUserIdUrl, String authToken) throws Exception {
+        RealmLog.debug("Network request (lookupUserId): " + lookupUserIdUrl);
+        Request request = newAuthRequest(lookupUserIdUrl, authToken)
+                .get()
+                .build();
+        Call call = client.newCall(request);
+        Response response = call.execute();
+        return LookupUserIdResponse.from(response);
+    }
+
+    private Request.Builder newAuthRequest(URL url) {
+        return newAuthRequest(url, null);
+    }
+
+    private Request.Builder newAuthRequest(URL url, String authToken) {
+        Request.Builder builder = new Request.Builder()
+                .url(url)
+                .addHeader("Content-Type", "application/json")
+                .addHeader("Accept", "application/json");
+
+        // Only add Authorization header for those API's that require it.
+        if (!Util.isEmptyString(authToken)) {
+            builder.addHeader("Authorization", authToken);
+        }
+
+        return builder;
+    }
+
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java
deleted file mode 100644
index 740125a54b..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java
+++ /dev/null
@@ -1,251 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.objectserver;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.net.URI;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import io.realm.SyncConfiguration;
-import io.realm.SyncSession;
-
-/**
- * Internal representation of a user on the Realm Object Server.
- * The public API is defined by {@link io.realm.SyncUser}.
- */
-public class ObjectServerUser {
-
-    private final String identity;
-    private Token refreshToken;
-    private URL authenticationUrl;
-    private Map<URI, AccessDescription> realms = new HashMap<URI, AccessDescription>();
-    private List<SyncSession> sessions = new ArrayList<SyncSession>();
-    private boolean loggedIn;
-
-    /**
-     * Create a new Realm Object Server User
-     */
-    public ObjectServerUser(Token refreshToken, URL authenticationUrl) {
-        this.identity = refreshToken.identity();
-        this.authenticationUrl = authenticationUrl;
-        this.refreshToken = refreshToken;
-        this.loggedIn = true;
-    }
-
-    private void setRefreshToken(final Token refreshToken) {
-        // TODO Shouldn't we check if the identity of the new refreshToken is the same with previous identity?
-        this.refreshToken = refreshToken; // Replace any existing token. TODO re-save the user with latest token.
-    }
-
-    /**
-     * Checks if the user has access to the given Realm. Being authenticated means that the
-     * user is know by the Realm Object Server and have been granted access to the given Realm.
-     *
-     * Authenticating will happen automatically as part of opening a Realm.
-     */
-    public boolean isAuthenticated(SyncConfiguration configuration) {
-        Token token = getAccessToken(configuration.getServerUrl());
-        return token != null && token.expiresMs() > System.currentTimeMillis();
-    }
-
-    public String toJson() {
-        JSONObject obj = new JSONObject();
-        try {
-            obj.put("authUrl", authenticationUrl);
-            obj.put("userToken", refreshToken.toJson());
-            JSONArray realmList = new JSONArray();
-            for (Map.Entry<URI, AccessDescription> entry : realms.entrySet()) {
-                JSONObject token = new JSONObject();
-                token.put("uri", entry.getKey().toString());
-                token.put("description", entry.getValue().toJson());
-                realmList.put(token);
-            }
-            obj.put("realms", realmList);
-            return obj.toString();
-        } catch (JSONException e) {
-            throw new RuntimeException("Could not convert User to JSON", e);
-        }
-    }
-
-    public String getIdentity() {
-        return identity;
-    }
-
-    public Token getAccessToken(URI serverUrl) {
-        AccessDescription accessDescription = realms.get(serverUrl);
-        return (accessDescription != null) ? accessDescription.accessToken : null;
-    }
-
-    void removeAccessToken(URI serverUrl) {
-        realms.remove(serverUrl);
-    }
-
-    public void addRealm(URI uri, AccessDescription description) {
-        realms.put(uri, description);
-    }
-
-    // When a session is started, add it to the user so it can be tracked
-    public void addSession(SyncSession session) {
-        sessions.add(session);
-    }
-
-    /**
-     * Adds an access token to this user.
-     * <p>
-     * An access token is a token granting access to one remote Realm. Access Tokens are normally fetched transparently
-     * when opening a Realm, but using this method it is possible to add tokens upfront if they have been fetched or
-     * created manually.
-     *
-     * @param uri {@link java.net.URI} pointing to a remote Realm.
-     * @param accessToken
-     */
-    public void addRealm(URI uri, String accessToken, String localPath, boolean deleteOnLogout) {
-        if (uri == null || accessToken == null) {
-            throw new IllegalArgumentException("Non-null 'uri' and 'accessToken' required.");
-        }
-        uri = SyncUtil.getFullServerUrl(uri, identity);
-
-        // Optimistically create a long-lived token with all permissions. If this is incorrect the Object Server
-        // will reject it anyway. If tokens are added manually it is up to the user to ensure they are also used
-        // correctly.
-        Token token = new Token(accessToken, null, uri.toString(), Long.MAX_VALUE, Token.Permission.values());
-        addRealm(uri, new AccessDescription(token, localPath, deleteOnLogout));
-    }
-
-    public URL getAuthenticationUrl() {
-        return authenticationUrl;
-    }
-
-    public Token getUserToken() {
-        return refreshToken;
-    }
-
-    public List<SyncSession> getSessions() {
-        return sessions;
-    }
-
-    // TODO merge this method into localLogout(). See https://github.com/realm/realm-java/pull/3642#discussion_r96818800
-    public void clearTokens() {
-        realms.clear();
-        refreshToken = null;
-    }
-
-    public boolean isLoggedIn() {
-        return loggedIn;
-    }
-
-    // Local Logout means that the user is no longer able to create new sync configurations,
-    // nor synchronize changes
-    public void localLogout() {
-        loggedIn = false;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-
-        ObjectServerUser syncUser = (ObjectServerUser) o;
-
-        if (!identity.equals(syncUser.identity)) return false;
-        if (refreshToken == null) {
-            if (syncUser.refreshToken != null) return false;
-        } else {
-            if (!refreshToken.equals(syncUser.refreshToken)) return false;
-        }
-        if (!authenticationUrl.toString().equals(syncUser.authenticationUrl.toString())) return false;
-        return realms.equals(syncUser.realms);
-    }
-
-    @Override
-    public int hashCode() {
-        int result = identity.hashCode();
-        result = 31 * result + (refreshToken == null ? 0 : refreshToken.hashCode());
-        result = 31 * result + authenticationUrl.toString().hashCode();
-        result = 31 * result + realms.hashCode();
-        return result;
-    }
-
-    public Collection<AccessDescription> getRealms() {
-        return realms.values();
-    }
-
-    // Wrapper for all Realm data needed by a User that might get serialized.
-    public static class AccessDescription {
-        public Token accessToken;
-        public String localPath;
-        public boolean deleteOnLogout;
-
-        public AccessDescription(Token accessToken, String localPath, boolean deleteOnLogout) {
-            this.accessToken = accessToken;
-            this.localPath = localPath;
-            this.deleteOnLogout = deleteOnLogout;
-        }
-
-        public static AccessDescription fromJson(JSONObject json) {
-            try {
-                Token token = Token.from(json.getJSONObject("accessToken"));
-                String localPath = json.getString("localPath");
-                boolean deleteOnLogout = json.getBoolean("deleteOnLogout");
-                return new AccessDescription(token, localPath, deleteOnLogout);
-            } catch (JSONException e) {
-                throw new RuntimeException(e);
-            }
-        }
-
-        public JSONObject toJson() {
-            try {
-                JSONObject obj = new JSONObject();
-                obj.put("accessToken", accessToken.toJson());
-                obj.put("localPath", localPath);
-                obj.put("deleteOnLogout", deleteOnLogout);
-                return obj;
-            } catch (JSONException e) {
-                throw new RuntimeException(e);
-            }
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) return true;
-            if (o == null || getClass() != o.getClass()) return false;
-
-            AccessDescription that = (AccessDescription) o;
-
-            if (deleteOnLogout != that.deleteOnLogout) return false;
-            if (!accessToken.equals(that.accessToken)) return false;
-            return localPath.equals(that.localPath);
-
-        }
-
-        @Override
-        public int hashCode() {
-            int result = accessToken.hashCode();
-            result = 31 * result + localPath.hashCode();
-            result = 31 * result + (deleteOnLogout ? 1 : 0);
-            return result;
-        }
-    }
-}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SyncUtil.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SyncUtil.java
deleted file mode 100644
index 9d6b8f1e23..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SyncUtil.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.objectserver;
-
-import java.net.URI;
-import java.net.URISyntaxException;
-
-/**
- * Helper class for Object Server classes.
- */
-public class SyncUtil {
-
-    /**
-     * Fully resolve an URL so all placeholder objects are replaced with the user identity.
-     */
-    public static URI getFullServerUrl(URI serverUrl, String userIdentity) {
-        try {
-            return new URI(serverUrl.toString().replace("/~/", "/" + userIdentity + "/"));
-        } catch (URISyntaxException e) {
-            throw new IllegalArgumentException("Could not replace '/~/' with a valid user ID.", e);
-        }
-    }
-}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/Token.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/Token.java
index 1d45632b40..3d642ef43c 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/Token.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/Token.java
@@ -30,20 +30,29 @@
  */
 public class Token {
 
+    private static final String KEY_TOKEN = "token";
+    private static final String KEY_TOKEN_DATA = "token_data";
+    private static final String KEY_IDENTITY = "identity";
+    private static final String KEY_PATH = "path";
+    private static final String KEY_EXPIRES = "expires";
+    private static final String KEY_ACCESS = "access";
+    private static final String KEY_IS_ADMIN = "is_admin";
+
     private final String value;
     private final long expiresSec;
     private final Permission[] permissions;
     private final String identity;
     private final String path;
+    private final boolean isAdmin;
 
     public static Token from(JSONObject token) throws JSONException {
-        String value = token.getString("token");
-        JSONObject tokenData = token.getJSONObject("token_data");
-        String identity = tokenData.getString("identity");
-        String path = tokenData.optString("path");
-        long expiresSec = tokenData.getLong("expires");
+        String value = token.getString(KEY_TOKEN);
+        JSONObject tokenData = token.getJSONObject(KEY_TOKEN_DATA);
+        String identity = tokenData.getString(KEY_IDENTITY);
+        String path = tokenData.optString(KEY_PATH);
+        long expiresSec = tokenData.getLong(KEY_EXPIRES);
         Permission[] permissions;
-        JSONArray access = tokenData.getJSONArray("access");
+        JSONArray access = tokenData.getJSONArray(KEY_ACCESS);
         if (access != null) {
             permissions = new Permission[access.length()];
             for (int i = 0; i < access.length(); i++) {
@@ -56,11 +65,16 @@ public static Token from(JSONObject token) throws JSONException {
         } else {
             permissions = new Permission[0];
         }
+        boolean isAdmin = tokenData.optBoolean(KEY_IS_ADMIN);
 
-        return new Token(value, identity, path, expiresSec, permissions);
+        return new Token(value, identity, path, expiresSec, permissions, isAdmin);
     }
 
     public Token(String value, String identity, String path, long expiresSec, Permission[] permissions) {
+        this(value, identity, path, expiresSec, permissions, false);
+    }
+
+    public Token(String value, String identity, String path, long expiresSec, Permission[] permissions, boolean isAdmin) {
         this.value = value;
         this.identity = identity;
         this.path = path;
@@ -70,6 +84,7 @@ public Token(String value, String identity, String path, long expiresSec, Permis
         } else {
             this.permissions = new Permission[0];
         }
+        this.isAdmin = isAdmin;
     }
 
     public String value() {
@@ -80,6 +95,8 @@ public String value() {
 
     public String path() { return path; }
 
+    public boolean isAdmin() { return isAdmin; }
+
     /**
      * Returns when this token expires. Timestamp is in UTC seconds.
      */
@@ -107,17 +124,18 @@ public long expiresMs() {
     public JSONObject toJson() {
         JSONObject obj = new JSONObject();
         try {
-            obj.put("token", value);
+            obj.put(KEY_TOKEN, value);
             JSONObject tokenData = new JSONObject();
-            tokenData.put("identity", identity);
-            tokenData.put("path", path);
-            tokenData.put("expires", expiresSec);
+            tokenData.put(KEY_IDENTITY, identity);
+            tokenData.put(KEY_PATH, path);
+            tokenData.put(KEY_EXPIRES, expiresSec);
             JSONArray perms = new JSONArray();
             for (int i = 0; i < permissions.length; i++) {
                 perms.put(permissions[i].toString().toLowerCase(Locale.US));
             }
-            tokenData.put("access", perms);
-            obj.put("token_data", tokenData);
+            tokenData.put(KEY_ACCESS, perms);
+            tokenData.put(KEY_IS_ADMIN, isAdmin);
+            obj.put(KEY_TOKEN_DATA, tokenData);
             return obj;
         } catch (JSONException e) {
             throw new RuntimeException("Could not convert Token to JSON.", e);
@@ -126,15 +144,16 @@ public JSONObject toJson() {
 
     @Override
     public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
+        if (this == o) { return true; }
+        if (o == null || getClass() != o.getClass()) { return false; }
 
         Token token = (Token) o;
 
-        if (expiresSec != token.expiresSec) return false;
-        if (!value.equals(token.value)) return false;
-        if (!Arrays.equals(permissions, token.permissions)) return false;
-        if (!identity.equals(token.identity)) return false;
+        if (expiresSec != token.expiresSec) { return false; }
+        if (isAdmin != token.isAdmin) { return false; }
+        if (!value.equals(token.value)) { return false; }
+        if (!Arrays.equals(permissions, token.permissions)) { return false; }
+        if (!identity.equals(token.identity)) { return false; }
         return path != null ? path.equals(token.path) : token.path == null;
     }
 
@@ -145,6 +164,7 @@ public int hashCode() {
         result = 31 * result + Arrays.hashCode(permissions);
         result = 31 * result + identity.hashCode();
         result = 31 * result + (path != null ? path.hashCode() : 0);
+        result = 31 * result + (isAdmin ? 1 : 0);
         return result;
     }
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/BasePermissionApi.java b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/BasePermissionApi.java
new file mode 100644
index 0000000000..ea7e6fc103
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/BasePermissionApi.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.permissions;
+
+import java.util.Date;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import io.realm.RealmModel;
+
+
+/**
+ * Common methods shared between most Realm model classes used in the Permission Realm API.
+ */
+public interface BasePermissionApi extends RealmModel {
+
+    /**
+     * Returns the unique id for this object.
+     *
+     * @return the unique id for this object.
+     */
+    String getId();
+
+    /**
+     * Returns the timestamp on the Client that created this object.
+     *
+     * @return {@link Date} this object was created. The timestamp will use the device clock it was created on.
+     */
+    @SuppressFBWarnings("EI_EXPOSE_REP")
+    Date getCreatedAt();
+
+    /**
+     * Returns the timestamp this object was last updated. The timstamp can be both a server timestamp and a device
+     * timestamp.
+     *
+     * @return {@link Date} this object was last modified.
+     */
+    @SuppressFBWarnings("EI_EXPOSE_REP")
+    Date getUpdatedAt();
+
+    /**
+     * Returns the status code for this change.
+     *
+     * @return {@code null} if not yet processed. {@code 0} if successful, {@code >0} if an error happened. See {@link #getStatusMessage()}.
+     */
+    Integer getStatusCode();
+
+    /**
+     * Returns the servers status message, if an error occurred. Otherwise it will return {@code null}.
+     *
+     * @return The servers status message in case of an error, {@code null} otherwise.
+     */
+    String getStatusMessage();
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionModule.java b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/ManagementModule.java
similarity index 83%
rename from realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionModule.java
rename to realm/realm-library/src/objectServer/java/io/realm/internal/permissions/ManagementModule.java
index 319cd2a83a..358330d92b 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionModule.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/ManagementModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2016 Realm Inc.
+ * Copyright 2017 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,10 +14,11 @@
  * limitations under the License.
  */
 
-package io.realm.permissions;
+package io.realm.internal.permissions;
 
 import io.realm.annotations.RealmModule;
+import io.realm.permissions.PermissionOffer;
 
 @RealmModule(library = true, classes = { PermissionChange.class, PermissionOffer.class, PermissionOfferResponse.class })
-public class PermissionModule {
+public class ManagementModule {
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionChange.java b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionChange.java
similarity index 60%
rename from realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionChange.java
rename to realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionChange.java
index 19f88c840f..df839523d4 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionChange.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionChange.java
@@ -13,22 +13,30 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.realm.permissions;
+package io.realm.internal.permissions;
 
 import java.util.Date;
 import java.util.UUID;
 
+import javax.annotation.Nullable;
+
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
 import io.realm.RealmObject;
 import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmClass;
 import io.realm.annotations.Required;
+import io.realm.permissions.AccessLevel;
+import io.realm.permissions.UserCondition;
+import io.realm.permissions.PermissionRequest;
+
 
 /**
  * This class is used for requesting changes to a Realm's permissions.
  *
  * @see <a href="https://realm.io/docs/realm-object-server/#permissions">Controlling Permissions</a>
  */
-public class PermissionChange extends RealmObject {
+@RealmClass
+public class PermissionChange implements BasePermissionApi {
 
     // Base fields
     @PrimaryKey
@@ -45,10 +53,42 @@
     private String realmUrl;
     @Required
     private String userId;
+
+    private String metadataKey;
+    private String metadataValue;
+    private String metadataNameSpace;
     private Boolean mayRead = false;
     private Boolean mayWrite = false;
     private Boolean mayManage = false;
 
+    /**
+     * Maps between a PermissionRequest and a PermissionChange object.
+     *
+     * @param request request to map to a PermissionChange.
+     */
+    public static PermissionChange fromRequest(PermissionRequest request) {
+        // PRE-CONDITION: All input are verified to be valid from the perspective of the Client.
+        UserCondition condition = request.getCondition();
+        AccessLevel level = request.getAccessLevel();
+        String realmUrl = request.getUrl();
+
+        String userId = "";
+        String metadataKey = null;
+        String metadataValue = null;
+        switch (condition.getType()) {
+            case USER_ID:
+                userId = condition.getValue();
+                break;
+            case METADATA:
+                metadataKey = condition.getKey();
+                metadataValue = condition.getValue();
+                break;
+        }
+
+        return new PermissionChange(realmUrl, userId, metadataKey, metadataValue, level.mayRead(), level.mayWrite(),
+                level.mayManage());
+    }
+
     public PermissionChange() {
         // Default constructor required by Realm
     }
@@ -67,7 +107,8 @@ public PermissionChange() {
      *
      * @see <a href="https://realm.io/docs/realm-object-server/#permissions">Controlling Permissions</a>
      */
-    public PermissionChange(String realmUrl, String userId, Boolean mayRead, Boolean mayWrite, Boolean mayManage) {
+    public PermissionChange(String realmUrl, String userId,
+            @Nullable Boolean mayRead, @Nullable Boolean mayWrite, @Nullable Boolean mayManage) {
         this.realmUrl = realmUrl;
         this.userId = userId;
         this.mayRead = mayRead;
@@ -75,15 +116,29 @@ public PermissionChange(String realmUrl, String userId, Boolean mayRead, Boolean
         this.mayManage = mayManage;
     }
 
+    public PermissionChange(String realmUrl, String userId, String metadataKey, String metadataValue, Boolean mayRead,
+            Boolean mayWrite, Boolean mayManage) {
+        this.realmUrl = realmUrl;
+        this.userId = userId;
+        this.metadataKey = metadataKey;
+        this.metadataValue = metadataValue;
+        this.mayRead = mayRead;
+        this.mayWrite = mayWrite;
+        this.mayManage = mayManage;
+    }
+
+    @Override
     public String getId() {
         return id;
     }
 
+    @Override
     @SuppressFBWarnings("EI_EXPOSE_REP")
     public Date getCreatedAt() {
         return createdAt;
     }
 
+    @Override
     @SuppressFBWarnings("EI_EXPOSE_REP")
     public Date getUpdatedAt() {
         return updatedAt;
@@ -94,10 +149,14 @@ public Date getUpdatedAt() {
      *
      * @return {@code null} if not yet processed. {@code 0} if successful, {@code >0} if an error happened. See {@link #getStatusMessage()}.
      */
+    @Override
+    @Nullable
     public Integer getStatusCode() {
         return statusCode;
     }
 
+    @Override
+    @Nullable
     public String getStatusMessage() {
         return statusMessage;
     }
@@ -110,15 +169,26 @@ public String getUserId() {
         return userId;
     }
 
+    @Nullable
     public Boolean mayRead() {
         return mayRead;
     }
 
+    @Nullable
     public Boolean mayWrite() {
         return mayWrite;
     }
 
+    @Nullable
     public Boolean mayManage() {
         return mayManage;
     }
+
+    public String getMetadataKey() {
+        return metadataKey;
+    }
+
+    public String getMetadataValue() {
+        return metadataValue;
+    }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionModule.java b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionModule.java
new file mode 100644
index 0000000000..9ba21bba00
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionModule.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal.permissions;
+
+import io.realm.annotations.RealmModule;
+import io.realm.permissions.Permission;
+
+@RealmModule(library = true, classes = { Permission.class })
+public class PermissionModule {
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOfferResponse.java b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionOfferResponse.java
similarity index 84%
rename from realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOfferResponse.java
rename to realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionOfferResponse.java
index e1562a363e..812c67d7e8 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOfferResponse.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/permissions/PermissionOfferResponse.java
@@ -13,15 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.realm.permissions;
+package io.realm.internal.permissions;
 
+import java.net.URI;
+import java.net.URISyntaxException;
 import java.util.Date;
 import java.util.UUID;
 
+import javax.annotation.Nullable;
+
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-import io.realm.RealmObject;
 import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmClass;
 import io.realm.annotations.Required;
+import io.realm.permissions.PermissionOffer;
+
 
 /**
  * This model is used to apply permission changes defined in the permission offer
@@ -33,7 +39,8 @@
  * @see <a href="https://realm.io/docs/realm-object-server/#permissions">Permissions description</a> for general
  * documentation.
  */
-public class PermissionOfferResponse extends RealmObject {
+@RealmClass
+public class PermissionOfferResponse implements BasePermissionApi {
 
     // Base fields
     @PrimaryKey
@@ -64,6 +71,7 @@ public PermissionOfferResponse() {
      *              {@link PermissionOffer}.
      */
     public PermissionOfferResponse(String token) {
+        //noinspection ConstantConditions
         if (token == null) {
             throw new IllegalArgumentException("Non-null 'token' required.");
         }
@@ -74,15 +82,18 @@ public void setToken(String token) {
         this.token = token;
     }
 
+    @Override
     public String getId() {
         return id;
     }
 
+    @Override
     @SuppressFBWarnings("EI_EXPOSE_REP")
     public Date getCreatedAt() {
         return createdAt;
     }
 
+    @Override
     @SuppressFBWarnings("EI_EXPOSE_REP")
     public Date getUpdatedAt() {
         return updatedAt;
@@ -93,6 +104,8 @@ public Date getUpdatedAt() {
      *
      * @return {@code null} if not yet processed. {@code 0} if successful, {@code >0} if an error happened. See {@link #getStatusMessage()}.
      */
+    @Override
+    @Nullable
     public Integer getStatusCode() {
         return statusCode;
     }
@@ -107,6 +120,8 @@ public boolean isSuccessful() {
         return statusCode != null && statusCode == 0;
     }
 
+    @Override
+    @Nullable
     public String getStatusMessage() {
         return statusMessage;
     }
@@ -115,7 +130,16 @@ public String getToken() {
         return token;
     }
 
+    @Nullable
     public String getRealmUrl() {
         return realmUrl;
     }
+
+    public String getPath() {
+        try {
+            return new URI(realmUrl).getPath();
+        } catch (URISyntaxException e) {
+            throw new RuntimeException(e);
+        }
+    }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/AccessLevel.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/AccessLevel.java
new file mode 100644
index 0000000000..79afe55b95
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/AccessLevel.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.permissions;
+
+import io.realm.PermissionManager;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
+
+
+/**
+ * Access levels which can be granted to Realm Mobile Platform users for specific synchronized Realms, using a
+ * {@link PermissionRequest}.
+ * <p>
+ * Note that each access level guarantees all allowed actions provided by less permissive access levels.
+ * Specifically, users with write access to a Realm can always read from that Realm, and users with administrative
+ * access can always read or write from the Realm. This means that {@code NONE < READ < WRITE < ADMIN}.
+ *
+ * @see PermissionRequest
+ * @see io.realm.PermissionManager#applyPermissions(PermissionRequest, PermissionManager.ApplyPermissionsCallback)
+ */
+public enum AccessLevel {
+
+    /**
+     * The user does not have access to this Realm.
+     */
+    NONE(false, false, false),
+
+    /**
+     * User can only read the contents of the Realm.
+     * <p>
+     * Users who have read-only access to a Realm should open it using `readOnly()` and
+     * `waitForInitialRemoteData()` on the {@link io.realm.SyncConfiguration}. Attempting to directly open the Realm
+     * is an error; in this case the Realm must manually be deleted using {@link Realm#deleteRealm(RealmConfiguration)}
+     * before being re-opened with the correct configuration.
+     * <p>
+     * <pre>
+     * {@code
+     * SyncConfiguration config = new SyncConfiguration(getUser(), getUrl())
+     *     .readOnly()
+     *     .waitForInitialRemoteData()
+     *     .build();
+     * }
+     * </pre>
+     */
+    READ(true, false, false),
+
+    /**
+     * User can read and write the contents of the Realm.
+     */
+    WRITE(true, true, false),
+
+    /**
+     * User can read, write, and administer the Realm. This includes both granting permissions as well as removing them
+     * again.
+     */
+    ADMIN(true, true, true);
+
+    private final boolean mayRead;
+    private final boolean mayWrite;
+    private final boolean mayManage;
+
+    AccessLevel(boolean mayRead, boolean mayWrite, boolean mayManage) {
+        this.mayRead = mayRead;
+        this.mayWrite = mayWrite;
+        this.mayManage = mayManage;
+    }
+
+    /**
+     * Returns {@code true} if the user is allowed to read a Realm, {@code false} if not.
+     */
+    public boolean mayRead() {
+        return mayRead;
+    }
+
+    /**
+     * Returns {@code true} if the user is allowed to write to the Realm, {@code false} if not.
+     */
+    public boolean mayWrite() {
+        return mayWrite;
+    }
+
+    /**
+     * Returns {@code true} if the user is allowed to manage the Realm, {@code false} if not.
+     * <p>
+     * Having this permission, means the user is able to grant permissions to other users as well as remove them
+     * again.
+     */
+    public boolean mayManage() {
+        return mayManage;
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/Permission.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/Permission.java
new file mode 100644
index 0000000000..2e975c7ff5
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/Permission.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.permissions;
+
+import java.util.Date;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+import io.realm.PermissionManager;
+import io.realm.RealmObject;
+import io.realm.SyncUser;
+import io.realm.annotations.Required;
+
+
+/**
+ * This class represents a given set of permissions for one user on one Realm.
+ * <p>
+ * Permissions can be changed by users with administrative rights using the {@link PermissionManager}.
+ *
+ * @see SyncUser#getPermissionManager()
+ */
+public class Permission extends RealmObject {
+
+    @Required
+    private String userId;
+    @Required
+    private String path;
+    private boolean mayRead;
+    private boolean mayWrite;
+    private boolean mayManage;
+    @Required
+    private Date updatedAt;
+
+    /**
+     * Required by Realm. Do not use.
+     */
+    public Permission() {
+        // Required by Realm
+    }
+
+    /**
+     * Returns the {@link SyncUser#getIdentity()} of the user effected by this permission.˚
+     * <p>
+     *
+     * @return the user effected by this permission.
+     */
+    public String getUserId() {
+        return userId;
+    }
+
+    /**
+     * Returns the path to the Realm on the server effected by this permission. This is not the full URL.
+     *
+     * @return the path to the Realm this permission object refers to.
+     */
+    public String getPath() {
+        return path;
+    }
+
+    /**
+     * Checks whether or not the user defined by this permission is allowed to read the Realm defined by
+     * {@link #getPath()}.
+     *
+     * @return {@code true} if this permission grant read permissions to the Realm, {@code false} if not.
+     */
+    public boolean mayRead() {
+        return mayRead;
+    }
+
+    /**
+     * Checks whether or not the user defined by this permission is allowed to write to the Realm defined by
+     * {@link #getPath()}.
+     *
+     * @return {@code true} if this permission grant write permissions to the Realm, {@code false} if not.
+     */
+    public boolean mayWrite() {
+        return mayWrite;
+    }
+
+    /**
+     * Checks whether or not the user defined by this permission is allowed to manage access to the Realm defined
+     * by {@link #getPath()}. Having this permission enable those users to add or remove permissions from
+     * other users, including the one who granted it.
+     *
+     * @return {@code true} if this permission grant administrative rights to the Realm, {@code false} if not.
+     */
+    public boolean mayManage() {
+        return mayManage;
+    }
+
+    /**
+     * Returns the timestamp for when this permission object was last updated.
+     *
+     * @return the timestamp for when this permission was last updated.
+     */
+    @SuppressFBWarnings({"EI_EXPOSE_REP"})
+    public Date getUpdatedAt() {
+        return updatedAt;
+    }
+
+    @Override
+    public String toString() {
+        return "Permission{" +
+                "userId='" + userId + '\'' +
+                ", path='" + path + '\'' +
+                ", mayRead=" + mayRead +
+                ", mayWrite=" + mayWrite +
+                ", mayManage=" + mayManage +
+                ", updatedAt=" + updatedAt +
+                '}';
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOffer.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOffer.java
index 0405f5ca70..a42e5b9e77 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOffer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionOffer.java
@@ -15,23 +15,39 @@
  */
 package io.realm.permissions;
 
+import java.net.URI;
+import java.net.URISyntaxException;
 import java.util.Date;
 import java.util.UUID;
 
+import javax.annotation.Nullable;
+
 import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-import io.realm.RealmObject;
+import io.realm.PermissionManager;
 import io.realm.annotations.Index;
 import io.realm.annotations.PrimaryKey;
+import io.realm.annotations.RealmClass;
 import io.realm.annotations.Required;
+import io.realm.internal.Util;
+import io.realm.internal.permissions.BasePermissionApi;
+
 
 /**
- * This model is used for offering permission changes to other users.
- * It should be used in conjunction with an {@link io.realm.SyncUser}'s management Realm.
+ * This class represents a permission offer for a Realm that can be given to other users.
+ * When an offer is successfully created, it will be represented by an {@code offerToken} that can be sent
+ * to other users. Once they accept this token, the permissions covered by this offer will take effect for that
+ * user.
+ * <p>
+ * Permission offers can only be created by users that can manage the Realm, the offer is about.
  *
+ * @see PermissionManager#makeOffer(PermissionOffer, PermissionManager.MakeOfferCallback)
+ * @see PermissionManager#acceptOffer(String, PermissionManager.AcceptOfferCallback)
  * @see <a href="https://realm.io/docs/realm-object-server/#permissions">Permissions description</a> for general
  * documentation.
  */
-public class PermissionOffer extends RealmObject {
+
+@RealmClass
+public class PermissionOffer implements BasePermissionApi {
 
     // Base fields
     @PrimaryKey
@@ -54,90 +70,206 @@
     private boolean mayManage;
     private Date expiresAt;
 
+    /**
+     * Constructor required by Realm. Should not be used.
+     */
     public PermissionOffer() {
         // No args constructor required by Realm
     }
 
     /**
-     * Construct a permission offer object used to offer permission changes to other users.
+     * Creates a request for an permission offer that last until it is manually revoked.
+     *
+     * @param url specific url to Realm effected this offer encompasses all Realms manged by the user making the offer.
+     * @param accessLevel the {@link AccessLevel} granted to the user accepting the offer.
      *
-     * @param url The URL to the Realm on which to apply these permission changes to, once the offer is accepted.
-     * @param mayRead Grant or revoke read access.
-     * @param mayWrite Grant or revoked read-write access.
-     * @param mayManage Grant or revoke administrative access.
-     * @param expiresAt When this token will expire and become invalid. Pass {@code null} if this offer should not expire.
+     * @see PermissionManager#revokeOffer(String, PermissionManager.RevokeOfferCallback)
      */
     @SuppressFBWarnings("EI_EXPOSE_REP2")
-    public PermissionOffer(String url, boolean mayRead, boolean mayWrite, boolean mayManage, Date expiresAt) {
-        if (url == null) {
-            throw new IllegalArgumentException("Non-null 'url' required.");
-        }
+    public PermissionOffer(String url, AccessLevel accessLevel) {
+        //noinspection ConstantConditions
+        this(url, accessLevel, null);
+    }
+
+    /**
+     * Creates a request for a permission offer that last until it is manually revoked.
+     *
+     * @param url specific url to Realm effected. The user sending the offer must have manage rights to this Realm.
+     * @param accessLevel the {@link AccessLevel} granted to the user accepting the offer.
+     * @param expiresAt the date and time when this offer expires. If {@code null} is provided the offer never expires.
+     *
+     *
+     * @see PermissionManager#revokeOffer(String, PermissionManager.RevokeOfferCallback)
+     */
+    @SuppressFBWarnings("EI_EXPOSE_REP2")
+    public PermissionOffer(String url, AccessLevel accessLevel, @Nullable Date expiresAt) {
+        validateUrl(url);
+        validateAccessLevel(accessLevel);
+        this.mayRead = accessLevel.mayRead();
+        this.mayWrite = accessLevel.mayWrite();
+        this.mayManage = accessLevel.mayManage();
         this.realmUrl = url;
-        this.mayRead = mayRead;
-        this.mayWrite= mayWrite;
-        this.mayManage = mayManage;
-        this.expiresAt = expiresAt;
+        //noinspection ConstantConditions
+        this.expiresAt = (expiresAt != null) ? (Date) expiresAt.clone() : null;
     }
 
+    private void validateUrl(String url) {
+        if (Util.isEmptyString(url)) {
+            throw new IllegalArgumentException("Non-empty 'realmUrl' required.");
+        }
+
+        try {
+            // Validate basic syntax.
+            new URI(url);
+        } catch (URISyntaxException e) {
+            throw new IllegalArgumentException("Invalid 'realmUrl'.", e);
+        }
+    }
+
+    private void validateAccessLevel(AccessLevel accessLevel) {
+        if (accessLevel == null) {
+            throw new IllegalArgumentException("Non-null 'accessLevel' required.");
+        }
+    }
+
+    /**
+     * Returns the id uniquely identifying this offer.
+     *
+     * @return the id uniquely identifying this offer.
+     */
+    @Override
     public String getId() {
         return id;
     }
 
+    /**
+     * Returns the timestamp when this offer was created.
+     *
+     * @return the timstamp when this offer was created.
+     */
+    @Override
     @SuppressFBWarnings("EI_EXPOSE_REP")
     public Date getCreatedAt() {
         return createdAt;
     }
 
+    /**
+     * Returns the timestamp this offer was last updated.
+     *
+     * @return the timestamp when this offer was last updated.
+     */
+    @Override
     @SuppressFBWarnings("EI_EXPOSE_REP")
     public Date getUpdatedAt() {
         return updatedAt;
     }
 
+
     /**
-     * Returns the status code for this change.
+     * Returns the server status code for this change.
      *
-     * @return {@code null} if not yet processed. {@code 0} if successful, {@code >0} if an error happened. See {@link #getStatusMessage()}.
+     * @return {@code null} if not yet processed. {@code 0} if successful, {@code >0} if an error happened.
+     * See {@link #getStatusMessage()}.
      */
+    @Override
+    @Nullable
     public Integer getStatusCode() {
         return statusCode;
     }
 
     /**
-     * Check if the request was successfully handled by the Realm Object Server.
+     * Returns the servers status message, if an error occurred. Otherwise it will return {@code null}.
      *
-     * @return {@code true} if request was handled successfully. {@code false} if not. See {@link #getStatusMessage()}
-     *         for the full error message.
+     * @return The servers status message in case of an error, {@code null} otherwise.
      */
-    public boolean isSuccessful() {
-        return statusCode != null && statusCode == 0;
-    }
-
+    @Override
+    @Nullable
     public String getStatusMessage() {
         return statusMessage;
     }
 
+    /**
+     * Checks if the request was successfully handled by the Realm Object Server.
+     *
+     * @return {@code true} if the request was handled successfully. {@code false} if not. See {@link #getStatusMessage()}
+     *         for the full error message.
+     */
+    public boolean isOfferCreated() {
+        return !Util.isEmptyString(token);
+    }
+
+    /**
+     * Returns the offer token if this offer was successfully created.
+     *
+     * @return the offer token or {@code null} if the offer wasn't created yet.
+     */
+    @Nullable
     public String getToken() {
         return token;
     }
 
+    /**
+     * Returns the Realm URL for which the permissions are granted.
+     *
+     * @return the Realm URL for which the permissions should be granted.
+     */
     public String getRealmUrl() {
         return realmUrl;
     }
 
-    public boolean isMayRead() {
+    /**
+     * Returns whether or not the user accepting this offer is granted read permission.
+     *
+     * @return {@code true} if the user accepting this offer is granted read permission, {@code false} if not.
+     */
+    public boolean mayRead() {
         return mayRead;
     }
 
-    public boolean isMayWrite() {
+    /**
+     * Returns whether or not the user accepting this offer is granted write permission.
+     *
+     * @return {@code true} if the user accepting this offer is granted write permission, {@code false} if not.
+     */
+    public boolean mayWrite() {
         return mayWrite;
     }
 
-    public boolean isMayManage() {
+    /**
+     * Returns whether or not the user accepting this offer is granted manage permission. This will allow this user
+     * to also grant or remove permission for other users on this Realm.
+     *
+     * @return {@code true} if the user accepting this offer is granted mange permission, {@code false} if not.
+     */
+    public boolean mayManage() {
         return mayManage;
     }
 
+    /**
+     * Returns when this offer expires. {@code null} is returned if this offer never expires.
+     *
+     * @return the date when this offer expires or {@code null} if it never expires.
+     */
     @SuppressFBWarnings("EI_EXPOSE_REP")
+    @Nullable
     public Date getExpiresAt() {
         return expiresAt;
     }
+
+    @Override
+    public String toString() {
+        return "PermissionOffer{" +
+                "id='" + id + '\'' +
+                ", createdAt=" + createdAt +
+                ", updatedAt=" + updatedAt +
+                ", statusCode=" + statusCode +
+                ", statusMessage='" + statusMessage + '\'' +
+                ", token='" + token + '\'' +
+                ", realmUrl='" + realmUrl + '\'' +
+                ", mayRead=" + mayRead +
+                ", mayWrite=" + mayWrite +
+                ", mayManage=" + mayManage +
+                ", expiresAt=" + expiresAt +
+                '}';
+    }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionRequest.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionRequest.java
new file mode 100644
index 0000000000..59dca34d0a
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/PermissionRequest.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.permissions;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+import io.realm.PermissionManager;
+import io.realm.internal.Util;
+
+
+/**
+ * This class represents the intent of giving a set of permissions to some users for some Realm(s).
+ * <p>
+ * If the request is successful, a {@link Permission} entry will be added to each affected users
+ * {@link PermissionManager}, where it can be fetched using
+ * {@link PermissionManager#getPermissions(PermissionManager.PermissionsCallback)}
+ *
+ * @see PermissionManager#applyPermissions(PermissionRequest, PermissionManager.ApplyPermissionsCallback)
+ * @see PermissionManager#getPermissions(PermissionManager.PermissionsCallback)
+ */
+public final class PermissionRequest {
+
+    private final AccessLevel accessLevel;
+    private final UserCondition condition;
+    private final String url;
+
+    /**
+     * Creates a description of a set of permissions granted to some users for some Realms.
+     *
+     * @param realmUrl the Realm URL whose permissions settings should be changed. Use {@code *} to change the
+     * permissions of all Realms managed by the user sending this request. The user that wants to grant these permissions
+     * must have administrative rights to those Realms.
+     *
+     * @param condition the conditions used to match which users are effected.
+     * @param accessLevel the {@link AccessLevel} to grant matching users. Setting the access level is absolute i.e., it
+     * may revoke permissions for users that previously had a higher access level. To revoke all permissions, use
+     * {@link AccessLevel#NONE}.
+     *
+     */
+    public PermissionRequest(UserCondition condition, String realmUrl, AccessLevel accessLevel) {
+        checkCondition(condition);
+        checkUrl(realmUrl);
+        checkAccessLevel(accessLevel);
+        this.condition = condition;
+        this.accessLevel = accessLevel;
+        this.url = realmUrl;
+    }
+
+    private void checkUrl(String url) {
+        if (Util.isEmptyString(url)) {
+            throw new IllegalArgumentException("Non-empty 'realmUrl' required.");
+        }
+
+        if (url.equals("*")) {
+            return; // Special case for selecting all URL's
+        }
+
+        try {
+            // Validate basic syntax.
+            new URI(url);
+        } catch (URISyntaxException e) {
+            throw new IllegalArgumentException("Invalid 'realmUrl'.", e);
+        }
+    }
+
+    private void checkCondition(UserCondition condition) {
+        if (condition == null) {
+            throw new IllegalArgumentException("Non-null 'condition' required.");
+        }
+    }
+
+    private void checkAccessLevel(AccessLevel accessLevel) {
+        if (accessLevel == null) {
+            throw new IllegalArgumentException("Non-null 'accessLevel' required.");
+        }
+    }
+
+    /**
+     * Returns the access level that users will be granted if the request is successful.
+     *
+     * @return the {@link AccessLevel} users will have once this request is successfully handled.
+     */
+    public AccessLevel getAccessLevel() {
+        return accessLevel;
+    }
+
+    /**
+     * Returns the {@link UserCondition} used to match users. Those users that match will be granted the the
+     * {@link AccessLevel} defined by {@link #getAccessLevel()}.
+     *
+     * @return the condition used to match users.
+     */
+    public UserCondition getCondition() {
+        return condition;
+    }
+
+    /**
+     * The Realm URL for which the permissions are granted. {@code *} is returned if the request should match
+     * all Realms, for which the user sending the request, has administrative rights.
+     *
+     * @return the Realm URL for which the permissions should be granted.
+     * @see Permission#mayManage()
+     */
+    public String getUrl() {
+        return url;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) { return true; }
+        if (o == null || getClass() != o.getClass()) { return false; }
+
+        PermissionRequest that = (PermissionRequest) o;
+
+        if (accessLevel != that.accessLevel) { return false; }
+        if (!condition.equals(that.condition)) { return false; }
+        return url.equals(that.url);
+
+    }
+
+    @Override
+    public int hashCode() {
+        int result = accessLevel.hashCode();
+        result = 31 * result + condition.hashCode();
+        result = 31 * result + url.hashCode();
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "PermissionRequest{" +
+                "accessLevel=" + accessLevel +
+                ", condition=" + condition +
+                ", url='" + url + '\'' +
+                '}';
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/UserCondition.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/UserCondition.java
new file mode 100644
index 0000000000..57026e7ed4
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/UserCondition.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.permissions;
+
+import io.realm.PermissionManager;
+import io.realm.SyncUser;
+import io.realm.internal.Util;
+
+
+/**
+ * This class represents a condition for matching users on the Realm Object Server.
+ * It is used when a request for changing existing permissions is made.
+ *
+ * @see PermissionRequest
+ * @see io.realm.PermissionManager#applyPermissions(PermissionRequest, PermissionManager.ApplyPermissionsCallback)
+ */
+public final class UserCondition {
+
+    private final String key;
+    private final String value;
+    private final MatcherType type;
+
+    /**
+     * Creates a condition for matching, exactly, a users username. The comparison is case-sensitive and wildcards are
+     * not allowed.
+     *
+     * @param username exact username to match against.
+     */
+    public static UserCondition username(String username) {
+        if (Util.isEmptyString(username)) {
+            throw new IllegalArgumentException("Non-empty 'username' required.");
+        }
+        return new UserCondition(MatcherType.METADATA, "email", username);
+    }
+
+    /**
+     * Creates a condition for matching, exactly, a users id.
+     *
+     * @param userId user id to match against. No wildcards are allowed.
+     * @see SyncUser#getIdentity()
+     */
+    public static UserCondition userId(String userId) {
+        if (Util.isEmptyString(userId)) {
+            throw new IllegalArgumentException("Non-empty 'userId' required.");
+        }
+        return new UserCondition(MatcherType.USER_ID, "", userId);
+    }
+
+    /**
+     * Creates a condition that will match all users with no permissions for the Realm.
+     * <p>
+     * The {@link AccessLevel} defined alongside this condition, will also be used as the default access level
+     * for future new users that might be given access to the Realm.
+     *
+     * @see PermissionManager#makeOffer(PermissionOffer, PermissionManager.MakeOfferCallback)
+     */
+    public static UserCondition noExistingPermissions() {
+        return userId("*");
+    }
+
+    /**
+     * Creates a custom permission condition.
+     * This will apply the permissions based on a key/value combination in the user's metadata.
+     *
+     * @param key key to use.
+     * @param value value for that field to match.
+     */
+    public static UserCondition keyValue(String key, String value) {
+        if (Util.isEmptyString(key)) {
+            throw new IllegalArgumentException("Non-empty 'key' required.");
+        }
+        if (value == null) {
+            throw new IllegalArgumentException("Non-null 'value' required.");
+        }
+        return new UserCondition(MatcherType.METADATA, key, value);
+    }
+
+    private UserCondition(MatcherType type, String key, String value) {
+        this.type = type;
+        this.key = key;
+        this.value = value;
+    }
+
+    /**
+     * Returns the they in the users metadata that is used for evaluating this condition.
+     *
+     * @return the key in the users metadata.
+     */
+    public String getKey() {
+        return key;
+    }
+
+    /**
+     * Returns the value that is used when matching users. The semantics of the value will be different
+     * depending on the type of key used.
+     *
+     * @return the value to searchh for in the users meta data.
+     */
+    public String getValue() {
+        return value;
+    }
+
+    /**
+     * Returns the type of data this condition matches.
+     *
+     * @return the type of data this condition matches.
+     */
+    public MatcherType getType() {
+        return type;
+    }
+
+    /**
+     * Type of matcher this condition represents.
+     */
+    public enum MatcherType {
+        USER_ID,
+        METADATA
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) { return true; }
+        if (o == null || getClass() != o.getClass()) { return false; }
+
+        UserCondition that = (UserCondition) o;
+
+        if (!key.equals(that.key)) { return false; }
+        return value.equals(that.value);
+
+    }
+
+    @Override
+    public int hashCode() {
+        int result = key.hashCode();
+        result = 31 * result + value.hashCode();
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "UserCondition{" +
+                "key='" + key + '\'' +
+                ", value='" + value + '\'' +
+                '}';
+    }
+}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/permissions/package-info.java b/realm/realm-library/src/objectServer/java/io/realm/permissions/package-info.java
new file mode 100644
index 0000000000..6a34b88722
--- /dev/null
+++ b/realm/realm-library/src/objectServer/java/io/realm/permissions/package-info.java
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+@javax.annotation.ParametersAreNonnullByDefault
+package io.realm.permissions;
diff --git a/realm/realm-library/src/androidTestObjectServer/assets/schemaversion_v1.realm b/realm/realm-library/src/syncIntegrationTest/assets/sync-1.x.realm
similarity index 64%
rename from realm/realm-library/src/androidTestObjectServer/assets/schemaversion_v1.realm
rename to realm/realm-library/src/syncIntegrationTest/assets/sync-1.x.realm
index d2dac44060..3f7404b42e 100644
Binary files a/realm/realm-library/src/androidTestObjectServer/assets/schemaversion_v1.realm and b/realm/realm-library/src/syncIntegrationTest/assets/sync-1.x.realm differ
diff --git a/realm/realm-library/src/syncIntegrationTest/assets/trusted_ca.pem b/realm/realm-library/src/syncIntegrationTest/assets/trusted_ca.pem
new file mode 100644
index 0000000000..080849fe6c
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/assets/trusted_ca.pem
@@ -0,0 +1,123 @@
+Certificate:
+    Data:
+        Version: 3 (0x2)
+        Serial Number: 1 (0x1)
+    Signature Algorithm: sha1WithRSAEncryption
+        Issuer: DC=io, DC=realm, O=Realm, OU=Realm Test Root CA, CN=Realm Test Root CA
+        Validity
+            Not Before: Sep  7 09:42:23 2016 GMT
+            Not After : Sep  7 09:42:23 2026 GMT
+        Subject: DC=io, DC=realm, O=Realm, OU=Realm Test Root CA, CN=Realm Test Root CA
+        Subject Public Key Info:
+            Public Key Algorithm: rsaEncryption
+                Public-Key: (4096 bit)
+                Modulus:
+                    00:dc:43:b2:92:b1:be:ff:da:43:f3:b8:d5:4b:42:
+                    9e:05:7f:4e:bf:09:2f:02:33:1a:24:44:ff:12:7e:
+                    35:9c:cd:b3:61:78:0a:b0:83:80:82:ec:a2:5c:66:
+                    f0:7d:d4:df:f9:9c:be:b5:4e:e6:6b:60:59:e7:ed:
+                    0f:85:47:2e:83:5a:55:c1:1a:32:a9:c8:b8:d4:5a:
+                    96:94:ef:4f:f1:aa:64:59:c8:8c:89:1a:e6:1a:f4:
+                    94:5c:e8:be:59:0f:6b:cc:9d:58:e5:e4:29:22:ba:
+                    54:96:dd:8a:f6:28:d6:d6:c8:ca:df:b2:c2:f7:1e:
+                    19:58:75:ab:a2:ab:04:e4:1f:ed:fe:04:ec:f2:f1:
+                    da:62:d2:bd:9b:4b:84:ba:d0:5e:dc:63:40:03:cc:
+                    c6:88:1c:15:5c:96:41:b0:58:3d:af:08:bd:64:34:
+                    b8:3b:00:03:28:21:37:bf:5c:bc:1c:e7:2d:08:a5:
+                    02:ad:c0:49:ba:34:56:8e:63:66:ba:60:8c:5c:89:
+                    ba:0f:76:47:9c:bc:31:6a:5d:8e:4d:a9:4d:74:c7:
+                    18:29:b1:9f:08:98:0b:ff:13:5b:58:52:0b:85:f1:
+                    b0:fe:be:3f:ba:ea:5e:50:2f:ea:1d:85:1f:c2:87:
+                    2a:70:14:05:3d:70:6c:e3:c7:a7:81:6b:3e:11:67:
+                    bf:b4:9e:26:a4:57:df:16:0a:f3:83:7c:fb:64:e3:
+                    33:9f:08:55:25:de:1e:93:e6:13:0a:38:94:33:0c:
+                    40:87:f7:c7:69:1c:1d:5b:aa:0e:8e:e7:8f:ae:36:
+                    07:5b:1b:7d:c3:5c:13:20:c6:01:7b:9b:f2:f6:c7:
+                    ec:82:5d:33:75:cb:5b:b1:6b:be:96:36:f6:c4:1d:
+                    83:eb:88:dd:9a:ae:92:ea:ee:0f:20:8a:d6:c1:04:
+                    24:c8:4b:6a:89:0e:c5:46:4c:f9:79:2a:7a:60:7a:
+                    4a:72:9a:82:03:d2:75:c6:10:fb:d3:00:3b:6b:13:
+                    bc:f5:fe:83:94:40:18:a1:97:46:8c:5e:5b:ae:4a:
+                    c5:93:74:a5:9f:1e:d2:64:13:b0:d6:83:60:4e:69:
+                    f7:16:05:0b:e9:45:ec:b9:52:78:12:53:60:d7:88:
+                    f5:58:75:20:e4:ab:4a:e3:cb:b1:5d:82:57:4c:3f:
+                    47:44:70:90:06:a7:70:14:3c:6b:83:f9:28:07:12:
+                    81:f6:70:02:24:2d:52:70:01:96:1c:77:29:67:6c:
+                    5e:80:d8:51:fd:e5:43:5d:60:ad:2c:5f:95:aa:74:
+                    2d:f2:8e:43:30:e9:67:eb:c7:65:0a:4b:3b:b0:3f:
+                    ae:85:da:30:26:2a:b8:20:11:b3:92:9a:8a:d0:13:
+                    e6:d7:23
+                Exponent: 65537 (0x10001)
+        X509v3 extensions:
+            X509v3 Key Usage: critical
+                Certificate Sign, CRL Sign
+            X509v3 Basic Constraints: critical
+                CA:TRUE
+            X509v3 Subject Key Identifier: 
+                84:70:71:2C:04:3B:D0:92:83:B5:FB:7C:7F:B0:61:0C:62:16:71:74
+            X509v3 Authority Key Identifier: 
+                keyid:84:70:71:2C:04:3B:D0:92:83:B5:FB:7C:7F:B0:61:0C:62:16:71:74
+
+    Signature Algorithm: sha1WithRSAEncryption
+         6c:35:e0:07:db:3a:15:30:00:7f:38:fd:6d:b7:7a:85:84:87:
+         1b:72:78:33:ee:00:81:c0:51:33:6f:f3:a8:e8:3b:30:fd:ef:
+         19:c5:d2:95:83:b7:80:8f:1b:79:ff:ac:e6:f2:f5:f6:a0:71:
+         16:57:72:58:1a:75:e4:4c:3d:b3:4b:b5:3d:8c:d9:66:1a:5f:
+         7c:c0:2c:1f:2c:0a:3e:fb:84:20:ce:c8:7d:8e:9b:e6:fe:4b:
+         06:af:10:4f:db:97:3c:cd:04:df:3c:2f:c2:c6:29:c0:70:19:
+         b3:5a:9e:fe:0f:7d:83:95:83:a5:db:01:d8:c4:91:6f:ee:25:
+         6b:cd:8e:2e:b2:69:88:1f:e9:57:ef:4c:c4:18:cd:d2:42:4e:
+         c1:19:bd:8d:c9:4e:e7:b3:05:fa:6e:c5:32:0a:c3:f0:bd:ec:
+         d3:44:d4:80:08:26:2d:12:cb:1b:a4:9d:09:ca:0b:02:eb:5a:
+         b6:54:51:ac:90:63:77:76:6f:33:35:fe:87:db:d2:c0:bc:ea:
+         5b:c5:9b:e9:4c:c2:82:28:a7:4f:62:df:18:4f:1c:8b:93:7a:
+         f3:32:89:0a:3e:c1:bd:8a:45:29:f8:7f:18:4c:a1:77:e1:e2:
+         b4:eb:50:31:6b:77:d5:78:12:95:c9:02:d7:61:03:13:6e:be:
+         fe:dd:83:35:2b:4c:dc:45:81:6f:16:7f:29:b8:6f:bb:6d:f6:
+         15:6d:3b:d2:14:f9:94:24:86:df:4e:b7:9e:93:2e:94:25:e6:
+         b1:b5:c0:96:c9:a3:56:cf:95:15:7f:43:41:f0:3e:c2:ed:8d:
+         16:c1:7b:db:ff:38:48:08:b4:39:43:81:65:31:ba:78:d1:77:
+         e9:1a:f0:5a:18:05:db:db:91:ca:e8:f9:8c:2e:6e:a9:8c:ba:
+         69:96:01:2e:fa:6a:f5:de:bf:1c:53:ca:14:2a:91:0b:2a:f2:
+         fa:b9:07:eb:6d:9d:59:ae:08:6b:fa:61:95:75:9c:76:4b:22:
+         a7:0c:c4:66:e7:aa:9e:da:84:76:fc:8e:50:59:c2:55:b8:e1:
+         01:e5:54:85:7f:32:4f:63:e0:74:77:96:ae:6b:35:db:0a:0c:
+         da:27:3b:c7:c8:3b:ba:d4:41:3a:aa:5c:ed:71:0b:10:88:05:
+         9e:21:c5:99:c3:3a:e2:a2:de:f9:f5:c6:ce:9a:16:be:18:41:
+         24:14:ee:47:76:f2:db:b1:98:f2:0e:fd:18:ae:a7:f0:f1:55:
+         56:7a:9a:f2:84:50:77:f2:08:c7:f4:3f:f5:1b:03:97:49:41:
+         e3:a1:2b:c3:ee:f5:bc:bc:9d:2b:38:39:10:74:5b:18:92:2a:
+         fa:c0:4b:46:c0:ff:46:56
+-----BEGIN CERTIFICATE-----
+MIIFyDCCA7CgAwIBAgIBATANBgkqhkiG9w0BAQUFADB1MRIwEAYKCZImiZPyLGQB
+GRYCaW8xFTATBgoJkiaJk/IsZAEZFgVyZWFsbTEOMAwGA1UECgwFUmVhbG0xGzAZ
+BgNVBAsMElJlYWxtIFRlc3QgUm9vdCBDQTEbMBkGA1UEAwwSUmVhbG0gVGVzdCBS
+b290IENBMB4XDTE2MDkwNzA5NDIyM1oXDTI2MDkwNzA5NDIyM1owdTESMBAGCgmS
+JomT8ixkARkWAmlvMRUwEwYKCZImiZPyLGQBGRYFcmVhbG0xDjAMBgNVBAoMBVJl
+YWxtMRswGQYDVQQLDBJSZWFsbSBUZXN0IFJvb3QgQ0ExGzAZBgNVBAMMElJlYWxt
+IFRlc3QgUm9vdCBDQTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANxD
+spKxvv/aQ/O41UtCngV/Tr8JLwIzGiRE/xJ+NZzNs2F4CrCDgILsolxm8H3U3/mc
+vrVO5mtgWeftD4VHLoNaVcEaMqnIuNRalpTvT/GqZFnIjIka5hr0lFzovlkPa8yd
+WOXkKSK6VJbdivYo1tbIyt+ywvceGVh1q6KrBOQf7f4E7PLx2mLSvZtLhLrQXtxj
+QAPMxogcFVyWQbBYPa8IvWQ0uDsAAyghN79cvBznLQilAq3ASbo0Vo5jZrpgjFyJ
+ug92R5y8MWpdjk2pTXTHGCmxnwiYC/8TW1hSC4XxsP6+P7rqXlAv6h2FH8KHKnAU
+BT1wbOPHp4FrPhFnv7SeJqRX3xYK84N8+2TjM58IVSXeHpPmEwo4lDMMQIf3x2kc
+HVuqDo7nj642B1sbfcNcEyDGAXub8vbH7IJdM3XLW7FrvpY29sQdg+uI3Zqukuru
+DyCK1sEEJMhLaokOxUZM+XkqemB6SnKaggPSdcYQ+9MAO2sTvPX+g5RAGKGXRoxe
+W65KxZN0pZ8e0mQTsNaDYE5p9xYFC+lF7LlSeBJTYNeI9Vh1IOSrSuPLsV2CV0w/
+R0RwkAancBQ8a4P5KAcSgfZwAiQtUnABlhx3KWdsXoDYUf3lQ11grSxflap0LfKO
+QzDpZ+vHZQpLO7A/roXaMCYquCARs5KaitAT5tcjAgMBAAGjYzBhMA4GA1UdDwEB
+/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBSEcHEsBDvQkoO1+3x/
+sGEMYhZxdDAfBgNVHSMEGDAWgBSEcHEsBDvQkoO1+3x/sGEMYhZxdDANBgkqhkiG
+9w0BAQUFAAOCAgEAbDXgB9s6FTAAfzj9bbd6hYSHG3J4M+4AgcBRM2/zqOg7MP3v
+GcXSlYO3gI8bef+s5vL19qBxFldyWBp15Ew9s0u1PYzZZhpffMAsHywKPvuEIM7I
+fY6b5v5LBq8QT9uXPM0E3zwvwsYpwHAZs1qe/g99g5WDpdsB2MSRb+4la82OLrJp
+iB/pV+9MxBjN0kJOwRm9jclO57MF+m7FMgrD8L3s00TUgAgmLRLLG6SdCcoLAuta
+tlRRrJBjd3ZvMzX+h9vSwLzqW8Wb6UzCgiinT2LfGE8ci5N68zKJCj7BvYpFKfh/
+GEyhd+HitOtQMWt31XgSlckC12EDE26+/t2DNStM3EWBbxZ/Kbhvu232FW070hT5
+lCSG3063npMulCXmsbXAlsmjVs+VFX9DQfA+wu2NFsF72/84SAi0OUOBZTG6eNF3
+6RrwWhgF29uRyuj5jC5uqYy6aZYBLvpq9d6/HFPKFCqRCyry+rkH622dWa4Ia/ph
+lXWcdksipwzEZueqntqEdvyOUFnCVbjhAeVUhX8yT2PgdHeWrms12woM2ic7x8g7
+utRBOqpc7XELEIgFniHFmcM64qLe+fXGzpoWvhhBJBTuR3by27GY8g79GK6n8PFV
+Vnqa8oRQd/IIx/Q/9RsDl0lB46Erw+71vLydKzg5EHRbGJIq+sBLRsD/RlY=
+-----END CERTIFICATE-----
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
new file mode 100644
index 0000000000..fa0406c914
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/BaseIntegrationTest.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.support.test.InstrumentationRegistry;
+import android.support.test.rule.UiThreadTestRule;
+import android.util.Log;
+
+import org.junit.Rule;
+import org.junit.rules.ExpectedException;
+
+import java.io.File;
+import java.io.IOException;
+
+import io.realm.internal.Util;
+import io.realm.log.LogLevel;
+import io.realm.log.RealmLog;
+import io.realm.objectserver.utils.HttpUtils;
+import io.realm.objectserver.utils.UserFactory;
+import io.realm.rule.RunInLooperThread;
+
+
+/**
+ * Base class used by Integration Tests.
+ * This class should not be used directly. Instead {@link StandardIntegrationTest} or {@link IsolatedIntegrationTests }
+ * should be used instead.
+ */
+public abstract class BaseIntegrationTest {
+
+    private static int originalLogLevel;
+
+    @Rule
+    public final TestSyncConfigurationFactory configurationFactory = new TestSyncConfigurationFactory();
+
+    @Rule
+    public RunInLooperThread looperThread = new RunInLooperThread();
+
+    @Rule
+    public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();
+
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    protected void prepareEnvironmentForTest() throws IOException {
+        // FIXME Trying to reset the device environment is crashing tests somehow
+        deleteRosFiles();
+        if (BaseRealm.applicationContext != null) {
+            // Realm was already initialized. Reset all internal state
+            // in order to be able fully re-initialize.
+
+            // This will set the 'm_metadata_manager' in 'sync_manager.cpp' to be 'null'
+            // causing the SyncUser to remain in memory.
+            // They're actually not persisted into disk.
+            // move this call to 'tearDown' to clean in-memory & on-disk users
+            // once https://github.com/realm/realm-object-store/issues/207 is resolved
+            SyncManager.reset();
+            BaseRealm.applicationContext = null; // Required for Realm.init() to work
+        }
+        Realm.init(InstrumentationRegistry.getContext());
+        originalLogLevel = RealmLog.getLevel();
+        RealmLog.setLevel(LogLevel.DEBUG);
+    }
+
+    /**
+     * Starts a new ROS instance that can be used for testing.
+     */
+    protected static void startSyncServer() {
+        SyncManager.Debug.skipOnlineChecking = true;
+        try {
+            HttpUtils.startSyncServer();
+        } catch (Exception e) {
+            throw new IllegalStateException(e);
+        }
+    }
+
+    /**
+     * Stops the ROS instance used for the test.
+     */
+    protected static void stopSyncServer() {
+        try {
+            HttpUtils.stopSyncServer();
+        } catch (Exception e) {
+            Log.e(HttpUtils.TAG, "Failed to stop Sync Server: " + Util.getStackTrace(e));
+        }
+    }
+
+    /**
+     * Tries to restore the environment as best as possible after a test.
+     */
+    protected void restoreEnvironmentAfterTest() {
+        // Block until all users are logged out
+        UserFactory.logoutAllUsers();
+
+        // Reset log level
+        RealmLog.setLevel(originalLogLevel);
+    }
+
+    // Cleanup filesystem to make sure nothing lives for the next test.
+    // Failing to do so might lead to DIVERGENT_HISTORY errors being thrown if Realms from
+    // previous tests are being accessed.
+    private static void deleteRosFiles() throws IOException {
+        File rosFiles = new File(InstrumentationRegistry.getContext().getFilesDir(),"realm-object-server");
+        deleteFile(rosFiles);
+    }
+
+    private static void deleteFile(File file) throws IOException {
+        if (file.isDirectory()) {
+            for (File c : file.listFiles()) {
+                deleteFile(c);
+            }
+        }
+        if (!file.delete()) {
+            throw new IllegalStateException("Failed to delete file or directory: " + file.getAbsolutePath());
+        }
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/IsolatedIntegrationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/IsolatedIntegrationTests.java
new file mode 100644
index 0000000000..e25225fbbe
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/IsolatedIntegrationTests.java
@@ -0,0 +1,42 @@
+package io.realm;
+
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+
+import java.io.IOException;
+
+
+/**
+ * Base class for integration tests where each test is run on a separate ROS instance.
+ * This adds quite a lot of overhead between each test, so only use this base class if absolutely needed.
+ * Otherwise use {@link IsolatedIntegrationTests}.
+ */
+public class IsolatedIntegrationTests extends BaseIntegrationTest {
+
+    @Before
+    public void setupTest() throws IOException {
+        startSyncServer();
+        prepareEnvironmentForTest();
+    }
+
+    @After
+    public void teardownTest() {
+        if (!looperThread.isRuleUsed() || looperThread.isTestComplete()) {
+            // Non-looper tests can reset here
+            restoreEnvironmentAfterTest();
+            stopSyncServer();
+        } else {
+            // Otherwise we need to wait for the test to complete
+            looperThread.runAfterTest(new Runnable() {
+                @Override
+                public void run() {
+                    restoreEnvironmentAfterTest();
+                    stopSyncServer();
+                }
+            });
+        }
+    }
+
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java
new file mode 100644
index 0000000000..dce05265a9
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/PermissionManagerTests.java
@@ -0,0 +1,1228 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.SystemClock;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+
+import io.realm.internal.OsRealmConfig;
+import io.realm.log.RealmLog;
+import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.UserFactory;
+import io.realm.permissions.AccessLevel;
+import io.realm.permissions.Permission;
+import io.realm.permissions.PermissionOffer;
+import io.realm.permissions.PermissionRequest;
+import io.realm.permissions.UserCondition;
+import io.realm.rule.RunTestInLooperThread;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class PermissionManagerTests extends StandardIntegrationTest {
+
+    private SyncUser user;
+
+    @Before
+    public void setUpTest() {
+        user = UserFactory.createUniqueUser();
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getPermissions_returnLoadedResults() {
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+        pm.getPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                assertTrue(permissions.isLoaded());
+                assertInitialPermissions(permissions);
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getPermissions_noLongerValidWhenPermissionManagerIsClosed() {
+        final PermissionManager pm = user.getPermissionManager();
+        pm.getPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                assertTrue(permissions.isValid());
+                pm.close();
+                assertFalse(permissions.isValid());
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                pm.close();
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    @Ignore
+    public void getPermissions_updatedWithNewRealms() {
+        final PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+        pm.getPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                assertTrue(permissions.isLoaded());
+                assertInitialPermissions(permissions);
+
+                // Create new Realm, which should create a new Permission entry
+                SyncConfiguration config2 = new SyncConfiguration.Builder(user, Constants.USER_REALM_2)
+                        .errorHandler(new SyncSession.ErrorHandler() {
+                            @Override
+                            public void onError(SyncSession session, ObjectServerError error) {
+                                fail(error.toString());
+                            }
+                        })
+                        .build();
+                final Realm secondRealm = Realm.getInstance(config2);
+                looperThread.closeAfterTest(secondRealm);
+                // Wait for the permission Result to report the new Realms
+                looperThread.keepStrongReference(permissions);
+                permissions.addChangeListener(new RealmChangeListener<RealmResults<Permission>>() {
+                    @Override
+                    public void onChange(RealmResults<Permission> permissions) {
+                        RealmLog.error(String.format("2ndCallback: Size: %s, Permissions: %s", permissions.size(), Arrays.toString(permissions.toArray())));
+                        Permission p = permissions.where().endsWith("path", "tests2").findFirst();
+                        if (p != null) {
+                            assertTrue(p.mayRead());
+                            assertTrue(p.mayWrite());
+                            assertTrue(p.mayManage());
+                            looperThread.testComplete();
+                        }
+                    }
+                });
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail("Could not open Realm: " + error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    @Ignore
+    public void getPermissions_updatedWithNewRealms_stressTest() {
+        final int TEST_SIZE = 10;
+        final PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+        pm.getPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                assertTrue(permissions.isLoaded());
+                assertInitialPermissions(permissions);
+
+                for (int i = 0; i < TEST_SIZE; i++) {
+                    SyncConfiguration configNew = new SyncConfiguration.Builder(user, "realm://" + Constants.HOST + "/~/test" + i).build();
+                    Realm newRealm = Realm.getInstance(configNew);
+                    looperThread.closeAfterTest(newRealm);
+                }
+
+                // Wait for the permission Result to report the new Realms
+                looperThread.keepStrongReference(permissions);
+                permissions.addChangeListener(new RealmChangeListener<RealmResults<Permission>>() {
+                    @Override
+                    public void onChange(RealmResults<Permission> permissions) {
+                        RealmLog.error(String.format("Size: %s, Permissions: %s", permissions.size(), Arrays.toString(permissions.toArray())));
+                        Permission p = permissions.where().endsWith("path", "test" + (TEST_SIZE - 1)).findFirst();
+                        if (p != null) {
+                            assertTrue(p.mayRead());
+                            assertTrue(p.mayWrite());
+                            assertTrue(p.mayManage());
+                            looperThread.testComplete();
+                        }
+                    }
+                });
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getPermissions_closed() throws IOException {
+        PermissionManager pm = user.getPermissionManager();
+        pm.close();
+
+        thrown.expect(IllegalStateException.class);
+        pm.getPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                fail();
+            }
+            @Override
+            public void onError(ObjectServerError error) { fail(); }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getPermissions_clientReset() {
+        final PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+        pm.getPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                // Simulate reset after first request succeeded to make sure that session is
+                // alive.
+                SyncManager.simulateClientReset(SyncManager.getSession(pm.permissionRealmConfig));
+                pm.getPermissions(new PermissionManager.PermissionsCallback() {
+                    @Override
+                    public void onSuccess(RealmResults<Permission> permissions) {
+                        fail();
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        assertEquals(ErrorCode.CLIENT_RESET, error.getErrorCode());
+                        looperThread.testComplete();
+                    }
+                });
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getPermissions_addTaskAfterClientReset() {
+        final PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+        pm.getPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                // Simulate reset after first request succeeded to make sure that session is
+                // alive.
+                SyncManager.simulateClientReset(SyncManager.getSession(pm.permissionRealmConfig));
+
+                // 1. Run task that fail
+                pm.getPermissions(new PermissionManager.PermissionsCallback() {
+                    @Override
+                    public void onSuccess(RealmResults<Permission> permissions) {
+                        fail();
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        assertEquals(ErrorCode.CLIENT_RESET, error.getErrorCode());
+                        // 2. Then try to add another
+                        pm.getDefaultPermissions(new PermissionManager.PermissionsCallback() {
+                            @Override
+                            public void onSuccess(RealmResults<Permission> permissions) {
+                                fail();
+                            }
+
+                            @Override
+                            public void onError(ObjectServerError error) {
+                                assertEquals(ErrorCode.CLIENT_RESET, error.getErrorCode());
+                                looperThread.testComplete();
+                            }
+                        });
+                    }
+                });
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Ignore("See https://github.com/realm/realm-java/issues/5143")
+    @Test
+    public void clientResetOnMultipleThreads() {
+
+        HandlerThread thread1 = new HandlerThread("handler1");
+        thread1.start();
+        Handler handler1 = new Handler(thread1.getLooper());
+
+        HandlerThread thread2 = new HandlerThread("handler2");
+        thread2.start();
+        Handler handler2 = new Handler(thread1.getLooper());
+
+        final AtomicReference<PermissionManager> pm1 = new AtomicReference<>(null);
+        final AtomicReference<PermissionManager> pm2 = new AtomicReference<>(null);
+
+        final CountDownLatch pmsOpened = new CountDownLatch(1);
+
+        // 1) Thread 1: Open PermissionManager and check permissions
+        handler1.post(new Runnable() {
+            @Override
+            public void run() {
+                PermissionManager pm = user.getPermissionManager();
+                pm1.set(pm);
+                pm.getPermissions(new PermissionManager.PermissionsCallback() {
+                    @Override
+                    public void onSuccess(RealmResults<Permission> permissions) {
+                        assertInitialPermissions(permissions);
+                        pmsOpened.countDown();
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        fail(error.toString());
+                    }
+                });
+            }
+        });
+
+        // 2) Thread 2: Open PermissionManager and check permissions
+        handler2.post(new Runnable() {
+            @Override
+            public void run() {
+                PermissionManager pm = user.getPermissionManager();
+                pm2.set(pm);
+                pm.getPermissions(new PermissionManager.PermissionsCallback() {
+                    @Override
+                    public void onSuccess(RealmResults<Permission> permissions) {
+                        assertInitialPermissions(permissions);
+                        pmsOpened.countDown();
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        fail(error.toString());
+                    }
+                });
+            }
+        });
+
+        TestHelper.awaitOrFail(pmsOpened);
+
+        // 3) Trigger Client Reset
+        SyncManager.simulateClientReset(SyncManager.getSession(pm1.get().permissionRealmConfig));
+        SyncManager.simulateClientReset(SyncManager.getSession(pm2.get().permissionRealmConfig));
+
+        // 4) Thread 1: Attempt to get permissions should trigger a Client Reset
+        final CountDownLatch clientResetThread1 = new CountDownLatch(1);
+        final CountDownLatch clientResetThread2 = new CountDownLatch(1);
+        handler1.post(new Runnable() {
+            @Override
+            public void run() {
+                final PermissionManager pm = pm1.get();
+                pm.getPermissions(new PermissionManager.PermissionsCallback() {
+                    @Override
+                    public void onSuccess(RealmResults<Permission> permissions) {
+                        fail("Client reset should have been triggered");
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        assertEquals(ErrorCode.CLIENT_RESET, error.getErrorCode());
+                        pm.close();
+                        assertFalse(new File(pm.permissionRealmConfig.getPath()).exists());
+                        clientResetThread1.countDown();
+                    }
+                });
+            }
+        });
+
+        // 5) Thread 2: Attempting to get permissions should also trigger a Client Reset even though
+        //    Thread 1 just executed it
+        TestHelper.awaitOrFail(clientResetThread1);
+        handler2.post(new Runnable() {
+            @Override
+            public void run() {
+                final PermissionManager pm = pm2.get();
+                pm.getPermissions(new PermissionManager.PermissionsCallback() {
+                    @Override
+                    public void onSuccess(RealmResults<Permission> permissions) {
+                        fail("Client reset should have been triggered");
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        assertEquals(ErrorCode.CLIENT_RESET, error.getErrorCode());
+                        pm.close();
+                        clientResetThread2.countDown();
+                    }
+                });
+            }
+        });
+        TestHelper.awaitOrFail(clientResetThread2);
+
+        // 6) After closing the PermissionManager, re-opening it again should work fine
+        final CountDownLatch newPmOpenedAndReady = new CountDownLatch(1);
+        handler1.post(new Runnable() {
+            @Override
+            public void run() {
+                final PermissionManager pm = user.getPermissionManager();
+                pm.getPermissions(new PermissionManager.PermissionsCallback() {
+                    @Override
+                    public void onSuccess(RealmResults<Permission> permissions) {
+                        assertInitialPermissions(permissions);
+                        pm.close();
+                        newPmOpenedAndReady.countDown();
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        fail(error.toString());
+                    }
+                });
+            }
+        });
+
+        TestHelper.awaitOrFail(newPmOpenedAndReady);
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getDefaultPermissions_returnLoadedResults() {
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+        pm.getDefaultPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                assertTrue(permissions.isLoaded());
+                assertInitialDefaultPermissions(permissions);
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getDefaultPermissions_noLongerValidWhenPermissionManagerIsClosed() {
+        final PermissionManager pm = user.getPermissionManager();
+        pm.getDefaultPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                try {
+                    assertTrue(permissions.isValid());
+                } finally {
+                    pm.close();
+                }
+                assertFalse(permissions.isValid());
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                pm.close();
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @Ignore("FIXME Add once `setPermissions` are implemented")
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getDefaultPermissions_updatedWithNewRealms() {
+
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getDefaultPermissions_closed() throws IOException {
+        PermissionManager pm = user.getPermissionManager();
+        pm.close();
+
+        thrown.expect(IllegalStateException.class);
+        pm.getDefaultPermissions(new PermissionManager.PermissionsCallback() {
+            @Override
+            public void onSuccess(RealmResults<Permission> permissions) {
+                fail();
+            }
+            @Override
+            public void onError(ObjectServerError error) { fail(); }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void permissionManagerAsyncTask_handlePermissionRealmError() throws NoSuchFieldException, IllegalAccessException {
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        // Simulate error in the permission Realm
+        Field permissionConfigField = pm.getClass().getDeclaredField("permissionRealmError");
+        permissionConfigField.setAccessible(true);
+        final ObjectServerError error = new ObjectServerError(ErrorCode.UNKNOWN, "Boom");
+        permissionConfigField.set(pm, error);
+
+        PermissionManager.ApplyPermissionsCallback callback = new PermissionManager.ApplyPermissionsCallback() {
+            @Override
+            public void onSuccess() {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertTrue(error.getErrorMessage().startsWith("Error occurred in Realm"));
+                assertTrue(error.getErrorMessage().contains("Permission Realm"));
+                assertEquals(ErrorCode.UNKNOWN, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        };
+
+        // Create dummy task that can trigger the error reporting
+        runTask(pm, callback);
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void permissionManagerAsyncTask_handleManagementRealmError() throws NoSuchFieldException, IllegalAccessException {
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        // Simulate error in the permission Realm
+        final ObjectServerError error = new ObjectServerError(ErrorCode.UNKNOWN, "Boom");
+        setRealmError(pm, "managementRealmError", error);
+
+        PermissionManager.ApplyPermissionsCallback callback = new PermissionManager.ApplyPermissionsCallback() {
+            @Override
+            public void onSuccess() {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertTrue(error.getErrorMessage().startsWith("Error occurred in Realm"));
+                assertTrue(error.getErrorMessage().contains("Management Realm"));
+                assertEquals(ErrorCode.UNKNOWN, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        };
+
+        // Create dummy task that can trigger the error reporting
+        runTask(pm, callback);
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void permissionManagerAsyncTask_handleTwoErrorsSameErrorCode() throws NoSuchFieldException, IllegalAccessException {
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        // Simulate error in the permission Realm
+        setRealmError(pm, "managementRealmError", new ObjectServerError(ErrorCode.CONNECTION_CLOSED, "Boom1"));
+
+        // Simulate error in the management Realm
+        setRealmError(pm, "permissionRealmError", new ObjectServerError(ErrorCode.CONNECTION_CLOSED, "Boom2"));
+
+        PermissionManager.ApplyPermissionsCallback callback = new PermissionManager.ApplyPermissionsCallback() {
+            @Override
+            public void onSuccess() {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.CONNECTION_CLOSED, error.getErrorCode());
+                assertTrue(error.toString().contains("Boom1"));
+                assertTrue(error.toString().contains("Boom2"));
+                looperThread.testComplete();
+            }
+        };
+
+        // Create dummy task that can trigger the error reporting
+        runTask(pm, callback);
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void permissionManagerAsyncTask_handleTwoErrorsDifferentErrorCode() throws NoSuchFieldException, IllegalAccessException {
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        // Simulate error in the permission Realm
+        setRealmError(pm, "managementRealmError", new ObjectServerError(ErrorCode.CONNECTION_CLOSED, "Boom1"));
+
+        // Simulate error in the management Realm
+        setRealmError(pm, "permissionRealmError", new ObjectServerError(ErrorCode.SESSION_CLOSED, "Boom2"));
+
+        PermissionManager.ApplyPermissionsCallback callback = new PermissionManager.ApplyPermissionsCallback() {
+            @Override
+            public void onSuccess() {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.UNKNOWN, error.getErrorCode());
+                assertTrue(error.toString().contains(ErrorCode.CONNECTION_CLOSED.toString()));
+                assertTrue(error.toString().contains(ErrorCode.SESSION_CLOSED.toString()));
+                looperThread.testComplete();
+            }
+        };
+
+        // Create dummy task that can trigger the error reporting
+        runTask(pm, callback);
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void applyPermissions_nonAdminUserFails() {
+        SyncUser user2 = UserFactory.createUniqueUser();
+        String otherUsersUrl = createRemoteRealm(user2, "test");
+
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        // Create request for setting permissions on another users Realm,
+        // i.e. user making the request do not have manage rights.
+        UserCondition condition = UserCondition.userId(user.getIdentity());
+        AccessLevel accessLevel = AccessLevel.WRITE;
+        PermissionRequest request = new PermissionRequest(condition, otherUsersUrl, accessLevel);
+
+        pm.applyPermissions(request, new PermissionManager.ApplyPermissionsCallback() {
+            @Override
+            public void onSuccess() {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.ACCESS_DENIED, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void applyPermissions_wrongUrlFails() {
+        String wrongUrl = createRemoteRealm(user, "test") + "-notexisting";
+
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        // Create request for setting permissions on another users Realm,
+        // i.e. user making the request do not have manage rights.
+        UserCondition condition = UserCondition.userId(user.getIdentity());
+        AccessLevel accessLevel = AccessLevel.WRITE;
+        PermissionRequest request = new PermissionRequest(condition, wrongUrl, accessLevel);
+
+        pm.applyPermissions(request, new PermissionManager.ApplyPermissionsCallback() {
+            @Override
+            public void onSuccess() {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                // FIXME: Should be 614, see https://github.com/realm/ros/issues/429
+                assertEquals(ErrorCode.INVALID_PARAMETERS, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void applyPermissions_withUserId() {
+        final SyncUser user2 = UserFactory.createUniqueUser();
+        String url = createRemoteRealm(user2, "test");
+        PermissionManager pm2 = user2.getPermissionManager();
+        looperThread.closeAfterTest(pm2);
+
+        // Create request for giving `user` WRITE permissions to `user2`'s Realm.
+        UserCondition condition = UserCondition.userId(user.getIdentity());
+        AccessLevel accessLevel = AccessLevel.WRITE;
+        PermissionRequest request = new PermissionRequest(condition, url, accessLevel);
+
+        pm2.applyPermissions(request, new PermissionManager.ApplyPermissionsCallback() {
+            @Override
+            public void onSuccess() {
+                PermissionManager pm = user.getPermissionManager();
+                looperThread.closeAfterTest(pm);
+                pm.getPermissions(new PermissionManager.PermissionsCallback() {
+                    @Override
+                    public void onSuccess(RealmResults<Permission> permissions) {
+                        assertPermissionPresent(permissions, user, "/test", AccessLevel.WRITE);
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        fail(error.toString());
+                    }
+                });
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void applyPermissions_withUsername() {
+        String user1Username = TestHelper.getRandomEmail();
+        String user2Username = TestHelper.getRandomEmail();
+        final SyncUser user1 = UserFactory.createUser(user1Username);
+        final SyncUser user2 = UserFactory.createUser(user2Username);
+        PermissionManager pm1 = user1.getPermissionManager();
+        looperThread.closeAfterTest(pm1);
+
+        // Create request for giving `user2` WRITE permissions to `user1`'s Realm.
+        UserCondition condition = UserCondition.username(user2Username);
+        AccessLevel accessLevel = AccessLevel.WRITE;
+        String url = createRemoteRealm(user1, "test");
+        PermissionRequest request = new PermissionRequest(condition, url, accessLevel);
+
+        pm1.applyPermissions(request, new PermissionManager.ApplyPermissionsCallback() {
+            @Override
+            public void onSuccess() {
+                PermissionManager pm2 = user2.getPermissionManager();
+                looperThread.closeAfterTest(pm2);
+                pm2.getPermissions(new PermissionManager.PermissionsCallback() {
+                    @Override
+                    public void onSuccess(RealmResults<Permission> permissions) {
+                        assertPermissionPresent(permissions, user2, user1.getIdentity() + "/test", AccessLevel.WRITE);
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        fail(error.toString());
+                    }
+                });
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void applyPermissions_usersWithNoExistingPermissions() {
+        final SyncUser user1 = UserFactory.createUser("user1@realm.io");
+        final SyncUser user2 = UserFactory.createUser("user2@realm.io");
+        PermissionManager pm1 = user1.getPermissionManager();
+        looperThread.closeAfterTest(pm1);
+
+        // Create request for giving all users with no existing permissions WRITE permissions to `user1`'s Realm.
+        UserCondition condition = UserCondition.noExistingPermissions();
+        AccessLevel accessLevel = AccessLevel.WRITE;
+        final String url = createRemoteRealm(user1, "test");
+        PermissionRequest request = new PermissionRequest(condition, url, accessLevel);
+
+        pm1.applyPermissions(request, new PermissionManager.ApplyPermissionsCallback() {
+            @Override
+            public void onSuccess() {
+                // Default permissions are not recorded in the __permission Realm for user2
+                // Only way to check is by opening the Realm.
+                SyncConfiguration config = new SyncConfiguration.Builder(user2, url)
+                        .waitForInitialRemoteData()
+                        .errorHandler(new SyncSession.ErrorHandler() {
+                            @Override
+                            public void onError(SyncSession session, ObjectServerError error) {
+                                fail(error.toString());
+                            }
+                        })
+                        .build();
+
+                RealmAsyncTask task = Realm.getInstanceAsync(config, new Realm.Callback() {
+                    @Override
+                    public void onSuccess(Realm realm) {
+                        realm.close();
+                        looperThread.testComplete();
+                    }
+
+                    @Override
+                    public void onError(Throwable exception) {
+                        fail(exception.toString());
+                    }
+                });
+                looperThread.keepStrongReference(task);
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void makeOffer() {
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+        String url = createRemoteRealm(user, "test");
+
+        PermissionOffer offer = new PermissionOffer(url, AccessLevel.WRITE);
+        pm.makeOffer(offer, new PermissionManager.MakeOfferCallback() {
+            @Override
+            public void onSuccess(String offerToken) {
+                assertNotNull(offerToken);
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void makeOffer_noManageAccessThrows() {
+        // User 2 creates a Realm
+        SyncUser user2 = UserFactory.createUniqueUser();
+        String url = createRemoteRealm(user2, "test");
+
+        // User 1 tries to create an offer for it.
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        PermissionOffer offer = new PermissionOffer(url, AccessLevel.WRITE);
+        pm.makeOffer(offer, new PermissionManager.MakeOfferCallback() {
+            @Override
+            public void onSuccess(String offerToken) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.ACCESS_DENIED, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void acceptOffer() {
+        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, null);
+
+        final SyncUser user2 = UserFactory.createUniqueUser();
+        final PermissionManager pm = user2.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        pm.acceptOffer(offerToken, new PermissionManager.AcceptOfferCallback() {
+            @Override
+            public void onSuccess(String url, Permission permission) {
+                assertEquals("/" + user.getIdentity() + "/test", permission.getPath());
+                assertTrue(permission.mayRead());
+                assertTrue(permission.mayWrite());
+                assertFalse(permission.mayManage());
+                assertEquals(user2.getIdentity(), permission.getUserId());
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void acceptOffer_invalidToken() {
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+        pm.acceptOffer("wrong-token", new PermissionManager.AcceptOfferCallback() {
+            @Override
+            public void onSuccess(String url, Permission permission) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.INVALID_PARAMETERS, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    @Ignore
+    public void acceptOffer_expiredThrows() {
+        // Trying to guess how long CI is to process this. The offer cannot be created if it
+        // already expired.
+        long delayMillis = TimeUnit.SECONDS.toMillis(10);
+        Date expiresAt = new Date(new Date().getTime() + delayMillis);
+        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, expiresAt);
+        SystemClock.sleep(delayMillis); // Make sure that the offer expires.
+        final SyncUser user2 = UserFactory.createUniqueUser();
+        final PermissionManager pm = user2.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        pm.acceptOffer(offerToken, new PermissionManager.AcceptOfferCallback() {
+            @Override
+            public void onSuccess(String url, Permission permission) {
+                fail();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                assertEquals(ErrorCode.EXPIRED_PERMISSION_OFFER, error.getErrorCode());
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void acceptOffer_multipleUsers() {
+        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, null);
+
+        final SyncUser user2 = UserFactory.createUniqueUser();
+        final SyncUser user3 = UserFactory.createUniqueUser();
+        final PermissionManager pm2 = user2.getPermissionManager();
+        final PermissionManager pm3 = user3.getPermissionManager();
+        looperThread.closeAfterTest(pm2);
+        looperThread.closeAfterTest(pm3);
+
+        final AtomicInteger offersAccepted = new AtomicInteger(0);
+        PermissionManager.AcceptOfferCallback callback = new PermissionManager.AcceptOfferCallback() {
+            @Override
+            public void onSuccess(String url, Permission permission) {
+                assertEquals("/" + user.getIdentity() + "/test", permission.getPath());
+                assertTrue(permission.mayRead());
+                assertTrue(permission.mayWrite());
+                assertFalse(permission.mayManage());
+                if (offersAccepted.incrementAndGet() == 2) {
+                    looperThread.testComplete();
+                }
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        };
+
+        pm2.acceptOffer(offerToken, callback);
+        pm3.acceptOffer(offerToken, callback);
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void getCreatedOffers() {
+        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, null);
+        PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        pm.getCreatedOffers(new PermissionManager.OffersCallback() {
+            @Override
+            public void onSuccess(RealmResults<PermissionOffer> offers) {
+                RealmResults filteredOffers = offers.where()
+                        .equalTo("token", offerToken)
+                        .findAllAsync();
+                looperThread.keepStrongReference(offers);
+                filteredOffers.addChangeListener(new RealmChangeListener<RealmResults>() {
+                    @Override
+                    public void onChange(RealmResults results) {
+                        switch (results.size()) {
+                            case 0: return;
+                            case 1:
+                                looperThread.testComplete();
+                                break;
+                            default:
+                                fail("To many offers: " + Arrays.toString(results.toArray()));
+                        }
+                    }
+                });
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void revokeOffer() {
+        // createOffer validates that the offer is actually in the __management Realm.
+        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, null);
+        final PermissionManager pm = user.getPermissionManager();
+        looperThread.closeAfterTest(pm);
+
+        pm.revokeOffer(offerToken, new PermissionManager.RevokeOfferCallback() {
+            @Override
+            public void onSuccess() {
+                pm.getCreatedOffers(new PermissionManager.OffersCallback() {
+                    @Override
+                    public void onSuccess(RealmResults<PermissionOffer> offers) {
+                        assertEquals(0, offers.size());
+                        looperThread.testComplete();
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        fail(error.toString());
+                    }
+                });
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    public void revokeOffer_afterOneAcceptEdit() {
+        // createOffer validates that the offer is actually in the __management Realm.
+        final String offerToken = createOffer(user, "test", AccessLevel.WRITE, null);
+
+        SyncUser user2 = UserFactory.createUniqueUser();
+        SyncUser user3 = UserFactory.createUniqueUser();
+        final PermissionManager pm1 = user.getPermissionManager();
+        PermissionManager pm2 = user2.getPermissionManager();
+        final PermissionManager pm3 = user3.getPermissionManager();
+        looperThread.closeAfterTest(pm1);
+        looperThread.closeAfterTest(pm2);
+        looperThread.closeAfterTest(pm3);
+
+        pm2.acceptOffer(offerToken, new PermissionManager.AcceptOfferCallback() {
+            @Override
+            public void onSuccess(String realmUrl, Permission permission) {
+                pm1.revokeOffer(offerToken, new PermissionManager.RevokeOfferCallback() {
+                    @Override
+                    public void onSuccess() {
+                        pm3.acceptOffer(offerToken, new PermissionManager.AcceptOfferCallback() {
+                            @Override
+                            public void onSuccess(String realmUrl, Permission permission) {
+                                fail("Offer should have been revoked");
+                            }
+
+                            @Override
+                            public void onError(ObjectServerError error) {
+                                assertEquals(ErrorCode.INVALID_PARAMETERS, error.getErrorCode());
+                                looperThread.testComplete();
+                            }
+                        });
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        fail(error.toString());
+                    }
+                });
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread(emulateMainThread = true)
+    @Ignore("Figure out why clocks on server/emulator on CI seem to differ")
+    public void revokeOffer_alreadyExpired() {
+        fail("Implement this");
+    }
+
+    /**
+     * Creates a offer for a newly created Realm.
+     *
+     * @param user User that should create the offer
+     * @param realmName Realm to create
+     * @param level accessLevel to offer
+     * @param expires when the offer expires
+     */
+    private String createOffer(final SyncUser user, final String realmName, final AccessLevel level, final Date expires) {
+        final CountDownLatch offerReady = new CountDownLatch(1);
+        final AtomicReference<String> offer = new AtomicReference<>(null);
+        final HandlerThread ht = new HandlerThread("OfferThread");
+        ht.start();
+        Handler handler = new Handler(ht.getLooper());
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                String url = createRemoteRealm(user, realmName);
+                final PermissionManager pm = user.getPermissionManager();
+                pm.makeOffer(new PermissionOffer(url, level, expires), new PermissionManager.MakeOfferCallback() {
+                    @Override
+                    public void onSuccess(String offerToken) {
+                        offer.set(offerToken);
+                        pm.close();
+                        offerReady.countDown();
+                    }
+
+                    @Override
+                    public void onError(ObjectServerError error) {
+                        pm.close();
+                        fail(error.toString());
+                    }
+                });
+            }
+        });
+        TestHelper.awaitOrFail(offerReady);
+        ht.quit();
+        return offer.get();
+    }
+
+    /**
+     * Wait for a given permission to be present.
+     *
+     * @param permissions permission results.
+     * @param user user that is being granted the permission.
+     * @param urlSuffix the url suffix to listen for.
+     * @param accessLevel the expected access level for 'user'.
+     */
+    private void assertPermissionPresent(RealmResults<Permission> permissions, final SyncUser user, String urlSuffix, final AccessLevel accessLevel) {
+        RealmResults<Permission> filteredPermissions = permissions.where().endsWith("path", urlSuffix).findAllAsync();
+        looperThread.keepStrongReference(permissions);
+        filteredPermissions.addChangeListener(new RealmChangeListener<RealmResults<Permission>>() {
+            @Override
+            public void onChange(RealmResults<Permission> permissions) {
+                switch(permissions.size()) {
+                    case 0: return;
+                    case 1:
+                        Permission p = permissions.first();
+                        assertEquals(accessLevel.mayRead(), p.mayRead());
+                        assertEquals(accessLevel.mayWrite(), p.mayWrite());
+                        assertEquals(accessLevel.mayManage(), p.mayManage());
+                        assertEquals(user.getIdentity(), p.getUserId());
+                        looperThread.testComplete();
+                        break;
+                    default:
+                        fail("To many permissions matched: " + Arrays.toString(permissions.toArray()));
+                }
+            }
+        });
+    }
+
+    private void setRealmError(PermissionManager pm, String fieldName, ObjectServerError error) throws NoSuchFieldException,
+            IllegalAccessException {
+        Field managementRealmErrorField = pm.getClass().getDeclaredField(fieldName);
+        managementRealmErrorField.setAccessible(true);
+        managementRealmErrorField.set(pm, error);
+    }
+
+    private void runTask(final PermissionManager pm, final PermissionManager.ApplyPermissionsCallback callback) {
+        new PermissionManager.PermissionManagerTask<Void>(pm, callback) {
+            @Override
+            public void run() {
+                if (!checkAndReportInvalidState()) {
+                    fail();
+                }
+            }
+        }.run();
+    }
+
+    /**
+     * Creates an empty remote Realm on ROS owned by the provided user
+     */
+    private String createRemoteRealm(SyncUser user, String realmName) {
+        String url = Constants.AUTH_SERVER_URL + "~/" + realmName;
+        SyncConfiguration config = new SyncConfiguration.Builder(user, url)
+                .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
+                .build();
+
+        Realm realm = Realm.getInstance(config);
+        SyncSession session = SyncManager.getSession(config);
+        final CountDownLatch uploadLatch = new CountDownLatch(1);
+        session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    uploadLatch.countDown();
+                }
+            }
+        });
+        TestHelper.awaitOrFail(uploadLatch);
+        realm.close();
+        return config.getServerUrl().toString();
+    }
+
+    /**
+     * The initial set of permissions of ROS is timing dependant. This method will identify the possible known starting
+     * states and fail if neither of these can be verified.
+     */
+    private void assertInitialPermissions(RealmResults<Permission> permissions) {
+        assertGreaterThan("Unexpected count() for __permission Realm: " + Arrays.toString(permissions.toArray()), 0, permissions.where().endsWith("path", "__permission").count());
+        assertGreaterThan("Unexpected count() for __management Realm: " + Arrays.toString(permissions.toArray()), 0, permissions.where().endsWith("path", "__management").count());
+        // FIXME: Enable these again when https://github.com/realm/ros/issues/549 is fixed
+        // assertEquals("Unexpected count() for __permission Realm: " + Arrays.toString(permissions.toArray()), 1, permissions.where().endsWith("path", "__permission").count());
+        // assertEquals("Unexpected count() for __management Realm: " + Arrays.toString(permissions.toArray()), 1, permissions.where().endsWith("path", "__management").count());
+    }
+
+    private void assertInitialDefaultPermissions(RealmResults<Permission> permissions) {
+        assertGreaterThan("Unexpected count() for __wildcardpermissions Realm: " + Arrays.toString(permissions.toArray()), 0, permissions.where().endsWith("path", "__wildcardpermissions").count());
+
+        // FIXME: Enable these again when https://github.com/realm/ros/issues/549 is fixed
+        // assertEquals("Unexpected count() for __wildcardpermissions Realm: " + Arrays.toString(permissions.toArray()), 1, permissions.where().endsWith("path", "__wildcardpermissions").count());
+    }
+
+    private void assertGreaterThan(String error, int base, long count) {
+        if (count <= base) {
+            throw new AssertionError(error);
+        }
+    }
+
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
new file mode 100644
index 0000000000..ab943c1e3c
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SSLConfigurationTests.java
@@ -0,0 +1,204 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.os.SystemClock;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.Timeout;
+import org.junit.runner.RunWith;
+
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+
+import io.realm.entities.StringOnly;
+import io.realm.exceptions.RealmFileException;
+import io.realm.log.LogLevel;
+import io.realm.log.RealmLog;
+import io.realm.objectserver.utils.Constants;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class SSLConfigurationTests extends StandardIntegrationTest {
+
+    @Rule
+    public Timeout globalTimeout = Timeout.seconds(10);
+
+    @Test
+    public void trustedRootCA() throws InterruptedException {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+
+        // 1. Copy a valid Realm to the server
+        final SyncConfiguration configOld = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .schema(StringOnly.class)
+                .build();
+        Realm realm = Realm.getInstance(configOld);
+
+        realm.beginTransaction();
+        realm.createObject(StringOnly.class).setChars("Foo");
+        realm.commitTransaction();
+
+        // make sure the changes gets to the server
+        SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));  // FIXME: Replace with Sync Progress Notifications once available.
+        realm.close();
+        user.logout();
+
+        // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
+        // download the uploaded changes.
+        user = SyncUser.login(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
+        SyncConfiguration config = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
+                .name("useSsl")
+                .schema(StringOnly.class)
+                .waitForInitialRemoteData()
+                .trustedRootCA("trusted_ca.pem")
+                .build();
+        realm = Realm.getInstance(config);
+
+        RealmResults<StringOnly> all = realm.where(StringOnly.class).findAll();
+        try {
+            assertEquals(1, all.size());
+            assertEquals("Foo", all.get(0).getChars());
+        } finally {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void withoutSSLVerification() throws InterruptedException {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+
+        // 1. Copy a valid Realm to the server
+        final SyncConfiguration configOld = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .schema(StringOnly.class)
+                .build();
+        Realm realm = Realm.getInstance(configOld);
+
+        realm.beginTransaction();
+        realm.createObject(StringOnly.class).setChars("Foo");
+        realm.commitTransaction();
+
+        // make sure the changes gets to the server
+        SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));  // FIXME: Replace with Sync Progress Notifications once available.
+        realm.close();
+        user.logout();
+
+        // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
+        // download the uploaded changes.
+        user = SyncUser.login(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
+        SyncConfiguration config = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
+                .name("useSsl")
+                .schema(StringOnly.class)
+                .waitForInitialRemoteData()
+                .disableSSLVerification()
+                .build();
+        realm = Realm.getInstance(config);
+
+        RealmResults<StringOnly> all = realm.where(StringOnly.class).findAll();
+        try {
+            assertEquals(1, all.size());
+            assertEquals("Foo", all.get(0).getChars());
+        } finally {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void trustedRootCA_syncShouldFailWithoutTrustedCA() throws InterruptedException {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+
+        // 1. Copy a valid Realm to the server
+        final SyncConfiguration configOld = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .schema(StringOnly.class)
+                .build();
+        Realm realm = Realm.getInstance(configOld);
+
+        realm.beginTransaction();
+        realm.createObject(StringOnly.class).setChars("Foo");
+        realm.commitTransaction();
+
+        // make sure the changes gets to the server
+        SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));  // FIXME: Replace with Sync Progress Notifications once available.
+        realm.close();
+        user.logout();
+
+        // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
+        // download the uploaded changes.
+        user = SyncUser.login(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
+        SyncConfiguration config = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
+                .name("useSsl")
+                .schema(StringOnly.class)
+                .build();
+        realm = Realm.getInstance(config);
+        try {
+            assertTrue(realm.isEmpty());
+        } finally {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void combining_trustedRootCA_and_withoutSSLVerification_willThrow() {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+
+        TestHelper.TestLogger testLogger = new TestHelper.TestLogger();
+        int originalLevel = RealmLog.getLevel();
+        RealmLog.add(testLogger);
+        RealmLog.setLevel(LogLevel.WARN);
+
+        configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
+                .schema(StringOnly.class)
+                .trustedRootCA("trusted_ca.pem")
+                .disableSSLVerification()
+                .build();
+
+        assertEquals("SSL Verification is disabled, the provided server certificate will not be used.",
+                testLogger.message);
+        RealmLog.remove(testLogger);
+        RealmLog.setLevel(originalLevel);
+    }
+
+    @Test
+    public void trustedRootCA_notExisting_certificate_willThrow() {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+        SyncConfiguration config = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM_SECURE)
+                .schema(StringOnly.class)
+                .trustedRootCA("not_existing_file.pem")
+                .build();
+
+        try {
+            Realm.getInstance(config);
+            fail();
+        } catch (RealmFileException ignored) {
+        }
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/StandardIntegrationTest.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/StandardIntegrationTest.java
new file mode 100644
index 0000000000..e2b7bb9513
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/StandardIntegrationTest.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+
+import java.io.IOException;
+
+
+/**
+ * The standard base class for integration tests.
+ * This class will keep a ROS instance running for all tests to minimize the overhead between each test.
+ */
+public abstract class StandardIntegrationTest extends BaseIntegrationTest {
+
+    @BeforeClass
+    public static void setupTestClass() throws Exception {
+        startSyncServer();
+    }
+
+    @AfterClass
+    public static void tearDownTestClass() throws Exception {
+        stopSyncServer();
+    }
+
+    @Before
+    public void setupTest() throws IOException {
+        prepareEnvironmentForTest();
+    }
+
+    @After
+    public void teardownTest() {
+        if (!looperThread.isRuleUsed() || looperThread.isTestComplete()) {
+            // Non-looper tests can reset here
+            restoreEnvironmentAfterTest();
+        } else {
+            // Otherwise we need to wait for the test to complete
+            looperThread.runAfterTest(new Runnable() {
+                @Override
+                public void run() {
+                    restoreEnvironmentAfterTest();
+                }
+            });
+        }
+    }
+
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
new file mode 100644
index 0000000000..7fce3b7a02
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
@@ -0,0 +1,503 @@
+package io.realm;
+
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.SystemClock;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Assert;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Arrays;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import io.realm.entities.AllTypes;
+import io.realm.entities.StringOnly;
+import io.realm.internal.OsRealmConfig;
+import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.StringOnlyModule;
+import io.realm.objectserver.utils.UserFactory;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.util.SyncTestUtils;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class SyncSessionTests extends StandardIntegrationTest {
+    @Rule
+    public TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
+
+    @Test(timeout=3000)
+    public void getState_active() {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        SyncConfiguration syncConfiguration = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .build();
+        Realm realm = Realm.getInstance(syncConfiguration);
+
+        SyncSession session = SyncManager.getSession(syncConfiguration);
+
+        // make sure the `access_token` is acquired. otherwise we can still be
+        // in WAITING_FOR_ACCESS_TOKEN state
+        while(session.getState() != SyncSession.State.ACTIVE) {
+            SystemClock.sleep(200);
+        }
+
+        realm.close();
+    }
+
+    @Test
+    public void getState_throwOnClosedSession() {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        SyncConfiguration syncConfiguration = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .build();
+        Realm realm = Realm.getInstance(syncConfiguration);
+
+        SyncSession session = SyncManager.getSession(syncConfiguration);
+        realm.close();
+        user.logout();
+        thrown.expect(IllegalStateException.class);
+        thrown.expectMessage("Could not find session, Realm was probably closed");
+        session.getState();
+    }
+
+    @Test
+    public void getState_loggedOut() {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        SyncConfiguration syncConfiguration = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .build();
+        Realm realm = Realm.getInstance(syncConfiguration);
+
+        SyncSession session = SyncManager.getSession(syncConfiguration);
+
+        user.logout();
+
+        SyncSession.State state = session.getState();
+        assertEquals(SyncSession.State.INACTIVE, state);
+
+        realm.close();
+    }
+
+    @Test
+    public void uploadDownloadAllChanges() throws InterruptedException {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+        SyncConfiguration userConfig = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .build();
+        SyncConfiguration adminConfig = configFactory
+                .createSyncConfigurationBuilder(adminUser, userConfig.getServerUrl().toString())
+                .build();
+
+        Realm userRealm = Realm.getInstance(userConfig);
+        userRealm.beginTransaction();
+        userRealm.createObject(AllTypes.class);
+        userRealm.commitTransaction();
+        SyncManager.getSession(userConfig).uploadAllLocalChanges();
+        userRealm.close();
+
+        Realm adminRealm = Realm.getInstance(adminConfig);
+        SyncManager.getSession(adminConfig).downloadAllServerChanges();
+        adminRealm.refresh();
+        assertEquals(1, adminRealm.where(AllTypes.class).count());
+        adminRealm.close();
+    }
+
+    @Test
+    @Ignore()
+    public void interruptWaits() throws InterruptedException {
+        final SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+        final SyncConfiguration userConfig = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .build();
+        final SyncConfiguration adminConfig = configFactory
+                .createSyncConfigurationBuilder(adminUser, userConfig.getServerUrl().toString())
+                .build();
+
+        Thread t = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm userRealm = Realm.getInstance(userConfig);
+                userRealm.beginTransaction();
+                userRealm.createObject(AllTypes.class);
+                userRealm.commitTransaction();
+                SyncSession userSession = SyncManager.getSession(userConfig);
+                try {
+                    // 1. Start download (which will be interrupted)
+                    Thread.currentThread().interrupt();
+                    userSession.downloadAllServerChanges();
+                } catch (InterruptedException ignored) {
+                    assertFalse(Thread.currentThread().isInterrupted());
+                }
+                try {
+                    // 2. Upload all changes
+                    userSession.uploadAllLocalChanges();
+                } catch (InterruptedException e) {
+                    fail("Upload interrupted");
+                }
+                userRealm.close();
+
+                Realm adminRealm = Realm.getInstance(adminConfig);
+                SyncSession adminSession = SyncManager.getSession(adminConfig);
+                try {
+                    // 3. Start upload (which will be interrupted)
+                    Thread.currentThread().interrupt();
+                    adminSession.uploadAllLocalChanges();
+                } catch (InterruptedException ignored) {
+                    assertFalse(Thread.currentThread().isInterrupted()); // clear interrupted flag
+                }
+                try {
+                    // 4. Download all changes
+                    adminSession.downloadAllServerChanges();
+                } catch (InterruptedException e) {
+                    fail("Download interrupted");
+                }
+                adminRealm.refresh();
+                assertEquals(1, adminRealm.where(AllTypes.class).count());
+                adminRealm.close();
+            }
+        });
+        t.start();
+        t.join();
+    }
+
+    // check that logging out a SyncUser used by different Realm will
+    // affect all associated sessions.
+    @Test(timeout=5000)
+    public void logout_sameSyncUserMultipleSessions() {
+        String uniqueName = UUID.randomUUID().toString();
+        SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
+        SyncUser user =  SyncUser.login(credentials, Constants.AUTH_URL);
+
+        SyncConfiguration syncConfiguration1 = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .build();
+        Realm realm1 = Realm.getInstance(syncConfiguration1);
+
+        SyncConfiguration syncConfiguration2 = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL_2)
+                .build();
+        Realm realm2 = Realm.getInstance(syncConfiguration2);
+
+        SyncSession session1 = SyncManager.getSession(syncConfiguration1);
+        SyncSession session2 = SyncManager.getSession(syncConfiguration2);
+
+        // make sure the `access_token` is acquired. otherwise we can still be
+        // in WAITING_FOR_ACCESS_TOKEN state
+        while(session1.getState() != SyncSession.State.ACTIVE || session2.getState() != SyncSession.State.ACTIVE) {
+            SystemClock.sleep(200);
+        }
+        assertEquals(SyncSession.State.ACTIVE, session1.getState());
+        assertEquals(SyncSession.State.ACTIVE, session2.getState());
+        assertNotEquals(session1, session2);
+
+        assertEquals(session1.getUser(), session2.getUser());
+
+        user.logout();
+
+        assertEquals(SyncSession.State.INACTIVE, session1.getState());
+        assertEquals(SyncSession.State.INACTIVE, session2.getState());
+
+        credentials = SyncCredentials.usernamePassword(uniqueName, "password", false);
+        SyncUser.login(credentials, Constants.AUTH_URL);
+
+        // reviving the sessions. The state could be changed concurrently.
+        assertTrue(session1.getState() == SyncSession.State.WAITING_FOR_ACCESS_TOKEN ||
+                session1.getState() == SyncSession.State.ACTIVE);
+        assertTrue(session2.getState() == SyncSession.State.WAITING_FOR_ACCESS_TOKEN ||
+                session2.getState() == SyncSession.State.ACTIVE);
+
+        realm1.close();
+        realm2.close();
+    }
+
+    // A Realm that was opened before a user logged out should be able to resume uploading if the user logs back in.
+    @Test
+    public void logBackResumeUpload() throws InterruptedException, NoSuchFieldException, IllegalAccessException {
+        final String uniqueName = UUID.randomUUID().toString();
+        SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+
+        final SyncConfiguration syncConfiguration = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .modules(new StringOnlyModule())
+                .waitForInitialRemoteData()
+                .build();
+        final Realm realm = Realm.getInstance(syncConfiguration);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(StringOnly.class).setChars("1");
+            }
+        });
+
+        final SyncSession session = SyncManager.getSession(syncConfiguration);
+        session.uploadAllLocalChanges();
+
+        user.logout();
+
+        // add a commit while we're still offline
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(StringOnly.class).setChars("2");
+            }
+        });
+
+        final CountDownLatch testCompleted = new CountDownLatch(1);
+
+        final HandlerThread handlerThread = new HandlerThread("HandlerThread");
+        handlerThread.start();
+        Looper looper = handlerThread.getLooper();
+        Handler handler = new Handler(looper);
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                // access the Realm from an different path on the device (using admin user), then monitor
+                // when the offline commits get synchronized
+                SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
+                SyncCredentials credentialsAdmin = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(admin).value(), "custom-admin-user");
+                SyncUser adminUser = SyncUser.login(credentialsAdmin, Constants.AUTH_URL);
+
+                SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, syncConfiguration.getServerUrl().toString())
+                        .modules(new StringOnlyModule())
+                        .waitForInitialRemoteData()
+                        .build();
+                final Realm adminRealm = Realm.getInstance(adminConfig);
+
+                RealmResults<StringOnly> all = adminRealm.where(StringOnly.class).findAllSorted(StringOnly.FIELD_CHARS);
+                RealmChangeListener<RealmResults<StringOnly>> realmChangeListener = new RealmChangeListener<RealmResults<StringOnly>>() {
+                    @Override
+                    public void onChange(RealmResults<StringOnly> stringOnlies) {
+                        if (stringOnlies.size() == 2) {
+                            Assert.assertEquals("1", stringOnlies.get(0).getChars());
+                            Assert.assertEquals("2", stringOnlies.get(1).getChars());
+                            adminRealm.close();
+                            testCompleted.countDown();
+                            handlerThread.quit();
+                        }
+                    }
+                };
+                all.addChangeListener(realmChangeListener);
+
+                // login again to re-activate the user
+                SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", false);
+                // this login will re-activate the logged out user, and resume all it's pending sessions
+                // the OS will trigger bindSessionWithConfig with the new refresh_token, in order to obtain
+                // a new access_token.
+                SyncUser.login(credentials, Constants.AUTH_URL);
+            }
+        });
+
+        TestHelper.awaitOrFail(testCompleted, 60);
+        realm.close();
+    }
+
+    // A Realm that was opened before a user logged out should be able to resume uploading if the user logs back in.
+    // this test validate the behaviour of SyncSessionStopPolicy::AfterChangesUploaded
+    @Test
+    @Ignore()
+    public void uploadChangesWhenRealmOutOfScope() throws InterruptedException {
+        final String uniqueName = UUID.randomUUID().toString();
+        SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+
+        final char[] chars = new char[1_000_000];// 2MB
+        Arrays.fill(chars, '.');
+        final String twoMBString = new String(chars);
+
+        final SyncConfiguration syncConfiguration = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.AFTER_CHANGES_UPLOADED)
+                .modules(new StringOnlyModule())
+                .build();
+        Realm realm = Realm.getInstance(syncConfiguration);
+
+        realm.beginTransaction();
+        // upload 50MB
+        for (int i = 0; i < 25; i++) {
+            realm.createObject(StringOnly.class).setChars(twoMBString);
+        }
+        realm.commitTransaction();
+        realm.close();
+
+        final CountDownLatch testCompleted = new CountDownLatch(1);
+
+        final HandlerThread handlerThread = new HandlerThread("HandlerThread");
+        handlerThread.start();
+        Looper looper = handlerThread.getLooper();
+        Handler handler = new Handler(looper);
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                // using an admin user to open the Realm on different path on the device to monitor when all the uploads are done
+                SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
+                SyncCredentials credentialsAdmin = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(admin).value(), "custom-admin-user");
+                SyncUser adminUser = SyncUser.login(credentialsAdmin, Constants.AUTH_URL);
+
+                SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, syncConfiguration.getServerUrl().toString())
+                        .modules(new StringOnlyModule())
+                        .build();
+                final Realm adminRealm = Realm.getInstance(adminConfig);
+                RealmResults<StringOnly> all = adminRealm.where(StringOnly.class).findAll();
+                RealmChangeListener<RealmResults<StringOnly>> realmChangeListener = new RealmChangeListener<RealmResults<StringOnly>>() {
+                    @Override
+                    public void onChange(RealmResults<StringOnly> stringOnlies) {
+                        if (stringOnlies.size() == 25) {
+                            for (int i = 0; i < 25; i++) {
+                                assertEquals(1_000_000, stringOnlies.get(i).getChars().length());
+                            }
+                            adminRealm.close();
+                            testCompleted.countDown();
+                            handlerThread.quit();
+                        }
+                    }
+                };
+                all.addChangeListener(realmChangeListener);
+            }
+        });
+
+        TestHelper.awaitOrFail(testCompleted, 60);
+
+        user.logout();
+        realm.close();
+    }
+
+    // A Realm that was opened before a user logged out should be able to resume downloading if the user logs back in.
+    @Test
+    public void downloadChangesWhenRealmOutOfScope() throws InterruptedException {
+        final String uniqueName = UUID.randomUUID().toString();
+        SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+
+        final SyncConfiguration syncConfiguration = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .modules(new StringOnlyModule())
+                .build();
+        Realm realm = Realm.getInstance(syncConfiguration);
+
+        realm.beginTransaction();
+        realm.createObject(StringOnly.class).setChars("1");
+        realm.commitTransaction();
+
+        SyncSession session = SyncManager.getSession(syncConfiguration);
+        session.uploadAllLocalChanges();
+
+        // Log out the user.
+        user.logout();
+
+        // Log the user back in.
+        credentials = SyncCredentials.usernamePassword(uniqueName, "password", false);
+        SyncUser.login(credentials, Constants.AUTH_URL);
+
+        // now let the admin upload some commits
+        final CountDownLatch backgroundUpload = new CountDownLatch(1);
+
+        final HandlerThread handlerThread = new HandlerThread("HandlerThread");
+        handlerThread.start();
+        Looper looper = handlerThread.getLooper();
+        Handler handler = new Handler(looper);
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                // using an admin user to open the Realm on different path on the device then some commits
+                SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
+                SyncCredentials credentialsAdmin = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(admin).value(), "custom-admin-user");
+                SyncUser adminUser = SyncUser.login(credentialsAdmin, Constants.AUTH_URL);
+
+                SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, syncConfiguration.getServerUrl().toString())
+                        .modules(new StringOnlyModule())
+                        .waitForInitialRemoteData()
+                        .build();
+
+                final Realm adminRealm = Realm.getInstance(adminConfig);
+                adminRealm.beginTransaction();
+                adminRealm.createObject(StringOnly.class).setChars("2");
+                adminRealm.createObject(StringOnly.class).setChars("3");
+                adminRealm.commitTransaction();
+
+                try {
+                    SyncManager.getSession(adminConfig).uploadAllLocalChanges();
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                    fail(e.getMessage());
+                }
+                adminRealm.close();
+
+                backgroundUpload.countDown();
+                handlerThread.quit();
+            }
+        });
+
+        TestHelper.awaitOrFail(backgroundUpload, 60);
+        // Resume downloading
+        session.downloadAllServerChanges();
+        realm.refresh();//FIXME not calling refresh will still point to the previous version of the Realm count == 1
+        assertEquals(3, realm.where(StringOnly.class).count());
+        realm.close();
+    }
+
+    // Check that if we manually trigger a Client Reset, then it should be possible to start
+    // downloading the Realm immediately after.
+    @Test
+    @RunTestInLooperThread
+    public void clientReset_manualTriggerAllowSessionToRestart() {
+        final String uniqueName = UUID.randomUUID().toString();
+        SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+
+        final AtomicReference<SyncConfiguration> configRef = new AtomicReference<>(null);
+        final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM).directory(looperThread.getRoot())
+
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        final ClientResetRequiredError handler = (ClientResetRequiredError) error;
+                        // Execute Client Reset
+                        looperThread.closeTestRealms();
+                        handler.executeClientReset();
+
+                        // Try to re-open Realm and download it again
+                        looperThread.postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                // Validate that files have been moved
+                                assertFalse(handler.getOriginalFile().exists());
+                                assertTrue(handler.getBackupFile().exists());
+
+                                SyncConfiguration config = configRef.get();
+                                Realm instance = Realm.getInstance(config);
+                                looperThread.addTestRealm(instance);
+                                try {
+                                    SyncManager.getSession(config).downloadAllServerChanges();
+                                    looperThread.testComplete();
+                                } catch (InterruptedException e) {
+                                    fail(e.toString());
+                                }
+                            }
+                        });
+                    }
+                })
+                .build();
+        configRef.set(config);
+
+        Realm realm = Realm.getInstance(config);
+        looperThread.addTestRealm(realm);
+        // Trigger error
+        SyncManager.simulateClientReset(SyncManager.getSession(config));
+    }
+
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
new file mode 100644
index 0000000000..7e581f6a6f
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmTests.java
@@ -0,0 +1,276 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.os.SystemClock;
+import android.support.test.annotation.UiThreadTest;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.hamcrest.CoreMatchers;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.io.File;
+import java.util.Random;
+import java.util.UUID;
+
+import io.realm.entities.StringOnly;
+import io.realm.exceptions.DownloadingRealmInterruptedException;
+import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.OsRealmConfig;
+import io.realm.objectserver.utils.Constants;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.util.SyncTestUtils;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.fail;
+
+
+/**
+ * Catch all class for tests that not naturally fit anywhere else.
+ */
+@RunWith(AndroidJUnit4.class)
+public class SyncedRealmTests extends StandardIntegrationTest {
+
+    @Test
+    @UiThreadTest
+    public void waitForInitialRemoteData_mainThreadThrows() {
+        final SyncUser user = SyncTestUtils.createTestUser(Constants.AUTH_URL);
+        SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM)
+                .waitForInitialRemoteData()
+                .build();
+
+        Realm realm = null;
+        try {
+            realm = Realm.getInstance(config);
+            fail();
+        } catch (IllegalStateException expected) {
+            assertThat(expected.getMessage(), CoreMatchers.containsString(
+                    "downloadAllServerChanges() cannot be called from the main thread."));
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+        }
+    }
+
+    @Test
+    public void waitForInitialRemoteData() throws InterruptedException {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+
+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)
+        final SyncConfiguration configOld = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .schema(StringOnly.class)
+                .sessionStopPolicy(OsRealmConfig.SyncSessionStopPolicy.IMMEDIATELY)
+                .build();
+        Realm realm = Realm.getInstance(configOld);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                for (int i = 0; i < 10; i++) {
+                    realm.createObject(StringOnly.class).setChars("Foo" + i);
+                }
+            }
+        });
+        SyncManager.getSession(configOld).uploadAllLocalChanges();
+        realm.close();
+        user.logout();
+
+        // 2. Local state should now be completely reset. Open the same sync Realm but different local name again with
+        // a new configuration which should download the uploaded changes (pray it managed to do so within the time frame).
+        user = SyncUser.login(SyncCredentials.usernamePassword(username, password), Constants.AUTH_URL);
+        SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM)
+                .name("newRealm")
+                .schema(StringOnly.class)
+                .waitForInitialRemoteData()
+                .build();
+
+        realm = Realm.getInstance(config);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                for (int i = 0; i < 10; i++) {
+                    realm.createObject(StringOnly.class).setChars("Foo 1" + i);
+                }
+            }
+        });
+        try {
+            assertEquals(20, realm.where(StringOnly.class).count());
+        } finally {
+            realm.close();
+        }
+    }
+
+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that
+    // We cannot do much better since we cannot control the order of events internally in Realm which would be
+    // needed to correctly test all error paths.
+    @Test
+    @Ignore("See https://github.com/realm/realm-java/issues/5177")
+    public void waitForInitialData_resilientInCaseOfRetries() throws InterruptedException {
+        SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM)
+                .waitForInitialRemoteData()
+                .build();
+
+        for (int i = 0; i < 10; i++) {
+            Thread t = new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    Realm realm = null;
+                    try {
+                        // This will cause the download latch called later to immediately throw an InterruptedException.
+                        Thread.currentThread().interrupt();
+                        realm = Realm.getInstance(config);
+                    } catch (DownloadingRealmInterruptedException ignored) {
+                        assertFalse(new File(config.getPath()).exists());
+                    } finally {
+                        if (realm != null) {
+                            realm.close();
+                            Realm.deleteRealm(config);
+                        }
+                    }
+                }
+            });
+            t.start();
+            t.join();
+        }
+    }
+
+    // This tests will start and cancel getting a Realm 10 times. The Realm should be resilient towards that
+    // We cannot do much better since we cannot control the order of events internally in Realm which would be
+    // needed to correctly test all error paths.
+    @Test
+    @RunTestInLooperThread
+    @Ignore("See https://github.com/realm/realm-java/issues/5373")
+    public void waitForInitialData_resilientInCaseOfRetriesAsync() {
+        SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.USER_REALM)
+                .waitForInitialRemoteData()
+                .build();
+        Random randomizer = new Random();
+
+        for (int i = 0; i < 10; i++) {
+            RealmAsyncTask task = Realm.getInstanceAsync(config, new Realm.Callback() {
+                @Override
+                public void onSuccess(Realm realm) {
+                    fail();
+                }
+
+                @Override
+                public void onError(Throwable exception) {
+                    fail(exception.toString());
+                }
+            });
+            SystemClock.sleep(randomizer.nextInt(5));
+            task.cancel();
+        }
+        looperThread.testComplete();
+    }
+
+    @Test
+    public void waitForInitialRemoteData_readOnlyTrue() throws InterruptedException {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+
+        // 1. Copy a valid Realm to the server (and pray it does it within 10 seconds)
+        final SyncConfiguration configOld = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .schema(StringOnly.class)
+                .build();
+        Realm realm = Realm.getInstance(configOld);
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                for (int i = 0; i < 10; i++) {
+                    realm.createObject(StringOnly.class).setChars("Foo" + i);
+                }
+            }
+        });
+        SyncManager.getSession(configOld).uploadAllLocalChanges();
+        realm.close();
+        user.logout();
+
+        // 2. Local state should now be completely reset. Open the Realm again with a new configuration which should
+        // download the uploaded changes (pray it managed to do so within the time frame).
+        user = SyncUser.login(SyncCredentials.usernamePassword(username, password, false), Constants.AUTH_URL);
+        final SyncConfiguration configNew = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .name("newRealm")
+                .waitForInitialRemoteData()
+                .readOnly()
+                .schema(StringOnly.class)
+                .build();
+        assertFalse(configNew.realmExists());
+
+        realm = Realm.getInstance(configNew);
+        assertEquals(10, realm.where(StringOnly.class).count());
+        realm.close();
+        user.logout();
+    }
+    
+    @Test
+    public void waitForInitialRemoteData_readOnlyTrue_throwsIfWrongServerSchema() {
+        SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        final SyncConfiguration configNew = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .waitForInitialRemoteData()
+                .readOnly()
+                .schema(StringOnly.class)
+                .build();
+        assertFalse(configNew.realmExists());
+
+        Realm realm = null;
+        try {
+            // This will fail, because the server Realm is completely empty and the Client is not allowed to write the
+            // schema.
+            realm = Realm.getInstance(configNew);
+            fail();
+        } catch (RealmMigrationNeededException ignored) {
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+            user.logout();
+        }
+    }
+
+    @Test
+    public void waitForInitialRemoteData_readOnlyFalse_upgradeSchema() {
+        SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), "password", true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        final SyncConfiguration config = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .waitForInitialRemoteData() // Not readonly so Client should be allowed to write schema
+                .schema(StringOnly.class) // This schema should be written when opening the empty Realm.
+                .schemaVersion(2)
+                .build();
+        assertFalse(config.realmExists());
+
+        Realm realm = Realm.getInstance(config);
+        try {
+            assertEquals(0, realm.where(StringOnly.class).count());
+        } finally {
+            realm.close();
+            user.logout();
+        }
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index c4364b53f0..bc3f4e6f39 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -1,34 +1,64 @@
 package io.realm.objectserver;
 
+import android.os.Handler;
+import android.os.Looper;
+import android.os.SystemClock;
 import android.support.test.runner.AndroidJUnit4;
 
-import org.junit.Rule;
+import org.junit.Assert;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.lang.reflect.Field;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import io.realm.AuthenticationListener;
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
+import io.realm.RealmConfiguration;
+import io.realm.StandardIntegrationTest;
 import io.realm.SyncConfiguration;
 import io.realm.SyncCredentials;
 import io.realm.SyncManager;
 import io.realm.SyncSession;
 import io.realm.SyncUser;
-import io.realm.log.LogLevel;
-import io.realm.log.RealmLog;
+import io.realm.SyncUserInfo;
+import io.realm.TestHelper;
+import io.realm.entities.StringOnly;
+import io.realm.internal.async.RealmAsyncTaskImpl;
+import io.realm.internal.objectserver.Token;
 import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.objectserver.utils.UserFactory;
-import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
+import io.realm.util.SyncTestUtils;
 
 import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertNotNull;
 import static junit.framework.Assert.assertTrue;
 import static junit.framework.Assert.fail;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.greaterThan;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNull;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 
 @RunWith(AndroidJUnit4.class)
-public class AuthTests extends BaseIntegrationTest {
-    @Rule
-    public RunInLooperThread looperThread = new RunInLooperThread();
+public class AuthTests extends StandardIntegrationTest {
 
     @Test
     public void login_userNotExist() {
@@ -45,7 +75,7 @@ public void login_userNotExist() {
     @RunTestInLooperThread
     public void loginAsync_userNotExist() {
         SyncCredentials credentials = SyncCredentials.usernamePassword("IWantToHackYou", "GeneralPassword", false);
-        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback() {
+        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
             @Override
             public void onSuccess(SyncUser user) {
                 fail();
@@ -59,14 +89,39 @@ public void onError(ObjectServerError error) {
         });
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void login_newUser() {
+        String userId = UUID.randomUUID().toString();
+        SyncCredentials credentials = SyncCredentials.usernamePassword(userId, "password", true);
+        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
+            @Override
+            public void onSuccess(SyncUser user) {
+                assertFalse(user.isAdmin());
+                try {
+                    assertEquals(new URL(Constants.AUTH_URL), user.getAuthenticationUrl());
+                } catch (MalformedURLException e) {
+                    fail(e.toString());
+                }
+                looperThread.testComplete();
+            }
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.toString());
+            }
+        });
+    }
+
     @Test
     @RunTestInLooperThread
     public void login_withAccessToken() {
-        SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
-        SyncCredentials credentials = SyncCredentials.accessToken(admin.getAccessToken().value(), "custom-admin-user");
-        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback() {
+        SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+        SyncCredentials credentials = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(adminUser).value(), "custom-admin-user", adminUser.isAdmin());
+        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
             @Override
             public void onSuccess(SyncUser user) {
+                assertTrue(user.isAdmin());
                 final SyncConfiguration config = new SyncConfiguration.Builder(user, Constants.SYNC_SERVER_URL)
                         .errorHandler(new SyncSession.ErrorHandler() {
                             @Override
@@ -78,16 +133,8 @@ public void onError(SyncSession session, ObjectServerError error) {
 
                 final Realm realm = Realm.getInstance(config);
                 looperThread.addTestRealm(realm);
-
-                // FIXME: Right now we have no Java API for detecting when a session is established
-                // So we optimistically assume it has been connected after 1 second.
-                looperThread.postRunnableDelayed(new Runnable() {
-                    @Override
-                    public void run() {
-                        assertTrue(SyncManager.getSession(config).getUser().isValid());
-                        looperThread.testComplete();
-                    }
-                }, 1000);
+                assertTrue(config.getUser().isValid());
+                looperThread.testComplete();
             }
 
             @Override
@@ -97,35 +144,609 @@ public void onError(ObjectServerError error) {
         });
     }
 
-    // The error handler throws an exception but it is ignored (but logged). That means, this test should not
-    // pass and not be stopped by an IllegalArgumentException.
+    @Test
+    public void loginAsync_errorHandlerThrows() throws InterruptedException {
+        final AtomicBoolean errorThrown = new AtomicBoolean(false);
+
+        // Create custom Looper thread to be able to check for errors thrown when processing Looper events.
+        Thread t = new Thread(new Runnable() {
+            private volatile Handler handler;
+            @Override
+            public void run() {
+                Looper.prepare();
+                try {
+                    handler = new Handler();
+                    handler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            SyncCredentials credentials = SyncCredentials.usernamePassword("IWantToHackYou", "GeneralPassword", false);
+                            SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback<SyncUser>() {
+                                @Override
+                                public void onSuccess(SyncUser user) {
+                                    fail();
+                                }
+
+                                @Override
+                                public void onError(ObjectServerError error) {
+                                    assertEquals(ErrorCode.INVALID_CREDENTIALS, error.getErrorCode());
+                                    throw new IllegalArgumentException("BOOM");
+                                }
+                            });
+                        }
+                    });
+                    Looper.loop(); //
+                } catch (IllegalArgumentException e) {
+                    errorThrown.set(true);
+                }
+            }
+        });
+        t.start();
+        t.join(TimeUnit.SECONDS.toMillis(10));
+        assertTrue(errorThrown.get());
+    }
+
+    @Test
+    public void changePassword() {
+        String username = UUID.randomUUID().toString();
+        String originalPassword = "password";
+        SyncCredentials credentials = SyncCredentials.usernamePassword(username, originalPassword, true);
+        SyncUser userOld = SyncUser.login(credentials, Constants.AUTH_URL);
+        assertTrue(userOld.isValid());
+
+        // Change password and try to log in with new password
+        String newPassword = "new-password";
+        userOld.changePassword(newPassword);
+        userOld.logout();
+
+        // Make sure old password doesn't work
+        try {
+            SyncUser.login(SyncCredentials.usernamePassword(username, originalPassword, false), Constants.AUTH_URL);
+            fail();
+        } catch (ObjectServerError e) {
+            assertEquals(ErrorCode.INVALID_CREDENTIALS, e.getErrorCode());
+        }
+
+        // Then login with new password
+        credentials = SyncCredentials.usernamePassword(username, newPassword, false);
+        SyncUser userNew = SyncUser.login(credentials, Constants.AUTH_URL);
+        assertTrue(userNew.isValid());
+        assertEquals(userOld.getIdentity(), userNew.getIdentity());
+    }
+
+    @Test
+    public void changePassword_using_admin() {
+        String username = UUID.randomUUID().toString();
+        String originalPassword = "password";
+        SyncCredentials credentials = SyncCredentials.usernamePassword(username, originalPassword, true);
+        SyncUser userOld = SyncUser.login(credentials, Constants.AUTH_URL);
+        assertTrue(userOld.isValid());
+
+        // Login an admin user
+        SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+        assertTrue(adminUser.isValid());
+        assertTrue(adminUser.isAdmin());
+
+        // Change password using admin user
+        String newPassword = "new-password";
+        adminUser.changePassword(userOld.getIdentity(), newPassword);
+
+        // Try to log in with new password
+        userOld.logout();
+        credentials = SyncCredentials.usernamePassword(username, newPassword, false);
+        SyncUser userNew = SyncUser.login(credentials, Constants.AUTH_URL);
+
+        assertTrue(userNew.isValid());
+        assertEquals(userOld.getIdentity(), userNew.getIdentity());
+    }
+
     @Test
     @RunTestInLooperThread
-    public void loginAsync_errorHandlerThrows() {
-        // set log level to info to make sure the IllegalArgumentException
-        // thrown in the test is visible in Logcat
-        final int defaultLevel = RealmLog.getLevel();
-        RealmLog.setLevel(LogLevel.INFO);
-        SyncCredentials credentials = SyncCredentials.usernamePassword("IWantToHackYou", "GeneralPassword", false);
-        SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback() {
+    public void changePassword_using_admin_async() {
+        final String username = UUID.randomUUID().toString();
+        final String originalPassword = "password";
+        final SyncCredentials credentials = SyncCredentials.usernamePassword(username, originalPassword, true);
+        final SyncUser userOld = SyncUser.login(credentials, Constants.AUTH_URL);
+        assertTrue(userOld.isValid());
+
+        // Login an admin user
+        final SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+        assertTrue(adminUser.isValid());
+        assertTrue(adminUser.isAdmin());
+
+        // Change password using admin user
+        final String newPassword = "new-password";
+        adminUser.changePasswordAsync(userOld.getIdentity(), newPassword, new SyncUser.Callback<SyncUser>() {
             @Override
-            public void onSuccess(SyncUser user) {
-                fail();
+            public void onSuccess(SyncUser administratorUser) {
+                assertEquals(adminUser, administratorUser);
+
+                // Try to log in with new password
+                userOld.logout();
+                SyncCredentials credentials = SyncCredentials.usernamePassword(username, newPassword, false);
+                SyncUser userNew = SyncUser.login(credentials, Constants.AUTH_URL);
+
+                assertTrue(userNew.isValid());
+                assertEquals(userOld.getIdentity(), userNew.getIdentity());
+
+                looperThread.testComplete();
             }
 
             @Override
             public void onError(ObjectServerError error) {
-                assertEquals(ErrorCode.INVALID_CREDENTIALS, error.getErrorCode());
-                throw new IllegalArgumentException("BOOM");
+                fail(error.getErrorMessage());
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changePassword_throwWhenUserIsLoggedOut() {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+        SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncManager.addAuthenticationListener(new AuthenticationListener() {
+            @Override
+            public void loggedIn(SyncUser user) {
+                SyncManager.removeAuthenticationListener(this);
+                // callback is happening on different thread, all assertions needs to be done on looper thread
+                looperThread.postRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        fail("loggedIn should not be invoked");
+                    }
+                });
+            }
+
+            @Override
+            public void loggedOut(SyncUser user) {
+                SyncManager.removeAuthenticationListener(this);
+                try {
+                    user.changePassword("new-password");
+                    looperThread.postRunnable(new Runnable() {
+                        @Override
+                        public void run() {
+                            fail("changePassword should throw ObjectServerError (INVALID CREDENTIALS)");
+                        }
+                    });
+                } catch (ObjectServerError expected) {
+                }
+                looperThread.testComplete();
             }
         });
+        user.logout();
+    }
+
+    @Test
+    public void cachedInstanceShouldNotThrowIfRefreshTokenExpires() throws InterruptedException {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+
+        SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
+        final SyncUser user = spy(SyncUser.login(credentials, Constants.AUTH_URL));
+
+        when(user.isValid()).thenReturn(true, false);
+
+        final RealmConfiguration configuration = new SyncConfiguration.Builder(user, Constants.USER_REALM).build();
+        Realm realm = Realm.getInstance(configuration);
 
-        looperThread.postRunnableDelayed(new Runnable() {
+        assertFalse(user.isValid());
+        verify(user, times(2)).isValid();
+
+        final CountDownLatch backgroundThread = new CountDownLatch(1);
+        // Should not throw when using an expired refresh_token form a different thread
+        // It should be able to open a Realm with an expired token
+        new Thread() {
             @Override
             public void run() {
-                RealmLog.setLevel(defaultLevel);
+                Realm instance = Realm.getInstance(configuration);
+                instance.close();
+                backgroundThread.countDown();
+            }
+        }.start();
+
+        backgroundThread.await();
+
+        // It should be possible to open a cached Realm with expired token
+        Realm cachedInstance = Realm.getInstance(configuration);
+        assertNotNull(cachedInstance);
+
+        realm.close();
+        cachedInstance.close();
+        user.logout();
+    }
+
+    @Test
+    public void buildingSyncConfigurationShouldThrowIfInvalidUser() {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+
+        SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser currentUser = SyncUser.currentUser();
+        user.logout();
+
+        assertFalse(user.isValid());
+
+        try {
+            // We should not be able to build a configuration with an invalid/logged out user
+            new SyncConfiguration.Builder(user, Constants.USER_REALM).build();
+            fail("Invalid user, it should not be possible to create a SyncConfiguration");
+        } catch (IllegalArgumentException expected) {
+            // User not authenticated or authentication expired.
+        }
+
+        try {
+            // We should not be able to build a configuration with an invalid/logged out user
+            new SyncConfiguration.Builder(currentUser, Constants.USER_REALM).build();
+            fail("Invalid currentUser, it should not be possible to create a SyncConfiguration");
+        } catch (IllegalArgumentException expected) {
+            // User not authenticated or authentication expired.
+        }
+    }
+
+    // using a logout user should not throw
+    @Test
+    public void usingConfigurationWithInvalidUserShouldThrow() {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+
+        SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        RealmConfiguration configuration = new SyncConfiguration.Builder(user, Constants.USER_REALM).build();
+        user.logout();
+        assertFalse(user.isValid());
+        Realm instance = Realm.getInstance(configuration);
+        instance.close();
+    }
+
+    @Test
+    public void logout_currentUserMoreThanOne() {
+        UserFactory.createUniqueUser(Constants.AUTH_URL);
+        SyncUser.currentUser().logout();
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        assertEquals(user, SyncUser.currentUser());
+    }
+
+    // logging out 'user' should have the same impact on other instance(s) of the same user
+    @Test
+    public void loggingOutUserShouldImpactOtherInstances() throws InterruptedException {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+
+        SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser currentUser = SyncUser.currentUser();
+
+        assertTrue(user.isValid());
+        assertEquals(user, currentUser);
+
+        user.logout();
+
+        assertFalse(user.isValid());
+        assertFalse(currentUser.isValid());
+    }
+
+    // logging out 'currentUser' should have the same impact on other instance(s) of the user
+    @Test
+    public void loggingOutCurrentUserShouldImpactOtherInstances() throws InterruptedException {
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+
+        SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        SyncUser currentUser = SyncUser.currentUser();
+
+        assertTrue(user.isValid());
+        assertEquals(user, currentUser);
+
+        SyncUser.currentUser().logout();
+
+        assertFalse(user.isValid());
+        assertFalse(currentUser.isValid());
+        assertNull(SyncUser.currentUser());
+    }
+
+    // verify that multiple users can be logged in at the same time
+    @Test
+    public void multipleUsersCanBeLoggedInSimultaneously() {
+        final String password = "password";
+        final SyncUser[] users = new SyncUser[3];
+
+        for (int i = 0; i < users.length; i++) {
+            SyncCredentials credentials = SyncCredentials.usernamePassword(UUID.randomUUID().toString(), password,
+                    true);
+            users[i] = SyncUser.login(credentials, Constants.AUTH_URL);
+        }
+
+        for (int i = 0; i < users.length; i++) {
+            assertTrue(users[i].isValid());
+        }
+
+        for (int i = 0; i < users.length; i++) {
+            users[i].logout();
+        }
+
+        for (int i = 0; i < users.length; i++) {
+            assertFalse(users[i].isValid());
+        }
+    }
+
+    // verify that a single user can be logged out and back in.
+    @Test
+    public void singleUserCanBeLoggedInAndOutRepeatedly() {
+        final String username = UUID.randomUUID().toString();
+        final String password = "password";
+
+        // register the user the first time
+        SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
+
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        assertTrue(user.isValid());
+        user.logout();
+        assertFalse(user.isValid());
+
+        // on subsequent logins, the user is already registered.
+        credentials = credentials = SyncCredentials.usernamePassword(username, password, false);
+        for (int i = 0; i < 3; i++) {
+            user = SyncUser.login(credentials, Constants.AUTH_URL);
+            assertTrue(user.isValid());
+            user.logout();
+            assertFalse(user.isValid());
+        }
+    }
+
+    @Test
+    public void revokedRefreshTokenIsNotSameAfterLogin() throws InterruptedException {
+        final CountDownLatch userLoggedInAgain = new CountDownLatch(1);
+        final String uniqueName = UUID.randomUUID().toString();
+
+        final SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", true);
+        SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        final Token revokedRefreshToken = SyncTestUtils.getRefreshToken(user);
+
+        SyncManager.addAuthenticationListener(new AuthenticationListener() {
+            @Override
+            public void loggedIn(SyncUser user) {
+
+            }
+
+            @Override
+            public void loggedOut(SyncUser user) {
+                SyncCredentials credentials = SyncCredentials.usernamePassword(uniqueName, "password", false);
+                SyncUser loggedInUser = SyncUser.login(credentials, Constants.AUTH_URL);
+
+                Token token = SyncTestUtils.getRefreshToken(loggedInUser);
+                // still comparing the same user
+                assertEquals(revokedRefreshToken.identity(), token.identity());
+
+                // different tokens
+                assertNotEquals(revokedRefreshToken.value(), token.value());
+                SyncManager.removeAuthenticationListener(this);
+                userLoggedInAgain.countDown();
+            }
+        });
+
+        user.logout();
+        TestHelper.awaitOrFail(userLoggedInAgain);
+    }
+
+    // The pre-emptive token refresh subsystem should function, and properly refresh the access token.
+    // WARNING: this test can fail if there's a difference between the server's and device's clock, causing the
+    // refresh access token to be too far in time.
+    @Test(timeout = 30000)
+    public void preemptiveTokenRefresh() throws NoSuchFieldException, IllegalAccessException, InterruptedException {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+
+        // make the access tokens map accessible
+        Field realmsField = SyncUser.class.getDeclaredField("realms");
+        realmsField.setAccessible(true);
+        @SuppressWarnings("unchecked") // using reflection
+        Map<SyncConfiguration, Token> accessTokens = (Map<SyncConfiguration, Token>) realmsField.get(user);
+
+        final SyncConfiguration syncConfiguration = configurationFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .modules(new StringOnlyModule())
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        fail(error.getErrorMessage());
+                    }
+                })
+                .build();
+        Realm realm = Realm.getInstance(syncConfiguration);
+
+        // create and wait for a transaction to be uploaded,
+        // this guarantees that an accessToken is available
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(StringOnly.class).setChars("1");
+            }
+        });
+        SyncSession session = SyncManager.getSession(syncConfiguration);
+        session.uploadAllLocalChanges();
+
+        assertFalse(accessTokens.isEmpty());
+        Assert.assertEquals(1, accessTokens.size());
+        Map.Entry<SyncConfiguration, Token> entry = accessTokens.entrySet().iterator().next();
+        Assert.assertEquals(syncConfiguration, entry.getKey());
+
+        final Token accessToken = entry.getValue();
+        Assert.assertNotNull(accessToken);
+        // getting refresh token delay
+        Field refreshTokenTaskField = SyncSession.class.getDeclaredField("refreshTokenTask");
+        refreshTokenTaskField.setAccessible(true);
+        RealmAsyncTaskImpl task = (RealmAsyncTaskImpl) refreshTokenTaskField.get(session);
+        Field pendingTaskField = RealmAsyncTaskImpl.class.getDeclaredField("pendingTask");
+        pendingTaskField.setAccessible(true);
+        ScheduledFuture<?> pendingTask = (ScheduledFuture<?>) pendingTaskField.get(task);
+        long nextRefreshTokenRefreshQueryDelay = pendingTask.getDelay(TimeUnit.MILLISECONDS);
+
+        // current configuration 'realm-java/tools/sync_test_server/configuration.yml'
+        // is setting the access token to expire every 20 seconds 'access_token: 20'
+        // we wait approximately actually 10 seconds since the SyncSession.REFRESH_MARGIN_DELAY is 10s
+        SystemClock.sleep(nextRefreshTokenRefreshQueryDelay);
+
+        // allow 3 seconds for the query to perform and complete
+        SystemClock.sleep(TimeUnit.SECONDS.toMillis(3));
+
+        Token newAccessToken = accessTokens.get(syncConfiguration);
+        assertThat("new Token expires after the old one", newAccessToken.expiresMs(), greaterThan(accessToken.expiresMs()));
+        assertNotEquals(accessToken, newAccessToken);
+
+        // refresh_token identity is the same
+        assertEquals(SyncTestUtils.getRefreshToken(user).identity(), newAccessToken.identity());
+        assertEquals(accessToken.identity(), newAccessToken.identity());
+
+        realm.close();
+    }
+
+    @Test
+    public void retrieve() {
+        final SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+
+        final String username = UUID.randomUUID().toString();
+        final String password = "password";
+        final SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
+        final SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        assertTrue(user.isValid());
+
+        String identity = user.getIdentity();
+
+        SyncUserInfo userInfo = adminUser.retrieveInfoForUser(username, SyncCredentials.IdentityProvider.USERNAME_PASSWORD);
+
+        assertNotNull(userInfo);
+        assertEquals(identity, userInfo.getIdentity());
+        assertFalse(userInfo.isAdmin());
+        assertTrue(userInfo.getMetadata().isEmpty());
+        assertEquals(username, userInfo.getAccounts().get(SyncCredentials.IdentityProvider.USERNAME_PASSWORD));
+    }
+
+
+    // retrieving a logged out user
+    @Test
+    @RunTestInLooperThread
+    public void retrieve_logout() {
+        final SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+
+        final String username = UUID.randomUUID().toString();
+        final String password = "password";
+        final SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
+        final SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        final String identity = user.getIdentity();
+
+        // unless the refresh_token is revoked (via logout) the admin user can still retrieve the user
+        // we make sure the token is revoked before trying to retrieve the user
+        SyncManager.addAuthenticationListener(new AuthenticationListener() {
+            @Override
+            public void loggedIn(SyncUser user) {
+                SyncManager.removeAuthenticationListener(this);
+                looperThread.postRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        fail("loggedIn should not be invoked");
+                    }
+                });
+            }
+
+            @Override
+            public void loggedOut(final SyncUser user) {
+                SyncManager.removeAuthenticationListener(this);
+                looperThread.postRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        assertFalse(user.isValid());
+                        SyncUserInfo userInfo = adminUser.retrieveInfoForUser(username, SyncCredentials.IdentityProvider.USERNAME_PASSWORD);
+
+                        assertNotNull(userInfo);
+                        assertEquals(identity, userInfo.getIdentity());
+                        assertFalse(userInfo.isAdmin());
+                        assertTrue(userInfo.getMetadata().isEmpty());
+                        assertEquals(username, userInfo.getAccounts().get(SyncCredentials.IdentityProvider.USERNAME_PASSWORD));
+
+                        looperThread.testComplete();
+                    }
+                });
+
+            }
+        });
+        user.logout();
+    }
+
+    @Test
+    public void retrieve_unknownProviderId() {
+        final SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+        SyncUserInfo userInfo = adminUser.retrieveInfoForUser("doesNotExist", SyncCredentials.IdentityProvider.USERNAME_PASSWORD);
+        assertNull(userInfo);
+    }
+
+    @Test
+    public void retrieve_invalidProvider() {
+        final SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+        final String username = UUID.randomUUID().toString();
+        final String password = "password";
+        final SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
+        final SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        assertTrue(user.isValid());
+
+        SyncUserInfo userInfo = adminUser.retrieveInfoForUser("username", "invalid");
+        assertNull(userInfo);
+    }
+
+    @Test
+    public void retrieve_notAdmin() {
+        final String username1 = UUID.randomUUID().toString();
+        final String password1 = "password";
+        final SyncCredentials credentials1 = SyncCredentials.usernamePassword(username1, password1, true);
+        final SyncUser user1 = SyncUser.login(credentials1, Constants.AUTH_URL);
+        assertTrue(user1.isValid());
+
+        final String username2 = UUID.randomUUID().toString();
+        final String password2 = "password";
+        final SyncCredentials credentials2 = SyncCredentials.usernamePassword(username2, password2, true);
+        final SyncUser user2 = SyncUser.login(credentials2, Constants.AUTH_URL);
+        assertTrue(user2.isValid());
+
+        // trying to lookup user2 using user1 should not work (requires admin token)
+        try {
+            user1.retrieveInfoForUser(SyncCredentials.IdentityProvider.USERNAME_PASSWORD, username2);
+            fail("It should not be possible to lookup a user using non admin token");
+        } catch (IllegalArgumentException expected) {
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void retrieve_async() {
+        final String username = UUID.randomUUID().toString();
+        final String password = "password";
+        final SyncCredentials credentials = SyncCredentials.usernamePassword(username, password, true);
+        final SyncUser user = SyncUser.login(credentials, Constants.AUTH_URL);
+        assertTrue(user.isValid());
+
+        // Login an admin user
+        final SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+        assertTrue(adminUser.isValid());
+        assertTrue(adminUser.isAdmin());
+
+        final String identity = user.getIdentity();
+        adminUser.retrieveInfoForUserAsync(username, SyncCredentials.IdentityProvider.USERNAME_PASSWORD, new SyncUser.Callback<SyncUserInfo>() {
+            @Override
+            public void onSuccess(SyncUserInfo userInfo) {
+                assertNotNull(userInfo);
+                assertEquals(identity, userInfo.getIdentity());
+                assertFalse(userInfo.isAdmin());
+                assertTrue(userInfo.getMetadata().isEmpty());
+                assertEquals(username, userInfo.getAccounts().get(SyncCredentials.IdentityProvider.USERNAME_PASSWORD));
+
                 looperThread.testComplete();
             }
-        }, 1000);
+
+            @Override
+            public void onError(ObjectServerError error) {
+                fail(error.getErrorMessage());
+            }
+        });
     }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java
deleted file mode 100644
index 764b511ee7..0000000000
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/BaseIntegrationTest.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.objectserver;
-
-import android.support.test.InstrumentationRegistry;
-
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
-
-import io.realm.Realm;
-import io.realm.SyncManager;
-import io.realm.log.RealmLog;
-import io.realm.objectserver.utils.HttpUtils;
-
-class BaseIntegrationTest {
-
-    @BeforeClass
-    public static void setUp () throws Exception {
-        SyncManager.Debug.skipOnlineChecking = true;
-        try {
-            Realm.init(InstrumentationRegistry.getContext());
-            HttpUtils.startSyncServer();
-        } catch (Exception e) {
-            // Throwing an exception from this method will crash JUnit. Instead just log it.
-            // If this setup method fails, all unit tests in the class extending it will most likely fail as well.
-            RealmLog.error("Could not start Sync Server", e);
-        }
-    }
-
-    @AfterClass
-    public static void tearDown () throws Exception {
-        try {
-            HttpUtils.stopSyncServer();
-        } catch (Exception e) {
-            RealmLog.error("Failed to stop Sync Server", e);
-        }
-    }
-}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
new file mode 100644
index 0000000000..ded87c8ca1
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
@@ -0,0 +1,243 @@
+package io.realm.objectserver;
+
+import android.os.SystemClock;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.Timeout;
+
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+
+import io.realm.ObjectServerError;
+import io.realm.Realm;
+import io.realm.RealmResults;
+import io.realm.StandardIntegrationTest;
+import io.realm.SyncConfiguration;
+import io.realm.SyncCredentials;
+import io.realm.SyncManager;
+import io.realm.SyncSession;
+import io.realm.SyncUser;
+import io.realm.TestHelper;
+import io.realm.entities.StringOnly;
+import io.realm.exceptions.RealmFileException;
+import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.StringOnlyModule;
+import io.realm.objectserver.utils.UserFactory;
+import io.realm.util.SyncTestUtils;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class EncryptedSynchronizedRealmTests extends StandardIntegrationTest {
+
+    @Rule
+    public Timeout globalTimeout = Timeout.seconds(10);
+
+    // Make sure the encryption is local, i.e after deleting a synced Realm
+    // re-open it again with no (or different) key, should be possible.
+    @Test
+    public void setEncryptionKey_canReOpenRealmWithoutKey() {
+
+        // STEP 1: open a synced Realm using a local encryption key
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+
+        final byte[] randomKey = TestHelper.getRandomKey();
+
+        SyncConfiguration configWithEncryption = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .modules(new StringOnlyModule())
+                .waitForInitialRemoteData()
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        fail(error.getErrorMessage());
+                    }
+                })
+                .encryptionKey(randomKey)
+                .build();
+
+        Realm realm = Realm.getInstance(configWithEncryption);
+        assertTrue(realm.isEmpty());
+
+        realm.beginTransaction();
+        realm.createObject(StringOnly.class).setChars("Hi Alice");
+        realm.commitTransaction();
+
+        // STEP 2:  make sure the changes gets to the server
+        SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));  // FIXME: Replace with Sync Progress Notifications once available.
+        realm.close();
+        user.logout();
+
+        // STEP 3: try to open again the same sync Realm but different local name without the encryption key should not
+        // fail
+        user = SyncUser.login(SyncCredentials.usernamePassword(username, password, false), Constants.AUTH_URL);
+        SyncConfiguration configWithoutEncryption = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .name("newName")
+                .modules(new StringOnlyModule())
+                .waitForInitialRemoteData()
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        fail(error.getErrorMessage());
+                    }
+                })
+                .build();
+
+        realm = Realm.getInstance(configWithoutEncryption);
+        RealmResults<StringOnly> all = realm.where(StringOnly.class).findAll();
+        assertEquals(1, all.size());
+        assertEquals("Hi Alice", all.get(0).getChars());
+
+        realm.close();
+        user.logout();
+    }
+
+    // If an encrypted synced Realm is re-opened with the wrong key, throw an exception.
+    @Test
+    public void setEncryptionKey_shouldCrashIfKeyNotProvided() throws InterruptedException {
+        // STEP 1: open a synced Realm using a local encryption key
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+
+        final byte[] randomKey = TestHelper.getRandomKey();
+
+        SyncConfiguration configWithEncryption = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .modules(new StringOnlyModule())
+                .waitForInitialRemoteData()
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        fail(error.getErrorMessage());
+                    }
+                })
+                .encryptionKey(randomKey)
+                .build();
+
+        Realm realm = Realm.getInstance(configWithEncryption);
+        assertTrue(realm.isEmpty());
+
+        realm.beginTransaction();
+        realm.createObject(StringOnly.class).setChars("Hi Alice");
+        realm.commitTransaction();
+
+        // STEP 2: make sure the changes gets to the server
+        SyncManager.getSession(configWithEncryption).uploadAllLocalChanges();
+
+        realm.close();
+        user.logout();
+
+        // STEP 3: try to open again the Realm without the encryption key should fail
+        user = SyncUser.login(SyncCredentials.usernamePassword(username, password, false), Constants.AUTH_URL);
+        SyncConfiguration configWithoutEncryption = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .modules(new StringOnlyModule())
+                .waitForInitialRemoteData()
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        fail(error.getErrorMessage());
+                    }
+                })
+                .build();
+
+        try {
+            realm = Realm.getInstance(configWithoutEncryption);
+            fail("It should not be possible to open the Realm without the encryption key set previously.");
+        } catch (RealmFileException ignored) {
+        } finally {
+            if (realm != null) {
+                realm.close();
+            }
+        }
+    }
+
+    // If client B encrypts its synced Realm, client A should be able to access that Realm with a different encryption key.
+    @Test
+    public void setEncryptionKey_differentClientsWithDifferentKeys() throws InterruptedException {
+        // STEP 1: prepare a synced Realm for client A
+        String username = UUID.randomUUID().toString();
+        String password = "password";
+        SyncUser user = SyncUser.login(SyncCredentials.usernamePassword(username, password, true), Constants.AUTH_URL);
+
+        final byte[] randomKey = TestHelper.getRandomKey();
+
+        SyncConfiguration configWithEncryption = configurationFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .modules(new StringOnlyModule())
+                .waitForInitialRemoteData()
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        fail(error.getErrorMessage());
+                    }
+                })
+                .encryptionKey(randomKey)
+                .build();
+
+        Realm realm = Realm.getInstance(configWithEncryption);
+        assertTrue(realm.isEmpty());
+
+        realm.beginTransaction();
+        realm.createObject(StringOnly.class).setChars("Hi Alice");
+        realm.commitTransaction();
+
+        // STEP 2: make sure the changes gets to the server
+        SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));  // FIXME: Replace with Sync Progress Notifications once available.
+        realm.close();
+
+        // STEP 3: prepare a synced Realm for client B (admin user)
+        SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
+        SyncCredentials credentials = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(admin).value(), "custom-admin-user");
+        SyncUser adminUser = SyncUser.login(credentials, Constants.AUTH_URL);
+
+        final byte[] adminRandomKey = TestHelper.getRandomKey();
+
+        SyncConfiguration adminConfigWithEncryption = configurationFactory.createSyncConfigurationBuilder(adminUser, configWithEncryption.getServerUrl().toString())
+                .modules(new StringOnlyModule())
+                .waitForInitialRemoteData()
+                .errorHandler(new SyncSession.ErrorHandler() {
+                    @Override
+                    public void onError(SyncSession session, ObjectServerError error) {
+                        fail(error.getErrorMessage());
+                    }
+                })
+                .encryptionKey(adminRandomKey)
+                .build();
+
+        Realm adminRealm = Realm.getInstance(adminConfigWithEncryption);
+        RealmResults<StringOnly> all = adminRealm.where(StringOnly.class).findAll();
+        assertEquals(1, all.size());
+        assertEquals("Hi Alice", all.get(0).getChars());
+
+        adminRealm.beginTransaction();
+        adminRealm.createObject(StringOnly.class).setChars("Hi Bob");
+        adminRealm.commitTransaction();
+
+        SystemClock.sleep(TimeUnit.SECONDS.toMillis(2));
+        adminRealm.close();
+
+        // STEP 4: client A can see changes from client B (although they're using different encryption keys)
+        realm = Realm.getInstance(configWithEncryption);
+        SyncManager.getSession(configWithEncryption).downloadAllServerChanges();// force download latest commits from ROS
+        realm.refresh();//FIXME not calling refresh will still point to the previous version of the Realm without the latest admin commit  "Hi Bob"
+        assertEquals(2, realm.where(StringOnly.class).count());
+
+        adminRealm = Realm.getInstance(adminConfigWithEncryption);
+
+        RealmResults<StringOnly> allSorted = realm.where(StringOnly.class).findAllSorted(StringOnly.FIELD_CHARS);
+        RealmResults<StringOnly> allSortedAdmin = adminRealm.where(StringOnly.class).findAllSorted(StringOnly.FIELD_CHARS);
+        assertEquals("Hi Alice", allSorted.get(0).getChars());
+        assertEquals("Hi Bob", allSorted.get(1).getChars());
+
+        assertEquals("Hi Alice", allSortedAdmin.get(0).getChars());
+        assertEquals("Hi Bob", allSortedAdmin.get(1).getChars());
+
+        adminRealm.close();
+        adminUser.logout();
+
+        realm.close();
+        user.logout();
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
deleted file mode 100644
index 0ad9688104..0000000000
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ManagementRealmTests.java
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
- * Copyright 2017 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.objectserver;
-
-import android.support.test.runner.AndroidJUnit4;
-
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.util.Date;
-import java.util.concurrent.atomic.AtomicReference;
-
-import io.realm.ObjectServerError;
-import io.realm.Realm;
-import io.realm.RealmChangeListener;
-import io.realm.RealmResults;
-import io.realm.SyncConfiguration;
-import io.realm.SyncSession;
-import io.realm.SyncUser;
-import io.realm.entities.Dog;
-import io.realm.log.RealmLog;
-import io.realm.objectserver.utils.Constants;
-import io.realm.objectserver.utils.UserFactory;
-import io.realm.permissions.PermissionOffer;
-import io.realm.permissions.PermissionOfferResponse;
-import io.realm.rule.RunInLooperThread;
-import io.realm.rule.RunTestInLooperThread;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-@RunWith(AndroidJUnit4.class)
-public class ManagementRealmTests extends BaseIntegrationTest {
-
-    @Rule
-    public RunInLooperThread looperThread = new RunInLooperThread();
-
-    @Ignore("TODO: Test is currently flaky. See https://github.com/realm/realm-java/pull/4066")
-    @Test
-    @RunTestInLooperThread
-    public void create_acceptOffer() {
-        SyncUser user1 = UserFactory.createUser(Constants.AUTH_URL, "user1");
-        final SyncUser user2 = UserFactory.createUser(Constants.AUTH_URL, "user2");
-
-        // 1. User1 creates Realm that user2 does not have access
-        final String user1RealmUrl = "realm://127.0.0.1:9080/" + user1.getIdentity() + "/permission-offer-test";
-        SyncConfiguration config1 = new SyncConfiguration.Builder(user1, user1RealmUrl).
-                errorHandler(new SyncSession.ErrorHandler() {
-                    @Override
-                    public void onError(SyncSession session, ObjectServerError error) {
-                        fail("Realm 1 unexpected error: " + error);
-                    }
-                })
-                .build();
-        final Realm realm1 = Realm.getInstance(config1);
-        looperThread.addTestRealm(realm1);
-        realm1.executeTransactionAsync(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                realm.createObject(Dog.class);
-            }
-        });
-
-        // 2. Create configuration for User2's Realm.
-        final SyncConfiguration config2 = new SyncConfiguration.Builder(user2, user1RealmUrl).build();
-
-        // 3. Create PermissionOffer
-        final AtomicReference<String> offerId = new AtomicReference<String>(null);
-        final Realm user1ManagementRealm = user1.getManagementRealm();
-        looperThread.addTestRealm(user1ManagementRealm);
-        user1ManagementRealm.executeTransactionAsync(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                boolean readPermission = true;
-                boolean readWritePermission = true;
-                boolean managePermission = false;
-                Date expiresAt = null;
-                PermissionOffer offer = new PermissionOffer(user1RealmUrl, readPermission, readWritePermission, managePermission, expiresAt);
-                offerId.set(offer.getId());
-                realm.copyToRealm(offer);
-            }
-        }, new Realm.Transaction.OnSuccess() {
-            @Override
-            public void onSuccess() {
-                // 4. Wait for offer to get an token
-                RealmLog.error("OfferID: " + offerId.get());
-                RealmResults<PermissionOffer> offers = user1ManagementRealm.where(PermissionOffer.class)
-                        .equalTo("id", offerId.get())
-                        .findAllAsync();
-                looperThread.keepStrongReference(offers);
-                offers.addChangeListener(new RealmChangeListener<RealmResults<PermissionOffer>>() {
-                    @Override
-                    public void onChange(RealmResults<PermissionOffer> offers) {
-                        final PermissionOffer offer = offers.first(null);
-                        if (offer != null && offer.isSuccessful() && offer.getToken() != null) {
-                            // 5. User2 uses the token to accept the offer
-                            final String offerToken = offer.getToken();
-                            final AtomicReference<String> offerResponseId = new AtomicReference<String>();
-                            final Realm user2ManagementRealm = user2.getManagementRealm();
-                            looperThread.addTestRealm(user2ManagementRealm);
-                            user2ManagementRealm.executeTransactionAsync(new Realm.Transaction() {
-                                @Override
-                                public void execute(Realm realm) {
-                                    PermissionOfferResponse offerResponse = new PermissionOfferResponse(offerToken);
-                                    offerResponseId.set(offerResponse.getId());
-                                    realm.copyToRealm(offerResponse);
-                                }
-                            }, new Realm.Transaction.OnSuccess() {
-                                @Override
-                                public void onSuccess() {
-                                    // 6. Wait for the offer response to be accepted
-                                    RealmResults<PermissionOfferResponse> responses = user2ManagementRealm.where(PermissionOfferResponse.class)
-                                            .equalTo("id", offerResponseId.get())
-                                            .findAllAsync();
-                                    looperThread.keepStrongReference(responses);
-                                    responses.addChangeListener(new RealmChangeListener<RealmResults<PermissionOfferResponse>>() {
-                                        @Override
-                                        public void onChange(RealmResults<PermissionOfferResponse> responses) {
-                                            PermissionOfferResponse response = responses.first(null);
-                                            if (response != null && response.isSuccessful() && response.getToken().equals(offerToken)) {
-                                                // 7. Response accepted. It should now be possible for user2 to access user1's Realm
-                                                Realm realm = Realm.getInstance(config2);
-                                                looperThread.addTestRealm(realm);
-                                                RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
-                                                looperThread.keepStrongReference(dogs);
-                                                dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
-                                                    @Override
-                                                    public void onChange(RealmResults<Dog> element) {
-                                                        assertEquals(1, element.size());
-                                                        looperThread.testComplete();
-                                                    }
-                                                });
-                                            }
-                                        }
-                                    });
-                                }
-                            });
-                        }
-                    }
-                });
-            }
-        });
-    }
-}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/PartialSyncTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/PartialSyncTests.java
new file mode 100644
index 0000000000..15d3f2ae49
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/PartialSyncTests.java
@@ -0,0 +1,150 @@
+package io.realm.objectserver;
+
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.concurrent.CountDownLatch;
+
+import io.realm.Realm;
+import io.realm.RealmResults;
+import io.realm.StandardIntegrationTest;
+import io.realm.SyncConfiguration;
+import io.realm.SyncManager;
+import io.realm.SyncUser;
+import io.realm.TestHelper;
+import io.realm.TestSyncConfigurationFactory;
+import io.realm.exceptions.RealmException;
+import io.realm.objectserver.model.PartialSyncModule;
+import io.realm.objectserver.model.PartialSyncObjectA;
+import io.realm.objectserver.model.PartialSyncObjectB;
+import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.UserFactory;
+
+import static org.hamcrest.number.OrderingComparison.greaterThan;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class PartialSyncTests extends StandardIntegrationTest {
+    @Rule
+    public TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
+
+    @Test
+    public void partialSync() throws InterruptedException {
+        SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
+
+        final SyncConfiguration syncConfig = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .waitForInitialRemoteData()
+                .modules(new PartialSyncModule())
+                .build();
+
+        final SyncConfiguration partialSyncConfig = configFactory
+                .createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL)
+                .name("partialSync")
+                .modules(new PartialSyncModule())
+                .partialRealm()
+                .build();
+
+        Realm realm = Realm.getInstance(syncConfig);
+        realm.beginTransaction();
+        PartialSyncObjectA objectA = realm.createObject(PartialSyncObjectA.class);
+        objectA.setNumber(0);
+        objectA.setString("realm");
+        objectA = realm.createObject(PartialSyncObjectA.class);
+        objectA.setNumber(1);
+        objectA.setString("");
+        objectA = realm.createObject(PartialSyncObjectA.class);
+        objectA.setNumber(2);
+        objectA.setString("");
+        objectA = realm.createObject(PartialSyncObjectA.class);
+        objectA.setNumber(3);
+        objectA.setString("");
+        objectA = realm.createObject(PartialSyncObjectA.class);
+        objectA.setNumber(4);
+        objectA.setString("realm");
+        objectA = realm.createObject(PartialSyncObjectA.class);
+        objectA.setNumber(5);
+        objectA.setString("sync");
+        objectA = realm.createObject(PartialSyncObjectA.class);
+        objectA.setNumber(6);
+        objectA.setString("partial");
+        objectA = realm.createObject(PartialSyncObjectA.class);
+        objectA.setNumber(7);
+        objectA.setString("partial");
+        objectA = realm.createObject(PartialSyncObjectA.class);
+        objectA.setNumber(8);
+        objectA.setString("partial");
+        objectA = realm.createObject(PartialSyncObjectA.class);
+        objectA.setNumber(9);
+        objectA.setString("partial");
+
+        for (int i = 0; i < 10; i++) {
+            realm.createObject(PartialSyncObjectB.class).setNumber(i);
+        }
+        realm.commitTransaction();
+
+        SyncManager.getSession(syncConfig).uploadAllLocalChanges();
+        realm.close();
+
+        final CountDownLatch latch = new CountDownLatch(2);
+
+        HandlerThread handlerThread = new HandlerThread("background");
+        handlerThread.start();
+        Handler handler = new Handler(handlerThread.getLooper());
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                final Realm partialSyncRealm = Realm.getInstance(partialSyncConfig);
+                assertTrue(partialSyncRealm.isEmpty());
+
+                partialSyncRealm.subscribeToObjects(PartialSyncObjectA.class, "number > 5", new Realm.PartialSyncCallback<PartialSyncObjectA>() {
+
+                    @Override
+                    public void onSuccess(RealmResults<PartialSyncObjectA> results) {
+                        assertEquals(4, results.size());
+                        for (PartialSyncObjectA object : results) {
+                            assertThat(object.getNumber(), greaterThan(5));
+                            assertEquals("partial", object.getString());
+                        }
+                        // make sure the Realm contains only PartialSyncObjectA
+                        assertEquals(0, partialSyncRealm.where(PartialSyncObjectB.class).count());
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(RealmException error) {
+                        fail(error.getMessage());
+                    }
+                });
+
+                // Invalid query
+                partialSyncRealm.subscribeToObjects(PartialSyncObjectA.class, "invalid_property > 5", new Realm.PartialSyncCallback<PartialSyncObjectA>() {
+
+                    @Override
+                    public void onSuccess(RealmResults<PartialSyncObjectA> results) {
+                        fail("Invalid query should not succeed");
+                    }
+
+                    @Override
+                    public void onError(RealmException error) {
+                        assertNotNull(error);
+                        partialSyncRealm.close();
+                        latch.countDown();
+                    }
+                });
+
+            }
+        });
+
+        TestHelper.awaitOrFail(latch);
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
index dfd7b31859..e4847f19aa 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
@@ -16,162 +16,210 @@
 
 package io.realm.objectserver;
 
-import android.content.Context;
-import android.content.Intent;
 import android.os.Looper;
-import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 
+import org.junit.Before;
 import org.junit.Ignore;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
+import java.util.UUID;
+import java.util.concurrent.atomic.AtomicInteger;
 
-import io.realm.ObjectServerError;
 import io.realm.Realm;
 import io.realm.RealmChangeListener;
 import io.realm.RealmResults;
+import io.realm.StandardIntegrationTest;
 import io.realm.SyncConfiguration;
-import io.realm.SyncSession;
 import io.realm.SyncUser;
 import io.realm.objectserver.model.ProcessInfo;
 import io.realm.objectserver.model.TestObject;
-import io.realm.objectserver.service.SendOneCommit;
-import io.realm.objectserver.service.SendsALot;
 import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.RemoteIntegrationTestService;
 import io.realm.objectserver.utils.UserFactory;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.RunTestWithRemoteService;
+import io.realm.rule.RunWithRemoteService;
+import io.realm.services.RemoteTestService;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
+
 
 @RunWith(AndroidJUnit4.class)
-public class ProcessCommitTests extends BaseIntegrationTest {
+public class ProcessCommitTests extends StandardIntegrationTest {
+
+    @Rule
+    public RunWithRemoteService remoteService = new RunWithRemoteService();
+
+    @Before
+    public void before() throws Exception {
+        UserFactory.resetInstance();
+    }
+
+    public static class SimpleCommitRemoteService extends RemoteIntegrationTestService {
+        private static SyncUser user;
+        public static final Step stepA_openRealmAndCreateOneObject = new Step(RemoteTestService.BASE_SIMPLE_COMMIT, 1) {
+
+            @Override
+            protected void run() {
+                user = UserFactory.getInstance().loginWithDefaultUser(Constants.AUTH_URL);
+                String realmUrl = Constants.SYNC_SERVER_URL;
+
+                final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user, realmUrl)
+                        .directory(getService().getRoot())
+                        .build();
+                getService().setRealm(Realm.getInstance(syncConfig));
+                Realm realm = getService().getRealm();
+
+                realm.beginTransaction();
+                ProcessInfo processInfo = realm.createObject(ProcessInfo.class);
+                processInfo.setName("Background_Process1");
+                processInfo.setPid(android.os.Process.myPid());
+                processInfo.setThreadId(Thread.currentThread().getId());
+                realm.commitTransaction();
+                // FIXME: If we close the Realm here, the data won't be able to synced to the main process. Is it a bug
+                // in sync client which stops too early?
+                // Realm is currently configured with stop_immediately. This means the sync session is closed as soon as
+                // the last realm instance is closed. Not doing this would make the Realm lifecycle really
+                // unpredictable. We should have an easy way to wait for all changes to be uploaded though.
+                // Perhaps SyncSession.uploadAllLocalChanges() or something similar to
+                // SyncSesson.downloadAllServerChanges()
+            }
+        };
 
-    // FIXME: Ignore for now. They do still not work. It might be caused by two processes each creating
-    // a Sync Client, but it needs to be investigated.
+        public static final Step stepB_closeRealmAndLogOut = new Step(RemoteTestService.BASE_SIMPLE_COMMIT, 2) {
+            @Override
+            protected void run() {
+                getService().getRealm().close();
+                user.logout();
+            }
+        };
+    }
+
+    // 1. Open a sync Realm and listen to changes.
+    // A. Open the same sync Realm and add one object.
+    // 2. Get the notification, check if the change in A is received.
     @Test
-    @Ignore
-    public void expectServerCommit() throws Throwable {
-        final Throwable[] exception = new Throwable[1];
-        final CountDownLatch testFinished = new CountDownLatch(1);
-        ExecutorService service = Executors.newSingleThreadExecutor();
-        //noinspection unused
-        final Future<?> future = service.submit(new Runnable() {
+    @RunTestInLooperThread
+    @RunTestWithRemoteService(remoteService = SimpleCommitRemoteService.class, onLooperThread = true)
+    @Ignore("See https://github.com/realm/realm-java/issues/5376")
+    public void expectSimpleCommit() {
+        looperThread.runAfterTest(remoteService.afterRunnable);
+        remoteService.createHandler(Looper.myLooper());
+
+        final SyncUser user = UserFactory.getInstance().createDefaultUser(Constants.AUTH_URL);
+        String realmUrl = Constants.SYNC_SERVER_URL;
+        final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user,realmUrl)
+                .directory(looperThread.getRoot())
+                .build();
+        final Realm realm = Realm.getInstance(syncConfig);
+        final RealmResults<ProcessInfo> all = realm.where(ProcessInfo.class).findAll();
+        looperThread.keepStrongReference(all);
+        all.addChangeListener(new RealmChangeListener<RealmResults<ProcessInfo>>() {
             @Override
-            public void run() {
-                try {
-                    Looper.prepare();
-                    Context targetContext = InstrumentationRegistry.getTargetContext();
-
-                    SyncUser user = UserFactory.createDefaultUser(Constants.AUTH_URL);
-                    String realmUrl = Constants.SYNC_SERVER_URL;
-                    final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user, realmUrl)
-                            .name(SendOneCommit.class.getSimpleName())
-                            .errorHandler(new SyncSession.ErrorHandler() {
-                                @Override
-                                public void onError(SyncSession session, ObjectServerError error) {
-                                    fail("Sync failure: " + error);
-                                }
-                            })
-                            .build();
-                    Realm.deleteRealm(syncConfig);//TODO do this in Rule as async tests
-                    final Realm realm = Realm.getInstance(syncConfig);
-                    Intent intent = new Intent(targetContext, SendOneCommit.class);
-                    targetContext.startService(intent);
-                    final RealmResults<ProcessInfo> all = realm.where(ProcessInfo.class).findAll();
-                    all.addChangeListener(new RealmChangeListener<RealmResults<ProcessInfo>>() {
-                        @Override
-                        public void onChange(RealmResults<ProcessInfo> element) {
-                            assertEquals(1, all.size());
-                            assertEquals("Background_Process1", all.get(0).getName());
-                            testFinished.countDown();
-                        }
-                    });
-
-                    Looper.loop();
-
-                } catch (Throwable e) {
-                    exception[0] = e;
-                    testFinished.countDown();
-                }
+            public void onChange(RealmResults<ProcessInfo> element) {
+                assertEquals(1, all.size());
+                assertEquals("Background_Process1", all.get(0).getName());
+                realm.close();
+                user.logout();
+
+                remoteService.triggerServiceStep(SimpleCommitRemoteService.stepB_closeRealmAndLogOut);
+
+                looperThread.testComplete();
             }
         });
-        boolean testTimedOut = testFinished.await(300, TimeUnit.SECONDS);
-        if (exception[0] != null) {
-            throw exception[0];
-        } else if (!testTimedOut) {
-            fail("Test timed out ");
-        }
+
+        remoteService.triggerServiceStep(SimpleCommitRemoteService.stepA_openRealmAndCreateOneObject);
     }
 
-    // FIXME: Ignore for now. They do still not work. It might be caused by two processes each creating
-    // a Sync Client, but it needs to be investigated.
-    //TODO send string from service and match
-    //     replicate integration tests from Cocoa
-    //     add gradle task to start the sh script automatically (create pid file, ==> run or kill existing process
-    //     check the requirement for the issue again
+    public static class ALotCommitsRemoteService extends RemoteIntegrationTestService {
+        private static SyncUser user;
+        public static final Step stepA_openRealm = new Step(RemoteTestService.BASE_A_LOT_COMMITS, 1) {
+
+            @Override
+            protected void run() {
+                user = UserFactory.getInstance().loginWithDefaultUser(Constants.AUTH_URL);
+                String realmUrl = Constants.SYNC_SERVER_URL;
+
+                final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user, realmUrl)
+                        .directory(getService().getRoot())
+                        .name(UUID.randomUUID().toString() + ".realm")
+                        .build();
+                getService().setRealm(Realm.getInstance(syncConfig));
+            }
+        };
+
+        public static final Step stepB_createObjects = new Step(RemoteTestService.BASE_A_LOT_COMMITS, 2) {
+            @Override
+            protected void run() {
+                Realm realm = getService().getRealm();
+                realm.beginTransaction();
+                for (int i = 0; i < 100; i++) {
+                    Number max = realm.where(TestObject.class).findAll().max("intProp");
+                    int pk = max == null ? 0 : max.intValue() + 1;
+                    TestObject testObject = realm.createObject(TestObject.class, pk);
+                    testObject.setStringProp("Str" + pk);
+                }
+                realm.commitTransaction();
+            }
+        };
+
+        public static final Step stepC_closeRealm = new Step(RemoteTestService.BASE_A_LOT_COMMITS, 3) {
+            @Override
+            protected void run() {
+                getService().getRealm().close();
+                user.logout();
+            }
+        };
+    }
+
+    // 1. Open a sync Realm and listen to changes.
+    // A. Open the same sync Realm.
+    // B. Create 100 objects.
+    // 2. Check if the 100 objects are received.
+    // #. Repeat B/2 10 times.
     @Test
-    @Ignore
+    @RunTestWithRemoteService(remoteService = ALotCommitsRemoteService.class, onLooperThread = true)
+    @RunTestInLooperThread
     public void expectALot() throws Throwable {
-        final Throwable[] exception = new Throwable[1];
-        final CountDownLatch testFinished = new CountDownLatch(1);
-        ExecutorService service = Executors.newSingleThreadExecutor();
-        //noinspection unused
-        final Future<?> future = service.submit(new Runnable() {
+        looperThread.runAfterTest(remoteService.afterRunnable);
+        remoteService.createHandler(Looper.myLooper());
+
+        final SyncUser user = UserFactory.getInstance().createDefaultUser(Constants.AUTH_URL);
+        String realmUrl = Constants.SYNC_SERVER_URL;
+        final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user,realmUrl)
+                .directory(looperThread.getRoot())
+                .build();
+        final Realm realm = Realm.getInstance(syncConfig);
+        final RealmResults<TestObject> all = realm.where(TestObject.class).findAllSorted("intProp");
+        looperThread.keepStrongReference(all);
+        final AtomicInteger listenerCalledCounter = new AtomicInteger(0);
+        all.addChangeListener(new RealmChangeListener<RealmResults<TestObject>>() {
             @Override
-            public void run() {
-                try {
-                    Looper.prepare();
-                    Context targetContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
-
-                    SyncUser user = UserFactory.createDefaultUser(Constants.AUTH_URL);
-                    String realmUrl = Constants.SYNC_SERVER_URL_2;
-                    final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user, realmUrl)
-                            .name(SendsALot.class.getSimpleName())
-                            .errorHandler(new SyncSession.ErrorHandler() {
-                                @Override
-                                public void onError(SyncSession session, ObjectServerError error) {
-                                    fail("Sync failure: " + error);
-                                }
-                            })
-                            .build();
-                    Realm.deleteRealm(syncConfig);//TODO do this in Rule as async tests
-                    final Realm realm = Realm.getInstance(syncConfig);
-                    Intent intent = new Intent(targetContext, SendsALot.class);
-                    targetContext.startService(intent);
-
-                    final RealmResults<TestObject> all = realm.where(TestObject.class).findAllSorted("intProp");
-                    all.addChangeListener(new RealmChangeListener<RealmResults<TestObject>>() {
-                        @Override
-                        public void onChange(RealmResults<TestObject> element) {
-                            assertEquals(100, element.size());
-                            for (int i = 0; i < 100; i++) {
-                                assertEquals(i, element.get(i).getIntProp());
-                                assertEquals("property " + i, element.get(i).getStringProp());
-                            }
-
-                            testFinished.countDown();
-                        }
-                    });
-
-                    Looper.loop();
-
-                } catch (Throwable e) {
-                    exception[0] = e;
-                    testFinished.countDown();
+            public void onChange(RealmResults<TestObject> element) {
+                int counter = listenerCalledCounter.incrementAndGet();
+                int size = all.size();
+                if (size == 0) {
+                    listenerCalledCounter.decrementAndGet();
+                    return;
+                }
+                assertEquals(0, size % 100); // Added 100 objects every time.
+                assertEquals(counter * 100 - 1, all.last().getIntProp());
+                assertEquals("Str" + (counter * 100 - 1), all.last().getStringProp());
+                if (counter == 10) {
+                    remoteService.triggerServiceStep(ALotCommitsRemoteService.stepC_closeRealm);
+                    realm.close();
+                    user.logout();
+                    looperThread.testComplete();
+                } else {
+                    remoteService.triggerServiceStep(ALotCommitsRemoteService.stepB_createObjects);
                 }
             }
         });
-        boolean testTimedOut = testFinished.await(30, TimeUnit.SECONDS);
-        if (exception[0] != null) {
-            throw exception[0];
-        } else if (!testTimedOut) {
-            fail("Test timed out ");
-        }
+
+        remoteService.triggerServiceStep(ALotCommitsRemoteService.stepA_openRealm);
+        remoteService.triggerServiceStep(ALotCommitsRemoteService.stepB_createObjects);
     }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
new file mode 100644
index 0000000000..d757107729
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProgressListenerTests.java
@@ -0,0 +1,426 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.net.URI;
+import java.util.Locale;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import javax.annotation.Nonnull;
+
+import io.realm.Progress;
+import io.realm.ProgressListener;
+import io.realm.ProgressMode;
+import io.realm.Realm;
+import io.realm.StandardIntegrationTest;
+import io.realm.SyncConfiguration;
+import io.realm.SyncManager;
+import io.realm.SyncSession;
+import io.realm.SyncUser;
+import io.realm.TestHelper;
+import io.realm.entities.AllTypes;
+import io.realm.log.RealmLog;
+import io.realm.objectserver.utils.Constants;
+import io.realm.objectserver.utils.UserFactory;
+import io.realm.TestSyncConfigurationFactory;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class ProgressListenerTests extends StandardIntegrationTest {
+
+    private static final long TEST_SIZE = 10;
+    @Rule
+    public TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
+
+    @Nonnull
+    private SyncConfiguration createSyncConfig() {
+        SyncUser user = UserFactory.createAdminUser(Constants.AUTH_URL);
+        return configFactory.createSyncConfigurationBuilder(user, Constants.SYNC_SERVER_URL).build();
+    }
+
+    private void writeSampleData(Realm realm) {
+        realm.beginTransaction();
+        for (int i = 0; i < TEST_SIZE; i++) {
+            AllTypes obj = realm.createObject(AllTypes.class);
+            obj.setColumnString("Object " + i);
+        }
+        realm.commitTransaction();
+    }
+
+    private void assertTransferComplete(Progress progress, boolean nonZeroChange) {
+        assertTrue(progress.isTransferComplete());
+        assertEquals(1.0D, progress.getFractionTransferred(), 0.0D);
+        assertEquals(progress.getTransferableBytes(), progress.getTransferredBytes());
+        if (nonZeroChange) {
+            assertTrue(progress.getTransferredBytes() > 0);
+        }
+    }
+
+    // Create remote data for a given user.
+    private URI createRemoteData(SyncUser user) {
+        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, Constants.USER_REALM)
+                .name("remote")
+                .build();
+        final Realm realm = Realm.getInstance(config);
+        final CountDownLatch changesUploaded = new CountDownLatch(1);
+        final SyncSession session = SyncManager.getSession(config);
+        final long beforeAdd = realm.where(AllTypes.class).count();
+        writeSampleData(realm);
+
+        session.addUploadProgressListener(ProgressMode.INDEFINITELY, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    Realm realm = Realm.getInstance(config);
+                    final long afterAdd = realm.where(AllTypes.class).count();
+                    realm.close();
+
+                    RealmLog.warn(String.format(Locale.ENGLISH,"createRemoteData upload %d/%d objects count:%d",
+                            progress.getTransferredBytes(), progress.getTransferableBytes(), afterAdd));
+                    // FIXME: Remove this after https://github.com/realm/realm-object-store/issues/581
+                    if (afterAdd == TEST_SIZE + beforeAdd) {
+                        session.removeProgressListener(this);
+                        changesUploaded.countDown();
+                    } else if (afterAdd < TEST_SIZE + beforeAdd) {
+                        fail("The added objects are more than expected.");
+                    }
+                }
+            }
+        });
+        TestHelper.awaitOrFail(changesUploaded);
+        realm.close();
+        return config.getServerUrl();
+    }
+
+    @Test
+    public void downloadProgressListener_changesOnly() {
+        final CountDownLatch allChangesDownloaded = new CountDownLatch(1);
+        SyncUser userWithData = UserFactory.createUniqueUser(Constants.AUTH_URL);
+        URI serverUrl = createRemoteData(userWithData);
+        SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+
+        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(adminUser, serverUrl.toString()).build();
+        Realm realm = Realm.getInstance(config);
+        SyncSession session = SyncManager.getSession(config);
+        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    assertTransferComplete(progress, true);
+                    Realm realm = Realm.getInstance(config);
+                    assertEquals(TEST_SIZE, realm.where(AllTypes.class).count());
+                    realm.close();
+                    allChangesDownloaded.countDown();
+                }
+            }
+        });
+        TestHelper.awaitOrFail(allChangesDownloaded);
+        realm.close();
+    }
+
+    @Test
+    @Ignore("https://github.com/realm/realm-sync/issues/1770")
+    public void downloadProgressListener_indefinitely() throws InterruptedException {
+        final AtomicInteger transferCompleted = new AtomicInteger(0);
+        final CountDownLatch allChangesDownloaded = new CountDownLatch(1);
+        final CountDownLatch startWorker = new CountDownLatch(1);
+        final SyncUser userWithData = UserFactory.createUniqueUser(Constants.AUTH_URL);
+
+        URI serverUrl = createRemoteData(userWithData);
+
+        // Create worker thread that puts data into another Realm.
+        // This is to avoid blocking one progress listener while waiting for another to complete.
+        Thread worker = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                TestHelper.awaitOrFail(startWorker);
+                createRemoteData(userWithData);
+            }
+        });
+        worker.start();
+
+        SyncUser adminUser = UserFactory.createAdminUser(Constants.AUTH_URL);
+        final SyncConfiguration adminConfig = configFactory.createSyncConfigurationBuilder(adminUser, serverUrl.toString())
+                .name("local")
+                .build();
+        Realm adminRealm = Realm.getInstance(adminConfig);
+        Realm userRealm = Realm.getInstance(configFactory.createSyncConfigurationBuilder(userWithData, Constants.USER_REALM).build()); // Keep session alive
+        SyncSession session = SyncManager.getSession(adminConfig);
+        session.addDownloadProgressListener(ProgressMode.INDEFINITELY, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                Realm adminRealm = Realm.getInstance(adminConfig);
+                long objectCounts = adminRealm.where(AllTypes.class).count();
+                adminRealm.close();
+                // The downloading progress listener could be triggered at the db version where only contains the meta
+                // data. So we start checking from when the first 10 objects downloaded.
+                if (objectCounts != 0 && progress.isTransferComplete()) {
+
+                    switch (transferCompleted.incrementAndGet()) {
+                        case 1: {
+                            assertEquals(TEST_SIZE, objectCounts);
+                            assertTransferComplete(progress, true);
+                            startWorker.countDown();
+                            break;
+                        }
+                        case 2: {
+                            assertTransferComplete(progress, true);
+                            assertEquals(TEST_SIZE * 2, objectCounts);
+                            allChangesDownloaded.countDown();
+                            break;
+                        }
+                        default:
+                            fail("Transfer complete called too many times:" + transferCompleted.get());
+                    }
+                    RealmLog.warn(String.format(
+                            Locale.ENGLISH,"downloadProgressListener_indefinitely download %d/%d objects count:%d",
+                            progress.getTransferredBytes(), progress.getTransferableBytes(), objectCounts));
+                }
+            }
+        });
+        TestHelper.awaitOrFail(allChangesDownloaded);
+        adminRealm.close();
+        userRealm.close();
+        // worker thread will hang if logout happens before listener triggered.
+        worker.join();
+        userWithData.logout();
+        adminUser.logout();
+    }
+
+    // Make sure that a ProgressListener continues to report the correct thing, even if it crashed
+    @Test
+    public void uploadListener_worksEvenIfCrashed() throws InterruptedException {
+        final AtomicInteger transferCompleted = new AtomicInteger(0);
+        final CountDownLatch testDone = new CountDownLatch(1);
+        final SyncConfiguration config = createSyncConfig();
+        Realm realm = Realm.getInstance(config);
+
+        writeSampleData(realm); // Write first batch of sample data
+        SyncSession session = SyncManager.getSession(config);
+        session.addUploadProgressListener(ProgressMode.INDEFINITELY, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    switch(transferCompleted.incrementAndGet()) {
+                        case 1:
+                            Realm realm = Realm.getInstance(config);
+                            writeSampleData(realm);
+                            realm.close();
+                            throw new RuntimeException("Crashing the changelistener");
+                        case 2:
+                            assertTransferComplete(progress, true);
+                            testDone.countDown();
+                            break;
+                        default:
+                            fail("Unsupported number of transfers completed: " + transferCompleted.get());
+                    }
+                }
+            }
+        });
+
+        TestHelper.awaitOrFail(testDone);
+        realm.close();
+    }
+
+    @Test
+    public void uploadProgressListener_changesOnly() {
+        final CountDownLatch allChangeUploaded = new CountDownLatch(1);
+        SyncConfiguration config = createSyncConfig();
+        Realm realm = Realm.getInstance(config);
+        writeSampleData(realm);
+
+        SyncSession session = SyncManager.getSession(config);
+        session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    assertTransferComplete(progress, true);
+                    allChangeUploaded.countDown();
+                }
+            }
+        });
+
+        TestHelper.awaitOrFail(allChangeUploaded);
+        realm.close();
+    }
+
+    @Test
+    public void uploadProgressListener_indefinitely() {
+        final AtomicInteger transferCompleted = new AtomicInteger(0);
+        final CountDownLatch testDone = new CountDownLatch(1);
+        final SyncConfiguration config = createSyncConfig();
+        Realm realm = Realm.getInstance(config);
+
+        writeSampleData(realm); // Write first batch of sample data
+        SyncSession session = SyncManager.getSession(config);
+        session.addUploadProgressListener(ProgressMode.INDEFINITELY, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                Realm tempRealm = Realm.getInstance(config);
+                long objectsCount = tempRealm.where(AllTypes.class).count();
+                tempRealm.close();
+                // FIXME: Remove the objectsCount checking when
+                // https://github.com/realm/realm-object-store/issues/581 gets fixed
+                if (objectsCount != 0 && progress.isTransferComplete()) {
+                    switch(transferCompleted.incrementAndGet()) {
+                        case 1:
+                            Realm realm = Realm.getInstance(config);
+                            writeSampleData(realm);
+                            realm.close();
+                            break;
+                        case 2:
+                            assertTransferComplete(progress, true);
+                            testDone.countDown();
+                            break;
+                        default:
+                            fail("Unsupported number of transfers completed: " + transferCompleted.get());
+                    }
+                }
+            }
+        });
+
+        TestHelper.awaitOrFail(testDone);
+        realm.close();
+    }
+
+    @Test
+    public void addListenerInsideCallback() {
+        final CountDownLatch allChangeUploaded = new CountDownLatch(1);
+        final SyncConfiguration config = createSyncConfig();
+        Realm realm = Realm.getInstance(config);
+        writeSampleData(realm);
+
+        final SyncSession session = SyncManager.getSession(config);
+        session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    Realm realm = Realm.getInstance(config);
+                    writeSampleData(realm);
+                    realm.close();
+                    session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+                        @Override
+                        public void onChange(Progress progress) {
+                            if (progress.isTransferComplete()) {
+                                allChangeUploaded.countDown();
+                            }
+                        }
+                    });
+                }
+            }
+        });
+
+        TestHelper.awaitOrFail(allChangeUploaded);
+        realm.close();
+    }
+
+    @Test
+    public void addListenerInsideCallback_mixProgressModes() {
+        final CountDownLatch allChangeUploaded = new CountDownLatch(3);
+        final AtomicBoolean progressCompletedReported = new AtomicBoolean(false);
+        final SyncConfiguration config = createSyncConfig();
+        Realm realm = Realm.getInstance(config);
+        writeSampleData(realm);
+
+        final SyncSession session = SyncManager.getSession(config);
+        session.addUploadProgressListener(ProgressMode.INDEFINITELY, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                if (progress.isTransferComplete()) {
+                    allChangeUploaded.countDown();
+                    if (progressCompletedReported.compareAndSet(false, true)) {
+                        Realm realm = Realm.getInstance(config);
+                        writeSampleData(realm);
+                        realm.close();
+                        session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+                            @Override
+                            public void onChange(Progress progress) {
+                                if (progress.isTransferComplete()) {
+                                    allChangeUploaded.countDown();
+                                }
+                            }
+                        });
+                    }
+                }
+            }
+        });
+
+        TestHelper.awaitOrFail(allChangeUploaded);
+        realm.close();
+    }
+
+    @Test
+    public void addProgressListener_triggerImmediatelyWhenRegistered() {
+        final SyncConfiguration config = createSyncConfig();
+        Realm realm = Realm.getInstance(config);
+        SyncSession session = SyncManager.getSession(config);
+
+        checkListener(session, ProgressMode.INDEFINITELY);
+        checkListener(session, ProgressMode.CURRENT_CHANGES);
+
+        realm.close();
+    }
+
+    @Test
+    public void uploadListener_keepIncreasingInSize() {
+        SyncConfiguration config = createSyncConfig();
+        Realm realm = Realm.getInstance(config);
+        SyncSession session = SyncManager.getSession(config);
+        for (int i = 0; i < 10; i++) {
+            final CountDownLatch changesUploaded = new CountDownLatch(1);
+            writeSampleData(realm);
+            final int testNo = i;
+            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, new ProgressListener() {
+                @Override
+                public void onChange(Progress progress) {
+                    RealmLog.info("Test %s -> %s", Integer.toString(testNo), progress.toString());
+                    if (progress.isTransferComplete()) {
+                        assertTransferComplete(progress, true);
+                        changesUploaded.countDown();
+                    }
+                }
+            });
+            TestHelper.awaitOrFail(changesUploaded);
+        }
+
+        realm.close();
+    }
+
+    private void checkListener(SyncSession session, ProgressMode progressMode) {
+        final CountDownLatch listenerCalled = new CountDownLatch(1);
+        session.addDownloadProgressListener(progressMode, new ProgressListener() {
+            @Override
+            public void onChange(Progress progress) {
+                listenerCalled.countDown();
+            }
+        });
+        TestHelper.awaitOrFail(listenerCalled);
+    }
+
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncModule.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncModule.java
new file mode 100644
index 0000000000..6552293cf7
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncModule.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.model;
+
+import io.realm.annotations.RealmModule;
+
+@RealmModule(classes = {PartialSyncObjectA.class, PartialSyncObjectB.class})
+public class PartialSyncModule {
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncObjectA.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncObjectA.java
new file mode 100644
index 0000000000..4af96f4768
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncObjectA.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.model;
+
+import io.realm.RealmObject;
+
+public class PartialSyncObjectA extends RealmObject {
+    private int number;
+    private String string;
+
+    public int getNumber() {
+        return number;
+    }
+
+    public void setNumber(int number) {
+        this.number = number;
+    }
+
+    public String getString() {
+        return string;
+    }
+
+    public void setString(String string) {
+        this.string = string;
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncObjectB.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncObjectB.java
new file mode 100644
index 0000000000..7a6c453229
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/PartialSyncObjectB.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.model;
+
+import io.realm.RealmObject;
+
+public class PartialSyncObjectB extends RealmObject {
+    private int number;
+    private String firstString;
+    private String secondString;
+
+    public int getNumber() {
+        return number;
+    }
+
+    public void setNumber(int number) {
+        this.number = number;
+    }
+
+    public String getFirstString() {
+        return firstString;
+    }
+
+    public void setFirstString(String firstString) {
+        this.firstString = firstString;
+    }
+
+    public String getSecondString() {
+        return secondString;
+    }
+
+    public void setSecondString(String secondString) {
+        this.secondString = secondString;
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/TestObject.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/TestObject.java
index 2bd27a6ef8..43b378d36a 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/TestObject.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/model/TestObject.java
@@ -17,9 +17,12 @@
 package io.realm.objectserver.model;
 
 import io.realm.RealmObject;
+import io.realm.annotations.PrimaryKey;
 
 public class TestObject extends RealmObject {
+    @PrimaryKey
     private int intProp;
+
     private String stringProp;
 
     public int getIntProp() {
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/package-info.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/package-info.java
new file mode 100644
index 0000000000..77bbb31d9e
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/package-info.java
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+@javax.annotation.ParametersAreNonnullByDefault
+package io.realm.objectserver;
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendOneCommit.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendOneCommit.java
deleted file mode 100644
index 4653b26211..0000000000
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendOneCommit.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.objectserver.service;
-
-import android.app.Service;
-import android.content.Intent;
-import android.os.IBinder;
-
-import io.realm.Realm;
-import io.realm.SyncConfiguration;
-import io.realm.SyncUser;
-import io.realm.objectserver.model.ProcessInfo;
-import io.realm.objectserver.utils.Constants;
-import io.realm.objectserver.utils.UserFactory;
-
-/**
- * Open a sync Realm on a different process, then send one commit.
- */
-public class SendOneCommit extends Service {
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-        Realm.init(getApplicationContext());
-        SyncUser user = UserFactory.createDefaultUser(Constants.AUTH_URL);
-        String realmUrl = Constants.SYNC_SERVER_URL;
-        final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user, realmUrl)
-                .name(SendOneCommit.class.getSimpleName())
-                .build();
-        Realm.deleteRealm(syncConfig);
-        Realm realm = Realm.getInstance(syncConfig);
-
-        realm.beginTransaction();
-        ProcessInfo processInfo = realm.createObject(ProcessInfo.class);
-        processInfo.setName("Background_Process1");
-        processInfo.setPid(android.os.Process.myPid());
-        processInfo.setThreadId(Thread.currentThread().getId());
-        realm.commitTransaction();
-
-        realm.close();//FIXME the close may not give a chance to the sync client to process/upload the changeset
-    }
-
-    @Override
-    public IBinder onBind(Intent intent) {
-        return null;
-    }
-}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendsALot.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendsALot.java
deleted file mode 100644
index dca642beb2..0000000000
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/service/SendsALot.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.objectserver.service;
-
-import android.app.Service;
-import android.content.Intent;
-import android.os.IBinder;
-
-import io.realm.Realm;
-import io.realm.SyncConfiguration;
-import io.realm.SyncUser;
-import io.realm.objectserver.model.TestObject;
-import io.realm.objectserver.utils.Constants;
-import io.realm.objectserver.utils.UserFactory;
-
-/**
- * Open a sync Realm on a different process, then send one commit.
- */
-public class SendsALot extends Service {
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-        Realm.init(getApplicationContext());
-        SyncUser user = UserFactory.createDefaultUser(Constants.AUTH_URL);
-        String realmUrl = Constants.SYNC_SERVER_URL_2;
-        final SyncConfiguration syncConfig = new SyncConfiguration.Builder(user, realmUrl)
-                .name(SendsALot.class.getSimpleName())
-                .build();
-        Realm.deleteRealm(syncConfig);
-        Realm realm = Realm.getInstance(syncConfig);
-
-        realm.beginTransaction();
-
-        for (int i = 0; i < 100; i++) {
-            TestObject testObject = realm.createObject(TestObject.class);
-            testObject.setIntProp(i);
-            testObject.setStringProp("property " + i);
-        }
-        realm.commitTransaction();
-
-        realm.close();//FIXME the close may not give a chance to the sync client to process/upload the changeset
-    }
-
-
-    @Override
-    public IBinder onBind(Intent intent) {
-        return null;
-    }
-}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/suite/IntegrationTestSuite.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/suite/IntegrationTestSuite.java
new file mode 100644
index 0000000000..d13f3546d1
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/suite/IntegrationTestSuite.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.suite;
+
+
+import org.junit.runner.RunWith;
+import org.junit.runners.Suite;
+
+import io.realm.SSLConfigurationTests;
+import io.realm.SyncedRealmTests;
+import io.realm.objectserver.AuthTests;
+import io.realm.objectserver.EncryptedSynchronizedRealmTests;
+import io.realm.objectserver.ProcessCommitTests;
+import io.realm.objectserver.ProgressListenerTests;
+import io.realm.SyncSessionTests;
+
+// Test suite includes all integration tests. Makes it easy to run all integration tests in the Android Studio.
+@RunWith(Suite.class)
+@Suite.SuiteClasses({
+        SSLConfigurationTests.class,
+        SyncedRealmTests.class,
+        AuthTests.class,
+        EncryptedSynchronizedRealmTests.class,
+        ProcessCommitTests.class,
+        ProgressListenerTests.class,
+        SyncSessionTests.class})
+public class IntegrationTestSuite {
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
index 02d9ddf64c..3f2e74c5ad 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
@@ -18,11 +18,13 @@
 
 public class Constants {
 
-    public static final String SYNC_SERVER_URL = "realm://127.0.0.1/tests";
-    public static final String SYNC_SERVER_URL_2 = "realm://127.0.0.1/tests2";
+    public static String HOST = "127.0.0.1";
+    public static final String USER_REALM = "realm://" + HOST + ":9080/~/tests";
+    public static final String USER_REALM_2 = "realm://" + HOST + ":9080/~/tests2";
+    public static final String USER_REALM_SECURE = "realms://" + HOST + ":9443/~/tests";
+    public static final String SYNC_SERVER_URL = "realm://" + HOST + ":9080/~/tests";
+    public static final String SYNC_SERVER_URL_2 = "realm://" + HOST + "/~/tests2";
 
-    public static final String AUTH_SERVER_URL = "http://127.0.0.1:9080/";
+    public static final String AUTH_SERVER_URL = "http://" + HOST + ":9080/";
     public static final String AUTH_URL = AUTH_SERVER_URL + "auth";
-
-    public static final long TEST_TIMEOUT_SECS = 300;
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
index 8770019e59..9c4d3881dc 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
@@ -16,27 +16,39 @@
 
 package io.realm.objectserver.utils;
 
+import android.os.SystemClock;
+import android.util.Log;
+
 import java.io.IOException;
+import java.net.SocketTimeoutException;
+import java.util.concurrent.TimeUnit;
 
 import io.realm.log.RealmLog;
 import okhttp3.Headers;
+import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
+import okhttp3.RequestBody;
 import okhttp3.Response;
 
 /**
  * Start and Stop the node server responsible of creating a
  * temp directory & start a sync server on it for each unit test.
+ *
+ * WARNING: This class is called before Realm is initialized, so RealmLog cannot be used.
  */
 public class HttpUtils {
+    // TODO If the timeouts are longer than the test timeout you risk getting
+    // "Realm could not be deleted errors".
     private final static OkHttpClient client = new OkHttpClient.Builder()
             .retryOnConnectionFailure(true)
             .build();
 
     // adb reverse tcp:8888 tcp:8888
     // will forward this query to the host, running the integration test server on 8888
-    private final static String START_SERVER = "http://127.0.0.1:8888/start";
-    private final static String STOP_SERVER = "http://127.0.0.1:8888/stop";
+    private static final String START_SERVER = "http://127.0.0.1:8888/start";
+    private static final String STOP_SERVER = "http://127.0.0.1:8888/stop";
+    public static final String TAG = "IntegrationTestServer";
 
     public static void startSyncServer() throws Exception {
         Request request = new Request.Builder()
@@ -46,53 +58,9 @@ public static void startSyncServer() throws Exception {
         Response response = client.newCall(request).execute();
         if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-        Headers responseHeaders = response.headers();
-        for (int i = 0; i < responseHeaders.size(); i++) {
-            RealmLog.debug(responseHeaders.name(i) + ": " + responseHeaders.value(i));
-        }
-
-        RealmLog.debug(response.body().string());
-
-        // FIXME: Server ready checking should be done in the control server side!
-        if (!waitAuthServerReady()) {
-            stopSyncServer();
-            throw new RuntimeException("Auth server cannot be started.");
-        }
-    }
-
-    // Checking the server
-    private static boolean waitAuthServerReady() throws InterruptedException {
-        int retryTimes = 20;
-
-        // Dummy invalid request, which will trigger a 400 (BAD REQUEST), but indicate the auth
-        // server is responsive
-        Request request = new Request.Builder()
-                .url(Constants.AUTH_SERVER_URL)
-                .build();
-
-        while (retryTimes != 0) {
-            Response response = null;
-            try {
-                response = client.newCall(request).execute();
-                if (response.isSuccessful()) {
-                    return true;
-                }
-                RealmLog.error("Error response from auth server: %s", response.toString());
-            } catch (IOException e) {
-                // TODO As long as the auth server hasn't started yet, OKHttp cannot parse the response
-                // correctly. At this point it is unknown weather is a bug in OKHttp or an
-                // unknown host is reported. This can cause a lot of "false" errors in the log.
-                RealmLog.error(e);
-                Thread.sleep(500);
-            } finally {
-                if (response != null) {
-                    response.close();
-                }
-            }
-            retryTimes--;
-        }
-
-        return false;
+        // Work around race condition between starting ROS and logging in first user
+        // See https://github.com/realm/ros/issues/389
+        SystemClock.sleep(2000);
     }
 
     public static void stopSyncServer() throws Exception {
@@ -102,12 +70,5 @@ public static void stopSyncServer() throws Exception {
 
         Response response = client.newCall(request).execute();
         if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-        Headers responseHeaders = response.headers();
-        for (int i = 0; i < responseHeaders.size(); i++) {
-            RealmLog.debug(responseHeaders.name(i) + ": " + responseHeaders.value(i));
-        }
-
-        RealmLog.debug(response.body().string());
     }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/RemoteIntegrationTestService.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/RemoteIntegrationTestService.java
new file mode 100644
index 0000000000..d80d79abba
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/RemoteIntegrationTestService.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.utils;
+
+import io.realm.SyncManager;
+import io.realm.services.RemoteTestService;
+
+// Remote test service base class which contains some initialization for sync.
+public class RemoteIntegrationTestService extends RemoteTestService {
+    public RemoteIntegrationTestService() {
+        super();
+        SyncManager.Debug.skipOnlineChecking = true;
+        SyncManager.Debug.separatedDirForSyncManager = true;
+    }
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/StringOnlyModule.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/StringOnlyModule.java
new file mode 100644
index 0000000000..e935a0b1b9
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/StringOnlyModule.java
@@ -0,0 +1,8 @@
+package io.realm.objectserver.utils;
+
+import io.realm.annotations.RealmModule;
+import io.realm.entities.StringOnly;
+
+@RealmModule(classes = { StringOnly.class})
+public class StringOnlyModule {
+}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
index 1145f8a310..24345677b3 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
@@ -16,24 +16,144 @@
 
 package io.realm.objectserver.utils;
 
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.SystemClock;
+
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import io.realm.AuthenticationListener;
+import io.realm.ErrorCode;
+import io.realm.ObjectServerError;
+import io.realm.Realm;
+import io.realm.RealmConfiguration;
 import io.realm.SyncCredentials;
+import io.realm.SyncManager;
 import io.realm.SyncUser;
+import io.realm.TestHelper;
+import io.realm.log.RealmLog;
+
+import static org.junit.Assert.fail;
+
 
+// Helper class to retrieve users with same IDs even in multi-processes.
 // Must be in `io.realm.objectserver` to work around package protected methods.
+// This require Realm.init() to be called before using this class.
 public class UserFactory {
+    private static final String PASSWORD = "myPassw0rd";
+    // Since the integration tests need to use the same user for different processes, we create a new user name when the
+    // test starts and store it in a Realm. Then it can be retrieved for every process.
+    private String userName;
+    private static UserFactory instance;
+    private static RealmConfiguration configuration = new RealmConfiguration.Builder()
+            .name("user-factory.realm")
+            .build();
+
+    private UserFactory(String userName) {
+        this.userName = userName;
+    }
+
+    public SyncUser loginWithDefaultUser(String authUrl) {
+        SyncCredentials credentials = SyncCredentials.usernamePassword(userName, PASSWORD, false);
+        return SyncUser.login(credentials, authUrl);
+    }
+
+    /**
+     * Create a unique user, using the standard authentification URL used by the test server.
+     */
+    public static SyncUser createUniqueUser() {
+        return createUniqueUser(Constants.AUTH_URL);
+    }
 
-    public static SyncUser createDefaultUser(String authUrl) {
-        return createUser(authUrl, "test-user");
+    public static SyncUser createUser(String username) {
+        return createUser(username, Constants.AUTH_URL);
     }
 
-    public static SyncUser createUser(String authUrl, String userIdentifier) {
-        SyncCredentials credentials = SyncCredentials.usernamePassword(userIdentifier, "myPassw0rd", true);
+    public static SyncUser createUniqueUser(String authUrl) {
+        String uniqueName = UUID.randomUUID().toString();
+        return createUser(uniqueName);
+    }
+
+    private static SyncUser createUser(String username, String authUrl) {
+        SyncCredentials credentials = SyncCredentials.usernamePassword(username, PASSWORD, true);
+        return SyncUser.login(credentials, authUrl);
+    }
+
+
+    public SyncUser createDefaultUser(String authUrl) {
+        SyncCredentials credentials = SyncCredentials.usernamePassword(userName, PASSWORD, true);
         return SyncUser.login(credentials, authUrl);
     }
 
     public static SyncUser createAdminUser(String authUrl) {
         // `admin` required as user identifier to be granted admin rights.
-        SyncCredentials credentials = SyncCredentials.custom("admin", "debug", null);
+        // ROS 2.0 comes with a default admin user named "realm-admin" with password "".
+        SyncCredentials credentials = SyncCredentials.usernamePassword("realm-admin", "", false);
         return SyncUser.login(credentials, authUrl);
     }
+
+    // Since we don't have a reliable way to reset the sync server and client, just use a new user factory for every
+    // test case.
+    public static void resetInstance() {
+        instance = null;
+        Realm realm = Realm.getInstance(configuration);
+        UserFactoryStore store = realm.where(UserFactoryStore.class).findFirst();
+        realm.beginTransaction();
+        if (store == null) {
+            store = realm.createObject(UserFactoryStore.class);
+        }
+        store.setUserName(UUID.randomUUID().toString());
+        realm.commitTransaction();
+        realm.close();
+    }
+
+    // The @Before method will be called before the looper tests finished. We need to find a better place to call this.
+    public static void clearInstance()  {
+        Realm realm = Realm.getInstance(configuration);
+        realm.beginTransaction();
+        realm.delete(UserFactoryStore.class);
+        realm.commitTransaction();
+        realm.close();
+    }
+
+    public static synchronized UserFactory getInstance() {
+        if (instance == null)  {
+            Realm realm = Realm.getInstance(configuration);
+            UserFactoryStore store = realm.where(UserFactoryStore.class).findFirst();
+            if (store == null || store.getUserName() == null) {
+                throw new IllegalStateException("Current user has not been set. Call resetInstance() first.");
+            }
+
+            instance = new UserFactory(store.getUserName());
+            realm.close();
+        }
+        RealmLog.debug("UserFactory.getInstance, the default user is " + instance.userName + " .");
+        return instance;
+    }
+
+    /**
+     * Blocking call that logs out all users
+     */
+    public static void logoutAllUsers() {
+        final CountDownLatch allUsersLoggedOut = new CountDownLatch(1);
+        final HandlerThread ht = new HandlerThread("LoggingOutUsersThread");
+        ht.start();
+        Handler handler = new Handler(ht.getLooper());
+        handler.post(new Runnable() {
+            @Override
+            public void run() {
+                Map<String, SyncUser> users = SyncUser.all();
+                for (SyncUser user : users.values()) {
+                    user.logout();
+                }
+                allUsersLoggedOut.countDown();
+
+            }
+        });
+        TestHelper.awaitOrFail(allUsersLoggedOut);
+        ht.quit();
+    }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactoryStore.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactoryStore.java
new file mode 100644
index 0000000000..80b8bac60c
--- /dev/null
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactoryStore.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.objectserver.utils;
+
+import io.realm.RealmObject;
+
+// Used by UserFactory. Storing current user name for testing to share the same user name across processes.
+public class UserFactoryStore extends RealmObject {
+    private String userName;
+
+    public String getUserName() {
+        return userName;
+    }
+
+    public void setUserName(String userName) {
+        this.userName = userName;
+    }
+}
diff --git a/realm/realm-library/testLibs/backlinks-missing-field-source.jar b/realm/realm-library/testLibs/backlinks-missing-field-source.jar
deleted file mode 100644
index a34490c3ca..0000000000
Binary files a/realm/realm-library/testLibs/backlinks-missing-field-source.jar and /dev/null differ
diff --git a/realm/realm-library/testLibs/backlinks-missing-field-target.jar b/realm/realm-library/testLibs/backlinks-missing-field-target.jar
deleted file mode 100644
index 91a513c5b3..0000000000
Binary files a/realm/realm-library/testLibs/backlinks-missing-field-target.jar and /dev/null differ
diff --git a/realm/realm-library/testLibs/backlinks-wrong-type-source.jar b/realm/realm-library/testLibs/backlinks-wrong-type-source.jar
deleted file mode 100644
index 67cbdbefea..0000000000
Binary files a/realm/realm-library/testLibs/backlinks-wrong-type-source.jar and /dev/null differ
diff --git a/realm/realm-library/testLibs/backlinks-wrong-type-target.jar b/realm/realm-library/testLibs/backlinks-wrong-type-target.jar
deleted file mode 100644
index 3745742b94..0000000000
Binary files a/realm/realm-library/testLibs/backlinks-wrong-type-target.jar and /dev/null differ
diff --git a/tools/release.sh b/tools/release.sh
index 33a01831b7..5d38989bb5 100755
--- a/tools/release.sh
+++ b/tools/release.sh
@@ -2,7 +2,6 @@
 
 # Script to make release on the local machine.
 # See https://github.com/realm/realm-wiki/wiki/Java-Release-Checklist for more details.
-# FIXME: Only patch release is supported now.
 
 set -euo pipefail
 IFS=$'\n\t'
@@ -93,14 +92,36 @@ prepare_branch() {
     git fetch --all
     git checkout releases
     git reset --hard origin/releases
-    if [[ "$BRANCH_TO_RELEASE" != "releases" ]] ; then
-        echo "Releasing from other branches than 'releases' is not supported right now."
-        exit -1
-    fi
-
     git clean -xfd
     git submodule update --init --recursive
 
+    # Merge the branch to the releases branch and check the CHANGELOG.md
+    if [[ "$BRANCH_TO_RELEASE" != "releases" ]] ; then
+        git merge "origin/$BRANCH_TO_RELEASE"
+        git submodule update --init --recursive
+
+        while true
+        do
+            read -r -p "Type the command to edit CHANGELOG.md, default(vim):" editor
+            if [ -z "$editor" ] ; then
+                editor="vim"
+            fi
+            "$editor" CHANGELOG.md
+
+            read -r -p "Please merge the unreleased entries in the 'CHANGELOG.md' and then press any key to continue..." _
+            if [ "$(grep -c "YYYY-MM-DD" CHANGELOG.md)" -eq 1 ] ; then
+                break
+            else
+                echo "There are more than one or none unreleased entries in the 'CHANGELOG.md'."
+            fi
+        done
+        # CHANGELOG.md is modified.
+        if ! git diff-index --quiet HEAD CHANGELOG.md ; then
+            git add CHANGELOG.md
+            git commit -m "Merge entries in changelog"
+        fi
+    fi
+
     if ! grep -q "SNAPSHOT" version.txt ; then
         echo "'version.txt' doesn't contain 'SNAPSHOT'."
         exit -1
@@ -124,7 +145,7 @@ prepare_branch() {
 
     # Update date in change log
     cur_date=$(date "+%F")
-    sed -i "1 s/YYYY-MM-DD/${cur_date}/" CHANGELOG.md
+    sed "1 s/YYYY-MM-DD/${cur_date}/" CHANGELOG.md > CHANGELOG.md.tmp && mv CHANGELOG.md.tmp CHANGELOG.md
     git add CHANGELOG.md
     git commit -m "Update changelog date"
 
@@ -144,7 +165,7 @@ build() {
     check_adb_device
 
     # Verify examples
-    (cd examples && ./gradlew uninstallAll && ./gradlew monkeyDebug)
+    (cd examples && ./gradlew clean uninstallAll && ./gradlew monkeyDebug)
 }
 
 upload_to_bintray() {
@@ -179,7 +200,7 @@ publish_distribution() {
     # Test
     check_adb_device
     pushd examples/
-    ./gradlew uninstallAll
+    ./gradlew clean uninstallAll
     ./gradlew monkeyRelease
     popd
     popd
@@ -191,8 +212,14 @@ push_release() {
 
     # Push branch & tag
     git checkout releases
-    git push origin releases
-    git push origin "v${VERSION}"
+     
+     # Don't push to releases branch if we are doing a beta release.
+    if [[ ! "$VERSION" =~ [a-zA-Z] ]] ; then
+        git push origin releases
+        git push origin "v${VERSION}"
+    else
+        echo "Non-final release. Release was not pushed to Github. Remember to remove commits on `releases` branch manually."
+    fi
 }
 
 publish_javadoc() {
@@ -213,8 +240,9 @@ publish_javadoc() {
         esac
     done
     git clean -xfd ./source/en/docs/java/
+    bundle update
     bundle exec rake generate:java_docs[$VERSION]
-    cp -R "${REALM_JAVA_PATH}/realm/realm-library/build/docs/javadoc/*" ./source/en/docs/java/latest/api/
+    cp -R "${REALM_JAVA_PATH}"/realm/realm-library/build/docs/javadoc/* ./source/en/docs/java/latest/api/
     bundle exec rake generate:inject_ga_latest_java_api
     git add ./source/en/docs/java/
     git commit -m "Release realm-java doc ${VERSION}"
diff --git a/tools/sync_test_server/Dockerfile b/tools/sync_test_server/Dockerfile
index cddec14681..c4f792b11c 100644
--- a/tools/sync_test_server/Dockerfile
+++ b/tools/sync_test_server/Dockerfile
@@ -1,23 +1,18 @@
-FROM ubuntu:16.04
+FROM node:6.11.4
 
 ARG ROS_DE_VERSION
 
-# Add realm repo
-RUN apt-get update -qq \
-    && apt-get install -y curl npm \
-    # && curl -s https://packagecloud.io/install/repositories/realm/realm/script.deb.sh \
-    && curl -s https://packagecloud.io/install/repositories/realm/realm-testing/script.deb.sh | bash
+# Install realm object server
+RUN npm install -g realm-object-server@$ROS_DE_VERSION -S
 
-# ROS npm dependencies
-RUN npm init -y
-RUN npm install winston temp httpdispatcher@1.0.0
+# Install test server dependencies
+RUN npm install winston temp httpdispatcher@1.0.0 fs-extra moment
 
-COPY keys/private.pem keys/public.pem configuration.yml /
+COPY keys/public.pem keys/private.pem keys/127_0_0_1-server.key.pem keys/127_0_0_1-chain.crt.pem configuration.yml /
 COPY ros-testing-server.js /usr/bin/
 
-# Install realm object server
-RUN apt-get update -qq \
-    && apt-get install -y realm-object-server-developer=$ROS_DE_VERSION \
-    && apt-get clean
+#Bypass the ROS license check
+ENV DOCKER_DATA_PATH /
+ENV ROS_TOS_EMAIL_ADDRESS 'ci@realm.io'
 
 CMD /usr/bin/ros-testing-server.js /tmp/ros-testing-server.log
diff --git a/tools/sync_test_server/configuration.yml b/tools/sync_test_server/configuration.yml
index 702e4c336a..9b73a0c68c 100644
--- a/tools/sync_test_server/configuration.yml
+++ b/tools/sync_test_server/configuration.yml
@@ -62,7 +62,10 @@ auth:
     ## The validity duration for Access Tokens. This should be a fairly small
     ## number, especially if you are concerned with revocations being applied
     ## quickly. This value is represented in seconds. Default: 1 minute.
-    # access_token: 60
+    ##
+    ## WARNING : Changing this value may impact the timeout of the refresh
+    ##           token test (AuthTests#preemptiveTokenRefresh)
+    access_token: 20
 
   providers:
     ## Providers of authentication tokens. Each provider has a configuration
@@ -103,7 +106,28 @@ auth:
     ## This enables authentication via a Facebook access token for a specific app.
     ## This provider needs no configuration (uncommenting the next line enables it).
     # facebook: {}
-    debug: {}
+
+    ## This enables authentication via an Azure Active Directory access token for a specific directory.
+    # azuread:
+      ## The Directory Id as retrieved from the Active Directory properties in the Azure portal.
+      # tenant_id: '01234567-89ab-cdef-0123-4567890a'
+
+    ## This would enable a custom authentication provider with the name "custom/twitter".
+    ## The prefix "custom/" is necessary for all authentication providers using a custom
+    ## implementation to ensure forwards-compatiblity and avoid name clashes.
+    # custom/twitter:
+      ## The implementation to be used. This can be either one of the predefined
+      ## implementations under a custom name or a custom implementation found at
+      ## the include_path or if not given at the auth:providers_include_path.
+      # implementation: custom_provider_implementation.js
+
+      ## The include path to use for this providers custom implementation.
+      # include_path: /~/.realm/auth
+
+      ## Beyond that custom implementations can define custom configuration
+      ## options which will be populated to their configuration and merged with
+      ## the default values they can define.
+     debug: {}
 
 ## ----------------------------------------------------------------------------
 
@@ -154,31 +178,31 @@ proxy:
     ## The address/interface on which the HTTP proxy module should listen. This defaults
     ## to 127.0.0.1. If you wish to listen on all available interfaces,
     ## uncomment the following line.
-    listen_address: '::'
+    listen_address: '0.0.0.0'
 
     ## The port that the HTTP proxy module should bind to.
-    # listen_port: 9080
+    listen_port: 9080
 
   https:
     ## Whether or not to enable the HTTPS proxy module. It enables multiplexing requests
     ## by forwarding incoming requests on a single port to all services.
     ## Note that even if it enabled, the HTTPS proxy will only start if supplied
     ## with a valid pair of certificates through certificate_path and private_key_path below.
-    # enable: false
+     enable: true
 
     ## The path to the certificate and private keys (in PEM format) that will be used
     ## to set up the HTTPS server accepting connections.
     ## These configuration options are MANDATORY to start the HTTPS proxy module.
-    # certificate_path: 'keys/https-proxy.crt'
-    # private_key_path: 'keys/https-proxy.key'
+     certificate_path: '/127_0_0_1-chain.crt.pem'
+     private_key_path: '/127_0_0_1-server.key.pem'
 
     ## The address/interface on which the HTTPS proxy module should listen. This defaults
     ## to 127.0.0.1. If you wish to listen on all available interfaces,
     ## uncomment the following line.
-    # listen_address: '::'
+     listen_address: '0.0.0.0'
 
     ## The port that the HTTPS proxy module should bind to.
-    # listen_port: 9443
+     listen_port: 9443
 
 ## ----------------------------------------------------------------------------
 
@@ -247,7 +271,7 @@ logging:
   ##   error
   ##   fatal
   ##   off: all output suppressed
-  # level: 'info'
+   level: 'detail'
 
   ## The file to which the synchronisation server should log. This should
   ## be a writable path from the perspective of the user under which the
diff --git a/tools/sync_test_server/keys/127_0_0_1-chain.crt.pem b/tools/sync_test_server/keys/127_0_0_1-chain.crt.pem
new file mode 100644
index 0000000000..7c55402c55
--- /dev/null
+++ b/tools/sync_test_server/keys/127_0_0_1-chain.crt.pem
@@ -0,0 +1,229 @@
+Certificate:
+    Data:
+        Version: 3 (0x2)
+        Serial Number: 7 (0x7)
+        Signature Algorithm: sha1WithRSAEncryption
+        Issuer: DC=io, DC=realm, O=Realm, OU=Realm Test Signing CA, CN=Realm Test Signing CA
+        Validity
+            Not Before: May 17 23:28:48 2017 GMT
+            Not After : May 17 23:28:48 2019 GMT
+        Subject: DC=127.0.0.1, O=Realm, OU=Realm, CN=127.0.0.1
+        Subject Public Key Info:
+            Public Key Algorithm: rsaEncryption
+            RSA Public Key: (2048 bit)
+                Modulus (2048 bit):
+                    00:b7:8c:99:7b:6b:5b:29:80:9c:99:b7:fe:b8:1e:
+                    06:6c:4d:58:bd:38:b6:cc:13:6a:ff:fd:f6:26:a0:
+                    71:d2:8a:94:ea:06:be:e1:b8:5b:03:5e:96:8e:61:
+                    19:0f:80:5f:b8:51:43:97:00:38:67:47:0e:09:b8:
+                    ab:80:d1:9c:81:b8:81:db:0b:b4:c5:de:7a:3c:f5:
+                    9c:cb:bf:2b:12:fe:b1:9d:4e:a0:4a:ab:ae:c4:11:
+                    19:54:c5:17:ed:58:c3:72:f0:e5:46:dc:21:41:4c:
+                    63:1d:31:85:f3:ba:f6:ad:69:3e:d8:86:9d:c4:56:
+                    3b:52:47:5d:24:dd:40:af:f9:fa:03:4c:4e:2d:5b:
+                    d2:34:dc:f0:a4:19:13:14:f6:6c:7c:1c:47:bd:7d:
+                    79:a2:09:61:ad:3f:8d:4e:59:c5:ae:a7:2b:39:00:
+                    e9:34:68:6c:6f:d8:60:a2:a9:24:33:1c:9f:80:b4:
+                    c6:8e:ba:37:98:71:3d:dd:82:66:d8:e0:c2:81:cc:
+                    4b:d1:5d:58:26:cf:85:0a:ac:fd:08:a5:40:50:ff:
+                    f9:73:e8:27:18:7b:70:75:73:2a:23:c7:d7:15:be:
+                    ca:ce:57:c9:ee:bb:6d:b4:d8:fd:c7:22:47:28:9b:
+                    00:5e:4b:af:82:63:c3:d7:6a:74:4e:60:17:94:6a:
+                    fb:83
+                Exponent: 65537 (0x10001)
+        X509v3 extensions:
+            X509v3 Key Usage: critical
+                Digital Signature, Key Encipherment
+            X509v3 Basic Constraints: 
+                CA:FALSE
+            X509v3 Extended Key Usage: 
+                TLS Web Server Authentication, TLS Web Client Authentication
+            X509v3 Subject Key Identifier: 
+                C6:BD:F4:49:F5:2E:76:52:44:F1:E2:CE:2E:6C:F9:59:B1:56:14:AD
+            X509v3 Authority Key Identifier: 
+                keyid:27:79:E1:DA:F1:15:D0:E9:E5:86:30:87:E7:1F:5F:CF:27:3A:70:B4
+
+            X509v3 Subject Alternative Name: 
+                IP Address:127.0.0.1
+    Signature Algorithm: sha1WithRSAEncryption
+        9b:3f:74:f4:69:72:6b:5b:75:88:b7:10:5f:e0:73:b2:82:be:
+        dc:71:1b:a3:d6:a4:6e:ae:a6:5f:51:78:5c:80:64:20:21:20:
+        13:16:08:d0:ae:15:f6:52:24:d9:23:5c:24:ed:62:3b:0e:e6:
+        5f:00:4b:bf:a1:94:34:2a:fb:2a:46:5f:54:e6:3b:7f:be:81:
+        5b:df:e8:78:a6:1e:ce:e2:87:b9:8b:e4:d8:04:1f:18:c4:29:
+        80:7a:21:a9:56:c5:29:ee:4e:28:33:fa:8d:92:46:a2:31:31:
+        c5:f9:31:19:ed:1d:f6:c7:75:82:65:b6:1a:ad:bc:34:4a:f3:
+        18:05:a0:a3:d4:9a:50:f2:ef:bb:c4:2f:89:10:95:68:17:6a:
+        85:76:ce:88:8c:19:cf:d7:aa:70:c3:d0:59:9b:9a:c0:d0:a8:
+        d0:d3:cd:f5:f0:8e:5e:19:ab:a1:ae:54:dc:07:ac:6d:6e:d8:
+        f0:ee:65:47:de:29:1e:76:1b:1d:0e:62:f5:dd:1d:f6:6e:ad:
+        27:2e:8d:be:c4:a8:41:0b:b1:44:22:3d:29:b3:57:74:3e:3b:
+        41:28:19:8d:48:ed:65:05:5b:8e:17:a7:ab:45:24:d9:95:00:
+        e4:04:e7:6c:d8:6b:6b:2a:89:5e:1f:fb:b4:f2:1c:20:55:ea:
+        f5:40:99:58:a2:de:c3:83:e5:01:70:f8:53:e9:8d:95:ba:0b:
+        20:d0:99:e6:b4:31:05:55:00:9c:f7:f3:96:7c:74:5b:7d:c7:
+        6a:ae:ec:90:f8:0f:f2:f0:58:ec:80:0c:79:04:b0:f3:69:cd:
+        e5:41:f2:f5:fc:44:ba:d9:4f:3f:32:fe:69:f3:6e:1f:32:94:
+        62:78:17:76:dc:d5:0c:19:a6:8b:97:70:e9:19:39:a8:fa:b1:
+        00:a6:18:6f:4b:2d:38:2f:1d:96:0b:87:98:86:c1:2c:75:44:
+        3c:0e:e1:eb:f4:c4:4e:02:c7:9f:f7:cc:30:8a:72:23:bf:44:
+        7c:7c:3f:f7:7c:b1:b1:d7:aa:4b:e4:1e:dd:ca:fd:5a:8d:2e:
+        aa:ff:49:af:a5:63:6f:88:31:26:7d:b3:a4:e3:4d:4d:45:d6:
+        44:7b:12:a8:6e:06:bb:81:c0:80:a4:5f:95:3b:d4:a5:4a:01:
+        1d:00:0e:7b:5d:20:29:97:d0:d6:88:73:f1:89:c1:01:54:85:
+        9b:9c:ef:41:6d:f9:b6:83:cc:65:ac:34:ca:bf:88:fc:34:4f:
+        7f:62:30:e2:d9:02:eb:c7:58:86:90:6f:e4:7e:5f:20:45:f2:
+        c4:a0:7e:ad:92:5a:85:8f:08:90:3d:e8:65:be:54:79:e2:62:
+        3c:5d:8e:57:36:2a:17:bb
+-----BEGIN CERTIFICATE-----
+MIIE1DCCArygAwIBAgIBBzANBgkqhkiG9w0BAQUFADB7MRIwEAYKCZImiZPyLGQB
+GRYCaW8xFTATBgoJkiaJk/IsZAEZFgVyZWFsbTEOMAwGA1UECgwFUmVhbG0xHjAc
+BgNVBAsMFVJlYWxtIFRlc3QgU2lnbmluZyBDQTEeMBwGA1UEAwwVUmVhbG0gVGVz
+dCBTaWduaW5nIENBMB4XDTE3MDUxNzIzMjg0OFoXDTE5MDUxNzIzMjg0OFowTzEZ
+MBcGCgmSJomT8ixkARkWCTEyNy4wLjAuMTEOMAwGA1UECgwFUmVhbG0xDjAMBgNV
+BAsMBVJlYWxtMRIwEAYDVQQDDAkxMjcuMC4wLjEwggEiMA0GCSqGSIb3DQEBAQUA
+A4IBDwAwggEKAoIBAQC3jJl7a1spgJyZt/64HgZsTVi9OLbME2r//fYmoHHSipTq
+Br7huFsDXpaOYRkPgF+4UUOXADhnRw4JuKuA0ZyBuIHbC7TF3no89ZzLvysS/rGd
+TqBKq67EERlUxRftWMNy8OVG3CFBTGMdMYXzuvataT7Yhp3EVjtSR10k3UCv+foD
+TE4tW9I03PCkGRMU9mx8HEe9fXmiCWGtP41OWcWupys5AOk0aGxv2GCiqSQzHJ+A
+tMaOujeYcT3dgmbY4MKBzEvRXVgmz4UKrP0IpUBQ//lz6CcYe3B1cyojx9cVvsrO
+V8nuu2202P3HIkcomwBeS6+CY8PXanROYBeUavuDAgMBAAGjgY4wgYswDgYDVR0P
+AQH/BAQDAgWgMAkGA1UdEwQCMAAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUF
+BwMCMB0GA1UdDgQWBBTGvfRJ9S52UkTx4s4ubPlZsVYUrTAfBgNVHSMEGDAWgBQn
+eeHa8RXQ6eWGMIfnH1/PJzpwtDAPBgNVHREECDAGhwR/AAABMA0GCSqGSIb3DQEB
+BQUAA4ICAQCbP3T0aXJrW3WItxBf4HOygr7ccRuj1qRurqZfUXhcgGQgISATFgjQ
+rhX2UiTZI1wk7WI7DuZfAEu/oZQ0KvsqRl9U5jt/voFb3+h4ph7O4oe5i+TYBB8Y
+xCmAeiGpVsUp7k4oM/qNkkaiMTHF+TEZ7R32x3WCZbYarbw0SvMYBaCj1JpQ8u+7
+xC+JEJVoF2qFds6IjBnP16pww9BZm5rA0KjQ08318I5eGauhrlTcB6xtbtjw7mVH
+3ikedhsdDmL13R32bq0nLo2+xKhBC7FEIj0ps1d0PjtBKBmNSO1lBVuOF6erRSTZ
+lQDkBOds2GtrKoleH/u08hwgVer1QJlYot7Dg+UBcPhT6Y2Vugsg0JnmtDEFVQCc
+9/OWfHRbfcdqruyQ+A/y8FjsgAx5BLDzac3lQfL1/ES62U8/Mv5p824fMpRieBd2
+3NUMGaaLl3DpGTmo+rEAphhvSy04Lx2WC4eYhsEsdUQ8DuHr9MROAsef98wwinIj
+v0R8fD/3fLGx16pL5B7dyv1ajS6q/0mvpWNviDEmfbOk401NRdZEexKobga7gcCA
+pF+VO9SlSgEdAA57XSApl9DWiHPxicEBVIWbnO9Bbfm2g8xlrDTKv4j8NE9/YjDi
+2QLrx1iGkG/kfl8gRfLEoH6tklqFjwiQPehlvlR54mI8XY5XNioXuw==
+-----END CERTIFICATE-----
+Certificate:
+    Data:
+        Version: 3 (0x2)
+        Serial Number: 2 (0x2)
+    Signature Algorithm: sha1WithRSAEncryption
+        Issuer: DC=io, DC=realm, O=Realm, OU=Realm Test Root CA, CN=Realm Test Root CA
+        Validity
+            Not Before: Sep  7 10:17:28 2016 GMT
+            Not After : Sep  7 10:17:28 2026 GMT
+        Subject: DC=io, DC=realm, O=Realm, OU=Realm Test Signing CA, CN=Realm Test Signing CA
+        Subject Public Key Info:
+            Public Key Algorithm: rsaEncryption
+                Public-Key: (4096 bit)
+                Modulus:
+                    00:bf:5b:5a:92:de:53:af:73:80:e1:3f:22:55:75:
+                    38:7d:9e:3b:65:49:aa:d3:a7:ac:04:be:4d:a5:c2:
+                    7d:03:30:c9:d8:41:d2:00:0a:cd:df:a3:68:a5:13:
+                    92:0a:71:22:c5:09:d4:75:97:73:a6:fa:37:64:a7:
+                    61:55:84:88:c1:be:eb:92:e0:a6:1b:00:04:c4:31:
+                    fd:4a:e9:14:56:c8:ad:0b:5c:73:c8:55:1c:e6:60:
+                    b1:3a:e3:c2:1d:41:1a:6d:57:12:df:da:c2:fe:40:
+                    e7:d1:a5:71:29:71:cb:0d:12:d5:c6:be:e8:ab:62:
+                    9c:11:70:b5:de:f1:20:b6:bc:05:af:7a:3f:e4:df:
+                    74:33:d6:bb:a3:33:59:f3:3a:a0:af:2d:ea:e7:16:
+                    c8:8f:25:f1:fb:27:73:80:46:e3:44:5b:b8:f5:4c:
+                    ba:8e:61:6d:5f:2c:c0:8f:e8:d2:bd:3a:e8:0d:fa:
+                    16:de:32:19:84:c8:6c:ad:11:14:5c:ce:44:be:46:
+                    be:f0:7b:83:27:21:f1:49:f5:ba:e5:bc:59:07:b0:
+                    c2:fb:4f:7e:56:76:eb:cb:14:f1:50:d6:b3:83:10:
+                    2b:b1:d3:80:68:98:45:67:70:9e:1b:ef:ff:28:d0:
+                    ef:1a:38:28:64:16:84:5a:d1:9f:05:7f:15:50:6a:
+                    ce:ac:08:25:e4:3f:d6:df:09:d9:59:b2:05:d9:b7:
+                    e3:94:ae:f6:c6:04:69:2e:d5:47:79:54:92:fb:72:
+                    f2:4c:09:2b:64:3a:3e:d1:30:76:0c:33:65:0a:08:
+                    55:34:44:83:05:e9:1e:51:c2:58:70:44:30:6c:ef:
+                    0a:e0:b0:e2:10:2b:e1:55:29:24:03:68:61:bb:44:
+                    58:ea:ad:03:b3:a9:0f:13:44:ff:ea:24:d3:7b:bd:
+                    25:78:57:79:7b:e4:4b:9e:bc:32:33:63:d5:f7:25:
+                    39:f7:c5:31:8d:9f:f2:76:a3:6b:bb:5b:a4:dd:cc:
+                    96:44:b4:44:9d:50:ef:2e:64:29:02:a3:c7:52:f7:
+                    36:92:c5:fa:fb:75:dd:25:67:3e:46:37:e3:9d:dc:
+                    de:f6:e5:6a:0a:95:7e:e9:90:3e:c9:b1:f8:74:07:
+                    b9:ff:f2:24:c9:84:f0:9f:3c:a7:ce:ca:64:be:77:
+                    1e:7c:93:29:6f:c8:8e:8d:74:d3:a8:1d:e1:db:9b:
+                    8b:c3:27:d8:0d:03:fc:7e:3e:25:19:6a:b8:a5:97:
+                    d0:7a:c3:13:33:bc:3a:8c:c7:25:e9:f9:cf:4a:c5:
+                    c3:26:63:42:ef:58:d7:42:06:30:8a:20:c8:cd:6a:
+                    40:8b:fa:88:e0:54:ed:60:09:69:26:12:43:b5:f2:
+                    93:6c:5b
+                Exponent: 65537 (0x10001)
+        X509v3 extensions:
+            X509v3 Key Usage: critical
+                Certificate Sign, CRL Sign
+            X509v3 Basic Constraints: critical
+                CA:TRUE, pathlen:0
+            X509v3 Subject Key Identifier: 
+                27:79:E1:DA:F1:15:D0:E9:E5:86:30:87:E7:1F:5F:CF:27:3A:70:B4
+            X509v3 Authority Key Identifier: 
+                keyid:84:70:71:2C:04:3B:D0:92:83:B5:FB:7C:7F:B0:61:0C:62:16:71:74
+
+    Signature Algorithm: sha1WithRSAEncryption
+         36:05:84:8c:88:21:08:a7:e2:bd:41:a8:27:7f:b7:c2:9a:86:
+         d7:21:fe:ed:4c:51:d1:29:df:35:4a:0e:ea:a0:b5:6c:cc:28:
+         2f:5e:bd:9f:97:68:be:aa:2a:ff:54:91:9e:ef:04:5d:0d:ec:
+         e7:98:35:10:78:50:b6:1f:17:96:a9:5e:9a:60:fb:68:e9:06:
+         7d:53:8c:58:b7:9a:47:e0:9f:c8:d1:43:1a:74:41:3f:ab:03:
+         21:35:88:8e:34:3a:25:b7:98:67:24:8b:d4:14:88:57:1c:99:
+         df:08:0c:bd:57:9f:53:db:3a:47:a4:e5:4c:29:38:e2:82:39:
+         45:ea:62:ca:1b:d8:95:cb:0a:e3:65:10:97:c7:10:d7:8b:2d:
+         db:fa:16:c6:c4:0c:81:26:e6:6f:f1:da:fb:79:c0:12:27:58:
+         9a:2b:95:a0:bd:73:88:ad:f5:ad:9b:cd:49:3d:ad:2c:02:84:
+         f8:88:be:3c:bf:d7:a2:28:e8:09:1e:7c:0d:b0:56:ad:e6:e3:
+         a7:11:56:58:66:83:dd:80:31:56:a6:15:45:e1:e3:52:49:f2:
+         f8:4c:3c:60:fd:d6:1b:45:61:ec:52:c1:d9:b9:da:b0:5d:5c:
+         3b:7f:ef:34:dd:48:26:19:5a:66:ad:b5:a7:87:6b:73:e8:ea:
+         d3:5d:cd:d1:3f:ac:77:e4:59:8d:4d:95:38:2f:e8:17:ff:8f:
+         67:c8:f8:5d:8e:86:b7:78:50:25:62:35:b9:07:15:f6:eb:65:
+         98:80:96:0b:d2:14:cb:54:1a:75:0c:ab:d9:c2:99:1b:20:da:
+         e3:a4:77:68:ef:75:cc:44:7f:66:f4:47:8c:7a:03:21:b6:6c:
+         c7:00:b2:50:15:84:5c:87:2a:fb:03:3a:d7:2d:df:52:96:80:
+         b6:c0:3d:a0:4b:65:67:5e:f3:bd:41:fe:f4:62:3a:de:0f:30:
+         8d:47:bf:8a:0b:f8:0e:d8:7b:84:93:60:e6:73:a9:60:11:f3:
+         5a:16:2c:2a:58:c0:dc:78:8f:66:c8:10:90:d5:da:03:35:e9:
+         a7:22:8a:04:14:cf:e1:fb:c9:46:5f:cc:29:ef:c7:22:bd:65:
+         a4:8a:47:e0:d5:10:0d:12:4c:a3:72:11:e6:5f:9e:5b:87:38:
+         eb:48:74:dd:86:26:ab:45:61:63:45:52:21:a9:35:65:84:30:
+         49:85:68:90:b6:23:0c:f0:10:7e:de:e1:e8:3d:94:6d:ff:44:
+         a0:2e:86:1c:4c:bb:ec:72:85:3b:d0:6d:49:69:47:a9:61:1f:
+         c5:39:cb:d6:7a:06:e9:41:52:df:00:00:c0:08:3f:21:bd:44:
+         52:c4:78:a5:fe:e5:33:fe
+-----BEGIN CERTIFICATE-----
+MIIF0TCCA7mgAwIBAgIBAjANBgkqhkiG9w0BAQUFADB1MRIwEAYKCZImiZPyLGQB
+GRYCaW8xFTATBgoJkiaJk/IsZAEZFgVyZWFsbTEOMAwGA1UECgwFUmVhbG0xGzAZ
+BgNVBAsMElJlYWxtIFRlc3QgUm9vdCBDQTEbMBkGA1UEAwwSUmVhbG0gVGVzdCBS
+b290IENBMB4XDTE2MDkwNzEwMTcyOFoXDTI2MDkwNzEwMTcyOFowezESMBAGCgmS
+JomT8ixkARkWAmlvMRUwEwYKCZImiZPyLGQBGRYFcmVhbG0xDjAMBgNVBAoMBVJl
+YWxtMR4wHAYDVQQLDBVSZWFsbSBUZXN0IFNpZ25pbmcgQ0ExHjAcBgNVBAMMFVJl
+YWxtIFRlc3QgU2lnbmluZyBDQTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoC
+ggIBAL9bWpLeU69zgOE/IlV1OH2eO2VJqtOnrAS+TaXCfQMwydhB0gAKzd+jaKUT
+kgpxIsUJ1HWXc6b6N2SnYVWEiMG+65LgphsABMQx/UrpFFbIrQtcc8hVHOZgsTrj
+wh1BGm1XEt/awv5A59GlcSlxyw0S1ca+6KtinBFwtd7xILa8Ba96P+TfdDPWu6Mz
+WfM6oK8t6ucWyI8l8fsnc4BG40RbuPVMuo5hbV8swI/o0r066A36Ft4yGYTIbK0R
+FFzORL5GvvB7gych8Un1uuW8WQewwvtPflZ268sU8VDWs4MQK7HTgGiYRWdwnhvv
+/yjQ7xo4KGQWhFrRnwV/FVBqzqwIJeQ/1t8J2VmyBdm345Su9sYEaS7VR3lUkvty
+8kwJK2Q6PtEwdgwzZQoIVTREgwXpHlHCWHBEMGzvCuCw4hAr4VUpJANoYbtEWOqt
+A7OpDxNE/+ok03u9JXhXeXvkS568MjNj1fclOffFMY2f8naja7tbpN3MlkS0RJ1Q
+7y5kKQKjx1L3NpLF+vt13SVnPkY3453c3vblagqVfumQPsmx+HQHuf/yJMmE8J88
+p87KZL53HnyTKW/Ijo1006gd4dubi8Mn2A0D/H4+JRlquKWX0HrDEzO8OozHJen5
+z0rFwyZjQu9Y10IGMIogyM1qQIv6iOBU7WAJaSYSQ7Xyk2xbAgMBAAGjZjBkMA4G
+A1UdDwEB/wQEAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBQneeHa
+8RXQ6eWGMIfnH1/PJzpwtDAfBgNVHSMEGDAWgBSEcHEsBDvQkoO1+3x/sGEMYhZx
+dDANBgkqhkiG9w0BAQUFAAOCAgEANgWEjIghCKfivUGoJ3+3wpqG1yH+7UxR0Snf
+NUoO6qC1bMwoL169n5dovqoq/1SRnu8EXQ3s55g1EHhQth8XlqlemmD7aOkGfVOM
+WLeaR+CfyNFDGnRBP6sDITWIjjQ6JbeYZySL1BSIVxyZ3wgMvVefU9s6R6TlTCk4
+4oI5RepiyhvYlcsK42UQl8cQ14st2/oWxsQMgSbmb/Ha+3nAEidYmiuVoL1ziK31
+rZvNST2tLAKE+Ii+PL/XoijoCR58DbBWrebjpxFWWGaD3YAxVqYVReHjUkny+Ew8
+YP3WG0Vh7FLB2bnasF1cO3/vNN1IJhlaZq21p4drc+jq013N0T+sd+RZjU2VOC/o
+F/+PZ8j4XY6Gt3hQJWI1uQcV9utlmICWC9IUy1QadQyr2cKZGyDa46R3aO91zER/
+ZvRHjHoDIbZsxwCyUBWEXIcq+wM61y3fUpaAtsA9oEtlZ17zvUH+9GI63g8wjUe/
+igv4Dth7hJNg5nOpYBHzWhYsKljA3HiPZsgQkNXaAzXppyKKBBTP4fvJRl/MKe/H
+Ir1lpIpH4NUQDRJMo3IR5l+eW4c460h03YYmq0VhY0VSIak1ZYQwSYVokLYjDPAQ
+ft7h6D2Ubf9EoC6GHEy77HKFO9BtSWlHqWEfxTnL1noG6UFS3wAAwAg/Ib1EUsR4
+pf7lM/4=
+-----END CERTIFICATE-----
diff --git a/tools/sync_test_server/keys/127_0_0_1-server.key.pem b/tools/sync_test_server/keys/127_0_0_1-server.key.pem
new file mode 100644
index 0000000000..8f46018e95
--- /dev/null
+++ b/tools/sync_test_server/keys/127_0_0_1-server.key.pem
@@ -0,0 +1,27 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIEowIBAAKCAQEAt4yZe2tbKYCcmbf+uB4GbE1YvTi2zBNq//32JqBx0oqU6ga+
+4bhbA16WjmEZD4BfuFFDlwA4Z0cOCbirgNGcgbiB2wu0xd56PPWcy78rEv6xnU6g
+SquuxBEZVMUX7VjDcvDlRtwhQUxjHTGF87r2rWk+2IadxFY7UkddJN1Ar/n6A0xO
+LVvSNNzwpBkTFPZsfBxHvX15oglhrT+NTlnFrqcrOQDpNGhsb9hgoqkkMxyfgLTG
+jro3mHE93YJm2ODCgcxL0V1YJs+FCqz9CKVAUP/5c+gnGHtwdXMqI8fXFb7KzlfJ
+7rtttNj9xyJHKJsAXkuvgmPD12p0TmAXlGr7gwIDAQABAoIBADZl3gr86zymmELa
+jAxHIcIxPi5+Q3bB/oE15CDYhkNOvQmKzEGbYKXj/5zc3A+DDVtUAkMbVpwNK/Tn
+nTSFauvrIdkoZAAMio/MfxbHZl2vzDYB2nGm5hnHs4kzDH9UQkCrclgI33Y5zFoX
+lkqAy6DjQzPq2ZEZuWUOL2XAiO5eF313OwfTfPGfswN3OWyUshdE7pxkD1JAwkU6
+f5oeOistu964OwJdCDdf2xF3q3Ix2Ll3JA2sccgvuh9If1Rqn9qOZ6yfElr/IClU
+Y73RBALvjc931cKtba1Syo7Brp/UysfH77DxSifsLp+MleYMVK2+EqYP1VaDnmjs
+5I2r/0kCgYEA78JKabi68+gTSk/4FlUw+nCQ4EV9p6JiZJZoSUAbfXYxy8dXGYk8
+rNsRFaoM8Fl3br3xpRSV2OyJyX3H9Y33jOWwXUU0E6Ao+K26FvHXNmmGZCDjWTF6
+LleMisYaFvU5L6E5PKgibiTf/Z8oT7fk0dqTJbWT+klxX9DHknSMv9UCgYEAw/uQ
+eEV2blUOcTXFh+9j0t4gBrixOvLn67siwFm3NQZV1PQAYfYqfRTZm4mpisaVMNKU
+juAp8GWvq/R1kVJfISoztLmzytuyRtFtuX9hUSuiv6HyYBPoVGoM2Mj52SZKE3pf
+XbkYQJdIgoaKvubem++eHrIQBcijio1Xmdl90fcCgYBiBcM6mgYFNjq8xRkeuFG/
+8kmpB4AqCx/DFCMq34TdtHcDY0pe7FbcLOw9OTr1AP7tTcb/wPzKpVpoAH7CC/rL
+phSG7YYvB+n4Ub6lJtbgLiB9y1xn2OylCbIyAnAkNrncmUO3Yt5Avd696FYo0XxB
+t+U1I5mOWHx7ufX+EJyCyQKBgQCYO6G1+ucKvyEvyT/93nMhCg/AiNiKXMLP9pYA
+6e+IzboAZ+SgM5I/hOGfkuhSdvzOZtSkwvVw2dwCayqjzmM8pMZzPMiu68bogaeE
+rrCOV6Hcz1QxU2VlpNcD0eFZzwc9aBIKAEwZaCoX0aCWt0j1wcSGPXR6uaZnanFA
+fZPhcwKBgD3HayHdVtdCxdeFF01pDf1wQFRNgGrOPFPB3PIYC8Dpc+VpHYZNrkQ0
+AJqs4elBq1KeW8Et23KuVjYkMLA7NeefnOZA1XkAS9SISOwDB083j9BbsM/Uc+ug
+qFl9DVG+S56WuyjfNDiVm95jcalD8UctQgqIxSj2u8QfO3LOyjLC
+-----END RSA PRIVATE KEY-----
diff --git a/tools/sync_test_server/ros-testing-server.js b/tools/sync_test_server/ros-testing-server.js
index c9ca2c2c5d..d86165a6e8 100755
--- a/tools/sync_test_server/ros-testing-server.js
+++ b/tools/sync_test_server/ros-testing-server.js
@@ -3,8 +3,11 @@
 var winston = require('winston'); //logging
 const temp = require('temp');
 const spawn = require('child_process').spawn;
+const exec = require('child_process').exec;
 var http = require('http');
 var dispatcher = require('httpdispatcher');
+var fs = require('fs-extra');
+var moment = require('moment')
 
 // Automatically track and cleanup files at exit
 temp.track();
@@ -13,9 +16,16 @@ if (process. argv. length <= 2) {
     console.log("Usage: " + __filename + " somefile.log");
     process.exit(-1);
 }
+
 const logFile = process.argv[2];
 winston.level = 'debug';
-winston.add(winston.transports.File, { filename: logFile });
+winston.add(winston.transports.File, {
+    filename: logFile,
+    json: false,
+    formatter: function(options) {
+        return moment().format('YYYY-MM-DD HH:mm:ss.SSSS') + ' ' + (undefined !== options.message ? options.message : '');
+    }
+});
 
 const PORT = 8888;
 
@@ -32,55 +42,112 @@ function handleRequest(request, response) {
 
 var syncServerChildProcess = null;
 
-function startRealmObjectServer() {
-    stopRealmObjectServer();
+// Waits for ROS to be fully initialized.
+function waitForRosToInitialize(attempts, onSuccess, onError) {
+    if (attempts == 0) {
+        onError("Could not get ROS to start. See Docker log.");
+        return;
+    }
+    http.get("http://0.0.0.0:9080/health", function(res) {
+        if (res.statusCode != 200) {
+            winston.info("ROS /health/ returned: " + res.statusCode)
+            waitForRosToInitialize(attempts - 1, onSuccess, onError)
+        } else {
+            onSuccess();
+        }
+    }).on('error', function(err) {
+        // ROS not accepting any connections yet.
+        // Errors like ECONNREFUSED 0.0.0.0:9080 will be reported here.
+        // Wait a little before trying again (common startup is ~1 second).
+        setTimeout(function() {
+            waitForRosToInitialize(attempts - 1, onSuccess, onError);
+        }, 200);
+    });
+}
+
+function startRealmObjectServer(onSuccess, onError) {
     temp.mkdir('ros', function(err, path) {
         if (!err) {
             winston.info("Starting sync server in ", path);
             var env = Object.create( process.env );
             winston.info(env.NODE_ENV);
             env.NODE_ENV = 'development';
-            syncServerChildProcess = spawn('realm-object-server',
-                    ['--root', path,
-                    '--configuration', '/configuration.yml'],
-                    { env: env });
+
+            // Manually cleanup Global Notifier State
+            // See https://github.com/realm/ros/issues/437#issuecomment-335380095
+            var globalNotifierDir = path + '/realm-object-server';
+            winston.info('Cleaning state in: ' + globalNotifierDir);
+            fs.removeSync(globalNotifierDir)
+            if (fs.existsSync(globalNotifierDir)) {
+                onError("Could not delete the global notifier directory: " + globalNotifierDir);
+                return;
+            }
+            fs.mkdirsSync(path + '/realm-object-server/io.realm.object-server-utility/metadata/')
+
+            // Start ROS
+            syncServerChildProcess = spawn('ros',
+                    ['start',
+                        '--data', path,
+                        '--loglevel', 'detail',
+                        '--https',
+                        '--https-key', '/127_0_0_1-server.key.pem',
+                        '--https-cert', '/127_0_0_1-chain.crt.pem',
+                        '--https-port', '9443',
+                        '--access-token-ttl', '20' //WARNING : Changing this value may impact the timeout of the refresh token test (AuthTests#preemptiveTokenRefresh)
+                    ],
+                    { env: env, cwd: path});
+
             // local config:
             syncServerChildProcess.stdout.on('data', (data) => {
-                winston.info(`stdout: ${data}`);
+                winston.info(`${data}`);
             });
 
             syncServerChildProcess.stderr.on('data', (data) => {
-                winston.info(`stderr: ${data}`);
+                winston.info(`${data}`);
             });
 
-            syncServerChildProcess.on('close', (code) => {
-                winston.info(`child process exited with code ${code}`);
-            });
+            waitForRosToInitialize(20, onSuccess, onError);
         }
     });
 }
 
-function stopRealmObjectServer() {
-    if (syncServerChildProcess) {
-        syncServerChildProcess.kill();
-        syncServerChildProcess = null;
+function stopRealmObjectServer(onSuccess, onError) {
+    if(syncServerChildProcess == null) {
+        onError("No ROS process found to stop");
     }
-}
 
+    syncServerChildProcess.on('exit', function(code) {
+        winston.info("ROS server stopped due to process being killed. Exit code: " + code);
+        syncServerChildProcess.removeAllListeners('exit');
+        syncServerChildProcess = null;
+        onSuccess();
+    });
+
+    syncServerChildProcess.kill('SIGKILL');
+}
 
 // start sync server
 dispatcher.onGet("/start", function(req, res) {
-    startRealmObjectServer();
-    res.writeHead(200, {'Content-Type': 'text/plain'});
-    res.end('Starting a server');
+    winston.info("Attempting to start ROS");
+    startRealmObjectServer(() => {
+        res.writeHead(200, {'Content-Type': 'text/plain'});
+        res.end('ROS started');
+    }, function (err) {
+        res.writeHead(500, {'Content-Type': 'text/plain'});
+        res.end('Starting ROS failed: ' + err);
+    });
 });
 
 // stop a previously started sync server
 dispatcher.onGet("/stop", function(req, res) {
-    stopRealmObjectServer();
-    winston.info("Sync server stopped");
-    res.writeHead(200, {'Content-Type': 'text/plain'});
-    res.end('Stopping the server');
+  winston.info("Attempting to stop ROS")
+  stopRealmObjectServer(function() {
+        res.writeHead(200, {'Content-Type': 'text/plain'});
+        res.end('ROS stopped');
+  }, function(err) {
+        res.writeHead(500, {'Content-Type': 'text/plain'});
+        res.end('Stopping ROS failed: ' + err);
+  });
 });
 
 //Create and start the Http server
diff --git a/tools/sync_test_server/start_server.sh b/tools/sync_test_server/start_server.sh
index cf49b3247f..37828b38d7 100755
--- a/tools/sync_test_server/start_server.sh
+++ b/tools/sync_test_server/start_server.sh
@@ -7,10 +7,11 @@ ROS_DE_VERSION=$(grep REALM_OBJECT_SERVER_DE_VERSION $DOCKERFILE_DIR/../../depen
 
 TMP_DIR=$(mktemp -d /tmp/sync-test.XXXX) || { echo "Failed to mktemp $TEST_TEMP_DIR" ; exit 1 ; }
 
+adb reverse tcp:9443 tcp:9443 && \
 adb reverse tcp:9080 tcp:9080 && \
 adb reverse tcp:8888 tcp:8888 || { echo "Failed to reverse adb port." ; exit 1 ; }
 
 docker build $DOCKERFILE_DIR --build-arg ROS_DE_VERSION=$ROS_DE_VERSION -t sync-test-server || { echo "Failed to build Docker image." ; exit 1 ; }
 
 echo "See log files in $TMP_DIR"
-docker run -p 9080:9080 -p 8888:8888 -v$TMP_DIR:/tmp --name sync-test-server sync-test-server
+docker run -p 9080:9080 -p 9443:9443 -p 8888:8888 -v$TMP_DIR:/tmp --name sync-test-server sync-test-server
diff --git a/tools/update_gradle_wrapper.sh b/tools/update_gradle_wrapper.sh
new file mode 100755
index 0000000000..224817cf23
--- /dev/null
+++ b/tools/update_gradle_wrapper.sh
@@ -0,0 +1,21 @@
+#!/bin/sh
+
+# This script updates Gradle Wrappers in this repository.
+# To run it:
+#   1. Make sure that you have run ./gradlew assemble in the root directory
+#   2. Replace the gradle version number in realm.properties in the root directory, with the new version number.
+#   3. Run tools/update_gradle_wrapper.sh
+
+HERE=`pwd`
+
+cd "$(dirname $0)/.."
+
+for i in $(find $(pwd) -type f -name gradlew); do
+    cd $(dirname $i)
+    pwd
+    ./gradlew wrapper
+    sed -E -i '' s/-bin\\.zip\$/-all.zip/ gradle/wrapper/gradle-wrapper.properties
+done
+
+cd $HERE
+
diff --git a/version.txt b/version.txt
index c77e8c03a0..017f4a0367 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-3.1.4-WEBITEASY
\ No newline at end of file
+4.1.1-WEBITEASY
\ No newline at end of file
