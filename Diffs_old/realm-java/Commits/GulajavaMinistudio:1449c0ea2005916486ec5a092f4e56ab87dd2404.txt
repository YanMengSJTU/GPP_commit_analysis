diff --git a/CHANGELOG.md b/CHANGELOG.md
index 404f9ffc0c..fa43c077b6 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,4 +1,4 @@
-## 3.2.1 (YYYY-MM-DD)
+## 3.2.1 (2017-05-19)
 
 ### Deprecated
 
@@ -8,11 +8,16 @@
 
 ### Bug Fixes
 
+* [ObjectServer] `schemaVersion` was mistakenly required in order to trigger migrations (#4658). 
+* [ObjectServer] Fields removed from model classes will now correctly be hidden instead of throwing an exception when opening the Realm (#4658). 
+* Fixed random crashes which were caused by a race condition in encrypted Realm (#4343).
+
 ### Internal
 
-## 3.2.0 (2017-05-16)
+* Upgraded to Realm Sync 1.8.5.
+* Upgraded to Realm Core 2.8.0.
 
-### Deprecated
+## 3.2.0 (2017-05-16)
 
 ### Enhancements
 
diff --git a/dependencies.list b/dependencies.list
index 7a9a09482c..f78a30cfc7 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,7 +1,7 @@
 # Realm Sync Core release used by Realm Java
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=1.6.0
-REALM_SYNC_SHA256=e8a973dbe6ab33ac49d3d0e45d6b63d69cec8d1d87d9a2311fcdd02767f76cf8
+REALM_SYNC_VERSION=1.8.5
+REALM_SYNC_SHA256=71e70f83b1604672bbfd7c04fcf984ecc8ac683864943ef3de262994c2e7b7fc
 
 # Object Server Release used by Integration tests
 # `realm` is stable releases, `realm-testing` is developer builds.
diff --git a/examples/kotlinExample/build.gradle b/examples/kotlinExample/build.gradle
index fdaceba7dd..d3984d3701 100644
--- a/examples/kotlinExample/build.gradle
+++ b/examples/kotlinExample/build.gradle
@@ -1,5 +1,5 @@
 buildscript {
-    ext.kotlin_version = '1.1.2-2'
+    ext.kotlin_version = '1.1.2-4'
     repositories {
         jcenter()
         mavenCentral()
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/IndexedFields.java b/realm/realm-library/src/androidTest/java/io/realm/entities/IndexedFields.java
new file mode 100644
index 0000000000..420062c098
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/IndexedFields.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.entities;
+
+import io.realm.RealmObject;
+import io.realm.annotations.Index;
+
+
+public class IndexedFields extends RealmObject {
+
+    public static final String FIELD_INDEXED_STRING = "indexedString";
+    public static final String FIELD_NON_INDEXED_STRING = "nonIndexedString";
+
+    @Index
+    private String indexedString;
+    private String nonIndexedString;
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
index 5e70b431b8..099977dcd9 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/PrimaryKeyAsString.java
@@ -24,6 +24,7 @@
 
     public static final String CLASS_NAME = "PrimaryKeyAsString";
     public static final String FIELD_PRIMARY_KEY = "name";
+    public static final String FIELD_ID = "id";
 
     @PrimaryKey
     private String name;
diff --git a/realm/realm-library/src/androidTest/java/io/realm/entities/StringOnly.java b/realm/realm-library/src/androidTest/java/io/realm/entities/StringOnly.java
index b4183425c9..c8c80a461a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/entities/StringOnly.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/StringOnly.java
@@ -19,6 +19,9 @@
 import io.realm.RealmObject;
 
 public class StringOnly extends RealmObject {
+
+    public static final String FIELD_CHARS = "chars";
+
     private String chars;
 
     public String getChars() {
diff --git a/realm/realm-library/src/androidTestObjectServer/assets/schemaversion_v1.realm b/realm/realm-library/src/androidTestObjectServer/assets/schemaversion_v1.realm
deleted file mode 100644
index d2dac44060..0000000000
Binary files a/realm/realm-library/src/androidTestObjectServer/assets/schemaversion_v1.realm and /dev/null differ
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
index d539d0bd9c..0ab6661ff9 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
@@ -450,88 +450,6 @@ public void compact_NotAllowed() {
         Realm.compactRealm(config);
     }
 
-    @Test
-    public void schemaVersion_throwsIfLessThanCurrentVersion() throws IOException {
-        SyncUser user = createTestUser();
-        String url = "realm://ros.realm.io/~/default";
-        @SuppressWarnings("unchecked")
-        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
-                .schema(AllJavaTypes.class, StringOnly.class)
-                .name("schemaversion_v1.realm")
-                .schemaVersion(0)
-                .build();
-
-        // Add v1 of the Realm to the filsystem
-        configFactory.copyRealmFromAssets(context, "schemaversion_v1.realm", config);
-
-        // Opening the Realm should throw an exception since the schema version is less than the one in the file.
-        Realm realm = null;
-        try {
-            realm = Realm.getInstance(config);
-            fail();
-        } catch(IllegalArgumentException ignore) {
-        } finally {
-            if (realm != null) {
-                realm.close();
-            }
-        }
-    }
-
-    @Test
-    public void schemaVersion_bumpWhenUpgradingSchema() throws IOException {
-        SyncUser user = createTestUser();
-        String url = "realm://ros.realm.io/~/default";
-        @SuppressWarnings("unchecked")
-        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
-                .schema(AllJavaTypes.class, StringOnly.class)
-                .name("schemaversion_v1.realm")
-                .schemaVersion(2)
-                .build();
-
-        // Add v1 of the Realm to the file system. v1 is missing the class `StringOnly`
-        configFactory.copyRealmFromAssets(context, "schemaversion_v1.realm", config);
-
-        // Opening the Realm should automatically upgrade the schema and version
-        Realm realm = null;
-        try {
-            realm = Realm.getInstance(config);
-            assertEquals(2, realm.getVersion());
-            assertTrue(realm.getSchema().contains(StringOnly.class.getSimpleName()));
-        } finally {
-            if (realm != null) {
-                realm.close();
-            }
-        }
-    }
-
-    @Test
-    public void schemaVersion_throwsIfNotUpdatedForSchemaUpgrade() throws IOException {
-        SyncUser user = createTestUser();
-        String url = "realm://ros.realm.io/~/default";
-        @SuppressWarnings("unchecked")
-        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user, url)
-                .schema(AllJavaTypes.class, StringOnly.class)
-                .name("schemaversion_v1.realm")
-                .schemaVersion(1)
-                .build();
-
-        // Add v1 of the Realm to the file system. v1 is missing the class `StringOnly`
-        configFactory.copyRealmFromAssets(context, "schemaversion_v1.realm", config);
-
-        // Opening the Realm should throw an exception since the schema changed, but the provided schema version is
-        // the same.
-        Realm realm = null;
-        try {
-            realm = Realm.getInstance(config);
-            fail();
-        } catch(IllegalArgumentException ignore) {
-        } finally {
-            if (realm != null) {
-                realm.close();
-            }
-        }
-    }
-
     // Check that it is possible for multiple users to reference the same Realm URL while each user still use their
     // own copy on the filesystem. This is e.g. what happens if a Realm is shared using a PermissionOffer.
     @Test
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
index 28f2e3984b..014cae155d 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
@@ -29,10 +29,18 @@
 
 import java.io.FileNotFoundException;
 
+import io.realm.entities.IndexedFields;
+import io.realm.entities.PrimaryKeyAsString;
+import io.realm.entities.StringOnly;
+import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.log.RealmLog;
 import io.realm.rule.TestRealmConfigurationFactory;
 import io.realm.rule.TestSyncConfigurationFactory;
 import io.realm.util.SyncTestUtils;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
@@ -56,4 +64,216 @@ public void migrateRealm_syncConfigurationThrows() {
         }
     }
 
+    // Check that the Realm can still be opened even if the ondisk schema are missing fields. These will be added
+    // automatically.
+    @Test
+    public void addField_worksWithMigrationError() {
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/auth")
+                .schema(StringOnly.class)
+                .build();
+
+        // Setup initial Realm schema (with missing fields)
+        String className = StringOnly.class.getSimpleName();
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);
+        RealmSchema schema = dynamicRealm.getSchema();
+        dynamicRealm.beginTransaction();
+        schema.create(className); // Create empty class
+        dynamicRealm.commitTransaction();
+        dynamicRealm.close();
+
+        // Open typed Realm, which will validate the schema
+        Realm realm = Realm.getInstance(config);
+        RealmObjectSchema stringOnlySchema = realm.getSchema().get(className);
+        try {
+            assertTrue(stringOnlySchema.hasField(StringOnly.FIELD_CHARS)); // Field has been added
+        } finally {
+            realm.close();
+        }
+    }
+
+    // Check that the Realm can still be opened even if the ondisk schema has more fields than in the model class.
+    // The underlying field should not be deleted, just hidden.
+    @Test
+    public void missingFields_hiddenSilently() {
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/auth")
+                .schema(StringOnly.class)
+                .build();
+
+        // Setup initial Realm schema (with too many fields)
+        String className = StringOnly.class.getSimpleName();
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);
+        RealmSchema schema = dynamicRealm.getSchema();
+        dynamicRealm.beginTransaction();
+        schema.create(className)
+                .addField(StringOnly.FIELD_CHARS, String.class)
+                .addField("newField", String.class);
+        dynamicRealm.commitTransaction();
+        dynamicRealm.close();
+
+        // Open typed Realm, which will validate the schema
+        Realm realm = Realm.getInstance(config);
+        RealmObjectSchema stringOnlySchema = realm.getSchema().get(className);
+        try {
+            assertTrue(stringOnlySchema.hasField(StringOnly.FIELD_CHARS));
+            // TODO Field is currently hidden, but should the field be visible in the schema
+            assertFalse(stringOnlySchema.hasField("newField"));
+            assertEquals(1, stringOnlySchema.getFieldNames().size());
+        } finally {
+            realm.close();
+        }
+    }
+
+    // Check that a Realm cannot be opened if it contain breaking schema changes, like changing a primary key
+    @Test
+    public void breakingSchemaChange_throws() {
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/auth")
+                .schema(PrimaryKeyAsString.class)
+                .build();
+
+        // Setup initial Realm schema (with a different primary key)
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);
+        RealmSchema schema = dynamicRealm.getSchema();
+        dynamicRealm.beginTransaction();
+        schema.create(PrimaryKeyAsString.class.getSimpleName())
+                .addField(PrimaryKeyAsString.FIELD_PRIMARY_KEY, String.class)
+                .addField(PrimaryKeyAsString.FIELD_ID, long.class, FieldAttribute.PRIMARY_KEY);
+        dynamicRealm.commitTransaction();
+        dynamicRealm.close();
+
+        try {
+            Realm.getInstance(config);
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
+    }
+
+    // Check that indexes are not being added if the schema version is the same
+    @Test
+    public void sameSchemaVersion_doNotRebuildIndexes() {
+
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/auth")
+                .schema(IndexedFields.class)
+                .schemaVersion(42)
+                .build();
+
+        // Setup initial Realm schema (with no indexes)
+        String className = IndexedFields.class.getSimpleName();
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);
+        RealmSchema schema = dynamicRealm.getSchema();
+        dynamicRealm.beginTransaction();
+        schema.create(className)
+                .addField(IndexedFields.FIELD_INDEXED_STRING, String.class) // No index
+                .addField(IndexedFields.FIELD_NON_INDEXED_STRING, String.class);
+        dynamicRealm.setVersion(42);
+        dynamicRealm.commitTransaction();
+        dynamicRealm.close();
+
+        try {
+            Realm realm = Realm.getInstance(config); // Opening at same schema version (42) will not rebuild indexes
+            fail();
+        } catch (RealmMigrationNeededException ignored) {
+        }
+
+// FIXME: This is the intended behaviour
+//        RealmObjectSchema indexedFieldsSchema = realm.getSchema().get(className);
+//        try {
+//            assertFalse(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_INDEXED_STRING));
+//            assertFalse(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_NON_INDEXED_STRING));
+//        } finally {
+//            realm.close();
+//        }
+    }
+
+    // Check that indexes are being added if the schema version is different
+    @Test
+    public void differentSchemaVersions_rebuildIndexes() {
+
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/auth")
+                .schema(IndexedFields.class)
+                .schemaVersion(42)
+                .build();
+
+        // Setup initial Realm schema (with no indexes)
+        String className = IndexedFields.class.getSimpleName();
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);
+        RealmSchema schema = dynamicRealm.getSchema();
+        dynamicRealm.beginTransaction();
+        schema.create(className)
+                .addField(IndexedFields.FIELD_INDEXED_STRING, String.class) // No index
+                .addField(IndexedFields.FIELD_NON_INDEXED_STRING, String.class);
+        dynamicRealm.setVersion(43);
+        dynamicRealm.commitTransaction();
+        dynamicRealm.close();
+
+        try {
+            Realm realm = Realm.getInstance(config); // Opening at different schema version (42) should rebuild indexes
+            fail();
+        } catch (RealmMigrationNeededException ignored) {
+        }
+
+// FIXME: This is the intended behaviour
+//        RealmObjectSchema indexedFieldsSchema = realm.getSchema().get(className);
+//        try {
+//            assertTrue(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_INDEXED_STRING));
+//            assertFalse(indexedFieldsSchema.hasIndex(IndexedFields.FIELD_NON_INDEXED_STRING));
+//        } finally {
+//            realm.close();
+//        }
+    }
+
+    // Check that indexes are being added if other fields are being added as well
+    @Test
+    public void addingFields_rebuildIndexes() {
+
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/auth")
+                .schema(IndexedFields.class)
+                .schemaVersion(42)
+                .build();
+
+        // Setup initial Realm schema (with no indexes)
+        String className = IndexedFields.class.getSimpleName();
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);
+        RealmSchema schema = dynamicRealm.getSchema();
+        dynamicRealm.beginTransaction();
+        schema.create(className)
+                .addField(IndexedFields.FIELD_INDEXED_STRING, String.class); // No index
+                // .addField(IndexedFields.FIELD_NON_INDEXED_STRING, String.class); // Missing field
+        dynamicRealm.setVersion(41);
+        dynamicRealm.commitTransaction();
+        dynamicRealm.close();
+
+        // Opening at different schema version (42) should add field and rebuild indexes
+        Realm realm = Realm.getInstance(config);
+        try {
+            assertTrue(realm.getSchema().get(className).hasField(IndexedFields.FIELD_NON_INDEXED_STRING));
+            assertTrue(realm.getSchema().get(className).hasIndex(IndexedFields.FIELD_INDEXED_STRING));
+        } finally {
+            realm.close();
+        }
+    }
+
+    @Test
+    public void schemaVersionUpgradedWhenMigrating() {
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/auth")
+                .schemaVersion(42)
+                .build();
+
+        // Setup initial Realm schema (with missing fields)
+        String className = StringOnly.class.getSimpleName();
+        DynamicRealm dynamicRealm = DynamicRealm.getInstance(config);
+        RealmSchema schema = dynamicRealm.getSchema();
+        dynamicRealm.beginTransaction();
+        schema.create(className); // Create empty class
+        dynamicRealm.setVersion(1);
+        dynamicRealm.commitTransaction();
+        dynamicRealm.close();
+
+        // Open typed Realm, which will validate the schema
+        Realm realm = Realm.getInstance(config);
+        try {
+            assertEquals(42, realm.getVersion());
+        } finally {
+            realm.close();
+        }
+    }
 }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
index 4c6da841e1..1f28126e1e 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsObject.cpp
@@ -19,6 +19,7 @@
 #include <realm/row.hpp>
 #include <object_schema.hpp>
 #include <object.hpp>
+#include <shared_realm.hpp>
 #include <util/format.hpp>
 
 #include "util.hpp"
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index dfddfa7f7b..4330f13eed 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit dfddfa7f7bf564619e2257243c252ffad6d5c9c3
+Subproject commit 4330f13eedfad4f34bcecdca25f71fb949fbc4b2
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index c3af8bfb8b..24291c5741 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -501,21 +501,9 @@ private static void initializeSyncedRealm(Realm realm) {
                 schemaCreator.close();
                 schemaCreator = null;
 
-                // !!! FIXME: This appalling kludge is necessitated by current package structure/visiblity constraints.
-                // It absolutely breaks encapsulation and needs to be fixed!
-                if (realm.sharedRealm.requiresMigration(schema.getNativePtr())) {
-                    if (currentVersion >= newVersion) {
-                        throw new IllegalArgumentException(String.format(
-                                "The schema was changed but the schema version was not updated. " +
-                                        "The configured schema version (%d) must be greater than the version " +
-                                        " in the Realm file (%d) in order to update the schema.",
-                                newVersion, currentVersion));
-                    }
-                    realm.sharedRealm.updateSchema(schema.getNativePtr(), newVersion);
-                    // The OS currently does not handle setting the schema version. We have to do it manually.
-                    realm.setVersion(newVersion);
-                    commitChanges = true;
-                }
+                // Object Store handles all update logic
+                realm.sharedRealm.updateSchema(schema.getNativePtr(), newVersion);
+                commitChanges = true;
             }
 
             // Validate the schema in the file
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
index 19ce6ab69e..124bc62b1f 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
@@ -489,13 +489,11 @@ public Builder encryptionKey(byte[] key) {
         /**
          * Sets the schema version of the Realm.
          * <p>
-         * While synced Realms only support additive schema changes which can be applied without requiring a manual
-         * migration, the schema version must still be incremented as an indication to Realm that the change was
-         * intentional.
-         * <p>
-         * Failing to increment the schema version will cause Realm to throw a {@link io.realm.exceptions.RealmMigrationNeededException}
-         * when the Realm is opened and the changed schema will not be applied.
-         * <p>
+         * Synced Realms only support additive schema changes which can be applied without requiring a manual
+         * migration. The schema version will only be used as an indication to the underlying storage layer to remove
+         * or add indexes. These will be recalculated if the provided schema version differ from the version in the
+         * Realm file.
+         *
          * <b>WARNING:</b> There is no guarantee that the value inserted here is the same returned by {@link Realm#getVersion()}.
          * Due to the nature of synced Realms, the value can both be higher and lower.
          * <ul>
diff --git a/version.txt b/version.txt
index 14900cee60..105bb87d77 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-3.2.1-SNAPSHOT
\ No newline at end of file
+3.2.2-SNAPSHOT
\ No newline at end of file
