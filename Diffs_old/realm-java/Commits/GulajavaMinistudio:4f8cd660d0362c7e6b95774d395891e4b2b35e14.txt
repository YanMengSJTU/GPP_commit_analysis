diff --git a/dependencies.list b/dependencies.list
index f58dbb65cb..6a3c2d6332 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -5,4 +5,4 @@ REALM_SYNC_SHA256=9141177ccc92d8f9282625dace61eee5c3d971d2daca7593266e175b610a24
 
 # Object Server Release used by Integration tests. Installed using NPM.
 # Use `npm view realm-object-server versions` to get a list of available versions.
-REALM_OBJECT_SERVER_DE_VERSION=3.0.0-rc.1
+REALM_OBJECT_SERVER_DE_VERSION=3.0.0
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
index 509ffa8c99..df194d2f83 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
@@ -126,4 +126,5 @@ public void addSupportForObjectLevelPermissions(RealmConfiguration.Builder build
     public OsResults createSubscriptionAwareResults(OsSharedRealm sharedRealm, TableQuery query, SortDescriptor sortDescriptor, SortDescriptor distinctDescriptor, String name) {
         throw new IllegalStateException("Should only be called by builds supporting Sync");
     }
+
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
index cc45224295..775b89954d 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -88,10 +88,15 @@
      */
     public static String APP_ID = null;
 
-    // Thread pool used when doing network requests against the Realm Authentication Server.
-    // FIXME Set proper parameters
-    static final ThreadPoolExecutor NETWORK_POOL_EXECUTOR = new ThreadPoolExecutor(
-            10, 10, 0, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<Runnable>(100));
+    /**
+     * Thread pool used when doing network requests against the Realm Object Server.
+     * <p>
+     * This pool is only exposed for testing purposes and replacing it while the queue is not
+     * empty will result in undefined behaviour.
+     */
+    @SuppressFBWarnings("MS_SHOULD_BE_FINAL")
+    public static ThreadPoolExecutor NETWORK_POOL_EXECUTOR = new ThreadPoolExecutor(
+            10, 10, 0, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<>(100));
 
     private static final SyncSession.ErrorHandler SESSION_NO_OP_ERROR_HANDLER = new SyncSession.ErrorHandler() {
         @Override
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java
index a5686ae139..f23dc5022b 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java
@@ -19,6 +19,7 @@
 import java.util.concurrent.TimeUnit;
 
 import io.realm.ErrorCode;
+import io.realm.log.RealmLog;
 
 /**
  * Abstracts the concept of running an network task with incremental backoff. It will run forever until interrupted.
@@ -46,7 +47,9 @@ protected boolean isSuccess(T result) {
     protected boolean shouldAbortTask(T response) {
         // Only retry in case of IO exceptions, since that might be network timeouts etc.
         // All other errors indicate a bigger problem, so just stop the task.
-        if (!response.isValid()) {
+        if (Thread.interrupted()) {
+            return true;
+        } else if (!response.isValid()) {
             return response.getError().getErrorCode() != ErrorCode.IO_EXCEPTION;
         } else {
             return false;
@@ -62,13 +65,14 @@ protected boolean shouldAbortTask(T response) {
     @Override
     public void run() {
         int attempt = 0;
-        while (true) {
+        while (!Thread.interrupted()) {
             attempt++;
             long sleep = calculateExponentialDelay(attempt - 1, TimeUnit.MINUTES.toMillis(5));
             if (sleep > 0) {
                 try {
                     Thread.sleep(sleep);
                 } catch (InterruptedException e) {
+                    RealmLog.debug("Incremental backoff was interrupted.");
                     return; // Abort if interrupted
                 }
             }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
index 8b33e38896..6c73bcd8a2 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
@@ -21,6 +21,7 @@
 import io.realm.entities.AllTypes;
 import io.realm.entities.StringOnly;
 import io.realm.internal.OsRealmConfig;
+import io.realm.log.RealmLog;
 import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.objectserver.utils.UserFactory;
@@ -327,8 +328,8 @@ public void uploadChangesWhenRealmOutOfScope() throws InterruptedException {
         Realm realm = Realm.getInstance(syncConfiguration);
 
         realm.beginTransaction();
-        // upload 50MB
-        for (int i = 0; i < 25; i++) {
+        // upload 10MB
+        for (int i = 0; i < 5; i++) {
             realm.createObject(StringOnly.class).setChars(twoMBString);
         }
         realm.commitTransaction();
@@ -345,33 +346,29 @@ public void uploadChangesWhenRealmOutOfScope() throws InterruptedException {
             public void run() {
                 // using an admin user to open the Realm on different path on the device to monitor when all the uploads are done
                 SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
-                SyncCredentials credentialsAdmin = SyncCredentials.accessToken(SyncTestUtils.getRefreshToken(admin).value(), "custom-admin-user");
-                SyncUser adminUser = SyncUser.logIn(credentialsAdmin, Constants.AUTH_URL);
 
-                SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, syncConfiguration.getServerUrl().toString())
+                SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(admin, syncConfiguration.getServerUrl().toString())
                         .modules(new StringOnlyModule())
                         .build();
                 final Realm adminRealm = Realm.getInstance(adminConfig);
                 RealmResults<StringOnly> all = adminRealm.where(StringOnly.class).findAll();
                 strongRefs.add(all);
-                RealmChangeListener<RealmResults<StringOnly>> realmChangeListener = new RealmChangeListener<RealmResults<StringOnly>>() {
-                    @Override
-                    public void onChange(RealmResults<StringOnly> stringOnlies) {
-                        if (stringOnlies.size() == 25) {
-                            for (int i = 0; i < 25; i++) {
-                                assertEquals(1_000_000, stringOnlies.get(i).getChars().length());
-                            }
-                            adminRealm.close();
-                            testCompleted.countDown();
-                            handlerThread.quit();
+                OrderedRealmCollectionChangeListener<RealmResults<StringOnly>> realmChangeListener = (results, changeSet) -> {
+                    RealmLog.info("Size: " + results.size() + ", state: " + changeSet.getState().toString());
+                    if (results.size() == 5) {
+                        for (int i = 0; i < 5; i++) {
+                            assertEquals(1_000_000, results.get(i).getChars().length());
                         }
+                        adminRealm.close();
+                        testCompleted.countDown();
+                        handlerThread.quit();
                     }
                 };
                 all.addChangeListener(realmChangeListener);
             }
         });
 
-        TestHelper.awaitOrFail(testCompleted, 60);
+        TestHelper.awaitOrFail(testCompleted, TestHelper.STANDARD_WAIT_SECS);
         handlerThread.join();
 
         user.logOut();
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java
index 083ee4b359..24cab081af 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncedRealmIntegrationTests.java
@@ -324,7 +324,7 @@ public void waitForInitialRemoteData_readOnlyFalse_upgradeSchema() {
 
     @Test
     public void defaultRealm() throws InterruptedException {
-        SyncCredentials credentials = SyncCredentials.nickname("test", true);
+        SyncCredentials credentials = SyncCredentials.nickname("test", false);
         SyncUser user = SyncUser.logIn(credentials, Constants.AUTH_URL);
         SyncConfiguration config = SyncConfiguration.automatic();
         Realm realm = Realm.getInstance(config);
@@ -332,7 +332,7 @@ public void defaultRealm() throws InterruptedException {
         realm.refresh();
 
         try {
-            assertFalse(realm.isEmpty());
+            assertTrue(realm.isEmpty());
         } finally {
             realm.close();
             user.logOut();
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ObjectLevelPermissionIntegrationTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ObjectLevelPermissionIntegrationTests.java
index c3f7979701..29c9c89cbe 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ObjectLevelPermissionIntegrationTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ObjectLevelPermissionIntegrationTests.java
@@ -15,8 +15,6 @@
  */
 package io.realm.objectserver;
 
-import android.os.Handler;
-import android.os.HandlerThread;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.Test;
@@ -24,29 +22,21 @@
 
 import java.util.Arrays;
 import java.util.List;
-import java.util.concurrent.CountDownLatch;
 
-import io.realm.ObjectServerError;
-import io.realm.PermissionManager;
+import io.realm.IsolatedIntegrationTests;
 import io.realm.Realm;
 import io.realm.RealmResults;
-import io.realm.StandardIntegrationTest;
 import io.realm.SyncConfiguration;
 import io.realm.SyncManager;
 import io.realm.SyncUser;
-import io.realm.TestHelper;
 import io.realm.annotations.RealmModule;
 import io.realm.entities.AllJavaTypes;
-import io.realm.internal.android.AndroidCapabilities;
-import io.realm.internal.permissions.PermissionModule;
 import io.realm.internal.sync.permissions.ObjectPermissionsModule;
+import io.realm.log.RealmLog;
 import io.realm.objectserver.model.PermissionObject;
 import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.StringOnlyModule;
 import io.realm.objectserver.utils.UserFactory;
-import io.realm.permissions.AccessLevel;
-import io.realm.permissions.PermissionRequest;
-import io.realm.permissions.UserCondition;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.sync.permissions.ClassPrivileges;
 import io.realm.sync.permissions.ObjectPrivileges;
@@ -55,12 +45,16 @@
 import io.realm.sync.permissions.Role;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
 
+/**
+ * Integration tests for Object Level Permissions.
+ * Each test is run in isolation as we use the the global default Realm for each test.
+ * It is currently not possible to manually create a world readable Realm as
+ * {@link io.realm.PermissionManager} is unstable on CI.
+ */
 @RunWith(AndroidJUnit4.class)
-public class ObjectLevelPermissionIntegrationTests extends StandardIntegrationTest {
+public class ObjectLevelPermissionIntegrationTests extends IsolatedIntegrationTests {
 
     @RealmModule(classes = {AllJavaTypes.class})
     public static class ObjectLevelTestModule {
@@ -74,12 +68,9 @@
     @Test
     @RunTestInLooperThread()
     public void getPrivileges_serverDefaults() throws InterruptedException {
-        String realmUrl = Constants.GLOBAL_REALM + "_getPrivileges_serverDefaults";
         List schemaModule = Arrays.asList(new ObjectLevelTestModule());
-        createWorldReadableRealm(realmUrl, schemaModule);
-
         SyncUser user = UserFactory.createUniqueUser(Constants.AUTH_URL);
-        SyncConfiguration syncConfig = configurationFactory.createSyncConfigurationBuilder(user, realmUrl)
+        SyncConfiguration syncConfig = configurationFactory.createSyncConfigurationBuilder(user, Constants.DEFAULT_REALM)
                 .modules(schemaModule)
                 .partialRealm()
                 .build();
@@ -117,25 +108,16 @@ public void getPrivileges_serverDefaults() throws InterruptedException {
         looperThread.testComplete();
     }
 
-//    @Test
-//    @RunTestInLooperThread
-//    public void getRoles() {
-//        fail("FIXME");
-//        looperThread.testComplete();
-//    }
-
     // Restrict read/write permission, only the owner of the object can see/modify it
     @Test
     @RunTestInLooperThread()
     public void restrictAccessToOwner() throws InterruptedException {
-        String realmUrl = Constants.GLOBAL_REALM + "_restrictAccessToOwner";
         List schemaModules = Arrays.asList(new StringOnlyModule(), new OLPermissionModule(), new ObjectPermissionsModule());
-        createWorldReadableRealm(realmUrl, schemaModules);
 
         // connect with user1
         SyncUser user1 = UserFactory.createUniqueUser(Constants.AUTH_URL);
         SyncConfiguration user1SyncConfig = configurationFactory
-                .createSyncConfigurationBuilder(user1, realmUrl)
+                .createSyncConfigurationBuilder(user1, Constants.DEFAULT_REALM)
                 .modules(schemaModules)
                 .partialRealm()
                 .build();
@@ -166,7 +148,7 @@ public void restrictAccessToOwner() throws InterruptedException {
 
         // Connect with admin user and verify that user1 object is visible (non-partial Realm)
         SyncUser adminUser = UserFactory.createNicknameUser(Constants.AUTH_URL, "admin2", true);
-        SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, realmUrl)
+        SyncConfiguration adminConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, Constants.DEFAULT_REALM)
                 .modules(schemaModules)
                 .waitForInitialRemoteData()
                 .build();
@@ -182,7 +164,7 @@ public void restrictAccessToOwner() throws InterruptedException {
 
         // Connect with user 2 and verify that user1 object is not visible
         SyncUser user2 = UserFactory.createUniqueUser(Constants.AUTH_URL);
-        SyncConfiguration syncConfig2 = configurationFactory.createSyncConfigurationBuilder(user2, realmUrl)
+        SyncConfiguration syncConfig2 = configurationFactory.createSyncConfigurationBuilder(user2, Constants.DEFAULT_REALM)
                 .modules(schemaModules)
                 .partialRealm()
                 .build();
@@ -192,17 +174,10 @@ public void restrictAccessToOwner() throws InterruptedException {
         looperThread.keepStrongReference(allAsync);
         // new object should not be visible for user2 partial sync
         allAsync.addChangeListener((permissionObjects2, changeSet) -> {
-            switch (changeSet.getState()) {
-                case INITIAL:
-                    assertEquals(0, permissionObjects2.size());
-                    break;
-                case UPDATE:
-                    assertEquals(0, permissionObjects2.size());
-                    looperThread.testComplete();
-                    break;
-                case ERROR:
-                    fail("Unexpected error callback");
-                    break;
+            RealmLog.info("State: " + changeSet.getState().toString() + ", complete: " + changeSet.isCompleteResult());
+            if (changeSet.isCompleteResult()) {
+                assertEquals(0, permissionObjects2.size());
+                looperThread.testComplete();
             }
         });
     }
@@ -239,52 +214,4 @@ private void assertFullAccess(ObjectPrivileges privileges) {
         assertTrue(privileges.canSetPermissions());
     }
 
-    private void createWorldReadableRealm(String realmUrl, List modules) {
-        HandlerThread t = new HandlerThread("create-realm-thread");
-        t.start();
-        Handler handler = new Handler(t.getLooper());
-        CountDownLatch setupRealm = new CountDownLatch(1);
-        handler.post(() -> {
-            final boolean oldValue = AndroidCapabilities.EMULATE_MAIN_THREAD;
-            SyncUser adminUser = UserFactory.createNicknameUser(Constants.AUTH_URL, "admin", true);
-            SyncConfiguration syncConfig = configurationFactory.createSyncConfigurationBuilder(adminUser, realmUrl)
-                    .modules(modules)
-                    .addModule(new PermissionModule())
-                    .partialRealm()
-                    .waitForInitialRemoteData()
-                    .build();
-            Realm.getInstanceAsync(syncConfig, new Realm.Callback() {
-                @Override
-                public void onSuccess(Realm realm) {
-                    AndroidCapabilities.EMULATE_MAIN_THREAD = true;
-                    PermissionManager pm = adminUser.getPermissionManager();
-                    pm.applyPermissions(new PermissionRequest(UserCondition.noExistingPermissions(), realmUrl, AccessLevel.WRITE), new PermissionManager.ApplyPermissionsCallback() {
-                        @Override
-                        public void onSuccess() {
-                            handler.post(() -> {
-                                AndroidCapabilities.EMULATE_MAIN_THREAD = oldValue;
-                                pm.close();
-                                realm.close();
-                                adminUser.logOut();
-                                setupRealm.countDown();
-                            });
-                        }
-
-                        @Override
-                        public void onError(ObjectServerError error) {
-                            fail(error.toString());
-                        }
-                    });
-                }
-
-                @Override
-                public void onError(Throwable exception) {
-                    fail(exception.toString());
-                }
-            });
-        });
-        TestHelper.awaitOrFail(setupRealm);
-    }
-
 }
-
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
index 9414bb4fcd..d39ae9dd24 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/Constants.java
@@ -25,7 +25,7 @@
     public static final String USER_REALM_SECURE = "realms://" + HOST + ":9443/~/tests";
     public static final String SYNC_SERVER_URL = "realm://" + HOST + ":9080/~/tests";
     public static final String SYNC_SERVER_URL_2 = "realm://" + HOST + ":9080/~/tests2";
-
+    public static final String DEFAULT_REALM = "realm://" + HOST + ":9080/default";
     public static final String AUTH_SERVER_URL = "http://" + HOST + ":9080/";
     public static final String AUTH_URL = AUTH_SERVER_URL + "auth";
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
index ccfd1c2f85..88c4ab3ee5 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/UserFactory.java
@@ -22,6 +22,7 @@
 import java.util.Map;
 import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
 
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
@@ -145,18 +146,20 @@ public static void logoutAllUsers() {
         final HandlerThread ht = new HandlerThread("LoggingOutUsersThread");
         ht.start();
         Handler handler = new Handler(ht.getLooper());
-        handler.post(new Runnable() {
-            @Override
-            public void run() {
-                Map<String, SyncUser> users = SyncUser.all();
-                for (SyncUser user : users.values()) {
-                    user.logOut();
-                }
-                allUsersLoggedOut.countDown();
-
+        handler.post(() -> {
+            Map<String, SyncUser> users = SyncUser.all();
+            for (SyncUser user : users.values()) {
+                user.logOut();
             }
+            TestHelper.waitForNetworkThreadExecutorToFinish();
+            allUsersLoggedOut.countDown();
         });
         TestHelper.awaitOrFail(allUsersLoggedOut);
         ht.quit();
+        try {
+            ht.join(TimeUnit.SECONDS.toMillis(TestHelper.SHORT_WAIT_SECS));
+        } catch (InterruptedException e) {
+            throw new AssertionError("LoggingOutUsersThread failed to finish in time");
+        }
     }
 }
diff --git a/realm/realm-library/src/testUtils/java/io/realm/TestHelper.java b/realm/realm-library/src/testUtils/java/io/realm/TestHelper.java
index a765dc60c2..a9db3a9934 100644
--- a/realm/realm-library/src/testUtils/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/testUtils/java/io/realm/TestHelper.java
@@ -40,8 +40,10 @@
 import java.util.Locale;
 import java.util.Random;
 import java.util.UUID;
+import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
+import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 
@@ -59,6 +61,7 @@
 import io.realm.internal.OsObject;
 import io.realm.internal.OsSharedRealm;
 import io.realm.internal.Table;
+import io.realm.internal.Util;
 import io.realm.internal.async.RealmThreadPoolExecutor;
 import io.realm.log.LogLevel;
 import io.realm.log.RealmLogger;
@@ -1249,4 +1252,52 @@ public static void populateLinkedDataSet(Realm realm) {
         realm.commitTransaction();
     }
 
+    /**
+     * This method will kill all tasks then shutdown and replace the SyncManager.NETWORK_POOL_EXECUTOR
+     * with a fresh and empty instance. This should only be called when exiting tests.
+     *
+     * If the build does not support Sync, this method will do nothing
+     */
+    private static final Field networkPoolExecutorField;
+    static {
+        Class syncManager = null;
+        try {
+            syncManager = Class.forName("io.realm.SyncManager");
+        } catch (ClassNotFoundException e) {
+            // Ignore
+        }
+
+        try {
+            networkPoolExecutorField = (syncManager != null) ? syncManager.getDeclaredField("NETWORK_POOL_EXECUTOR") : null;
+        } catch (NoSuchFieldException e) {
+            throw new AssertionError("Could not find field: NETWORK_POOL_EXECUTOR\n" + Util.getStackTrace(e));
+        }
+    }
+
+    public static void waitForNetworkThreadExecutorToFinish() {
+        if (networkPoolExecutorField == null) {
+            return; // This build do not support Sync
+        }
+        try {
+            ThreadPoolExecutor pool = (ThreadPoolExecutor) networkPoolExecutorField.get(null);
+            // Since this method should only be called when exiting a test, it should be safe to just
+            // cancel all ongoing network requests and shut down the pool as soon as possible.
+            // When shut down we replace it with a new, now empty, pool that can be used by future
+            // tests
+            pool.shutdownNow();
+            try {
+                pool.awaitTermination(5, TimeUnit.SECONDS);
+            } catch (InterruptedException e) {
+                throw new AssertionError("NetworkPoolExecutor was not shut down in time:\n" + Util.getStackTrace(e));
+            } finally {
+                // Replace the executor, since the old one is now dead.
+                // The setup of this should mirror what is done in SyncManager.
+                networkPoolExecutorField.set(null, new ThreadPoolExecutor(
+                        10, 10, 0, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<Runnable>(100)));
+            }
+        } catch (IllegalAccessException e) {
+            throw new AssertionError(Util.getStackTrace(e));
+        }
+    }
+
 }
diff --git a/realm/realm-library/src/testUtils/java/io/realm/rule/RunInLooperThread.java b/realm/realm-library/src/testUtils/java/io/realm/rule/RunInLooperThread.java
index 31d73961f2..baef25a0f1 100644
--- a/realm/realm-library/src/testUtils/java/io/realm/rule/RunInLooperThread.java
+++ b/realm/realm-library/src/testUtils/java/io/realm/rule/RunInLooperThread.java
@@ -40,6 +40,7 @@
 import io.realm.Realm;
 import io.realm.RealmConfiguration;
 import io.realm.TestHelper;
+import io.realm.internal.ObjectServerFacade;
 import io.realm.internal.android.AndroidCapabilities;
 
 
@@ -285,6 +286,7 @@ protected void after() {
         // Wait for all async tasks to have completed to ensure a successful deleteRealm call.
         // If it times out, it will throw.
         TestHelper.waitRealmThreadExecutorFinish();
+        TestHelper.waitForNetworkThreadExecutorToFinish();
         AndroidCapabilities.EMULATE_MAIN_THREAD = false;
         super.after();
 
